/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-polyfill/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/babel-polyfill/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

__webpack_require__(/*! core-js/shim */ "./node_modules/core-js/shim.js");

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/babel-polyfill/node_modules/regenerator-runtime/runtime.js");

__webpack_require__(/*! core-js/fn/regexp/escape */ "./node_modules/core-js/fn/regexp/escape.js");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}

global._babelPolyfill = true;
var DEFINE_PROPERTY = "defineProperty";

function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);
"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/regenerator-runtime/runtime.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/regenerator-runtime/runtime.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */
!function (global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;

  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    } // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.


    return;
  } // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.


  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  runtime.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  runtime.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function () {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function (record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
}( // Among the various tricks for obtaining a reference to the global
// object, this seems to be the most reliable technique that does not
// use indirect eval (which violates Content Security Policy).
typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/core-js/fn/regexp/escape.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/fn/regexp/escape.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/core.regexp.escape */ "./node_modules/core-js/modules/core.regexp.escape.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").RegExp.escape;

/***/ }),

/***/ "./node_modules/core-js/modules/_a-function.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_a-function.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_a-number-value.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_a-number-value.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_add-to-unscopables.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_add-to-unscopables.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('unscopables');

var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(ArrayProto, UNSCOPABLES, {});

module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_advance-string-index.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_advance-string-index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(true); // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex


module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_an-instance.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_an-instance.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
    throw TypeError(name + ': incorrect invocation!');
  }

  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_an-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_an-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-copy-within.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-copy-within.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)


var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = [].copyWithin || function copyWithin(target
/* = 0 */
, start
/* = 0, end = @length */
) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;

  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }

  while (count-- > 0) {
    if (from in O) O[to] = O[from];else delete O[to];
    to += inc;
    from += inc;
  }

  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-fill.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_array-fill.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = function fill(value
/* , start = 0, end = @length */
) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

  while (endPos > index) O[index++] = value;

  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-from-iterable.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-from-iterable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-includes.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_array-includes.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-methods.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_array-methods.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var asc = __webpack_require__(/*! ./_array-species-create */ "./node_modules/core-js/modules/_array-species-create.js");

module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;

    for (; length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);

      if (TYPE) {
        if (IS_MAP) result[index] = res; // map
        else if (res) switch (TYPE) {
            case 3:
              return true;
            // some

            case 5:
              return val;
            // find

            case 6:
              return index;
            // findIndex

            case 2:
              result.push(val);
            // filter
          } else if (IS_EVERY) return false; // every
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-reduce.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_array-reduce.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }

    index += i;

    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }

  for (; isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }

  return memo;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-species-constructor.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-species-constructor.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (original) {
  var C;

  if (isArray(original)) {
    C = original.constructor; // cross-realm fallback

    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;

    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }

  return C === undefined ? Array : C;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-species-create.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-species-create.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ "./node_modules/core-js/modules/_array-species-constructor.js");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_bind.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_bind.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/core-js/modules/_invoke.js");

var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']'; // eslint-disable-next-line no-new-func


    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  }

  return factories[len](F, args);
};

module.exports = Function.bind || function bind(that
/* , ...args */
) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);

  var bound = function ()
  /* args... */
  {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };

  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_classof.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_classof.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag'); // ES3 wrong here


var ARG = cof(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) {
    /* empty */
  }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
  : ARG ? cof(O) // ES3 arguments fallback
  : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_cof.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_cof.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_collection-strong.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_collection-strong.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

var $iterDefine = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/modules/_iter-define.js");

var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/modules/_iter-step.js");

var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var fastKey = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").fastKey;

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index]; // frozen object case

  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type

      that._i = create(null); // index

      that._f = undefined; // first entry

      that._l = undefined; // last entry

      that[SIZE] = 0; // size

      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }

        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);

        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        }

        return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn
      /* , that = undefined */
      ) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;

        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this); // revert to the last existing entry

          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index; // change existing entry

    if (entry) {
      entry.v = value; // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true),
        // <- index
        k: key,
        // <- key
        v: value,
        // <- value
        p: prev = that._l,
        // <- previous entry
        n: undefined,
        // <- next entry
        r: false // <- removed

      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++; // add to index

      if (index !== 'F') that._i[index] = entry;
    }

    return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target

      this._k = kind; // kind

      this._l = undefined; // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l; // revert to the last existing entry

      while (entry && entry.r) entry = entry.p; // get next entry


      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      } // return step by kind


      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

    setSpecies(NAME);
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_collection-to-json.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_collection-to-json.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

var from = __webpack_require__(/*! ./_array-from-iterable */ "./node_modules/core-js/modules/_array-from-iterable.js");

module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_collection-weak.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_collection-weak.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

var getWeak = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").getWeak;

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js");

var $has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0; // fallback for uncaught frozen keys

var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function () {
  this.a = [];
};

var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};
module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type

      that._i = id++; // collection id

      that._l = undefined; // leak store for uncaught frozen objects

      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

/***/ }),

/***/ "./node_modules/core-js/modules/_collection.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_collection.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/core-js/modules/_inherit-if-required.js");

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};

  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY, KEY == 'delete' ? function (a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'has' ? function has(a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'get' ? function get(a) {
      return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'add' ? function add(a) {
      fn.call(this, a === 0 ? 0 : a);
      return this;
    } : function set(a, b) {
      fn.call(this, a === 0 ? 0 : a, b);
      return this;
    });
  };

  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C(); // early implementations not supports chaining

    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false

    var THROWS_ON_PRIMITIVES = fails(function () {
      instance.has(1);
    }); // most early implementations doesn't supports iterables, most modern - not close it correctly

    var ACCEPT_ITERABLES = $iterDetect(function (iter) {
      new C(iter);
    }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same

    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;

      while (index--) $instance[ADDER](index, index);

      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);
  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);
  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
  return C;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_core.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_core.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = {
  version: '2.6.11'
};
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/core-js/modules/_create-property.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_create-property.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_ctx.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_ctx.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_date-to-iso-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_date-to-iso-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
}; // PhantomJS / old WebKit has a broken implementations


module.exports = fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
}) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

/***/ }),

/***/ "./node_modules/core-js/modules/_date-to-primitive.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_date-to-primitive.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_defined.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_defined.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_descriptors.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_descriptors.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/core-js/modules/_dom-create.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_dom-create.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document; // typeof document.createElement is 'object' in old IE


var is = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),

/***/ "./node_modules/core-js/modules/_enum-bug-keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_enum-bug-keys.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

/***/ }),

/***/ "./node_modules/core-js/modules/_enum-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_enum-keys.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");

module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;

  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;

    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  }

  return result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_export.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_export.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;

  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

    out = (own ? target : source)[key]; // bind timers to global for call from export context

    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global

    if (target) redefine(target, key, out, type & $export.U); // export

    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};

global.core = core; // type bitmap

$export.F = 1; // forced

$export.G = 2; // global

$export.S = 4; // static

$export.P = 8; // proto

$export.B = 16; // bind

$export.W = 32; // wrap

$export.U = 64; // safe

$export.R = 128; // real proto method for `library`

module.exports = $export;

/***/ }),

/***/ "./node_modules/core-js/modules/_fails-is-regexp.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_fails-is-regexp.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match');

module.exports = function (KEY) {
  var re = /./;

  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) {
      /* empty */
    }
  }

  return true;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_fails.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_fails.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_fix-re-wks.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_fix-re-wks.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./es6.regexp.exec */ "./node_modules/core-js/modules/es6.regexp.exec.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");

var SPECIES = wks('species');
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;

  re.exec = function () {
    var result = [];
    result.groups = {
      a: '7'
    };
    return result;
  };

  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;

  re.exec = function () {
    return originalExec.apply(this, arguments);
  };

  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
}();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};

    O[SYMBOL] = function () {
      return 7;
    };

    return ''[KEY](O) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    re.exec = function () {
      execCalled = true;
      return null;
    };

    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};

      re.constructor[SPECIES] = function () {
        return re;
      };
    }

    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return {
            done: true,
            value: nativeRegExpMethod.call(regexp, str, arg2)
          };
        }

        return {
          done: true,
          value: nativeMethod.call(str, regexp, arg2)
        };
      }

      return {
        done: false
      };
    });
    var strfn = fns[0];
    var rxfn = fns[1];
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {
      return rxfn.call(string, this, arg);
    } // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {
      return rxfn.call(string, this);
    });
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_flags.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_flags.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 21.2.5.3 get RegExp.prototype.flags

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_flatten-into-array.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_flatten-into-array.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray

var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var IS_CONCAT_SPREADABLE = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
      spreadable = false;

      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }

    sourceIndex++;
  }

  return targetIndex;
}

module.exports = flattenIntoArray;

/***/ }),

/***/ "./node_modules/core-js/modules/_for-of.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_for-of.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/modules/_iter-call.js");

var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");

var BREAK = {};
var RETURN = {};

var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () {
    return iterable;
  } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator

  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};

exports.BREAK = BREAK;
exports.RETURN = RETURN;

/***/ }),

/***/ "./node_modules/core-js/modules/_function-to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_function-to-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('native-function-to-string', Function.toString);

/***/ }),

/***/ "./node_modules/core-js/modules/_global.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/core-js/modules/_has.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_has.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_hide.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_hide.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_html.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_html.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document;

module.exports = document && document.documentElement;

/***/ }),

/***/ "./node_modules/core-js/modules/_ie8-dom-define.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_ie8-dom-define.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js")('div'), 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/core-js/modules/_inherit-if-required.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_inherit-if-required.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var setPrototypeOf = __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/modules/_set-proto.js").set;

module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;

  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  }

  return that;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_invoke.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_invoke.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;

  switch (args.length) {
    case 0:
      return un ? fn() : fn.call(that);

    case 1:
      return un ? fn(args[0]) : fn.call(that, args[0]);

    case 2:
      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);

    case 3:
      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);

    case 4:
      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
  }

  return fn.apply(that, args);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iobject.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_iobject.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js"); // eslint-disable-next-line no-prototype-builtins


module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-array-iter.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_is-array-iter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');

var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-array.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_is-array.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-integer.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-integer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var floor = Math.floor;

module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-regexp.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-regexp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

var MATCH = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match');

module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-call.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-call.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-create.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-create.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

__webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator'), function () {
  return this;
});

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, {
    next: descriptor(1, next)
  });
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-define.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-define.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/modules/_iter-create.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');

var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () {
  return this;
};

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);

  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];

    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };

      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }

    return function entries() {
      return new Constructor(this, kind);
    };
  };

  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype; // Fix native

  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));

    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  } // fix Array#{values, @@iterator}.name in V8 / FF


  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;

    $default = function values() {
      return $native.call(this);
    };
  } // Define iterator


  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  } // Plug for library


  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;

  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }

  return methods;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-detect.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-detect.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');

var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();

  riter['return'] = function () {
    SAFE_CLOSING = true;
  }; // eslint-disable-next-line no-throw-literal


  Array.from(riter, function () {
    throw 2;
  });
} catch (e) {
  /* empty */
}

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;

  try {
    var arr = [7];
    var iter = arr[ITERATOR]();

    iter.next = function () {
      return {
        done: safe = true
      };
    };

    arr[ITERATOR] = function () {
      return iter;
    };

    exec(arr);
  } catch (e) {
    /* empty */
  }

  return safe;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-step.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-step.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return {
    value: value,
    done: !!done
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iterators.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iterators.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),

/***/ "./node_modules/core-js/modules/_library.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_library.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = false;

/***/ }),

/***/ "./node_modules/core-js/modules/_math-expm1.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_math-expm1.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = !$expm1 // Old FF bug
|| $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 // Tor Browser bug
|| $expm1(-2e-17) != -2e-17 ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

/***/ }),

/***/ "./node_modules/core-js/modules/_math-fround.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_math-fround.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(/*! ./_math-sign */ "./node_modules/core-js/modules/_math-sign.js");

var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs); // eslint-disable-next-line no-self-compare

  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_math-log1p.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_math-log1p.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_math-scale.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_math-scale.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (arguments.length === 0 // eslint-disable-next-line no-self-compare
  || x != x // eslint-disable-next-line no-self-compare
  || inLow != inLow // eslint-disable-next-line no-self-compare
  || inHigh != inHigh // eslint-disable-next-line no-self-compare
  || outLow != outLow // eslint-disable-next-line no-self-compare
  || outHigh != outHigh) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_math-sign.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_math-sign.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_meta.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_meta.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js")('meta');

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var setDesc = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var FREEZE = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});

var setMeta = function (it) {
  setDesc(it, META, {
    value: {
      i: 'O' + ++id,
      // object ID
      w: {} // weak collections IDs

    }
  });
};

var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F'; // not necessary to add metadata

    if (!create) return 'E'; // add missing metadata

    setMeta(it); // return object ID
  }

  return it[META].i;
};

var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true; // not necessary to add metadata

    if (!create) return false; // add missing metadata

    setMeta(it); // return hash weak collections IDs
  }

  return it[META].w;
}; // add metadata on freeze-family methods calling


var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};

var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

/***/ }),

/***/ "./node_modules/core-js/modules/_metadata.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_metadata.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Map = __webpack_require__(/*! ./es6.map */ "./node_modules/core-js/modules/es6.map.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('metadata');

var store = shared.store || (shared.store = new (__webpack_require__(/*! ./es6.weak-map */ "./node_modules/core-js/modules/es6.weak-map.js"))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);

  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }

  var keyMetadata = targetMetadata.get(targetKey);

  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  }

  return keyMetadata;
};

var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};

var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};

var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};

var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) {
    keys.push(key);
  });
  return keys;
};

var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};

var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

/***/ }),

/***/ "./node_modules/core-js/modules/_microtask.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_microtask.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var macrotask = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js").set;

var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();

    while (head) {
      fn = head.fn;
      head = head.next;

      try {
        fn();
      } catch (e) {
        if (head) notify();else last = undefined;
        throw e;
      }
    }

    last = undefined;
    if (parent) parent.enter();
  }; // Node.js


  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    }; // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339

  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, {
      characterData: true
    }); // eslint-disable-line no-new

    notify = function () {
      node.data = toggle = !toggle;
    }; // environments with maybe non-completely correct, but existent Promise

  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);

    notify = function () {
      promise.then(flush);
    }; // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout

  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = {
      fn: fn,
      next: undefined
    };
    if (last) last.next = task;

    if (!head) {
      head = task;
      notify();
    }

    last = task;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_new-promise-capability.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/_new-promise-capability.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 25.4.1.5 NewPromiseCapability(C)

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-assign.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-assign.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 19.1.2.1 Object.assign(target, source, ...)

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");

var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

module.exports = !$assign || __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  var A = {};
  var B = {}; // eslint-disable-next-line no-undef

  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;

  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  }

  return T;
} : $assign;

/***/ }),

/***/ "./node_modules/core-js/modules/_object-create.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-create.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/modules/_object-dps.js");

var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js");

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

var Empty = function () {
  /* empty */
};

var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js")('iframe');

  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';

  __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js").appendChild(iframe);

  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);

  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;

  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];

  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO] = O;
  } else result = createDict();

  return Properties === undefined ? result : dPs(result, Properties);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-dp.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/modules/_ie8-dom-define.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var dP = Object.defineProperty;
exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-dps.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dps.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;

  while (length > i) dP.f(O, P = keys[i++], Properties[P]);

  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-forced-pam.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_object-forced-pam.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Forced replacement prototype accessors methods

module.exports = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js") || !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  var K = Math.random(); // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call

  __defineSetter__.call(null, K, function () {
    /* empty */
  });

  delete __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js")[K];
});

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopd.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopd.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/modules/_ie8-dom-define.js");

var gOPD = Object.getOwnPropertyDescriptor;
exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) {
    /* empty */
  }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopn-ext.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopn-ext.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

var toString = {}.toString;
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopn.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopn.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/modules/_object-keys-internal.js");

var hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gops.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gops.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gpo.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gpo.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];

  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }

  return O instanceof Object ? ObjectProto : null;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys-internal.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys-internal.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(false);

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key); // Don't enum bug & hidden keys


  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }

  return result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/modules/_object-keys-internal.js");

var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-pie.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-pie.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),

/***/ "./node_modules/core-js/modules/_object-sap.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-sap.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () {
    fn(1);
  }), 'Object', exp);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-to-array.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-to-array.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var isEnum = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js").f;

module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;

    while (length > i) {
      key = keys[i++];

      if (!DESCRIPTORS || isEnum.call(O, key)) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }

    return result;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_own-keys.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_own-keys.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var Reflect = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Reflect;

module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_parse-float.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_parse-float.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").parseFloat;

var $trim = __webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js").trim;

module.exports = 1 / $parseFloat(__webpack_require__(/*! ./_string-ws */ "./node_modules/core-js/modules/_string-ws.js") + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

/***/ }),

/***/ "./node_modules/core-js/modules/_parse-int.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_parse-int.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").parseInt;

var $trim = __webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js").trim;

var ws = __webpack_require__(/*! ./_string-ws */ "./node_modules/core-js/modules/_string-ws.js");

var hex = /^[-+]?0[xX]/;
module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
} : $parseInt;

/***/ }),

/***/ "./node_modules/core-js/modules/_perform.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_perform.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return {
      e: false,
      v: exec()
    };
  } catch (e) {
    return {
      e: true,
      v: e
    };
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_promise-resolve.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_promise-resolve.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/modules/_new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_property-desc.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_property-desc.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_redefine-all.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_redefine-all.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);

  return target;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_redefine.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_redefine.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var SRC = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js")('src');

var $toString = __webpack_require__(/*! ./_function-to-string */ "./node_modules/core-js/modules/_function-to-string.js");

var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

/***/ }),

/***/ "./node_modules/core-js/modules/_regexp-exec-abstract.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_regexp-exec-abstract.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec

module.exports = function (R, S) {
  var exec = R.exec;

  if (typeof exec === 'function') {
    var result = exec.call(R, S);

    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }

    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }

  return builtinExec.call(R, S);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_regexp-exec.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_regexp-exec.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpFlags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");

var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.

var nativeReplace = String.prototype.replace;
var patchedExec = nativeExec;
var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
}(); // nonparticipating capturing group, copied from es5-shim's String#split patch.


var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }

    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }

    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;

/***/ }),

/***/ "./node_modules/core-js/modules/_replacer.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_replacer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_same-value.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_same-value.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-collection-from.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_set-collection-from.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-setmap-offrom/

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, {
    from: function from(source
    /* , mapFn, thisArg */
    ) {
      var mapFn = arguments[1];
      var mapping, A, n, cb;
      aFunction(this);
      mapping = mapFn !== undefined;
      if (mapping) aFunction(mapFn);
      if (source == undefined) return new this();
      A = [];

      if (mapping) {
        n = 0;
        cb = ctx(mapFn, arguments[2], 2);
        forOf(source, false, function (nextItem) {
          A.push(cb(nextItem, n++));
        });
      } else {
        forOf(source, false, A.push, A);
      }

      return new this(A);
    }
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-collection-of.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_set-collection-of.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-setmap-offrom/

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, {
    of: function of() {
      var length = arguments.length;
      var A = new Array(length);

      while (length--) A[length] = arguments[length];

      return new this(A);
    }
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-proto.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_set-proto.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.

/* eslint-disable no-proto */
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};

module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
    try {
      set = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js")(Function.call, __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f(Object.prototype, '__proto__').set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }

    return function setPrototypeOf(O, proto) {
      check(O, proto);
      if (buggy) O.__proto__ = proto;else set(O, proto);
      return O;
    };
  }({}, false) : undefined),
  check: check
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-species.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_set-species.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () {
      return this;
    }
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-to-string-tag.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_set-to-string-tag.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
    configurable: true,
    value: tag
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_shared-key.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_shared-key.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('keys');

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_shared.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_shared.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js") ? 'pure' : 'global',
  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
});

/***/ }),

/***/ "./node_modules/core-js/modules/_species-constructor.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_species-constructor.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_strict-method.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_strict-method.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () {
      /* empty */
    }, 1) : method.call(null);
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-at.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-at.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js"); // true  -> String#at
// false -> String#codePointAt


module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-context.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_string-context.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-html.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_string-html.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value)

var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};

module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-pad.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-pad.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var repeat = __webpack_require__(/*! ./_string-repeat */ "./node_modules/core-js/modules/_string-repeat.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-repeat.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_string-repeat.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");

  for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;

  return res;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-trim.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_string-trim.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var spaces = __webpack_require__(/*! ./_string-ws */ "./node_modules/core-js/modules/_string-ws.js");

var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
}; // 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim


var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

/***/ }),

/***/ "./node_modules/core-js/modules/_string-ws.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-ws.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ }),

/***/ "./node_modules/core-js/modules/_task.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_task.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/core-js/modules/_invoke.js");

var html = __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js");

var cel = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function () {
  var id = +this; // eslint-disable-next-line no-prototype-builtins

  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var listener = function (event) {
  run.call(event.data);
}; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;

    while (arguments.length > i) args.push(arguments[i++]);

    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };

    defer(counter);
    return counter;
  };

  clearTask = function clearImmediate(id) {
    delete queue[id];
  }; // Node.js 0.8-


  if (__webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js")(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    }; // Sphere (JS game engine) Dispatch API

  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    }; // Browsers with MessageChannel, includes WebWorkers

  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };

    global.addEventListener('message', listener, false); // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    }; // Rest old browsers

  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}

module.exports = {
  set: setTask,
  clear: clearTask
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-absolute-index.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_to-absolute-index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var max = Math.max;
var min = Math.min;

module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-index.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_to-index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-integer.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-integer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;

module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-iobject.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-iobject.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function (it) {
  return IObject(defined(it));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-length.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-length.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var min = Math.min;

module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function (it) {
  return Object(defined(it));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-primitive.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_to-primitive.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js"); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),

/***/ "./node_modules/core-js/modules/_typed-array.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_typed-array.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js")) {
  var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

  var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

  var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

  var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

  var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");

  var $buffer = __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js");

  var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

  var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

  var propertyDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

  var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

  var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

  var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

  var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

  var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/core-js/modules/_to-index.js");

  var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

  var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

  var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

  var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

  var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

  var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");

  var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

  var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

  var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

  var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");

  var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

  var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

  var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js");

  var createArrayIncludes = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js");

  var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

  var ArrayIterators = __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");

  var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

  var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js");

  var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js");

  var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js");

  var arrayCopyWithin = __webpack_require__(/*! ./_array-copy-within */ "./node_modules/core-js/modules/_array-copy-within.js");

  var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

  var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';
  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });
  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });
  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    }

    return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);

    while (length > index) result[index] = list[index++];

    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, {
      get: function () {
        return this._d[internal];
      }
    });
  };

  var $from = function from(source
  /* , mapfn, thisArg */
  ) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;

    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      }

      O = values;
    }

    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);

    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }

    return result;
  };

  var $of = function of()
  /* ...items */
  {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);

    while (length > index) result[index] = arguments[index++];

    return result;
  }; // iOS Safari 6.x fails here


  var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
    arrayToLocaleString.call(new Uint8Array(1));
  });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start
    /* , end */
    ) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn
    /* , thisArg */
    ) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value
    /* , start, end */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn
    /* , thisArg */
    ) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate
    /* , thisArg */
    ) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate
    /* , thisArg */
    ) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn
    /* , thisArg */
    ) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement
    /* , fromIndex */
    ) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement
    /* , fromIndex */
    ) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) {
      // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement
    /* , fromIndex */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn
    /* , thisArg */
    ) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn
    /* , initialValue */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn
    /* , initialValue */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;

      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      }

      return that;
    },
    some: function some(callbackfn
    /* , thisArg */
    ) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike
  /* , offset */
  ) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);

    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target) && target[TYPED_ARRAY] && typeof key != 'symbol' && key in target && String(+key) == String(key);
  };

  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
  };

  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') // TODO: add validation descriptor w/o calling accessors
    && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
      target[key] = desc.value;
      return target;
    }

    return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () {
    arrayToString.call({});
  })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () {
      /* noop */
    },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () {
      return this[TYPED_ARRAY];
    }
  }); // eslint-disable-next-line max-statements

  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];

    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };

    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };

    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;

        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;

          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }

          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }

        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });

        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new

      new TypedArray(null); // eslint-disable-line no-new

      new TypedArray(1.5); // eslint-disable-line no-new

      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass; // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645

        if (!isObject(data)) return new Base(toIndex(data));

        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
        }

        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }

    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () {
          return NAME;
        }
      });
    }

    O[NAME] = TypedArray;
    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });
    $export($export.S + $export.F * fails(function () {
      Base.of.call(TypedArray, 1);
    }), NAME, {
      from: $from,
      of: $of
    });
    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
    $export($export.P, NAME, proto);
    setSpecies(NAME);
    $export($export.P + $export.F * FORCED_SET, NAME, {
      set: $set
    });
    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, {
      slice: $slice
    });
    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, {
      toLocaleString: $toLocaleString
    });
    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () {
  /* empty */
};

/***/ }),

/***/ "./node_modules/core-js/modules/_typed-buffer.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_typed-buffer.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/core-js/modules/_to-index.js");

var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError; // eslint-disable-next-line no-shadow-restricted-names

var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET; // IEEE754 conversions based on https://github.com/feross/ieee754

function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value); // eslint-disable-next-line no-self-compare

  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);

    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);

  buffer[--i] |= s * 128;
  return buffer;
}

function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;

  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}

function packI8(it) {
  return [it & 0xff];
}

function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}

function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}

function packF64(it) {
  return packIEEE754(it, 52, 8);
}

function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, {
    get: function () {
      return this[internal];
    }
  });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}

function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);

  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset
    /* , littleEndian */
    ) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset
    /* , littleEndian */
    ) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new

    new $ArrayBuffer(1.5); // eslint-disable-line no-new

    new $ArrayBuffer(NaN); // eslint-disable-line no-new

    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };

    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];

    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }

    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  } // iOS Safari 7.x bug


  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

/***/ }),

/***/ "./node_modules/core-js/modules/_typed.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_typed.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;
var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

/***/ }),

/***/ "./node_modules/core-js/modules/_uid.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_uid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();

module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_user-agent.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_user-agent.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var navigator = global.navigator;
module.exports = navigator && navigator.userAgent || '';

/***/ }),

/***/ "./node_modules/core-js/modules/_validate-collection.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_validate-collection.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_wks-define.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_wks-define.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/modules/_wks-ext.js");

var defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, {
    value: wksExt.f(name)
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_wks-ext.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_wks-ext.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

/***/ }),

/***/ "./node_modules/core-js/modules/_wks.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_wks.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('wks');

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

var Symbol = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Symbol;

var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),

/***/ "./node_modules/core-js/modules/core.get-iterator-method.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/core.get-iterator-method.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

module.exports = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

/***/ }),

/***/ "./node_modules/core-js/modules/core.regexp.escape.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/core.regexp.escape.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/benjamingr/RexExp.escape
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $re = __webpack_require__(/*! ./_replacer */ "./node_modules/core-js/modules/_replacer.js")(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', {
  escape: function escape(it) {
    return $re(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.copy-within.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.copy-within.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', {
  copyWithin: __webpack_require__(/*! ./_array-copy-within */ "./node_modules/core-js/modules/_array-copy-within.js")
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('copyWithin');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.every.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.every.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $every = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(4);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn
  /* , thisArg */
  ) {
    return $every(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.fill.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.fill.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', {
  fill: __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js")
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('fill');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.filter.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.filter.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $filter = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(2);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn
  /* , thisArg */
  ) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.find-index.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.find-index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $find = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(6);

var KEY = 'findIndex';
var forced = true; // Shouldn't skip holes

if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")(KEY);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.find.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.find.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $find = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(5);

var KEY = 'find';
var forced = true; // Shouldn't skip holes

if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")(KEY);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.for-each.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.for-each.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $forEach = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(0);

var STRICT = __webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn
  /* , thisArg */
  ) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.from.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.from.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/modules/_iter-call.js");

var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/modules/_create-property.js");

var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");

$export($export.S + $export.F * !__webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  Array.from(iter);
}), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike
  /* , mapfn = undefined, thisArg = undefined */
  ) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);

      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }

    result.length = index;
    return result;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.index-of.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.index-of.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $indexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(false);

var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement
  /* , fromIndex = 0 */
  ) {
    return NEGATIVE_ZERO // convert -0 to +0
    ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.is-array.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.is-array.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Array', {
  isArray: __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js");

var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/modules/_iter-step.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js"); // 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()


module.exports = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target

  this._i = 0; // next index

  this._k = kind; // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;

  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }

  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

Iterators.Arguments = Iterators.Array;
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.join.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.join.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.13 Array.prototype.join(separator)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var arrayJoin = [].join; // fallback for not array-like strings

$export($export.P + $export.F * (__webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js") != Object || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.last-index-of.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.last-index-of.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement
  /* , fromIndex = @[*-1] */
  ) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;

    for (; index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;

    return -1;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.map.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.map.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $map = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(1);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn
  /* , thisArg */
  ) {
    return $map(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.of.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.of.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/modules/_create-property.js"); // WebKit Array.of isn't generic


$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  function F() {
    /* empty */
  }

  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of()
  /* ...args */
  {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);

    while (aLen > index) createProperty(result, index, arguments[index++]);

    result.length = aLen;
    return result;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.reduce-right.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.reduce-right.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $reduce = __webpack_require__(/*! ./_array-reduce */ "./node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.reduce.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.reduce.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $reduce = __webpack_require__(/*! ./_array-reduce */ "./node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.slice.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.slice.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var html = __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js");

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var arraySlice = [].slice; // fallback for not array-like ES3 strings and DOM objects

$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;

    for (; i < size; i++) cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];

    return cloned;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.some.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.some.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $some = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(3);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn
  /* , thisArg */
  ) {
    return $some(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.sort.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.sort.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var $sort = [].sort;
var test = [1, 2, 3];
$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null); // Old WebKit
}) || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.species.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.species.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")('Array');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.now.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.now.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Date', {
  now: function () {
    return new Date().getTime();
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-iso-string.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-iso-string.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toISOString = __webpack_require__(/*! ./_date-to-iso-string */ "./node_modules/core-js/modules/_date-to-iso-string.js"); // PhantomJS / old WebKit has a broken implementations


$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-json.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-json.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
    toISOString: function () {
      return 1;
    }
  }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-primitive.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-primitive.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toPrimitive');

var proto = Date.prototype;
if (!(TO_PRIMITIVE in proto)) __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(proto, TO_PRIMITIVE, __webpack_require__(/*! ./_date-to-primitive */ "./node_modules/core-js/modules/_date-to-primitive.js"));

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-string.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;

if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this); // eslint-disable-next-line no-self-compare

    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.bind.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.function.bind.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'Function', {
  bind: __webpack_require__(/*! ./_bind */ "./node_modules/core-js/modules/_bind.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.has-instance.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.function.has-instance.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var HAS_INSTANCE = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('hasInstance');

var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype[@@hasInstance](V)

if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f(FunctionProto, HAS_INSTANCE, {
  value: function (O) {
    if (typeof this != 'function' || !isObject(O)) return false;
    if (!isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:

    while (O = getPrototypeOf(O)) if (this.prototype === O) return true;

    return false;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.name.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.function.name.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name'; // 19.2.4.2 name

NAME in FProto || __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.map.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/es6.map.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(/*! ./_collection-strong */ "./node_modules/core-js/modules/_collection-strong.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var MAP = 'Map'; // 23.1 Map Objects

module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(MAP, function (get) {
  return function Map() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.acosh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.acosh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var log1p = __webpack_require__(/*! ./_math-log1p */ "./node_modules/core-js/modules/_math-log1p.js");

var sqrt = Math.sqrt;
var $acosh = Math.acosh;
$export($export.S + $export.F * !($acosh // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
&& Math.floor($acosh(Number.MAX_VALUE)) == 710 // Tor Browser bug: Math.acosh(Infinity) -> NaN
&& $acosh(Infinity) == Infinity), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.asinh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.asinh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
} // Tor Browser bug: Math.asinh(0) -> -0


$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {
  asinh: asinh
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.atanh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.atanh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $atanh = Math.atanh; // Tor Browser bug: Math.atanh(-0) -> 0

$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.cbrt.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.cbrt.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var sign = __webpack_require__(/*! ./_math-sign */ "./node_modules/core-js/modules/_math-sign.js");

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.clz32.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.clz32.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.cosh.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.cosh.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var exp = Math.exp;
$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.expm1.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.expm1.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/core-js/modules/_math-expm1.js");

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {
  expm1: $expm1
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.fround.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.fround.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  fround: __webpack_require__(/*! ./_math-fround */ "./node_modules/core-js/modules/_math-fround.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.hypot.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.hypot.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var abs = Math.abs;
$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) {
    // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;

    while (i < aLen) {
      arg = abs(arguments[i++]);

      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }

    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.imul.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.imul.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $imul = Math.imul; // some WebKit versions fails with big numbers, some has wrong arity

$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.log10.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.log10.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.log1p.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.log1p.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log1p: __webpack_require__(/*! ./_math-log1p */ "./node_modules/core-js/modules/_math-log1p.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.log2.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.log2.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.sign.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.sign.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  sign: __webpack_require__(/*! ./_math-sign */ "./node_modules/core-js/modules/_math-sign.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.sinh.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.sinh.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/core-js/modules/_math-expm1.js");

var exp = Math.exp; // V8 near Chromium 38 has a problem with very small numbers

$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.tanh.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.tanh.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/core-js/modules/_math-expm1.js");

var exp = Math.exp;
$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.trunc.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.trunc.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.constructor.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.constructor.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/core-js/modules/_inherit-if-required.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f;

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var $trim = __webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js").trim;

var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype; // Opera ~12 has broken Object#toString

var BROKEN_COF = cof(__webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js")(proto)) == NUMBER;
var TRIM = ('trim' in String.prototype); // 7.1.3 ToNumber(argument)

var toNumber = function (argument) {
  var it = toPrimitive(argument, false);

  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;

    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        // fast equal /^0b[01]+$/i

        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        // fast equal /^0o[0-7]+$/i

        default:
          return +it;
      }

      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i); // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols

        if (code < 48 || code > maxCode) return NaN;
      }

      return parseInt(digits, radix);
    }
  }

  return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number // check on 1..constructor(foo) case
    && (BROKEN_COF ? fails(function () {
      proto.valueOf.call(that);
    }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };

  for (var keys = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? gOPN(Base) : ( // ES3:
  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES6 (in case, if modules with ES6 Number statics required before):
  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }

  $Number.prototype = proto;
  proto.constructor = $Number;

  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(global, NUMBER, $Number);
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.epsilon.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.epsilon.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  EPSILON: Math.pow(2, -52)
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-finite.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-finite.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var _isFinite = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-integer.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-integer.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  isInteger: __webpack_require__(/*! ./_is-integer */ "./node_modules/core-js/modules/_is-integer.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-nan.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-nan.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-safe-integer.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-safe-integer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var isInteger = __webpack_require__(/*! ./_is-integer */ "./node_modules/core-js/modules/_is-integer.js");

var abs = Math.abs;
$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.max-safe-integer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.max-safe-integer.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  MAX_SAFE_INTEGER: 0x1fffffffffffff
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.min-safe-integer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.min-safe-integer.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  MIN_SAFE_INTEGER: -0x1fffffffffffff
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.parse-float.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.parse-float.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $parseFloat = __webpack_require__(/*! ./_parse-float */ "./node_modules/core-js/modules/_parse-float.js"); // 20.1.2.12 Number.parseFloat(string)


$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {
  parseFloat: $parseFloat
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.parse-int.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.parse-int.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $parseInt = __webpack_require__(/*! ./_parse-int */ "./node_modules/core-js/modules/_parse-int.js"); // 20.1.2.13 Number.parseInt(string, radix)


$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {
  parseInt: $parseInt
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.to-fixed.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.to-fixed.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var aNumberValue = __webpack_require__(/*! ./_a-number-value */ "./node_modules/core-js/modules/_a-number-value.js");

var repeat = __webpack_require__(/*! ./_string-repeat */ "./node_modules/core-js/modules/_string-repeat.js");

var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;

  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};

var divide = function (n) {
  var i = 6;
  var c = 0;

  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = c % n * 1e7;
  }
};

var numToString = function () {
  var i = 6;
  var s = '';

  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  }

  return s;
};

var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function (x) {
  var n = 0;
  var x2 = x;

  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }

  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  }

  return n;
};

$export($export.P + $export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR); // eslint-disable-next-line no-self-compare

    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);

    if (x < 0) {
      s = '-';
      x = -x;
    }

    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;

      if (e > 0) {
        multiply(0, z);
        j = f;

        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }

        multiply(pow(10, j, 1), 0);
        j = e - 1;

        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }

        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }

    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    }

    return m;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.to-precision.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.to-precision.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var aNumberValue = __webpack_require__(/*! ./_a-number-value */ "./node_modules/core-js/modules/_a-number-value.js");

var $toPrecision = 1.0.toPrecision;
$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.assign.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.assign.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S + $export.F, 'Object', {
  assign: __webpack_require__(/*! ./_object-assign */ "./node_modules/core-js/modules/_object-assign.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.create.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.create.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js"); // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])


$export($export.S, 'Object', {
  create: __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.define-properties.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.define-properties.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js"); // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)


$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js"), 'Object', {
  defineProperties: __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/modules/_object-dps.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.define-property.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.define-property.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js"); // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)


$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js"), 'Object', {
  defineProperty: __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.freeze.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.freeze.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.get-own-property-descriptor.js":
/*!********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.get-own-property-descriptor.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var $getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.get-own-property-names.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.get-own-property-names.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('getOwnPropertyNames', function () {
  return __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/core-js/modules/_object-gopn-ext.js").f;
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.get-prototype-of.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.get-prototype-of.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var $getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is-extensible.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is-extensible.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is-frozen.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is-frozen.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is-sealed.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is-sealed.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Object', {
  is: __webpack_require__(/*! ./_same-value */ "./node_modules/core-js/modules/_same-value.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.keys.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.prevent-extensions.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.prevent-extensions.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.seal.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.seal.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.set-prototype-of.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.set-prototype-of.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Object', {
  setPrototypeOf: __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/modules/_set-proto.js").set
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.to-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 19.1.3.6 Object.prototype.toString()

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

var test = {};
test[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag')] = 'z';

if (test + '' != '[object z]') {
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.parse-float.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.parse-float.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $parseFloat = __webpack_require__(/*! ./_parse-float */ "./node_modules/core-js/modules/_parse-float.js"); // 18.2.4 parseFloat(string)


$export($export.G + $export.F * (parseFloat != $parseFloat), {
  parseFloat: $parseFloat
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.parse-int.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.parse-int.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $parseInt = __webpack_require__(/*! ./_parse-int */ "./node_modules/core-js/modules/_parse-int.js"); // 18.2.5 parseInt(string, radix)


$export($export.G + $export.F * (parseInt != $parseInt), {
  parseInt: $parseInt
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.promise.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/es6.promise.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

var task = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js").set;

var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/core-js/modules/_microtask.js")();

var newPromiseCapabilityModule = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/modules/_new-promise-capability.js");

var perform = __webpack_require__(/*! ./_perform */ "./node_modules/core-js/modules/_perform.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js");

var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/core-js/modules/_promise-resolve.js");

var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';

var empty = function () {
  /* empty */
};

var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);

    var FakePromise = (promise.constructor = {})[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species')] = function (exec) {
      exec(empty, empty);
    }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test


    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // we can't detect it synchronously, so just check versions
    && v8.indexOf('6.6') !== 0 && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) {
    /* empty */
  }
}(); // helpers

var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;

    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;

      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }

          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value); // may throw

            if (domain) {
              domain.exit();
              exited = true;
            }
          }

          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };

    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach


    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};

var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;

    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({
            promise: promise,
            reason: value
          });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    }

    promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};

var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};

var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;

    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({
        promise: promise,
        reason: promise._v
      });
    }
  });
};

var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};

var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");

    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = {
          _w: promise,
          _d: false
        }; // wrap

        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({
      _w: promise,
      _d: false
    }, e); // wrap
  }
}; // constructor polyfill


if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);

    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  }; // eslint-disable-next-line no-unused-vars


  Internal = function Promise(executor) {
    this._c = []; // <- awaiting reactions

    this._a = undefined; // <- checked in isUnhandled reactions

    this._s = 0; // <- state

    this._d = false; // <- done

    this._v = undefined; // <- value

    this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled

    this._n = false; // <- notify
  };

  Internal.prototype = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;

      this._c.push(reaction);

      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });

  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };

  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Promise: $Promise
});

__webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js")($Promise, PROMISE);

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")(PROMISE);

Wrapper = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js")[PROMISE]; // statics

$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.apply.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.apply.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var rApply = (__webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Reflect || {}).apply;
var fApply = Function.apply; // MS Edge argumentsList argument is optional

$export($export.S + $export.F * !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  rApply(function () {
    /* empty */
  });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.construct.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.construct.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var bind = __webpack_require__(/*! ./_bind */ "./node_modules/core-js/modules/_bind.js");

var rConstruct = (__webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Reflect || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it

var NEW_TARGET_BUG = fails(function () {
  function F() {
    /* empty */
  }

  return !(rConstruct(function () {
    /* empty */
  }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () {
    /* empty */
  });
});
$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args
  /* , newTarget */
  ) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);

    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0:
          return new Target();

        case 1:
          return new Target(args[0]);

        case 2:
          return new Target(args[0], args[1]);

        case 3:
          return new Target(args[0], args[1], args[2]);

        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      } // w/o altered newTarget, lot of arguments case


      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    } // with altered newTarget, not support built-in constructors


    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.define-property.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.define-property.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js"); // MS Edge has broken Reflect.defineProperty - throwing instead of returning false


$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, {
    value: 1
  }), 1, {
    value: 2
  });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);

    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.delete-property.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.delete-property.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f;

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.enumerate.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.enumerate.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 26.1.5 Reflect.enumerate(target)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target

  this._i = 0; // next index

  var keys = this._k = []; // keys

  var key;

  for (key in iterated) keys.push(key);
};

__webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/modules/_iter-create.js")(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;

  do {
    if (that._i >= keys.length) return {
      value: undefined,
      done: true
    };
  } while (!((key = keys[that._i++]) in that._t));

  return {
    value: key,
    done: false
  };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.get-prototype-of.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.get-prototype-of.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var getProto = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.get.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.get.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

function get(target, propertyKey
/* , receiver */
) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', {
  get: get
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.has.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.has.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.is-extensible.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.is-extensible.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var $isExtensible = Object.isExtensible;
$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.own-keys.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.own-keys.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', {
  ownKeys: __webpack_require__(/*! ./_own-keys */ "./node_modules/core-js/modules/_own-keys.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.prevent-extensions.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.prevent-extensions.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var $preventExtensions = Object.preventExtensions;
$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);

    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.set-prototype-of.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.set-prototype-of.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var setProto = __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/modules/_set-proto.js");

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);

    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.set.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.set.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

function set(target, propertyKey, V
/* , receiver */
) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;

  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }

    ownDesc = createDesc(0);
  }

  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;

    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));

    return true;
  }

  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', {
  set: set
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.constructor.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.constructor.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/core-js/modules/_inherit-if-required.js");

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");

var $flags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");

var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g; // "new" creates a new object, old webkit buggy here

var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && (!CORRECT_NEW || __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  re2[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match')] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp);
  };

  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () {
        return Base[key];
      },
      set: function (it) {
        Base[key] = it;
      }
    });
  };

  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);

  proto.constructor = $RegExp;
  $RegExp.prototype = proto;

  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(global, 'RegExp', $RegExp);
}

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")('RegExp');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.exec.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.exec.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");

__webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js")({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.flags.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.flags.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && /./g.flags != 'g') __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.match.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.match.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js"); // @@match logic


__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [// `String.prototype.match` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.match
  function match(regexp) {
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, // `RegExp.prototype[@@match]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
  function (regexp) {
    var res = maybeCallNative($match, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    if (!rx.global) return regExpExec(rx, S);
    var fullUnicode = rx.unicode;
    rx.lastIndex = 0;
    var A = [];
    var n = 0;
    var result;

    while ((result = regExpExec(rx, S)) !== null) {
      var matchStr = String(result[0]);
      A[n] = matchStr;
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      n++;
    }

    return n === 0 ? null : A;
  }];
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.replace.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.replace.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");

var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
}; // @@replace logic


__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [// `String.prototype.replace` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.replace
  function replace(searchValue, replaceValue) {
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
  }, // `RegExp.prototype[@@replace]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
  function (regexp, replaceValue) {
    var res = maybeCallNative($replace, regexp, this, replaceValue);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var functionalReplace = typeof replaceValue === 'function';
    if (!functionalReplace) replaceValue = String(replaceValue);
    var global = rx.global;

    if (global) {
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
    }

    var results = [];

    while (true) {
      var result = regExpExec(rx, S);
      if (result === null) break;
      results.push(result);
      if (!global) break;
      var matchStr = String(result[0]);
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
    }

    var accumulatedResult = '';
    var nextSourcePosition = 0;

    for (var i = 0; i < results.length; i++) {
      result = results[i];
      var matched = String(result[0]);
      var position = max(min(toInteger(result.index), S.length), 0);
      var captures = []; // NOTE: This is equivalent to
      //   captures = result.slice(1).map(maybeToString)
      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

      for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));

      var namedCaptures = result.groups;

      if (functionalReplace) {
        var replacerArgs = [matched].concat(captures, position, S);
        if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
        var replacement = String(replaceValue.apply(undefined, replacerArgs));
      } else {
        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
      }

      if (position >= nextSourcePosition) {
        accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
        nextSourcePosition = position + matched.length;
      }
    }

    return accumulatedResult + S.slice(nextSourcePosition);
  }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }

    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;

      switch (ch.charAt(0)) {
        case '$':
          return '$';

        case '&':
          return matched;

        case '`':
          return str.slice(0, position);

        case "'":
          return str.slice(tailPos);

        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;

        default:
          // \d\d?
          var n = +ch;
          if (n === 0) return match;

          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }

          capture = captures[n - 1];
      }

      return capture === undefined ? '' : capture;
    });
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.search.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.search.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var sameValue = __webpack_require__(/*! ./_same-value */ "./node_modules/core-js/modules/_same-value.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js"); // @@search logic


__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [// `String.prototype.search` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.search
  function search(regexp) {
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, // `RegExp.prototype[@@search]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
  function (regexp) {
    var res = maybeCallNative($search, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var previousLastIndex = rx.lastIndex;
    if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
    var result = regExpExec(rx, S);
    if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
    return result === null ? -1 : result.index;
  }];
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.split.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.split.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var callRegExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");

var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff; // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError

var SUPPORTS_Y = !fails(function () {
  RegExp(MAX_UINT32, 'y');
}); // @@split logic

__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;

  if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return []; // If `separator` is not a regex, use native split

      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0; // Make `global` and avoid `lastIndex` issues by working with a copy

      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;

      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];

        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }

        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }

      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));

      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    }; // Chakra, V8

  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [// `String.prototype.split` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.split
  function split(separator, limit) {
    var O = defined(this);
    var splitter = separator == undefined ? undefined : separator[SPLIT];
    return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
  }, // `RegExp.prototype[@@split]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
  //
  // NOTE: This cannot be properly polyfilled in engines that don't support
  // the 'y' flag.
  function (regexp, limit) {
    var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var C = speciesConstructor(rx, RegExp);
    var unicodeMatching = rx.unicode;
    var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g'); // ^(? + rx + ) is needed, in combination with some S slicing, to
    // simulate the 'y' flag.

    var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
    var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
    if (lim === 0) return [];
    if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
    var p = 0;
    var q = 0;
    var A = [];

    while (q < S.length) {
      splitter.lastIndex = SUPPORTS_Y ? q : 0;
      var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
      var e;

      if (z === null || (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
        q = advanceStringIndex(S, q, unicodeMatching);
      } else {
        A.push(S.slice(p, q));
        if (A.length === lim) return A;

        for (var i = 1; i <= z.length - 1; i++) {
          A.push(z[i]);
          if (A.length === lim) return A;
        }

        q = p = e;
      }
    }

    A.push(S.slice(p));
    return A;
  }];
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.to-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./es6.regexp.flags */ "./node_modules/core-js/modules/es6.regexp.flags.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var $flags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(RegExp.prototype, TO_STRING, fn, true);
}; // 21.2.5.14 RegExp.prototype.toString()


if (__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return $toString.call({
    source: 'a',
    flags: 'b'
  }) != '/a/b';
})) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  }); // FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.set.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/es6.set.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(/*! ./_collection-strong */ "./node_modules/core-js/modules/_collection-strong.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var SET = 'Set'; // 23.2 Set Objects

module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(SET, function (get) {
  return function Set() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.anchor.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.anchor.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.2 String.prototype.anchor(name)

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.big.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.big.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.3 String.prototype.big()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.blink.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.blink.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.4 String.prototype.blink()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.bold.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.bold.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.5 String.prototype.bold()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.code-point-at.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.code-point-at.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(false);

$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.ends-with.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.ends-with.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var context = __webpack_require__(/*! ./_string-context */ "./node_modules/core-js/modules/_string-context.js");

var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/core-js/modules/_fails-is-regexp.js")(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString
  /* , endPosition = @length */
  ) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.fixed.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.fixed.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.6 String.prototype.fixed()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.fontcolor.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.fontcolor.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.7 String.prototype.fontcolor(color)

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.fontsize.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.fontsize.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.8 String.prototype.fontsize(size)

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.from-code-point.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.from-code-point.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem

$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) {
    // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;

    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
    }

    return res.join('');
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.includes.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.includes.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var context = __webpack_require__(/*! ./_string-context */ "./node_modules/core-js/modules/_string-context.js");

var INCLUDES = 'includes';
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/core-js/modules/_fails-is-regexp.js")(INCLUDES), 'String', {
  includes: function includes(searchString
  /* , position = 0 */
  ) {
    return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.italics.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.italics.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.9 String.prototype.italics()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.iterator.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(true); // 21.1.3.27 String.prototype[@@iterator]()


__webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target

  this._i = 0; // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return {
    value: undefined,
    done: true
  };
  point = $at(O, index);
  this._i += point.length;
  return {
    value: point,
    done: false
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.link.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.link.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.10 String.prototype.link(url)

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.raw.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.raw.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;

    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    }

    return res.join('');
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.repeat.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.repeat.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(/*! ./_string-repeat */ "./node_modules/core-js/modules/_string-repeat.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.small.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.small.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.11 String.prototype.small()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.starts-with.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.starts-with.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var context = __webpack_require__(/*! ./_string-context */ "./node_modules/core-js/modules/_string-context.js");

var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/core-js/modules/_fails-is-regexp.js")(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString
  /* , position = 0 */
  ) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.strike.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.strike.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.12 String.prototype.strike()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.sub.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.sub.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.13 String.prototype.sub()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.sup.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.sup.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.14 String.prototype.sup()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.trim.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.trim.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 21.1.3.25 String.prototype.trim()

__webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js")('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.symbol.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es6.symbol.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // ECMAScript 6 symbols shim

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var META = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").KEY;

var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/modules/_wks-ext.js");

var wksDefine = __webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/modules/_wks-define.js");

var enumKeys = __webpack_require__(/*! ./_enum-keys */ "./node_modules/core-js/modules/_enum-keys.js");

var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

var _create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

var gOPNExt = __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/core-js/modules/_object-gopn-ext.js");

var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var $GOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");

var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;

var _stringify = $JSON && $JSON.stringify;

var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () {
      return dP(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);

  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);

  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, {
        enumerable: createDesc(0, false)
      });
    }

    return setSymbolDesc(it, key, D);
  }

  return dP(it, key, D);
};

var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;

  while (l > i) $defineProperty(it, key = keys[i++], P[key]);

  return it;
};

var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};

var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};

var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  }

  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  }

  return result;
}; // 19.4.1.1 Symbol([description])


if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);

    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };

    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: $set
    });
    return wrap(tag);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });
  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js").f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Symbol: $Symbol
});

for (var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');

    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () {
    setter = true;
  },
  useSimple: function () {
    setter = false;
  }
});
$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
}); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443

var FAILS_ON_PRIMITIVES = $fails(function () {
  $GOPS.f(1);
});
$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
}); // 24.3.2 JSON.stringify(value [, replacer [, space]])

$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol(); // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols

  return _stringify([S]) != '[null]' || _stringify({
    a: S
  }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;

    while (arguments.length > i) args.push(arguments[i++]);

    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
}); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)

$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag]

setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag]

setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag]

setToStringTag(global.JSON, 'JSON', true);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.array-buffer.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.array-buffer.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");

var buffer = __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var ArrayBuffer = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").ArrayBuffer;

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';
$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {
  ArrayBuffer: $ArrayBuffer
});
$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});
$export($export.P + $export.U + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix

    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;

    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    }

    return result;
  }
});

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")(ARRAY_BUFFER);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.data-view.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.data-view.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.G + $export.W + $export.F * !__webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js").ABV, {
  DataView: __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js").DataView
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.float32-array.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.float32-array.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.float64-array.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.float64-array.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.int16-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.int16-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.int32-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.int32-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.int8-array.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.int8-array.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint16-array.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint16-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint32-array.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint32-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint8-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint8-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint8-clamped-array.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint8-clamped-array.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.weak-map.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.weak-map.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var each = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(0);

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js");

var assign = __webpack_require__(/*! ./_object-assign */ "./node_modules/core-js/modules/_object-assign.js");

var weak = __webpack_require__(/*! ./_collection-weak */ "./node_modules/core-js/modules/_collection-weak.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var NATIVE_WEAK_MAP = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
}; // 23.3 WeakMap Objects

var $WeakMap = module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(WEAK_MAP, wrapper, methods, weak, true, true); // IE11 WeakMap frozen keys fix


if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();

        var result = this._f[key](a, b);

        return key == 'set' ? this : result; // store all the rest on native weakmap
      }

      return method.call(this, a, b);
    });
  });
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.weak-set.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.weak-set.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var weak = __webpack_require__(/*! ./_collection-weak */ "./node_modules/core-js/modules/_collection-weak.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var WEAK_SET = 'WeakSet'; // 23.4 WeakSet Objects

__webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(WEAK_SET, function (get) {
  return function WeakSet() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

/***/ }),

/***/ "./node_modules/core-js/modules/es7.array.flat-map.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.array.flat-map.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var flattenIntoArray = __webpack_require__(/*! ./_flatten-into-array */ "./node_modules/core-js/modules/_flatten-into-array.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var arraySpeciesCreate = __webpack_require__(/*! ./_array-species-create */ "./node_modules/core-js/modules/_array-species-create.js");

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn
  /* , thisArg */
  ) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('flatMap');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.array.flatten.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.array.flatten.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var flattenIntoArray = __webpack_require__(/*! ./_flatten-into-array */ "./node_modules/core-js/modules/_flatten-into-array.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var arraySpeciesCreate = __webpack_require__(/*! ./_array-species-create */ "./node_modules/core-js/modules/_array-species-create.js");

$export($export.P, 'Array', {
  flatten: function flatten()
  /* depthArg = 1 */
  {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('flatten');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.array.includes.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.array.includes.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/Array.prototype.includes

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $includes = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(true);

$export($export.P, 'Array', {
  includes: function includes(el
  /* , fromIndex = 0 */
  ) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('includes');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.asap.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/es7.asap.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/core-js/modules/_microtask.js")();

var process = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").process;

var isNode = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js")(process) == 'process';
$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.error.is-error.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.error.is-error.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/ljharb/proposal-is-error
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.global.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es7.global.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.G, {
  global: __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.map.from.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es7.map.from.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/core-js/modules/_set-collection-from.js")('Map');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.map.of.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es7.map.of.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/core-js/modules/_set-collection-of.js")('Map');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.map.to-json.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.map.to-json.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P + $export.R, 'Map', {
  toJSON: __webpack_require__(/*! ./_collection-to-json */ "./node_modules/core-js/modules/_collection-to-json.js")('Map')
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.clamp.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.clamp.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.deg-per-rad.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.deg-per-rad.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  DEG_PER_RAD: Math.PI / 180
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.degrees.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.degrees.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var RAD_PER_DEG = 180 / Math.PI;
$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.fscale.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.fscale.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var scale = __webpack_require__(/*! ./_math-scale */ "./node_modules/core-js/modules/_math-scale.js");

var fround = __webpack_require__(/*! ./_math-fround */ "./node_modules/core-js/modules/_math-fround.js");

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.iaddh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.iaddh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.imulh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.imulh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.isubh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.isubh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.rad-per-deg.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.rad-per-deg.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  RAD_PER_DEG: 180 / Math.PI
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.radians.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.radians.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var DEG_PER_RAD = Math.PI / 180;
$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.scale.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.scale.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  scale: __webpack_require__(/*! ./_math-scale */ "./node_modules/core-js/modules/_math-scale.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.signbit.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.signbit.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// http://jfbastien.github.io/papers/Math.signbit.html
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  signbit: function signbit(x) {
    // eslint-disable-next-line no-self-compare
    return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.umulh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.umulh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.define-getter.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.define-getter.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js"); // B.2.2.2 Object.prototype.__defineGetter__(P, getter)


__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "./node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, {
      get: aFunction(getter),
      enumerable: true,
      configurable: true
    });
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.define-setter.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.define-setter.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js"); // B.2.2.3 Object.prototype.__defineSetter__(P, setter)


__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "./node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, {
      set: aFunction(setter),
      enumerable: true,
      configurable: true
    });
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.entries.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.entries.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $entries = __webpack_require__(/*! ./_object-to-array */ "./node_modules/core-js/modules/_object-to-array.js")(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var ownKeys = __webpack_require__(/*! ./_own-keys */ "./node_modules/core-js/modules/_own-keys.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/modules/_create-property.js");

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;

    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }

    return result;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.lookup-getter.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.lookup-getter.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f; // B.2.2.4 Object.prototype.__lookupGetter__(P)


__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "./node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;

    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.lookup-setter.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.lookup-setter.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f; // B.2.2.5 Object.prototype.__lookupSetter__(P)


__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "./node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;

    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.values.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.values.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $values = __webpack_require__(/*! ./_object-to-array */ "./node_modules/core-js/modules/_object-to-array.js")(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.observable.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.observable.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/zenparsing/es-observable

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/core-js/modules/_microtask.js")();

var OBSERVABLE = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('observable');

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;

  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);

  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;

    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () {
        subscription.unsubscribe();
      };else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  }

  if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() {
    closeSubscription(this);
  }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;

    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;

      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;

    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    }

    cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;

    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;

      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      }

      cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});
redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);

    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }

    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          }

          observer.complete();
        }
      });
      return function () {
        done = true;
      };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];

    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          }

          observer.complete();
        }
      });
      return function () {
        done = true;
      };
    });
  }
});
hide($Observable.prototype, OBSERVABLE, function () {
  return this;
});
$export($export.G, {
  Observable: $Observable
});

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")('Observable');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.promise.finally.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.promise.finally.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/core-js/modules/_promise-resolve.js");

$export($export.P + $export.R, 'Promise', {
  'finally': function (onFinally) {
    var C = speciesConstructor(this, core.Promise || global.Promise);
    var isFunction = typeof onFinally == 'function';
    return this.then(isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () {
        return x;
      });
    } : onFinally, isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () {
        throw e;
      });
    } : onFinally);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.promise.try.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.promise.try.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-promise-try

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/modules/_new-promise-capability.js");

var perform = __webpack_require__(/*! ./_perform */ "./node_modules/core-js/modules/_perform.js");

$export($export.S, 'Promise', {
  'try': function (callbackfn) {
    var promiseCapability = newPromiseCapability.f(this);
    var result = perform(callbackfn);
    (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
    return promiseCapability.promise;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.define-metadata.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.define-metadata.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;
metadata.exp({
  defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
    ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.delete-metadata.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.delete-metadata.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;
metadata.exp({
  deleteMetadata: function deleteMetadata(metadataKey, target
  /* , targetKey */
  ) {
    var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
    var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
    if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
    if (metadataMap.size) return true;
    var targetMetadata = store.get(target);
    targetMetadata['delete'](targetKey);
    return !!targetMetadata.size || store['delete'](target);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.get-metadata-keys.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.get-metadata-keys.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(/*! ./es6.set */ "./node_modules/core-js/modules/es6.set.js");

var from = __webpack_require__(/*! ./_array-from-iterable */ "./node_modules/core-js/modules/_array-from-iterable.js");

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({
  getMetadataKeys: function getMetadataKeys(target
  /* , targetKey */
  ) {
    return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.get-metadata.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.get-metadata.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({
  getMetadata: function getMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;
metadata.exp({
  getOwnMetadataKeys: function getOwnMetadataKeys(target
  /* , targetKey */
  ) {
    return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.get-own-metadata.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.get-own-metadata.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;
metadata.exp({
  getOwnMetadata: function getOwnMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryGetOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.has-metadata.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.has-metadata.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({
  hasMetadata: function hasMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.has-own-metadata.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.has-own-metadata.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;
metadata.exp({
  hasOwnMetadata: function hasOwnMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryHasOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.metadata.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.metadata.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;
$metadata.exp({
  metadata: function metadata(metadataKey, metadataValue) {
    return function decorator(target, targetKey) {
      ordinaryDefineOwnMetadata(metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey(targetKey));
    };
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.set.from.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es7.set.from.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/core-js/modules/_set-collection-from.js")('Set');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.set.of.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es7.set.of.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/core-js/modules/_set-collection-of.js")('Set');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.set.to-json.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.set.to-json.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P + $export.R, 'Set', {
  toJSON: __webpack_require__(/*! ./_collection-to-json */ "./node_modules/core-js/modules/_collection-to-json.js")('Set')
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.at.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.at.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/mathiasbynens/String.prototype.at

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.match-all.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.match-all.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/String.prototype.matchAll/

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");

var getFlags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");

var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

__webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/modules/_iter-create.js")($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);

  return {
    value: match,
    done: match === null
  };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.pad-end.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.pad-end.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $pad = __webpack_require__(/*! ./_string-pad */ "./node_modules/core-js/modules/_string-pad.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js"); // https://github.com/zloirock/core-js/issues/280


var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padEnd: function padEnd(maxLength
  /* , fillString = ' ' */
  ) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.pad-start.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.pad-start.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $pad = __webpack_require__(/*! ./_string-pad */ "./node_modules/core-js/modules/_string-pad.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js"); // https://github.com/zloirock/core-js/issues/280


var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength
  /* , fillString = ' ' */
  ) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.trim-left.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.trim-left.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/sebmarkbage/ecmascript-string-left-right-trim

__webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js")('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.trim-right.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.trim-right.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/sebmarkbage/ecmascript-string-left-right-trim

__webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js")('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.symbol.async-iterator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.symbol.async-iterator.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/modules/_wks-define.js")('asyncIterator');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.symbol.observable.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.symbol.observable.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/modules/_wks-define.js")('observable');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.system.global.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.system.global.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'System', {
  global: __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.weak-map.from.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.weak-map.from.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/core-js/modules/_set-collection-from.js")('WeakMap');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.weak-map.of.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.weak-map.of.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/core-js/modules/_set-collection-of.js")('WeakMap');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.weak-set.from.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.weak-set.from.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/core-js/modules/_set-collection-from.js")('WeakSet');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.weak-set.of.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.weak-set.of.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/core-js/modules/_set-collection-of.js")('WeakSet');

/***/ }),

/***/ "./node_modules/core-js/modules/web.dom.iterable.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom.iterable.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;
var DOMIterables = {
  CSSRuleList: true,
  // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true,
  // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true,
  // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;

  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

/***/ }),

/***/ "./node_modules/core-js/modules/web.immediate.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/web.immediate.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $task = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js");

$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

/***/ }),

/***/ "./node_modules/core-js/modules/web.timers.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/web.timers.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js");

var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check

var wrap = function (set) {
  return function (fn, time
  /* , ...args */
  ) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};

$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

/***/ }),

/***/ "./node_modules/core-js/shim.js":
/*!**************************************!*\
  !*** ./node_modules/core-js/shim.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./modules/es6.symbol */ "./node_modules/core-js/modules/es6.symbol.js");

__webpack_require__(/*! ./modules/es6.object.create */ "./node_modules/core-js/modules/es6.object.create.js");

__webpack_require__(/*! ./modules/es6.object.define-property */ "./node_modules/core-js/modules/es6.object.define-property.js");

__webpack_require__(/*! ./modules/es6.object.define-properties */ "./node_modules/core-js/modules/es6.object.define-properties.js");

__webpack_require__(/*! ./modules/es6.object.get-own-property-descriptor */ "./node_modules/core-js/modules/es6.object.get-own-property-descriptor.js");

__webpack_require__(/*! ./modules/es6.object.get-prototype-of */ "./node_modules/core-js/modules/es6.object.get-prototype-of.js");

__webpack_require__(/*! ./modules/es6.object.keys */ "./node_modules/core-js/modules/es6.object.keys.js");

__webpack_require__(/*! ./modules/es6.object.get-own-property-names */ "./node_modules/core-js/modules/es6.object.get-own-property-names.js");

__webpack_require__(/*! ./modules/es6.object.freeze */ "./node_modules/core-js/modules/es6.object.freeze.js");

__webpack_require__(/*! ./modules/es6.object.seal */ "./node_modules/core-js/modules/es6.object.seal.js");

__webpack_require__(/*! ./modules/es6.object.prevent-extensions */ "./node_modules/core-js/modules/es6.object.prevent-extensions.js");

__webpack_require__(/*! ./modules/es6.object.is-frozen */ "./node_modules/core-js/modules/es6.object.is-frozen.js");

__webpack_require__(/*! ./modules/es6.object.is-sealed */ "./node_modules/core-js/modules/es6.object.is-sealed.js");

__webpack_require__(/*! ./modules/es6.object.is-extensible */ "./node_modules/core-js/modules/es6.object.is-extensible.js");

__webpack_require__(/*! ./modules/es6.object.assign */ "./node_modules/core-js/modules/es6.object.assign.js");

__webpack_require__(/*! ./modules/es6.object.is */ "./node_modules/core-js/modules/es6.object.is.js");

__webpack_require__(/*! ./modules/es6.object.set-prototype-of */ "./node_modules/core-js/modules/es6.object.set-prototype-of.js");

__webpack_require__(/*! ./modules/es6.object.to-string */ "./node_modules/core-js/modules/es6.object.to-string.js");

__webpack_require__(/*! ./modules/es6.function.bind */ "./node_modules/core-js/modules/es6.function.bind.js");

__webpack_require__(/*! ./modules/es6.function.name */ "./node_modules/core-js/modules/es6.function.name.js");

__webpack_require__(/*! ./modules/es6.function.has-instance */ "./node_modules/core-js/modules/es6.function.has-instance.js");

__webpack_require__(/*! ./modules/es6.parse-int */ "./node_modules/core-js/modules/es6.parse-int.js");

__webpack_require__(/*! ./modules/es6.parse-float */ "./node_modules/core-js/modules/es6.parse-float.js");

__webpack_require__(/*! ./modules/es6.number.constructor */ "./node_modules/core-js/modules/es6.number.constructor.js");

__webpack_require__(/*! ./modules/es6.number.to-fixed */ "./node_modules/core-js/modules/es6.number.to-fixed.js");

__webpack_require__(/*! ./modules/es6.number.to-precision */ "./node_modules/core-js/modules/es6.number.to-precision.js");

__webpack_require__(/*! ./modules/es6.number.epsilon */ "./node_modules/core-js/modules/es6.number.epsilon.js");

__webpack_require__(/*! ./modules/es6.number.is-finite */ "./node_modules/core-js/modules/es6.number.is-finite.js");

__webpack_require__(/*! ./modules/es6.number.is-integer */ "./node_modules/core-js/modules/es6.number.is-integer.js");

__webpack_require__(/*! ./modules/es6.number.is-nan */ "./node_modules/core-js/modules/es6.number.is-nan.js");

__webpack_require__(/*! ./modules/es6.number.is-safe-integer */ "./node_modules/core-js/modules/es6.number.is-safe-integer.js");

__webpack_require__(/*! ./modules/es6.number.max-safe-integer */ "./node_modules/core-js/modules/es6.number.max-safe-integer.js");

__webpack_require__(/*! ./modules/es6.number.min-safe-integer */ "./node_modules/core-js/modules/es6.number.min-safe-integer.js");

__webpack_require__(/*! ./modules/es6.number.parse-float */ "./node_modules/core-js/modules/es6.number.parse-float.js");

__webpack_require__(/*! ./modules/es6.number.parse-int */ "./node_modules/core-js/modules/es6.number.parse-int.js");

__webpack_require__(/*! ./modules/es6.math.acosh */ "./node_modules/core-js/modules/es6.math.acosh.js");

__webpack_require__(/*! ./modules/es6.math.asinh */ "./node_modules/core-js/modules/es6.math.asinh.js");

__webpack_require__(/*! ./modules/es6.math.atanh */ "./node_modules/core-js/modules/es6.math.atanh.js");

__webpack_require__(/*! ./modules/es6.math.cbrt */ "./node_modules/core-js/modules/es6.math.cbrt.js");

__webpack_require__(/*! ./modules/es6.math.clz32 */ "./node_modules/core-js/modules/es6.math.clz32.js");

__webpack_require__(/*! ./modules/es6.math.cosh */ "./node_modules/core-js/modules/es6.math.cosh.js");

__webpack_require__(/*! ./modules/es6.math.expm1 */ "./node_modules/core-js/modules/es6.math.expm1.js");

__webpack_require__(/*! ./modules/es6.math.fround */ "./node_modules/core-js/modules/es6.math.fround.js");

__webpack_require__(/*! ./modules/es6.math.hypot */ "./node_modules/core-js/modules/es6.math.hypot.js");

__webpack_require__(/*! ./modules/es6.math.imul */ "./node_modules/core-js/modules/es6.math.imul.js");

__webpack_require__(/*! ./modules/es6.math.log10 */ "./node_modules/core-js/modules/es6.math.log10.js");

__webpack_require__(/*! ./modules/es6.math.log1p */ "./node_modules/core-js/modules/es6.math.log1p.js");

__webpack_require__(/*! ./modules/es6.math.log2 */ "./node_modules/core-js/modules/es6.math.log2.js");

__webpack_require__(/*! ./modules/es6.math.sign */ "./node_modules/core-js/modules/es6.math.sign.js");

__webpack_require__(/*! ./modules/es6.math.sinh */ "./node_modules/core-js/modules/es6.math.sinh.js");

__webpack_require__(/*! ./modules/es6.math.tanh */ "./node_modules/core-js/modules/es6.math.tanh.js");

__webpack_require__(/*! ./modules/es6.math.trunc */ "./node_modules/core-js/modules/es6.math.trunc.js");

__webpack_require__(/*! ./modules/es6.string.from-code-point */ "./node_modules/core-js/modules/es6.string.from-code-point.js");

__webpack_require__(/*! ./modules/es6.string.raw */ "./node_modules/core-js/modules/es6.string.raw.js");

__webpack_require__(/*! ./modules/es6.string.trim */ "./node_modules/core-js/modules/es6.string.trim.js");

__webpack_require__(/*! ./modules/es6.string.iterator */ "./node_modules/core-js/modules/es6.string.iterator.js");

__webpack_require__(/*! ./modules/es6.string.code-point-at */ "./node_modules/core-js/modules/es6.string.code-point-at.js");

__webpack_require__(/*! ./modules/es6.string.ends-with */ "./node_modules/core-js/modules/es6.string.ends-with.js");

__webpack_require__(/*! ./modules/es6.string.includes */ "./node_modules/core-js/modules/es6.string.includes.js");

__webpack_require__(/*! ./modules/es6.string.repeat */ "./node_modules/core-js/modules/es6.string.repeat.js");

__webpack_require__(/*! ./modules/es6.string.starts-with */ "./node_modules/core-js/modules/es6.string.starts-with.js");

__webpack_require__(/*! ./modules/es6.string.anchor */ "./node_modules/core-js/modules/es6.string.anchor.js");

__webpack_require__(/*! ./modules/es6.string.big */ "./node_modules/core-js/modules/es6.string.big.js");

__webpack_require__(/*! ./modules/es6.string.blink */ "./node_modules/core-js/modules/es6.string.blink.js");

__webpack_require__(/*! ./modules/es6.string.bold */ "./node_modules/core-js/modules/es6.string.bold.js");

__webpack_require__(/*! ./modules/es6.string.fixed */ "./node_modules/core-js/modules/es6.string.fixed.js");

__webpack_require__(/*! ./modules/es6.string.fontcolor */ "./node_modules/core-js/modules/es6.string.fontcolor.js");

__webpack_require__(/*! ./modules/es6.string.fontsize */ "./node_modules/core-js/modules/es6.string.fontsize.js");

__webpack_require__(/*! ./modules/es6.string.italics */ "./node_modules/core-js/modules/es6.string.italics.js");

__webpack_require__(/*! ./modules/es6.string.link */ "./node_modules/core-js/modules/es6.string.link.js");

__webpack_require__(/*! ./modules/es6.string.small */ "./node_modules/core-js/modules/es6.string.small.js");

__webpack_require__(/*! ./modules/es6.string.strike */ "./node_modules/core-js/modules/es6.string.strike.js");

__webpack_require__(/*! ./modules/es6.string.sub */ "./node_modules/core-js/modules/es6.string.sub.js");

__webpack_require__(/*! ./modules/es6.string.sup */ "./node_modules/core-js/modules/es6.string.sup.js");

__webpack_require__(/*! ./modules/es6.date.now */ "./node_modules/core-js/modules/es6.date.now.js");

__webpack_require__(/*! ./modules/es6.date.to-json */ "./node_modules/core-js/modules/es6.date.to-json.js");

__webpack_require__(/*! ./modules/es6.date.to-iso-string */ "./node_modules/core-js/modules/es6.date.to-iso-string.js");

__webpack_require__(/*! ./modules/es6.date.to-string */ "./node_modules/core-js/modules/es6.date.to-string.js");

__webpack_require__(/*! ./modules/es6.date.to-primitive */ "./node_modules/core-js/modules/es6.date.to-primitive.js");

__webpack_require__(/*! ./modules/es6.array.is-array */ "./node_modules/core-js/modules/es6.array.is-array.js");

__webpack_require__(/*! ./modules/es6.array.from */ "./node_modules/core-js/modules/es6.array.from.js");

__webpack_require__(/*! ./modules/es6.array.of */ "./node_modules/core-js/modules/es6.array.of.js");

__webpack_require__(/*! ./modules/es6.array.join */ "./node_modules/core-js/modules/es6.array.join.js");

__webpack_require__(/*! ./modules/es6.array.slice */ "./node_modules/core-js/modules/es6.array.slice.js");

__webpack_require__(/*! ./modules/es6.array.sort */ "./node_modules/core-js/modules/es6.array.sort.js");

__webpack_require__(/*! ./modules/es6.array.for-each */ "./node_modules/core-js/modules/es6.array.for-each.js");

__webpack_require__(/*! ./modules/es6.array.map */ "./node_modules/core-js/modules/es6.array.map.js");

__webpack_require__(/*! ./modules/es6.array.filter */ "./node_modules/core-js/modules/es6.array.filter.js");

__webpack_require__(/*! ./modules/es6.array.some */ "./node_modules/core-js/modules/es6.array.some.js");

__webpack_require__(/*! ./modules/es6.array.every */ "./node_modules/core-js/modules/es6.array.every.js");

__webpack_require__(/*! ./modules/es6.array.reduce */ "./node_modules/core-js/modules/es6.array.reduce.js");

__webpack_require__(/*! ./modules/es6.array.reduce-right */ "./node_modules/core-js/modules/es6.array.reduce-right.js");

__webpack_require__(/*! ./modules/es6.array.index-of */ "./node_modules/core-js/modules/es6.array.index-of.js");

__webpack_require__(/*! ./modules/es6.array.last-index-of */ "./node_modules/core-js/modules/es6.array.last-index-of.js");

__webpack_require__(/*! ./modules/es6.array.copy-within */ "./node_modules/core-js/modules/es6.array.copy-within.js");

__webpack_require__(/*! ./modules/es6.array.fill */ "./node_modules/core-js/modules/es6.array.fill.js");

__webpack_require__(/*! ./modules/es6.array.find */ "./node_modules/core-js/modules/es6.array.find.js");

__webpack_require__(/*! ./modules/es6.array.find-index */ "./node_modules/core-js/modules/es6.array.find-index.js");

__webpack_require__(/*! ./modules/es6.array.species */ "./node_modules/core-js/modules/es6.array.species.js");

__webpack_require__(/*! ./modules/es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");

__webpack_require__(/*! ./modules/es6.regexp.constructor */ "./node_modules/core-js/modules/es6.regexp.constructor.js");

__webpack_require__(/*! ./modules/es6.regexp.exec */ "./node_modules/core-js/modules/es6.regexp.exec.js");

__webpack_require__(/*! ./modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");

__webpack_require__(/*! ./modules/es6.regexp.flags */ "./node_modules/core-js/modules/es6.regexp.flags.js");

__webpack_require__(/*! ./modules/es6.regexp.match */ "./node_modules/core-js/modules/es6.regexp.match.js");

__webpack_require__(/*! ./modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");

__webpack_require__(/*! ./modules/es6.regexp.search */ "./node_modules/core-js/modules/es6.regexp.search.js");

__webpack_require__(/*! ./modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");

__webpack_require__(/*! ./modules/es6.promise */ "./node_modules/core-js/modules/es6.promise.js");

__webpack_require__(/*! ./modules/es6.map */ "./node_modules/core-js/modules/es6.map.js");

__webpack_require__(/*! ./modules/es6.set */ "./node_modules/core-js/modules/es6.set.js");

__webpack_require__(/*! ./modules/es6.weak-map */ "./node_modules/core-js/modules/es6.weak-map.js");

__webpack_require__(/*! ./modules/es6.weak-set */ "./node_modules/core-js/modules/es6.weak-set.js");

__webpack_require__(/*! ./modules/es6.typed.array-buffer */ "./node_modules/core-js/modules/es6.typed.array-buffer.js");

__webpack_require__(/*! ./modules/es6.typed.data-view */ "./node_modules/core-js/modules/es6.typed.data-view.js");

__webpack_require__(/*! ./modules/es6.typed.int8-array */ "./node_modules/core-js/modules/es6.typed.int8-array.js");

__webpack_require__(/*! ./modules/es6.typed.uint8-array */ "./node_modules/core-js/modules/es6.typed.uint8-array.js");

__webpack_require__(/*! ./modules/es6.typed.uint8-clamped-array */ "./node_modules/core-js/modules/es6.typed.uint8-clamped-array.js");

__webpack_require__(/*! ./modules/es6.typed.int16-array */ "./node_modules/core-js/modules/es6.typed.int16-array.js");

__webpack_require__(/*! ./modules/es6.typed.uint16-array */ "./node_modules/core-js/modules/es6.typed.uint16-array.js");

__webpack_require__(/*! ./modules/es6.typed.int32-array */ "./node_modules/core-js/modules/es6.typed.int32-array.js");

__webpack_require__(/*! ./modules/es6.typed.uint32-array */ "./node_modules/core-js/modules/es6.typed.uint32-array.js");

__webpack_require__(/*! ./modules/es6.typed.float32-array */ "./node_modules/core-js/modules/es6.typed.float32-array.js");

__webpack_require__(/*! ./modules/es6.typed.float64-array */ "./node_modules/core-js/modules/es6.typed.float64-array.js");

__webpack_require__(/*! ./modules/es6.reflect.apply */ "./node_modules/core-js/modules/es6.reflect.apply.js");

__webpack_require__(/*! ./modules/es6.reflect.construct */ "./node_modules/core-js/modules/es6.reflect.construct.js");

__webpack_require__(/*! ./modules/es6.reflect.define-property */ "./node_modules/core-js/modules/es6.reflect.define-property.js");

__webpack_require__(/*! ./modules/es6.reflect.delete-property */ "./node_modules/core-js/modules/es6.reflect.delete-property.js");

__webpack_require__(/*! ./modules/es6.reflect.enumerate */ "./node_modules/core-js/modules/es6.reflect.enumerate.js");

__webpack_require__(/*! ./modules/es6.reflect.get */ "./node_modules/core-js/modules/es6.reflect.get.js");

__webpack_require__(/*! ./modules/es6.reflect.get-own-property-descriptor */ "./node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js");

__webpack_require__(/*! ./modules/es6.reflect.get-prototype-of */ "./node_modules/core-js/modules/es6.reflect.get-prototype-of.js");

__webpack_require__(/*! ./modules/es6.reflect.has */ "./node_modules/core-js/modules/es6.reflect.has.js");

__webpack_require__(/*! ./modules/es6.reflect.is-extensible */ "./node_modules/core-js/modules/es6.reflect.is-extensible.js");

__webpack_require__(/*! ./modules/es6.reflect.own-keys */ "./node_modules/core-js/modules/es6.reflect.own-keys.js");

__webpack_require__(/*! ./modules/es6.reflect.prevent-extensions */ "./node_modules/core-js/modules/es6.reflect.prevent-extensions.js");

__webpack_require__(/*! ./modules/es6.reflect.set */ "./node_modules/core-js/modules/es6.reflect.set.js");

__webpack_require__(/*! ./modules/es6.reflect.set-prototype-of */ "./node_modules/core-js/modules/es6.reflect.set-prototype-of.js");

__webpack_require__(/*! ./modules/es7.array.includes */ "./node_modules/core-js/modules/es7.array.includes.js");

__webpack_require__(/*! ./modules/es7.array.flat-map */ "./node_modules/core-js/modules/es7.array.flat-map.js");

__webpack_require__(/*! ./modules/es7.array.flatten */ "./node_modules/core-js/modules/es7.array.flatten.js");

__webpack_require__(/*! ./modules/es7.string.at */ "./node_modules/core-js/modules/es7.string.at.js");

__webpack_require__(/*! ./modules/es7.string.pad-start */ "./node_modules/core-js/modules/es7.string.pad-start.js");

__webpack_require__(/*! ./modules/es7.string.pad-end */ "./node_modules/core-js/modules/es7.string.pad-end.js");

__webpack_require__(/*! ./modules/es7.string.trim-left */ "./node_modules/core-js/modules/es7.string.trim-left.js");

__webpack_require__(/*! ./modules/es7.string.trim-right */ "./node_modules/core-js/modules/es7.string.trim-right.js");

__webpack_require__(/*! ./modules/es7.string.match-all */ "./node_modules/core-js/modules/es7.string.match-all.js");

__webpack_require__(/*! ./modules/es7.symbol.async-iterator */ "./node_modules/core-js/modules/es7.symbol.async-iterator.js");

__webpack_require__(/*! ./modules/es7.symbol.observable */ "./node_modules/core-js/modules/es7.symbol.observable.js");

__webpack_require__(/*! ./modules/es7.object.get-own-property-descriptors */ "./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js");

__webpack_require__(/*! ./modules/es7.object.values */ "./node_modules/core-js/modules/es7.object.values.js");

__webpack_require__(/*! ./modules/es7.object.entries */ "./node_modules/core-js/modules/es7.object.entries.js");

__webpack_require__(/*! ./modules/es7.object.define-getter */ "./node_modules/core-js/modules/es7.object.define-getter.js");

__webpack_require__(/*! ./modules/es7.object.define-setter */ "./node_modules/core-js/modules/es7.object.define-setter.js");

__webpack_require__(/*! ./modules/es7.object.lookup-getter */ "./node_modules/core-js/modules/es7.object.lookup-getter.js");

__webpack_require__(/*! ./modules/es7.object.lookup-setter */ "./node_modules/core-js/modules/es7.object.lookup-setter.js");

__webpack_require__(/*! ./modules/es7.map.to-json */ "./node_modules/core-js/modules/es7.map.to-json.js");

__webpack_require__(/*! ./modules/es7.set.to-json */ "./node_modules/core-js/modules/es7.set.to-json.js");

__webpack_require__(/*! ./modules/es7.map.of */ "./node_modules/core-js/modules/es7.map.of.js");

__webpack_require__(/*! ./modules/es7.set.of */ "./node_modules/core-js/modules/es7.set.of.js");

__webpack_require__(/*! ./modules/es7.weak-map.of */ "./node_modules/core-js/modules/es7.weak-map.of.js");

__webpack_require__(/*! ./modules/es7.weak-set.of */ "./node_modules/core-js/modules/es7.weak-set.of.js");

__webpack_require__(/*! ./modules/es7.map.from */ "./node_modules/core-js/modules/es7.map.from.js");

__webpack_require__(/*! ./modules/es7.set.from */ "./node_modules/core-js/modules/es7.set.from.js");

__webpack_require__(/*! ./modules/es7.weak-map.from */ "./node_modules/core-js/modules/es7.weak-map.from.js");

__webpack_require__(/*! ./modules/es7.weak-set.from */ "./node_modules/core-js/modules/es7.weak-set.from.js");

__webpack_require__(/*! ./modules/es7.global */ "./node_modules/core-js/modules/es7.global.js");

__webpack_require__(/*! ./modules/es7.system.global */ "./node_modules/core-js/modules/es7.system.global.js");

__webpack_require__(/*! ./modules/es7.error.is-error */ "./node_modules/core-js/modules/es7.error.is-error.js");

__webpack_require__(/*! ./modules/es7.math.clamp */ "./node_modules/core-js/modules/es7.math.clamp.js");

__webpack_require__(/*! ./modules/es7.math.deg-per-rad */ "./node_modules/core-js/modules/es7.math.deg-per-rad.js");

__webpack_require__(/*! ./modules/es7.math.degrees */ "./node_modules/core-js/modules/es7.math.degrees.js");

__webpack_require__(/*! ./modules/es7.math.fscale */ "./node_modules/core-js/modules/es7.math.fscale.js");

__webpack_require__(/*! ./modules/es7.math.iaddh */ "./node_modules/core-js/modules/es7.math.iaddh.js");

__webpack_require__(/*! ./modules/es7.math.isubh */ "./node_modules/core-js/modules/es7.math.isubh.js");

__webpack_require__(/*! ./modules/es7.math.imulh */ "./node_modules/core-js/modules/es7.math.imulh.js");

__webpack_require__(/*! ./modules/es7.math.rad-per-deg */ "./node_modules/core-js/modules/es7.math.rad-per-deg.js");

__webpack_require__(/*! ./modules/es7.math.radians */ "./node_modules/core-js/modules/es7.math.radians.js");

__webpack_require__(/*! ./modules/es7.math.scale */ "./node_modules/core-js/modules/es7.math.scale.js");

__webpack_require__(/*! ./modules/es7.math.umulh */ "./node_modules/core-js/modules/es7.math.umulh.js");

__webpack_require__(/*! ./modules/es7.math.signbit */ "./node_modules/core-js/modules/es7.math.signbit.js");

__webpack_require__(/*! ./modules/es7.promise.finally */ "./node_modules/core-js/modules/es7.promise.finally.js");

__webpack_require__(/*! ./modules/es7.promise.try */ "./node_modules/core-js/modules/es7.promise.try.js");

__webpack_require__(/*! ./modules/es7.reflect.define-metadata */ "./node_modules/core-js/modules/es7.reflect.define-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.delete-metadata */ "./node_modules/core-js/modules/es7.reflect.delete-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.get-metadata */ "./node_modules/core-js/modules/es7.reflect.get-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.get-metadata-keys */ "./node_modules/core-js/modules/es7.reflect.get-metadata-keys.js");

__webpack_require__(/*! ./modules/es7.reflect.get-own-metadata */ "./node_modules/core-js/modules/es7.reflect.get-own-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.get-own-metadata-keys */ "./node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js");

__webpack_require__(/*! ./modules/es7.reflect.has-metadata */ "./node_modules/core-js/modules/es7.reflect.has-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.has-own-metadata */ "./node_modules/core-js/modules/es7.reflect.has-own-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.metadata */ "./node_modules/core-js/modules/es7.reflect.metadata.js");

__webpack_require__(/*! ./modules/es7.asap */ "./node_modules/core-js/modules/es7.asap.js");

__webpack_require__(/*! ./modules/es7.observable */ "./node_modules/core-js/modules/es7.observable.js");

__webpack_require__(/*! ./modules/web.timers */ "./node_modules/core-js/modules/web.timers.js");

__webpack_require__(/*! ./modules/web.immediate */ "./node_modules/core-js/modules/web.immediate.js");

__webpack_require__(/*! ./modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");

module.exports = __webpack_require__(/*! ./modules/_core */ "./node_modules/core-js/modules/_core.js");

/***/ }),

/***/ "./node_modules/highcharts/highcharts.js":
/*!***********************************************!*\
  !*** ./node_modules/highcharts/highcharts.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 Highcharts JS v8.0.4 (2020-03-10)

 (c) 2009-2018 Torstein Honsi

 License: www.highcharts.com/license
*/
(function (aa, S) {
   true && module.exports ? (S["default"] = S, module.exports = aa.document ? S(aa) : S) :  true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    return S(aa);
  }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
})("undefined" !== typeof window ? window : this, function (aa) {
  function S(d, g, W, u) {
    d.hasOwnProperty(g) || (d[g] = u.apply(null, W));
  }

  var r = {};
  S(r, "parts/Globals.js", [], function () {
    var d = "undefined" !== typeof aa ? aa : "undefined" !== typeof window ? window : {},
        g = d.document,
        W = d.navigator && d.navigator.userAgent || "",
        u = g && g.createElementNS && !!g.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect,
        r = /(edge|msie|trident)/i.test(W) && !d.opera,
        M = -1 !== W.indexOf("Firefox"),
        E = -1 !== W.indexOf("Chrome"),
        A = M && 4 > parseInt(W.split("Firefox/")[1], 10);
    return {
      product: "Highcharts",
      version: "8.0.4",
      deg2rad: 2 * Math.PI / 360,
      doc: g,
      hasBidiBug: A,
      hasTouch: !!d.TouchEvent,
      isMS: r,
      isWebKit: -1 !== W.indexOf("AppleWebKit"),
      isFirefox: M,
      isChrome: E,
      isSafari: !E && -1 !== W.indexOf("Safari"),
      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(W),
      SVG_NS: "http://www.w3.org/2000/svg",
      chartCount: 0,
      seriesTypes: {},
      symbolSizes: {},
      svg: u,
      win: d,
      marginNames: ["plotTop", "marginRight", "marginBottom", "plotLeft"],
      noop: function () {},
      charts: [],
      dateFormats: {}
    };
  });
  S(r, "parts/Utilities.js", [r["parts/Globals.js"]], function (d) {
    function g() {
      var b,
          a = arguments,
          m = {},
          f = function (b, a) {
        "object" !== typeof b && (b = {});
        Y(a, function (m, c) {
          !h(m, !0) || q(m) || N(m) ? b[c] = a[c] : b[c] = f(b[c] || {}, m);
        });
        return b;
      };

      !0 === a[0] && (m = a[1], a = Array.prototype.slice.call(a, 2));
      var c = a.length;

      for (b = 0; b < c; b++) m = f(m, a[b]);

      return m;
    }

    function W(b, a, m) {
      var f;
      t(a) ? c(m) ? b.setAttribute(a, m) : b && b.getAttribute && ((f = b.getAttribute(a)) || "class" !== a || (f = b.getAttribute(a + "Name"))) : Y(a, function (a, m) {
        b.setAttribute(m, a);
      });
      return f;
    }

    function u() {
      for (var b = arguments, a = b.length, m = 0; m < a; m++) {
        var f = b[m];
        if ("undefined" !== typeof f && null !== f) return f;
      }
    }

    function r(b, a) {
      if (!b) return a;
      var m = b.split(".").reverse();
      if (1 === m.length) return a[b];

      for (b = m.pop(); "undefined" !== typeof b && "undefined" !== typeof a && null !== a;) a = a[b], b = m.pop();

      return a;
    }

    d.timers = [];

    var M = d.charts,
        E = d.doc,
        A = d.win,
        G = d.error = function (b, a, m, f) {
      var c = P(b),
          p = c ? "Highcharts error #" + b + ": www.highcharts.com/errors/" + b + "/" : b.toString(),
          e = function () {
        if (a) throw Error(p);
        A.console && console.log(p);
      };

      if ("undefined" !== typeof f) {
        var x = "";
        c && (p += "?");
        d.objectEach(f, function (b, a) {
          x += "\n" + a + ": " + b;
          c && (p += encodeURI(a) + "=" + encodeURI(b));
        });
        p += x;
      }

      m ? d.fireEvent(m, "displayError", {
        code: b,
        message: p,
        params: f
      }, e) : e();
    },
        J = function () {
      function b(b, a, m) {
        this.options = a;
        this.elem = b;
        this.prop = m;
      }

      b.prototype.dSetter = function () {
        var b = this.paths[0],
            a = this.paths[1],
            m = [],
            f = this.now,
            c = b.length;
        if (1 === f) m = this.toD;else if (c === a.length && 1 > f) for (; c--;) {
          var p = parseFloat(b[c]);
          m[c] = isNaN(p) || "A" === a[c - 4] || "A" === a[c - 5] ? a[c] : f * parseFloat("" + (a[c] - p)) + p;
        } else m = a;
        this.elem.attr("d", m, null, !0);
      };

      b.prototype.update = function () {
        var b = this.elem,
            a = this.prop,
            m = this.now,
            f = this.options.step;
        if (this[a + "Setter"]) this[a + "Setter"]();else b.attr ? b.element && b.attr(a, m, null, !0) : b.style[a] = m + this.unit;
        f && f.call(b, m, this);
      };

      b.prototype.run = function (b, a, m) {
        var f = this,
            c = f.options,
            p = function (b) {
          return p.stopped ? !1 : f.step(b);
        },
            e = A.requestAnimationFrame || function (b) {
          setTimeout(b, 13);
        },
            x = function () {
          for (var b = 0; b < d.timers.length; b++) d.timers[b]() || d.timers.splice(b--, 1);

          d.timers.length && e(x);
        };

        b !== a || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = b, this.end = a, this.unit = m, this.now = this.start, this.pos = 0, p.elem = this.elem, p.prop = this.prop, p() && 1 === d.timers.push(p) && e(x)) : (delete c.curAnim[this.prop], c.complete && 0 === Object.keys(c.curAnim).length && c.complete.call(this.elem));
      };

      b.prototype.step = function (b) {
        var a = +new Date(),
            m = this.options,
            f = this.elem,
            c = m.complete,
            p = m.duration,
            e = m.curAnim;
        if (f.attr && !f.element) b = !1;else if (b || a >= p + this.startTime) {
          this.now = this.end;
          this.pos = 1;
          this.update();
          var x = e[this.prop] = !0;
          Y(e, function (b) {
            !0 !== b && (x = !1);
          });
          x && c && c.call(f);
          b = !1;
        } else this.pos = m.easing((a - this.startTime) / p), this.now = this.start + (this.end - this.start) * this.pos, this.update(), b = !0;
        return b;
      };

      b.prototype.initPath = function (b, a, m) {
        function f(b) {
          for (C = b.length; C--;) {
            var a = "M" === b[C] || "L" === b[C];
            var m = /[a-zA-Z]/.test(b[C + 3]);
            a && m && b.splice(C + 1, 0, b[C + 1], b[C + 2], b[C + 1], b[C + 2]);
          }
        }

        function c(b, a) {
          for (; b.length < v;) {
            b[0] = a[v - b.length];
            var m = b.slice(0, T);
            [].splice.apply(b, [0, 0].concat(m));
            k && (m = b.slice(b.length - T), [].splice.apply(b, [b.length, 0].concat(m)), C--);
          }

          b[0] = "M";
        }

        function p(b, a) {
          for (var m = (v - b.length) / T; 0 < m && m--;) l = b.slice().splice(b.length / n - T, T * n), l[0] = a[v - T - m * T], F && (l[T - 6] = l[T - 2], l[T - 5] = l[T - 1]), [].splice.apply(b, [b.length / n, 0].concat(l)), k && m--;
        }

        a = a || "";
        var e = b.startX,
            x = b.endX,
            F = -1 < a.indexOf("C"),
            T = F ? 7 : 3,
            l,
            C;
        a = a.split(" ");
        m = m.slice();
        var k = b.isArea,
            n = k ? 2 : 1;
        F && (f(a), f(m));

        if (e && x) {
          for (C = 0; C < e.length; C++) if (e[C] === x[0]) {
            var V = C;
            break;
          } else if (e[0] === x[x.length - e.length + C]) {
            V = C;
            var w = !0;
            break;
          } else if (e[e.length - 1] === x[x.length - e.length + C]) {
            V = e.length - C;
            break;
          }

          "undefined" === typeof V && (a = []);
        }

        if (a.length && P(V)) {
          var v = m.length + V * n * T;
          w ? (c(a, m), p(m, a)) : (c(m, a), p(a, m));
        }

        return [a, m];
      };

      b.prototype.fillSetter = function () {
        d.Fx.prototype.strokeSetter.apply(this, arguments);
      };

      b.prototype.strokeSetter = function () {
        this.elem.attr(this.prop, d.color(this.start).tweenTo(d.color(this.end), this.pos), null, !0);
      };

      return b;
    }();

    d.Fx = J;
    d.merge = g;

    var y = d.pInt = function (b, a) {
      return parseInt(b, a || 10);
    },
        t = d.isString = function (b) {
      return "string" === typeof b;
    },
        D = d.isArray = function (b) {
      b = Object.prototype.toString.call(b);
      return "[object Array]" === b || "[object Array Iterator]" === b;
    },
        h = d.isObject = function (b, a) {
      return !!b && "object" === typeof b && (!a || !D(b));
    },
        N = d.isDOMElement = function (b) {
      return h(b) && "number" === typeof b.nodeType;
    },
        q = d.isClass = function (b) {
      var a = b && b.constructor;
      return !(!h(b, !0) || N(b) || !a || !a.name || "Object" === a.name);
    },
        P = d.isNumber = function (b) {
      return "number" === typeof b && !isNaN(b) && Infinity > b && -Infinity < b;
    },
        e = d.erase = function (b, a) {
      for (var m = b.length; m--;) if (b[m] === a) {
        b.splice(m, 1);
        break;
      }
    },
        c = d.defined = function (b) {
      return "undefined" !== typeof b && null !== b;
    };

    d.attr = W;

    var k = d.splat = function (b) {
      return D(b) ? b : [b];
    },
        n = d.syncTimeout = function (b, a, m) {
      if (0 < a) return setTimeout(b, a, m);
      b.call(0, m);
      return -1;
    },
        f = d.clearTimeout = function (b) {
      c(b) && clearTimeout(b);
    },
        a = d.extend = function (b, a) {
      var m;
      b || (b = {});

      for (m in a) b[m] = a[m];

      return b;
    };

    d.pick = u;

    var l = d.css = function (b, m) {
      d.isMS && !d.svg && m && "undefined" !== typeof m.opacity && (m.filter = "alpha(opacity=" + 100 * m.opacity + ")");
      a(b.style, m);
    },
        v = d.createElement = function (b, m, f, c, p) {
      b = E.createElement(b);
      m && a(b, m);
      p && l(b, {
        padding: "0",
        border: "none",
        margin: "0"
      });
      f && l(b, f);
      c && c.appendChild(b);
      return b;
    },
        z = d.extendClass = function (b, m) {
      var f = function () {};

      f.prototype = new b();
      a(f.prototype, m);
      return f;
    },
        w = d.pad = function (b, a, m) {
      return Array((a || 2) + 1 - String(b).replace("-", "").length).join(m || "0") + b;
    },
        B = d.relativeLength = function (b, a, m) {
      return /%$/.test(b) ? a * parseFloat(b) / 100 + (m || 0) : parseFloat(b);
    },
        L = d.wrap = function (b, a, m) {
      var f = b[a];

      b[a] = function () {
        var b = Array.prototype.slice.call(arguments),
            a = arguments,
            c = this;

        c.proceed = function () {
          f.apply(c, arguments.length ? arguments : a);
        };

        b.unshift(f);
        b = m.apply(this, b);
        c.proceed = null;
        return b;
      };
    },
        Q = d.format = function (b, a, m) {
      var f = "{",
          c = !1,
          p = [],
          e = /f$/,
          x = /\.([0-9])/,
          F = d.defaultOptions.lang,
          C = m && m.time || d.time;

      for (m = m && m.numberFormatter || T; b;) {
        var l = b.indexOf(f);
        if (-1 === l) break;
        var k = b.slice(0, l);

        if (c) {
          k = k.split(":");
          f = r(k.shift() || "", a);
          if (k.length && "number" === typeof f) if (k = k.join(":"), e.test(k)) {
            var n = parseInt((k.match(x) || ["", "-1"])[1], 10);
            null !== f && (f = m(f, n, F.decimalPoint, -1 < k.indexOf(",") ? F.thousandsSep : ""));
          } else f = C.dateFormat(k, f);
          p.push(f);
        } else p.push(k);

        b = b.slice(l + 1);
        f = (c = !c) ? "}" : "{";
      }

      p.push(b);
      return p.join("");
    },
        H = d.getMagnitude = function (b) {
      return Math.pow(10, Math.floor(Math.log(b) / Math.LN10));
    },
        K = d.normalizeTickInterval = function (b, a, m, f, c) {
      var p = b;
      m = u(m, 1);
      var e = b / m;
      a || (a = c ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === f && (1 === m ? a = a.filter(function (b) {
        return 0 === b % 1;
      }) : .1 >= m && (a = [1 / m])));

      for (f = 0; f < a.length && !(p = a[f], c && p * m >= b || !c && e <= (a[f] + (a[f + 1] || a[f])) / 2); f++);

      return p = O(p * m, -Math.round(Math.log(.001) / Math.LN10));
    },
        p = d.stableSort = function (b, a) {
      var m = b.length,
          f,
          c;

      for (c = 0; c < m; c++) b[c].safeI = c;

      b.sort(function (b, m) {
        f = a(b, m);
        return 0 === f ? b.safeI - m.safeI : f;
      });

      for (c = 0; c < m; c++) delete b[c].safeI;
    },
        b = d.arrayMin = function (b) {
      for (var a = b.length, m = b[0]; a--;) b[a] < m && (m = b[a]);

      return m;
    },
        C = d.arrayMax = function (b) {
      for (var a = b.length, m = b[0]; a--;) b[a] > m && (m = b[a]);

      return m;
    },
        x = d.destroyObjectProperties = function (b, a) {
      Y(b, function (m, f) {
        m && m !== a && m.destroy && m.destroy();
        delete b[f];
      });
    },
        R = d.discardElement = function (b) {
      var a = d.garbageBin;
      a || (a = v("div"));
      b && a.appendChild(b);
      a.innerHTML = "";
    },
        O = d.correctFloat = function (b, a) {
      return parseFloat(b.toPrecision(a || 14));
    },
        X = d.setAnimation = function (b, a) {
      a.renderer.globalAnimation = u(b, a.options.chart.animation, !0);
    },
        U = d.animObject = function (b) {
      return h(b) ? g(b) : {
        duration: b ? 500 : 0
      };
    },
        m = d.timeUnits = {
      millisecond: 1,
      second: 1E3,
      minute: 6E4,
      hour: 36E5,
      day: 864E5,
      week: 6048E5,
      month: 24192E5,
      year: 314496E5
    },
        T = d.numberFormat = function (b, a, m, f) {
      b = +b || 0;
      a = +a;
      var c = d.defaultOptions.lang,
          p = (b.toString().split(".")[1] || "").split("e")[0].length,
          e = b.toString().split("e");
      if (-1 === a) a = Math.min(p, 20);else if (!P(a)) a = 2;else if (a && e[1] && 0 > e[1]) {
        var x = a + +e[1];
        0 <= x ? (e[0] = (+e[0]).toExponential(x).split("e")[0], a = x) : (e[0] = e[0].split(".")[0] || 0, b = 20 > a ? (e[0] * Math.pow(10, e[1])).toFixed(a) : 0, e[1] = 0);
      }
      var F = (Math.abs(e[1] ? e[0] : b) + Math.pow(10, -Math.max(a, p) - 1)).toFixed(a);
      p = String(y(F));
      x = 3 < p.length ? p.length % 3 : 0;
      m = u(m, c.decimalPoint);
      f = u(f, c.thousandsSep);
      b = (0 > b ? "-" : "") + (x ? p.substr(0, x) + f : "");
      b += p.substr(x).replace(/(\d{3})(?=\d)/g, "$1" + f);
      a && (b += m + F.slice(-a));
      e[1] && 0 !== +b && (b += "e" + e[1]);
      return b;
    };

    Math.easeInOutSine = function (b) {
      return -.5 * (Math.cos(Math.PI * b) - 1);
    };

    var Z = d.getStyle = function (b, a, m) {
      if ("width" === a) return a = Math.min(b.offsetWidth, b.scrollWidth), m = b.getBoundingClientRect && b.getBoundingClientRect().width, m < a && m >= a - 1 && (a = Math.floor(m)), Math.max(0, a - d.getStyle(b, "padding-left") - d.getStyle(b, "padding-right"));
      if ("height" === a) return Math.max(0, Math.min(b.offsetHeight, b.scrollHeight) - d.getStyle(b, "padding-top") - d.getStyle(b, "padding-bottom"));
      A.getComputedStyle || G(27, !0);
      if (b = A.getComputedStyle(b, void 0)) b = b.getPropertyValue(a), u(m, "opacity" !== a) && (b = y(b));
      return b;
    },
        ca = d.inArray = function (b, a, m) {
      return a.indexOf(b, m);
    },
        F = d.find = Array.prototype.find ? function (b, a) {
      return b.find(a);
    } : function (b, a) {
      var m,
          f = b.length;

      for (m = 0; m < f; m++) if (a(b[m], m)) return b[m];
    };

    d.keys = Object.keys;

    var V = d.offset = function (b) {
      var a = E.documentElement;
      b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {
        top: 0,
        left: 0
      };
      return {
        top: b.top + (A.pageYOffset || a.scrollTop) - (a.clientTop || 0),
        left: b.left + (A.pageXOffset || a.scrollLeft) - (a.clientLeft || 0)
      };
    },
        ba = d.stop = function (b, a) {
      for (var m = d.timers.length; m--;) d.timers[m].elem !== b || a && a !== d.timers[m].prop || (d.timers[m].stopped = !0);
    },
        Y = d.objectEach = function (b, a, m) {
      for (var f in b) Object.hasOwnProperty.call(b, f) && a.call(m || b[f], b[f], f, b);
    };

    Y({
      map: "map",
      each: "forEach",
      grep: "filter",
      reduce: "reduce",
      some: "some"
    }, function (b, a) {
      d[a] = function (a) {
        return Array.prototype[b].apply(a, [].slice.call(arguments, 1));
      };
    });

    var fa = d.addEvent = function (b, a, m, f) {
      void 0 === f && (f = {});
      var c = b.addEventListener || d.addEventListenerPolyfill;
      var p = "function" === typeof b && b.prototype ? b.prototype.protoEvents = b.prototype.protoEvents || {} : b.hcEvents = b.hcEvents || {};
      d.Point && b instanceof d.Point && b.series && b.series.chart && (b.series.chart.runTrackerClick = !0);
      c && c.call(b, a, m, !1);
      p[a] || (p[a] = []);
      p[a].push({
        fn: m,
        order: "number" === typeof f.order ? f.order : Infinity
      });
      p[a].sort(function (b, a) {
        return b.order - a.order;
      });
      return function () {
        da(b, a, m);
      };
    },
        da = d.removeEvent = function (b, a, m) {
      function f(a, m) {
        var f = b.removeEventListener || d.removeEventListenerPolyfill;
        f && f.call(b, a, m, !1);
      }

      function c(m) {
        var c;

        if (b.nodeName) {
          if (a) {
            var p = {};
            p[a] = !0;
          } else p = m;

          Y(p, function (b, a) {
            if (m[a]) for (c = m[a].length; c--;) f(a, m[a][c].fn);
          });
        }
      }

      var p;
      ["protoEvents", "hcEvents"].forEach(function (e, x) {
        var F = (x = x ? b : b.prototype) && x[e];
        F && (a ? (p = F[a] || [], m ? (F[a] = p.filter(function (b) {
          return m !== b.fn;
        }), f(a, m)) : (c(F), F[a] = [])) : (c(F), x[e] = {}));
      });
    },
        ha = d.fireEvent = function (b, m, f, c) {
      var p;
      f = f || {};

      if (E.createEvent && (b.dispatchEvent || b.fireEvent)) {
        var e = E.createEvent("Events");
        e.initEvent(m, !0, !0);
        a(e, f);
        b.dispatchEvent ? b.dispatchEvent(e) : b.fireEvent(m, e);
      } else f.target || a(f, {
        preventDefault: function () {
          f.defaultPrevented = !0;
        },
        target: b,
        type: m
      }), function (a, m) {
        void 0 === a && (a = []);
        void 0 === m && (m = []);
        var c = 0,
            e = 0,
            x = a.length + m.length;

        for (p = 0; p < x; p++) !1 === (a[c] ? m[e] ? a[c].order <= m[e].order ? a[c++] : m[e++] : a[c++] : m[e++]).fn.call(b, f) && f.preventDefault();
      }(b.protoEvents && b.protoEvents[m], b.hcEvents && b.hcEvents[m]);

      c && !f.defaultPrevented && c.call(b, f);
    },
        ia = d.animate = function (b, a, m) {
      var f,
          c = "",
          p,
          e;

      if (!h(m)) {
        var x = arguments;
        m = {
          duration: x[2],
          easing: x[3],
          complete: x[4]
        };
      }

      P(m.duration) || (m.duration = 400);
      m.easing = "function" === typeof m.easing ? m.easing : Math[m.easing] || Math.easeInOutSine;
      m.curAnim = g(a);
      Y(a, function (x, F) {
        ba(b, F);
        e = new J(b, m, F);
        p = null;
        "d" === F ? (e.paths = e.initPath(b, b.d, a.d), e.toD = a.d, f = 0, p = 1) : b.attr ? f = b.attr(F) : (f = parseFloat(Z(b, F)) || 0, "opacity" !== F && (c = "px"));
        p || (p = x);
        p && p.match && p.match("px") && (p = p.replace(/px/g, ""));
        e.run(f, p, c);
      });
    },
        ja = d.seriesType = function (b, a, m, f, c) {
      var p = d.getOptions(),
          e = d.seriesTypes;
      p.plotOptions[b] = g(p.plotOptions[a], m);
      e[b] = z(e[a] || function () {}, f);
      e[b].prototype.type = b;
      c && (e[b].prototype.pointClass = z(d.Point, c));
      return e[b];
    },
        ea = d.uniqueKey = function () {
      var b = Math.random().toString(36).substring(2, 9),
          a = 0;
      return function () {
        return "highcharts-" + b + "-" + a++;
      };
    }(),
        ka = d.isFunction = function (b) {
      return "function" === typeof b;
    };

    A.jQuery && (A.jQuery.fn.highcharts = function () {
      var b = [].slice.call(arguments);
      if (this[0]) return b[0] ? (new d[t(b[0]) ? b.shift() : "Chart"](this[0], b[0], b[1]), this) : M[W(this[0], "data-highcharts-chart")];
    });
    return {
      Fx: J,
      addEvent: fa,
      animate: ia,
      animObject: U,
      arrayMax: C,
      arrayMin: b,
      attr: W,
      clamp: function (b, a, m) {
        return b > a ? b < m ? b : m : a;
      },
      clearTimeout: f,
      correctFloat: O,
      createElement: v,
      css: l,
      defined: c,
      destroyObjectProperties: x,
      discardElement: R,
      erase: e,
      error: G,
      extend: a,
      extendClass: z,
      find: F,
      fireEvent: ha,
      format: Q,
      getMagnitude: H,
      getNestedProperty: r,
      getStyle: Z,
      inArray: ca,
      isArray: D,
      isClass: q,
      isDOMElement: N,
      isFunction: ka,
      isNumber: P,
      isObject: h,
      isString: t,
      merge: g,
      normalizeTickInterval: K,
      numberFormat: T,
      objectEach: Y,
      offset: V,
      pad: w,
      pick: u,
      pInt: y,
      relativeLength: B,
      removeEvent: da,
      seriesType: ja,
      setAnimation: X,
      splat: k,
      stableSort: p,
      stop: ba,
      syncTimeout: n,
      timeUnits: m,
      uniqueKey: ea,
      wrap: L
    };
  });
  S(r, "parts/Color.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var W = g.isNumber,
        u = g.merge,
        r = g.pInt;

    g = function () {
      function d(g) {
        this.parsers = [{
          regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
          parse: function (d) {
            return [r(d[1]), r(d[2]), r(d[3]), parseFloat(d[4], 10)];
          }
        }, {
          regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
          parse: function (d) {
            return [r(d[1]), r(d[2]), r(d[3]), 1];
          }
        }];
        this.rgba = [];
        if (!(this instanceof d)) return new d(g);
        this.init(g);
      }

      d.parse = function (g) {
        return new d(g);
      };

      d.prototype.init = function (g) {
        var A, G;
        if ((this.input = g = d.names[g && g.toLowerCase ? g.toLowerCase() : ""] || g) && g.stops) this.stops = g.stops.map(function (t) {
          return new d(t[1]);
        });else {
          if (g && g.charAt && "#" === g.charAt()) {
            var u = g.length;
            g = parseInt(g.substr(1), 16);
            7 === u ? A = [(g & 16711680) >> 16, (g & 65280) >> 8, g & 255, 1] : 4 === u && (A = [(g & 3840) >> 4 | (g & 3840) >> 8, (g & 240) >> 4 | g & 240, (g & 15) << 4 | g & 15, 1]);
          }

          if (!A) for (G = this.parsers.length; G-- && !A;) {
            var y = this.parsers[G];
            (u = y.regex.exec(g)) && (A = y.parse(u));
          }
        }
        this.rgba = A || [];
      };

      d.prototype.get = function (d) {
        var g = this.input,
            G = this.rgba;

        if ("undefined" !== typeof this.stops) {
          var E = u(g);
          E.stops = [].concat(E.stops);
          this.stops.forEach(function (g, t) {
            E.stops[t] = [E.stops[t][0], g.get(d)];
          });
        } else E = G && W(G[0]) ? "rgb" === d || !d && 1 === G[3] ? "rgb(" + G[0] + "," + G[1] + "," + G[2] + ")" : "a" === d ? G[3] : "rgba(" + G.join(",") + ")" : g;

        return E;
      };

      d.prototype.brighten = function (d) {
        var g,
            u = this.rgba;
        if (this.stops) this.stops.forEach(function (g) {
          g.brighten(d);
        });else if (W(d) && 0 !== d) for (g = 0; 3 > g; g++) u[g] += r(255 * d), 0 > u[g] && (u[g] = 0), 255 < u[g] && (u[g] = 255);
        return this;
      };

      d.prototype.setOpacity = function (d) {
        this.rgba[3] = d;
        return this;
      };

      d.prototype.tweenTo = function (d, g) {
        var u = this.rgba,
            A = d.rgba;
        A.length && u && u.length ? (d = 1 !== A[3] || 1 !== u[3], g = (d ? "rgba(" : "rgb(") + Math.round(A[0] + (u[0] - A[0]) * (1 - g)) + "," + Math.round(A[1] + (u[1] - A[1]) * (1 - g)) + "," + Math.round(A[2] + (u[2] - A[2]) * (1 - g)) + (d ? "," + (A[3] + (u[3] - A[3]) * (1 - g)) : "") + ")") : g = d.input || "none";
        return g;
      };

      d.names = {
        white: "#ffffff",
        black: "#000000"
      };
      return d;
    }();

    d.Color = g;
    d.color = g.parse;
    return d.Color;
  });
  S(r, "parts/SvgRenderer.js", [r["parts/Globals.js"], r["parts/Color.js"], r["parts/Utilities.js"]], function (d, g, r) {
    var u = g.parse,
        I = r.addEvent,
        M = r.animate,
        E = r.animObject,
        A = r.attr,
        G = r.createElement,
        J = r.css,
        y = r.defined,
        t = r.destroyObjectProperties,
        D = r.erase,
        h = r.extend,
        N = r.inArray,
        q = r.isArray,
        P = r.isNumber,
        e = r.isObject,
        c = r.isString,
        k = r.merge,
        n = r.objectEach,
        f = r.pick,
        a = r.pInt,
        l = r.removeEvent,
        v = r.splat,
        z = r.stop,
        w = r.uniqueKey,
        B = d.charts,
        L = d.deg2rad,
        Q = d.doc,
        H = d.hasTouch,
        K = d.isFirefox,
        p = d.isMS,
        b = d.isWebKit,
        C = d.noop,
        x = d.svg,
        R = d.SVG_NS,
        O = d.symbolSizes,
        X = d.win;

    var U = d.SVGElement = function () {
      return this;
    };

    h(U.prototype, {
      opacity: 1,
      SVG_NS: R,
      textProps: "direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline cursor".split(" "),
      init: function (b, a) {
        this.element = "span" === a ? G(a) : Q.createElementNS(this.SVG_NS, a);
        this.renderer = b;
        d.fireEvent(this, "afterInit");
      },
      animate: function (b, a, c) {
        var m = E(f(a, this.renderer.globalAnimation, !0));
        f(Q.hidden, Q.msHidden, Q.webkitHidden, !1) && (m.duration = 0);
        0 !== m.duration ? (c && (m.complete = c), M(this, b, m)) : (this.attr(b, void 0, c), n(b, function (b, a) {
          m.step && m.step.call(this, b, {
            prop: a,
            pos: 1
          });
        }, this));
        return this;
      },
      complexColor: function (b, a, f) {
        var m = this.renderer,
            c,
            p,
            e,
            x,
            T,
            C,
            l,
            v,
            z,
            Z,
            O,
            R = [],
            B;
        d.fireEvent(this.renderer, "complexColor", {
          args: arguments
        }, function () {
          b.radialGradient ? p = "radialGradient" : b.linearGradient && (p = "linearGradient");
          p && (e = b[p], T = m.gradients, l = b.stops, Z = f.radialReference, q(e) && (b[p] = e = {
            x1: e[0],
            y1: e[1],
            x2: e[2],
            y2: e[3],
            gradientUnits: "userSpaceOnUse"
          }), "radialGradient" === p && Z && !y(e.gradientUnits) && (x = e, e = k(e, m.getRadialAttr(Z, x), {
            gradientUnits: "userSpaceOnUse"
          })), n(e, function (b, a) {
            "id" !== a && R.push(a, b);
          }), n(l, function (b) {
            R.push(b);
          }), R = R.join(","), T[R] ? O = T[R].attr("id") : (e.id = O = w(), T[R] = C = m.createElement(p).attr(e).add(m.defs), C.radAttr = x, C.stops = [], l.forEach(function (b) {
            0 === b[1].indexOf("rgba") ? (c = u(b[1]), v = c.get("rgb"), z = c.get("a")) : (v = b[1], z = 1);
            b = m.createElement("stop").attr({
              offset: b[0],
              "stop-color": v,
              "stop-opacity": z
            }).add(C);
            C.stops.push(b);
          })), B = "url(" + m.url + "#" + O + ")", f.setAttribute(a, B), f.gradient = R, b.toString = function () {
            return B;
          });
        });
      },
      applyTextOutline: function (b) {
        var a = this.element,
            m;
        -1 !== b.indexOf("contrast") && (b = b.replace(/contrast/g, this.renderer.getContrast(a.style.fill)));
        b = b.split(" ");
        var f = b[b.length - 1];

        if ((m = b[0]) && "none" !== m && d.svg) {
          this.fakeTS = !0;
          b = [].slice.call(a.getElementsByTagName("tspan"));
          this.ySetter = this.xSetter;
          m = m.replace(/(^[\d\.]+)(.*?)$/g, function (b, a, m) {
            return 2 * a + m;
          });
          this.removeTextOutline(b);
          var c = a.textContent ? /^[\u0591-\u065F\u066A-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC]/.test(a.textContent) : !1;
          var p = a.firstChild;
          b.forEach(function (b, e) {
            0 === e && (b.setAttribute("x", a.getAttribute("x")), e = a.getAttribute("y"), b.setAttribute("y", e || 0), null === e && a.setAttribute("y", 0));
            e = b.cloneNode(!0);
            A(c && !K ? b : e, {
              "class": "highcharts-text-outline",
              fill: f,
              stroke: f,
              "stroke-width": m,
              "stroke-linejoin": "round"
            });
            a.insertBefore(e, p);
          });
          c && K && b[0] && (b = b[0].cloneNode(!0), b.textContent = " ", a.insertBefore(b, p));
        }
      },
      removeTextOutline: function (b) {
        for (var a = b.length, m; a--;) m = b[a], "highcharts-text-outline" === m.getAttribute("class") && D(b, this.element.removeChild(m));
      },
      symbolCustomAttribs: "x y width height r start end innerR anchorX anchorY rounded".split(" "),
      attr: function (b, a, f, c) {
        var m = this.element,
            p,
            e = this,
            x,
            C,
            l = this.symbolCustomAttribs;

        if ("string" === typeof b && "undefined" !== typeof a) {
          var T = b;
          b = {};
          b[T] = a;
        }

        "string" === typeof b ? e = (this[b + "Getter"] || this._defaultGetter).call(this, b, m) : (n(b, function (a, f) {
          x = !1;
          c || z(this, f);
          this.symbolName && -1 !== N(f, l) && (p || (this.symbolAttr(b), p = !0), x = !0);
          !this.rotation || "x" !== f && "y" !== f || (this.doTransform = !0);
          x || (C = this[f + "Setter"] || this._defaultSetter, C.call(this, a, f, m), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(f) && this.updateShadows(f, a, C));
        }, this), this.afterSetters());
        f && f.call(this);
        return e;
      },
      afterSetters: function () {
        this.doTransform && (this.updateTransform(), this.doTransform = !1);
      },
      updateShadows: function (b, a, f) {
        for (var m = this.shadows, c = m.length; c--;) f.call(m[c], "height" === b ? Math.max(a - (m[c].cutHeight || 0), 0) : "d" === b ? this.d : a, b, m[c]);
      },
      addClass: function (b, a) {
        var m = a ? "" : this.attr("class") || "";
        b = (b || "").split(/ /g).reduce(function (b, a) {
          -1 === m.indexOf(a) && b.push(a);
          return b;
        }, m ? [m] : []).join(" ");
        b !== m && this.attr("class", b);
        return this;
      },
      hasClass: function (b) {
        return -1 !== (this.attr("class") || "").split(" ").indexOf(b);
      },
      removeClass: function (b) {
        return this.attr("class", (this.attr("class") || "").replace(c(b) ? new RegExp(" ?" + b + " ?") : b, ""));
      },
      symbolAttr: function (b) {
        var a = this;
        "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (m) {
          a[m] = f(b[m], a[m]);
        });
        a.attr({
          d: a.renderer.symbols[a.symbolName](a.x, a.y, a.width, a.height, a)
        });
      },
      clip: function (b) {
        return this.attr("clip-path", b ? "url(" + this.renderer.url + "#" + b.id + ")" : "none");
      },
      crisp: function (b, a) {
        a = a || b.strokeWidth || 0;
        var m = Math.round(a) % 2 / 2;
        b.x = Math.floor(b.x || this.x || 0) + m;
        b.y = Math.floor(b.y || this.y || 0) + m;
        b.width = Math.floor((b.width || this.width || 0) - 2 * m);
        b.height = Math.floor((b.height || this.height || 0) - 2 * m);
        y(b.strokeWidth) && (b.strokeWidth = a);
        return b;
      },
      css: function (b) {
        var m = this.styles,
            f = {},
            c = this.element,
            p = "",
            e = !m,
            C = ["textOutline", "textOverflow", "width"];
        b && b.color && (b.fill = b.color);
        m && n(b, function (b, a) {
          b !== m[a] && (f[a] = b, e = !0);
        });

        if (e) {
          m && (b = h(m, f));
          if (b) if (null === b.width || "auto" === b.width) delete this.textWidth;else if ("text" === c.nodeName.toLowerCase() && b.width) var l = this.textWidth = a(b.width);
          this.styles = b;
          l && !x && this.renderer.forExport && delete b.width;

          if (c.namespaceURI === this.SVG_NS) {
            var k = function (b, a) {
              return "-" + a.toLowerCase();
            };

            n(b, function (b, a) {
              -1 === C.indexOf(a) && (p += a.replace(/([A-Z])/g, k) + ":" + b + ";");
            });
            p && A(c, "style", p);
          } else J(c, b);

          this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), b && b.textOutline && this.applyTextOutline(b.textOutline));
        }

        return this;
      },
      getStyle: function (b) {
        return X.getComputedStyle(this.element || this, "").getPropertyValue(b);
      },
      strokeWidth: function () {
        if (!this.renderer.styledMode) return this["stroke-width"] || 0;
        var b = this.getStyle("stroke-width"),
            f = 0;
        if (b.indexOf("px") === b.length - 2) f = a(b);else if ("" !== b) {
          var c = Q.createElementNS(R, "rect");
          A(c, {
            width: b,
            "stroke-width": 0
          });
          this.element.parentNode.appendChild(c);
          f = c.getBBox().width;
          c.parentNode.removeChild(c);
        }
        return f;
      },
      on: function (b, a) {
        var m,
            f,
            c = this.element,
            p;
        H && "click" === b ? (c.ontouchstart = function (b) {
          m = b.touches[0].clientX;
          f = b.touches[0].clientY;
        }, c.ontouchend = function (b) {
          m && 4 <= Math.sqrt(Math.pow(m - b.changedTouches[0].clientX, 2) + Math.pow(f - b.changedTouches[0].clientY, 2)) || a.call(c, b);
          p = !0;
          b.preventDefault();
        }, c.onclick = function (b) {
          p || a.call(c, b);
        }) : c["on" + b] = a;
        return this;
      },
      setRadialReference: function (b) {
        var a = this.renderer.gradients[this.element.gradient];
        this.element.radialReference = b;
        a && a.radAttr && a.animate(this.renderer.getRadialAttr(b, a.radAttr));
        return this;
      },
      translate: function (b, a) {
        return this.attr({
          translateX: b,
          translateY: a
        });
      },
      invert: function (b) {
        this.inverted = b;
        this.updateTransform();
        return this;
      },
      updateTransform: function () {
        var b = this.translateX || 0,
            a = this.translateY || 0,
            c = this.scaleX,
            p = this.scaleY,
            e = this.inverted,
            x = this.rotation,
            C = this.matrix,
            l = this.element;
        e && (b += this.width, a += this.height);
        b = ["translate(" + b + "," + a + ")"];
        y(C) && b.push("matrix(" + C.join(",") + ")");
        e ? b.push("rotate(90) scale(-1,1)") : x && b.push("rotate(" + x + " " + f(this.rotationOriginX, l.getAttribute("x"), 0) + " " + f(this.rotationOriginY, l.getAttribute("y") || 0) + ")");
        (y(c) || y(p)) && b.push("scale(" + f(c, 1) + " " + f(p, 1) + ")");
        b.length && l.setAttribute("transform", b.join(" "));
      },
      toFront: function () {
        var b = this.element;
        b.parentNode.appendChild(b);
        return this;
      },
      align: function (b, a, p) {
        var m,
            e = {};
        var x = this.renderer;
        var C = x.alignedObjects;
        var l, k;

        if (b) {
          if (this.alignOptions = b, this.alignByTranslate = a, !p || c(p)) this.alignTo = m = p || "renderer", D(C, this), C.push(this), p = null;
        } else b = this.alignOptions, a = this.alignByTranslate, m = this.alignTo;

        p = f(p, x[m], x);
        m = b.align;
        x = b.verticalAlign;
        C = (p.x || 0) + (b.x || 0);
        var T = (p.y || 0) + (b.y || 0);
        "right" === m ? l = 1 : "center" === m && (l = 2);
        l && (C += (p.width - (b.width || 0)) / l);
        e[a ? "translateX" : "x"] = Math.round(C);
        "bottom" === x ? k = 1 : "middle" === x && (k = 2);
        k && (T += (p.height - (b.height || 0)) / k);
        e[a ? "translateY" : "y"] = Math.round(T);
        this[this.placed ? "animate" : "attr"](e);
        this.placed = !0;
        this.alignAttr = e;
        return this;
      },
      getBBox: function (b, a) {
        var m,
            c = this.renderer,
            p = this.element,
            e = this.styles,
            x = this.textStr,
            C,
            l = c.cache,
            k = c.cacheKeys,
            T = p.namespaceURI === this.SVG_NS;
        a = f(a, this.rotation, 0);
        var n = c.styledMode ? p && U.prototype.getStyle.call(p, "font-size") : e && e.fontSize;

        if (y(x)) {
          var v = x.toString();
          -1 === v.indexOf("<") && (v = v.replace(/[0-9]/g, "0"));
          v += ["", a, n, this.textWidth, e && e.textOverflow].join();
        }

        v && !b && (m = l[v]);

        if (!m) {
          if (T || c.forExport) {
            try {
              (C = this.fakeTS && function (b) {
                [].forEach.call(p.querySelectorAll(".highcharts-text-outline"), function (a) {
                  a.style.display = b;
                });
              }) && C("none"), m = p.getBBox ? h({}, p.getBBox()) : {
                width: p.offsetWidth,
                height: p.offsetHeight
              }, C && C("");
            } catch (ea) {
              "";
            }

            if (!m || 0 > m.width) m = {
              width: 0,
              height: 0
            };
          } else m = this.htmlGetBBox();

          c.isSVG && (b = m.width, c = m.height, T && (m.height = c = {
            "11px,17": 14,
            "13px,20": 16
          }[e && e.fontSize + "," + Math.round(c)] || c), a && (e = a * L, m.width = Math.abs(c * Math.sin(e)) + Math.abs(b * Math.cos(e)), m.height = Math.abs(c * Math.cos(e)) + Math.abs(b * Math.sin(e))));

          if (v && 0 < m.height) {
            for (; 250 < k.length;) delete l[k.shift()];

            l[v] || k.push(v);
            l[v] = m;
          }
        }

        return m;
      },
      show: function (b) {
        return this.attr({
          visibility: b ? "inherit" : "visible"
        });
      },
      hide: function (b) {
        b ? this.attr({
          y: -9999
        }) : this.attr({
          visibility: "hidden"
        });
        return this;
      },
      fadeOut: function (b) {
        var a = this;
        a.animate({
          opacity: 0
        }, {
          duration: b || 150,
          complete: function () {
            a.attr({
              y: -9999
            });
          }
        });
      },
      add: function (b) {
        var a = this.renderer,
            m = this.element;
        b && (this.parentGroup = b);
        this.parentInverted = b && b.inverted;
        "undefined" !== typeof this.textStr && a.buildText(this);
        this.added = !0;
        if (!b || b.handleZ || this.zIndex) var f = this.zIndexSetter();
        f || (b ? b.element : a.box).appendChild(m);
        if (this.onAdd) this.onAdd();
        return this;
      },
      safeRemoveChild: function (b) {
        var a = b.parentNode;
        a && a.removeChild(b);
      },
      destroy: function () {
        var b = this,
            a = b.element || {},
            f = b.renderer,
            c = f.isSVG && "SPAN" === a.nodeName && b.parentGroup,
            p = a.ownerSVGElement,
            e = b.clipPath;
        a.onclick = a.onmouseout = a.onmouseover = a.onmousemove = a.point = null;
        z(b);
        e && p && ([].forEach.call(p.querySelectorAll("[clip-path],[CLIP-PATH]"), function (b) {
          -1 < b.getAttribute("clip-path").indexOf(e.element.id) && b.removeAttribute("clip-path");
        }), b.clipPath = e.destroy());

        if (b.stops) {
          for (p = 0; p < b.stops.length; p++) b.stops[p] = b.stops[p].destroy();

          b.stops = null;
        }

        b.safeRemoveChild(a);

        for (f.styledMode || b.destroyShadows(); c && c.div && 0 === c.div.childNodes.length;) a = c.parentGroup, b.safeRemoveChild(c.div), delete c.div, c = a;

        b.alignTo && D(f.alignedObjects, b);
        n(b, function (a, m) {
          b[m] && b[m].parentGroup === b && b[m].destroy && b[m].destroy();
          delete b[m];
        });
      },
      shadow: function (b, a, c) {
        var m = [],
            p,
            e = this.element;
        if (!b) this.destroyShadows();else if (!this.shadows) {
          var x = f(b.width, 3);
          var C = (b.opacity || .15) / x;
          var l = this.parentInverted ? "(-1,-1)" : "(" + f(b.offsetX, 1) + ", " + f(b.offsetY, 1) + ")";

          for (p = 1; p <= x; p++) {
            var k = e.cloneNode(0);
            var n = 2 * x + 1 - 2 * p;
            A(k, {
              stroke: b.color || "#000000",
              "stroke-opacity": C * p,
              "stroke-width": n,
              transform: "translate" + l,
              fill: "none"
            });
            k.setAttribute("class", (k.getAttribute("class") || "") + " highcharts-shadow");
            c && (A(k, "height", Math.max(A(k, "height") - n, 0)), k.cutHeight = n);
            a ? a.element.appendChild(k) : e.parentNode && e.parentNode.insertBefore(k, e);
            m.push(k);
          }

          this.shadows = m;
        }
        return this;
      },
      destroyShadows: function () {
        (this.shadows || []).forEach(function (b) {
          this.safeRemoveChild(b);
        }, this);
        this.shadows = void 0;
      },
      xGetter: function (b) {
        "circle" === this.element.nodeName && ("x" === b ? b = "cx" : "y" === b && (b = "cy"));
        return this._defaultGetter(b);
      },
      _defaultGetter: function (b) {
        b = f(this[b + "Value"], this[b], this.element ? this.element.getAttribute(b) : null, 0);
        /^[\-0-9\.]+$/.test(b) && (b = parseFloat(b));
        return b;
      },
      dSetter: function (b, a, f) {
        b && b.join && (b = b.join(" "));
        /(NaN| {2}|^$)/.test(b) && (b = "M 0 0");
        this[a] !== b && (f.setAttribute(a, b), this[a] = b);
      },
      dashstyleSetter: function (b) {
        var f,
            c = this["stroke-width"];
        "inherit" === c && (c = 1);

        if (b = b && b.toLowerCase()) {
          b = b.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");

          for (f = b.length; f--;) b[f] = a(b[f]) * c;

          b = b.join(",").replace(/NaN/g, "none");
          this.element.setAttribute("stroke-dasharray", b);
        }
      },
      alignSetter: function (b) {
        var a = {
          left: "start",
          center: "middle",
          right: "end"
        };
        a[b] && (this.alignValue = b, this.element.setAttribute("text-anchor", a[b]));
      },
      opacitySetter: function (b, a, f) {
        this[a] = b;
        f.setAttribute(a, b);
      },
      titleSetter: function (b) {
        var a = this.element.getElementsByTagName("title")[0];
        a || (a = Q.createElementNS(this.SVG_NS, "title"), this.element.appendChild(a));
        a.firstChild && a.removeChild(a.firstChild);
        a.appendChild(Q.createTextNode(String(f(b, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">")));
      },
      textSetter: function (b) {
        b !== this.textStr && (delete this.bBox, delete this.textPxLength, this.textStr = b, this.added && this.renderer.buildText(this));
      },
      setTextPath: function (b, a) {
        var f = this.element,
            c = {
          textAnchor: "text-anchor"
        },
            m = !1,
            p = this.textPathWrapper,
            e = !p;
        a = k(!0, {
          enabled: !0,
          attributes: {
            dy: -5,
            startOffset: "50%",
            textAnchor: "middle"
          }
        }, a);
        var x = a.attributes;

        if (b && a && a.enabled) {
          p && null === p.element.parentNode ? (e = !0, p = p.destroy()) : p && this.removeTextOutline.call(p.parentGroup, [].slice.call(f.getElementsByTagName("tspan")));
          this.options && this.options.padding && (x.dx = -this.options.padding);
          p || (this.textPathWrapper = p = this.renderer.createElement("textPath"), m = !0);
          var l = p.element;
          (a = b.element.getAttribute("id")) || b.element.setAttribute("id", a = w());
          if (e) for (b = f.getElementsByTagName("tspan"); b.length;) b[0].setAttribute("y", 0), P(x.dx) && b[0].setAttribute("x", -x.dx), l.appendChild(b[0]);
          m && p.add({
            element: this.text ? this.text.element : f
          });
          l.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + a);
          y(x.dy) && (l.parentNode.setAttribute("dy", x.dy), delete x.dy);
          y(x.dx) && (l.parentNode.setAttribute("dx", x.dx), delete x.dx);
          n(x, function (b, a) {
            l.setAttribute(c[a] || a, b);
          });
          f.removeAttribute("transform");
          this.removeTextOutline.call(p, [].slice.call(f.getElementsByTagName("tspan")));
          this.text && !this.renderer.styledMode && this.attr({
            fill: "none",
            "stroke-width": 0
          });
          this.applyTextOutline = this.updateTransform = C;
        } else p && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(f, b), this.updateTransform(), this.options.rotation && this.applyTextOutline(this.options.style.textOutline));

        return this;
      },
      destroyTextPath: function (b, a) {
        var f = b.getElementsByTagName("text")[0];

        if (f) {
          if (f.removeAttribute("dx"), f.removeAttribute("dy"), a.element.setAttribute("id", ""), f.getElementsByTagName("textPath").length) {
            for (b = this.textPathWrapper.element.childNodes; b.length;) f.appendChild(b[0]);

            f.removeChild(this.textPathWrapper.element);
          }
        } else if (b.getAttribute("dx") || b.getAttribute("dy")) b.removeAttribute("dx"), b.removeAttribute("dy");

        this.textPathWrapper = this.textPathWrapper.destroy();
      },
      fillSetter: function (b, a, f) {
        "string" === typeof b ? f.setAttribute(a, b) : b && this.complexColor(b, a, f);
      },
      visibilitySetter: function (b, a, f) {
        "inherit" === b ? f.removeAttribute(a) : this[a] !== b && f.setAttribute(a, b);
        this[a] = b;
      },
      zIndexSetter: function (b, f) {
        var c = this.renderer,
            m = this.parentGroup,
            p = (m || c).element || c.box,
            e = this.element,
            x = !1;
        c = p === c.box;
        var C = this.added;
        var l;
        y(b) ? (e.setAttribute("data-z-index", b), b = +b, this[f] === b && (C = !1)) : y(this[f]) && e.removeAttribute("data-z-index");
        this[f] = b;

        if (C) {
          (b = this.zIndex) && m && (m.handleZ = !0);
          f = p.childNodes;

          for (l = f.length - 1; 0 <= l && !x; l--) {
            m = f[l];
            C = m.getAttribute("data-z-index");
            var k = !y(C);
            if (m !== e) if (0 > b && k && !c && !l) p.insertBefore(e, f[l]), x = !0;else if (a(C) <= b || k && (!y(b) || 0 <= b)) p.insertBefore(e, f[l + 1] || null), x = !0;
          }

          x || (p.insertBefore(e, f[c ? 3 : 0] || null), x = !0);
        }

        return x;
      },
      _defaultSetter: function (b, a, f) {
        f.setAttribute(a, b);
      }
    });
    U.prototype.yGetter = U.prototype.xGetter;

    U.prototype.translateXSetter = U.prototype.translateYSetter = U.prototype.rotationSetter = U.prototype.verticalAlignSetter = U.prototype.rotationOriginXSetter = U.prototype.rotationOriginYSetter = U.prototype.scaleXSetter = U.prototype.scaleYSetter = U.prototype.matrixSetter = function (b, a) {
      this[a] = b;
      this.doTransform = !0;
    };

    U.prototype["stroke-widthSetter"] = U.prototype.strokeSetter = function (b, a, f) {
      this[a] = b;
      this.stroke && this["stroke-width"] ? (U.prototype.fillSetter.call(this, this.stroke, "stroke", f), f.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === a && 0 === b && this.hasStroke ? (f.removeAttribute("stroke"), this.hasStroke = !1) : this.renderer.styledMode && this["stroke-width"] && (f.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0);
    };

    g = d.SVGRenderer = function () {
      this.init.apply(this, arguments);
    };

    h(g.prototype, {
      Element: U,
      SVG_NS: R,
      init: function (a, f, c, p, e, x, C) {
        var m = this.createElement("svg").attr({
          version: "1.1",
          "class": "highcharts-root"
        });
        C || m.css(this.getStyle(p));
        p = m.element;
        a.appendChild(p);
        A(a, "dir", "ltr");
        -1 === a.innerHTML.indexOf("xmlns") && A(p, "xmlns", this.SVG_NS);
        this.isSVG = !0;
        this.box = p;
        this.boxWrapper = m;
        this.alignedObjects = [];
        this.url = (K || b) && Q.getElementsByTagName("base").length ? X.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "";
        this.createElement("desc").add().element.appendChild(Q.createTextNode("Created with Highcharts 8.0.4"));
        this.defs = this.createElement("defs").add();
        this.allowHTML = x;
        this.forExport = e;
        this.styledMode = C;
        this.gradients = {};
        this.cache = {};
        this.cacheKeys = [];
        this.imgCount = 0;
        this.setSize(f, c, !1);
        var l;
        K && a.getBoundingClientRect && (f = function () {
          J(a, {
            left: 0,
            top: 0
          });
          l = a.getBoundingClientRect();
          J(a, {
            left: Math.ceil(l.left) - l.left + "px",
            top: Math.ceil(l.top) - l.top + "px"
          });
        }, f(), this.unSubPixelFix = I(X, "resize", f));
      },
      definition: function (b) {
        function a(b, c) {
          var p;
          v(b).forEach(function (b) {
            var m = f.createElement(b.tagName),
                e = {};
            n(b, function (b, a) {
              "tagName" !== a && "children" !== a && "textContent" !== a && (e[a] = b);
            });
            m.attr(e);
            m.add(c || f.defs);
            b.textContent && m.element.appendChild(Q.createTextNode(b.textContent));
            a(b.children || [], m);
            p = m;
          });
          return p;
        }

        var f = this;
        return a(b);
      },
      getStyle: function (b) {
        return this.style = h({
          fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
          fontSize: "12px"
        }, b);
      },
      setStyle: function (b) {
        this.boxWrapper.css(this.getStyle(b));
      },
      isHidden: function () {
        return !this.boxWrapper.getBBox().width;
      },
      destroy: function () {
        var b = this.defs;
        this.box = null;
        this.boxWrapper = this.boxWrapper.destroy();
        t(this.gradients || {});
        this.gradients = null;
        b && (this.defs = b.destroy());
        this.unSubPixelFix && this.unSubPixelFix();
        return this.alignedObjects = null;
      },
      createElement: function (b) {
        var a = new this.Element();
        a.init(this, b);
        return a;
      },
      draw: C,
      getRadialAttr: function (b, a) {
        return {
          cx: b[0] - b[2] / 2 + a.cx * b[2],
          cy: b[1] - b[2] / 2 + a.cy * b[2],
          r: a.r * b[2]
        };
      },
      truncate: function (b, a, f, c, p, e, x) {
        var m = this,
            C = b.rotation,
            l,
            k = c ? 1 : 0,
            F = (f || c).length,
            n = F,
            v = [],
            w = function (b) {
          a.firstChild && a.removeChild(a.firstChild);
          b && a.appendChild(Q.createTextNode(b));
        },
            z = function (e, l) {
          l = l || e;
          if ("undefined" === typeof v[l]) if (a.getSubStringLength) try {
            v[l] = p + a.getSubStringLength(0, c ? l + 1 : l);
          } catch (la) {
            "";
          } else m.getSpanWidth && (w(x(f || c, e)), v[l] = p + m.getSpanWidth(b, a));
          return v[l];
        },
            O;

        b.rotation = 0;
        var T = z(a.textContent.length);

        if (O = p + T > e) {
          for (; k <= F;) n = Math.ceil((k + F) / 2), c && (l = x(c, n)), T = z(n, l && l.length - 1), k === F ? k = F + 1 : T > e ? F = n - 1 : k = n;

          0 === F ? w("") : f && F === f.length - 1 || w(l || x(f || c, n));
        }

        c && c.splice(0, n);
        b.actualWidth = T;
        b.rotation = C;
        return O;
      },
      escapes: {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "'": "&#39;",
        '"': "&quot;"
      },
      buildText: function (b) {
        var c = b.element,
            p = this,
            e = p.forExport,
            m = f(b.textStr, "").toString(),
            l = -1 !== m.indexOf("<"),
            C = c.childNodes,
            k,
            v = A(c, "x"),
            w = b.styles,
            z = b.textWidth,
            O = w && w.lineHeight,
            q = w && w.textOutline,
            B = w && "ellipsis" === w.textOverflow,
            d = w && "nowrap" === w.whiteSpace,
            N = w && w.fontSize,
            X,
            h = C.length;
        w = z && !b.added && this.box;

        var L = function (b) {
          var f;
          p.styledMode || (f = /(px|em)$/.test(b && b.style.fontSize) ? b.style.fontSize : N || p.style.fontSize || 12);
          return O ? a(O) : p.fontMetrics(f, b.getAttribute("style") ? b : c).h;
        },
            t = function (b, a) {
          n(p.escapes, function (f, c) {
            a && -1 !== a.indexOf(f) || (b = b.toString().replace(new RegExp(f, "g"), c));
          });
          return b;
        },
            U = function (b, a) {
          var f = b.indexOf("<");
          b = b.substring(f, b.indexOf(">") - f);
          f = b.indexOf(a + "=");
          if (-1 !== f && (f = f + a.length + 1, a = b.charAt(f), '"' === a || "'" === a)) return b = b.substring(f + 1), b.substring(0, b.indexOf(a));
        },
            P = /<br.*?>/g;

        var g = [m, B, d, O, q, N, z].join();

        if (g !== b.textCache) {
          for (b.textCache = g; h--;) c.removeChild(C[h]);

          l || q || B || z || -1 !== m.indexOf(" ") && (!d || P.test(m)) ? (w && w.appendChild(c), l ? (m = p.styledMode ? m.replace(/<(b|strong)>/g, '<span class="highcharts-strong">').replace(/<(i|em)>/g, '<span class="highcharts-emphasized">') : m.replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">'), m = m.replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(P)) : m = [m], m = m.filter(function (b) {
            return "" !== b;
          }), m.forEach(function (a, f) {
            var m = 0,
                l = 0;
            a = a.replace(/^\s+|\s+$/g, "").replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||");
            var C = a.split("|||");
            C.forEach(function (a) {
              if ("" !== a || 1 === C.length) {
                var n = {},
                    F = Q.createElementNS(p.SVG_NS, "tspan"),
                    w,
                    O;
                (w = U(a, "class")) && A(F, "class", w);
                if (w = U(a, "style")) w = w.replace(/(;| |^)color([ :])/, "$1fill$2"), A(F, "style", w);
                (O = U(a, "href")) && !e && (A(F, "onclick", 'location.href="' + O + '"'), A(F, "class", "highcharts-anchor"), p.styledMode || J(F, {
                  cursor: "pointer"
                }));
                a = t(a.replace(/<[a-zA-Z\/](.|\n)*?>/g, "") || " ");

                if (" " !== a) {
                  F.appendChild(Q.createTextNode(a));
                  m ? n.dx = 0 : f && null !== v && (n.x = v);
                  A(F, n);
                  c.appendChild(F);
                  !m && X && (!x && e && J(F, {
                    display: "block"
                  }), A(F, "dy", L(F)));

                  if (z) {
                    var q = a.replace(/([^\^])-/g, "$1- ").split(" ");
                    n = !d && (1 < C.length || f || 1 < q.length);
                    O = 0;
                    var T = L(F);
                    if (B) k = p.truncate(b, F, a, void 0, 0, Math.max(0, z - parseInt(N || 12, 10)), function (b, a) {
                      return b.substring(0, a) + "\u2026";
                    });else if (n) for (; q.length;) q.length && !d && 0 < O && (F = Q.createElementNS(R, "tspan"), A(F, {
                      dy: T,
                      x: v
                    }), w && A(F, "style", w), F.appendChild(Q.createTextNode(q.join(" ").replace(/- /g, "-"))), c.appendChild(F)), p.truncate(b, F, null, q, 0 === O ? l : 0, z, function (b, a) {
                      return q.slice(0, a).join(" ").replace(/- /g, "-");
                    }), l = b.actualWidth, O++;
                  }

                  m++;
                }
              }
            });
            X = X || c.childNodes.length;
          }), B && k && b.attr("title", t(b.textStr, ["&lt;", "&gt;"])), w && w.removeChild(c), q && b.applyTextOutline && b.applyTextOutline(q)) : c.appendChild(Q.createTextNode(t(m)));
        }
      },
      getContrast: function (b) {
        b = u(b).rgba;
        b[0] *= 1;
        b[1] *= 1.2;
        b[2] *= .5;
        return 459 < b[0] + b[1] + b[2] ? "#000000" : "#FFFFFF";
      },
      button: function (b, a, f, c, e, x, l, C, n, w) {
        var m = this.label(b, a, f, n, null, null, w, null, "button"),
            F = 0,
            v = this.styledMode;
        m.attr(k({
          padding: 8,
          r: 2
        }, e));

        if (!v) {
          e = k({
            fill: "#f7f7f7",
            stroke: "#cccccc",
            "stroke-width": 1,
            style: {
              color: "#333333",
              cursor: "pointer",
              fontWeight: "normal"
            }
          }, e);
          var z = e.style;
          delete e.style;
          x = k(e, {
            fill: "#e6e6e6"
          }, x);
          var O = x.style;
          delete x.style;
          l = k(e, {
            fill: "#e6ebf5",
            style: {
              color: "#000000",
              fontWeight: "bold"
            }
          }, l);
          var q = l.style;
          delete l.style;
          C = k(e, {
            style: {
              color: "#cccccc"
            }
          }, C);
          var R = C.style;
          delete C.style;
        }

        I(m.element, p ? "mouseover" : "mouseenter", function () {
          3 !== F && m.setState(1);
        });
        I(m.element, p ? "mouseout" : "mouseleave", function () {
          3 !== F && m.setState(F);
        });

        m.setState = function (b) {
          1 !== b && (m.state = F = b);
          m.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][b || 0]);
          v || m.attr([e, x, l, C][b || 0]).css([z, O, q, R][b || 0]);
        };

        v || m.attr(e).css(h({
          cursor: "default"
        }, z));
        return m.on("click", function (b) {
          3 !== F && c.call(m, b);
        });
      },
      crispLine: function (b, a) {
        b[1] === b[4] && (b[1] = b[4] = Math.round(b[1]) - a % 2 / 2);
        b[2] === b[5] && (b[2] = b[5] = Math.round(b[2]) + a % 2 / 2);
        return b;
      },
      path: function (b) {
        var a = this.styledMode ? {} : {
          fill: "none"
        };
        q(b) ? a.d = b : e(b) && h(a, b);
        return this.createElement("path").attr(a);
      },
      circle: function (b, a, f) {
        b = e(b) ? b : "undefined" === typeof b ? {} : {
          x: b,
          y: a,
          r: f
        };
        a = this.createElement("circle");

        a.xSetter = a.ySetter = function (b, a, f) {
          f.setAttribute("c" + a, b);
        };

        return a.attr(b);
      },
      arc: function (b, a, f, c, p, x) {
        e(b) ? (c = b, a = c.y, f = c.r, b = c.x) : c = {
          innerR: c,
          start: p,
          end: x
        };
        b = this.symbol("arc", b, a, f, f, c);
        b.r = f;
        return b;
      },
      rect: function (b, a, f, c, p, x) {
        p = e(b) ? b.r : p;
        var m = this.createElement("rect");
        b = e(b) ? b : "undefined" === typeof b ? {} : {
          x: b,
          y: a,
          width: Math.max(f, 0),
          height: Math.max(c, 0)
        };
        this.styledMode || ("undefined" !== typeof x && (b.strokeWidth = x, b = m.crisp(b)), b.fill = "none");
        p && (b.r = p);

        m.rSetter = function (b, a, f) {
          m.r = b;
          A(f, {
            rx: b,
            ry: b
          });
        };

        m.rGetter = function () {
          return m.r;
        };

        return m.attr(b);
      },
      setSize: function (b, a, c) {
        var p = this.alignedObjects,
            e = p.length;
        this.width = b;
        this.height = a;

        for (this.boxWrapper.animate({
          width: b,
          height: a
        }, {
          step: function () {
            this.attr({
              viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
            });
          },
          duration: f(c, !0) ? void 0 : 0
        }); e--;) p[e].align();
      },
      g: function (b) {
        var a = this.createElement("g");
        return b ? a.attr({
          "class": "highcharts-" + b
        }) : a;
      },
      image: function (b, a, f, c, p, e) {
        var x = {
          preserveAspectRatio: "none"
        },
            m = function (b, a) {
          b.setAttributeNS ? b.setAttributeNS("http://www.w3.org/1999/xlink", "href", a) : b.setAttribute("hc-svg-href", a);
        },
            l = function (a) {
          m(C.element, b);
          e.call(C, a);
        };

        1 < arguments.length && h(x, {
          x: a,
          y: f,
          width: c,
          height: p
        });
        var C = this.createElement("image").attr(x);
        e ? (m(C.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), x = new X.Image(), I(x, "load", l), x.src = b, x.complete && l({})) : m(C.element, b);
        return C;
      },
      symbol: function (b, a, c, p, e, x) {
        var m = this,
            l = /^url\((.*?)\)$/,
            C = l.test(b),
            k = !C && (this.symbols[b] ? b : "circle"),
            n = k && this.symbols[k],
            F = y(a) && n && n.call(this.symbols, Math.round(a), Math.round(c), p, e, x);

        if (n) {
          var w = this.path(F);
          m.styledMode || w.attr("fill", "none");
          h(w, {
            symbolName: k,
            x: a,
            y: c,
            width: p,
            height: e
          });
          x && h(w, x);
        } else if (C) {
          var v = b.match(l)[1];
          w = this.image(v);
          w.imgwidth = f(O[v] && O[v].width, x && x.width);
          w.imgheight = f(O[v] && O[v].height, x && x.height);

          var z = function () {
            w.attr({
              width: w.width,
              height: w.height
            });
          };

          ["width", "height"].forEach(function (b) {
            w[b + "Setter"] = function (b, a) {
              var f = {},
                  c = this["img" + a],
                  p = "width" === a ? "translateX" : "translateY";
              this[a] = b;
              y(c) && (x && "within" === x.backgroundSize && this.width && this.height && (c = Math.round(c * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(a, c), this.alignByTranslate || (f[p] = ((this[a] || 0) - c) / 2, this.attr(f)));
            };
          });
          y(a) && w.attr({
            x: a,
            y: c
          });
          w.isImg = !0;
          y(w.imgwidth) && y(w.imgheight) ? z() : (w.attr({
            width: 0,
            height: 0
          }), G("img", {
            onload: function () {
              var b = B[m.chartIndex];
              0 === this.width && (J(this, {
                position: "absolute",
                top: "-999em"
              }), Q.body.appendChild(this));
              O[v] = {
                width: this.width,
                height: this.height
              };
              w.imgwidth = this.width;
              w.imgheight = this.height;
              w.element && z();
              this.parentNode && this.parentNode.removeChild(this);
              m.imgCount--;
              if (!m.imgCount && b && !b.hasLoaded) b.onload();
            },
            src: v
          }), this.imgCount++);
        }

        return w;
      },
      symbols: {
        circle: function (b, a, f, c) {
          return this.arc(b + f / 2, a + c / 2, f / 2, c / 2, {
            start: .5 * Math.PI,
            end: 2.5 * Math.PI,
            open: !1
          });
        },
        square: function (b, a, f, c) {
          return ["M", b, a, "L", b + f, a, b + f, a + c, b, a + c, "Z"];
        },
        triangle: function (b, a, f, c) {
          return ["M", b + f / 2, a, "L", b + f, a + c, b, a + c, "Z"];
        },
        "triangle-down": function (b, a, f, c) {
          return ["M", b, a, "L", b + f, a, b + f / 2, a + c, "Z"];
        },
        diamond: function (b, a, f, c) {
          return ["M", b + f / 2, a, "L", b + f, a + c / 2, b + f / 2, a + c, b, a + c / 2, "Z"];
        },
        arc: function (b, a, c, p, e) {
          var x = e.start,
              m = e.r || c,
              l = e.r || p || c,
              C = e.end - .001;
          c = e.innerR;
          p = f(e.open, .001 > Math.abs(e.end - e.start - 2 * Math.PI));
          var k = Math.cos(x),
              n = Math.sin(x),
              w = Math.cos(C);
          C = Math.sin(C);
          x = f(e.longArc, .001 > e.end - x - Math.PI ? 0 : 1);
          m = ["M", b + m * k, a + l * n, "A", m, l, 0, x, f(e.clockwise, 1), b + m * w, a + l * C];
          y(c) && m.push(p ? "M" : "L", b + c * w, a + c * C, "A", c, c, 0, x, y(e.clockwise) ? 1 - e.clockwise : 0, b + c * k, a + c * n);
          m.push(p ? "" : "Z");
          return m;
        },
        callout: function (b, a, f, c, p) {
          var e = Math.min(p && p.r || 0, f, c),
              x = e + 6,
              l = p && p.anchorX;
          p = p && p.anchorY;
          var m = ["M", b + e, a, "L", b + f - e, a, "C", b + f, a, b + f, a, b + f, a + e, "L", b + f, a + c - e, "C", b + f, a + c, b + f, a + c, b + f - e, a + c, "L", b + e, a + c, "C", b, a + c, b, a + c, b, a + c - e, "L", b, a + e, "C", b, a, b, a, b + e, a];
          l && l > f ? p > a + x && p < a + c - x ? m.splice(13, 3, "L", b + f, p - 6, b + f + 6, p, b + f, p + 6, b + f, a + c - e) : m.splice(13, 3, "L", b + f, c / 2, l, p, b + f, c / 2, b + f, a + c - e) : l && 0 > l ? p > a + x && p < a + c - x ? m.splice(33, 3, "L", b, p + 6, b - 6, p, b, p - 6, b, a + e) : m.splice(33, 3, "L", b, c / 2, l, p, b, c / 2, b, a + e) : p && p > c && l > b + x && l < b + f - x ? m.splice(23, 3, "L", l + 6, a + c, l, a + c + 6, l - 6, a + c, b + e, a + c) : p && 0 > p && l > b + x && l < b + f - x && m.splice(3, 3, "L", l - 6, a, l, a - 6, l + 6, a, f - e, a);
          return m;
        }
      },
      clipRect: function (b, a, f, c) {
        var p = w() + "-",
            e = this.createElement("clipPath").attr({
          id: p
        }).add(this.defs);
        b = this.rect(b, a, f, c, 0).add(e);
        b.id = p;
        b.clipPath = e;
        b.count = 0;
        return b;
      },
      text: function (b, a, f, c) {
        var p = {};
        if (c && (this.allowHTML || !this.forExport)) return this.html(b, a, f);
        p.x = Math.round(a || 0);
        f && (p.y = Math.round(f));
        y(b) && (p.text = b);
        b = this.createElement("text").attr(p);
        c || (b.xSetter = function (b, a, f) {
          var c = f.getElementsByTagName("tspan"),
              p = f.getAttribute(a),
              e;

          for (e = 0; e < c.length; e++) {
            var x = c[e];
            x.getAttribute(a) === p && x.setAttribute(a, b);
          }

          f.setAttribute(a, b);
        });
        return b;
      },
      fontMetrics: function (b, f) {
        b = !this.styledMode && /px/.test(b) || !X.getComputedStyle ? b || f && f.style && f.style.fontSize || this.style && this.style.fontSize : f && U.prototype.getStyle.call(f, "font-size");
        b = /px/.test(b) ? a(b) : 12;
        f = 24 > b ? b + 3 : Math.round(1.2 * b);
        return {
          h: f,
          b: Math.round(.8 * f),
          f: b
        };
      },
      rotCorr: function (b, a, f) {
        var c = b;
        a && f && (c = Math.max(c * Math.cos(a * L), 4));
        return {
          x: -b / 3 * Math.sin(a * L),
          y: c
        };
      },
      label: function (b, a, f, c, p, e, x, C, n) {
        var m = this,
            w = m.styledMode,
            v = m.g("button" !== n && "label"),
            F = v.text = m.text("", 0, 0, x).attr({
          zIndex: 1
        }),
            z,
            O,
            q = 0,
            R = 3,
            B = 0,
            d,
            N,
            X,
            V,
            L,
            t = {},
            T,
            g,
            Q = /^url\((.*?)\)$/.test(c),
            H = w || Q,
            K = function () {
          return w ? z.strokeWidth() % 2 / 2 : (T ? parseInt(T, 10) : 0) % 2 / 2;
        };

        n && v.addClass("highcharts-" + n);

        var ba = function () {
          var b = F.element.style,
              a = {};
          O = ("undefined" === typeof d || "undefined" === typeof N || L) && y(F.textStr) && F.getBBox();
          v.width = (d || O.width || 0) + 2 * R + B;
          v.height = (N || O.height || 0) + 2 * R;
          g = R + Math.min(m.fontMetrics(b && b.fontSize, F).b, O ? O.height : Infinity);
          H && (z || (v.box = z = m.symbols[c] || Q ? m.symbol(c) : m.rect(), z.addClass(("button" === n ? "" : "highcharts-label-box") + (n ? " highcharts-" + n + "-box" : "")), z.add(v), b = K(), a.x = b, a.y = (C ? -g : 0) + b), a.width = Math.round(v.width), a.height = Math.round(v.height), z.attr(h(a, t)), t = {});
        };

        var u = function () {
          var b = B + R;
          var a = C ? 0 : g;
          y(d) && O && ("center" === L || "right" === L) && (b += {
            center: .5,
            right: 1
          }[L] * (d - O.width));
          if (b !== F.x || a !== F.y) F.attr("x", b), F.hasBoxWidthChanged && (O = F.getBBox(!0), ba()), "undefined" !== typeof a && F.attr("y", a);
          F.x = b;
          F.y = a;
        };

        var Y = function (b, a) {
          z ? z.attr(b, a) : t[b] = a;
        };

        v.onAdd = function () {
          F.add(v);
          v.attr({
            text: b || 0 === b ? b : "",
            x: a,
            y: f
          });
          z && y(p) && v.attr({
            anchorX: p,
            anchorY: e
          });
        };

        v.widthSetter = function (b) {
          d = P(b) ? b : null;
        };

        v.heightSetter = function (b) {
          N = b;
        };

        v["text-alignSetter"] = function (b) {
          L = b;
        };

        v.paddingSetter = function (b) {
          y(b) && b !== R && (R = v.padding = b, u());
        };

        v.paddingLeftSetter = function (b) {
          y(b) && b !== B && (B = b, u());
        };

        v.alignSetter = function (b) {
          b = {
            left: 0,
            center: .5,
            right: 1
          }[b];
          b !== q && (q = b, O && v.attr({
            x: X
          }));
        };

        v.textSetter = function (b) {
          "undefined" !== typeof b && F.attr({
            text: b
          });
          ba();
          u();
        };

        v["stroke-widthSetter"] = function (b, a) {
          b && (H = !0);
          T = this["stroke-width"] = b;
          Y(a, b);
        };

        w ? v.rSetter = function (b, a) {
          Y(a, b);
        } : v.strokeSetter = v.fillSetter = v.rSetter = function (b, a) {
          "r" !== a && ("fill" === a && b && (H = !0), v[a] = b);
          Y(a, b);
        };

        v.anchorXSetter = function (b, a) {
          p = v.anchorX = b;
          Y(a, Math.round(b) - K() - X);
        };

        v.anchorYSetter = function (b, a) {
          e = v.anchorY = b;
          Y(a, b - V);
        };

        v.xSetter = function (b) {
          v.x = b;
          q && (b -= q * ((d || O.width) + 2 * R), v["forceAnimate:x"] = !0);
          X = Math.round(b);
          v.attr("translateX", X);
        };

        v.ySetter = function (b) {
          V = v.y = Math.round(b);
          v.attr("translateY", V);
        };

        var D = v.css;
        x = {
          css: function (b) {
            if (b) {
              var a = {};
              b = k(b);
              v.textProps.forEach(function (f) {
                "undefined" !== typeof b[f] && (a[f] = b[f], delete b[f]);
              });
              F.css(a);
              "width" in a && ba();
              "fontSize" in a && (ba(), u());
            }

            return D.call(v, b);
          },
          getBBox: function () {
            return {
              width: O.width + 2 * R,
              height: O.height + 2 * R,
              x: O.x - R,
              y: O.y - R
            };
          },
          destroy: function () {
            l(v.element, "mouseenter");
            l(v.element, "mouseleave");
            F && (F = F.destroy());
            z && (z = z.destroy());
            U.prototype.destroy.call(v);
            v = m = ba = u = Y = null;
          }
        };
        w || (x.shadow = function (b) {
          b && (ba(), z && z.shadow(b));
          return v;
        });
        return h(v, x);
      }
    });
    d.Renderer = g;
  });
  S(r, "parts/Html.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.attr,
        u = g.createElement,
        I = g.css,
        M = g.defined,
        E = g.extend,
        A = g.pick,
        G = g.pInt,
        J = d.isFirefox,
        y = d.isMS,
        t = d.isWebKit,
        D = d.SVGElement;
    g = d.SVGRenderer;
    var h = d.win;
    E(D.prototype, {
      htmlCss: function (d) {
        var q = "SPAN" === this.element.tagName && d && "width" in d,
            N = A(q && d.width, void 0);

        if (q) {
          delete d.width;
          this.textWidth = N;
          var e = !0;
        }

        d && "ellipsis" === d.textOverflow && (d.whiteSpace = "nowrap", d.overflow = "hidden");
        this.styles = E(this.styles, d);
        I(this.element, d);
        e && this.htmlUpdateTransform();
        return this;
      },
      htmlGetBBox: function () {
        var d = this.element;
        return {
          x: d.offsetLeft,
          y: d.offsetTop,
          width: d.offsetWidth,
          height: d.offsetHeight
        };
      },
      htmlUpdateTransform: function () {
        if (this.added) {
          var d = this.renderer,
              q = this.element,
              h = this.translateX || 0,
              e = this.translateY || 0,
              c = this.x || 0,
              k = this.y || 0,
              n = this.textAlign || "left",
              f = {
            left: 0,
            center: .5,
            right: 1
          }[n],
              a = this.styles,
              l = a && a.whiteSpace;
          I(q, {
            marginLeft: h,
            marginTop: e
          });
          !d.styledMode && this.shadows && this.shadows.forEach(function (a) {
            I(a, {
              marginLeft: h + 1,
              marginTop: e + 1
            });
          });
          this.inverted && [].forEach.call(q.childNodes, function (a) {
            d.invertChild(a, q);
          });

          if ("SPAN" === q.tagName) {
            a = this.rotation;
            var v = this.textWidth && G(this.textWidth),
                z = [a, n, q.innerHTML, this.textWidth, this.textAlign].join(),
                w;
            (w = v !== this.oldTextWidth) && !(w = v > this.oldTextWidth) && ((w = this.textPxLength) || (I(q, {
              width: "",
              whiteSpace: l || "nowrap"
            }), w = q.offsetWidth), w = w > v);
            w && (/[ \-]/.test(q.textContent || q.innerText) || "ellipsis" === q.style.textOverflow) ? (I(q, {
              width: v + "px",
              display: "block",
              whiteSpace: l || "normal"
            }), this.oldTextWidth = v, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;
            z !== this.cTT && (l = d.fontMetrics(q.style.fontSize, q).b, !M(a) || a === (this.oldRotation || 0) && n === this.oldAlign || this.setSpanRotation(a, f, l), this.getSpanCorrection(!M(a) && this.textPxLength || q.offsetWidth, l, f, a, n));
            I(q, {
              left: c + (this.xCorr || 0) + "px",
              top: k + (this.yCorr || 0) + "px"
            });
            this.cTT = z;
            this.oldRotation = a;
            this.oldAlign = n;
          }
        } else this.alignOnAdd = !0;
      },
      setSpanRotation: function (d, q, h) {
        var e = {},
            c = this.renderer.getTransformKey();
        e[c] = e.transform = "rotate(" + d + "deg)";
        e[c + (J ? "Origin" : "-origin")] = e.transformOrigin = 100 * q + "% " + h + "px";
        I(this.element, e);
      },
      getSpanCorrection: function (d, q, h) {
        this.xCorr = -d * h;
        this.yCorr = -q;
      }
    });
    E(g.prototype, {
      getTransformKey: function () {
        return y && !/Edge/.test(h.navigator.userAgent) ? "-ms-transform" : t ? "-webkit-transform" : J ? "MozTransform" : h.opera ? "-o-transform" : "";
      },
      html: function (d, q, h) {
        var e = this.createElement("span"),
            c = e.element,
            k = e.renderer,
            n = k.isSVG,
            f = function (a, f) {
          ["opacity", "visibility"].forEach(function (c) {
            a[c + "Setter"] = function (e, l, k) {
              var v = a.div ? a.div.style : f;
              D.prototype[c + "Setter"].call(this, e, l, k);
              v && (v[l] = e);
            };
          });
          a.addedSetters = !0;
        };

        e.textSetter = function (a) {
          a !== c.innerHTML && (delete this.bBox, delete this.oldTextWidth);
          this.textStr = a;
          c.innerHTML = A(a, "");
          e.doTransform = !0;
        };

        n && f(e, e.element.style);

        e.xSetter = e.ySetter = e.alignSetter = e.rotationSetter = function (a, f) {
          "align" === f && (f = "textAlign");
          e[f] = a;
          e.doTransform = !0;
        };

        e.afterSetters = function () {
          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
        };

        e.attr({
          text: d,
          x: Math.round(q),
          y: Math.round(h)
        }).css({
          position: "absolute"
        });
        k.styledMode || e.css({
          fontFamily: this.style.fontFamily,
          fontSize: this.style.fontSize
        });
        c.style.whiteSpace = "nowrap";
        e.css = e.htmlCss;
        n && (e.add = function (a) {
          var l = k.box.parentNode,
              v = [];

          if (this.parentGroup = a) {
            var n = a.div;

            if (!n) {
              for (; a;) v.push(a), a = a.parentGroup;

              v.reverse().forEach(function (a) {
                function c(f, c) {
                  a[c] = f;
                  "translateX" === c ? w.left = f + "px" : w.top = f + "px";
                  a.doTransform = !0;
                }

                var k = r(a.element, "class");
                n = a.div = a.div || u("div", k ? {
                  className: k
                } : void 0, {
                  position: "absolute",
                  left: (a.translateX || 0) + "px",
                  top: (a.translateY || 0) + "px",
                  display: a.display,
                  opacity: a.opacity,
                  pointerEvents: a.styles && a.styles.pointerEvents
                }, n || l);
                var w = n.style;
                E(a, {
                  classSetter: function (a) {
                    return function (f) {
                      this.element.setAttribute("class", f);
                      a.className = f;
                    };
                  }(n),
                  on: function () {
                    v[0].div && e.on.apply({
                      element: v[0].div
                    }, arguments);
                    return a;
                  },
                  translateXSetter: c,
                  translateYSetter: c
                });
                a.addedSetters || f(a);
              });
            }
          } else n = l;

          n.appendChild(c);
          e.added = !0;
          e.alignOnAdd && e.htmlUpdateTransform();
          return e;
        });
        return e;
      }
    });
  });
  S(r, "parts/Tick.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.clamp,
        u = g.correctFloat,
        I = g.defined,
        M = g.destroyObjectProperties,
        E = g.extend,
        A = g.isNumber,
        G = g.merge,
        J = g.objectEach,
        y = g.pick,
        t = d.fireEvent,
        D = d.deg2rad;

    g = function () {
      function h(d, q, h, e, c) {
        this.isNewLabel = this.isNew = !0;
        this.axis = d;
        this.pos = q;
        this.type = h || "";
        this.parameters = c || {};
        this.tickmarkOffset = this.parameters.tickmarkOffset;
        this.options = this.parameters.options;
        h || e || this.addLabel();
      }

      h.prototype.addLabel = function () {
        var d = this,
            q = d.axis,
            h = q.options,
            e = q.chart,
            c = q.categories,
            k = q.names,
            n = d.pos,
            f = y(d.options && d.options.labels, h.labels),
            a = q.tickPositions,
            l = n === a[0],
            v = n === a[a.length - 1];
        k = this.parameters.category || (c ? y(c[n], k[n], n) : n);
        var z = d.label;
        c = (!f.step || 1 === f.step) && 1 === q.tickInterval;
        a = a.info;
        var w, B;

        if (q.isDatetimeAxis && a) {
          var L = e.time.resolveDTLFormat(h.dateTimeLabelFormats[!h.grid && a.higherRanks[n] || a.unitName]);
          var t = L.main;
        }

        d.isFirst = l;
        d.isLast = v;
        d.formatCtx = {
          axis: q,
          chart: e,
          isFirst: l,
          isLast: v,
          dateTimeLabelFormat: t,
          tickPositionInfo: a,
          value: q.isLog ? u(q.lin2log(k)) : k,
          pos: n
        };
        h = q.labelFormatter.call(d.formatCtx, this.formatCtx);
        if (B = L && L.list) d.shortenLabel = function () {
          for (w = 0; w < B.length; w++) if (z.attr({
            text: q.labelFormatter.call(E(d.formatCtx, {
              dateTimeLabelFormat: B[w]
            }))
          }), z.getBBox().width < q.getSlotWidth(d) - 2 * y(f.padding, 5)) return;

          z.attr({
            text: ""
          });
        };
        c && q._addedPlotLB && q.isXAxis && d.moveLabel(h, f);
        I(z) || d.movedLabel ? z && z.textStr !== h && !c && (!z.textWidth || f.style && f.style.width || z.styles.width || z.css({
          width: null
        }), z.attr({
          text: h
        }), z.textPxLength = z.getBBox().width) : (d.label = z = d.createLabel({
          x: 0,
          y: 0
        }, h, f), d.rotation = 0);
      };

      h.prototype.createLabel = function (d, q, h) {
        var e = this.axis,
            c = e.chart;
        if (d = I(q) && h.enabled ? c.renderer.text(q, d.x, d.y, h.useHTML).add(e.labelGroup) : null) c.styledMode || d.css(G(h.style)), d.textPxLength = d.getBBox().width;
        return d;
      };

      h.prototype.destroy = function () {
        M(this, this.axis);
      };

      h.prototype.getPosition = function (d, q, h, e) {
        var c = this.axis,
            k = c.chart,
            n = e && k.oldChartHeight || k.chartHeight;
        d = {
          x: d ? u(c.translate(q + h, null, null, e) + c.transB) : c.left + c.offset + (c.opposite ? (e && k.oldChartWidth || k.chartWidth) - c.right - c.left : 0),
          y: d ? n - c.bottom + c.offset - (c.opposite ? c.height : 0) : u(n - c.translate(q + h, null, null, e) - c.transB)
        };
        d.y = r(d.y, -1E5, 1E5);
        t(this, "afterGetPosition", {
          pos: d
        });
        return d;
      };

      h.prototype.getLabelPosition = function (d, q, h, e, c, k, n, f) {
        var a = this.axis,
            l = a.transA,
            v = a.isLinked && a.linkedParent ? a.linkedParent.reversed : a.reversed,
            z = a.staggerLines,
            w = a.tickRotCorr || {
          x: 0,
          y: 0
        },
            B = c.y,
            L = e || a.reserveSpaceDefault ? 0 : -a.labelOffset * ("center" === a.labelAlign ? .5 : 1),
            N = {};
        I(B) || (B = 0 === a.side ? h.rotation ? -8 : -h.getBBox().height : 2 === a.side ? w.y + 8 : Math.cos(h.rotation * D) * (w.y - h.getBBox(!1, 0).height / 2));
        d = d + c.x + L + w.x - (k && e ? k * l * (v ? -1 : 1) : 0);
        q = q + B - (k && !e ? k * l * (v ? 1 : -1) : 0);
        z && (h = n / (f || 1) % z, a.opposite && (h = z - h - 1), q += a.labelOffset / z * h);
        N.x = d;
        N.y = Math.round(q);
        t(this, "afterGetLabelPosition", {
          pos: N,
          tickmarkOffset: k,
          index: n
        });
        return N;
      };

      h.prototype.getLabelSize = function () {
        return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
      };

      h.prototype.getMarkPath = function (d, q, h, e, c, k) {
        return k.crispLine(["M", d, q, "L", d + (c ? 0 : -h), q + (c ? h : 0)], e);
      };

      h.prototype.handleOverflow = function (d) {
        var q = this.axis,
            h = q.options.labels,
            e = d.x,
            c = q.chart.chartWidth,
            k = q.chart.spacing,
            n = y(q.labelLeft, Math.min(q.pos, k[3]));
        k = y(q.labelRight, Math.max(q.isRadial ? 0 : q.pos + q.len, c - k[1]));
        var f = this.label,
            a = this.rotation,
            l = {
          left: 0,
          center: .5,
          right: 1
        }[q.labelAlign || f.attr("align")],
            v = f.getBBox().width,
            z = q.getSlotWidth(this),
            w = z,
            B = 1,
            L,
            t = {};
        if (a || "justify" !== y(h.overflow, "justify")) 0 > a && e - l * v < n ? L = Math.round(e / Math.cos(a * D) - n) : 0 < a && e + l * v > k && (L = Math.round((c - e) / Math.cos(a * D)));else if (c = e + (1 - l) * v, e - l * v < n ? w = d.x + w * (1 - l) - n : c > k && (w = k - d.x + w * l, B = -1), w = Math.min(z, w), w < z && "center" === q.labelAlign && (d.x += B * (z - w - l * (z - Math.min(v, w)))), v > w || q.autoRotation && (f.styles || {}).width) L = w;
        L && (this.shortenLabel ? this.shortenLabel() : (t.width = Math.floor(L), (h.style || {}).textOverflow || (t.textOverflow = "ellipsis"), f.css(t)));
      };

      h.prototype.moveLabel = function (d, q) {
        var h = this,
            e = h.label,
            c = !1,
            k = h.axis,
            n = k.reversed,
            f = k.chart.inverted;
        e && e.textStr === d ? (h.movedLabel = e, c = !0, delete h.label) : J(k.ticks, function (a) {
          c || a.isNew || a === h || !a.label || a.label.textStr !== d || (h.movedLabel = a.label, c = !0, a.labelPos = h.movedLabel.xy, delete a.label);
        });

        if (!c && (h.labelPos || e)) {
          var a = h.labelPos || e.xy;
          e = f ? a.x : n ? 0 : k.width + k.left;
          k = f ? n ? k.width + k.left : 0 : a.y;
          h.movedLabel = h.createLabel({
            x: e,
            y: k
          }, d, q);
          h.movedLabel && h.movedLabel.attr({
            opacity: 0
          });
        }
      };

      h.prototype.render = function (h, q, t) {
        var e = this.axis,
            c = e.horiz,
            k = this.pos,
            n = y(this.tickmarkOffset, e.tickmarkOffset);
        k = this.getPosition(c, k, n, q);
        n = k.x;
        var f = k.y;
        e = c && n === e.pos + e.len || !c && f === e.pos ? -1 : 1;
        t = y(t, 1);
        this.isActive = !0;
        this.renderGridLine(q, t, e);
        this.renderMark(k, t, e);
        this.renderLabel(k, q, t, h);
        this.isNew = !1;
        d.fireEvent(this, "afterRender");
      };

      h.prototype.renderGridLine = function (d, q, h) {
        var e = this.axis,
            c = e.options,
            k = this.gridLine,
            n = {},
            f = this.pos,
            a = this.type,
            l = y(this.tickmarkOffset, e.tickmarkOffset),
            v = e.chart.renderer,
            z = a ? a + "Grid" : "grid",
            w = c[z + "LineWidth"],
            B = c[z + "LineColor"];
        c = c[z + "LineDashStyle"];
        k || (e.chart.styledMode || (n.stroke = B, n["stroke-width"] = w, c && (n.dashstyle = c)), a || (n.zIndex = 1), d && (q = 0), this.gridLine = k = v.path().attr(n).addClass("highcharts-" + (a ? a + "-" : "") + "grid-line").add(e.gridGroup));
        if (k && (h = e.getPlotLinePath({
          value: f + l,
          lineWidth: k.strokeWidth() * h,
          force: "pass",
          old: d
        }))) k[d || this.isNew ? "attr" : "animate"]({
          d: h,
          opacity: q
        });
      };

      h.prototype.renderMark = function (d, q, h) {
        var e = this.axis,
            c = e.options,
            k = e.chart.renderer,
            n = this.type,
            f = n ? n + "Tick" : "tick",
            a = e.tickSize(f),
            l = this.mark,
            v = !l,
            z = d.x;
        d = d.y;
        var w = y(c[f + "Width"], !n && e.isXAxis ? 1 : 0);
        c = c[f + "Color"];
        a && (e.opposite && (a[0] = -a[0]), v && (this.mark = l = k.path().addClass("highcharts-" + (n ? n + "-" : "") + "tick").add(e.axisGroup), e.chart.styledMode || l.attr({
          stroke: c,
          "stroke-width": w
        })), l[v ? "attr" : "animate"]({
          d: this.getMarkPath(z, d, a[0], l.strokeWidth() * h, e.horiz, k),
          opacity: q
        }));
      };

      h.prototype.renderLabel = function (d, q, h, e) {
        var c = this.axis,
            k = c.horiz,
            n = c.options,
            f = this.label,
            a = n.labels,
            l = a.step;
        c = y(this.tickmarkOffset, c.tickmarkOffset);
        var v = !0,
            z = d.x;
        d = d.y;
        f && A(z) && (f.xy = d = this.getLabelPosition(z, d, f, k, a, c, e, l), this.isFirst && !this.isLast && !y(n.showFirstLabel, 1) || this.isLast && !this.isFirst && !y(n.showLastLabel, 1) ? v = !1 : !k || a.step || a.rotation || q || 0 === h || this.handleOverflow(d), l && e % l && (v = !1), v && A(d.y) ? (d.opacity = h, f[this.isNewLabel ? "attr" : "animate"](d), this.isNewLabel = !1) : (f.attr("y", -9999), this.isNewLabel = !0));
      };

      h.prototype.replaceMovedLabel = function () {
        var d = this.label,
            q = this.axis,
            h = q.reversed,
            e = this.axis.chart.inverted;

        if (d && !this.isNew) {
          var c = e ? d.xy.x : h ? q.left : q.width + q.left;
          h = e ? h ? q.width + q.top : q.top : d.xy.y;
          d.animate({
            x: c,
            y: h,
            opacity: 0
          }, void 0, d.destroy);
          delete this.label;
        }

        q.isDirty = !0;
        this.label = this.movedLabel;
        delete this.movedLabel;
      };

      return h;
    }();

    d.Tick = g;
    return d.Tick;
  });
  S(r, "parts/Time.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.defined,
        u = g.error,
        I = g.extend,
        M = g.isObject,
        E = g.merge,
        A = g.objectEach,
        G = g.pad,
        J = g.pick,
        y = g.splat,
        t = g.timeUnits,
        D = d.win;

    g = function () {
      function h(d) {
        this.options = {};
        this.variableTimezone = this.useUTC = !1;
        this.Date = D.Date;
        this.getTimezoneOffset = this.timezoneOffsetFunction();
        this.update(d);
      }

      h.prototype.get = function (d, q) {
        if (this.variableTimezone || this.timezoneOffset) {
          var h = q.getTime(),
              e = h - this.getTimezoneOffset(q);
          q.setTime(e);
          d = q["getUTC" + d]();
          q.setTime(h);
          return d;
        }

        return this.useUTC ? q["getUTC" + d]() : q["get" + d]();
      };

      h.prototype.set = function (d, q, h) {
        if (this.variableTimezone || this.timezoneOffset) {
          if ("Milliseconds" === d || "Seconds" === d || "Minutes" === d) return q["setUTC" + d](h);
          var e = this.getTimezoneOffset(q);
          e = q.getTime() - e;
          q.setTime(e);
          q["setUTC" + d](h);
          d = this.getTimezoneOffset(q);
          e = q.getTime() + d;
          return q.setTime(e);
        }

        return this.useUTC ? q["setUTC" + d](h) : q["set" + d](h);
      };

      h.prototype.update = function (d) {
        var q = J(d && d.useUTC, !0);
        this.options = d = E(!0, this.options || {}, d);
        this.Date = d.Date || D.Date || Date;
        this.timezoneOffset = (this.useUTC = q) && d.timezoneOffset;
        this.getTimezoneOffset = this.timezoneOffsetFunction();
        this.variableTimezone = !(q && !d.getTimezoneOffset && !d.timezone);
      };

      h.prototype.makeTime = function (h, q, t, e, c, k) {
        if (this.useUTC) {
          var n = this.Date.UTC.apply(0, arguments);
          var f = this.getTimezoneOffset(n);
          n += f;
          var a = this.getTimezoneOffset(n);
          f !== a ? n += a - f : f - 36E5 !== this.getTimezoneOffset(n - 36E5) || d.isSafari || (n -= 36E5);
        } else n = new this.Date(h, q, J(t, 1), J(e, 0), J(c, 0), J(k, 0)).getTime();

        return n;
      };

      h.prototype.timezoneOffsetFunction = function () {
        var d = this,
            q = this.options,
            h = D.moment;
        if (!this.useUTC) return function (e) {
          return 6E4 * new Date(e.toString()).getTimezoneOffset();
        };

        if (q.timezone) {
          if (h) return function (e) {
            return 6E4 * -h.tz(e, q.timezone).utcOffset();
          };
          u(25);
        }

        return this.useUTC && q.getTimezoneOffset ? function (e) {
          return 6E4 * q.getTimezoneOffset(e.valueOf());
        } : function () {
          return 6E4 * (d.timezoneOffset || 0);
        };
      };

      h.prototype.dateFormat = function (h, q, t) {
        var e;
        if (!r(q) || isNaN(q)) return (null === (e = d.defaultOptions.lang) || void 0 === e ? void 0 : e.invalidDate) || "";
        h = J(h, "%Y-%m-%d %H:%M:%S");
        var c = this;
        e = new this.Date(q);
        var k = this.get("Hours", e),
            n = this.get("Day", e),
            f = this.get("Date", e),
            a = this.get("Month", e),
            l = this.get("FullYear", e),
            v = d.defaultOptions.lang,
            z = null === v || void 0 === v ? void 0 : v.weekdays,
            w = null === v || void 0 === v ? void 0 : v.shortWeekdays;
        e = I({
          a: w ? w[n] : z[n].substr(0, 3),
          A: z[n],
          d: G(f),
          e: G(f, 2, " "),
          w: n,
          b: v.shortMonths[a],
          B: v.months[a],
          m: G(a + 1),
          o: a + 1,
          y: l.toString().substr(2, 2),
          Y: l,
          H: G(k),
          k: k,
          I: G(k % 12 || 12),
          l: k % 12 || 12,
          M: G(this.get("Minutes", e)),
          p: 12 > k ? "AM" : "PM",
          P: 12 > k ? "am" : "pm",
          S: G(e.getSeconds()),
          L: G(Math.floor(q % 1E3), 3)
        }, d.dateFormats);
        A(e, function (a, f) {
          for (; -1 !== h.indexOf("%" + f);) h = h.replace("%" + f, "function" === typeof a ? a.call(c, q) : a);
        });
        return t ? h.substr(0, 1).toUpperCase() + h.substr(1) : h;
      };

      h.prototype.resolveDTLFormat = function (d) {
        return M(d, !0) ? d : (d = y(d), {
          main: d[0],
          from: d[1],
          to: d[2]
        });
      };

      h.prototype.getTimeTicks = function (d, h, g, e) {
        var c = this,
            k = [],
            n = {};
        var f = new c.Date(h);
        var a = d.unitRange,
            l = d.count || 1,
            v;
        e = J(e, 1);

        if (r(h)) {
          c.set("Milliseconds", f, a >= t.second ? 0 : l * Math.floor(c.get("Milliseconds", f) / l));
          a >= t.second && c.set("Seconds", f, a >= t.minute ? 0 : l * Math.floor(c.get("Seconds", f) / l));
          a >= t.minute && c.set("Minutes", f, a >= t.hour ? 0 : l * Math.floor(c.get("Minutes", f) / l));
          a >= t.hour && c.set("Hours", f, a >= t.day ? 0 : l * Math.floor(c.get("Hours", f) / l));
          a >= t.day && c.set("Date", f, a >= t.month ? 1 : Math.max(1, l * Math.floor(c.get("Date", f) / l)));

          if (a >= t.month) {
            c.set("Month", f, a >= t.year ? 0 : l * Math.floor(c.get("Month", f) / l));
            var z = c.get("FullYear", f);
          }

          a >= t.year && c.set("FullYear", f, z - z % l);
          a === t.week && (z = c.get("Day", f), c.set("Date", f, c.get("Date", f) - z + e + (z < e ? -7 : 0)));
          z = c.get("FullYear", f);
          e = c.get("Month", f);
          var w = c.get("Date", f),
              q = c.get("Hours", f);
          h = f.getTime();
          c.variableTimezone && (v = g - h > 4 * t.month || c.getTimezoneOffset(h) !== c.getTimezoneOffset(g));
          h = f.getTime();

          for (f = 1; h < g;) k.push(h), h = a === t.year ? c.makeTime(z + f * l, 0) : a === t.month ? c.makeTime(z, e + f * l) : !v || a !== t.day && a !== t.week ? v && a === t.hour && 1 < l ? c.makeTime(z, e, w, q + f * l) : h + a * l : c.makeTime(z, e, w + f * l * (a === t.day ? 1 : 7)), f++;

          k.push(h);
          a <= t.hour && 1E4 > k.length && k.forEach(function (a) {
            0 === a % 18E5 && "000000000" === c.dateFormat("%H%M%S%L", a) && (n[a] = "day");
          });
        }

        k.info = I(d, {
          higherRanks: n,
          totalRange: a * l
        });
        return k;
      };

      h.defaultOptions = {
        Date: void 0,
        getTimezoneOffset: void 0,
        timezone: void 0,
        timezoneOffset: 0,
        useUTC: !0
      };
      return h;
    }();

    d.Time = g;
    return d.Time;
  });
  S(r, "parts/Options.js", [r["parts/Globals.js"], r["parts/Time.js"], r["parts/Color.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    r = r.parse;
    var I = u.merge;
    d.defaultOptions = {
      colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),
      symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
      lang: {
        loading: "Loading...",
        months: "January February March April May June July August September October November December".split(" "),
        shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
        weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
        decimalPoint: ".",
        numericSymbols: "kMGTPE".split(""),
        resetZoom: "Reset zoom",
        resetZoomTitle: "Reset zoom level 1:1",
        thousandsSep: " "
      },
      global: {},
      time: g.defaultOptions,
      chart: {
        styledMode: !1,
        borderRadius: 0,
        colorCount: 10,
        defaultSeriesType: "line",
        ignoreHiddenSeries: !0,
        spacing: [10, 10, 15, 10],
        resetZoomButton: {
          theme: {
            zIndex: 6
          },
          position: {
            align: "right",
            x: -10,
            y: 10
          }
        },
        width: null,
        height: null,
        borderColor: "#335cad",
        backgroundColor: "#ffffff",
        plotBorderColor: "#cccccc"
      },
      title: {
        text: "Chart title",
        align: "center",
        margin: 15,
        widthAdjust: -44
      },
      subtitle: {
        text: "",
        align: "center",
        widthAdjust: -44
      },
      caption: {
        margin: 15,
        text: "",
        align: "left",
        verticalAlign: "bottom"
      },
      plotOptions: {},
      labels: {
        style: {
          position: "absolute",
          color: "#333333"
        }
      },
      legend: {
        enabled: !0,
        align: "center",
        alignColumns: !0,
        layout: "horizontal",
        labelFormatter: function () {
          return this.name;
        },
        borderColor: "#999999",
        borderRadius: 0,
        navigation: {
          activeColor: "#003399",
          inactiveColor: "#cccccc"
        },
        itemStyle: {
          color: "#333333",
          cursor: "pointer",
          fontSize: "12px",
          fontWeight: "bold",
          textOverflow: "ellipsis"
        },
        itemHoverStyle: {
          color: "#000000"
        },
        itemHiddenStyle: {
          color: "#cccccc"
        },
        shadow: !1,
        itemCheckboxStyle: {
          position: "absolute",
          width: "13px",
          height: "13px"
        },
        squareSymbol: !0,
        symbolPadding: 5,
        verticalAlign: "bottom",
        x: 0,
        y: 0,
        title: {
          style: {
            fontWeight: "bold"
          }
        }
      },
      loading: {
        labelStyle: {
          fontWeight: "bold",
          position: "relative",
          top: "45%"
        },
        style: {
          position: "absolute",
          backgroundColor: "#ffffff",
          opacity: .5,
          textAlign: "center"
        }
      },
      tooltip: {
        enabled: !0,
        animation: d.svg,
        borderRadius: 3,
        dateTimeLabelFormats: {
          millisecond: "%A, %b %e, %H:%M:%S.%L",
          second: "%A, %b %e, %H:%M:%S",
          minute: "%A, %b %e, %H:%M",
          hour: "%A, %b %e, %H:%M",
          day: "%A, %b %e, %Y",
          week: "Week from %A, %b %e, %Y",
          month: "%B %Y",
          year: "%Y"
        },
        footerFormat: "",
        padding: 8,
        snap: d.isTouchDevice ? 25 : 10,
        headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
        pointFormat: '<span style="color:{point.color}">\u25cf</span> {series.name}: <b>{point.y}</b><br/>',
        backgroundColor: r("#f7f7f7").setOpacity(.85).get(),
        borderWidth: 1,
        shadow: !0,
        style: {
          color: "#333333",
          cursor: "default",
          fontSize: "12px",
          whiteSpace: "nowrap"
        }
      },
      credits: {
        enabled: !0,
        href: "https://www.highcharts.com?credits",
        position: {
          align: "right",
          x: -10,
          verticalAlign: "bottom",
          y: -5
        },
        style: {
          cursor: "pointer",
          color: "#999999",
          fontSize: "9px"
        },
        text: "Highcharts.com"
      }
    };

    d.setOptions = function (g) {
      d.defaultOptions = I(!0, d.defaultOptions, g);
      (g.time || g.global) && d.time.update(I(d.defaultOptions.global, d.defaultOptions.time, g.global, g.time));
      return d.defaultOptions;
    };

    d.getOptions = function () {
      return d.defaultOptions;
    };

    d.defaultPlotOptions = d.defaultOptions.plotOptions;
    d.time = new g(I(d.defaultOptions.global, d.defaultOptions.time));

    d.dateFormat = function (g, u, A) {
      return d.time.dateFormat(g, u, A);
    };

    "";
  });
  S(r, "parts/Axis.js", [r["parts/Globals.js"], r["parts/Color.js"], r["parts/Tick.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    var I = g.parse,
        M = u.addEvent,
        E = u.animObject,
        A = u.arrayMax,
        G = u.arrayMin,
        J = u.clamp,
        y = u.correctFloat,
        t = u.defined,
        D = u.destroyObjectProperties,
        h = u.error,
        N = u.extend,
        q = u.fireEvent,
        P = u.format,
        e = u.getMagnitude,
        c = u.isArray,
        k = u.isFunction,
        n = u.isNumber,
        f = u.isString,
        a = u.merge,
        l = u.normalizeTickInterval,
        v = u.objectEach,
        z = u.pick,
        w = u.relativeLength,
        B = u.removeEvent,
        L = u.splat,
        Q = u.syncTimeout,
        H = d.defaultOptions,
        K = d.deg2rad;

    g = function () {
      this.init.apply(this, arguments);
    };

    N(g.prototype, {
      defaultOptions: {
        dateTimeLabelFormats: {
          millisecond: {
            main: "%H:%M:%S.%L",
            range: !1
          },
          second: {
            main: "%H:%M:%S",
            range: !1
          },
          minute: {
            main: "%H:%M",
            range: !1
          },
          hour: {
            main: "%H:%M",
            range: !1
          },
          day: {
            main: "%e. %b"
          },
          week: {
            main: "%e. %b"
          },
          month: {
            main: "%b '%y"
          },
          year: {
            main: "%Y"
          }
        },
        endOnTick: !1,
        labels: {
          enabled: !0,
          indentation: 10,
          x: 0,
          style: {
            color: "#666666",
            cursor: "default",
            fontSize: "11px"
          }
        },
        maxPadding: .01,
        minorTickLength: 2,
        minorTickPosition: "outside",
        minPadding: .01,
        showEmpty: !0,
        startOfWeek: 1,
        startOnTick: !1,
        tickLength: 10,
        tickPixelInterval: 100,
        tickmarkPlacement: "between",
        tickPosition: "outside",
        title: {
          align: "middle",
          style: {
            color: "#666666"
          }
        },
        type: "linear",
        minorGridLineColor: "#f2f2f2",
        minorGridLineWidth: 1,
        minorTickColor: "#999999",
        lineColor: "#ccd6eb",
        lineWidth: 1,
        gridLineColor: "#e6e6e6",
        tickColor: "#ccd6eb"
      },
      defaultYAxisOptions: {
        endOnTick: !0,
        maxPadding: .05,
        minPadding: .05,
        tickPixelInterval: 72,
        showLastLabel: !0,
        labels: {
          x: -8
        },
        startOnTick: !0,
        title: {
          rotation: 270,
          text: "Values"
        },
        stackLabels: {
          allowOverlap: !1,
          enabled: !1,
          crop: !0,
          overflow: "justify",
          formatter: function () {
            var a = this.axis.chart.numberFormatter;
            return a(this.total, -1);
          },
          style: {
            color: "#000000",
            fontSize: "11px",
            fontWeight: "bold",
            textOutline: "1px contrast"
          }
        },
        gridLineWidth: 1,
        lineWidth: 0
      },
      defaultLeftAxisOptions: {
        labels: {
          x: -15
        },
        title: {
          rotation: 270
        }
      },
      defaultRightAxisOptions: {
        labels: {
          x: 15
        },
        title: {
          rotation: 90
        }
      },
      defaultBottomAxisOptions: {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        margin: 15,
        title: {
          rotation: 0
        }
      },
      defaultTopAxisOptions: {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        margin: 15,
        title: {
          rotation: 0
        }
      },
      init: function (a, b) {
        var f = b.isX,
            c = this;
        c.chart = a;
        c.horiz = a.inverted && !c.isZAxis ? !f : f;
        c.isXAxis = f;
        c.coll = c.coll || (f ? "xAxis" : "yAxis");
        q(this, "init", {
          userOptions: b
        });
        c.opposite = b.opposite;
        c.side = b.side || (c.horiz ? c.opposite ? 0 : 2 : c.opposite ? 1 : 3);
        c.setOptions(b);
        var p = this.options,
            e = p.type;
        c.labelFormatter = p.labels.formatter || c.defaultLabelFormatter;
        c.userOptions = b;
        c.minPixelPadding = 0;
        c.reversed = p.reversed;
        c.visible = !1 !== p.visible;
        c.zoomEnabled = !1 !== p.zoomEnabled;
        c.hasNames = "category" === e || !0 === p.categories;
        c.categories = p.categories || c.hasNames;
        c.names || (c.names = [], c.names.keys = {});
        c.plotLinesAndBandsGroups = {};
        c.isLog = "logarithmic" === e;
        c.isDatetimeAxis = "datetime" === e;
        c.positiveValuesOnly = c.isLog && !c.allowNegativeLog;
        c.isLinked = t(p.linkedTo);
        c.ticks = {};
        c.labelEdge = [];
        c.minorTicks = {};
        c.plotLinesAndBands = [];
        c.alternateBands = {};
        c.len = 0;
        c.minRange = c.userMinRange = p.minRange || p.maxZoom;
        c.range = p.range;
        c.offset = p.offset || 0;
        c.stacks = {};
        c.oldStacks = {};
        c.stacksTouched = 0;
        c.max = null;
        c.min = null;
        c.crosshair = z(p.crosshair, L(a.options.tooltip.crosshairs)[f ? 0 : 1], !1);
        b = c.options.events;
        -1 === a.axes.indexOf(c) && (f ? a.axes.splice(a.xAxis.length, 0, c) : a.axes.push(c), a[c.coll].push(c));
        c.series = c.series || [];
        a.inverted && !c.isZAxis && f && "undefined" === typeof c.reversed && (c.reversed = !0);
        v(b, function (b, a) {
          k(b) && M(c, a, b);
        });
        c.lin2log = p.linearToLogConverter || c.lin2log;
        c.isLog && (c.val2lin = c.log2lin, c.lin2val = c.lin2log);
        q(this, "afterInit");
      },
      setOptions: function (c) {
        this.options = a(this.defaultOptions, "yAxis" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], a(H[this.coll], c));
        q(this, "afterSetOptions", {
          userOptions: c
        });
      },
      defaultLabelFormatter: function () {
        var a = this.axis,
            b = this.value,
            c = a.chart.time,
            f = a.categories,
            e = this.dateTimeLabelFormat,
            l = H.lang,
            k = l.numericSymbols;
        l = l.numericSymbolMagnitude || 1E3;
        var v = k && k.length,
            m = a.options.labels.format;
        a = a.isLog ? Math.abs(b) : a.tickInterval;
        var n = this.chart,
            d = n.numberFormatter;
        if (m) var w = P(m, this, n);else if (f) w = b;else if (e) w = c.dateFormat(e, b);else if (v && 1E3 <= a) for (; v-- && "undefined" === typeof w;) c = Math.pow(l, v + 1), a >= c && 0 === 10 * b % c && null !== k[v] && 0 !== b && (w = d(b / c, -1) + k[v]);
        "undefined" === typeof w && (w = 1E4 <= Math.abs(b) ? d(b, -1) : d(b, -1, void 0, ""));
        return w;
      },
      getSeriesExtremes: function () {
        var a = this,
            b = a.chart,
            c;
        q(this, "getSeriesExtremes", null, function () {
          a.hasVisibleSeries = !1;
          a.dataMin = a.dataMax = a.threshold = null;
          a.softThreshold = !a.isXAxis;
          a.buildStacks && a.buildStacks();
          a.series.forEach(function (f) {
            if (f.visible || !b.options.chart.ignoreHiddenSeries) {
              var e = f.options,
                  p = e.threshold;
              a.hasVisibleSeries = !0;
              a.positiveValuesOnly && 0 >= p && (p = null);

              if (a.isXAxis) {
                if (e = f.xData, e.length) {
                  c = f.getXExtremes(e);
                  var x = c.min;
                  var l = c.max;
                  n(x) || x instanceof Date || (e = e.filter(n), c = f.getXExtremes(e), x = c.min, l = c.max);
                  e.length && (a.dataMin = Math.min(z(a.dataMin, x), x), a.dataMax = Math.max(z(a.dataMax, l), l));
                }
              } else if (f.getExtremes(), l = f.dataMax, x = f.dataMin, t(x) && t(l) && (a.dataMin = Math.min(z(a.dataMin, x), x), a.dataMax = Math.max(z(a.dataMax, l), l)), t(p) && (a.threshold = p), !e.softThreshold || a.positiveValuesOnly) a.softThreshold = !1;
            }
          });
        });
        q(this, "afterGetSeriesExtremes");
      },
      translate: function (a, b, c, f, e, l) {
        var p = this.linkedParent || this,
            x = 1,
            m = 0,
            C = f ? p.oldTransA : p.transA;
        f = f ? p.oldMin : p.min;
        var k = p.minPixelPadding;
        e = (p.isOrdinal || p.isBroken || p.isLog && e) && p.lin2val;
        C || (C = p.transA);
        c && (x *= -1, m = p.len);
        p.reversed && (x *= -1, m -= x * (p.sector || p.len));
        b ? (a = (a * x + m - k) / C + f, e && (a = p.lin2val(a))) : (e && (a = p.val2lin(a)), a = n(f) ? x * (a - f) * C + m + x * k + (n(l) ? C * l : 0) : void 0);
        return a;
      },
      toPixels: function (a, b) {
        return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);
      },
      toValue: function (a, b) {
        return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);
      },
      getPlotLinePath: function (a) {
        var b = this,
            c = b.chart,
            f = b.left,
            e = b.top,
            p = a.old,
            l = a.value,
            k = a.translatedValue,
            m = a.lineWidth,
            v = a.force,
            d,
            w,
            F,
            h,
            B = p && c.oldChartHeight || c.chartHeight,
            L = p && c.oldChartWidth || c.chartWidth,
            t,
            g = b.transB,
            H = function (b, a, c) {
          if ("pass" !== v && b < a || b > c) v ? b = J(b, a, c) : t = !0;
          return b;
        };

        a = {
          value: l,
          lineWidth: m,
          old: p,
          force: v,
          acrossPanes: a.acrossPanes,
          translatedValue: k
        };
        q(this, "getPlotLinePath", a, function (a) {
          k = z(k, b.translate(l, null, null, p));
          k = J(k, -1E5, 1E5);
          d = F = Math.round(k + g);
          w = h = Math.round(B - k - g);
          n(k) ? b.horiz ? (w = e, h = B - b.bottom, d = F = H(d, f, f + b.width)) : (d = f, F = L - b.right, w = h = H(w, e, e + b.height)) : (t = !0, v = !1);
          a.path = t && !v ? null : c.renderer.crispLine(["M", d, w, "L", F, h], m || 1);
        });
        return a.path;
      },
      getLinearTickPositions: function (a, b, c) {
        var f = y(Math.floor(b / a) * a);
        c = y(Math.ceil(c / a) * a);
        var e = [],
            p;
        y(f + a) === f && (p = 20);
        if (this.single) return [b];

        for (b = f; b <= c;) {
          e.push(b);
          b = y(b + a, p);
          if (b === l) break;
          var l = b;
        }

        return e;
      },
      getMinorTickInterval: function () {
        var a = this.options;
        return !0 === a.minorTicks ? z(a.minorTickInterval, "auto") : !1 === a.minorTicks ? null : a.minorTickInterval;
      },
      getMinorTickPositions: function () {
        var a = this,
            b = a.options,
            c = a.tickPositions,
            f = a.minorTickInterval,
            e = [],
            l = a.pointRangePadding || 0,
            k = a.min - l;
        l = a.max + l;
        var v = l - k;
        if (v && v / f < a.len / 3) if (a.isLog) this.paddedTicks.forEach(function (b, c, p) {
          c && e.push.apply(e, a.getLogTickPositions(f, p[c - 1], p[c], !0));
        });else if (a.isDatetimeAxis && "auto" === this.getMinorTickInterval()) e = e.concat(a.getTimeTicks(a.normalizeTimeTickInterval(f), k, l, b.startOfWeek));else for (b = k + (c[0] - k) % f; b <= l && b !== e[0]; b += f) e.push(b);
        0 !== e.length && a.trimTicks(e);
        return e;
      },
      adjustForMinRange: function () {
        var a = this.options,
            b = this.min,
            c = this.max,
            f,
            e,
            l,
            k,
            v;
        this.isXAxis && "undefined" === typeof this.minRange && !this.isLog && (t(a.min) || t(a.max) ? this.minRange = null : (this.series.forEach(function (b) {
          k = b.xData;

          for (e = v = b.xIncrement ? 1 : k.length - 1; 0 < e; e--) if (l = k[e] - k[e - 1], "undefined" === typeof f || l < f) f = l;
        }), this.minRange = Math.min(5 * f, this.dataMax - this.dataMin)));

        if (c - b < this.minRange) {
          var m = this.dataMax - this.dataMin >= this.minRange;
          var n = this.minRange;
          var d = (n - c + b) / 2;
          d = [b - d, z(a.min, b - d)];
          m && (d[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin);
          b = A(d);
          c = [b + n, z(a.max, b + n)];
          m && (c[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax);
          c = G(c);
          c - b < n && (d[0] = c - n, d[1] = z(a.min, c - n), b = A(d));
        }

        this.min = b;
        this.max = c;
      },
      getClosest: function () {
        var a;
        this.categories ? a = 1 : this.series.forEach(function (b) {
          var c = b.closestPointRange,
              f = b.visible || !b.chart.options.chart.ignoreHiddenSeries;
          !b.noSharedTooltip && t(c) && f && (a = t(a) ? Math.min(a, c) : c);
        });
        return a;
      },
      nameToX: function (a) {
        var b = c(this.categories),
            f = b ? this.categories : this.names,
            e = a.options.x;
        a.series.requireSorting = !1;
        t(e) || (e = !1 === this.options.uniqueNames ? a.series.autoIncrement() : b ? f.indexOf(a.name) : z(f.keys[a.name], -1));

        if (-1 === e) {
          if (!b) var p = f.length;
        } else p = e;

        "undefined" !== typeof p && (this.names[p] = a.name, this.names.keys[a.name] = p);
        return p;
      },
      updateNames: function () {
        var a = this,
            b = this.names;
        0 < b.length && (Object.keys(b.keys).forEach(function (a) {
          delete b.keys[a];
        }), b.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (b) {
          b.xIncrement = null;
          if (!b.points || b.isDirtyData) a.max = Math.max(a.max, b.xData.length - 1), b.processData(), b.generatePoints();
          b.data.forEach(function (c, f) {
            if (c && c.options && "undefined" !== typeof c.name) {
              var e = a.nameToX(c);
              "undefined" !== typeof e && e !== c.x && (c.x = e, b.xData[f] = e);
            }
          });
        }));
      },
      setAxisTranslation: function (a) {
        var b = this,
            c = b.max - b.min,
            e = b.axisPointRange || 0,
            p = 0,
            l = 0,
            k = b.linkedParent,
            v = !!b.categories,
            m = b.transA,
            d = b.isXAxis;

        if (d || v || e) {
          var n = b.getClosest();
          k ? (p = k.minPointOffset, l = k.pointRangePadding) : b.series.forEach(function (a) {
            var c = v ? 1 : d ? z(a.options.pointRange, n, 0) : b.axisPointRange || 0,
                x = a.options.pointPlacement;
            e = Math.max(e, c);
            if (!b.single || v) a = a.is("xrange") ? !d : d, p = Math.max(p, a && f(x) ? 0 : c / 2), l = Math.max(l, a && "on" === x ? 0 : c);
          });
          k = b.ordinalSlope && n ? b.ordinalSlope / n : 1;
          b.minPointOffset = p *= k;
          b.pointRangePadding = l *= k;
          b.pointRange = Math.min(e, b.single && v ? 1 : c);
          d && (b.closestPointRange = n);
        }

        a && (b.oldTransA = m);
        b.translationSlope = b.transA = m = b.staticScale || b.len / (c + l || 1);
        b.transB = b.horiz ? b.left : b.bottom;
        b.minPixelPadding = m * p;
        q(this, "afterSetAxisTranslation");
      },
      minFromRange: function () {
        return this.max - this.range;
      },
      setTickInterval: function (a) {
        var b = this,
            c = b.chart,
            f = b.options,
            p = b.isLog,
            k = b.isDatetimeAxis,
            v = b.isXAxis,
            d = b.isLinked,
            m = f.maxPadding,
            w = f.minPadding,
            B = f.tickInterval,
            L = f.tickPixelInterval,
            F = b.categories,
            V = n(b.threshold) ? b.threshold : null,
            g = b.softThreshold;
        k || F || d || this.getTickAmount();
        var H = z(b.userMin, f.min);
        var K = z(b.userMax, f.max);

        if (d) {
          b.linkedParent = c[b.coll][f.linkedTo];
          var Q = b.linkedParent.getExtremes();
          b.min = z(Q.min, Q.dataMin);
          b.max = z(Q.max, Q.dataMax);
          f.type !== b.linkedParent.options.type && h(11, 1, c);
        } else {
          if (!g && t(V)) if (b.dataMin >= V) Q = V, w = 0;else if (b.dataMax <= V) {
            var u = V;
            m = 0;
          }
          b.min = z(H, Q, b.dataMin);
          b.max = z(K, u, b.dataMax);
        }

        p && (b.positiveValuesOnly && !a && 0 >= Math.min(b.min, z(b.dataMin, b.min)) && h(10, 1, c), b.min = y(b.log2lin(b.min), 16), b.max = y(b.log2lin(b.max), 16));
        b.range && t(b.max) && (b.userMin = b.min = H = Math.max(b.dataMin, b.minFromRange()), b.userMax = K = b.max, b.range = null);
        q(b, "foundExtremes");
        b.beforePadding && b.beforePadding();
        b.adjustForMinRange();
        !(F || b.axisPointRange || b.usePercentage || d) && t(b.min) && t(b.max) && (c = b.max - b.min) && (!t(H) && w && (b.min -= c * w), !t(K) && m && (b.max += c * m));
        n(b.userMin) || (n(f.softMin) && f.softMin < b.min && (b.min = H = f.softMin), n(f.floor) && (b.min = Math.max(b.min, f.floor)));
        n(b.userMax) || (n(f.softMax) && f.softMax > b.max && (b.max = K = f.softMax), n(f.ceiling) && (b.max = Math.min(b.max, f.ceiling)));
        g && t(b.dataMin) && (V = V || 0, !t(H) && b.min < V && b.dataMin >= V ? b.min = b.options.minRange ? Math.min(V, b.max - b.minRange) : V : !t(K) && b.max > V && b.dataMax <= V && (b.max = b.options.minRange ? Math.max(V, b.min + b.minRange) : V));
        b.tickInterval = b.min === b.max || "undefined" === typeof b.min || "undefined" === typeof b.max ? 1 : d && !B && L === b.linkedParent.options.tickPixelInterval ? B = b.linkedParent.tickInterval : z(B, this.tickAmount ? (b.max - b.min) / Math.max(this.tickAmount - 1, 1) : void 0, F ? 1 : (b.max - b.min) * L / Math.max(b.len, L));
        v && !a && b.series.forEach(function (a) {
          a.processData(b.min !== b.oldMin || b.max !== b.oldMax);
        });
        b.setAxisTranslation(!0);
        b.beforeSetTickPositions && b.beforeSetTickPositions();
        b.postProcessTickInterval && (b.tickInterval = b.postProcessTickInterval(b.tickInterval));
        b.pointRange && !B && (b.tickInterval = Math.max(b.pointRange, b.tickInterval));
        a = z(f.minTickInterval, b.isDatetimeAxis && b.closestPointRange);
        !B && b.tickInterval < a && (b.tickInterval = a);
        k || p || B || (b.tickInterval = l(b.tickInterval, null, e(b.tickInterval), z(f.allowDecimals, !(.5 < b.tickInterval && 5 > b.tickInterval && 1E3 < b.max && 9999 > b.max)), !!this.tickAmount));
        this.tickAmount || (b.tickInterval = b.unsquish());
        this.setTickPositions();
      },
      setTickPositions: function () {
        var a = this.options,
            b = a.tickPositions;
        var c = this.getMinorTickInterval();
        var f = a.tickPositioner,
            e = a.startOnTick,
            l = a.endOnTick;
        this.tickmarkOffset = this.categories && "between" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
        this.minorTickInterval = "auto" === c && this.tickInterval ? this.tickInterval / 5 : c;
        this.single = this.min === this.max && t(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== a.allowDecimals);
        this.tickPositions = c = b && b.slice();
        !c && (!this.ordinalPositions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200) ? (c = [this.min, this.max], h(19, !1, this.chart)) : c = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), c.length > this.len && (c = [c[0], c.pop()], c[0] === c[1] && (c.length = 1)), this.tickPositions = c, f && (f = f.apply(this, [this.min, this.max]))) && (this.tickPositions = c = f);
        this.paddedTicks = c.slice(0);
        this.trimTicks(c, e, l);
        this.isLinked || (this.single && 2 > c.length && !this.categories && !this.series.some(function (b) {
          return b.is("heatmap") && "between" === b.options.pointPlacement;
        }) && (this.min -= .5, this.max += .5), b || f || this.adjustTickAmount());
        q(this, "afterSetTickPositions");
      },
      trimTicks: function (a, b, c) {
        var f = a[0],
            e = a[a.length - 1],
            p = !this.isOrdinal && this.minPointOffset || 0;
        q(this, "trimTicks");

        if (!this.isLinked) {
          if (b && -Infinity !== f) this.min = f;else for (; this.min - p > a[0];) a.shift();
          if (c) this.max = e;else for (; this.max + p < a[a.length - 1];) a.pop();
          0 === a.length && t(f) && !this.options.tickPositions && a.push((e + f) / 2);
        }
      },
      alignToOthers: function () {
        var a = {},
            b,
            c = this.options;
        !1 === this.chart.options.chart.alignTicks || !1 === c.alignTicks || !1 === c.startOnTick || !1 === c.endOnTick || this.isLog || this.chart[this.coll].forEach(function (c) {
          var f = c.options;
          f = [c.horiz ? f.left : f.top, f.width, f.height, f.pane].join();
          c.series.length && (a[f] ? b = !0 : a[f] = 1);
        });
        return b;
      },
      getTickAmount: function () {
        var a = this.options,
            b = a.tickAmount,
            c = a.tickPixelInterval;
        !t(a.tickInterval) && this.len < c && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (b = 2);
        !b && this.alignToOthers() && (b = Math.ceil(this.len / c) + 1);
        4 > b && (this.finalTickAmt = b, b = 5);
        this.tickAmount = b;
      },
      adjustTickAmount: function () {
        var a = this.options,
            b = this.tickInterval,
            c = this.tickPositions,
            f = this.tickAmount,
            e = this.finalTickAmt,
            l = c && c.length,
            k = z(this.threshold, this.softThreshold ? 0 : null),
            v;

        if (this.hasData()) {
          if (l < f) {
            for (v = this.min; c.length < f;) c.length % 2 || v === k ? c.push(y(c[c.length - 1] + b)) : c.unshift(y(c[0] - b));

            this.transA *= (l - 1) / (f - 1);
            this.min = a.startOnTick ? c[0] : Math.min(this.min, c[0]);
            this.max = a.endOnTick ? c[c.length - 1] : Math.max(this.max, c[c.length - 1]);
          } else l > f && (this.tickInterval *= 2, this.setTickPositions());

          if (t(e)) {
            for (b = a = c.length; b--;) (3 === e && 1 === b % 2 || 2 >= e && 0 < b && b < a - 1) && c.splice(b, 1);

            this.finalTickAmt = void 0;
          }
        }
      },
      setScale: function () {
        var a = this.series.some(function (b) {
          return b.isDirtyData || b.isDirty || b.xAxis && b.xAxis.isDirty;
        }),
            b;
        this.oldMin = this.min;
        this.oldMax = this.max;
        this.oldAxisLength = this.len;
        this.setAxisSize();
        (b = this.len !== this.oldAxisLength) || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();
        q(this, "afterSetScale");
      },
      setExtremes: function (a, b, c, f, e) {
        var p = this,
            l = p.chart;
        c = z(c, !0);
        p.series.forEach(function (b) {
          delete b.kdTree;
        });
        e = N(e, {
          min: a,
          max: b
        });
        q(p, "setExtremes", e, function () {
          p.userMin = a;
          p.userMax = b;
          p.eventArgs = e;
          c && l.redraw(f);
        });
      },
      zoom: function (a, b) {
        var c = this.dataMin,
            f = this.dataMax,
            e = this.options,
            p = Math.min(c, z(e.min, c)),
            l = Math.max(f, z(e.max, f));
        a = {
          newMin: a,
          newMax: b
        };
        q(this, "zoom", a, function (b) {
          var a = b.newMin,
              e = b.newMax;
          if (a !== this.min || e !== this.max) this.allowZoomOutside || (t(c) && (a < p && (a = p), a > l && (a = l)), t(f) && (e < p && (e = p), e > l && (e = l))), this.displayBtn = "undefined" !== typeof a || "undefined" !== typeof e, this.setExtremes(a, e, !1, void 0, {
            trigger: "zoom"
          });
          b.zoomed = !0;
        });
        return a.zoomed;
      },
      setAxisSize: function () {
        var a = this.chart,
            b = this.options,
            c = b.offsets || [0, 0, 0, 0],
            f = this.horiz,
            e = this.width = Math.round(w(z(b.width, a.plotWidth - c[3] + c[1]), a.plotWidth)),
            l = this.height = Math.round(w(z(b.height, a.plotHeight - c[0] + c[2]), a.plotHeight)),
            k = this.top = Math.round(w(z(b.top, a.plotTop + c[0]), a.plotHeight, a.plotTop));
        b = this.left = Math.round(w(z(b.left, a.plotLeft + c[3]), a.plotWidth, a.plotLeft));
        this.bottom = a.chartHeight - l - k;
        this.right = a.chartWidth - e - b;
        this.len = Math.max(f ? e : l, 0);
        this.pos = f ? b : k;
      },
      getExtremes: function () {
        var a = this.isLog;
        return {
          min: a ? y(this.lin2log(this.min)) : this.min,
          max: a ? y(this.lin2log(this.max)) : this.max,
          dataMin: this.dataMin,
          dataMax: this.dataMax,
          userMin: this.userMin,
          userMax: this.userMax
        };
      },
      getThreshold: function (a) {
        var b = this.isLog,
            c = b ? this.lin2log(this.min) : this.min;
        b = b ? this.lin2log(this.max) : this.max;
        null === a || -Infinity === a ? a = c : Infinity === a ? a = b : c > a ? a = c : b < a && (a = b);
        return this.translate(a, 0, 1, 0, 1);
      },
      autoLabelAlign: function (a) {
        var b = (z(a, 0) - 90 * this.side + 720) % 360;
        a = {
          align: "center"
        };
        q(this, "autoLabelAlign", a, function (a) {
          15 < b && 165 > b ? a.align = "right" : 195 < b && 345 > b && (a.align = "left");
        });
        return a.align;
      },
      tickSize: function (a) {
        var b = this.options,
            c = b[a + "Length"],
            f = z(b[a + "Width"], "tick" === a && this.isXAxis && !this.categories ? 1 : 0);

        if (f && c) {
          "inside" === b[a + "Position"] && (c = -c);
          var e = [c, f];
        }

        a = {
          tickSize: e
        };
        q(this, "afterTickSize", a);
        return a.tickSize;
      },
      labelMetrics: function () {
        var a = this.tickPositions && this.tickPositions[0] || 0;
        return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);
      },
      unsquish: function () {
        var a = this.options.labels,
            b = this.horiz,
            c = this.tickInterval,
            f = c,
            e = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / c),
            l,
            k = a.rotation,
            v = this.labelMetrics(),
            m,
            d = Number.MAX_VALUE,
            n,
            w = this.max - this.min,
            F = function (b) {
          var a = b / (e || 1);
          a = 1 < a ? Math.ceil(a) : 1;
          a * c > w && Infinity !== b && Infinity !== e && w && (a = Math.ceil(w / c));
          return y(a * c);
        };

        b ? (n = !a.staggerLines && !a.step && (t(k) ? [k] : e < z(a.autoRotationLimit, 80) && a.autoRotation)) && n.forEach(function (b) {
          if (b === k || b && -90 <= b && 90 >= b) {
            m = F(Math.abs(v.h / Math.sin(K * b)));
            var a = m + Math.abs(b / 360);
            a < d && (d = a, l = b, f = m);
          }
        }) : a.step || (f = F(v.h));
        this.autoRotation = n;
        this.labelRotation = z(l, k);
        return f;
      },
      getSlotWidth: function (a) {
        var b = this.chart,
            c = this.horiz,
            f = this.options.labels,
            e = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
            l = b.margin[3];
        return a && a.slotWidth || c && 2 > (f.step || 0) && !f.rotation && (this.staggerLines || 1) * this.len / e || !c && (f.style && parseInt(f.style.width, 10) || l && l - b.spacing[3] || .33 * b.chartWidth);
      },
      renderUnsquish: function () {
        var a = this.chart,
            b = a.renderer,
            c = this.tickPositions,
            e = this.ticks,
            l = this.options.labels,
            k = l && l.style || {},
            v = this.horiz,
            d = this.getSlotWidth(),
            m = Math.max(1, Math.round(d - 2 * (l.padding || 5))),
            n = {},
            w = this.labelMetrics(),
            h = l.style && l.style.textOverflow,
            F = 0;
        f(l.rotation) || (n.rotation = l.rotation || 0);
        c.forEach(function (b) {
          b = e[b];
          b.movedLabel && b.replaceMovedLabel();
          b && b.label && b.label.textPxLength > F && (F = b.label.textPxLength);
        });
        this.maxLabelLength = F;
        if (this.autoRotation) F > m && F > w.h ? n.rotation = this.labelRotation : this.labelRotation = 0;else if (d) {
          var z = m;

          if (!h) {
            var q = "clip";

            for (m = c.length; !v && m--;) {
              var B = c[m];
              if (B = e[B].label) B.styles && "ellipsis" === B.styles.textOverflow ? B.css({
                textOverflow: "clip"
              }) : B.textPxLength > d && B.css({
                width: d + "px"
              }), B.getBBox().height > this.len / c.length - (w.h - w.f) && (B.specificTextOverflow = "ellipsis");
            }
          }
        }
        n.rotation && (z = F > .5 * a.chartHeight ? .33 * a.chartHeight : F, h || (q = "ellipsis"));
        if (this.labelAlign = l.align || this.autoLabelAlign(this.labelRotation)) n.align = this.labelAlign;
        c.forEach(function (b) {
          var a = (b = e[b]) && b.label,
              c = k.width,
              f = {};
          a && (a.attr(n), b.shortenLabel ? b.shortenLabel() : z && !c && "nowrap" !== k.whiteSpace && (z < a.textPxLength || "SPAN" === a.element.tagName) ? (f.width = z, h || (f.textOverflow = a.specificTextOverflow || q), a.css(f)) : a.styles && a.styles.width && !f.width && !c && a.css({
            width: null
          }), delete a.specificTextOverflow, b.rotation = n.rotation);
        }, this);
        this.tickRotCorr = b.rotCorr(w.b, this.labelRotation || 0, 0 !== this.side);
      },
      hasData: function () {
        return this.series.some(function (a) {
          return a.hasData();
        }) || this.options.showEmpty && t(this.min) && t(this.max);
      },
      addTitle: function (c) {
        var b = this.chart.renderer,
            f = this.horiz,
            e = this.opposite,
            l = this.options.title,
            p,
            k = this.chart.styledMode;
        this.axisTitle || ((p = l.textAlign) || (p = (f ? {
          low: "left",
          middle: "center",
          high: "right"
        } : {
          low: e ? "right" : "left",
          middle: "center",
          high: e ? "left" : "right"
        })[l.align]), this.axisTitle = b.text(l.text, 0, 0, l.useHTML).attr({
          zIndex: 7,
          rotation: l.rotation || 0,
          align: p
        }).addClass("highcharts-axis-title"), k || this.axisTitle.css(a(l.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);
        k || l.style.width || this.isRadial || this.axisTitle.css({
          width: this.len
        });
        this.axisTitle[c ? "show" : "hide"](c);
      },
      generateTick: function (a) {
        var b = this.ticks;
        b[a] ? b[a].addLabel() : b[a] = new r(this, a);
      },
      getOffset: function () {
        var a = this,
            b = a.chart,
            c = b.renderer,
            f = a.options,
            e = a.tickPositions,
            l = a.ticks,
            k = a.horiz,
            d = a.side,
            m = b.inverted && !a.isZAxis ? [1, 0, 3, 2][d] : d,
            n,
            w = 0,
            h = 0,
            F = f.title,
            B = f.labels,
            L = 0,
            g = b.axisOffset;
        b = b.clipOffset;
        var H = [-1, 1, 1, -1][d],
            K = f.className,
            Q = a.axisParent;
        var y = a.hasData();
        a.showAxis = n = y || z(f.showEmpty, !0);
        a.staggerLines = a.horiz && B.staggerLines;
        a.axisGroup || (a.gridGroup = c.g("grid").attr({
          zIndex: f.gridZIndex || 1
        }).addClass("highcharts-" + this.coll.toLowerCase() + "-grid " + (K || "")).add(Q), a.axisGroup = c.g("axis").attr({
          zIndex: f.zIndex || 2
        }).addClass("highcharts-" + this.coll.toLowerCase() + " " + (K || "")).add(Q), a.labelGroup = c.g("axis-labels").attr({
          zIndex: B.zIndex || 7
        }).addClass("highcharts-" + a.coll.toLowerCase() + "-labels " + (K || "")).add(Q));
        y || a.isLinked ? (e.forEach(function (b, c) {
          a.generateTick(b, c);
        }), a.renderUnsquish(), a.reserveSpaceDefault = 0 === d || 2 === d || {
          1: "left",
          3: "right"
        }[d] === a.labelAlign, z(B.reserveSpace, "center" === a.labelAlign ? !0 : null, a.reserveSpaceDefault) && e.forEach(function (b) {
          L = Math.max(l[b].getLabelSize(), L);
        }), a.staggerLines && (L *= a.staggerLines), a.labelOffset = L * (a.opposite ? -1 : 1)) : v(l, function (b, a) {
          b.destroy();
          delete l[a];
        });

        if (F && F.text && !1 !== F.enabled && (a.addTitle(n), n && !1 !== F.reserveSpace)) {
          a.titleOffset = w = a.axisTitle.getBBox()[k ? "height" : "width"];
          var u = F.offset;
          h = t(u) ? 0 : z(F.margin, k ? 5 : 10);
        }

        a.renderLine();
        a.offset = H * z(f.offset, g[d] ? g[d] + (f.margin || 0) : 0);
        a.tickRotCorr = a.tickRotCorr || {
          x: 0,
          y: 0
        };
        c = 0 === d ? -a.labelMetrics().h : 2 === d ? a.tickRotCorr.y : 0;
        h = Math.abs(L) + h;
        L && (h = h - c + H * (k ? z(B.y, a.tickRotCorr.y + 8 * H) : B.x));
        a.axisTitleMargin = z(u, h);
        a.getMaxLabelDimensions && (a.maxLabelDimensions = a.getMaxLabelDimensions(l, e));
        k = this.tickSize("tick");
        g[d] = Math.max(g[d], a.axisTitleMargin + w + H * a.offset, h, e && e.length && k ? k[0] + H * a.offset : 0);
        f = f.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);
        b[m] = Math.max(b[m], f);
        q(this, "afterGetOffset");
      },
      getLinePath: function (a) {
        var b = this.chart,
            c = this.opposite,
            f = this.offset,
            e = this.horiz,
            l = this.left + (c ? this.width : 0) + f;
        f = b.chartHeight - this.bottom - (c ? this.height : 0) + f;
        c && (a *= -1);
        return b.renderer.crispLine(["M", e ? this.left : l, e ? f : this.top, "L", e ? b.chartWidth - this.right : l, e ? f : b.chartHeight - this.bottom], a);
      },
      renderLine: function () {
        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
          stroke: this.options.lineColor,
          "stroke-width": this.options.lineWidth,
          zIndex: 7
        }));
      },
      getTitlePosition: function () {
        var a = this.horiz,
            b = this.left,
            c = this.top,
            f = this.len,
            e = this.options.title,
            l = a ? b : c,
            k = this.opposite,
            d = this.offset,
            m = e.x || 0,
            v = e.y || 0,
            n = this.axisTitle,
            w = this.chart.renderer.fontMetrics(e.style && e.style.fontSize, n);
        n = Math.max(n.getBBox(null, 0).height - w.h - 1, 0);
        f = {
          low: l + (a ? 0 : f),
          middle: l + f / 2,
          high: l + (a ? f : 0)
        }[e.align];
        b = (a ? c + this.height : b) + (a ? 1 : -1) * (k ? -1 : 1) * this.axisTitleMargin + [-n, n, w.f, -n][this.side];
        a = {
          x: a ? f + m : b + (k ? this.width : 0) + d + m,
          y: a ? b + v - (k ? this.height : 0) + d : f + v
        };
        q(this, "afterGetTitlePosition", {
          titlePosition: a
        });
        return a;
      },
      renderMinorTick: function (a) {
        var b = this.chart.hasRendered && n(this.oldMin),
            c = this.minorTicks;
        c[a] || (c[a] = new r(this, a, "minor"));
        b && c[a].isNew && c[a].render(null, !0);
        c[a].render(null, !1, 1);
      },
      renderTick: function (a, b) {
        var c = this.isLinked,
            f = this.ticks,
            e = this.chart.hasRendered && n(this.oldMin);
        if (!c || a >= this.min && a <= this.max) f[a] || (f[a] = new r(this, a)), e && f[a].isNew && f[a].render(b, !0, -1), f[a].render(b);
      },
      render: function () {
        var a = this,
            b = a.chart,
            c = a.options,
            f = a.isLog,
            e = a.isLinked,
            l = a.tickPositions,
            k = a.axisTitle,
            w = a.ticks,
            m = a.minorTicks,
            h = a.alternateBands,
            z = c.stackLabels,
            B = c.alternateGridColor,
            F = a.tickmarkOffset,
            L = a.axisLine,
            t = a.showAxis,
            g = E(b.renderer.globalAnimation),
            H,
            K;
        a.labelEdge.length = 0;
        a.overlap = !1;
        [w, m, h].forEach(function (b) {
          v(b, function (b) {
            b.isActive = !1;
          });
        });
        if (a.hasData() || e) a.minorTickInterval && !a.categories && a.getMinorTickPositions().forEach(function (b) {
          a.renderMinorTick(b);
        }), l.length && (l.forEach(function (b, c) {
          a.renderTick(b, c);
        }), F && (0 === a.min || a.single) && (w[-1] || (w[-1] = new r(a, -1, null, !0)), w[-1].render(-1))), B && l.forEach(function (c, e) {
          K = "undefined" !== typeof l[e + 1] ? l[e + 1] + F : a.max - F;
          0 === e % 2 && c < a.max && K <= a.max + (b.polar ? -F : F) && (h[c] || (h[c] = new d.PlotLineOrBand(a)), H = c + F, h[c].options = {
            from: f ? a.lin2log(H) : H,
            to: f ? a.lin2log(K) : K,
            color: B
          }, h[c].render(), h[c].isActive = !0);
        }), a._addedPlotLB || ((c.plotLines || []).concat(c.plotBands || []).forEach(function (b) {
          a.addPlotBandOrLine(b);
        }), a._addedPlotLB = !0);
        [w, m, h].forEach(function (a) {
          var c,
              f = [],
              e = g.duration;
          v(a, function (b, a) {
            b.isActive || (b.render(a, !1, 0), b.isActive = !1, f.push(a));
          });
          Q(function () {
            for (c = f.length; c--;) a[f[c]] && !a[f[c]].isActive && (a[f[c]].destroy(), delete a[f[c]]);
          }, a !== h && b.hasRendered && e ? e : 0);
        });
        L && (L[L.isPlaced ? "animate" : "attr"]({
          d: this.getLinePath(L.strokeWidth())
        }), L.isPlaced = !0, L[t ? "show" : "hide"](t));
        k && t && (c = a.getTitlePosition(), n(c.y) ? (k[k.isNew ? "attr" : "animate"](c), k.isNew = !1) : (k.attr("y", -9999), k.isNew = !0));
        z && z.enabled && a.renderStackTotals();
        a.isDirty = !1;
        q(this, "afterRender");
      },
      redraw: function () {
        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (a) {
          a.render();
        }));
        this.series.forEach(function (a) {
          a.isDirty = !0;
        });
      },
      keepProps: "extKey hcEvents names series userMax userMin".split(" "),
      destroy: function (a) {
        var b = this,
            c = b.stacks,
            f = b.plotLinesAndBands,
            e;
        q(this, "destroy", {
          keepEvents: a
        });
        a || B(b);
        v(c, function (b, a) {
          D(b);
          c[a] = null;
        });
        [b.ticks, b.minorTicks, b.alternateBands].forEach(function (b) {
          D(b);
        });
        if (f) for (a = f.length; a--;) f[a].destroy();
        "stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (a) {
          b[a] && (b[a] = b[a].destroy());
        });

        for (e in b.plotLinesAndBandsGroups) b.plotLinesAndBandsGroups[e] = b.plotLinesAndBandsGroups[e].destroy();

        v(b, function (a, c) {
          -1 === b.keepProps.indexOf(c) && delete b[c];
        });
      },
      drawCrosshair: function (a, b) {
        var c = this.crosshair,
            f = z(c.snap, !0),
            e,
            l = this.cross,
            k = this.chart;
        q(this, "drawCrosshair", {
          e: a,
          point: b
        });
        a || (a = this.cross && this.cross.e);

        if (this.crosshair && !1 !== (t(b) || !f)) {
          f ? t(b) && (e = z("colorAxis" !== this.coll ? b.crosshairPos : null, this.isXAxis ? b.plotX : this.len - b.plotY)) : e = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);

          if (t(e)) {
            var d = {
              value: b && (this.isXAxis ? b.x : z(b.stackY, b.y)),
              translatedValue: e
            };
            k.polar && N(d, {
              isCrosshair: !0,
              chartX: a && a.chartX,
              chartY: a && a.chartY,
              point: b
            });
            d = this.getPlotLinePath(d) || null;
          }

          if (!t(d)) {
            this.hideCrosshair();
            return;
          }

          f = this.categories && !this.isRadial;
          l || (this.cross = l = k.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (f ? "category " : "thin ") + c.className).attr({
            zIndex: z(c.zIndex, 2)
          }).add(), k.styledMode || (l.attr({
            stroke: c.color || (f ? I("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
            "stroke-width": z(c.width, 1)
          }).css({
            "pointer-events": "none"
          }), c.dashStyle && l.attr({
            dashstyle: c.dashStyle
          })));
          l.show().attr({
            d: d
          });
          f && !c.width && l.attr({
            "stroke-width": this.transA
          });
          this.cross.e = a;
        } else this.hideCrosshair();

        q(this, "afterDrawCrosshair", {
          e: a,
          point: b
        });
      },
      hideCrosshair: function () {
        this.cross && this.cross.hide();
        q(this, "afterHideCrosshair");
      }
    });
    return d.Axis = g;
  });
  S(r, "parts/DateTimeAxis.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.getMagnitude,
        u = g.normalizeTickInterval,
        I = g.timeUnits;
    d = d.Axis;

    d.prototype.getTimeTicks = function () {
      return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
    };

    d.prototype.normalizeTimeTickInterval = function (d, g) {
      var A = g || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
      g = A[A.length - 1];
      var G = I[g[0]],
          E = g[1],
          y;

      for (y = 0; y < A.length && !(g = A[y], G = I[g[0]], E = g[1], A[y + 1] && d <= (G * E[E.length - 1] + I[A[y + 1][0]]) / 2); y++);

      G === I.year && d < 5 * G && (E = [1, 2, 5]);
      d = u(d / G, E, "year" === g[0] ? Math.max(r(d / G), 1) : 1);
      return {
        unitRange: G,
        count: d,
        unitName: g[0]
      };
    };
  });
  S(r, "parts/LogarithmicAxis.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.getMagnitude,
        u = g.normalizeTickInterval,
        I = g.pick;
    d = d.Axis;

    d.prototype.getLogTickPositions = function (d, g, A, G) {
      var E = this.options,
          y = this.len,
          t = [];
      G || (this._minorAutoInterval = null);
      if (.5 <= d) d = Math.round(d), t = this.getLinearTickPositions(d, g, A);else if (.08 <= d) {
        y = Math.floor(g);
        var D, h;

        for (E = .3 < d ? [1, 2, 4] : .15 < d ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; y < A + 1 && !h; y++) {
          var N = E.length;

          for (D = 0; D < N && !h; D++) {
            var q = this.log2lin(this.lin2log(y) * E[D]);
            q > g && (!G || P <= A) && "undefined" !== typeof P && t.push(P);
            P > A && (h = !0);
            var P = q;
          }
        }
      } else g = this.lin2log(g), A = this.lin2log(A), d = G ? this.getMinorTickInterval() : E.tickInterval, d = I("auto" === d ? null : d, this._minorAutoInterval, E.tickPixelInterval / (G ? 5 : 1) * (A - g) / ((G ? y / this.tickPositions.length : y) || 1)), d = u(d, null, r(d)), t = this.getLinearTickPositions(d, g, A).map(this.log2lin), G || (this._minorAutoInterval = d / 5);
      G || (this.tickInterval = d);
      return t;
    };

    d.prototype.log2lin = function (d) {
      return Math.log(d) / Math.LN10;
    };

    d.prototype.lin2log = function (d) {
      return Math.pow(10, d);
    };
  });
  S(r, "parts/PlotLineOrBand.js", [r["parts/Globals.js"], r["parts/Axis.js"], r["parts/Utilities.js"]], function (d, g, r) {
    var u = r.arrayMax,
        I = r.arrayMin,
        M = r.defined,
        E = r.destroyObjectProperties,
        A = r.erase,
        G = r.extend,
        J = r.merge,
        y = r.objectEach,
        t = r.pick,
        D = function () {
      function h(d, h) {
        this.axis = d;
        h && (this.options = h, this.id = h.id);
      }

      h.prototype.render = function () {
        d.fireEvent(this, "render");
        var h = this,
            q = h.axis,
            g = q.horiz,
            e = h.options,
            c = e.label,
            k = h.label,
            n = e.to,
            f = e.from,
            a = e.value,
            l = M(f) && M(n),
            v = M(a),
            z = h.svgElem,
            w = !z,
            B = [],
            L = e.color,
            Q = t(e.zIndex, 0),
            H = e.events;
        B = {
          "class": "highcharts-plot-" + (l ? "band " : "line ") + (e.className || "")
        };
        var K = {},
            p = q.chart.renderer,
            b = l ? "bands" : "lines";
        q.isLog && (f = q.log2lin(f), n = q.log2lin(n), a = q.log2lin(a));
        q.chart.styledMode || (v ? (B.stroke = L || "#999999", B["stroke-width"] = t(e.width, 1), e.dashStyle && (B.dashstyle = e.dashStyle)) : l && (B.fill = L || "#e6ebf5", e.borderWidth && (B.stroke = e.borderColor, B["stroke-width"] = e.borderWidth)));
        K.zIndex = Q;
        b += "-" + Q;
        (L = q.plotLinesAndBandsGroups[b]) || (q.plotLinesAndBandsGroups[b] = L = p.g("plot-" + b).attr(K).add());
        w && (h.svgElem = z = p.path().attr(B).add(L));
        if (v) B = q.getPlotLinePath({
          value: a,
          lineWidth: z.strokeWidth(),
          acrossPanes: e.acrossPanes
        });else if (l) B = q.getPlotBandPath(f, n, e);else return;
        (w || !z.d) && B && B.length ? (z.attr({
          d: B
        }), H && y(H, function (b, a) {
          z.on(a, function (b) {
            H[a].apply(h, [b]);
          });
        })) : z && (B ? (z.show(!0), z.animate({
          d: B
        })) : z.d && (z.hide(), k && (h.label = k = k.destroy())));
        c && (M(c.text) || M(c.formatter)) && B && B.length && 0 < q.width && 0 < q.height && !B.isFlat ? (c = J({
          align: g && l && "center",
          x: g ? !l && 4 : 10,
          verticalAlign: !g && l && "middle",
          y: g ? l ? 16 : 10 : l ? 6 : -4,
          rotation: g && !l && 90
        }, c), this.renderLabel(c, B, l, Q)) : k && k.hide();
        return h;
      };

      h.prototype.renderLabel = function (d, h, g, e) {
        var c = this.label,
            k = this.axis.chart.renderer;
        c || (c = {
          align: d.textAlign || d.align,
          rotation: d.rotation,
          "class": "highcharts-plot-" + (g ? "band" : "line") + "-label " + (d.className || "")
        }, c.zIndex = e, e = this.getLabelText(d), this.label = c = k.text(e, 0, 0, d.useHTML).attr(c).add(), this.axis.chart.styledMode || c.css(d.style));
        k = h.xBounds || [h[1], h[4], g ? h[6] : h[1]];
        h = h.yBounds || [h[2], h[5], g ? h[7] : h[2]];
        g = I(k);
        e = I(h);
        c.align(d, !1, {
          x: g,
          y: e,
          width: u(k) - g,
          height: u(h) - e
        });
        c.show(!0);
      };

      h.prototype.getLabelText = function (d) {
        return M(d.formatter) ? d.formatter.call(this) : d.text;
      };

      h.prototype.destroy = function () {
        A(this.axis.plotLinesAndBands, this);
        delete this.axis;
        E(this);
      };

      return h;
    }();

    G(g.prototype, {
      getPlotBandPath: function (d, g) {
        var h = this.getPlotLinePath({
          value: g,
          force: !0,
          acrossPanes: this.options.acrossPanes
        }),
            t = this.getPlotLinePath({
          value: d,
          force: !0,
          acrossPanes: this.options.acrossPanes
        }),
            e = [],
            c = this.horiz,
            k = 1;
        d = d < this.min && g < this.min || d > this.max && g > this.max;

        if (t && h) {
          if (d) {
            var n = t.toString() === h.toString();
            k = 0;
          }

          for (d = 0; d < t.length; d += 6) c && h[d + 1] === t[d + 1] ? (h[d + 1] += k, h[d + 4] += k) : c || h[d + 2] !== t[d + 2] || (h[d + 2] += k, h[d + 5] += k), e.push("M", t[d + 1], t[d + 2], "L", t[d + 4], t[d + 5], h[d + 4], h[d + 5], h[d + 1], h[d + 2], "z"), e.isFlat = n;
        }

        return e;
      },
      addPlotBand: function (d) {
        return this.addPlotBandOrLine(d, "plotBands");
      },
      addPlotLine: function (d) {
        return this.addPlotBandOrLine(d, "plotLines");
      },
      addPlotBandOrLine: function (d, g) {
        var h = new D(this, d).render(),
            t = this.userOptions;

        if (h) {
          if (g) {
            var e = t[g] || [];
            e.push(d);
            t[g] = e;
          }

          this.plotLinesAndBands.push(h);
        }

        return h;
      },
      removePlotBandOrLine: function (d) {
        for (var h = this.plotLinesAndBands, q = this.options, g = this.userOptions, e = h.length; e--;) h[e].id === d && h[e].destroy();

        [q.plotLines || [], g.plotLines || [], q.plotBands || [], g.plotBands || []].forEach(function (c) {
          for (e = c.length; e--;) c[e].id === d && A(c, c[e]);
        });
      },
      removePlotBand: function (d) {
        this.removePlotBandOrLine(d);
      },
      removePlotLine: function (d) {
        this.removePlotBandOrLine(d);
      }
    });
    d.PlotLineOrBand = D;
    return d.PlotLineOrBand;
  });
  S(r, "parts/Tooltip.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.clamp,
        u = g.css,
        I = g.defined,
        M = g.discardElement,
        E = g.extend,
        A = g.format,
        G = g.isNumber,
        J = g.isString,
        y = g.merge,
        t = g.pick,
        D = g.splat,
        h = g.syncTimeout,
        N = g.timeUnits;
    "";

    var q = d.doc,
        P = function () {
      function e(c, e) {
        this.crosshairs = [];
        this.distance = 0;
        this.isHidden = !0;
        this.isSticky = !1;
        this.now = {};
        this.options = {};
        this.outside = !1;
        this.chart = c;
        this.init(c, e);
      }

      e.prototype.applyFilter = function () {
        var c = this.chart;
        c.renderer.definition({
          tagName: "filter",
          id: "drop-shadow-" + c.index,
          opacity: .5,
          children: [{
            tagName: "feGaussianBlur",
            "in": "SourceAlpha",
            stdDeviation: 1
          }, {
            tagName: "feOffset",
            dx: 1,
            dy: 1
          }, {
            tagName: "feComponentTransfer",
            children: [{
              tagName: "feFuncA",
              type: "linear",
              slope: .3
            }]
          }, {
            tagName: "feMerge",
            children: [{
              tagName: "feMergeNode"
            }, {
              tagName: "feMergeNode",
              "in": "SourceGraphic"
            }]
          }]
        });
        c.renderer.definition({
          tagName: "style",
          textContent: ".highcharts-tooltip-" + c.index + "{filter:url(#drop-shadow-" + c.index + ")}"
        });
      };

      e.prototype.bodyFormatter = function (c) {
        return c.map(function (c) {
          var e = c.series.tooltipOptions;
          return (e[(c.point.formatPrefix || "point") + "Formatter"] || c.point.tooltipFormatter).call(c.point, e[(c.point.formatPrefix || "point") + "Format"] || "");
        });
      };

      e.prototype.cleanSplit = function (c) {
        this.chart.series.forEach(function (e) {
          var d = e && e.tt;
          d && (!d.isActive || c ? e.tt = d.destroy() : d.isActive = !1);
        });
      };

      e.prototype.defaultFormatter = function (c) {
        var e = this.points || D(this);
        var d = [c.tooltipFooterHeaderFormatter(e[0])];
        d = d.concat(c.bodyFormatter(e));
        d.push(c.tooltipFooterHeaderFormatter(e[0], !0));
        return d;
      };

      e.prototype.destroy = function () {
        this.label && (this.label = this.label.destroy());
        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());
        this.renderer && (this.renderer = this.renderer.destroy(), M(this.container));
        g.clearTimeout(this.hideTimer);
        g.clearTimeout(this.tooltipTimeout);
      };

      e.prototype.getAnchor = function (c, e) {
        var d = this.chart,
            f = d.pointer,
            a = d.inverted,
            l = d.plotTop,
            k = d.plotLeft,
            h = 0,
            w = 0,
            B,
            q;
        c = D(c);
        this.followPointer && e ? ("undefined" === typeof e.chartX && (e = f.normalize(e)), c = [e.chartX - k, e.chartY - l]) : c[0].tooltipPos ? c = c[0].tooltipPos : (c.forEach(function (c) {
          B = c.series.yAxis;
          q = c.series.xAxis;
          h += c.plotX + (!a && q ? q.left - k : 0);
          w += (c.plotLow ? (c.plotLow + c.plotHigh) / 2 : c.plotY) + (!a && B ? B.top - l : 0);
        }), h /= c.length, w /= c.length, c = [a ? d.plotWidth - w : h, this.shared && !a && 1 < c.length && e ? e.chartY - l : a ? d.plotHeight - h : w]);
        return c.map(Math.round);
      };

      e.prototype.getDateFormat = function (c, e, d, f) {
        var a = this.chart.time,
            l = a.dateFormat("%m-%d %H:%M:%S.%L", e),
            k = {
          millisecond: 15,
          second: 12,
          minute: 9,
          hour: 6,
          day: 3
        },
            n = "millisecond";

        for (w in N) {
          if (c === N.week && +a.dateFormat("%w", e) === d && "00:00:00.000" === l.substr(6)) {
            var w = "week";
            break;
          }

          if (N[w] > c) {
            w = n;
            break;
          }

          if (k[w] && l.substr(k[w]) !== "01-01 00:00:00.000".substr(k[w])) break;
          "week" !== w && (n = w);
        }

        if (w) var h = a.resolveDTLFormat(f[w]).main;
        return h;
      };

      e.prototype.getLabel = function () {
        var c,
            e = this,
            n = this.chart.renderer,
            f = this.chart.styledMode,
            a = this.options,
            l = "tooltip" + (I(a.className) ? " " + a.className : ""),
            v = (null === (c = a.style) || void 0 === c ? void 0 : c.pointerEvents) || (!this.followPointer && a.stickOnContact ? "auto" : "none"),
            h;

        c = function () {
          e.inContact = !0;
        };

        var w = function () {
          var a = e.chart.hoverSeries;
          e.inContact = !1;
          if (a && a.onMouseOut) a.onMouseOut();
        };

        if (!this.label) {
          this.outside && (this.container = h = d.doc.createElement("div"), h.className = "highcharts-tooltip-container", u(h, {
            position: "absolute",
            top: "1px",
            pointerEvents: v,
            zIndex: 3
          }), d.doc.body.appendChild(h), this.renderer = n = new d.Renderer(h, 0, 0, {}, void 0, void 0, n.styledMode));
          this.split ? this.label = n.g(l) : (this.label = n.label("", 0, 0, a.shape || "callout", null, null, a.useHTML, null, l).attr({
            padding: a.padding,
            r: a.borderRadius
          }), f || this.label.attr({
            fill: a.backgroundColor,
            "stroke-width": a.borderWidth
          }).css(a.style).css({
            pointerEvents: v
          }).shadow(a.shadow));
          f && (this.applyFilter(), this.label.addClass("highcharts-tooltip-" + this.chart.index));

          if (e.outside && !e.split) {
            var B = {
              x: this.label.xSetter,
              y: this.label.ySetter
            };

            this.label.xSetter = function (a, c) {
              B[c].call(this.label, e.distance);
              h.style.left = a + "px";
            };

            this.label.ySetter = function (a, c) {
              B[c].call(this.label, e.distance);
              h.style.top = a + "px";
            };
          }

          this.label.on("mouseenter", c).on("mouseleave", w).attr({
            zIndex: 8
          }).add();
        }

        return this.label;
      };

      e.prototype.getPosition = function (c, e, d) {
        var f = this.chart,
            a = this.distance,
            l = {},
            k = f.inverted && d.h || 0,
            n,
            w = this.outside,
            h = w ? q.documentElement.clientWidth - 2 * a : f.chartWidth,
            g = w ? Math.max(q.body.scrollHeight, q.documentElement.scrollHeight, q.body.offsetHeight, q.documentElement.offsetHeight, q.documentElement.clientHeight) : f.chartHeight,
            Q = f.pointer.getChartPosition(),
            H = f.containerScaling,
            K = function (b) {
          return H ? b * H.scaleX : b;
        },
            p = function (b) {
          return H ? b * H.scaleY : b;
        },
            b = function (b) {
          var l = "x" === b;
          return [b, l ? h : g, l ? c : e].concat(w ? [l ? K(c) : p(e), l ? Q.left - a + K(d.plotX + f.plotLeft) : Q.top - a + p(d.plotY + f.plotTop), 0, l ? h : g] : [l ? c : e, l ? d.plotX + f.plotLeft : d.plotY + f.plotTop, l ? f.plotLeft : f.plotTop, l ? f.plotLeft + f.plotWidth : f.plotTop + f.plotHeight]);
        },
            C = b("y"),
            x = b("x"),
            R = !this.followPointer && t(d.ttBelow, !f.inverted === !!d.negative),
            O = function (b, c, f, e, d, m, v) {
          var n = "y" === b ? p(a) : K(a),
              w = (f - e) / 2,
              x = e < d - a,
              h = d + a + e < c,
              F = d - n - f + w;
          d = d + n - w;
          if (R && h) l[b] = d;else if (!R && x) l[b] = F;else if (x) l[b] = Math.min(v - e, 0 > F - k ? F : F - k);else if (h) l[b] = Math.max(m, d + k + f > c ? d : d + k);else return !1;
        },
            y = function (b, c, f, e, d) {
          var k;
          d < a || d > c - a ? k = !1 : l[b] = d < f / 2 ? 1 : d > c - e / 2 ? c - e - 2 : d - f / 2;
          return k;
        },
            u = function (b) {
          var a = C;
          C = x;
          x = a;
          n = b;
        },
            m = function () {
          !1 !== O.apply(0, C) ? !1 !== y.apply(0, x) || n || (u(!0), m()) : n ? l.x = l.y = 0 : (u(!0), m());
        };

        (f.inverted || 1 < this.len) && u();
        m();
        return l;
      };

      e.prototype.getXDateFormat = function (c, e, d) {
        e = e.dateTimeLabelFormats;
        var f = d && d.closestPointRange;
        return (f ? this.getDateFormat(f, c.x, d.options.startOfWeek, e) : e.day) || e.year;
      };

      e.prototype.hide = function (c) {
        var e = this;
        g.clearTimeout(this.hideTimer);
        c = t(c, this.options.hideDelay, 500);
        this.isHidden || (this.hideTimer = h(function () {
          e.getLabel()[c ? "fadeOut" : "hide"]();
          e.isHidden = !0;
        }, c));
      };

      e.prototype.init = function (c, e) {
        this.chart = c;
        this.options = e;
        this.crosshairs = [];
        this.now = {
          x: 0,
          y: 0
        };
        this.isHidden = !0;
        this.split = e.split && !c.inverted && !c.polar;
        this.shared = e.shared || this.split;
        this.outside = t(e.outside, !(!c.scrollablePixelsX && !c.scrollablePixelsY));
      };

      e.prototype.isStickyOnContact = function () {
        return !(this.followPointer || !this.options.stickOnContact || !this.inContact);
      };

      e.prototype.move = function (c, e, d, f) {
        var a = this,
            l = a.now,
            k = !1 !== a.options.animation && !a.isHidden && (1 < Math.abs(c - l.x) || 1 < Math.abs(e - l.y)),
            n = a.followPointer || 1 < a.len;
        E(l, {
          x: k ? (2 * l.x + c) / 3 : c,
          y: k ? (l.y + e) / 2 : e,
          anchorX: n ? void 0 : k ? (2 * l.anchorX + d) / 3 : d,
          anchorY: n ? void 0 : k ? (l.anchorY + f) / 2 : f
        });
        a.getLabel().attr(l);
        a.drawTracker();
        k && (g.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
          a && a.move(c, e, d, f);
        }, 32));
      };

      e.prototype.refresh = function (c, e) {
        var k = this.chart,
            f = this.options,
            a = c,
            l = {},
            v = [],
            h = f.formatter || this.defaultFormatter;
        l = this.shared;
        var w = k.styledMode;

        if (f.enabled) {
          g.clearTimeout(this.hideTimer);
          this.followPointer = D(a)[0].series.tooltipOptions.followPointer;
          var B = this.getAnchor(a, e);
          e = B[0];
          var q = B[1];
          !l || a.series && a.series.noSharedTooltip ? l = a.getLabelConfig() : (k.pointer.applyInactiveState(a), a.forEach(function (a) {
            a.setState("hover");
            v.push(a.getLabelConfig());
          }), l = {
            x: a[0].category,
            y: a[0].y
          }, l.points = v, a = a[0]);
          this.len = v.length;
          k = h.call(l, this);
          h = a.series;
          this.distance = t(h.tooltipOptions.distance, 16);
          !1 === k ? this.hide() : (this.split ? this.renderSplit(k, D(c)) : (c = this.getLabel(), f.style.width && !w || c.css({
            width: this.chart.spacingBox.width
          }), c.attr({
            text: k && k.join ? k.join("") : k
          }), c.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + t(a.colorIndex, h.colorIndex)), w || c.attr({
            stroke: f.borderColor || a.color || h.color || "#666666"
          }), this.updatePosition({
            plotX: e,
            plotY: q,
            negative: a.negative,
            ttBelow: a.ttBelow,
            h: B[2] || 0
          })), this.isHidden && this.label && this.label.attr({
            opacity: 1
          }).show(), this.isHidden = !1);
          d.fireEvent(this, "refresh");
        }
      };

      e.prototype.renderSplit = function (c, e) {
        function k(b, a, c, f, e) {
          void 0 === e && (e = !0);
          c ? (a = u ? 0 : A, b = r(b - f / 2, O.left, O.right - f)) : (a -= m, b = e ? b - f - C : b + C, b = r(b, e ? b : O.left, O.right));
          return {
            x: b,
            y: a
          };
        }

        var f = this,
            a = f.chart,
            l = f.chart,
            v = l.plotHeight,
            h = l.plotLeft,
            w = l.plotTop,
            B = l.pointer,
            q = l.renderer,
            g = l.scrollablePixelsY,
            H = void 0 === g ? 0 : g;
        g = l.scrollingContainer;
        g = void 0 === g ? {
          scrollLeft: 0,
          scrollTop: 0
        } : g;
        var K = g.scrollLeft,
            p = g.scrollTop,
            b = l.styledMode,
            C = f.distance,
            x = f.options,
            R = f.options.positioner,
            O = {
          left: K,
          right: K + l.chartWidth,
          top: p,
          bottom: p + l.chartHeight
        },
            y = f.getLabel(),
            u = !(!a.xAxis[0] || !a.xAxis[0].opposite),
            m = w + p,
            D = 0,
            A = v - H;
        J(c) && (c = [!1, c]);
        c = c.slice(0, e.length + 1).reduce(function (a, c, l) {
          if (!1 !== c && "" !== c) {
            l = e[l - 1] || {
              isHeader: !0,
              plotX: e[0].plotX,
              plotY: v,
              series: {}
            };
            var d = l.isHeader,
                n = d ? f : l.series,
                F = n.tt,
                z = l.isHeader;
            var B = l.series;
            var g = "highcharts-color-" + t(l.colorIndex, B.colorIndex, "none");
            F || (F = {
              padding: x.padding,
              r: x.borderRadius
            }, b || (F.fill = x.backgroundColor, F["stroke-width"] = x.borderWidth), F = q.label("", 0, 0, x[z ? "headerShape" : "shape"] || "callout", void 0, void 0, x.useHTML).addClass((z ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + g).attr(F).add(y));
            F.isActive = !0;
            F.attr({
              text: c
            });
            b || F.css(x.style).shadow(x.shadow).attr({
              stroke: x.borderColor || l.color || B.color || "#333333"
            });
            c = n.tt = F;
            z = c.getBBox();
            n = z.width + c.strokeWidth();
            d && (D = z.height, A += D, u && (m -= D));
            B = l.plotX;
            B = void 0 === B ? 0 : B;
            g = l.plotY;
            g = void 0 === g ? 0 : g;
            var L = l.series;

            if (l.isHeader) {
              B = h + B;
              var K = w + v / 2;
            } else F = L.xAxis, L = L.yAxis, B = F.pos + r(B, -C, F.len + C), L.pos + g >= p + w && L.pos + g <= p + w + v - H && (K = L.pos + g);

            B = r(B, O.left - C, O.right + C);
            "number" === typeof K ? (z = z.height + 1, g = R ? R.call(f, n, z, l) : k(B, K, d, n), a.push({
              align: R ? 0 : void 0,
              anchorX: B,
              anchorY: K,
              boxWidth: n,
              point: l,
              rank: t(g.rank, d ? 1 : 0),
              size: z,
              target: g.y,
              tt: c,
              x: g.x
            })) : c.isActive = !1;
          }

          return a;
        }, []);
        !R && c.some(function (b) {
          return b.x < O.left;
        }) && (c = c.map(function (b) {
          var a = k(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);
          return E(b, {
            target: a.y,
            x: a.x
          });
        }));
        f.cleanSplit();
        d.distribute(c, A);
        c.forEach(function (b) {
          var a = b.pos;
          b.tt.attr({
            visibility: "undefined" === typeof a ? "hidden" : "inherit",
            x: b.x,
            y: a + m,
            anchorX: b.anchorX,
            anchorY: b.anchorY
          });
        });
        c = f.container;
        a = f.renderer;
        f.outside && c && a && (l = y.getBBox(), a.setSize(l.width + l.x, l.height + l.y, !1), B = B.getChartPosition(), c.style.left = B.left + "px", c.style.top = B.top + "px");
      };

      e.prototype.drawTracker = function () {
        if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {
          var c = this.chart,
              e = this.label,
              d = c.hoverPoint;

          if (e && d) {
            var f = {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            };
            d = this.getAnchor(d);
            var a = e.getBBox();
            d[0] += c.plotLeft - e.translateX;
            d[1] += c.plotTop - e.translateY;
            f.x = Math.min(0, d[0]);
            f.y = Math.min(0, d[1]);
            f.width = 0 > d[0] ? Math.max(Math.abs(d[0]), a.width - d[0]) : Math.max(Math.abs(d[0]), a.width);
            f.height = 0 > d[1] ? Math.max(Math.abs(d[1]), a.height - Math.abs(d[1])) : Math.max(Math.abs(d[1]), a.height);
            this.tracker ? this.tracker.attr(f) : (this.tracker = e.renderer.rect(f).addClass("highcharts-tracker").add(e), c.styledMode || this.tracker.attr({
              fill: "rgba(0,0,0,0)"
            }));
          }
        }
      };

      e.prototype.styledModeFormat = function (c) {
        return c.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
      };

      e.prototype.tooltipFooterHeaderFormatter = function (c, e) {
        var k = e ? "footer" : "header",
            f = c.series,
            a = f.tooltipOptions,
            l = a.xDateFormat,
            v = f.xAxis,
            h = v && "datetime" === v.options.type && G(c.key),
            w = a[k + "Format"];
        e = {
          isFooter: e,
          labelConfig: c
        };
        d.fireEvent(this, "headerFormatter", e, function (e) {
          h && !l && (l = this.getXDateFormat(c, a, v));
          h && l && (c.point && c.point.tooltipDateKeys || ["key"]).forEach(function (a) {
            w = w.replace("{point." + a + "}", "{point." + a + ":" + l + "}");
          });
          f.chart.styledMode && (w = this.styledModeFormat(w));
          e.text = A(w, {
            point: c,
            series: f
          }, this.chart);
        });
        return e.text;
      };

      e.prototype.update = function (c) {
        this.destroy();
        y(!0, this.chart.options.tooltip.userOptions, c);
        this.init(this.chart, y(!0, this.options, c));
      };

      e.prototype.updatePosition = function (c) {
        var e = this.chart,
            d = e.pointer,
            f = this.getLabel(),
            a = c.plotX + e.plotLeft,
            l = c.plotY + e.plotTop;
        d = d.getChartPosition();
        c = (this.options.positioner || this.getPosition).call(this, f.width, f.height, c);

        if (this.outside) {
          var v = (this.options.borderWidth || 0) + 2 * this.distance;
          this.renderer.setSize(f.width + v, f.height + v, !1);
          if (e = e.containerScaling) u(this.container, {
            transform: "scale(" + e.scaleX + ", " + e.scaleY + ")"
          }), a *= e.scaleX, l *= e.scaleY;
          a += d.left - c.x;
          l += d.top - c.y;
        }

        this.move(Math.round(c.x), Math.round(c.y || 0), a, l);
      };

      return e;
    }();

    d.Tooltip = P;
    return d.Tooltip;
  });
  S(r, "parts/Pointer.js", [r["parts/Globals.js"], r["parts/Utilities.js"], r["parts/Tooltip.js"], r["parts/Color.js"]], function (d, g, r, u) {
    var I = g.addEvent,
        M = g.attr,
        E = g.css,
        A = g.defined,
        G = g.extend,
        J = g.find,
        y = g.fireEvent,
        t = g.isNumber,
        D = g.isObject,
        h = g.objectEach,
        N = g.offset,
        q = g.pick,
        P = g.splat,
        e = u.parse,
        c = d.charts,
        k = d.noop;

    g = function () {
      function n(c, a) {
        this.lastValidTouch = {};
        this.pinchDown = [];
        this.runChartClick = !1;
        this.chart = c;
        this.hasDragged = !1;
        this.options = a;

        this.unbindContainerMouseLeave = function () {};

        this.init(c, a);
      }

      n.prototype.applyInactiveState = function (c) {
        var a = [],
            f;
        (c || []).forEach(function (c) {
          f = c.series;
          a.push(f);
          f.linkedParent && a.push(f.linkedParent);
          f.linkedSeries && (a = a.concat(f.linkedSeries));
          f.navigatorSeries && a.push(f.navigatorSeries);
        });
        this.chart.series.forEach(function (c) {
          -1 === a.indexOf(c) ? c.setState("inactive", !0) : c.options.inactiveOtherPoints && c.setAllPointsToState("inactive");
        });
      };

      n.prototype.destroy = function () {
        var c = this;
        "undefined" !== typeof c.unDocMouseMove && c.unDocMouseMove();
        this.unbindContainerMouseLeave();
        d.chartCount || (d.unbindDocumentMouseUp && (d.unbindDocumentMouseUp = d.unbindDocumentMouseUp()), d.unbindDocumentTouchEnd && (d.unbindDocumentTouchEnd = d.unbindDocumentTouchEnd()));
        clearInterval(c.tooltipTimeout);
        h(c, function (a, f) {
          c[f] = null;
        });
      };

      n.prototype.drag = function (c) {
        var a = this.chart,
            f = a.options.chart,
            d = c.chartX,
            k = c.chartY,
            w = this.zoomHor,
            n = this.zoomVert,
            h = a.plotLeft,
            q = a.plotTop,
            g = a.plotWidth,
            t = a.plotHeight,
            p = this.selectionMarker,
            b = this.mouseDownX || 0,
            C = this.mouseDownY || 0,
            x = D(f.panning) ? f.panning && f.panning.enabled : f.panning,
            y = f.panKey && c[f.panKey + "Key"];
        if (!p || !p.touch) if (d < h ? d = h : d > h + g && (d = h + g), k < q ? k = q : k > q + t && (k = q + t), this.hasDragged = Math.sqrt(Math.pow(b - d, 2) + Math.pow(C - k, 2)), 10 < this.hasDragged) {
          var O = a.isInsidePlot(b - h, C - q);
          a.hasCartesianSeries && (this.zoomX || this.zoomY) && O && !y && !p && (this.selectionMarker = p = a.renderer.rect(h, q, w ? 1 : g, n ? 1 : t, 0).attr({
            "class": "highcharts-selection-marker",
            zIndex: 7
          }).add(), a.styledMode || p.attr({
            fill: f.selectionMarkerFill || e("#335cad").setOpacity(.25).get()
          }));
          p && w && (d -= b, p.attr({
            width: Math.abs(d),
            x: (0 < d ? 0 : d) + b
          }));
          p && n && (d = k - C, p.attr({
            height: Math.abs(d),
            y: (0 < d ? 0 : d) + C
          }));
          O && !p && x && a.pan(c, f.panning);
        }
      };

      n.prototype.dragStart = function (c) {
        var a = this.chart;
        a.mouseIsDown = c.type;
        a.cancelClick = !1;
        a.mouseDownX = this.mouseDownX = c.chartX;
        a.mouseDownY = this.mouseDownY = c.chartY;
      };

      n.prototype.drop = function (c) {
        var a = this,
            f = this.chart,
            e = this.hasPinched;

        if (this.selectionMarker) {
          var d = {
            originalEvent: c,
            xAxis: [],
            yAxis: []
          },
              k = this.selectionMarker,
              n = k.attr ? k.attr("x") : k.x,
              h = k.attr ? k.attr("y") : k.y,
              q = k.attr ? k.attr("width") : k.width,
              g = k.attr ? k.attr("height") : k.height,
              K;
          if (this.hasDragged || e) f.axes.forEach(function (f) {
            if (f.zoomEnabled && A(f.min) && (e || a[{
              xAxis: "zoomX",
              yAxis: "zoomY"
            }[f.coll]])) {
              var b = f.horiz,
                  l = "touchend" === c.type ? f.minPixelPadding : 0,
                  k = f.toValue((b ? n : h) + l);
              b = f.toValue((b ? n + q : h + g) - l);
              d[f.coll].push({
                axis: f,
                min: Math.min(k, b),
                max: Math.max(k, b)
              });
              K = !0;
            }
          }), K && y(f, "selection", d, function (a) {
            f.zoom(G(a, e ? {
              animation: !1
            } : null));
          });
          t(f.index) && (this.selectionMarker = this.selectionMarker.destroy());
          e && this.scaleGroups();
        }

        f && t(f.index) && (E(f.container, {
          cursor: f._cursor
        }), f.cancelClick = 10 < this.hasDragged, f.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
      };

      n.prototype.findNearestKDPoint = function (c, a, e) {
        var f = this.chart,
            d = f.hoverPoint;
        f = f.tooltip;
        if (d && f && f.isStickyOnContact()) return d;
        var l;
        c.forEach(function (c) {
          var f = !(c.noSharedTooltip && a) && 0 > c.options.findNearestPointBy.indexOf("y");
          c = c.searchPoint(e, f);

          if ((f = D(c, !0)) && !(f = !D(l, !0))) {
            f = l.distX - c.distX;
            var d = l.dist - c.dist,
                k = (c.series.group && c.series.group.zIndex) - (l.series.group && l.series.group.zIndex);
            f = 0 < (0 !== f && a ? f : 0 !== d ? d : 0 !== k ? k : l.series.index > c.series.index ? -1 : 1);
          }

          f && (l = c);
        });
        return l;
      };

      n.prototype.getChartCoordinatesFromPoint = function (c, a) {
        var f = c.series,
            e = f.xAxis;
        f = f.yAxis;
        var d = q(c.clientX, c.plotX),
            k = c.shapeArgs;
        if (e && f) return a ? {
          chartX: e.len + e.pos - d,
          chartY: f.len + f.pos - c.plotY
        } : {
          chartX: d + e.pos,
          chartY: c.plotY + f.pos
        };
        if (k && k.x && k.y) return {
          chartX: k.x,
          chartY: k.y
        };
      };

      n.prototype.getChartPosition = function () {
        return this.chartPosition || (this.chartPosition = N(this.chart.container));
      };

      n.prototype.getCoordinates = function (c) {
        var a = {
          xAxis: [],
          yAxis: []
        };
        this.chart.axes.forEach(function (f) {
          a[f.isXAxis ? "xAxis" : "yAxis"].push({
            axis: f,
            value: f.toValue(c[f.horiz ? "chartX" : "chartY"])
          });
        });
        return a;
      };

      n.prototype.getHoverData = function (c, a, e, d, k, n) {
        var f,
            l = [];
        d = !(!d || !c);
        var v = a && !a.stickyTracking,
            h = {
          chartX: n ? n.chartX : void 0,
          chartY: n ? n.chartY : void 0,
          shared: k
        };
        y(this, "beforeGetHoverData", h);
        v = v ? [a] : e.filter(function (a) {
          return h.filter ? h.filter(a) : a.visible && !(!k && a.directTouch) && q(a.options.enableMouseTracking, !0) && a.stickyTracking;
        });
        a = (f = d || !n ? c : this.findNearestKDPoint(v, k, n)) && f.series;
        f && (k && !a.noSharedTooltip ? (v = e.filter(function (a) {
          return h.filter ? h.filter(a) : a.visible && !(!k && a.directTouch) && q(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;
        }), v.forEach(function (a) {
          var c = J(a.points, function (b) {
            return b.x === f.x && !b.isNull;
          });
          D(c) && (a.chart.isBoosting && (c = a.getPoint(c)), l.push(c));
        })) : l.push(f));
        h = {
          hoverPoint: f
        };
        y(this, "afterGetHoverData", h);
        return {
          hoverPoint: h.hoverPoint,
          hoverSeries: a,
          hoverPoints: l
        };
      };

      n.prototype.getPointFromEvent = function (c) {
        c = c.target;

        for (var a; c && !a;) a = c.point, c = c.parentNode;

        return a;
      };

      n.prototype.onTrackerMouseOut = function (c) {
        var a = this.chart.hoverSeries;
        c = c.relatedTarget || c.toElement;
        this.isDirectTouch = !1;
        if (!(!a || !c || a.stickyTracking || this.inClass(c, "highcharts-tooltip") || this.inClass(c, "highcharts-series-" + a.index) && this.inClass(c, "highcharts-tracker"))) a.onMouseOut();
      };

      n.prototype.inClass = function (c, a) {
        for (var f; c;) {
          if (f = M(c, "class")) {
            if (-1 !== f.indexOf(a)) return !0;
            if (-1 !== f.indexOf("highcharts-container")) return !1;
          }

          c = c.parentNode;
        }
      };

      n.prototype.init = function (c, a) {
        this.options = a;
        this.chart = c;
        this.runChartClick = a.chart.events && !!a.chart.events.click;
        this.pinchDown = [];
        this.lastValidTouch = {};
        r && (c.tooltip = new r(c, a.tooltip), this.followTouchMove = q(a.tooltip.followTouchMove, !0));
        this.setDOMEvents();
      };

      n.prototype.normalize = function (c, a) {
        var f = c.touches,
            e = f ? f.length ? f.item(0) : f.changedTouches[0] : c;
        a || (a = this.getChartPosition());
        f = e.pageX - a.left;
        a = e.pageY - a.top;
        if (e = this.chart.containerScaling) f /= e.scaleX, a /= e.scaleY;
        return G(c, {
          chartX: Math.round(f),
          chartY: Math.round(a)
        });
      };

      n.prototype.onContainerClick = function (c) {
        var a = this.chart,
            f = a.hoverPoint,
            e = a.plotLeft,
            d = a.plotTop;
        c = this.normalize(c);
        a.cancelClick || (f && this.inClass(c.target, "highcharts-tracker") ? (y(f.series, "click", G(c, {
          point: f
        })), a.hoverPoint && f.firePointEvent("click", c)) : (G(c, this.getCoordinates(c)), a.isInsidePlot(c.chartX - e, c.chartY - d) && y(a, "click", c)));
      };

      n.prototype.onContainerMouseDown = function (c) {
        c = this.normalize(c);
        2 !== c.button && (this.zoomOption(c), c.preventDefault && c.preventDefault(), this.dragStart(c));
      };

      n.prototype.onContainerMouseLeave = function (f) {
        var a = c[d.hoverChartIndex];
        a && (f.relatedTarget || f.toElement) && (a.pointer.reset(), a.pointer.chartPosition = void 0);
      };

      n.prototype.onContainerMouseMove = function (f) {
        var a = this.chart;
        A(d.hoverChartIndex) && c[d.hoverChartIndex] && c[d.hoverChartIndex].mouseIsDown || (d.hoverChartIndex = a.index);
        f = this.normalize(f);
        f.preventDefault || (f.returnValue = !1);
        "mousedown" === a.mouseIsDown && this.drag(f);
        a.openMenu || !this.inClass(f.target, "highcharts-tracker") && !a.isInsidePlot(f.chartX - a.plotLeft, f.chartY - a.plotTop) || this.runPointActions(f);
      };

      n.prototype.onDocumentTouchEnd = function (f) {
        c[d.hoverChartIndex] && c[d.hoverChartIndex].pointer.drop(f);
      };

      n.prototype.onContainerTouchMove = function (c) {
        this.touch(c);
      };

      n.prototype.onContainerTouchStart = function (c) {
        this.zoomOption(c);
        this.touch(c, !0);
      };

      n.prototype.onDocumentMouseMove = function (c) {
        var a = this.chart,
            f = this.chartPosition,
            e = a.tooltip;
        c = this.normalize(c, f);
        !f || e && e.isStickyOnContact() || a.isInsidePlot(c.chartX - a.plotLeft, c.chartY - a.plotTop) || this.inClass(c.target, "highcharts-tracker") || this.reset();
      };

      n.prototype.onDocumentMouseUp = function (f) {
        c[d.hoverChartIndex] && c[d.hoverChartIndex].pointer.drop(f);
      };

      n.prototype.pinch = function (c) {
        var a = this,
            f = a.chart,
            e = a.pinchDown,
            d = c.touches || [],
            n = d.length,
            h = a.lastValidTouch,
            g = a.hasZoom,
            t = a.selectionMarker,
            H = {},
            K = 1 === n && (a.inClass(c.target, "highcharts-tracker") && f.runTrackerClick || a.runChartClick),
            p = {};
        1 < n && (a.initiated = !0);
        g && a.initiated && !K && c.preventDefault();
        [].map.call(d, function (b) {
          return a.normalize(b);
        });
        "touchstart" === c.type ? ([].forEach.call(d, function (b, a) {
          e[a] = {
            chartX: b.chartX,
            chartY: b.chartY
          };
        }), h.x = [e[0].chartX, e[1] && e[1].chartX], h.y = [e[0].chartY, e[1] && e[1].chartY], f.axes.forEach(function (b) {
          if (b.zoomEnabled) {
            var a = f.bounds[b.horiz ? "h" : "v"],
                c = b.minPixelPadding,
                e = b.toPixels(Math.min(q(b.options.min, b.dataMin), b.dataMin)),
                d = b.toPixels(Math.max(q(b.options.max, b.dataMax), b.dataMax)),
                l = Math.max(e, d);
            a.min = Math.min(b.pos, Math.min(e, d) - c);
            a.max = Math.max(b.pos + b.len, l + c);
          }
        }), a.res = !0) : a.followTouchMove && 1 === n ? this.runPointActions(a.normalize(c)) : e.length && (t || (a.selectionMarker = t = G({
          destroy: k,
          touch: !0
        }, f.plotBox)), a.pinchTranslate(e, d, H, t, p, h), a.hasPinched = g, a.scaleGroups(H, p), a.res && (a.res = !1, this.reset(!1, 0)));
      };

      n.prototype.pinchTranslate = function (c, a, e, d, k, n) {
        this.zoomHor && this.pinchTranslateDirection(!0, c, a, e, d, k, n);
        this.zoomVert && this.pinchTranslateDirection(!1, c, a, e, d, k, n);
      };

      n.prototype.pinchTranslateDirection = function (c, a, e, d, k, n, h, q) {
        var f = this.chart,
            l = c ? "x" : "y",
            v = c ? "X" : "Y",
            p = "chart" + v,
            b = c ? "width" : "height",
            w = f["plot" + (c ? "Left" : "Top")],
            x,
            B,
            g = q || 1,
            z = f.inverted,
            t = f.bounds[c ? "h" : "v"],
            m = 1 === a.length,
            L = a[0][p],
            y = e[0][p],
            u = !m && a[1][p],
            F = !m && e[1][p];

        e = function () {
          "number" === typeof F && 20 < Math.abs(L - u) && (g = q || Math.abs(y - F) / Math.abs(L - u));
          B = (w - y) / g + L;
          x = f["plot" + (c ? "Width" : "Height")] / g;
        };

        e();
        a = B;

        if (a < t.min) {
          a = t.min;
          var V = !0;
        } else a + x > t.max && (a = t.max - x, V = !0);

        V ? (y -= .8 * (y - h[l][0]), "number" === typeof F && (F -= .8 * (F - h[l][1])), e()) : h[l] = [y, F];
        z || (n[l] = B - w, n[b] = x);
        n = z ? 1 / g : g;
        k[b] = x;
        k[l] = a;
        d[z ? c ? "scaleY" : "scaleX" : "scale" + v] = g;
        d["translate" + v] = n * w + (y - n * L);
      };

      n.prototype.reset = function (c, a) {
        var f = this.chart,
            e = f.hoverSeries,
            d = f.hoverPoint,
            k = f.hoverPoints,
            n = f.tooltip,
            h = n && n.shared ? k : d;
        c && h && P(h).forEach(function (a) {
          a.series.isCartesian && "undefined" === typeof a.plotX && (c = !1);
        });
        if (c) n && h && P(h).length && (n.refresh(h), n.shared && k ? k.forEach(function (a) {
          a.setState(a.state, !0);
          a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));
        }) : d && (d.setState(d.state, !0), f.axes.forEach(function (a) {
          a.crosshair && d.series[a.coll] === a && a.drawCrosshair(null, d);
        })));else {
          if (d) d.onMouseOut();
          k && k.forEach(function (a) {
            a.setState();
          });
          if (e) e.onMouseOut();
          n && n.hide(a);
          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
          f.axes.forEach(function (a) {
            a.hideCrosshair();
          });
          this.hoverX = f.hoverPoints = f.hoverPoint = null;
        }
      };

      n.prototype.runPointActions = function (f, a) {
        var e = this.chart,
            k = e.tooltip && e.tooltip.options.enabled ? e.tooltip : void 0,
            n = k ? k.shared : !1,
            h = a || e.hoverPoint,
            g = h && h.series || e.hoverSeries;
        g = this.getHoverData(h, g, e.series, (!f || "touchmove" !== f.type) && (!!a || g && g.directTouch && this.isDirectTouch), n, f);
        h = g.hoverPoint;
        var t = g.hoverPoints;
        a = (g = g.hoverSeries) && g.tooltipOptions.followPointer;
        n = n && g && !g.noSharedTooltip;

        if (h && (h !== e.hoverPoint || k && k.isHidden)) {
          (e.hoverPoints || []).forEach(function (a) {
            -1 === t.indexOf(a) && a.setState();
          });
          if (e.hoverSeries !== g) g.onMouseOver();
          this.applyInactiveState(t);
          (t || []).forEach(function (a) {
            a.setState("hover");
          });
          e.hoverPoint && e.hoverPoint.firePointEvent("mouseOut");
          if (!h.series) return;
          h.firePointEvent("mouseOver");
          e.hoverPoints = t;
          e.hoverPoint = h;
          k && k.refresh(n ? t : h, f);
        } else a && k && !k.isHidden && (h = k.getAnchor([{}], f), k.updatePosition({
          plotX: h[0],
          plotY: h[1]
        }));

        this.unDocMouseMove || (this.unDocMouseMove = I(e.container.ownerDocument, "mousemove", function (a) {
          var f = c[d.hoverChartIndex];
          if (f) f.pointer.onDocumentMouseMove(a);
        }));
        e.axes.forEach(function (a) {
          var c = q(a.crosshair.snap, !0),
              e = c ? J(t, function (c) {
            return c.series[a.coll] === a;
          }) : void 0;
          e || !c ? a.drawCrosshair(f, e) : a.hideCrosshair();
        });
      };

      n.prototype.scaleGroups = function (c, a) {
        var f = this.chart,
            e;
        f.series.forEach(function (d) {
          e = c || d.getPlotBox();
          d.xAxis && d.xAxis.zoomEnabled && d.group && (d.group.attr(e), d.markerGroup && (d.markerGroup.attr(e), d.markerGroup.clip(a ? f.clipRect : null)), d.dataLabelsGroup && d.dataLabelsGroup.attr(e));
        });
        f.clipRect.attr(a || f.clipBox);
      };

      n.prototype.setDOMEvents = function () {
        var c = this,
            a = c.chart.container,
            e = a.ownerDocument;

        a.onmousedown = function (a) {
          c.onContainerMouseDown(a);
        };

        a.onmousemove = function (a) {
          c.onContainerMouseMove(a);
        };

        a.onclick = function (a) {
          c.onContainerClick(a);
        };

        this.unbindContainerMouseLeave = I(a, "mouseleave", c.onContainerMouseLeave);
        d.unbindDocumentMouseUp || (d.unbindDocumentMouseUp = I(e, "mouseup", c.onDocumentMouseUp));
        d.hasTouch && (I(a, "touchstart", function (a) {
          c.onContainerTouchStart(a);
        }), I(a, "touchmove", function (a) {
          c.onContainerTouchMove(a);
        }), d.unbindDocumentTouchEnd || (d.unbindDocumentTouchEnd = I(e, "touchend", c.onDocumentTouchEnd)));
      };

      n.prototype.touch = function (c, a) {
        var f = this.chart,
            e;
        if (f.index !== d.hoverChartIndex) this.onContainerMouseLeave({
          relatedTarget: !0
        });
        d.hoverChartIndex = f.index;
        if (1 === c.touches.length) {
          if (c = this.normalize(c), (e = f.isInsidePlot(c.chartX - f.plotLeft, c.chartY - f.plotTop)) && !f.openMenu) {
            a && this.runPointActions(c);

            if ("touchmove" === c.type) {
              a = this.pinchDown;
              var k = a[0] ? 4 <= Math.sqrt(Math.pow(a[0].chartX - c.chartX, 2) + Math.pow(a[0].chartY - c.chartY, 2)) : !1;
            }

            q(k, !0) && this.pinch(c);
          } else a && this.reset();
        } else 2 === c.touches.length && this.pinch(c);
      };

      n.prototype.zoomOption = function (c) {
        var a = this.chart,
            f = a.options.chart,
            e = f.zoomType || "";
        a = a.inverted;
        /touch/.test(c.type) && (e = q(f.pinchType, e));
        this.zoomX = c = /x/.test(e);
        this.zoomY = e = /y/.test(e);
        this.zoomHor = c && !a || e && a;
        this.zoomVert = e && !a || c && a;
        this.hasZoom = c || e;
      };

      return n;
    }();

    d.Pointer = g;
    return d.Pointer;
  });
  S(r, "parts/MSPointer.js", [r["parts/Globals.js"], r["parts/Pointer.js"], r["parts/Utilities.js"]], function (d, g, r) {
    function u() {
      var d = [];

      d.item = function (d) {
        return this[d];
      };

      G(h, function (h) {
        d.push({
          pageX: h.pageX,
          pageY: h.pageY,
          target: h.target
        });
      });
      return d;
    }

    function I(h, g, e, c) {
      "touch" !== h.pointerType && h.pointerType !== h.MSPOINTER_TYPE_TOUCH || !y[d.hoverChartIndex] || (c(h), c = y[d.hoverChartIndex].pointer, c[g]({
        type: e,
        target: h.currentTarget,
        preventDefault: D,
        touches: u()
      }));
    }

    var M = this && this.__extends || function () {
      var d = function (h, e) {
        d = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (c, e) {
          c.__proto__ = e;
        } || function (c, e) {
          for (var d in e) e.hasOwnProperty(d) && (c[d] = e[d]);
        };

        return d(h, e);
      };

      return function (h, e) {
        function c() {
          this.constructor = h;
        }

        d(h, e);
        h.prototype = null === e ? Object.create(e) : (c.prototype = e.prototype, new c());
      };
    }(),
        E = r.addEvent,
        A = r.css,
        G = r.objectEach,
        J = r.removeEvent,
        y = d.charts,
        t = d.doc,
        D = d.noop,
        h = {},
        N = !!d.win.PointerEvent;

    return function (d) {
      function g() {
        return null !== d && d.apply(this, arguments) || this;
      }

      M(g, d);

      g.prototype.batchMSEvents = function (e) {
        e(this.chart.container, N ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
        e(this.chart.container, N ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
        e(t, N ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
      };

      g.prototype.destroy = function () {
        this.batchMSEvents(J);
        d.prototype.destroy.call(this);
      };

      g.prototype.init = function (e, c) {
        d.prototype.init.call(this, e, c);
        this.hasZoom && A(e.container, {
          "-ms-touch-action": "none",
          "touch-action": "none"
        });
      };

      g.prototype.onContainerPointerDown = function (e) {
        I(e, "onContainerTouchStart", "touchstart", function (c) {
          h[c.pointerId] = {
            pageX: c.pageX,
            pageY: c.pageY,
            target: c.currentTarget
          };
        });
      };

      g.prototype.onContainerPointerMove = function (e) {
        I(e, "onContainerTouchMove", "touchmove", function (c) {
          h[c.pointerId] = {
            pageX: c.pageX,
            pageY: c.pageY
          };
          h[c.pointerId].target || (h[c.pointerId].target = c.currentTarget);
        });
      };

      g.prototype.onDocumentPointerUp = function (e) {
        I(e, "onDocumentTouchEnd", "touchend", function (c) {
          delete h[c.pointerId];
        });
      };

      g.prototype.setDOMEvents = function () {
        d.prototype.setDOMEvents.call(this);
        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(E);
      };

      return g;
    }(g);
  });
  S(r, "parts/Legend.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.addEvent,
        u = g.css,
        I = g.defined,
        M = g.discardElement,
        E = g.find,
        A = g.fireEvent,
        G = g.format,
        J = g.isNumber,
        y = g.merge,
        t = g.pick,
        D = g.relativeLength,
        h = g.setAnimation,
        N = g.stableSort,
        q = g.syncTimeout;
    g = g.wrap;

    var P = d.isFirefox,
        e = d.marginNames,
        c = d.win,
        k = function () {
      function c(c, a) {
        this.allItems = [];
        this.contentGroup = this.box = void 0;
        this.display = !1;
        this.group = void 0;
        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
        this.options = {};
        this.padding = 0;
        this.pages = [];
        this.proximate = !1;
        this.scrollGroup = void 0;
        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
        this.chart = c;
        this.init(c, a);
      }

      c.prototype.init = function (c, a) {
        this.chart = c;
        this.setOptions(a);
        a.enabled && (this.render(), r(this.chart, "endResize", function () {
          this.legend.positionCheckboxes();
        }), this.proximate ? this.unchartrender = r(this.chart, "render", function () {
          this.legend.proximatePositions();
          this.legend.positionItems();
        }) : this.unchartrender && this.unchartrender());
      };

      c.prototype.setOptions = function (c) {
        var a = t(c.padding, 8);
        this.options = c;
        this.chart.styledMode || (this.itemStyle = c.itemStyle, this.itemHiddenStyle = y(this.itemStyle, c.itemHiddenStyle));
        this.itemMarginTop = c.itemMarginTop || 0;
        this.itemMarginBottom = c.itemMarginBottom || 0;
        this.padding = a;
        this.initialItemY = a - 5;
        this.symbolWidth = t(c.symbolWidth, 16);
        this.pages = [];
        this.proximate = "proximate" === c.layout && !this.chart.inverted;
        this.baseline = void 0;
      };

      c.prototype.update = function (c, a) {
        var f = this.chart;
        this.setOptions(y(!0, this.options, c));
        this.destroy();
        f.isDirtyLegend = f.isDirtyBox = !0;
        t(a, !0) && f.redraw();
        A(this, "afterUpdate");
      };

      c.prototype.colorizeItem = function (c, a) {
        c.legendGroup[a ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");

        if (!this.chart.styledMode) {
          var f = this.options,
              e = c.legendItem,
              d = c.legendLine,
              k = c.legendSymbol,
              h = this.itemHiddenStyle.color;
          f = a ? f.itemStyle.color : h;
          var n = a ? c.color || h : h,
              g = c.options && c.options.marker,
              q = {
            fill: n
          };
          e && e.css({
            fill: f,
            color: f
          });
          d && d.attr({
            stroke: n
          });
          k && (g && k.isMarker && (q = c.pointAttribs(), a || (q.stroke = q.fill = h)), k.attr(q));
        }

        A(this, "afterColorizeItem", {
          item: c,
          visible: a
        });
      };

      c.prototype.positionItems = function () {
        this.allItems.forEach(this.positionItem, this);
        this.chart.isResizing || this.positionCheckboxes();
      };

      c.prototype.positionItem = function (c) {
        var a = this.options,
            f = a.symbolPadding;
        a = !a.rtl;
        var e = c._legendItemPos,
            d = e[0];
        e = e[1];
        var k = c.checkbox;
        if ((c = c.legendGroup) && c.element) c[I(c.translateY) ? "animate" : "attr"]({
          translateX: a ? d : this.legendWidth - d - 2 * f - 4,
          translateY: e
        });
        k && (k.x = d, k.y = e);
      };

      c.prototype.destroyItem = function (c) {
        var a = c.checkbox;
        ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function (a) {
          c[a] && (c[a] = c[a].destroy());
        });
        a && M(c.checkbox);
      };

      c.prototype.destroy = function () {
        function c(a) {
          this[a] && (this[a] = this[a].destroy());
        }

        this.getAllItems().forEach(function (a) {
          ["legendItem", "legendGroup"].forEach(c, a);
        });
        "clipRect up down pager nav box title group".split(" ").forEach(c, this);
        this.display = null;
      };

      c.prototype.positionCheckboxes = function () {
        var c = this.group && this.group.alignAttr,
            a = this.clipHeight || this.legendHeight,
            e = this.titleHeight;

        if (c) {
          var d = c.translateY;
          this.allItems.forEach(function (f) {
            var k = f.checkbox;

            if (k) {
              var l = d + e + k.y + (this.scrollOffset || 0) + 3;
              u(k, {
                left: c.translateX + f.checkboxOffset + k.x - 20 + "px",
                top: l + "px",
                display: this.proximate || l > d - 6 && l < d + a - 6 ? "" : "none"
              });
            }
          }, this);
        }
      };

      c.prototype.renderTitle = function () {
        var c = this.options,
            a = this.padding,
            e = c.title,
            d = 0;
        e.text && (this.title || (this.title = this.chart.renderer.label(e.text, a - 3, a - 4, null, null, null, c.useHTML, null, "legend-title").attr({
          zIndex: 1
        }), this.chart.styledMode || this.title.css(e.style), this.title.add(this.group)), e.width || this.title.css({
          width: this.maxLegendWidth + "px"
        }), c = this.title.getBBox(), d = c.height, this.offsetWidth = c.width, this.contentGroup.attr({
          translateY: d
        }));
        this.titleHeight = d;
      };

      c.prototype.setText = function (c) {
        var a = this.options;
        c.legendItem.attr({
          text: a.labelFormat ? G(a.labelFormat, c, this.chart) : a.labelFormatter.call(c)
        });
      };

      c.prototype.renderItem = function (c) {
        var a = this.chart,
            e = a.renderer,
            f = this.options,
            d = this.symbolWidth,
            k = f.symbolPadding,
            h = this.itemStyle,
            n = this.itemHiddenStyle,
            g = "horizontal" === f.layout ? t(f.itemDistance, 20) : 0,
            q = !f.rtl,
            K = c.legendItem,
            p = !c.series,
            b = !p && c.series.drawLegendSymbol ? c.series : c,
            C = b.options;
        C = this.createCheckboxForItem && C && C.showCheckbox;
        g = d + k + g + (C ? 20 : 0);
        var x = f.useHTML,
            R = c.options.className;
        K || (c.legendGroup = e.g("legend-item").addClass("highcharts-" + b.type + "-series highcharts-color-" + c.colorIndex + (R ? " " + R : "") + (p ? " highcharts-series-" + c.index : "")).attr({
          zIndex: 1
        }).add(this.scrollGroup), c.legendItem = K = e.text("", q ? d + k : -k, this.baseline || 0, x), a.styledMode || K.css(y(c.visible ? h : n)), K.attr({
          align: q ? "left" : "right",
          zIndex: 2
        }).add(c.legendGroup), this.baseline || (this.fontMetrics = e.fontMetrics(a.styledMode ? 12 : h.fontSize, K), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, K.attr("y", this.baseline)), this.symbolHeight = f.symbolHeight || this.fontMetrics.f, b.drawLegendSymbol(this, c), this.setItemEvents && this.setItemEvents(c, K, x));
        C && !c.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(c);
        this.colorizeItem(c, c.visible);
        !a.styledMode && h.width || K.css({
          width: (f.itemWidth || this.widthOption || a.spacingBox.width) - g
        });
        this.setText(c);
        a = K.getBBox();
        c.itemWidth = c.checkboxOffset = f.itemWidth || c.legendItemWidth || a.width + g;
        this.maxItemWidth = Math.max(this.maxItemWidth, c.itemWidth);
        this.totalItemWidth += c.itemWidth;
        this.itemHeight = c.itemHeight = Math.round(c.legendItemHeight || a.height || this.symbolHeight);
      };

      c.prototype.layoutItem = function (c) {
        var a = this.options,
            e = this.padding,
            f = "horizontal" === a.layout,
            d = c.itemHeight,
            k = this.itemMarginBottom,
            h = this.itemMarginTop,
            n = f ? t(a.itemDistance, 20) : 0,
            g = this.maxLegendWidth;
        a = a.alignColumns && this.totalItemWidth > g ? this.maxItemWidth : c.itemWidth;
        f && this.itemX - e + a > g && (this.itemX = e, this.lastLineHeight && (this.itemY += h + this.lastLineHeight + k), this.lastLineHeight = 0);
        this.lastItemY = h + this.itemY + k;
        this.lastLineHeight = Math.max(d, this.lastLineHeight);
        c._legendItemPos = [this.itemX, this.itemY];
        f ? this.itemX += a : (this.itemY += h + d + k, this.lastLineHeight = d);
        this.offsetWidth = this.widthOption || Math.max((f ? this.itemX - e - (c.checkbox ? 0 : n) : a) + e, this.offsetWidth);
      };

      c.prototype.getAllItems = function () {
        var c = [];
        this.chart.series.forEach(function (a) {
          var e = a && a.options;
          a && t(e.showInLegend, I(e.linkedTo) ? !1 : void 0, !0) && (c = c.concat(a.legendItems || ("point" === e.legendType ? a.data : a)));
        });
        A(this, "afterGetAllItems", {
          allItems: c
        });
        return c;
      };

      c.prototype.getAlignment = function () {
        var c = this.options;
        return this.proximate ? c.align.charAt(0) + "tv" : c.floating ? "" : c.align.charAt(0) + c.verticalAlign.charAt(0) + c.layout.charAt(0);
      };

      c.prototype.adjustMargins = function (c, a) {
        var f = this.chart,
            d = this.options,
            k = this.getAlignment();
        k && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (l, h) {
          l.test(k) && !I(c[h]) && (f[e[h]] = Math.max(f[e[h]], f.legend[(h + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][h] * d[h % 2 ? "x" : "y"] + t(d.margin, 12) + a[h] + (f.titleOffset[h] || 0)));
        });
      };

      c.prototype.proximatePositions = function () {
        var c = this.chart,
            a = [],
            e = "left" === this.options.align;
        this.allItems.forEach(function (f) {
          var d = e;

          if (f.yAxis && f.points) {
            f.xAxis.options.reversed && (d = !d);
            var k = E(d ? f.points : f.points.slice(0).reverse(), function (a) {
              return J(a.plotY);
            });
            d = this.itemMarginTop + f.legendItem.getBBox().height + this.itemMarginBottom;
            var l = f.yAxis.top - c.plotTop;
            f.visible ? (k = k ? k.plotY : f.yAxis.height, k += l - .3 * d) : k = l + f.yAxis.height;
            a.push({
              target: k,
              size: d,
              item: f
            });
          }
        }, this);
        d.distribute(a, c.plotHeight);
        a.forEach(function (a) {
          a.item._legendItemPos[1] = c.plotTop - c.spacing[0] + a.pos;
        });
      };

      c.prototype.render = function () {
        var c = this.chart,
            a = c.renderer,
            e = this.group,
            d,
            k = this.box,
            h = this.options,
            n = this.padding;
        this.itemX = n;
        this.itemY = this.initialItemY;
        this.lastItemY = this.offsetWidth = 0;
        this.widthOption = D(h.width, c.spacingBox.width - n);
        var g = c.spacingBox.width - 2 * n - h.x;
        -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (g /= 2);
        this.maxLegendWidth = this.widthOption || g;
        e || (this.group = e = a.g("legend").attr({
          zIndex: 7
        }).add(), this.contentGroup = a.g().attr({
          zIndex: 1
        }).add(e), this.scrollGroup = a.g().add(this.contentGroup));
        this.renderTitle();
        g = this.getAllItems();
        N(g, function (a, c) {
          return (a.options && a.options.legendIndex || 0) - (c.options && c.options.legendIndex || 0);
        });
        h.reversed && g.reverse();
        this.allItems = g;
        this.display = d = !!g.length;
        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
        g.forEach(this.renderItem, this);
        g.forEach(this.layoutItem, this);
        g = (this.widthOption || this.offsetWidth) + n;
        var q = this.lastItemY + this.lastLineHeight + this.titleHeight;
        q = this.handleOverflow(q);
        q += n;
        k || (this.box = k = a.rect().addClass("highcharts-legend-box").attr({
          r: h.borderRadius
        }).add(e), k.isNew = !0);
        c.styledMode || k.attr({
          stroke: h.borderColor,
          "stroke-width": h.borderWidth || 0,
          fill: h.backgroundColor || "none"
        }).shadow(h.shadow);
        0 < g && 0 < q && (k[k.isNew ? "attr" : "animate"](k.crisp.call({}, {
          x: 0,
          y: 0,
          width: g,
          height: q
        }, k.strokeWidth())), k.isNew = !1);
        k[d ? "show" : "hide"]();
        c.styledMode && "none" === e.getStyle("display") && (g = q = 0);
        this.legendWidth = g;
        this.legendHeight = q;
        d && (a = c.spacingBox, k = a.y, /(lth|ct|rth)/.test(this.getAlignment()) && 0 < c.titleOffset[0] ? k += c.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < c.titleOffset[2] && (k -= c.titleOffset[2]), k !== a.y && (a = y(a, {
          y: k
        })), e.align(y(h, {
          width: g,
          height: q,
          verticalAlign: this.proximate ? "top" : h.verticalAlign
        }), !0, a));
        this.proximate || this.positionItems();
        A(this, "afterRender");
      };

      c.prototype.handleOverflow = function (c) {
        var a = this,
            e = this.chart,
            f = e.renderer,
            d = this.options,
            k = d.y,
            h = this.padding;
        k = e.spacingBox.height + ("top" === d.verticalAlign ? -k : k) - h;

        var n = d.maxHeight,
            g,
            q = this.clipRect,
            y = d.navigation,
            p = t(y.animation, !0),
            b = y.arrowSize || 12,
            C = this.nav,
            x = this.pages,
            R,
            O = this.allItems,
            u = function (b) {
          "number" === typeof b ? q.attr({
            height: b
          }) : q && (a.clipRect = q.destroy(), a.contentGroup.clip());
          a.contentGroup.div && (a.contentGroup.div.style.clip = b ? "rect(" + h + "px,9999px," + (h + b) + "px,0)" : "auto");
        },
            D = function (c) {
          a[c] = f.circle(0, 0, 1.3 * b).translate(b / 2, b / 2).add(C);
          e.styledMode || a[c].attr("fill", "rgba(0,0,0,0.0001)");
          return a[c];
        };

        "horizontal" !== d.layout || "middle" === d.verticalAlign || d.floating || (k /= 2);
        n && (k = Math.min(k, n));
        x.length = 0;
        c > k && !1 !== y.enabled ? (this.clipHeight = g = Math.max(k - 20 - this.titleHeight - h, 0), this.currentPage = t(this.currentPage, 1), this.fullHeight = c, O.forEach(function (b, a) {
          var c = b._legendItemPos[1],
              e = Math.round(b.legendItem.getBBox().height),
              f = x.length;
          if (!f || c - x[f - 1] > g && (R || c) !== x[f - 1]) x.push(R || c), f++;
          b.pageIx = f - 1;
          R && (O[a - 1].pageIx = f - 1);
          a === O.length - 1 && c + e - x[f - 1] > g && c !== R && (x.push(c), b.pageIx = f);
          c !== R && (R = c);
        }), q || (q = a.clipRect = f.clipRect(0, h, 9999, 0), a.contentGroup.clip(q)), u(g), C || (this.nav = C = f.g().attr({
          zIndex: 1
        }).add(this.group), this.up = f.symbol("triangle", 0, 0, b, b).add(C), D("upTracker").on("click", function () {
          a.scroll(-1, p);
        }), this.pager = f.text("", 15, 10).addClass("highcharts-legend-navigation"), e.styledMode || this.pager.css(y.style), this.pager.add(C), this.down = f.symbol("triangle-down", 0, 0, b, b).add(C), D("downTracker").on("click", function () {
          a.scroll(1, p);
        })), a.scroll(0), c = k) : C && (u(), this.nav = C.destroy(), this.scrollGroup.attr({
          translateY: 1
        }), this.clipHeight = 0);
        return c;
      };

      c.prototype.scroll = function (c, a) {
        var e = this,
            f = this.chart,
            k = this.pages,
            n = k.length,
            g = this.currentPage + c;
        c = this.clipHeight;
        var y = this.options.navigation,
            u = this.pager,
            H = this.padding;
        g > n && (g = n);
        0 < g && ("undefined" !== typeof a && h(a, f), this.nav.attr({
          translateX: H,
          translateY: c + this.padding + 7 + this.titleHeight,
          visibility: "visible"
        }), [this.up, this.upTracker].forEach(function (a) {
          a.attr({
            "class": 1 === g ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
          });
        }), u.attr({
          text: g + "/" + n
        }), [this.down, this.downTracker].forEach(function (a) {
          a.attr({
            x: 18 + this.pager.getBBox().width,
            "class": g === n ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
          });
        }, this), f.styledMode || (this.up.attr({
          fill: 1 === g ? y.inactiveColor : y.activeColor
        }), this.upTracker.css({
          cursor: 1 === g ? "default" : "pointer"
        }), this.down.attr({
          fill: g === n ? y.inactiveColor : y.activeColor
        }), this.downTracker.css({
          cursor: g === n ? "default" : "pointer"
        })), this.scrollOffset = -k[g - 1] + this.initialItemY, this.scrollGroup.animate({
          translateY: this.scrollOffset
        }), this.currentPage = g, this.positionCheckboxes(), a = d.animObject(t(a, f.renderer.globalAnimation, !0)), q(function () {
          A(e, "afterScroll", {
            currentPage: g
          });
        }, a.duration || 0));
      };

      return c;
    }();

    (/Trident\/7\.0/.test(c.navigator && c.navigator.userAgent) || P) && g(k.prototype, "positionItem", function (c, e) {
      var a = this,
          f = function () {
        e._legendItemPos && c.call(a, e);
      };

      f();
      a.bubbleLegend || setTimeout(f);
    });
    d.Legend = k;
    return d.Legend;
  });
  S(r, "parts/Chart.js", [r["parts/Globals.js"], r["parts/Legend.js"], r["parts/MSPointer.js"], r["parts/Pointer.js"], r["parts/Time.js"], r["parts/Utilities.js"]], function (d, g, r, u, I, M) {
    var E = M.addEvent,
        A = M.animate,
        G = M.animObject,
        J = M.attr,
        y = M.createElement,
        t = M.css,
        D = M.defined,
        h = M.discardElement,
        N = M.erase,
        q = M.error,
        P = M.extend,
        e = M.find,
        c = M.fireEvent,
        k = M.getStyle,
        n = M.isArray,
        f = M.isFunction,
        a = M.isNumber,
        l = M.isObject,
        v = M.isString,
        z = M.merge,
        w = M.numberFormat,
        B = M.objectEach,
        L = M.pick,
        Q = M.pInt,
        H = M.relativeLength,
        K = M.removeEvent,
        p = M.setAnimation,
        b = M.splat,
        C = M.syncTimeout,
        x = M.uniqueKey,
        R = d.doc,
        O = d.Axis,
        X = d.defaultOptions,
        U = d.charts,
        m = d.marginNames,
        T = d.seriesTypes,
        Z = d.win,
        ca = d.Chart = function () {
      this.getArgs.apply(this, arguments);
    };

    d.chart = function (b, a, c) {
      return new ca(b, a, c);
    };

    P(ca.prototype, {
      callbacks: [],
      getArgs: function () {
        var b = [].slice.call(arguments);
        if (v(b[0]) || b[0].nodeName) this.renderTo = b.shift();
        this.init(b[0], b[1]);
      },
      init: function (b, a) {
        var e,
            k = b.series,
            h = b.plotOptions || {};
        c(this, "init", {
          args: arguments
        }, function () {
          b.series = null;
          e = z(X, b);
          B(e.plotOptions, function (b, a) {
            l(b) && (b.tooltip = h[a] && z(h[a].tooltip) || void 0);
          });
          e.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;
          e.series = b.series = k;
          this.userOptions = b;
          var m = e.chart,
              n = m.events;
          this.margin = [];
          this.spacing = [];
          this.bounds = {
            h: {},
            v: {}
          };
          this.labelCollectors = [];
          this.callback = a;
          this.isResizing = 0;
          this.options = e;
          this.axes = [];
          this.series = [];
          this.time = b.time && Object.keys(b.time).length ? new I(b.time) : d.time;
          this.numberFormatter = m.numberFormatter || w;
          this.styledMode = m.styledMode;
          this.hasCartesianSeries = m.showAxes;
          var p = this;
          p.index = U.length;
          U.push(p);
          d.chartCount++;
          n && B(n, function (b, a) {
            f(b) && E(p, a, b);
          });
          p.xAxis = [];
          p.yAxis = [];
          p.pointCount = p.colorCounter = p.symbolCounter = 0;
          c(p, "afterInit");
          p.firstRender();
        });
      },
      initSeries: function (b) {
        var a = this.options.chart;
        a = b.type || a.type || a.defaultSeriesType;
        var c = T[a];
        c || q(17, !0, this, {
          missingModuleFor: a
        });
        a = new c();
        a.init(this, b);
        return a;
      },
      setSeriesData: function () {
        this.getSeriesOrderByLinks().forEach(function (b) {
          b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);
        });
      },
      getSeriesOrderByLinks: function () {
        return this.series.concat().sort(function (b, a) {
          return b.linkedSeries.length || a.linkedSeries.length ? a.linkedSeries.length - b.linkedSeries.length : 0;
        });
      },
      orderSeries: function (b) {
        var a = this.series;

        for (b = b || 0; b < a.length; b++) a[b] && (a[b].index = b, a[b].name = a[b].getName());
      },
      isInsidePlot: function (b, a, e) {
        var f = e ? a : b;
        b = e ? b : a;
        f = {
          x: f,
          y: b,
          isInsidePlot: 0 <= f && f <= this.plotWidth && 0 <= b && b <= this.plotHeight
        };
        c(this, "afterIsInsidePlot", f);
        return f.isInsidePlot;
      },
      redraw: function (b) {
        c(this, "beforeRedraw");
        var a = this.axes,
            e = this.series,
            f = this.pointer,
            d = this.legend,
            k = this.userOptions.legend,
            l = this.isDirtyLegend,
            h = this.hasCartesianSeries,
            m = this.isDirtyBox,
            n = this.renderer,
            x = n.isHidden(),
            g = [];
        this.setResponsive && this.setResponsive(!1);
        p(this.hasRendered ? b : !1, this);
        x && this.temporaryDisplay();
        this.layOutTitles();

        for (b = e.length; b--;) {
          var w = e[b];

          if (w.options.stacking) {
            var C = !0;

            if (w.isDirty) {
              var v = !0;
              break;
            }
          }
        }

        if (v) for (b = e.length; b--;) w = e[b], w.options.stacking && (w.isDirty = !0);
        e.forEach(function (b) {
          b.isDirty && ("point" === b.options.legendType ? (b.updateTotals && b.updateTotals(), l = !0) : k && (k.labelFormatter || k.labelFormat) && (l = !0));
          b.isDirtyData && c(b, "updatedData");
        });
        l && d && d.options.enabled && (d.render(), this.isDirtyLegend = !1);
        C && this.getStacks();
        h && a.forEach(function (b) {
          b.updateNames();
          b.setScale();
        });
        this.getMargins();
        h && (a.forEach(function (b) {
          b.isDirty && (m = !0);
        }), a.forEach(function (b) {
          var a = b.min + "," + b.max;
          b.extKey !== a && (b.extKey = a, g.push(function () {
            c(b, "afterSetExtremes", P(b.eventArgs, b.getExtremes()));
            delete b.eventArgs;
          }));
          (m || C) && b.redraw();
        }));
        m && this.drawChartBox();
        c(this, "predraw");
        e.forEach(function (b) {
          (m || b.isDirty) && b.visible && b.redraw();
          b.isDirtyData = !1;
        });
        f && f.reset(!0);
        n.draw();
        c(this, "redraw");
        c(this, "render");
        x && this.temporaryDisplay(!0);
        g.forEach(function (b) {
          b.call();
        });
      },
      get: function (b) {
        function a(a) {
          return a.id === b || a.options && a.options.id === b;
        }

        var c = this.series,
            f;
        var d = e(this.axes, a) || e(this.series, a);

        for (f = 0; !d && f < c.length; f++) d = e(c[f].points || [], a);

        return d;
      },
      getAxes: function () {
        var a = this,
            e = this.options,
            f = e.xAxis = b(e.xAxis || {});
        e = e.yAxis = b(e.yAxis || {});
        c(this, "getAxes");
        f.forEach(function (b, a) {
          b.index = a;
          b.isX = !0;
        });
        e.forEach(function (b, a) {
          b.index = a;
        });
        f.concat(e).forEach(function (b) {
          new O(a, b);
        });
        c(this, "afterGetAxes");
      },
      getSelectedPoints: function () {
        var b = [];
        this.series.forEach(function (a) {
          b = b.concat(a.getPointsCollection().filter(function (b) {
            return L(b.selectedStaging, b.selected);
          }));
        });
        return b;
      },
      getSelectedSeries: function () {
        return this.series.filter(function (b) {
          return b.selected;
        });
      },
      setTitle: function (b, a, c) {
        this.applyDescription("title", b);
        this.applyDescription("subtitle", a);
        this.applyDescription("caption", void 0);
        this.layOutTitles(c);
      },
      applyDescription: function (b, a) {
        var c = this,
            e = "title" === b ? {
          color: "#333333",
          fontSize: this.options.isStock ? "16px" : "18px"
        } : {
          color: "#666666"
        };
        e = this.options[b] = z(!this.styledMode && {
          style: e
        }, this.options[b], a);
        var f = this[b];
        f && a && (this[b] = f = f.destroy());
        e && !f && (f = this.renderer.text(e.text, 0, 0, e.useHTML).attr({
          align: e.align,
          "class": "highcharts-" + b,
          zIndex: e.zIndex || 4
        }).add(), f.update = function (a) {
          c[{
            title: "setTitle",
            subtitle: "setSubtitle",
            caption: "setCaption"
          }[b]](a);
        }, this.styledMode || f.css(e.style), this[b] = f);
      },
      layOutTitles: function (b) {
        var a = [0, 0, 0],
            e = this.renderer,
            f = this.spacingBox;
        ["title", "subtitle", "caption"].forEach(function (b) {
          var c = this[b],
              d = this.options[b],
              k = d.verticalAlign || "top";
          b = "title" === b ? -3 : "top" === k ? a[0] + 2 : 0;

          if (c) {
            if (!this.styledMode) var l = d.style.fontSize;
            l = e.fontMetrics(l, c).b;
            c.css({
              width: (d.width || f.width + (d.widthAdjust || 0)) + "px"
            });
            var h = Math.round(c.getBBox(d.useHTML).height);
            c.align(P({
              y: "bottom" === k ? l : b + l,
              height: h
            }, d), !1, "spacingBox");
            d.floating || ("top" === k ? a[0] = Math.ceil(a[0] + h) : "bottom" === k && (a[2] = Math.ceil(a[2] + h)));
          }
        }, this);
        a[0] && "top" === (this.options.title.verticalAlign || "top") && (a[0] += this.options.title.margin);
        a[2] && "bottom" === this.options.caption.verticalAlign && (a[2] += this.options.caption.margin);
        var d = !this.titleOffset || this.titleOffset.join(",") !== a.join(",");
        this.titleOffset = a;
        c(this, "afterLayOutTitles");
        !this.isDirtyBox && d && (this.isDirtyBox = this.isDirtyLegend = d, this.hasRendered && L(b, !0) && this.isDirtyBox && this.redraw());
      },
      getChartSize: function () {
        var b = this.options.chart,
            a = b.width;
        b = b.height;
        var c = this.renderTo;
        D(a) || (this.containerWidth = k(c, "width"));
        D(b) || (this.containerHeight = k(c, "height"));
        this.chartWidth = Math.max(0, a || this.containerWidth || 600);
        this.chartHeight = Math.max(0, H(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
      },
      temporaryDisplay: function (b) {
        var a = this.renderTo;
        if (b) for (; a && a.style;) a.hcOrigStyle && (t(a, a.hcOrigStyle), delete a.hcOrigStyle), a.hcOrigDetached && (R.body.removeChild(a), a.hcOrigDetached = !1), a = a.parentNode;else for (; a && a.style;) {
          R.body.contains(a) || a.parentNode || (a.hcOrigDetached = !0, R.body.appendChild(a));
          if ("none" === k(a, "display", !1) || a.hcOricDetached) a.hcOrigStyle = {
            display: a.style.display,
            height: a.style.height,
            overflow: a.style.overflow
          }, b = {
            display: "block",
            overflow: "hidden"
          }, a !== this.renderTo && (b.height = 0), t(a, b), a.offsetWidth || a.style.setProperty("display", "block", "important");
          a = a.parentNode;
          if (a === R.body) break;
        }
      },
      setClassName: function (b) {
        this.container.className = "highcharts-container " + (b || "");
      },
      getContainer: function () {
        var b = this.options,
            e = b.chart;
        var f = this.renderTo;
        var k = x(),
            l,
            h;
        f || (this.renderTo = f = e.renderTo);
        v(f) && (this.renderTo = f = R.getElementById(f));
        f || q(13, !0, this);
        var m = Q(J(f, "data-highcharts-chart"));
        a(m) && U[m] && U[m].hasRendered && U[m].destroy();
        J(f, "data-highcharts-chart", this.index);
        f.innerHTML = "";
        e.skipClone || f.offsetWidth || this.temporaryDisplay();
        this.getChartSize();
        m = this.chartWidth;
        var n = this.chartHeight;
        t(f, {
          overflow: "hidden"
        });
        this.styledMode || (l = P({
          position: "relative",
          overflow: "hidden",
          width: m + "px",
          height: n + "px",
          textAlign: "left",
          lineHeight: "normal",
          zIndex: 0,
          "-webkit-tap-highlight-color": "rgba(0,0,0,0)"
        }, e.style));
        this.container = f = y("div", {
          id: k
        }, l, f);
        this._cursor = f.style.cursor;
        this.renderer = new (d[e.renderer] || d.Renderer)(f, m, n, null, e.forExport, b.exporting && b.exporting.allowHTML, this.styledMode);
        p(void 0, this);
        this.setClassName(e.className);
        if (this.styledMode) for (h in b.defs) this.renderer.definition(b.defs[h]);else this.renderer.setStyle(e.style);
        this.renderer.chartIndex = this.index;
        c(this, "afterGetContainer");
      },
      getMargins: function (b) {
        var a = this.spacing,
            e = this.margin,
            f = this.titleOffset;
        this.resetMargins();
        f[0] && !D(e[0]) && (this.plotTop = Math.max(this.plotTop, f[0] + a[0]));
        f[2] && !D(e[2]) && (this.marginBottom = Math.max(this.marginBottom, f[2] + a[2]));
        this.legend && this.legend.display && this.legend.adjustMargins(e, a);
        c(this, "getMargins");
        b || this.getAxisMargins();
      },
      getAxisMargins: function () {
        var b = this,
            a = b.axisOffset = [0, 0, 0, 0],
            c = b.colorAxis,
            e = b.margin,
            f = function (b) {
          b.forEach(function (b) {
            b.visible && b.getOffset();
          });
        };

        b.hasCartesianSeries ? f(b.axes) : c && c.length && f(c);
        m.forEach(function (c, f) {
          D(e[f]) || (b[c] += a[f]);
        });
        b.setChartSize();
      },
      reflow: function (b) {
        var a = this,
            c = a.options.chart,
            e = a.renderTo,
            f = D(c.width) && D(c.height),
            d = c.width || k(e, "width");
        c = c.height || k(e, "height");
        e = b ? b.target : Z;

        if (!f && !a.isPrinting && d && c && (e === Z || e === R)) {
          if (d !== a.containerWidth || c !== a.containerHeight) M.clearTimeout(a.reflowTimeout), a.reflowTimeout = C(function () {
            a.container && a.setSize(void 0, void 0, !1);
          }, b ? 100 : 0);
          a.containerWidth = d;
          a.containerHeight = c;
        }
      },
      setReflow: function (b) {
        var a = this;
        !1 === b || this.unbindReflow ? !1 === b && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = E(Z, "resize", function (b) {
          a.options && a.reflow(b);
        }), E(this, "destroy", this.unbindReflow));
      },
      setSize: function (b, a, e) {
        var f = this,
            d = f.renderer;
        f.isResizing += 1;
        p(e, f);
        e = d.globalAnimation;
        f.oldChartHeight = f.chartHeight;
        f.oldChartWidth = f.chartWidth;
        "undefined" !== typeof b && (f.options.chart.width = b);
        "undefined" !== typeof a && (f.options.chart.height = a);
        f.getChartSize();
        f.styledMode || (e ? A : t)(f.container, {
          width: f.chartWidth + "px",
          height: f.chartHeight + "px"
        }, e);
        f.setChartSize(!0);
        d.setSize(f.chartWidth, f.chartHeight, e);
        f.axes.forEach(function (b) {
          b.isDirty = !0;
          b.setScale();
        });
        f.isDirtyLegend = !0;
        f.isDirtyBox = !0;
        f.layOutTitles();
        f.getMargins();
        f.redraw(e);
        f.oldChartHeight = null;
        c(f, "resize");
        C(function () {
          f && c(f, "endResize", null, function () {
            --f.isResizing;
          });
        }, G(e).duration || 0);
      },
      setChartSize: function (b) {
        var a = this.inverted,
            e = this.renderer,
            f = this.chartWidth,
            d = this.chartHeight,
            k = this.options.chart,
            l = this.spacing,
            h = this.clipOffset,
            m,
            n,
            p,
            x;
        this.plotLeft = m = Math.round(this.plotLeft);
        this.plotTop = n = Math.round(this.plotTop);
        this.plotWidth = p = Math.max(0, Math.round(f - m - this.marginRight));
        this.plotHeight = x = Math.max(0, Math.round(d - n - this.marginBottom));
        this.plotSizeX = a ? x : p;
        this.plotSizeY = a ? p : x;
        this.plotBorderWidth = k.plotBorderWidth || 0;
        this.spacingBox = e.spacingBox = {
          x: l[3],
          y: l[0],
          width: f - l[3] - l[1],
          height: d - l[0] - l[2]
        };
        this.plotBox = e.plotBox = {
          x: m,
          y: n,
          width: p,
          height: x
        };
        f = 2 * Math.floor(this.plotBorderWidth / 2);
        a = Math.ceil(Math.max(f, h[3]) / 2);
        e = Math.ceil(Math.max(f, h[0]) / 2);
        this.clipBox = {
          x: a,
          y: e,
          width: Math.floor(this.plotSizeX - Math.max(f, h[1]) / 2 - a),
          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(f, h[2]) / 2 - e))
        };
        b || this.axes.forEach(function (b) {
          b.setAxisSize();
          b.setAxisTranslation();
        });
        c(this, "afterSetChartSize", {
          skipAxes: b
        });
      },
      resetMargins: function () {
        c(this, "resetMargins");
        var b = this,
            a = b.options.chart;
        ["margin", "spacing"].forEach(function (c) {
          var e = a[c],
              f = l(e) ? e : [e, e, e, e];
          ["Top", "Right", "Bottom", "Left"].forEach(function (e, d) {
            b[c][d] = L(a[c + e], f[d]);
          });
        });
        m.forEach(function (a, c) {
          b[a] = L(b.margin[c], b.spacing[c]);
        });
        b.axisOffset = [0, 0, 0, 0];
        b.clipOffset = [0, 0, 0, 0];
      },
      drawChartBox: function () {
        var b = this.options.chart,
            a = this.renderer,
            e = this.chartWidth,
            f = this.chartHeight,
            d = this.chartBackground,
            k = this.plotBackground,
            l = this.plotBorder,
            h = this.styledMode,
            m = this.plotBGImage,
            n = b.backgroundColor,
            p = b.plotBackgroundColor,
            x = b.plotBackgroundImage,
            g,
            w = this.plotLeft,
            C = this.plotTop,
            v = this.plotWidth,
            q = this.plotHeight,
            t = this.plotBox,
            B = this.clipRect,
            z = this.clipBox,
            O = "animate";
        d || (this.chartBackground = d = a.rect().addClass("highcharts-background").add(), O = "attr");
        if (h) var y = g = d.strokeWidth();else {
          y = b.borderWidth || 0;
          g = y + (b.shadow ? 8 : 0);
          n = {
            fill: n || "none"
          };
          if (y || d["stroke-width"]) n.stroke = b.borderColor, n["stroke-width"] = y;
          d.attr(n).shadow(b.shadow);
        }
        d[O]({
          x: g / 2,
          y: g / 2,
          width: e - g - y % 2,
          height: f - g - y % 2,
          r: b.borderRadius
        });
        O = "animate";
        k || (O = "attr", this.plotBackground = k = a.rect().addClass("highcharts-plot-background").add());
        k[O](t);
        h || (k.attr({
          fill: p || "none"
        }).shadow(b.plotShadow), x && (m ? (x !== m.attr("href") && m.attr("href", x), m.animate(t)) : this.plotBGImage = a.image(x, w, C, v, q).add()));
        B ? B.animate({
          width: z.width,
          height: z.height
        }) : this.clipRect = a.clipRect(z);
        O = "animate";
        l || (O = "attr", this.plotBorder = l = a.rect().addClass("highcharts-plot-border").attr({
          zIndex: 1
        }).add());
        h || l.attr({
          stroke: b.plotBorderColor,
          "stroke-width": b.plotBorderWidth || 0,
          fill: "none"
        });
        l[O](l.crisp({
          x: w,
          y: C,
          width: v,
          height: q
        }, -l.strokeWidth()));
        this.isDirtyBox = !1;
        c(this, "afterDrawChartBox");
      },
      propFromSeries: function () {
        var b = this,
            a = b.options.chart,
            c,
            e = b.options.series,
            f,
            d;
        ["inverted", "angular", "polar"].forEach(function (k) {
          c = T[a.type || a.defaultSeriesType];
          d = a[k] || c && c.prototype[k];

          for (f = e && e.length; !d && f--;) (c = T[e[f].type]) && c.prototype[k] && (d = !0);

          b[k] = d;
        });
      },
      linkSeries: function () {
        var b = this,
            a = b.series;
        a.forEach(function (b) {
          b.linkedSeries.length = 0;
        });
        a.forEach(function (a) {
          var c = a.options.linkedTo;
          v(c) && (c = ":previous" === c ? b.series[a.index - 1] : b.get(c)) && c.linkedParent !== a && (c.linkedSeries.push(a), a.linkedParent = c, c.enabledDataSorting && a.setDataSortingOptions(), a.visible = L(a.options.visible, c.options.visible, a.visible));
        });
        c(this, "afterLinkSeries");
      },
      renderSeries: function () {
        this.series.forEach(function (b) {
          b.translate();
          b.render();
        });
      },
      renderLabels: function () {
        var b = this,
            a = b.options.labels;
        a.items && a.items.forEach(function (c) {
          var e = P(a.style, c.style),
              f = Q(e.left) + b.plotLeft,
              d = Q(e.top) + b.plotTop + 12;
          delete e.left;
          delete e.top;
          b.renderer.text(c.html, f, d).attr({
            zIndex: 2
          }).css(e).add();
        });
      },
      render: function () {
        var b = this.axes,
            a = this.colorAxis,
            c = this.renderer,
            e = this.options,
            f = 0,
            d = function (b) {
          b.forEach(function (b) {
            b.visible && b.render();
          });
        };

        this.setTitle();
        this.legend = new g(this, e.legend);
        this.getStacks && this.getStacks();
        this.getMargins(!0);
        this.setChartSize();
        e = this.plotWidth;
        b.some(function (b) {
          if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return f = 21, !0;
        });
        var k = this.plotHeight = Math.max(this.plotHeight - f, 0);
        b.forEach(function (b) {
          b.setScale();
        });
        this.getAxisMargins();
        var l = 1.1 < e / this.plotWidth;
        var h = 1.05 < k / this.plotHeight;
        if (l || h) b.forEach(function (b) {
          (b.horiz && l || !b.horiz && h) && b.setTickInterval(!0);
        }), this.getMargins();
        this.drawChartBox();
        this.hasCartesianSeries ? d(b) : a && a.length && d(a);
        this.seriesGroup || (this.seriesGroup = c.g("series-group").attr({
          zIndex: 3
        }).add());
        this.renderSeries();
        this.renderLabels();
        this.addCredits();
        this.setResponsive && this.setResponsive();
        this.updateContainerScaling();
        this.hasRendered = !0;
      },
      addCredits: function (b) {
        var a = this;
        b = z(!0, this.options.credits, b);
        b.enabled && !this.credits && (this.credits = this.renderer.text(b.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
          b.href && (Z.location.href = b.href);
        }).attr({
          align: b.position.align,
          zIndex: 8
        }), a.styledMode || this.credits.css(b.style), this.credits.add().align(b.position), this.credits.update = function (b) {
          a.credits = a.credits.destroy();
          a.addCredits(b);
        });
      },
      updateContainerScaling: function () {
        var b = this.container;

        if (b.offsetWidth && b.offsetHeight && b.getBoundingClientRect) {
          var a = b.getBoundingClientRect(),
              c = a.width / b.offsetWidth;
          b = a.height / b.offsetHeight;
          1 !== c || 1 !== b ? this.containerScaling = {
            scaleX: c,
            scaleY: b
          } : delete this.containerScaling;
        }
      },
      destroy: function () {
        var b = this,
            a = b.axes,
            e = b.series,
            f = b.container,
            k,
            l = f && f.parentNode;
        c(b, "destroy");
        b.renderer.forExport ? N(U, b) : U[b.index] = void 0;
        d.chartCount--;
        b.renderTo.removeAttribute("data-highcharts-chart");
        K(b);

        for (k = a.length; k--;) a[k] = a[k].destroy();

        this.scroller && this.scroller.destroy && this.scroller.destroy();

        for (k = e.length; k--;) e[k] = e[k].destroy();

        "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (a) {
          var c = b[a];
          c && c.destroy && (b[a] = c.destroy());
        });
        f && (f.innerHTML = "", K(f), l && h(f));
        B(b, function (a, c) {
          delete b[c];
        });
      },
      firstRender: function () {
        var b = this,
            a = b.options;

        if (!b.isReadyToRender || b.isReadyToRender()) {
          b.getContainer();
          b.resetMargins();
          b.setChartSize();
          b.propFromSeries();
          b.getAxes();
          (n(a.series) ? a.series : []).forEach(function (a) {
            b.initSeries(a);
          });
          b.linkSeries();
          b.setSeriesData();
          c(b, "beforeRender");
          u && (b.pointer = d.hasTouch || !Z.PointerEvent && !Z.MSPointerEvent ? new u(b, a) : new r(b, a));
          b.render();
          if (!b.renderer.imgCount && !b.hasLoaded) b.onload();
          b.temporaryDisplay(!0);
        }
      },
      onload: function () {
        this.callbacks.concat([this.callback]).forEach(function (b) {
          b && "undefined" !== typeof this.index && b.apply(this, [this]);
        }, this);
        c(this, "load");
        c(this, "render");
        D(this.index) && this.setReflow(this.options.chart.reflow);
        this.hasLoaded = !0;
      }
    });
  });
  S(r, "parts/ScrollablePlotArea.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.addEvent,
        u = g.createElement,
        I = g.pick,
        M = g.stop;
    g = d.Chart;
    "";
    r(g, "afterSetChartSize", function (g) {
      var u = this.options.chart.scrollablePlotArea,
          r = u && u.minWidth;
      u = u && u.minHeight;

      if (!this.renderer.forExport) {
        if (r) {
          if (this.scrollablePixelsX = r = Math.max(0, r - this.chartWidth)) {
            this.plotWidth += r;
            this.inverted ? (this.clipBox.height += r, this.plotBox.height += r) : (this.clipBox.width += r, this.plotBox.width += r);
            var E = {
              1: {
                name: "right",
                value: r
              }
            };
          }
        } else u && (this.scrollablePixelsY = r = Math.max(0, u - this.chartHeight)) && (this.plotHeight += r, this.inverted ? (this.clipBox.width += r, this.plotBox.width += r) : (this.clipBox.height += r, this.plotBox.height += r), E = {
          2: {
            name: "bottom",
            value: r
          }
        });

        E && !g.skipAxes && this.axes.forEach(function (g) {
          E[g.side] ? g.getPlotLinePath = function () {
            var t = E[g.side].name,
                y = this[t];
            this[t] = y - E[g.side].value;
            var h = d.Axis.prototype.getPlotLinePath.apply(this, arguments);
            this[t] = y;
            return h;
          } : (g.setAxisSize(), g.setAxisTranslation());
        });
      }
    });
    r(g, "render", function () {
      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
    });

    g.prototype.setUpScrolling = function () {
      var d = this,
          g = {
        WebkitOverflowScrolling: "touch",
        overflowX: "hidden",
        overflowY: "hidden"
      };
      this.scrollablePixelsX && (g.overflowX = "auto");
      this.scrollablePixelsY && (g.overflowY = "auto");
      this.scrollingContainer = u("div", {
        className: "highcharts-scrolling"
      }, g, this.renderTo);
      r(this.scrollingContainer, "scroll", function () {
        d.pointer && delete d.pointer.chartPosition;
      });
      this.innerContainer = u("div", {
        className: "highcharts-inner-container"
      }, null, this.scrollingContainer);
      this.innerContainer.appendChild(this.container);
      this.setUpScrolling = null;
    };

    g.prototype.moveFixedElements = function () {
      var d = this.container,
          g = this.fixedRenderer,
          u = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),
          r;
      this.scrollablePixelsX && !this.inverted ? r = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? r = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? r = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (r = ".highcharts-yaxis");
      u.push(r, r + "-labels");
      u.forEach(function (y) {
        [].forEach.call(d.querySelectorAll(y), function (d) {
          (d.namespaceURI === g.SVG_NS ? g.box : g.box.parentNode).appendChild(d);
          d.style.pointerEvents = "auto";
        });
      });
    };

    g.prototype.applyFixed = function () {
      var g,
          A = !this.fixedDiv,
          G = this.options.chart.scrollablePlotArea;
      A ? (this.fixedDiv = u("div", {
        className: "highcharts-fixed"
      }, {
        position: "absolute",
        overflow: "hidden",
        pointerEvents: "none",
        zIndex: 2
      }, null, !0), this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild), this.renderTo.style.overflow = "visible", this.fixedRenderer = g = new d.Renderer(this.fixedDiv, this.chartWidth, this.chartHeight), this.scrollableMask = g.path().attr({
        fill: this.options.chart.backgroundColor || "#fff",
        "fill-opacity": I(G.opacity, .85),
        zIndex: -1
      }).addClass("highcharts-scrollable-mask").add(), this.moveFixedElements(), r(this, "afterShowResetZoom", this.moveFixedElements), r(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
      g = this.chartWidth + (this.scrollablePixelsX || 0);
      var J = this.chartHeight + (this.scrollablePixelsY || 0);
      M(this.container);
      this.container.style.width = g + "px";
      this.container.style.height = J + "px";
      this.renderer.boxWrapper.attr({
        width: g,
        height: J,
        viewBox: [0, 0, g, J].join(" ")
      });
      this.chartBackground.attr({
        width: g,
        height: J
      });
      this.scrollablePixelsY && (this.scrollingContainer.style.height = this.chartHeight + "px");
      A && (G.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * G.scrollPositionX), G.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * G.scrollPositionY));
      J = this.axisOffset;
      A = this.plotTop - J[0] - 1;
      G = this.plotLeft - J[3] - 1;
      g = this.plotTop + this.plotHeight + J[2] + 1;
      J = this.plotLeft + this.plotWidth + J[1] + 1;
      var y = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
          t = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
      A = this.scrollablePixelsX ? ["M", 0, A, "L", this.plotLeft - 1, A, "L", this.plotLeft - 1, g, "L", 0, g, "Z", "M", y, A, "L", this.chartWidth, A, "L", this.chartWidth, g, "L", y, g, "Z"] : this.scrollablePixelsY ? ["M", G, 0, "L", G, this.plotTop - 1, "L", J, this.plotTop - 1, "L", J, 0, "Z", "M", G, t, "L", G, this.chartHeight, "L", J, this.chartHeight, "L", J, t, "Z"] : ["M", 0, 0];
      "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({
        d: A
      });
    };
  });
  S(r, "mixins/legend-symbol.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.merge,
        u = g.pick;
    d.LegendSymbolMixin = {
      drawRectangle: function (d, g) {
        var r = d.symbolHeight,
            A = d.options.squareSymbol;
        g.legendSymbol = this.chart.renderer.rect(A ? (d.symbolWidth - r) / 2 : 0, d.baseline - r + 1, A ? r : d.symbolWidth, r, u(d.options.symbolRadius, r / 2)).addClass("highcharts-point").attr({
          zIndex: 3
        }).add(g.legendGroup);
      },
      drawLineMarker: function (d) {
        var g = this.options,
            E = g.marker,
            A = d.symbolWidth,
            G = d.symbolHeight,
            J = G / 2,
            y = this.chart.renderer,
            t = this.legendGroup;
        d = d.baseline - Math.round(.3 * d.fontMetrics.b);
        var D = {};
        this.chart.styledMode || (D = {
          "stroke-width": g.lineWidth || 0
        }, g.dashStyle && (D.dashstyle = g.dashStyle));
        this.legendLine = y.path(["M", 0, d, "L", A, d]).addClass("highcharts-graph").attr(D).add(t);
        E && !1 !== E.enabled && A && (g = Math.min(u(E.radius, J), J), 0 === this.symbol.indexOf("url") && (E = r(E, {
          width: G,
          height: G
        }), g = 0), this.legendSymbol = E = y.symbol(this.symbol, A / 2 - g, d - g, 2 * g, 2 * g, E).addClass("highcharts-point").add(t), E.isMarker = !0);
      }
    };
    return d.LegendSymbolMixin;
  });
  S(r, "parts/Point.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    "";

    var r = g.animObject,
        u = g.defined,
        I = g.erase,
        M = g.extend,
        E = g.format,
        A = g.getNestedProperty,
        G = g.isArray,
        J = g.isNumber,
        y = g.isObject,
        t = g.syncTimeout,
        D = g.pick,
        h = g.removeEvent,
        N = g.uniqueKey,
        q = d.fireEvent;

    g = function () {
      function d() {
        this.colorIndex = this.category = void 0;
        this.formatPrefix = "point";
        this.id = void 0;
        this.isNull = !1;
        this.percentage = this.options = this.name = void 0;
        this.selected = !1;
        this.total = this.series = void 0;
        this.visible = !0;
        this.x = void 0;
      }

      d.prototype.animateBeforeDestroy = function () {
        var e = this,
            c = {
          x: e.startXPos,
          opacity: 0
        },
            d,
            h = e.getGraphicalProps();
        h.singular.forEach(function (f) {
          d = "dataLabel" === f;
          e[f] = e[f].animate(d ? {
            x: e[f].startXPos,
            y: e[f].startYPos,
            opacity: 0
          } : c);
        });
        h.plural.forEach(function (c) {
          e[c].forEach(function (a) {
            a.element && a.animate(M({
              x: e.startXPos
            }, a.startYPos ? {
              x: a.startXPos,
              y: a.startYPos
            } : {}));
          });
        });
      };

      d.prototype.applyOptions = function (e, c) {
        var k = this.series,
            h = k.options.pointValKey || k.pointValKey;
        e = d.prototype.optionsToObject.call(this, e);
        M(this, e);
        this.options = this.options ? M(this.options, e) : e;
        e.group && delete this.group;
        e.dataLabels && delete this.dataLabels;
        h && (this.y = d.prototype.getNestedProperty.call(this, h));
        this.formatPrefix = (this.isNull = D(this.isValid && !this.isValid(), null === this.x || !J(this.y))) ? "null" : "point";
        this.selected && (this.state = "select");
        "name" in this && "undefined" === typeof c && k.xAxis && k.xAxis.hasNames && (this.x = k.xAxis.nameToX(this));
        "undefined" === typeof this.x && k && (this.x = "undefined" === typeof c ? k.autoIncrement(this) : c);
        return this;
      };

      d.prototype.destroy = function () {
        function e() {
          if (c.graphic || c.dataLabel || c.dataLabels) h(c), c.destroyElements();

          for (l in c) c[l] = null;
        }

        var c = this,
            d = c.series,
            n = d.chart;
        d = d.options.dataSorting;
        var f = n.hoverPoints,
            a = r(c.series.chart.renderer.globalAnimation),
            l;
        c.legendItem && n.legend.destroyItem(c);
        f && (c.setState(), I(f, c), f.length || (n.hoverPoints = null));
        if (c === n.hoverPoint) c.onMouseOut();
        d && d.enabled ? (this.animateBeforeDestroy(), t(e, a.duration)) : e();
        n.pointCount--;
      };

      d.prototype.destroyElements = function (e) {
        var c = this;
        e = c.getGraphicalProps(e);
        e.singular.forEach(function (e) {
          c[e] = c[e].destroy();
        });
        e.plural.forEach(function (e) {
          c[e].forEach(function (c) {
            c.element && c.destroy();
          });
          delete c[e];
        });
      };

      d.prototype.firePointEvent = function (e, c, d) {
        var k = this,
            f = this.series.options;
        (f.point.events[e] || k.options && k.options.events && k.options.events[e]) && k.importEvents();
        "click" === e && f.allowPointSelect && (d = function (a) {
          k.select && k.select(null, a.ctrlKey || a.metaKey || a.shiftKey);
        });
        q(k, e, c, d);
      };

      d.prototype.getClassName = function () {
        return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
      };

      d.prototype.getGraphicalProps = function (e) {
        var c = this,
            d = [],
            h,
            f = {
          singular: [],
          plural: []
        };
        e = e || {
          graphic: 1,
          dataLabel: 1
        };
        e.graphic && d.push("graphic", "shadowGroup");
        e.dataLabel && d.push("dataLabel", "dataLabelUpper", "connector");

        for (h = d.length; h--;) {
          var a = d[h];
          c[a] && f.singular.push(a);
        }

        ["dataLabel", "connector"].forEach(function (a) {
          var d = a + "s";
          e[a] && c[d] && f.plural.push(d);
        });
        return f;
      };

      d.prototype.getLabelConfig = function () {
        return {
          x: this.category,
          y: this.y,
          color: this.color,
          colorIndex: this.colorIndex,
          key: this.name || this.category,
          series: this.series,
          point: this,
          percentage: this.percentage,
          total: this.total || this.stackTotal
        };
      };

      d.prototype.getNestedProperty = function (e) {
        if (e) return 0 === e.indexOf("custom.") ? A(e, this.options) : this[e];
      };

      d.prototype.getZone = function () {
        var e = this.series,
            c = e.zones;
        e = e.zoneAxis || "y";
        var d = 0,
            h;

        for (h = c[d]; this[e] >= h.value;) h = c[++d];

        this.nonZonedColor || (this.nonZonedColor = this.color);
        this.color = h && h.color && !this.options.color ? h.color : this.nonZonedColor;
        return h;
      };

      d.prototype.hasNewShapeType = function () {
        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
      };

      d.prototype.init = function (e, c, d) {
        this.series = e;
        this.applyOptions(c, d);
        this.id = u(this.id) ? this.id : N();
        this.resolveColor();
        e.chart.pointCount++;
        q(this, "afterInit");
        return this;
      };

      d.prototype.optionsToObject = function (e) {
        var c = {},
            k = this.series,
            h = k.options.keys,
            f = h || k.pointArrayMap || ["y"],
            a = f.length,
            l = 0,
            g = 0;
        if (J(e) || null === e) c[f[0]] = e;else if (G(e)) for (!h && e.length > a && (k = typeof e[0], "string" === k ? c.name = e[0] : "number" === k && (c.x = e[0]), l++); g < a;) h && "undefined" === typeof e[l] || (0 < f[g].indexOf(".") ? d.prototype.setNestedProperty(c, e[l], f[g]) : c[f[g]] = e[l]), l++, g++;else "object" === typeof e && (c = e, e.dataLabels && (k._hasPointLabels = !0), e.marker && (k._hasPointMarkers = !0));
        return c;
      };

      d.prototype.resolveColor = function () {
        var e = this.series;
        var c = e.chart.options.chart.colorCount;
        var d = e.chart.styledMode;
        d || this.options.color || (this.color = e.color);
        e.options.colorByPoint ? (d || (c = e.options.colors || e.chart.options.colors, this.color = this.color || c[e.colorCounter], c = c.length), d = e.colorCounter, e.colorCounter++, e.colorCounter === c && (e.colorCounter = 0)) : d = e.colorIndex;
        this.colorIndex = D(this.colorIndex, d);
      };

      d.prototype.setNestedProperty = function (e, c, d) {
        d.split(".").reduce(function (e, f, a, d) {
          e[f] = d.length - 1 === a ? c : y(e[f], !0) ? e[f] : {};
          return e[f];
        }, e);
        return e;
      };

      d.prototype.tooltipFormatter = function (e) {
        var c = this.series,
            d = c.tooltipOptions,
            h = D(d.valueDecimals, ""),
            f = d.valuePrefix || "",
            a = d.valueSuffix || "";
        c.chart.styledMode && (e = c.chart.tooltip.styledModeFormat(e));
        (c.pointArrayMap || ["y"]).forEach(function (c) {
          c = "{point." + c;
          if (f || a) e = e.replace(RegExp(c + "}", "g"), f + c + "}" + a);
          e = e.replace(RegExp(c + "}", "g"), c + ":,." + h + "f}");
        });
        return E(e, {
          point: this,
          series: this.series
        }, c.chart);
      };

      return d;
    }();

    d.Point = g;
    return d.Point;
  });
  S(r, "parts/Series.js", [r["parts/Globals.js"], r["mixins/legend-symbol.js"], r["parts/Point.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    "";

    var I = u.addEvent,
        M = u.animObject,
        E = u.arrayMax,
        A = u.arrayMin,
        G = u.clamp,
        J = u.correctFloat,
        y = u.defined,
        t = u.erase,
        D = u.error,
        h = u.extend,
        N = u.find,
        q = u.fireEvent,
        P = u.getNestedProperty,
        e = u.isArray,
        c = u.isFunction,
        k = u.isNumber,
        n = u.isString,
        f = u.merge,
        a = u.objectEach,
        l = u.pick,
        v = u.removeEvent,
        z = u.seriesType,
        w = u.splat,
        B = u.syncTimeout,
        L = d.defaultOptions,
        Q = d.defaultPlotOptions,
        H = d.seriesTypes,
        K = d.SVGElement,
        p = d.win;
    d.Series = z("line", null, {
      lineWidth: 2,
      allowPointSelect: !1,
      showCheckbox: !1,
      animation: {
        duration: 1E3
      },
      events: {},
      marker: {
        enabledThreshold: 2,
        lineColor: "#ffffff",
        lineWidth: 0,
        radius: 4,
        states: {
          normal: {
            animation: !0
          },
          hover: {
            animation: {
              duration: 50
            },
            enabled: !0,
            radiusPlus: 2,
            lineWidthPlus: 1
          },
          select: {
            fillColor: "#cccccc",
            lineColor: "#000000",
            lineWidth: 2
          }
        }
      },
      point: {
        events: {}
      },
      dataLabels: {
        align: "center",
        formatter: function () {
          var b = this.series.chart.numberFormatter;
          return "number" !== typeof this.y ? "" : b(this.y, -1);
        },
        padding: 5,
        style: {
          fontSize: "11px",
          fontWeight: "bold",
          color: "contrast",
          textOutline: "1px contrast"
        },
        verticalAlign: "bottom",
        x: 0,
        y: 0
      },
      cropThreshold: 300,
      opacity: 1,
      pointRange: 0,
      softThreshold: !0,
      states: {
        normal: {
          animation: !0
        },
        hover: {
          animation: {
            duration: 50
          },
          lineWidthPlus: 1,
          marker: {},
          halo: {
            size: 10,
            opacity: .25
          }
        },
        select: {
          animation: {
            duration: 0
          }
        },
        inactive: {
          animation: {
            duration: 50
          },
          opacity: .2
        }
      },
      stickyTracking: !0,
      turboThreshold: 1E3,
      findNearestPointBy: "x"
    }, {
      axisTypes: ["xAxis", "yAxis"],
      coll: "series",
      colorCounter: 0,
      cropShoulder: 1,
      directTouch: !1,
      eventsToUnbind: [],
      isCartesian: !0,
      parallelArrays: ["x", "y"],
      pointClass: r,
      requireSorting: !0,
      sorted: !0,
      init: function (b, e) {
        q(this, "init", {
          options: e
        });
        var f = this,
            d = b.series,
            k;
        this.eventOptions = this.eventOptions || {};
        f.chart = b;
        f.options = e = f.setOptions(e);
        f.linkedSeries = [];
        f.bindAxes();
        h(f, {
          name: e.name,
          state: "",
          visible: !1 !== e.visible,
          selected: !0 === e.selected
        });
        var p = e.events;
        a(p, function (b, a) {
          c(b) && f.eventOptions[a] !== b && (c(f.eventOptions[a]) && v(f, a, f.eventOptions[a]), f.eventOptions[a] = b, I(f, a, b));
        });
        if (p && p.click || e.point && e.point.events && e.point.events.click || e.allowPointSelect) b.runTrackerClick = !0;
        f.getColor();
        f.getSymbol();
        f.parallelArrays.forEach(function (b) {
          f[b + "Data"] || (f[b + "Data"] = []);
        });
        f.isCartesian && (b.hasCartesianSeries = !0);
        d.length && (k = d[d.length - 1]);
        f._i = l(k && k._i, -1) + 1;
        b.orderSeries(this.insert(d));
        e.dataSorting && e.dataSorting.enabled ? f.setDataSortingOptions() : f.points || f.data || f.setData(e.data, !1);
        q(this, "afterInit");
      },
      is: function (b) {
        return H[b] && this instanceof H[b];
      },
      insert: function (b) {
        var a = this.options.index,
            c;

        if (k(a)) {
          for (c = b.length; c--;) if (a >= l(b[c].options.index, b[c]._i)) {
            b.splice(c + 1, 0, this);
            break;
          }

          -1 === c && b.unshift(this);
          c += 1;
        } else b.push(this);

        return l(c, b.length - 1);
      },
      bindAxes: function () {
        var b = this,
            a = b.options,
            c = b.chart,
            e;
        q(this, "bindAxes", null, function () {
          (b.axisTypes || []).forEach(function (f) {
            c[f].forEach(function (c) {
              e = c.options;
              if (a[f] === e.index || "undefined" !== typeof a[f] && a[f] === e.id || "undefined" === typeof a[f] && 0 === e.index) b.insert(c.series), b[f] = c, c.isDirty = !0;
            });
            b[f] || b.optionalAxis === f || D(18, !0, c);
          });
        });
        q(this, "afterBindAxes");
      },
      updateParallelArrays: function (b, a) {
        var c = b.series,
            e = arguments,
            f = k(a) ? function (e) {
          var f = "y" === e && c.toYData ? c.toYData(b) : b[e];
          c[e + "Data"][a] = f;
        } : function (b) {
          Array.prototype[a].apply(c[b + "Data"], Array.prototype.slice.call(e, 2));
        };
        c.parallelArrays.forEach(f);
      },
      hasData: function () {
        return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
      },
      autoIncrement: function () {
        var b = this.options,
            a = this.xIncrement,
            c,
            e = b.pointIntervalUnit,
            f = this.chart.time;
        a = l(a, b.pointStart, 0);
        this.pointInterval = c = l(this.pointInterval, b.pointInterval, 1);
        e && (b = new f.Date(a), "day" === e ? f.set("Date", b, f.get("Date", b) + c) : "month" === e ? f.set("Month", b, f.get("Month", b) + c) : "year" === e && f.set("FullYear", b, f.get("FullYear", b) + c), c = b.getTime() - a);
        this.xIncrement = a + c;
        return a;
      },
      setDataSortingOptions: function () {
        var b = this.options;
        h(this, {
          requireSorting: !1,
          sorted: !1,
          enabledDataSorting: !0,
          allowDG: !1
        });
        y(b.pointRange) || (b.pointRange = 1);
      },
      setOptions: function (b) {
        var a = this.chart,
            c = a.options,
            e = c.plotOptions,
            d = a.userOptions || {};
        b = f(b);
        a = a.styledMode;
        var k = {
          plotOptions: e,
          userOptions: b
        };
        q(this, "setOptions", k);
        var h = k.plotOptions[this.type],
            m = d.plotOptions || {};
        this.userOptions = k.userOptions;
        d = f(h, e.series, d.plotOptions && d.plotOptions[this.type], b);
        this.tooltipOptions = f(L.tooltip, L.plotOptions.series && L.plotOptions.series.tooltip, L.plotOptions[this.type].tooltip, c.tooltip.userOptions, e.series && e.series.tooltip, e[this.type].tooltip, b.tooltip);
        this.stickyTracking = l(b.stickyTracking, m[this.type] && m[this.type].stickyTracking, m.series && m.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : d.stickyTracking);
        null === h.marker && delete d.marker;
        this.zoneAxis = d.zoneAxis;
        c = this.zones = (d.zones || []).slice();
        !d.negativeColor && !d.negativeFillColor || d.zones || (e = {
          value: d[this.zoneAxis + "Threshold"] || d.threshold || 0,
          className: "highcharts-negative"
        }, a || (e.color = d.negativeColor, e.fillColor = d.negativeFillColor), c.push(e));
        c.length && y(c[c.length - 1].value) && c.push(a ? {} : {
          color: this.color,
          fillColor: this.fillColor
        });
        q(this, "afterSetOptions", {
          options: d
        });
        return d;
      },
      getName: function () {
        return l(this.options.name, "Series " + (this.index + 1));
      },
      getCyclic: function (b, a, c) {
        var e = this.chart,
            f = this.userOptions,
            d = b + "Index",
            k = b + "Counter",
            h = c ? c.length : l(e.options.chart[b + "Count"], e[b + "Count"]);

        if (!a) {
          var p = l(f[d], f["_" + d]);
          y(p) || (e.series.length || (e[k] = 0), f["_" + d] = p = e[k] % h, e[k] += 1);
          c && (a = c[p]);
        }

        "undefined" !== typeof p && (this[d] = p);
        this[b] = a;
      },
      getColor: function () {
        this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.options.color = null : this.getCyclic("color", this.options.color || Q[this.type].color, this.chart.options.colors);
      },
      getPointsCollection: function () {
        return (this.hasGroupedData ? this.points : this.data) || [];
      },
      getSymbol: function () {
        this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
      },
      findPointIndex: function (b, a) {
        var c = b.id,
            e = b.x,
            f = this.points,
            d,
            h = this.options.dataSorting;
        if (c) var l = this.chart.get(c);else if (this.linkedParent || this.enabledDataSorting) {
          var p = h && h.matchByName ? "name" : "index";
          l = N(f, function (a) {
            return !a.touched && a[p] === b[p];
          });
          if (!l) return;
        }

        if (l) {
          var n = l && l.index;
          "undefined" !== typeof n && (d = !0);
        }

        "undefined" === typeof n && k(e) && (n = this.xData.indexOf(e, a));
        -1 !== n && "undefined" !== typeof n && this.cropped && (n = n >= this.cropStart ? n - this.cropStart : n);
        !d && f[n] && f[n].touched && (n = void 0);
        return n;
      },
      drawLegendSymbol: g.drawLineMarker,
      updateData: function (b, a) {
        var c = this.options,
            e = c.dataSorting,
            f = this.points,
            d = [],
            h,
            l,
            n,
            p = this.requireSorting,
            g = b.length === f.length,
            w = !0;
        this.xIncrement = null;
        b.forEach(function (b, a) {
          var l = y(b) && this.pointClass.prototype.optionsToObject.call({
            series: this
          }, b) || {};
          var m = l.x;

          if (l.id || k(m)) {
            if (m = this.findPointIndex(l, n), -1 === m || "undefined" === typeof m ? d.push(b) : f[m] && b !== c.data[m] ? (f[m].update(b, !1, null, !1), f[m].touched = !0, p && (n = m + 1)) : f[m] && (f[m].touched = !0), !g || a !== m || e && e.enabled || this.hasDerivedData) h = !0;
          } else d.push(b);
        }, this);
        if (h) for (b = f.length; b--;) (l = f[b]) && !l.touched && l.remove && l.remove(!1, a);else !g || e && e.enabled ? w = !1 : (b.forEach(function (b, a) {
          f[a].update && b !== f[a].y && f[a].update(b, !1, null, !1);
        }), d.length = 0);
        f.forEach(function (b) {
          b && (b.touched = !1);
        });
        if (!w) return !1;
        d.forEach(function (b) {
          this.addPoint(b, !1, null, null, !1);
        }, this);
        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = E(this.xData), this.autoIncrement());
        return !0;
      },
      setData: function (b, a, c, f) {
        var d = this,
            h = d.points,
            p = h && h.length || 0,
            m,
            g = d.options,
            w = d.chart,
            x = g.dataSorting,
            q = null,
            v = d.xAxis;
        q = g.turboThreshold;
        var C = this.xData,
            t = this.yData,
            B = (m = d.pointArrayMap) && m.length,
            z = g.keys,
            y = 0,
            L = 1,
            u;
        b = b || [];
        m = b.length;
        a = l(a, !0);
        x && x.enabled && (b = this.sortData(b));
        !1 !== f && m && p && !d.cropped && !d.hasGroupedData && d.visible && !d.isSeriesBoosting && (u = this.updateData(b, c));

        if (!u) {
          d.xIncrement = null;
          d.colorCounter = 0;
          this.parallelArrays.forEach(function (b) {
            d[b + "Data"].length = 0;
          });
          if (q && m > q) {
            if (q = d.getFirstValidPoint(b), k(q)) for (c = 0; c < m; c++) C[c] = this.autoIncrement(), t[c] = b[c];else if (e(q)) {
              if (B) for (c = 0; c < m; c++) f = b[c], C[c] = f[0], t[c] = f.slice(1, B + 1);else for (z && (y = z.indexOf("x"), L = z.indexOf("y"), y = 0 <= y ? y : 0, L = 0 <= L ? L : 1), c = 0; c < m; c++) f = b[c], C[c] = f[y], t[c] = f[L];
            } else D(12, !1, w);
          } else for (c = 0; c < m; c++) "undefined" !== typeof b[c] && (f = {
            series: d
          }, d.pointClass.prototype.applyOptions.apply(f, [b[c]]), d.updateParallelArrays(f, c));
          t && n(t[0]) && D(14, !0, w);
          d.data = [];
          d.options.data = d.userOptions.data = b;

          for (c = p; c--;) h[c] && h[c].destroy && h[c].destroy();

          v && (v.minRange = v.userMinRange);
          d.isDirty = w.isDirtyBox = !0;
          d.isDirtyData = !!h;
          c = !1;
        }

        "point" === g.legendType && (this.processData(), this.generatePoints());
        a && w.redraw(c);
      },
      sortData: function (b) {
        var a = this,
            c = a.options.dataSorting.sortKey || "y",
            e = function (b, a) {
          return y(a) && b.pointClass.prototype.optionsToObject.call({
            series: b
          }, a) || {};
        };

        b.forEach(function (c, f) {
          b[f] = e(a, c);
          b[f].index = f;
        }, this);
        b.concat().sort(function (b, a) {
          b = P(c, b);
          a = P(c, a);
          return a < b ? -1 : a > b ? 1 : 0;
        }).forEach(function (b, a) {
          b.x = a;
        }, this);
        a.linkedSeries && a.linkedSeries.forEach(function (a) {
          var c = a.options,
              f = c.data;
          c.dataSorting && c.dataSorting.enabled || !f || (f.forEach(function (c, d) {
            f[d] = e(a, c);
            b[d] && (f[d].x = b[d].x, f[d].index = d);
          }), a.setData(f, !1));
        });
        return b;
      },
      processData: function (b) {
        var a = this.xData,
            c = this.yData,
            e = a.length;
        var f = 0;
        var d = this.xAxis,
            k = this.options;
        var h = k.cropThreshold;
        var l = this.getExtremesFromAll || k.getExtremesFromAll,
            p = this.isCartesian;
        k = d && d.val2lin;
        var n = d && d.isLog,
            g = this.requireSorting;
        if (p && !this.isDirty && !d.isDirty && !this.yAxis.isDirty && !b) return !1;

        if (d) {
          b = d.getExtremes();
          var w = b.min;
          var q = b.max;
        }

        if (p && this.sorted && !l && (!h || e > h || this.forceCrop)) if (a[e - 1] < w || a[0] > q) a = [], c = [];else if (this.yData && (a[0] < w || a[e - 1] > q)) {
          f = this.cropData(this.xData, this.yData, w, q);
          a = f.xData;
          c = f.yData;
          f = f.start;
          var v = !0;
        }

        for (h = a.length || 1; --h;) if (e = n ? k(a[h]) - k(a[h - 1]) : a[h] - a[h - 1], 0 < e && ("undefined" === typeof t || e < t)) var t = e;else 0 > e && g && (D(15, !1, this.chart), g = !1);

        this.cropped = v;
        this.cropStart = f;
        this.processedXData = a;
        this.processedYData = c;
        this.closestPointRange = this.basePointRange = t;
      },
      cropData: function (b, a, c, e, f) {
        var d = b.length,
            k = 0,
            h = d,
            p;
        f = l(f, this.cropShoulder);

        for (p = 0; p < d; p++) if (b[p] >= c) {
          k = Math.max(0, p - f);
          break;
        }

        for (c = p; c < d; c++) if (b[c] > e) {
          h = c + f;
          break;
        }

        return {
          xData: b.slice(k, h),
          yData: a.slice(k, h),
          start: k,
          end: h
        };
      },
      generatePoints: function () {
        var b = this.options,
            a = b.data,
            c = this.data,
            e,
            f = this.processedXData,
            d = this.processedYData,
            k = this.pointClass,
            l = f.length,
            p = this.cropStart || 0,
            n = this.hasGroupedData;
        b = b.keys;
        var g = [],
            v;
        c || n || (c = [], c.length = a.length, c = this.data = c);
        b && n && (this.options.keys = !1);

        for (v = 0; v < l; v++) {
          var t = p + v;

          if (n) {
            var B = new k().init(this, [f[v]].concat(w(d[v])));
            B.dataGroup = this.groupMap[v];
            B.dataGroup.options && (B.options = B.dataGroup.options, h(B, B.dataGroup.options), delete B.dataLabels);
          } else (B = c[t]) || "undefined" === typeof a[t] || (c[t] = B = new k().init(this, a[t], f[v]));

          B && (B.index = t, g[v] = B);
        }

        this.options.keys = b;
        if (c && (l !== (e = c.length) || n)) for (v = 0; v < e; v++) v !== p || n || (v += l), c[v] && (c[v].destroyElements(), c[v].plotX = void 0);
        this.data = c;
        this.points = g;
        q(this, "afterGeneratePoints");
      },
      getXExtremes: function (b) {
        return {
          min: A(b),
          max: E(b)
        };
      },
      getExtremes: function (b) {
        var a = this.xAxis,
            c = this.yAxis,
            f = this.processedXData || this.xData,
            d = [],
            h = 0,
            l = 0;
        var m = 0;
        var p = this.requireSorting ? this.cropShoulder : 0,
            n = c ? c.positiveValuesOnly : !1,
            g;
        b = b || this.stackedYData || this.processedYData || [];
        c = b.length;
        a && (m = a.getExtremes(), l = m.min, m = m.max);

        for (g = 0; g < c; g++) {
          var w = f[g];
          var v = b[g];
          var t = (k(v) || e(v)) && (v.length || 0 < v || !n);
          w = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !a || (f[g + p] || w) >= l && (f[g - p] || w) <= m;
          if (t && w) if (t = v.length) for (; t--;) k(v[t]) && (d[h++] = v[t]);else d[h++] = v;
        }

        this.dataMin = A(d);
        this.dataMax = E(d);
        q(this, "afterGetExtremes");
      },
      getFirstValidPoint: function (b) {
        for (var a = null, c = b.length, e = 0; null === a && e < c;) a = b[e], e++;

        return a;
      },
      translate: function () {
        this.processedXData || this.processData();
        this.generatePoints();
        var b = this.options,
            a = b.stacking,
            c = this.xAxis,
            f = c.categories,
            d = this.enabledDataSorting,
            h = this.yAxis,
            p = this.points,
            m = p.length,
            n = !!this.modifyValue,
            g,
            w = this.pointPlacementToXValue(),
            v = !!w,
            t = b.threshold,
            B = b.startFromThreshold ? t : 0,
            z,
            L = this.zoneAxis || "y",
            u = Number.MAX_VALUE;

        for (g = 0; g < m; g++) {
          var K = p[g],
              r = K.x,
              H = K.y,
              D = K.low,
              A = a && h.stacks[(this.negStacks && H < (B ? 0 : t) ? "-" : "") + this.stackKey];
          h.positiveValuesOnly && null !== H && 0 >= H && (K.isNull = !0);
          K.plotX = z = J(G(c.translate(r, 0, 0, 0, 1, w, "flags" === this.type), -1E5, 1E5));

          if (a && this.visible && A && A[r]) {
            var N = this.getStackIndicator(N, r, this.index);

            if (!K.isNull) {
              var Q = A[r];
              var E = Q.points[N.key];
            }
          }

          e(E) && (D = E[0], H = E[1], D === B && N.key === A[r].base && (D = l(k(t) && t, h.min)), h.positiveValuesOnly && 0 >= D && (D = null), K.total = K.stackTotal = Q.total, K.percentage = Q.total && K.y / Q.total * 100, K.stackY = H, this.irregularWidths || Q.setOffset(this.pointXOffset || 0, this.barW || 0));
          K.yBottom = y(D) ? G(h.translate(D, 0, 1, 0, 1), -1E5, 1E5) : null;
          n && (H = this.modifyValue(H, K));
          K.plotY = "number" === typeof H && Infinity !== H ? G(h.translate(H, 0, 1, 0, 1), -1E5, 1E5) : void 0;
          K.isInside = this.isPointInside(K);
          K.clientX = v ? J(c.translate(r, 0, 0, 0, 1, w)) : z;
          K.negative = K[L] < (b[L + "Threshold"] || t || 0);
          K.category = f && "undefined" !== typeof f[K.x] ? f[K.x] : K.x;

          if (!K.isNull && !1 !== K.visible) {
            "undefined" !== typeof P && (u = Math.min(u, Math.abs(z - P)));
            var P = z;
          }

          K.zone = this.zones.length && K.getZone();
          !K.graphic && this.group && d && (K.isNew = !0);
        }

        this.closestPointRangePx = u;
        q(this, "afterTranslate");
      },
      getValidPoints: function (b, a, c) {
        var e = this.chart;
        return (b || this.points || []).filter(function (b) {
          return a && !e.isInsidePlot(b.plotX, b.plotY, e.inverted) ? !1 : !1 !== b.visible && (c || !b.isNull);
        });
      },
      getClipBox: function (b, a) {
        var c = this.options,
            e = this.chart,
            f = e.inverted,
            d = this.xAxis,
            k = d && this.yAxis;
        b && !1 === c.clip && k ? b = f ? {
          y: -e.chartWidth + k.len + k.pos,
          height: e.chartWidth,
          width: e.chartHeight,
          x: -e.chartHeight + d.len + d.pos
        } : {
          y: -k.pos,
          height: e.chartHeight,
          width: e.chartWidth,
          x: -d.pos
        } : (b = this.clipBox || e.clipBox, a && (b.width = e.plotSizeX, b.x = 0));
        return a ? {
          width: b.width,
          x: b.x
        } : b;
      },
      setClip: function (b) {
        var a = this.chart,
            c = this.options,
            e = a.renderer,
            f = a.inverted,
            d = this.clipBox,
            k = this.getClipBox(b),
            h = this.sharedClipKey || ["_sharedClip", b && b.duration, b && b.easing, k.height, c.xAxis, c.yAxis].join(),
            l = a[h],
            p = a[h + "m"];
        b && (k.width = 0, f && (k.x = a.plotHeight + (!1 !== c.clip ? 0 : a.plotTop)));
        l ? a.hasLoaded || l.attr(k) : (b && (a[h + "m"] = p = e.clipRect(f ? a.plotSizeX + 99 : -99, f ? -a.plotLeft : -a.plotTop, 99, f ? a.chartWidth : a.chartHeight)), a[h] = l = e.clipRect(k), l.count = {
          length: 0
        });
        b && !l.count[this.index] && (l.count[this.index] = !0, l.count.length += 1);
        if (!1 !== c.clip || b) this.group.clip(b || d ? l : a.clipRect), this.markerGroup.clip(p), this.sharedClipKey = h;
        b || (l.count[this.index] && (delete l.count[this.index], --l.count.length), 0 === l.count.length && h && a[h] && (d || (a[h] = a[h].destroy()), a[h + "m"] && (a[h + "m"] = a[h + "m"].destroy())));
      },
      animate: function (b) {
        var a = this.chart,
            c = M(this.options.animation);
        if (!a.hasRendered) if (b) this.setClip(c);else {
          var e = this.sharedClipKey;
          b = a[e];
          var f = this.getClipBox(c, !0);
          b && b.animate(f, c);
          a[e + "m"] && a[e + "m"].animate({
            width: f.width + 99,
            x: f.x - (a.inverted ? 0 : 99)
          }, c);
        }
      },
      afterAnimate: function () {
        this.setClip();
        q(this, "afterAnimate");
        this.finishedAnimating = !0;
      },
      drawPoints: function () {
        var b = this.points,
            a = this.chart,
            c,
            e,
            f = this.options.marker,
            d = this[this.specialGroup] || this.markerGroup,
            k = this.xAxis,
            h = l(f.enabled, !k || k.isRadial ? !0 : null, this.closestPointRangePx >= f.enabledThreshold * f.radius);
        if (!1 !== f.enabled || this._hasPointMarkers) for (c = 0; c < b.length; c++) {
          var p = b[c];
          var n = (e = p.graphic) ? "animate" : "attr";
          var g = p.marker || {};
          var w = !!p.marker;

          if ((h && "undefined" === typeof g.enabled || g.enabled) && !p.isNull && !1 !== p.visible) {
            var v = l(g.symbol, this.symbol);
            var q = this.markerAttribs(p, p.selected && "select");
            this.enabledDataSorting && (p.startXPos = k.reversed ? -q.width : k.width);
            var t = !1 !== p.isInside;
            e ? e[t ? "show" : "hide"](t).animate(q) : t && (0 < q.width || p.hasImage) && (p.graphic = e = a.renderer.symbol(v, q.x, q.y, q.width, q.height, w ? g : f).add(d), this.enabledDataSorting && a.hasRendered && (e.attr({
              x: p.startXPos
            }), n = "animate"));
            e && "animate" === n && e[t ? "show" : "hide"](t).animate(q);
            if (e && !a.styledMode) e[n](this.pointAttribs(p, p.selected && "select"));
            e && e.addClass(p.getClassName(), !0);
          } else e && (p.graphic = e.destroy());
        }
      },
      markerAttribs: function (b, a) {
        var c = this.options.marker,
            e = b.marker || {},
            f = e.symbol || c.symbol,
            d = l(e.radius, c.radius);
        a && (c = c.states[a], a = e.states && e.states[a], d = l(a && a.radius, c && c.radius, d + (c && c.radiusPlus || 0)));
        b.hasImage = f && 0 === f.indexOf("url");
        b.hasImage && (d = 0);
        b = {
          x: Math.floor(b.plotX) - d,
          y: b.plotY - d
        };
        d && (b.width = b.height = 2 * d);
        return b;
      },
      pointAttribs: function (b, a) {
        var c = this.options.marker,
            e = b && b.options,
            f = e && e.marker || {},
            d = this.color,
            k = e && e.color,
            h = b && b.color;
        e = l(f.lineWidth, c.lineWidth);
        var p = b && b.zone && b.zone.color;
        b = 1;
        d = k || p || h || d;
        k = f.fillColor || c.fillColor || d;
        d = f.lineColor || c.lineColor || d;
        a = a || "normal";
        c = c.states[a];
        a = f.states && f.states[a] || {};
        e = l(a.lineWidth, c.lineWidth, e + l(a.lineWidthPlus, c.lineWidthPlus, 0));
        k = a.fillColor || c.fillColor || k;
        d = a.lineColor || c.lineColor || d;
        b = l(a.opacity, c.opacity, b);
        return {
          stroke: d,
          "stroke-width": e,
          fill: k,
          opacity: b
        };
      },
      destroy: function (b) {
        var c = this,
            e = c.chart,
            f = /AppleWebKit\/533/.test(p.navigator.userAgent),
            d,
            k,
            h = c.data || [],
            l,
            n;
        q(c, "destroy");
        this.removeEvents(b);
        (c.axisTypes || []).forEach(function (b) {
          (n = c[b]) && n.series && (t(n.series, c), n.isDirty = n.forceRedraw = !0);
        });
        c.legendItem && c.chart.legend.destroyItem(c);

        for (k = h.length; k--;) (l = h[k]) && l.destroy && l.destroy();

        c.points = null;
        u.clearTimeout(c.animationTimeout);
        a(c, function (b, a) {
          b instanceof K && !b.survive && (d = f && "group" === a ? "hide" : "destroy", b[d]());
        });
        e.hoverSeries === c && (e.hoverSeries = null);
        t(e.series, c);
        e.orderSeries();
        a(c, function (a, e) {
          b && "hcEvents" === e || delete c[e];
        });
      },
      getGraphPath: function (b, a, c) {
        var e = this,
            f = e.options,
            d = f.step,
            k,
            h = [],
            l = [],
            p;
        b = b || e.points;
        (k = b.reversed) && b.reverse();
        (d = {
          right: 1,
          center: 2
        }[d] || d && 3) && k && (d = 4 - d);
        b = this.getValidPoints(b, !1, !(f.connectNulls && !a && !c));
        b.forEach(function (k, n) {
          var m = k.plotX,
              g = k.plotY,
              w = b[n - 1];
          (k.leftCliff || w && w.rightCliff) && !c && (p = !0);
          k.isNull && !y(a) && 0 < n ? p = !f.connectNulls : k.isNull && !a ? p = !0 : (0 === n || p ? n = ["M", k.plotX, k.plotY] : e.getPointSpline ? n = e.getPointSpline(b, k, n) : d ? (n = 1 === d ? ["L", w.plotX, g] : 2 === d ? ["L", (w.plotX + m) / 2, w.plotY, "L", (w.plotX + m) / 2, g] : ["L", m, w.plotY], n.push("L", m, g)) : n = ["L", m, g], l.push(k.x), d && (l.push(k.x), 2 === d && l.push(k.x)), h.push.apply(h, n), p = !1);
        });
        h.xMap = l;
        return e.graphPath = h;
      },
      drawGraph: function () {
        var b = this,
            a = this.options,
            c = (this.gappedPath || this.getGraphPath).call(this),
            e = this.chart.styledMode,
            f = [["graph", "highcharts-graph"]];
        e || f[0].push(a.lineColor || this.color || "#cccccc", a.dashStyle);
        f = b.getZonesGraphs(f);
        f.forEach(function (f, d) {
          var k = f[0],
              h = b[k],
              l = h ? "animate" : "attr";
          h ? (h.endX = b.preventGraphAnimation ? null : c.xMap, h.animate({
            d: c
          })) : c.length && (b[k] = h = b.chart.renderer.path(c).addClass(f[1]).attr({
            zIndex: 1
          }).add(b.group));
          h && !e && (k = {
            stroke: f[2],
            "stroke-width": a.lineWidth,
            fill: b.fillGraph && b.color || "none"
          }, f[3] ? k.dashstyle = f[3] : "square" !== a.linecap && (k["stroke-linecap"] = k["stroke-linejoin"] = "round"), h[l](k).shadow(2 > d && a.shadow));
          h && (h.startX = c.xMap, h.isArea = c.isArea);
        });
      },
      getZonesGraphs: function (a) {
        this.zones.forEach(function (b, c) {
          c = ["zone-graph-" + c, "highcharts-graph highcharts-zone-graph-" + c + " " + (b.className || "")];
          this.chart.styledMode || c.push(b.color || this.color, b.dashStyle || this.options.dashStyle);
          a.push(c);
        }, this);
        return a;
      },
      applyZones: function () {
        var a = this,
            c = this.chart,
            e = c.renderer,
            f = this.zones,
            d,
            k,
            h = this.clips || [],
            p,
            n = this.graph,
            g = this.area,
            w = Math.max(c.chartWidth, c.chartHeight),
            v = this[(this.zoneAxis || "y") + "Axis"],
            q = c.inverted,
            t,
            B,
            z,
            y = !1;

        if (f.length && (n || g) && v && "undefined" !== typeof v.min) {
          var K = v.reversed;
          var L = v.horiz;
          n && !this.showLine && n.hide();
          g && g.hide();
          var u = v.getExtremes();
          f.forEach(function (b, f) {
            d = K ? L ? c.plotWidth : 0 : L ? 0 : v.toPixels(u.min) || 0;
            d = G(l(k, d), 0, w);
            k = G(Math.round(v.toPixels(l(b.value, u.max), !0) || 0), 0, w);
            y && (d = k = v.toPixels(u.max));
            t = Math.abs(d - k);
            B = Math.min(d, k);
            z = Math.max(d, k);
            v.isXAxis ? (p = {
              x: q ? z : B,
              y: 0,
              width: t,
              height: w
            }, L || (p.x = c.plotHeight - p.x)) : (p = {
              x: 0,
              y: q ? z : B,
              width: w,
              height: t
            }, L && (p.y = c.plotWidth - p.y));
            q && e.isVML && (p = v.isXAxis ? {
              x: 0,
              y: K ? B : z,
              height: p.width,
              width: c.chartWidth
            } : {
              x: p.y - c.plotLeft - c.spacingBox.x,
              y: 0,
              width: p.height,
              height: c.chartHeight
            });
            h[f] ? h[f].animate(p) : h[f] = e.clipRect(p);
            n && a["zone-graph-" + f].clip(h[f]);
            g && a["zone-area-" + f].clip(h[f]);
            y = b.value > u.max;
            a.resetZones && 0 === k && (k = void 0);
          });
          this.clips = h;
        } else a.visible && (n && n.show(!0), g && g.show(!0));
      },
      invertGroups: function (a) {
        function b() {
          ["group", "markerGroup"].forEach(function (b) {
            c[b] && (e.renderer.isVML && c[b].attr({
              width: c.yAxis.len,
              height: c.xAxis.len
            }), c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(c.isRadialSeries ? !1 : a));
          });
        }

        var c = this,
            e = c.chart;
        c.xAxis && (c.eventsToUnbind.push(I(e, "resize", b)), b(), c.invertGroups = b);
      },
      plotGroup: function (a, c, e, f, d) {
        var b = this[a],
            k = !b;
        k && (this[a] = b = this.chart.renderer.g().attr({
          zIndex: f || .1
        }).add(d));
        b.addClass("highcharts-" + c + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (y(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (b.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
        b.attr({
          visibility: e
        })[k ? "attr" : "animate"](this.getPlotBox());
        return b;
      },
      getPlotBox: function () {
        var a = this.chart,
            c = this.xAxis,
            e = this.yAxis;
        a.inverted && (c = e, e = this.xAxis);
        return {
          translateX: c ? c.left : a.plotLeft,
          translateY: e ? e.top : a.plotTop,
          scaleX: 1,
          scaleY: 1
        };
      },
      removeEvents: function (a) {
        a ? this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (a) {
          a();
        }), this.eventsToUnbind.length = 0) : v(this);
      },
      render: function () {
        var a = this,
            c = a.chart,
            e = a.options,
            f = !a.finishedAnimating && c.renderer.isSVG && M(e.animation).duration,
            d = a.visible ? "inherit" : "hidden",
            k = e.zIndex,
            h = a.hasRendered,
            l = c.seriesGroup,
            p = c.inverted;
        q(this, "render");
        var n = a.plotGroup("group", "series", d, k, l);
        a.markerGroup = a.plotGroup("markerGroup", "markers", d, k, l);
        f && a.animate && a.animate(!0);
        n.inverted = a.isCartesian || a.invertable ? p : !1;
        a.drawGraph && (a.drawGraph(), a.applyZones());
        a.visible && a.drawPoints();
        a.drawDataLabels && a.drawDataLabels();
        a.redrawPoints && a.redrawPoints();
        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();
        a.invertGroups(p);
        !1 === e.clip || a.sharedClipKey || h || n.clip(c.clipRect);
        f && a.animate && a.animate();
        h || (a.animationTimeout = B(function () {
          a.afterAnimate();
        }, f || 0));
        a.isDirty = !1;
        a.hasRendered = !0;
        q(a, "afterRender");
      },
      redraw: function () {
        var a = this.chart,
            c = this.isDirty || this.isDirtyData,
            e = this.group,
            f = this.xAxis,
            d = this.yAxis;
        e && (a.inverted && e.attr({
          width: a.plotWidth,
          height: a.plotHeight
        }), e.animate({
          translateX: l(f && f.left, a.plotLeft),
          translateY: l(d && d.top, a.plotTop)
        }));
        this.translate();
        this.render();
        c && delete this.kdTree;
      },
      kdAxisArray: ["clientX", "plotY"],
      searchPoint: function (a, c) {
        var b = this.xAxis,
            e = this.yAxis,
            f = this.chart.inverted;
        return this.searchKDTree({
          clientX: f ? b.len - a.chartY + b.pos : a.chartX - b.pos,
          plotY: f ? e.len - a.chartX + e.pos : a.chartY - e.pos
        }, c, a);
      },
      buildKDTree: function (a) {
        function b(a, e, f) {
          var d;

          if (d = a && a.length) {
            var k = c.kdAxisArray[e % f];
            a.sort(function (a, b) {
              return a[k] - b[k];
            });
            d = Math.floor(d / 2);
            return {
              point: a[d],
              left: b(a.slice(0, d), e + 1, f),
              right: b(a.slice(d + 1), e + 1, f)
            };
          }
        }

        this.buildingKdTree = !0;
        var c = this,
            e = -1 < c.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        delete c.kdTree;
        B(function () {
          c.kdTree = b(c.getValidPoints(null, !c.directTouch), e, e);
          c.buildingKdTree = !1;
        }, c.options.kdNow || a && "touchstart" === a.type ? 0 : 1);
      },
      searchKDTree: function (a, c, e) {
        function b(a, c, e, l) {
          var p = c.point,
              n = f.kdAxisArray[e % l],
              g = p;
          var m = y(a[d]) && y(p[d]) ? Math.pow(a[d] - p[d], 2) : null;
          var w = y(a[k]) && y(p[k]) ? Math.pow(a[k] - p[k], 2) : null;
          w = (m || 0) + (w || 0);
          p.dist = y(w) ? Math.sqrt(w) : Number.MAX_VALUE;
          p.distX = y(m) ? Math.sqrt(m) : Number.MAX_VALUE;
          n = a[n] - p[n];
          w = 0 > n ? "left" : "right";
          m = 0 > n ? "right" : "left";
          c[w] && (w = b(a, c[w], e + 1, l), g = w[h] < g[h] ? w : p);
          c[m] && Math.sqrt(n * n) < g[h] && (a = b(a, c[m], e + 1, l), g = a[h] < g[h] ? a : g);
          return g;
        }

        var f = this,
            d = this.kdAxisArray[0],
            k = this.kdAxisArray[1],
            h = c ? "distX" : "dist";
        c = -1 < f.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        this.kdTree || this.buildingKdTree || this.buildKDTree(e);
        if (this.kdTree) return b(a, this.kdTree, c, c);
      },
      pointPlacementToXValue: function () {
        var a = this.options,
            c = a.pointRange,
            e = this.xAxis;
        a = a.pointPlacement;
        "between" === a && (a = e.reversed ? -.5 : .5);
        return k(a) ? a * l(c, e.pointRange) : 0;
      },
      isPointInside: function (a) {
        return "undefined" !== typeof a.plotY && "undefined" !== typeof a.plotX && 0 <= a.plotY && a.plotY <= this.yAxis.len && 0 <= a.plotX && a.plotX <= this.xAxis.len;
      }
    });
    "";
  });
  S(r, "parts/Stacking.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.correctFloat,
        u = g.defined,
        I = g.destroyObjectProperties,
        M = g.format,
        E = g.objectEach,
        A = g.pick;
    g = d.Axis;
    var G = d.Chart,
        J = d.Series;

    d.StackItem = function (d, g, u, h, r) {
      var q = d.chart.inverted;
      this.axis = d;
      this.isNegative = u;
      this.options = g = g || {};
      this.x = h;
      this.total = null;
      this.points = {};
      this.stack = r;
      this.rightCliff = this.leftCliff = 0;
      this.alignOptions = {
        align: g.align || (q ? u ? "left" : "right" : "center"),
        verticalAlign: g.verticalAlign || (q ? "middle" : u ? "bottom" : "top"),
        y: g.y,
        x: g.x
      };
      this.textAlign = g.textAlign || (q ? u ? "right" : "left" : "center");
    };

    d.StackItem.prototype = {
      destroy: function () {
        I(this, this.axis);
      },
      render: function (d) {
        var g = this.axis.chart,
            y = this.options,
            h = y.format;
        h = h ? M(h, this, g) : y.formatter.call(this);
        this.label ? this.label.attr({
          text: h,
          visibility: "hidden"
        }) : (this.label = g.renderer.label(h, null, null, y.shape, null, null, y.useHTML, !1, "stack-labels"), h = {
          text: h,
          rotation: y.rotation,
          padding: A(y.padding, 5),
          visibility: "hidden"
        }, this.label.attr(h), g.styledMode || this.label.css(y.style), this.label.added || this.label.add(d));
        this.label.labelrank = g.plotHeight;
      },
      setOffset: function (d, g, r, h, N) {
        var q = this.axis,
            t = q.chart;
        h = q.translate(q.usePercentage ? 100 : h ? h : this.total, 0, 0, 0, 1);
        r = q.translate(r ? r : 0);
        r = u(h) && Math.abs(h - r);
        d = A(N, t.xAxis[0].translate(this.x)) + d;
        q = u(h) && this.getStackBox(t, this, d, h, g, r, q);
        g = this.label;
        r = this.isNegative;
        d = "justify" === A(this.options.overflow, "justify");
        var e = this.textAlign;
        g && q && (N = g.getBBox(), h = g.padding, e = "left" === e ? t.inverted ? -h : h : "right" === e ? N.width : t.inverted && "center" === e ? N.width / 2 : t.inverted ? r ? N.width + h : -h : N.width / 2, r = t.inverted ? N.height / 2 : r ? -h : N.height, this.alignOptions.x = A(this.options.x, 0), this.alignOptions.y = A(this.options.y, 0), q.x -= e, q.y -= r, g.align(this.alignOptions, null, q), t.isInsidePlot(g.alignAttr.x + e - this.alignOptions.x, g.alignAttr.y + r - this.alignOptions.y) ? g.show() : (g.alignAttr.y = -9999, d = !1), d && J.prototype.justifyDataLabel.call(this.axis, g, this.alignOptions, g.alignAttr, N, q), g.attr({
          x: g.alignAttr.x,
          y: g.alignAttr.y
        }), A(!d && this.options.crop, !0) && ((t = t.isInsidePlot(g.x - h + g.width, g.y) && t.isInsidePlot(g.x + h, g.y)) || g.hide()));
      },
      getStackBox: function (d, g, r, h, u, q, A) {
        var e = g.axis.reversed,
            c = d.inverted;
        d = A.height + A.pos - (c ? d.plotLeft : d.plotTop);
        g = g.isNegative && !e || !g.isNegative && e;
        return {
          x: c ? g ? h : h - q : r,
          y: c ? d - r - u : g ? d - h - q : d - h,
          width: c ? q : u,
          height: c ? u : q
        };
      }
    };

    G.prototype.getStacks = function () {
      var d = this,
          g = d.inverted;
      d.yAxis.forEach(function (d) {
        d.stacks && d.hasVisibleSeries && (d.oldStacks = d.stacks);
      });
      d.series.forEach(function (t) {
        var h = t.xAxis && t.xAxis.options || {};
        !t.options.stacking || !0 !== t.visible && !1 !== d.options.chart.ignoreHiddenSeries || (t.stackKey = [t.type, A(t.options.stack, ""), g ? h.top : h.left, g ? h.height : h.width].join());
      });
    };

    g.prototype.buildStacks = function () {
      var g = this.series,
          t = A(this.options.reversedStacks, !0),
          r = g.length,
          h;

      if (!this.isXAxis) {
        this.usePercentage = !1;

        for (h = r; h--;) {
          var u = g[t ? h : r - h - 1];
          u.setStackedPoints();
        }

        for (h = 0; h < r; h++) g[h].modifyStacks();

        d.fireEvent(this, "afterBuildStacks");
      }
    };

    g.prototype.renderStackTotals = function () {
      var d = this.chart,
          g = d.renderer,
          r = this.stacks,
          h = this.stackTotalGroup;
      h || (this.stackTotalGroup = h = g.g("stack-labels").attr({
        visibility: "visible",
        zIndex: 6
      }).add());
      h.translate(d.plotLeft, d.plotTop);
      E(r, function (d) {
        E(d, function (d) {
          d.render(h);
        });
      });
    };

    g.prototype.resetStacks = function () {
      var d = this,
          g = d.stacks;
      d.isXAxis || E(g, function (g) {
        E(g, function (h, t) {
          h.touched < d.stacksTouched ? (h.destroy(), delete g[t]) : (h.total = null, h.cumulative = null);
        });
      });
    };

    g.prototype.cleanStacks = function () {
      if (!this.isXAxis) {
        if (this.oldStacks) var d = this.stacks = this.oldStacks;
        E(d, function (d) {
          E(d, function (d) {
            d.cumulative = d.total;
          });
        });
      }
    };

    J.prototype.setStackedPoints = function () {
      if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
        var g = this.processedXData,
            t = this.processedYData,
            D = [],
            h = t.length,
            N = this.options,
            q = N.threshold,
            G = A(N.startFromThreshold && q, 0),
            e = N.stack;
        N = N.stacking;
        var c = this.stackKey,
            k = "-" + c,
            n = this.negStacks,
            f = this.yAxis,
            a = f.stacks,
            l = f.oldStacks,
            v,
            z;
        f.stacksTouched += 1;

        for (z = 0; z < h; z++) {
          var w = g[z];
          var B = t[z];
          var L = this.getStackIndicator(L, w, this.index);
          var Q = L.key;
          var H = (v = n && B < (G ? 0 : q)) ? k : c;
          a[H] || (a[H] = {});
          a[H][w] || (l[H] && l[H][w] ? (a[H][w] = l[H][w], a[H][w].total = null) : a[H][w] = new d.StackItem(f, f.options.stackLabels, v, w, e));
          H = a[H][w];
          null !== B ? (H.points[Q] = H.points[this.index] = [A(H.cumulative, G)], u(H.cumulative) || (H.base = Q), H.touched = f.stacksTouched, 0 < L.index && !1 === this.singleStacks && (H.points[Q][0] = H.points[this.index + "," + w + ",0"][0])) : H.points[Q] = H.points[this.index] = null;
          "percent" === N ? (v = v ? c : k, n && a[v] && a[v][w] ? (v = a[v][w], H.total = v.total = Math.max(v.total, H.total) + Math.abs(B) || 0) : H.total = r(H.total + (Math.abs(B) || 0))) : H.total = r(H.total + (B || 0));
          H.cumulative = A(H.cumulative, G) + (B || 0);
          null !== B && (H.points[Q].push(H.cumulative), D[z] = H.cumulative);
        }

        "percent" === N && (f.usePercentage = !0);
        this.stackedYData = D;
        f.oldStacks = {};
      }
    };

    J.prototype.modifyStacks = function () {
      var d = this,
          g = d.stackKey,
          r = d.yAxis.stacks,
          h = d.processedXData,
          u,
          q = d.options.stacking;
      d[q + "Stacker"] && [g, "-" + g].forEach(function (g) {
        for (var e = h.length, c, k; e--;) if (c = h[e], u = d.getStackIndicator(u, c, d.index, g), k = (c = r[g] && r[g][c]) && c.points[u.key]) d[q + "Stacker"](k, c, e);
      });
    };

    J.prototype.percentStacker = function (d, g, u) {
      g = g.total ? 100 / g.total : 0;
      d[0] = r(d[0] * g);
      d[1] = r(d[1] * g);
      this.stackedYData[u] = d[1];
    };

    J.prototype.getStackIndicator = function (d, g, r, h) {
      !u(d) || d.x !== g || h && d.key !== h ? d = {
        x: g,
        index: 0,
        key: h
      } : d.index++;
      d.key = [r, g, d.index].join();
      return d;
    };
  });
  S(r, "parts/Dynamics.js", [r["parts/Globals.js"], r["parts/Point.js"], r["parts/Time.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    var I = u.addEvent,
        M = u.animate,
        E = u.createElement,
        A = u.css,
        G = u.defined,
        J = u.erase,
        y = u.error,
        t = u.extend,
        D = u.fireEvent,
        h = u.isArray,
        N = u.isNumber,
        q = u.isObject,
        P = u.isString,
        e = u.merge,
        c = u.objectEach,
        k = u.pick,
        n = u.relativeLength,
        f = u.setAnimation,
        a = u.splat,
        l = d.Axis;
    u = d.Chart;
    var v = d.Series,
        z = d.seriesTypes;

    d.cleanRecursively = function (a, e) {
      var f = {};
      c(a, function (c, k) {
        if (q(a[k], !0) && !a.nodeType && e[k]) c = d.cleanRecursively(a[k], e[k]), Object.keys(c).length && (f[k] = c);else if (q(a[k]) || a[k] !== e[k]) f[k] = a[k];
      });
      return f;
    };

    t(u.prototype, {
      addSeries: function (a, c, e) {
        var f,
            d = this;
        a && (c = k(c, !0), D(d, "addSeries", {
          options: a
        }, function () {
          f = d.initSeries(a);
          d.isDirtyLegend = !0;
          d.linkSeries();
          f.enabledDataSorting && f.setData(a.data, !1);
          D(d, "afterAddSeries", {
            series: f
          });
          c && d.redraw(e);
        }));
        return f;
      },
      addAxis: function (a, c, e, f) {
        return this.createAxis(c ? "xAxis" : "yAxis", {
          axis: a,
          redraw: e,
          animation: f
        });
      },
      addColorAxis: function (a, c, e) {
        return this.createAxis("colorAxis", {
          axis: a,
          redraw: c,
          animation: e
        });
      },
      createAxis: function (c, f) {
        var h = this.options,
            g = "colorAxis" === c,
            n = f.redraw,
            w = f.animation;
        f = e(f.axis, {
          index: this[c].length,
          isX: "xAxis" === c
        });
        var p = g ? new d.ColorAxis(this, f) : new l(this, f);
        h[c] = a(h[c] || {});
        h[c].push(f);
        g && (this.isDirtyLegend = !0, this.axes.forEach(function (a) {
          a.series = [];
        }), this.series.forEach(function (a) {
          a.bindAxes();
          a.isDirtyData = !0;
        }));
        k(n, !0) && this.redraw(w);
        return p;
      },
      showLoading: function (a) {
        var c = this,
            e = c.options,
            f = c.loadingDiv,
            d = e.loading,
            h = function () {
          f && A(f, {
            left: c.plotLeft + "px",
            top: c.plotTop + "px",
            width: c.plotWidth + "px",
            height: c.plotHeight + "px"
          });
        };

        f || (c.loadingDiv = f = E("div", {
          className: "highcharts-loading highcharts-loading-hidden"
        }, null, c.container), c.loadingSpan = E("span", {
          className: "highcharts-loading-inner"
        }, null, f), I(c, "redraw", h));
        f.className = "highcharts-loading";
        c.loadingSpan.innerHTML = k(a, e.lang.loading, "");
        c.styledMode || (A(f, t(d.style, {
          zIndex: 10
        })), A(c.loadingSpan, d.labelStyle), c.loadingShown || (A(f, {
          opacity: 0,
          display: ""
        }), M(f, {
          opacity: d.style.opacity || .5
        }, {
          duration: d.showDuration || 0
        })));
        c.loadingShown = !0;
        h();
      },
      hideLoading: function () {
        var a = this.options,
            c = this.loadingDiv;
        c && (c.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || M(c, {
          opacity: 0
        }, {
          duration: a.loading.hideDuration || 100,
          complete: function () {
            A(c, {
              display: "none"
            });
          }
        }));
        this.loadingShown = !1;
      },
      propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
      propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
      propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" "),
      collectionsWithUpdate: ["xAxis", "yAxis", "zAxis", "series"],
      update: function (f, h, l, g) {
        var v = this,
            w = {
          credits: "addCredits",
          title: "setTitle",
          subtitle: "setSubtitle",
          caption: "setCaption"
        },
            p,
            b,
            q,
            t = f.isResponsiveOptions,
            z = [];
        D(v, "update", {
          options: f
        });
        t || v.setResponsive(!1, !0);
        f = d.cleanRecursively(f, v.options);
        e(!0, v.userOptions, f);

        if (p = f.chart) {
          e(!0, v.options.chart, p);
          "className" in p && v.setClassName(p.className);
          "reflow" in p && v.setReflow(p.reflow);

          if ("inverted" in p || "polar" in p || "type" in p) {
            v.propFromSeries();
            var B = !0;
          }

          "alignTicks" in p && (B = !0);
          c(p, function (a, c) {
            -1 !== v.propsRequireUpdateSeries.indexOf("chart." + c) && (b = !0);
            -1 !== v.propsRequireDirtyBox.indexOf(c) && (v.isDirtyBox = !0);
            t || -1 === v.propsRequireReflow.indexOf(c) || (q = !0);
          });
          !v.styledMode && "style" in p && v.renderer.setStyle(p.style);
        }

        !v.styledMode && f.colors && (this.options.colors = f.colors);
        f.plotOptions && e(!0, this.options.plotOptions, f.plotOptions);
        f.time && this.time === d.time && (this.time = new r(f.time));
        c(f, function (a, c) {
          if (v[c] && "function" === typeof v[c].update) v[c].update(a, !1);else if ("function" === typeof v[w[c]]) v[w[c]](a);
          "chart" !== c && -1 !== v.propsRequireUpdateSeries.indexOf(c) && (b = !0);
        });
        this.collectionsWithUpdate.forEach(function (b) {
          if (f[b]) {
            if ("series" === b) {
              var c = [];
              v[b].forEach(function (a, b) {
                a.options.isInternal || c.push(k(a.options.index, b));
              });
            }

            a(f[b]).forEach(function (a, e) {
              (e = G(a.id) && v.get(a.id) || v[b][c ? c[e] : e]) && e.coll === b && (e.update(a, !1), l && (e.touched = !0));
              !e && l && v.collectionsWithInit[b] && (v.collectionsWithInit[b][0].apply(v, [a].concat(v.collectionsWithInit[b][1] || []).concat([!1])).touched = !0);
            });
            l && v[b].forEach(function (a) {
              a.touched || a.options.isInternal ? delete a.touched : z.push(a);
            });
          }
        });
        z.forEach(function (a) {
          a.remove && a.remove(!1);
        });
        B && v.axes.forEach(function (a) {
          a.update({}, !1);
        });
        b && v.getSeriesOrderByLinks().forEach(function (a) {
          a.chart && a.update({}, !1);
        }, this);
        f.loading && e(!0, v.options.loading, f.loading);
        B = p && p.width;
        p = p && p.height;
        P(p) && (p = n(p, B || v.chartWidth));
        q || N(B) && B !== v.chartWidth || N(p) && p !== v.chartHeight ? v.setSize(B, p, g) : k(h, !0) && v.redraw(g);
        D(v, "afterUpdate", {
          options: f,
          redraw: h,
          animation: g
        });
      },
      setSubtitle: function (a, c) {
        this.applyDescription("subtitle", a);
        this.layOutTitles(c);
      },
      setCaption: function (a, c) {
        this.applyDescription("caption", a);
        this.layOutTitles(c);
      }
    });
    u.prototype.collectionsWithInit = {
      xAxis: [u.prototype.addAxis, [!0]],
      yAxis: [u.prototype.addAxis, [!1]],
      series: [u.prototype.addSeries]
    };
    t(g.prototype, {
      update: function (a, c, e, f) {
        function d() {
          h.applyOptions(a);
          var f = b && h.hasDummyGraphic;
          f = null === h.y ? !f : f;
          b && f && (h.graphic = b.destroy(), delete h.hasDummyGraphic);
          q(a, !0) && (b && b.element && a && a.marker && "undefined" !== typeof a.marker.symbol && (h.graphic = b.destroy()), a && a.dataLabels && h.dataLabel && (h.dataLabel = h.dataLabel.destroy()), h.connector && (h.connector = h.connector.destroy()));
          g = h.index;
          l.updateParallelArrays(h, g);
          v.data[g] = q(v.data[g], !0) || q(a, !0) ? h.options : k(a, v.data[g]);
          l.isDirty = l.isDirtyData = !0;
          !l.fixedBox && l.hasCartesianSeries && (n.isDirtyBox = !0);
          "point" === v.legendType && (n.isDirtyLegend = !0);
          c && n.redraw(e);
        }

        var h = this,
            l = h.series,
            b = h.graphic,
            g,
            n = l.chart,
            v = l.options;
        c = k(c, !0);
        !1 === f ? d() : h.firePointEvent("update", {
          options: a
        }, d);
      },
      remove: function (a, c) {
        this.series.removePoint(this.series.data.indexOf(this), a, c);
      }
    });
    t(v.prototype, {
      addPoint: function (a, c, e, f, d) {
        var h = this.options,
            l = this.data,
            b = this.chart,
            g = this.xAxis;
        g = g && g.hasNames && g.names;
        var n = h.data,
            v = this.xData,
            q;
        c = k(c, !0);
        var w = {
          series: this
        };
        this.pointClass.prototype.applyOptions.apply(w, [a]);
        var t = w.x;
        var m = v.length;
        if (this.requireSorting && t < v[m - 1]) for (q = !0; m && v[m - 1] > t;) m--;
        this.updateParallelArrays(w, "splice", m, 0, 0);
        this.updateParallelArrays(w, m);
        g && w.name && (g[t] = w.name);
        n.splice(m, 0, a);
        q && (this.data.splice(m, 0, null), this.processData());
        "point" === h.legendType && this.generatePoints();
        e && (l[0] && l[0].remove ? l[0].remove(!1) : (l.shift(), this.updateParallelArrays(w, "shift"), n.shift()));
        !1 !== d && D(this, "addPoint", {
          point: w
        });
        this.isDirtyData = this.isDirty = !0;
        c && b.redraw(f);
      },
      removePoint: function (a, c, e) {
        var d = this,
            h = d.data,
            l = h[a],
            g = d.points,
            b = d.chart,
            n = function () {
          g && g.length === h.length && g.splice(a, 1);
          h.splice(a, 1);
          d.options.data.splice(a, 1);
          d.updateParallelArrays(l || {
            series: d
          }, "splice", a, 1);
          l && l.destroy();
          d.isDirty = !0;
          d.isDirtyData = !0;
          c && b.redraw();
        };

        f(e, b);
        c = k(c, !0);
        l ? l.firePointEvent("remove", null, n) : n();
      },
      remove: function (a, c, e, f) {
        function d() {
          h.destroy(f);
          h.remove = null;
          l.isDirtyLegend = l.isDirtyBox = !0;
          l.linkSeries();
          k(a, !0) && l.redraw(c);
        }

        var h = this,
            l = h.chart;
        !1 !== e ? D(h, "remove", null, d) : d();
      },
      update: function (a, c) {
        a = d.cleanRecursively(a, this.userOptions);
        D(this, "update", {
          options: a
        });
        var f = this,
            h = f.chart,
            l = f.userOptions,
            g = f.initialType || f.type,
            n = a.type || l.type || h.options.chart.type,
            b = !(this.hasDerivedData || a.dataGrouping || n && n !== this.type || "undefined" !== typeof a.pointStart || a.pointInterval || a.pointIntervalUnit || a.keys),
            v = z[g].prototype,
            q,
            w = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"],
            r = ["eventOptions", "navigatorSeries", "baseSeries"],
            B = f.finishedAnimating && {
          animation: !1
        },
            u = {};
        b && (r.push("data", "isDirtyData", "points", "processedXData", "processedYData", "xIncrement", "_hasPointMarkers", "_hasPointLabels", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== a.visible && r.push("area", "graph"), f.parallelArrays.forEach(function (a) {
          r.push(a + "Data");
        }), a.data && (a.dataSorting && t(f.options.dataSorting, a.dataSorting), this.setData(a.data, !1)));
        a = e(l, B, {
          index: "undefined" === typeof l.index ? f.index : l.index,
          pointStart: k(l.pointStart, f.xData[0])
        }, !b && {
          data: f.options.data
        }, a);
        b && a.data && (a.data = f.options.data);
        r = w.concat(r);
        r.forEach(function (a) {
          r[a] = f[a];
          delete f[a];
        });
        f.remove(!1, null, !1, !0);

        for (q in v) f[q] = void 0;

        z[n || g] ? t(f, z[n || g].prototype) : y(17, !0, h, {
          missingModuleFor: n || g
        });
        r.forEach(function (a) {
          f[a] = r[a];
        });
        f.init(h, a);

        if (b && this.points) {
          var m = f.options;
          !1 === m.visible ? (u.graphic = 1, u.dataLabel = 1) : f._hasPointLabels || (n = m.marker, v = m.dataLabels, n && (!1 === n.enabled || "symbol" in n) && (u.graphic = 1), v && !1 === v.enabled && (u.dataLabel = 1));
          this.points.forEach(function (a) {
            a && a.series && (a.resolveColor(), Object.keys(u).length && a.destroyElements(u), !1 === m.showInLegend && a.legendItem && h.legend.destroyItem(a));
          }, this);
        }

        a.zIndex !== l.zIndex && w.forEach(function (b) {
          f[b] && f[b].attr({
            zIndex: a.zIndex
          });
        });
        f.initialType = g;
        h.linkSeries();
        D(this, "afterUpdate");
        k(c, !0) && h.redraw(b ? void 0 : !1);
      },
      setName: function (a) {
        this.name = this.options.name = this.userOptions.name = a;
        this.chart.isDirtyLegend = !0;
      }
    });
    t(l.prototype, {
      update: function (a, f) {
        var d = this.chart,
            h = a && a.events || {};
        a = e(this.userOptions, a);
        d.options[this.coll].indexOf && (d.options[this.coll][d.options[this.coll].indexOf(this.userOptions)] = a);
        c(d.options[this.coll].events, function (a, c) {
          "undefined" === typeof h[c] && (h[c] = void 0);
        });
        this.destroy(!0);
        this.init(d, t(a, {
          events: h
        }));
        d.isDirtyBox = !0;
        k(f, !0) && d.redraw();
      },
      remove: function (a) {
        for (var c = this.chart, e = this.coll, f = this.series, d = f.length; d--;) f[d] && f[d].remove(!1);

        J(c.axes, this);
        J(c[e], this);
        h(c.options[e]) ? c.options[e].splice(this.options.index, 1) : delete c.options[e];
        c[e].forEach(function (a, c) {
          a.options.index = a.userOptions.index = c;
        });
        this.destroy();
        c.isDirtyBox = !0;
        k(a, !0) && c.redraw();
      },
      setTitle: function (a, c) {
        this.update({
          title: a
        }, c);
      },
      setCategories: function (a, c) {
        this.update({
          categories: a
        }, c);
      }
    });
  });
  S(r, "parts/AreaSeries.js", [r["parts/Globals.js"], r["parts/Color.js"], r["mixins/legend-symbol.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    var I = g.parse,
        M = u.objectEach,
        E = u.pick;
    g = u.seriesType;
    var A = d.Series;
    g("area", "line", {
      softThreshold: !1,
      threshold: 0
    }, {
      singleStacks: !1,
      getStackPoints: function (d) {
        var g = [],
            r = [],
            t = this.xAxis,
            u = this.yAxis,
            h = u.stacks[this.stackKey],
            A = {},
            q = this.index,
            G = u.series,
            e = G.length,
            c = E(u.options.reversedStacks, !0) ? 1 : -1,
            k;
        d = d || this.points;

        if (this.options.stacking) {
          for (k = 0; k < d.length; k++) d[k].leftNull = d[k].rightNull = void 0, A[d[k].x] = d[k];

          M(h, function (c, a) {
            null !== c.total && r.push(a);
          });
          r.sort(function (c, a) {
            return c - a;
          });
          var n = G.map(function (c) {
            return c.visible;
          });
          r.forEach(function (f, a) {
            var d = 0,
                v,
                z;
            if (A[f] && !A[f].isNull) g.push(A[f]), [-1, 1].forEach(function (d) {
              var l = 1 === d ? "rightNull" : "leftNull",
                  g = 0,
                  w = h[r[a + d]];
              if (w) for (k = q; 0 <= k && k < e;) v = w.points[k], v || (k === q ? A[f][l] = !0 : n[k] && (z = h[f].points[k]) && (g -= z[1] - z[0])), k += c;
              A[f][1 === d ? "rightCliff" : "leftCliff"] = g;
            });else {
              for (k = q; 0 <= k && k < e;) {
                if (v = h[f].points[k]) {
                  d = v[1];
                  break;
                }

                k += c;
              }

              d = u.translate(d, 0, 1, 0, 1);
              g.push({
                isNull: !0,
                plotX: t.translate(f, 0, 0, 0, 1),
                x: f,
                plotY: d,
                yBottom: d
              });
            }
          });
        }

        return g;
      },
      getGraphPath: function (d) {
        var g = A.prototype.getGraphPath,
            r = this.options,
            t = r.stacking,
            u = this.yAxis,
            h,
            N = [],
            q = [],
            G = this.index,
            e = u.stacks[this.stackKey],
            c = r.threshold,
            k = Math.round(u.getThreshold(r.threshold));
        r = E(r.connectNulls, "percent" === t);

        var n = function (f, h, l) {
          var g = d[f];
          f = t && e[g.x].points[G];
          var n = g[l + "Null"] || 0;
          l = g[l + "Cliff"] || 0;
          g = !0;

          if (l || n) {
            var v = (n ? f[0] : f[1]) + l;
            var w = f[0] + l;
            g = !!n;
          } else !t && d[h] && d[h].isNull && (v = w = c);

          "undefined" !== typeof v && (q.push({
            plotX: a,
            plotY: null === v ? k : u.getThreshold(v),
            isNull: g,
            isCliff: !0
          }), N.push({
            plotX: a,
            plotY: null === w ? k : u.getThreshold(w),
            doCurve: !1
          }));
        };

        d = d || this.points;
        t && (d = this.getStackPoints(d));

        for (h = 0; h < d.length; h++) {
          t || (d[h].leftCliff = d[h].rightCliff = d[h].leftNull = d[h].rightNull = void 0);
          var f = d[h].isNull;
          var a = E(d[h].rectPlotX, d[h].plotX);
          var l = E(d[h].yBottom, k);
          if (!f || r) r || n(h, h - 1, "left"), f && !t && r || (q.push(d[h]), N.push({
            x: h,
            plotX: a,
            plotY: l
          })), r || n(h, h + 1, "right");
        }

        h = g.call(this, q, !0, !0);
        N.reversed = !0;
        f = g.call(this, N, !0, !0);
        f.length && (f[0] = "L");
        f = h.concat(f);
        g = g.call(this, q, !1, r);
        f.xMap = h.xMap;
        this.areaPath = f;
        return g;
      },
      drawGraph: function () {
        this.areaPath = [];
        A.prototype.drawGraph.apply(this);
        var d = this,
            g = this.areaPath,
            r = this.options,
            t = [["area", "highcharts-area", this.color, r.fillColor]];
        this.zones.forEach(function (g, h) {
          t.push(["zone-area-" + h, "highcharts-area highcharts-zone-area-" + h + " " + g.className, g.color || d.color, g.fillColor || r.fillColor]);
        });
        t.forEach(function (t) {
          var h = t[0],
              u = d[h],
              q = u ? "animate" : "attr",
              y = {};
          u ? (u.endX = d.preventGraphAnimation ? null : g.xMap, u.animate({
            d: g
          })) : (y.zIndex = 0, u = d[h] = d.chart.renderer.path(g).addClass(t[1]).add(d.group), u.isArea = !0);
          d.chart.styledMode || (y.fill = E(t[3], I(t[2]).setOpacity(E(r.fillOpacity, .75)).get()));
          u[q](y);
          u.startX = g.xMap;
          u.shiftUnit = r.step ? 2 : 1;
        });
      },
      drawLegendSymbol: r.drawRectangle
    });
    "";
  });
  S(r, "parts/SplineSeries.js", [r["parts/Utilities.js"]], function (d) {
    var g = d.pick;
    d = d.seriesType;
    d("spline", "line", {}, {
      getPointSpline: function (d, r, I) {
        var u = r.plotX,
            E = r.plotY,
            A = d[I - 1];
        I = d[I + 1];

        if (A && !A.isNull && !1 !== A.doCurve && !r.isCliff && I && !I.isNull && !1 !== I.doCurve && !r.isCliff) {
          d = A.plotY;
          var G = I.plotX;
          I = I.plotY;
          var J = 0;
          var y = (1.5 * u + A.plotX) / 2.5;
          var t = (1.5 * E + d) / 2.5;
          G = (1.5 * u + G) / 2.5;
          var D = (1.5 * E + I) / 2.5;
          G !== y && (J = (D - t) * (G - u) / (G - y) + E - D);
          t += J;
          D += J;
          t > d && t > E ? (t = Math.max(d, E), D = 2 * E - t) : t < d && t < E && (t = Math.min(d, E), D = 2 * E - t);
          D > I && D > E ? (D = Math.max(I, E), t = 2 * E - D) : D < I && D < E && (D = Math.min(I, E), t = 2 * E - D);
          r.rightContX = G;
          r.rightContY = D;
        }

        r = ["C", g(A.rightContX, A.plotX), g(A.rightContY, A.plotY), g(y, u), g(t, E), u, E];
        A.rightContX = A.rightContY = null;
        return r;
      }
    });
    "";
  });
  S(r, "parts/AreaSplineSeries.js", [r["parts/Globals.js"], r["mixins/legend-symbol.js"], r["parts/Utilities.js"]], function (d, g, r) {
    r = r.seriesType;
    var u = d.seriesTypes.area.prototype;
    r("areaspline", "spline", d.defaultPlotOptions.area, {
      getStackPoints: u.getStackPoints,
      getGraphPath: u.getGraphPath,
      drawGraph: u.drawGraph,
      drawLegendSymbol: g.drawRectangle
    });
    "";
  });
  S(r, "parts/ColumnSeries.js", [r["parts/Globals.js"], r["parts/Color.js"], r["mixins/legend-symbol.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    "";

    var I = g.parse,
        M = u.animObject,
        E = u.clamp,
        A = u.defined,
        G = u.extend,
        J = u.isNumber,
        y = u.merge,
        t = u.pick;
    g = u.seriesType;
    var D = d.Series;
    g("column", "line", {
      borderRadius: 0,
      crisp: !0,
      groupPadding: .2,
      marker: null,
      pointPadding: .1,
      minPointLength: 0,
      cropThreshold: 50,
      pointRange: null,
      states: {
        hover: {
          halo: !1,
          brightness: .1
        },
        select: {
          color: "#cccccc",
          borderColor: "#000000"
        }
      },
      dataLabels: {
        align: null,
        verticalAlign: null,
        y: null
      },
      softThreshold: !1,
      startFromThreshold: !0,
      stickyTracking: !1,
      tooltip: {
        distance: 6
      },
      threshold: 0,
      borderColor: "#ffffff"
    }, {
      cropShoulder: 0,
      directTouch: !0,
      trackerGroups: ["group", "dataLabelsGroup"],
      negStacks: !0,
      init: function () {
        D.prototype.init.apply(this, arguments);
        var d = this,
            g = d.chart;
        g.hasRendered && g.series.forEach(function (h) {
          h.type === d.type && (h.isDirty = !0);
        });
      },
      getColumnMetrics: function () {
        var d = this,
            g = d.options,
            q = d.xAxis,
            r = d.yAxis,
            e = q.options.reversedStacks;
        e = q.reversed && !e || !q.reversed && e;
        var c,
            k = {},
            n = 0;
        !1 === g.grouping ? n = 1 : d.chart.series.forEach(function (a) {
          var e = a.yAxis,
              f = a.options;

          if (a.type === d.type && (a.visible || !d.chart.options.chart.ignoreHiddenSeries) && r.len === e.len && r.pos === e.pos) {
            if (f.stacking) {
              c = a.stackKey;
              "undefined" === typeof k[c] && (k[c] = n++);
              var h = k[c];
            } else !1 !== f.grouping && (h = n++);

            a.columnIndex = h;
          }
        });
        var f = Math.min(Math.abs(q.transA) * (q.ordinalSlope || g.pointRange || q.closestPointRange || q.tickInterval || 1), q.len),
            a = f * g.groupPadding,
            l = (f - 2 * a) / (n || 1);
        g = Math.min(g.maxPointWidth || q.len, t(g.pointWidth, l * (1 - 2 * g.pointPadding)));
        d.columnMetrics = {
          width: g,
          offset: (l - g) / 2 + (a + ((d.columnIndex || 0) + (e ? 1 : 0)) * l - f / 2) * (e ? -1 : 1)
        };
        return d.columnMetrics;
      },
      crispCol: function (d, g, q, t) {
        var e = this.chart,
            c = this.borderWidth,
            k = -(c % 2 ? .5 : 0);
        c = c % 2 ? .5 : 1;
        e.inverted && e.renderer.isVML && (c += 1);
        this.options.crisp && (q = Math.round(d + q) + k, d = Math.round(d) + k, q -= d);
        t = Math.round(g + t) + c;
        k = .5 >= Math.abs(g) && .5 < t;
        g = Math.round(g) + c;
        t -= g;
        k && t && (--g, t += 1);
        return {
          x: d,
          y: g,
          width: q,
          height: t
        };
      },
      translate: function () {
        var d = this,
            g = d.chart,
            q = d.options,
            r = d.dense = 2 > d.closestPointRange * d.xAxis.transA;
        r = d.borderWidth = t(q.borderWidth, r ? 0 : 1);
        var e = d.xAxis,
            c = d.yAxis,
            k = q.threshold,
            n = d.translatedThreshold = c.getThreshold(k),
            f = t(q.minPointLength, 5),
            a = d.getColumnMetrics(),
            l = a.width,
            v = d.barW = Math.max(l, 1 + 2 * r),
            z = d.pointXOffset = a.offset,
            w = d.dataMin,
            u = d.dataMax;
        g.inverted && (n -= .5);
        q.pointPadding && (v = Math.ceil(v));
        D.prototype.translate.apply(d);
        d.points.forEach(function (a) {
          var h = t(a.yBottom, n),
              q = 999 + Math.abs(h),
              r = l,
              p = a.plotX;
          q = E(a.plotY, -q, c.len + q);
          var b = a.plotX + z,
              B = v,
              x = Math.min(q, h),
              y = Math.max(q, h) - x;

          if (f && Math.abs(y) < f) {
            y = f;
            var L = !c.reversed && !a.negative || c.reversed && a.negative;
            a.y === k && d.dataMax <= k && c.min < k && w !== u && (L = !L);
            x = Math.abs(x - n) > f ? h - f : n - (L ? f : 0);
          }

          A(a.options.pointWidth) && (r = B = Math.ceil(a.options.pointWidth), b -= Math.round((r - l) / 2));
          a.barX = b;
          a.pointWidth = r;
          a.tooltipPos = g.inverted ? [c.len + c.pos - g.plotLeft - q, e.len + e.pos - g.plotTop - (p || 0) - z - B / 2, y] : [b + B / 2, q + c.pos - g.plotTop, y];
          a.shapeType = d.pointClass.prototype.shapeType || "rect";
          a.shapeArgs = d.crispCol.apply(d, a.isNull ? [b, n, B, 0] : [b, x, B, y]);
        });
      },
      getSymbol: d.noop,
      drawLegendSymbol: r.drawRectangle,
      drawGraph: function () {
        this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
      },
      pointAttribs: function (d, g) {
        var h = this.options,
            r = this.pointAttrToOptions || {};
        var e = r.stroke || "borderColor";
        var c = r["stroke-width"] || "borderWidth",
            k = d && d.color || this.color,
            n = d && d[e] || h[e] || this.color || k,
            f = d && d[c] || h[c] || this[c] || 0;
        r = d && d.options.dashStyle || h.dashStyle;
        var a = t(d && d.opacity, h.opacity, 1);

        if (d && this.zones.length) {
          var l = d.getZone();
          k = d.options.color || l && (l.color || d.nonZonedColor) || this.color;
          l && (n = l.borderColor || n, r = l.dashStyle || r, f = l.borderWidth || f);
        }

        g && d && (d = y(h.states[g], d.options.states && d.options.states[g] || {}), g = d.brightness, k = d.color || "undefined" !== typeof g && I(k).brighten(d.brightness).get() || k, n = d[e] || n, f = d[c] || f, r = d.dashStyle || r, a = t(d.opacity, a));
        e = {
          fill: k,
          stroke: n,
          "stroke-width": f,
          opacity: a
        };
        r && (e.dashstyle = r);
        return e;
      },
      drawPoints: function () {
        var d = this,
            g = this.chart,
            q = d.options,
            t = g.renderer,
            e = q.animationLimit || 250,
            c;
        d.points.forEach(function (k) {
          var h = k.graphic,
              f = !!h,
              a = h && g.pointCount < e ? "animate" : "attr";

          if (J(k.plotY) && null !== k.y) {
            c = k.shapeArgs;
            h && k.hasNewShapeType() && (h = h.destroy());
            d.enabledDataSorting && (k.startXPos = d.xAxis.reversed ? -(c ? c.width : 0) : d.xAxis.width);
            h || (k.graphic = h = t[k.shapeType](c).add(k.group || d.group)) && d.enabledDataSorting && g.hasRendered && g.pointCount < e && (h.attr({
              x: k.startXPos
            }), f = !0, a = "animate");
            if (h && f) h[a](y(c));
            if (q.borderRadius) h[a]({
              r: q.borderRadius
            });
            g.styledMode || h[a](d.pointAttribs(k, k.selected && "select")).shadow(!1 !== k.allowShadow && q.shadow, null, q.stacking && !q.borderRadius);
            h.addClass(k.getClassName(), !0);
          } else h && (k.graphic = h.destroy());
        });
      },
      animate: function (d) {
        var h = this,
            g = this.yAxis,
            t = h.options,
            e = this.chart.inverted,
            c = {},
            k = e ? "translateX" : "translateY";
        if (d) c.scaleY = .001, d = E(g.toPixels(t.threshold), g.pos, g.pos + g.len), e ? c.translateX = d - g.len : c.translateY = d, h.clipBox && h.setClip(), h.group.attr(c);else {
          var n = h.group.attr(k);
          h.group.animate({
            scaleY: 1
          }, G(M(h.options.animation), {
            step: function (e, a) {
              h.group && (c[k] = n + a.pos * (g.pos - n), h.group.attr(c));
            }
          }));
        }
      },
      remove: function () {
        var d = this,
            g = d.chart;
        g.hasRendered && g.series.forEach(function (h) {
          h.type === d.type && (h.isDirty = !0);
        });
        D.prototype.remove.apply(d, arguments);
      }
    });
    "";
  });
  S(r, "parts/BarSeries.js", [r["parts/Utilities.js"]], function (d) {
    d = d.seriesType;
    d("bar", "column", null, {
      inverted: !0
    });
    "";
  });
  S(r, "parts/ScatterSeries.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.addEvent;
    g = g.seriesType;
    var u = d.Series;
    g("scatter", "line", {
      lineWidth: 0,
      findNearestPointBy: "xy",
      jitter: {
        x: 0,
        y: 0
      },
      marker: {
        enabled: !0
      },
      tooltip: {
        headerFormat: '<span style="color:{point.color}">\u25cf</span> <span style="font-size: 10px"> {series.name}</span><br/>',
        pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
      }
    }, {
      sorted: !1,
      requireSorting: !1,
      noSharedTooltip: !0,
      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
      takeOrdinalPosition: !1,
      drawGraph: function () {
        this.options.lineWidth && u.prototype.drawGraph.call(this);
      },
      applyJitter: function () {
        var d = this,
            g = this.options.jitter,
            r = this.points.length;
        g && this.points.forEach(function (u, E) {
          ["x", "y"].forEach(function (A, y) {
            var t = "plot" + A.toUpperCase();

            if (g[A] && !u.isNull) {
              var D = d[A + "Axis"];
              var h = g[A] * D.transA;

              if (D && !D.isLog) {
                var G = Math.max(0, u[t] - h);
                D = Math.min(D.len, u[t] + h);
                y = 1E4 * Math.sin(E + y * r);
                u[t] = G + (D - G) * (y - Math.floor(y));
                "x" === A && (u.clientX = u.plotX);
              }
            }
          });
        });
      }
    });
    r(u, "afterTranslate", function () {
      this.applyJitter && this.applyJitter();
    });
    "";
  });
  S(r, "mixins/centered-series.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.isNumber,
        u = g.pick,
        I = g.relativeLength,
        M = d.deg2rad;
    d.CenteredSeriesMixin = {
      getCenter: function () {
        var d = this.options,
            g = this.chart,
            r = 2 * (d.slicedOffset || 0),
            J = g.plotWidth - 2 * r,
            y = g.plotHeight - 2 * r,
            t = d.center,
            D = Math.min(J, y),
            h = d.size,
            N = d.innerSize || 0;
        "string" === typeof h && (h = parseFloat(h));
        "string" === typeof N && (N = parseFloat(N));
        d = [u(t[0], "50%"), u(t[1], "50%"), u(h && 0 > h ? void 0 : d.size, "100%"), u(N && 0 > N ? void 0 : d.innerSize || 0, "0%")];
        g.angular && (d[3] = 0);

        for (t = 0; 4 > t; ++t) h = d[t], g = 2 > t || 2 === t && /%$/.test(h), d[t] = I(h, [J, y, D, d[2]][t]) + (g ? r : 0);

        d[3] > d[2] && (d[3] = d[2]);
        return d;
      },
      getStartAndEndRadians: function (d, g) {
        d = r(d) ? d : 0;
        g = r(g) && g > d && 360 > g - d ? g : d + 360;
        return {
          start: M * (d + -90),
          end: M * (g + -90)
        };
      }
    };
  });
  S(r, "parts/PieSeries.js", [r["parts/Globals.js"], r["mixins/legend-symbol.js"], r["parts/Point.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    var I = u.addEvent,
        M = u.clamp,
        E = u.defined,
        A = u.fireEvent,
        G = u.isNumber,
        J = u.merge,
        y = u.pick,
        t = u.relativeLength,
        D = u.seriesType,
        h = u.setAnimation;
    u = d.CenteredSeriesMixin;
    var N = u.getStartAndEndRadians,
        q = d.noop,
        P = d.Series;
    D("pie", "line", {
      center: [null, null],
      clip: !1,
      colorByPoint: !0,
      dataLabels: {
        allowOverlap: !0,
        connectorPadding: 5,
        connectorShape: "fixedOffset",
        crookDistance: "70%",
        distance: 30,
        enabled: !0,
        formatter: function () {
          return this.point.isNull ? void 0 : this.point.name;
        },
        softConnector: !0,
        x: 0
      },
      fillColor: void 0,
      ignoreHiddenPoint: !0,
      inactiveOtherPoints: !0,
      legendType: "point",
      marker: null,
      size: null,
      showInLegend: !1,
      slicedOffset: 10,
      stickyTracking: !1,
      tooltip: {
        followPointer: !0
      },
      borderColor: "#ffffff",
      borderWidth: 1,
      lineWidth: void 0,
      states: {
        hover: {
          brightness: .1
        }
      }
    }, {
      isCartesian: !1,
      requireSorting: !1,
      directTouch: !0,
      noSharedTooltip: !0,
      trackerGroups: ["group", "dataLabelsGroup"],
      axisTypes: [],
      pointAttribs: d.seriesTypes.column.prototype.pointAttribs,
      animate: function (e) {
        var c = this,
            d = c.points,
            g = c.startAngleRad;
        e || d.forEach(function (e) {
          var a = e.graphic,
              f = e.shapeArgs;
          a && f && (a.attr({
            r: y(e.startR, c.center && c.center[3] / 2),
            start: g,
            end: g
          }), a.animate({
            r: f.r,
            start: f.start,
            end: f.end
          }, c.options.animation));
        });
      },
      hasData: function () {
        return !!this.processedXData.length;
      },
      updateTotals: function () {
        var e,
            c = 0,
            d = this.points,
            g = d.length,
            f = this.options.ignoreHiddenPoint;

        for (e = 0; e < g; e++) {
          var a = d[e];
          c += f && !a.visible ? 0 : a.isNull ? 0 : a.y;
        }

        this.total = c;

        for (e = 0; e < g; e++) a = d[e], a.percentage = 0 < c && (a.visible || !f) ? a.y / c * 100 : 0, a.total = c;
      },
      generatePoints: function () {
        P.prototype.generatePoints.call(this);
        this.updateTotals();
      },
      getX: function (e, c, d) {
        var k = this.center,
            f = this.radii ? this.radii[d.index] : k[2] / 2;
        e = Math.asin(M((e - k[1]) / (f + d.labelDistance), -1, 1));
        return k[0] + (c ? -1 : 1) * Math.cos(e) * (f + d.labelDistance) + (0 < d.labelDistance ? (c ? -1 : 1) * this.options.dataLabels.padding : 0);
      },
      translate: function (e) {
        this.generatePoints();
        var c = 0,
            d = this.options,
            g = d.slicedOffset,
            f = g + (d.borderWidth || 0),
            a = N(d.startAngle, d.endAngle),
            h = this.startAngleRad = a.start;
        a = (this.endAngleRad = a.end) - h;
        var v = this.points,
            q = d.dataLabels.distance;
        d = d.ignoreHiddenPoint;
        var w,
            r = v.length;
        e || (this.center = e = this.getCenter());

        for (w = 0; w < r; w++) {
          var u = v[w];
          var D = h + c * a;
          if (!d || u.visible) c += u.percentage / 100;
          var H = h + c * a;
          u.shapeType = "arc";
          u.shapeArgs = {
            x: e[0],
            y: e[1],
            r: e[2] / 2,
            innerR: e[3] / 2,
            start: Math.round(1E3 * D) / 1E3,
            end: Math.round(1E3 * H) / 1E3
          };
          u.labelDistance = y(u.options.dataLabels && u.options.dataLabels.distance, q);
          u.labelDistance = t(u.labelDistance, u.shapeArgs.r);
          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, u.labelDistance);
          H = (H + D) / 2;
          H > 1.5 * Math.PI ? H -= 2 * Math.PI : H < -Math.PI / 2 && (H += 2 * Math.PI);
          u.slicedTranslation = {
            translateX: Math.round(Math.cos(H) * g),
            translateY: Math.round(Math.sin(H) * g)
          };
          var K = Math.cos(H) * e[2] / 2;
          var p = Math.sin(H) * e[2] / 2;
          u.tooltipPos = [e[0] + .7 * K, e[1] + .7 * p];
          u.half = H < -Math.PI / 2 || H > Math.PI / 2 ? 1 : 0;
          u.angle = H;
          D = Math.min(f, u.labelDistance / 5);
          u.labelPosition = {
            natural: {
              x: e[0] + K + Math.cos(H) * u.labelDistance,
              y: e[1] + p + Math.sin(H) * u.labelDistance
            },
            "final": {},
            alignment: 0 > u.labelDistance ? "center" : u.half ? "right" : "left",
            connectorPosition: {
              breakAt: {
                x: e[0] + K + Math.cos(H) * D,
                y: e[1] + p + Math.sin(H) * D
              },
              touchingSliceAt: {
                x: e[0] + K,
                y: e[1] + p
              }
            }
          };
        }

        A(this, "afterTranslate");
      },
      drawEmpty: function () {
        var e = this.options;

        if (0 === this.total) {
          var c = this.center[0];
          var d = this.center[1];
          this.graph || (this.graph = this.chart.renderer.circle(c, d, 0).addClass("highcharts-graph").add(this.group));
          this.graph.animate({
            "stroke-width": e.borderWidth,
            cx: c,
            cy: d,
            r: this.center[2] / 2,
            fill: e.fillColor || "none",
            stroke: e.color || "#cccccc"
          }, this.options.animation);
        } else this.graph && (this.graph = this.graph.destroy());
      },
      redrawPoints: function () {
        var e = this,
            c = e.chart,
            d = c.renderer,
            g,
            f,
            a,
            h,
            v = e.options.shadow;
        this.drawEmpty();
        !v || e.shadowGroup || c.styledMode || (e.shadowGroup = d.g("shadow").attr({
          zIndex: -1
        }).add(e.group));
        e.points.forEach(function (k) {
          var l = {};
          f = k.graphic;

          if (!k.isNull && f) {
            h = k.shapeArgs;
            g = k.getTranslate();

            if (!c.styledMode) {
              var n = k.shadowGroup;
              v && !n && (n = k.shadowGroup = d.g("shadow").add(e.shadowGroup));
              n && n.attr(g);
              a = e.pointAttribs(k, k.selected && "select");
            }

            k.delayedRendering ? (f.setRadialReference(e.center).attr(h).attr(g), c.styledMode || f.attr(a).attr({
              "stroke-linejoin": "round"
            }).shadow(v, n), k.delayedRendering = !1) : (f.setRadialReference(e.center), c.styledMode || J(!0, l, a), J(!0, l, h, g), f.animate(l));
            f.attr({
              visibility: k.visible ? "inherit" : "hidden"
            });
            f.addClass(k.getClassName());
          } else f && (k.graphic = f.destroy());
        });
      },
      drawPoints: function () {
        var e = this.chart.renderer;
        this.points.forEach(function (c) {
          c.graphic && c.hasNewShapeType() && (c.graphic = c.graphic.destroy());
          c.graphic || (c.graphic = e[c.shapeType](c.shapeArgs).add(c.series.group), c.delayedRendering = !0);
        });
      },
      searchPoint: q,
      sortByAngle: function (e, c) {
        e.sort(function (e, d) {
          return "undefined" !== typeof e.angle && (d.angle - e.angle) * c;
        });
      },
      drawLegendSymbol: g.drawRectangle,
      getCenter: u.getCenter,
      getSymbol: q,
      drawGraph: null
    }, {
      init: function () {
        r.prototype.init.apply(this, arguments);
        var e = this;
        e.name = y(e.name, "Slice");

        var c = function (c) {
          e.slice("select" === c.type);
        };

        I(e, "select", c);
        I(e, "unselect", c);
        return e;
      },
      isValid: function () {
        return G(this.y) && 0 <= this.y;
      },
      setVisible: function (e, c) {
        var d = this,
            g = d.series,
            f = g.chart,
            a = g.options.ignoreHiddenPoint;
        c = y(c, a);
        e !== d.visible && (d.visible = d.options.visible = e = "undefined" === typeof e ? !d.visible : e, g.options.data[g.data.indexOf(d)] = d.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (a) {
          if (d[a]) d[a][e ? "show" : "hide"](!0);
        }), d.legendItem && f.legend.colorizeItem(d, e), e || "hover" !== d.state || d.setState(""), a && (g.isDirty = !0), c && f.redraw());
      },
      slice: function (e, c, d) {
        var g = this.series;
        h(d, g.chart);
        y(c, !0);
        this.sliced = this.options.sliced = E(e) ? e : !this.sliced;
        g.options.data[g.data.indexOf(this)] = this.options;
        this.graphic.animate(this.getTranslate());
        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
      },
      getTranslate: function () {
        return this.sliced ? this.slicedTranslation : {
          translateX: 0,
          translateY: 0
        };
      },
      haloPath: function (e) {
        var c = this.shapeArgs;
        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + e, c.r + e, {
          innerR: c.r - 1,
          start: c.start,
          end: c.end
        });
      },
      connectorShapes: {
        fixedOffset: function (e, c, d) {
          var g = c.breakAt;
          c = c.touchingSliceAt;
          return ["M", e.x, e.y].concat(d.softConnector ? ["C", e.x + ("left" === e.alignment ? -5 : 5), e.y, 2 * g.x - c.x, 2 * g.y - c.y, g.x, g.y] : ["L", g.x, g.y]).concat(["L", c.x, c.y]);
        },
        straight: function (e, c) {
          c = c.touchingSliceAt;
          return ["M", e.x, e.y, "L", c.x, c.y];
        },
        crookedLine: function (e, c, d) {
          c = c.touchingSliceAt;
          var g = this.series,
              f = g.center[0],
              a = g.chart.plotWidth,
              k = g.chart.plotLeft;
          g = e.alignment;
          var h = this.shapeArgs.r;
          d = t(d.crookDistance, 1);
          d = "left" === g ? f + h + (a + k - f - h) * (1 - d) : k + (f - h) * d;
          f = ["L", d, e.y];
          if ("left" === g ? d > e.x || d < c.x : d < e.x || d > c.x) f = [];
          return ["M", e.x, e.y].concat(f).concat(["L", c.x, c.y]);
        }
      },
      getConnectorPath: function () {
        var e = this.labelPosition,
            c = this.series.options.dataLabels,
            d = c.connectorShape,
            g = this.connectorShapes;
        g[d] && (d = g[d]);
        return d.call(this, {
          x: e.final.x,
          y: e.final.y,
          alignment: e.alignment
        }, e.connectorPosition, c);
      }
    });
    "";
  });
  S(r, "parts/DataLabels.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.animObject,
        u = g.arrayMax,
        I = g.clamp,
        M = g.defined,
        E = g.extend,
        A = g.format,
        G = g.isArray,
        J = g.merge,
        y = g.objectEach,
        t = g.pick,
        D = g.relativeLength,
        h = g.splat,
        N = g.stableSort;
    g = d.noop;
    var q = d.Series,
        P = d.seriesTypes;

    d.distribute = function (e, c, g) {
      function h(a, c) {
        return a.target - c.target;
      }

      var f,
          a = !0,
          k = e,
          v = [];
      var q = 0;
      var w = k.reducedLen || c;

      for (f = e.length; f--;) q += e[f].size;

      if (q > w) {
        N(e, function (a, c) {
          return (c.rank || 0) - (a.rank || 0);
        });

        for (q = f = 0; q <= w;) q += e[f].size, f++;

        v = e.splice(f - 1, e.length);
      }

      N(e, h);

      for (e = e.map(function (a) {
        return {
          size: a.size,
          targets: [a.target],
          align: t(a.align, .5)
        };
      }); a;) {
        for (f = e.length; f--;) a = e[f], q = (Math.min.apply(0, a.targets) + Math.max.apply(0, a.targets)) / 2, a.pos = I(q - a.size * a.align, 0, c - a.size);

        f = e.length;

        for (a = !1; f--;) 0 < f && e[f - 1].pos + e[f - 1].size > e[f].pos && (e[f - 1].size += e[f].size, e[f - 1].targets = e[f - 1].targets.concat(e[f].targets), e[f - 1].align = .5, e[f - 1].pos + e[f - 1].size > c && (e[f - 1].pos = c - e[f - 1].size), e.splice(f, 1), a = !0);
      }

      k.push.apply(k, v);
      f = 0;
      e.some(function (a) {
        var e = 0;
        if (a.targets.some(function () {
          k[f].pos = a.pos + e;
          if ("undefined" !== typeof g && Math.abs(k[f].pos - k[f].target) > g) return k.slice(0, f + 1).forEach(function (a) {
            delete a.pos;
          }), k.reducedLen = (k.reducedLen || c) - .1 * c, k.reducedLen > .1 * c && d.distribute(k, c, g), !0;
          e += k[f].size;
          f++;
        })) return !0;
      });
      N(k, h);
    };

    q.prototype.drawDataLabels = function () {
      function e(a, c) {
        var b = c.filter;
        return b ? (c = b.operator, a = a[b.property], b = b.value, ">" === c && a > b || "<" === c && a < b || ">=" === c && a >= b || "<=" === c && a <= b || "==" === c && a == b || "===" === c && a === b ? !0 : !1) : !0;
      }

      function c(a, c) {
        var b = [],
            e;
        if (G(a) && !G(c)) b = a.map(function (a) {
          return J(a, c);
        });else if (G(c) && !G(a)) b = c.map(function (b) {
          return J(a, b);
        });else if (G(a) || G(c)) for (e = Math.max(a.length, c.length); e--;) b[e] = J(a[e], c[e]);else b = J(a, c);
        return b;
      }

      var g = this,
          n = g.chart,
          f = g.options,
          a = f.dataLabels,
          l = g.points,
          v,
          q = g.hasRendered || 0,
          w = r(f.animation).duration,
          u = Math.min(w, 200),
          L = !n.renderer.forExport && t(a.defer, 0 < u),
          D = n.renderer;
      a = c(c(n.options.plotOptions && n.options.plotOptions.series && n.options.plotOptions.series.dataLabels, n.options.plotOptions && n.options.plotOptions[g.type] && n.options.plotOptions[g.type].dataLabels), a);
      d.fireEvent(this, "drawDataLabels");

      if (G(a) || a.enabled || g._hasPointLabels) {
        var H = g.plotGroup("dataLabelsGroup", "data-labels", L && !q ? "hidden" : "inherit", a.zIndex || 6);
        L && (H.attr({
          opacity: +q
        }), q || setTimeout(function () {
          var a = g.dataLabelsGroup;
          a && (g.visible && H.show(!0), a[f.animation ? "animate" : "attr"]({
            opacity: 1
          }, {
            duration: u
          }));
        }, w - u));
        l.forEach(function (d) {
          v = h(c(a, d.dlOptions || d.options && d.options.dataLabels));
          v.forEach(function (a, b) {
            var c = a.enabled && (!d.isNull || d.dataLabelOnNull) && e(d, a),
                h = d.dataLabels ? d.dataLabels[b] : d.dataLabel,
                k = d.connectors ? d.connectors[b] : d.connector,
                l = t(a.distance, d.labelDistance),
                p = !h;

            if (c) {
              var v = d.getLabelConfig();
              var m = t(a[d.formatPrefix + "Format"], a.format);
              v = M(m) ? A(m, v, n) : (a[d.formatPrefix + "Formatter"] || a.formatter).call(v, a);
              m = a.style;
              var q = a.rotation;
              n.styledMode || (m.color = t(a.color, m.color, g.color, "#000000"), "contrast" === m.color ? (d.contrastColor = D.getContrast(d.color || g.color), m.color = !M(l) && a.inside || 0 > l || f.stacking ? d.contrastColor : "#000000") : delete d.contrastColor, f.cursor && (m.cursor = f.cursor));
              var w = {
                r: a.borderRadius || 0,
                rotation: q,
                padding: a.padding,
                zIndex: 1
              };
              n.styledMode || (w.fill = a.backgroundColor, w.stroke = a.borderColor, w["stroke-width"] = a.borderWidth);
              y(w, function (a, b) {
                "undefined" === typeof a && delete w[b];
              });
            }

            !h || c && M(v) ? c && M(v) && (h ? w.text = v : (d.dataLabels = d.dataLabels || [], h = d.dataLabels[b] = q ? D.text(v, 0, -9999, a.useHTML).addClass("highcharts-data-label") : D.label(v, 0, -9999, a.shape, null, null, a.useHTML, null, "data-label"), b || (d.dataLabel = h), h.addClass(" highcharts-data-label-color-" + d.colorIndex + " " + (a.className || "") + (a.useHTML ? " highcharts-tracker" : ""))), h.options = a, h.attr(w), n.styledMode || h.css(m).shadow(a.shadow), h.added || h.add(H), a.textPath && !a.useHTML && (h.setTextPath(d.getDataLabelPath && d.getDataLabelPath(h) || d.graphic, a.textPath), d.dataLabelPath && !a.textPath.enabled && (d.dataLabelPath = d.dataLabelPath.destroy())), g.alignDataLabel(d, h, a, null, p)) : (d.dataLabel = d.dataLabel && d.dataLabel.destroy(), d.dataLabels && (1 === d.dataLabels.length ? delete d.dataLabels : delete d.dataLabels[b]), b || delete d.dataLabel, k && (d.connector = d.connector.destroy(), d.connectors && (1 === d.connectors.length ? delete d.connectors : delete d.connectors[b])));
          });
        });
      }

      d.fireEvent(this, "afterDrawDataLabels");
    };

    q.prototype.alignDataLabel = function (d, c, g, h, f) {
      var a = this,
          e = this.chart,
          k = this.isCartesian && e.inverted,
          n = this.enabledDataSorting,
          q = t(d.dlBox && d.dlBox.centerX, d.plotX, -9999),
          r = t(d.plotY, -9999),
          u = c.getBBox(),
          y = g.rotation,
          A = g.align,
          K = e.isInsidePlot(q, Math.round(r), k),
          p = "justify" === t(g.overflow, n ? "none" : "justify"),
          b = this.visible && !1 !== d.visible && (d.series.forceDL || n && !p || K || g.inside && h && e.isInsidePlot(q, k ? h.x + 1 : h.y + h.height - 1, k));

      var C = function (b) {
        n && a.xAxis && !p && a.setDataLabelStartPos(d, c, f, K, b);
      };

      if (b) {
        var x = e.renderer.fontMetrics(e.styledMode ? void 0 : g.style.fontSize, c).b;
        h = E({
          x: k ? this.yAxis.len - r : q,
          y: Math.round(k ? this.xAxis.len - q : r),
          width: 0,
          height: 0
        }, h);
        E(g, {
          width: u.width,
          height: u.height
        });
        y ? (p = !1, q = e.renderer.rotCorr(x, y), q = {
          x: h.x + g.x + h.width / 2 + q.x,
          y: h.y + g.y + {
            top: 0,
            middle: .5,
            bottom: 1
          }[g.verticalAlign] * h.height
        }, C(q), c[f ? "attr" : "animate"](q).attr({
          align: A
        }), C = (y + 720) % 360, C = 180 < C && 360 > C, "left" === A ? q.y -= C ? u.height : 0 : "center" === A ? (q.x -= u.width / 2, q.y -= u.height / 2) : "right" === A && (q.x -= u.width, q.y -= C ? 0 : u.height), c.placed = !0, c.alignAttr = q) : (C(h), c.align(g, null, h), q = c.alignAttr);
        p && 0 <= h.height ? this.justifyDataLabel(c, g, q, u, h, f) : t(g.crop, !0) && (b = e.isInsidePlot(q.x, q.y) && e.isInsidePlot(q.x + u.width, q.y + u.height));
        if (g.shape && !y) c[f ? "attr" : "animate"]({
          anchorX: k ? e.plotWidth - d.plotY : d.plotX,
          anchorY: k ? e.plotHeight - d.plotX : d.plotY
        });
      }

      f && n && (c.placed = !1);
      b || n && !p || (c.hide(!0), c.placed = !1);
    };

    q.prototype.setDataLabelStartPos = function (d, c, g, h, f) {
      var a = this.chart,
          e = a.inverted,
          k = this.xAxis,
          n = k.reversed,
          q = e ? c.height / 2 : c.width / 2;
      d = (d = d.pointWidth) ? d / 2 : 0;
      k = e ? f.x : n ? -q - d : k.width - q + d;
      f = e ? n ? this.yAxis.height - q + d : -q - d : f.y;
      c.startXPos = k;
      c.startYPos = f;
      h ? "hidden" === c.visibility && (c.show(), c.attr({
        opacity: 0
      }).animate({
        opacity: 1
      })) : c.attr({
        opacity: 1
      }).animate({
        opacity: 0
      }, void 0, c.hide);
      a.hasRendered && (g && c.attr({
        x: c.startXPos,
        y: c.startYPos
      }), c.placed = !0);
    };

    q.prototype.justifyDataLabel = function (d, c, g, h, f, a) {
      var e = this.chart,
          k = c.align,
          n = c.verticalAlign,
          q = d.box ? 0 : d.padding || 0;
      var r = g.x + q;

      if (0 > r) {
        "right" === k ? (c.align = "left", c.inside = !0) : c.x = -r;
        var t = !0;
      }

      r = g.x + h.width - q;
      r > e.plotWidth && ("left" === k ? (c.align = "right", c.inside = !0) : c.x = e.plotWidth - r, t = !0);
      r = g.y + q;
      0 > r && ("bottom" === n ? (c.verticalAlign = "top", c.inside = !0) : c.y = -r, t = !0);
      r = g.y + h.height - q;
      r > e.plotHeight && ("top" === n ? (c.verticalAlign = "bottom", c.inside = !0) : c.y = e.plotHeight - r, t = !0);
      t && (d.placed = !a, d.align(c, null, f));
      return t;
    };

    P.pie && (P.pie.prototype.dataLabelPositioners = {
      radialDistributionY: function (d) {
        return d.top + d.distributeBox.pos;
      },
      radialDistributionX: function (d, c, g, h) {
        return d.getX(g < c.top + 2 || g > c.bottom - 2 ? h : g, c.half, c);
      },
      justify: function (d, c, g) {
        return g[0] + (d.half ? -1 : 1) * (c + d.labelDistance);
      },
      alignToPlotEdges: function (d, c, g, h) {
        d = d.getBBox().width;
        return c ? d + h : g - d - h;
      },
      alignToConnectors: function (d, c, g, h) {
        var e = 0,
            a;
        d.forEach(function (c) {
          a = c.dataLabel.getBBox().width;
          a > e && (e = a);
        });
        return c ? e + h : g - e - h;
      }
    }, P.pie.prototype.drawDataLabels = function () {
      var e = this,
          c = e.data,
          g,
          h = e.chart,
          f = e.options.dataLabels || {},
          a = f.connectorPadding,
          l,
          v = h.plotWidth,
          r = h.plotHeight,
          w = h.plotLeft,
          y = Math.round(h.chartWidth / 3),
          A,
          D = e.center,
          H = D[2] / 2,
          K = D[1],
          p,
          b,
          C,
          x,
          G = [[], []],
          E,
          N,
          I,
          m,
          P = [0, 0, 0, 0],
          S = e.dataLabelPositioners,
          W;
      e.visible && (f.enabled || e._hasPointLabels) && (c.forEach(function (a) {
        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({
          width: "auto"
        }).css({
          width: "auto",
          textOverflow: "clip"
        }), a.dataLabel.shortened = !1);
      }), q.prototype.drawDataLabels.apply(e), c.forEach(function (a) {
        a.dataLabel && (a.visible ? (G[a.half].push(a), a.dataLabel._pos = null, !M(f.style.width) && !M(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > y && (a.dataLabel.css({
          width: .7 * y
        }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));
      }), G.forEach(function (c, k) {
        var l = c.length,
            n = [],
            q;

        if (l) {
          e.sortByAngle(c, k - .5);

          if (0 < e.maxLabelDistance) {
            var u = Math.max(0, K - H - e.maxLabelDistance);
            var z = Math.min(K + H + e.maxLabelDistance, h.plotHeight);
            c.forEach(function (a) {
              0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, K - H - a.labelDistance), a.bottom = Math.min(K + H + a.labelDistance, h.plotHeight), q = a.dataLabel.getBBox().height || 21, a.distributeBox = {
                target: a.labelPosition.natural.y - a.top + q / 2,
                size: q,
                rank: a.y
              }, n.push(a.distributeBox));
            });
            u = z + q - u;
            d.distribute(n, u, u / 5);
          }

          for (m = 0; m < l; m++) {
            g = c[m];
            C = g.labelPosition;
            p = g.dataLabel;
            I = !1 === g.visible ? "hidden" : "inherit";
            N = u = C.natural.y;
            n && M(g.distributeBox) && ("undefined" === typeof g.distributeBox.pos ? I = "hidden" : (x = g.distributeBox.size, N = S.radialDistributionY(g)));
            delete g.positionIndex;
            if (f.justify) E = S.justify(g, H, D);else switch (f.alignTo) {
              case "connectors":
                E = S.alignToConnectors(c, k, v, w);
                break;

              case "plotEdges":
                E = S.alignToPlotEdges(p, k, v, w);
                break;

              default:
                E = S.radialDistributionX(e, g, N, u);
            }
            p._attr = {
              visibility: I,
              align: C.alignment
            };
            W = g.options.dataLabels || {};
            p._pos = {
              x: E + t(W.x, f.x) + ({
                left: a,
                right: -a
              }[C.alignment] || 0),
              y: N + t(W.y, f.y) - 10
            };
            C.final.x = E;
            C.final.y = N;
            t(f.crop, !0) && (b = p.getBBox().width, u = null, E - b < a && 1 === k ? (u = Math.round(b - E + a), P[3] = Math.max(u, P[3])) : E + b > v - a && 0 === k && (u = Math.round(E + b - v + a), P[1] = Math.max(u, P[1])), 0 > N - x / 2 ? P[0] = Math.max(Math.round(-N + x / 2), P[0]) : N + x / 2 > r && (P[2] = Math.max(Math.round(N + x / 2 - r), P[2])), p.sideOverflow = u);
          }
        }
      }), 0 === u(P) || this.verifyDataLabelOverflow(P)) && (this.placeDataLabels(), this.points.forEach(function (a) {
        W = J(f, a.options.dataLabels);

        if (l = t(W.connectorWidth, 1)) {
          var b;
          A = a.connector;

          if ((p = a.dataLabel) && p._pos && a.visible && 0 < a.labelDistance) {
            I = p._attr.visibility;
            if (b = !A) a.connector = A = h.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + a.colorIndex + (a.className ? " " + a.className : "")).add(e.dataLabelsGroup), h.styledMode || A.attr({
              "stroke-width": l,
              stroke: W.connectorColor || a.color || "#666666"
            });
            A[b ? "attr" : "animate"]({
              d: a.getConnectorPath()
            });
            A.attr("visibility", I);
          } else A && (a.connector = A.destroy());
        }
      }));
    }, P.pie.prototype.placeDataLabels = function () {
      this.points.forEach(function (d) {
        var c = d.dataLabel,
            e;
        c && d.visible && ((e = c._pos) ? (c.sideOverflow && (c._attr.width = Math.max(c.getBBox().width - c.sideOverflow, 0), c.css({
          width: c._attr.width + "px",
          textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
        }), c.shortened = !0), c.attr(c._attr), c[c.moved ? "animate" : "attr"](e), c.moved = !0) : c && c.attr({
          y: -9999
        }));
        delete d.distributeBox;
      }, this);
    }, P.pie.prototype.alignDataLabel = g, P.pie.prototype.verifyDataLabelOverflow = function (d) {
      var c = this.center,
          e = this.options,
          g = e.center,
          f = e.minSize || 80,
          a = null !== e.size;

      if (!a) {
        if (null !== g[0]) var h = Math.max(c[2] - Math.max(d[1], d[3]), f);else h = Math.max(c[2] - d[1] - d[3], f), c[0] += (d[3] - d[1]) / 2;
        null !== g[1] ? h = I(h, f, c[2] - Math.max(d[0], d[2])) : (h = I(h, f, c[2] - d[0] - d[2]), c[1] += (d[0] - d[2]) / 2);
        h < c[2] ? (c[2] = h, c[3] = Math.min(D(e.innerSize || 0, h), h), this.translate(c), this.drawDataLabels && this.drawDataLabels()) : a = !0;
      }

      return a;
    });
    P.column && (P.column.prototype.alignDataLabel = function (d, c, g, h, f) {
      var a = this.chart.inverted,
          e = d.series,
          k = d.dlBox || d.shapeArgs,
          n = t(d.below, d.plotY > t(this.translatedThreshold, e.yAxis.len)),
          r = t(g.inside, !!this.options.stacking);
      k && (h = J(k), 0 > h.y && (h.height += h.y, h.y = 0), k = h.y + h.height - e.yAxis.len, 0 < k && k < h.height && (h.height -= k), a && (h = {
        x: e.yAxis.len - h.y - h.height,
        y: e.xAxis.len - h.x - h.width,
        width: h.height,
        height: h.width
      }), r || (a ? (h.x += n ? 0 : h.width, h.width = 0) : (h.y += n ? h.height : 0, h.height = 0)));
      g.align = t(g.align, !a || r ? "center" : n ? "right" : "left");
      g.verticalAlign = t(g.verticalAlign, a || r ? "middle" : n ? "top" : "bottom");
      q.prototype.alignDataLabel.call(this, d, c, g, h, f);
      g.inside && d.contrastColor && c.css({
        color: d.contrastColor
      });
    });
  });
  S(r, "modules/overlapping-datalabels.src.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.addEvent,
        u = g.fireEvent,
        I = g.isArray,
        M = g.objectEach,
        E = g.pick;
    d = d.Chart;
    r(d, "render", function () {
      var d = [];
      (this.labelCollectors || []).forEach(function (g) {
        d = d.concat(g());
      });
      (this.yAxis || []).forEach(function (g) {
        g.options.stackLabels && !g.options.stackLabels.allowOverlap && M(g.stacks, function (g) {
          M(g, function (g) {
            d.push(g.label);
          });
        });
      });
      (this.series || []).forEach(function (g) {
        var r = g.options.dataLabels;
        g.visible && (!1 !== r.enabled || g._hasPointLabels) && (g.nodes || g.points).forEach(function (g) {
          g.visible && (I(g.dataLabels) ? g.dataLabels : g.dataLabel ? [g.dataLabel] : []).forEach(function (r) {
            var t = r.options;
            r.labelrank = E(t.labelrank, g.labelrank, g.shapeArgs && g.shapeArgs.height);
            t.allowOverlap || d.push(r);
          });
        });
      });
      this.hideOverlappingLabels(d);
    });

    d.prototype.hideOverlappingLabels = function (d) {
      var g = this,
          r = d.length,
          y = g.renderer,
          t,
          A,
          h,
          E = !1;

      var q = function (c) {
        var d = c.box ? 0 : c.padding || 0;
        var e = 0;

        if (c && (!c.alignAttr || c.placed)) {
          var f = c.alignAttr || {
            x: c.attr("x"),
            y: c.attr("y")
          };
          var a = c.parentGroup;
          c.width || (e = c.getBBox(), c.width = e.width, c.height = e.height, e = y.fontMetrics(null, c.element).h);
          return {
            x: f.x + (a.translateX || 0) + d,
            y: f.y + (a.translateY || 0) + d - e,
            width: c.width - 2 * d,
            height: c.height - 2 * d
          };
        }
      };

      for (A = 0; A < r; A++) if (t = d[A]) t.oldOpacity = t.opacity, t.newOpacity = 1, t.absoluteBox = q(t);

      d.sort(function (c, d) {
        return (d.labelrank || 0) - (c.labelrank || 0);
      });

      for (A = 0; A < r; A++) {
        var I = (q = d[A]) && q.absoluteBox;

        for (t = A + 1; t < r; ++t) {
          var e = (h = d[t]) && h.absoluteBox;
          !I || !e || q === h || 0 === q.newOpacity || 0 === h.newOpacity || e.x > I.x + I.width || e.x + e.width < I.x || e.y > I.y + I.height || e.y + e.height < I.y || ((q.labelrank < h.labelrank ? q : h).newOpacity = 0);
        }
      }

      d.forEach(function (c) {
        var d;

        if (c) {
          var e = c.newOpacity;
          c.oldOpacity !== e && (c.alignAttr && c.placed ? (e ? c.show(!0) : d = function () {
            c.hide(!0);
            c.placed = !1;
          }, E = !0, c.alignAttr.opacity = e, c[c.isOld ? "animate" : "attr"](c.alignAttr, null, d), u(g, "afterHideOverlappingLabel")) : c.attr({
            opacity: e
          }));
          c.isOld = !0;
        }
      });
      E && u(g, "afterHideAllOverlappingLabels");
    };
  });
  S(r, "parts/Interaction.js", [r["parts/Globals.js"], r["parts/Legend.js"], r["parts/Point.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    var I = u.addEvent,
        M = u.createElement,
        E = u.css,
        A = u.defined,
        G = u.extend,
        J = u.fireEvent,
        y = u.isArray,
        t = u.isFunction,
        D = u.isObject,
        h = u.merge,
        N = u.objectEach,
        q = u.pick;
    u = d.Chart;
    var P = d.defaultOptions,
        e = d.defaultPlotOptions,
        c = d.hasTouch,
        k = d.Series,
        n = d.seriesTypes,
        f = d.svg;
    d = d.TrackerMixin = {
      drawTrackerPoint: function () {
        var a = this,
            d = a.chart,
            e = d.pointer,
            f = function (a) {
          var c = e.getPointFromEvent(a);
          "undefined" !== typeof c && (e.isDirectTouch = !0, c.onMouseOver(a));
        },
            g;

        a.points.forEach(function (a) {
          g = y(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];
          a.graphic && (a.graphic.element.point = a);
          g.forEach(function (c) {
            c.div ? c.div.point = a : c.element.point = a;
          });
        });
        a._hasTracking || (a.trackerGroups.forEach(function (g) {
          if (a[g]) {
            a[g].addClass("highcharts-tracker").on("mouseover", f).on("mouseout", function (a) {
              e.onTrackerMouseOut(a);
            });
            if (c) a[g].on("touchstart", f);
            !d.styledMode && a.options.cursor && a[g].css(E).css({
              cursor: a.options.cursor
            });
          }
        }), a._hasTracking = !0);
        J(this, "afterDrawTracker");
      },
      drawTrackerGraph: function () {
        var a = this,
            d = a.options,
            e = d.trackByArea,
            g = [].concat(e ? a.areaPath : a.graphPath),
            h = g.length,
            k = a.chart,
            n = k.pointer,
            q = k.renderer,
            r = k.options.tooltip.snap,
            t = a.tracker,
            p,
            b = function () {
          if (k.hoverSeries !== a) a.onMouseOver();
        },
            u = "rgba(192,192,192," + (f ? .0001 : .002) + ")";

        if (h && !e) for (p = h + 1; p--;) "M" === g[p] && g.splice(p + 1, 0, g[p + 1] - r, g[p + 2], "L"), (p && "M" === g[p] || p === h) && g.splice(p, 0, "L", g[p - 2] + r, g[p - 1]);
        t ? t.attr({
          d: g
        }) : a.graph && (a.tracker = q.path(g).attr({
          visibility: a.visible ? "visible" : "hidden",
          zIndex: 2
        }).addClass(e ? "highcharts-tracker-area" : "highcharts-tracker-line").add(a.group), k.styledMode || a.tracker.attr({
          "stroke-linejoin": "round",
          stroke: u,
          fill: e ? u : "none",
          "stroke-width": a.graph.strokeWidth() + (e ? 0 : 2 * r)
        }), [a.tracker, a.markerGroup].forEach(function (a) {
          a.addClass("highcharts-tracker").on("mouseover", b).on("mouseout", function (a) {
            n.onTrackerMouseOut(a);
          });
          d.cursor && !k.styledMode && a.css({
            cursor: d.cursor
          });
          if (c) a.on("touchstart", b);
        }));
        J(this, "afterDrawTracker");
      }
    };
    n.column && (n.column.prototype.drawTracker = d.drawTrackerPoint);
    n.pie && (n.pie.prototype.drawTracker = d.drawTrackerPoint);
    n.scatter && (n.scatter.prototype.drawTracker = d.drawTrackerPoint);
    G(g.prototype, {
      setItemEvents: function (a, c, d) {
        var e = this,
            f = e.chart.renderer.boxWrapper,
            g = a instanceof r,
            k = "highcharts-legend-" + (g ? "point" : "series") + "-active",
            l = e.chart.styledMode;
        (d ? [c, a.legendSymbol] : [a.legendGroup]).forEach(function (d) {
          if (d) d.on("mouseover", function () {
            a.visible && e.allItems.forEach(function (c) {
              a !== c && c.setState("inactive", !g);
            });
            a.setState("hover");
            a.visible && f.addClass(k);
            l || c.css(e.options.itemHoverStyle);
          }).on("mouseout", function () {
            e.chart.styledMode || c.css(h(a.visible ? e.itemStyle : e.itemHiddenStyle));
            e.allItems.forEach(function (c) {
              a !== c && c.setState("", !g);
            });
            f.removeClass(k);
            a.setState();
          }).on("click", function (c) {
            var d = function () {
              a.setVisible && a.setVisible();
              e.allItems.forEach(function (b) {
                a !== b && b.setState(a.visible ? "inactive" : "", !g);
              });
            };

            f.removeClass(k);
            c = {
              browserEvent: c
            };
            a.firePointEvent ? a.firePointEvent("legendItemClick", c, d) : J(a, "legendItemClick", c, d);
          });
        });
      },
      createCheckboxForItem: function (a) {
        a.checkbox = M("input", {
          type: "checkbox",
          className: "highcharts-legend-checkbox",
          checked: a.selected,
          defaultChecked: a.selected
        }, this.options.itemCheckboxStyle, this.chart.container);
        I(a.checkbox, "click", function (c) {
          J(a.series || a, "checkboxClick", {
            checked: c.target.checked,
            item: a
          }, function () {
            a.select();
          });
        });
      }
    });
    G(u.prototype, {
      showResetZoom: function () {
        function a() {
          c.zoomOut();
        }

        var c = this,
            d = P.lang,
            e = c.options.chart.resetZoomButton,
            f = e.theme,
            g = f.states,
            h = "chart" === e.relativeTo || "spaceBox" === e.relativeTo ? null : "plotBox";
        J(this, "beforeShowResetZoom", null, function () {
          c.resetZoomButton = c.renderer.button(d.resetZoom, null, null, a, f, g && g.hover).attr({
            align: e.position.align,
            title: d.resetZoomTitle
          }).addClass("highcharts-reset-zoom").add().align(e.position, !1, h);
        });
        J(this, "afterShowResetZoom");
      },
      zoomOut: function () {
        J(this, "selection", {
          resetSelection: !0
        }, this.zoom);
      },
      zoom: function (a) {
        var c = this,
            d,
            e = c.pointer,
            f = !1,
            g = c.inverted ? e.mouseDownX : e.mouseDownY;
        !a || a.resetSelection ? (c.axes.forEach(function (a) {
          d = a.zoom();
        }), e.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {
          var h = a.axis,
              k = c.inverted ? h.left : h.top,
              l = c.inverted ? k + h.width : k + h.height,
              b = h.isXAxis,
              n = !1;
          if (!b && g >= k && g <= l || b || !A(g)) n = !0;
          e[b ? "zoomX" : "zoomY"] && n && (d = h.zoom(a.min, a.max), h.displayBtn && (f = !0));
        });
        var h = c.resetZoomButton;
        f && !h ? c.showResetZoom() : !f && D(h) && (c.resetZoomButton = h.destroy());
        d && c.redraw(q(c.options.chart.animation, a && a.animation, 100 > c.pointCount));
      },
      pan: function (a, c) {
        var d = this,
            e = d.hoverPoints,
            f = d.options.chart,
            g;
        c = "object" === typeof c ? c : {
          enabled: c,
          type: "x"
        };
        f && f.panning && (f.panning = c);
        var h = c.type;
        J(this, "pan", {
          originalEvent: a
        }, function () {
          e && e.forEach(function (a) {
            a.setState();
          });
          var c = [1];
          "xy" === h ? c = [1, 0] : "y" === h && (c = [0]);
          c.forEach(function (c) {
            var e = d[c ? "xAxis" : "yAxis"][0],
                f = e.options,
                b = e.horiz,
                h = a[b ? "chartX" : "chartY"];
            b = b ? "mouseDownX" : "mouseDownY";
            var k = d[b],
                l = (e.pointRange || 0) / 2,
                n = e.reversed && !d.inverted || !e.reversed && d.inverted ? -1 : 1,
                q = e.getExtremes(),
                v = e.toValue(k - h, !0) + l * n;
            n = e.toValue(k + e.len - h, !0) - l * n;
            var m = n < v;
            k = m ? n : v;
            v = m ? v : n;
            n = Math.min(q.dataMin, l ? q.min : e.toValue(e.toPixels(q.min) - e.minPixelPadding));
            l = Math.max(q.dataMax, l ? q.max : e.toValue(e.toPixels(q.max) + e.minPixelPadding));

            if (!f.ordinal) {
              c && (f = n - k, 0 < f && (v += f, k = n), f = v - l, 0 < f && (v = l, k -= f));
              if (e.series.length && k !== q.min && v !== q.max && c || e.panningState && k >= e.panningState.startMin && v <= e.panningState.startMax) e.setExtremes(k, v, !1, !1, {
                trigger: "pan"
              }), g = !0;
              d[b] = h;
            }
          });
          g && d.redraw(!1);
          E(d.container, {
            cursor: "move"
          });
        });
      }
    });
    G(r.prototype, {
      select: function (a, c) {
        var d = this,
            e = d.series,
            f = e.chart;
        this.selectedStaging = a = q(a, !d.selected);
        d.firePointEvent(a ? "select" : "unselect", {
          accumulate: c
        }, function () {
          d.selected = d.options.selected = a;
          e.options.data[e.data.indexOf(d)] = d.options;
          d.setState(a && "select");
          c || f.getSelectedPoints().forEach(function (a) {
            var c = a.series;
            a.selected && a !== d && (a.selected = a.options.selected = !1, c.options.data[c.data.indexOf(a)] = a.options, a.setState(f.hoverPoints && c.options.inactiveOtherPoints ? "inactive" : ""), a.firePointEvent("unselect"));
          });
        });
        delete this.selectedStaging;
      },
      onMouseOver: function (a) {
        var c = this.series.chart,
            d = c.pointer;
        a = a ? d.normalize(a) : d.getChartCoordinatesFromPoint(this, c.inverted);
        d.runPointActions(a, this);
      },
      onMouseOut: function () {
        var a = this.series.chart;
        this.firePointEvent("mouseOut");
        this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (a) {
          a.setState();
        });
        a.hoverPoints = a.hoverPoint = null;
      },
      importEvents: function () {
        if (!this.hasImportedEvents) {
          var a = this,
              c = h(a.series.options.point, a.options).events;
          a.events = c;
          N(c, function (c, d) {
            t(c) && I(a, d, c);
          });
          this.hasImportedEvents = !0;
        }
      },
      setState: function (a, c) {
        var d = this.series,
            f = this.state,
            g = d.options.states[a || "normal"] || {},
            h = e[d.type].marker && d.options.marker,
            k = h && !1 === h.enabled,
            l = h && h.states && h.states[a || "normal"] || {},
            n = !1 === l.enabled,
            r = d.stateMarkerGraphic,
            p = this.marker || {},
            b = d.chart,
            t = d.halo,
            u,
            y = h && d.markerAttribs;
        a = a || "";

        if (!(a === this.state && !c || this.selected && "select" !== a || !1 === g.enabled || a && (n || k && !1 === l.enabled) || a && p.states && p.states[a] && !1 === p.states[a].enabled)) {
          this.state = a;
          y && (u = d.markerAttribs(this, a));

          if (this.graphic) {
            f && this.graphic.removeClass("highcharts-point-" + f);
            a && this.graphic.addClass("highcharts-point-" + a);

            if (!b.styledMode) {
              var A = d.pointAttribs(this, a);
              var D = q(b.options.chart.animation, g.animation);
              d.options.inactiveOtherPoints && ((this.dataLabels || []).forEach(function (a) {
                a && a.animate({
                  opacity: A.opacity
                }, D);
              }), this.connector && this.connector.animate({
                opacity: A.opacity
              }, D));
              this.graphic.animate(A, D);
            }

            u && this.graphic.animate(u, q(b.options.chart.animation, l.animation, h.animation));
            r && r.hide();
          } else {
            if (a && l) {
              f = p.symbol || d.symbol;
              r && r.currentSymbol !== f && (r = r.destroy());
              if (u) if (r) r[c ? "animate" : "attr"]({
                x: u.x,
                y: u.y
              });else f && (d.stateMarkerGraphic = r = b.renderer.symbol(f, u.x, u.y, u.width, u.height).add(d.markerGroup), r.currentSymbol = f);
              !b.styledMode && r && r.attr(d.pointAttribs(this, a));
            }

            r && (r[a && this.isInside ? "show" : "hide"](), r.element.point = this);
          }

          a = g.halo;
          g = (r = this.graphic || r) && r.visibility || "inherit";
          a && a.size && r && "hidden" !== g && !this.isCluster ? (t || (d.halo = t = b.renderer.path().add(r.parentGroup)), t.show()[c ? "animate" : "attr"]({
            d: this.haloPath(a.size)
          }), t.attr({
            "class": "highcharts-halo highcharts-color-" + q(this.colorIndex, d.colorIndex) + (this.className ? " " + this.className : ""),
            visibility: g,
            zIndex: -1
          }), t.point = this, b.styledMode || t.attr(G({
            fill: this.color || d.color,
            "fill-opacity": a.opacity
          }, a.attributes))) : t && t.point && t.point.haloPath && t.animate({
            d: t.point.haloPath(0)
          }, null, t.hide);
          J(this, "afterSetState");
        }
      },
      haloPath: function (a) {
        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);
      }
    });
    G(k.prototype, {
      onMouseOver: function () {
        var a = this.chart,
            c = a.hoverSeries;
        if (c && c !== this) c.onMouseOut();
        this.options.events.mouseOver && J(this, "mouseOver");
        this.setState("hover");
        a.hoverSeries = this;
      },
      onMouseOut: function () {
        var a = this.options,
            c = this.chart,
            d = c.tooltip,
            e = c.hoverPoint;
        c.hoverSeries = null;
        if (e) e.onMouseOut();
        this && a.events.mouseOut && J(this, "mouseOut");
        !d || this.stickyTracking || d.shared && !this.noSharedTooltip || d.hide();
        c.series.forEach(function (a) {
          a.setState("", !0);
        });
      },
      setState: function (a, c) {
        var d = this,
            e = d.options,
            f = d.graph,
            g = e.inactiveOtherPoints,
            h = e.states,
            k = e.lineWidth,
            l = e.opacity,
            n = q(h[a || "normal"] && h[a || "normal"].animation, d.chart.options.chart.animation);
        e = 0;
        a = a || "";

        if (d.state !== a && ([d.group, d.markerGroup, d.dataLabelsGroup].forEach(function (c) {
          c && (d.state && c.removeClass("highcharts-series-" + d.state), a && c.addClass("highcharts-series-" + a));
        }), d.state = a, !d.chart.styledMode)) {
          if (h[a] && !1 === h[a].enabled) return;
          a && (k = h[a].lineWidth || k + (h[a].lineWidthPlus || 0), l = q(h[a].opacity, l));
          if (f && !f.dashstyle) for (h = {
            "stroke-width": k
          }, f.animate(h, n); d["zone-graph-" + e];) d["zone-graph-" + e].attr(h), e += 1;
          g || [d.group, d.markerGroup, d.dataLabelsGroup, d.labelBySeries].forEach(function (a) {
            a && a.animate({
              opacity: l
            }, n);
          });
        }

        c && g && d.points && d.setAllPointsToState(a);
      },
      setAllPointsToState: function (a) {
        this.points.forEach(function (c) {
          c.setState && c.setState(a);
        });
      },
      setVisible: function (a, c) {
        var d = this,
            e = d.chart,
            f = d.legendItem,
            g = e.options.chart.ignoreHiddenSeries,
            h = d.visible;
        var k = (d.visible = a = d.options.visible = d.userOptions.visible = "undefined" === typeof a ? !h : a) ? "show" : "hide";
        ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (a) {
          if (d[a]) d[a][k]();
        });
        if (e.hoverSeries === d || (e.hoverPoint && e.hoverPoint.series) === d) d.onMouseOut();
        f && e.legend.colorizeItem(d, a);
        d.isDirty = !0;
        d.options.stacking && e.series.forEach(function (a) {
          a.options.stacking && a.visible && (a.isDirty = !0);
        });
        d.linkedSeries.forEach(function (c) {
          c.setVisible(a, !1);
        });
        g && (e.isDirtyBox = !0);
        J(d, k);
        !1 !== c && e.redraw();
      },
      show: function () {
        this.setVisible(!0);
      },
      hide: function () {
        this.setVisible(!1);
      },
      select: function (a) {
        this.selected = a = this.options.selected = "undefined" === typeof a ? !this.selected : a;
        this.checkbox && (this.checkbox.checked = a);
        J(this, a ? "select" : "unselect");
      },
      drawTracker: d.drawTrackerGraph
    });
  });
  S(r, "parts/Responsive.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.find,
        u = g.isArray,
        I = g.isObject,
        M = g.merge,
        E = g.objectEach,
        A = g.pick,
        G = g.splat,
        J = g.uniqueKey;
    d = d.Chart;

    d.prototype.setResponsive = function (d, g) {
      var t = this.options.responsive,
          h = [],
          u = this.currentResponsive;
      !g && t && t.rules && t.rules.forEach(function (d) {
        "undefined" === typeof d._id && (d._id = J());
        this.matchResponsiveRule(d, h);
      }, this);
      g = M.apply(0, h.map(function (d) {
        return r(t.rules, function (g) {
          return g._id === d;
        }).chartOptions;
      }));
      g.isResponsiveOptions = !0;
      h = h.toString() || void 0;
      h !== (u && u.ruleIds) && (u && this.update(u.undoOptions, d, !0), h ? (u = this.currentOptions(g), u.isResponsiveOptions = !0, this.currentResponsive = {
        ruleIds: h,
        mergedOptions: g,
        undoOptions: u
      }, this.update(g, d, !0)) : this.currentResponsive = void 0);
    };

    d.prototype.matchResponsiveRule = function (d, g) {
      var r = d.condition;
      (r.callback || function () {
        return this.chartWidth <= A(r.maxWidth, Number.MAX_VALUE) && this.chartHeight <= A(r.maxHeight, Number.MAX_VALUE) && this.chartWidth >= A(r.minWidth, 0) && this.chartHeight >= A(r.minHeight, 0);
      }).call(this) && g.push(d._id);
    };

    d.prototype.currentOptions = function (d) {
      function g(d, h, t, e) {
        var c;
        E(d, function (d, n) {
          if (!e && -1 < r.collectionsWithUpdate.indexOf(n)) for (d = G(d), t[n] = [], c = 0; c < d.length; c++) h[n][c] && (t[n][c] = {}, g(d[c], h[n][c], t[n][c], e + 1));else I(d) ? (t[n] = u(d) ? [] : {}, g(d, h[n] || {}, t[n], e + 1)) : t[n] = "undefined" === typeof h[n] ? null : h[n];
        });
      }

      var r = this,
          h = {};
      g(d, this.options, h, 0);
      return h;
    };
  });
  S(r, "masters/highcharts.src.js", [r["parts/Globals.js"]], function (d) {
    return d;
  });
  r["masters/highcharts.src.js"]._modules = r;
  return r["masters/highcharts.src.js"];
});

/***/ }),

/***/ "./node_modules/highcharts/modules/exporting.js":
/*!******************************************************!*\
  !*** ./node_modules/highcharts/modules/exporting.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 Highcharts JS v8.0.4 (2020-03-10)

 Exporting module

 (c) 2010-2019 Torstein Honsi

 License: www.highcharts.com/license
*/
(function (e) {
   true && module.exports ? (e["default"] = e, module.exports = e) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! highcharts */ "./node_modules/highcharts/highcharts.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (m) {
    e(m);
    e.Highcharts = m;
    return e;
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(function (e) {
  function m(f, g, e, n) {
    f.hasOwnProperty(g) || (f[g] = n.apply(null, e));
  }

  e = e ? e._modules : {};
  m(e, "modules/full-screen.src.js", [e["parts/Globals.js"]], function (f) {
    var g = f.addEvent,
        e = f.Chart,
        n = function () {
      function g(h) {
        this.chart = h;
        this.isOpen = !1;
        h.container.parentNode instanceof Element && (h = h.container.parentNode, this.browserProps || ("function" === typeof h.requestFullscreen ? this.browserProps = {
          fullscreenChange: "fullscreenchange",
          requestFullscreen: "requestFullscreen",
          exitFullscreen: "exitFullscreen"
        } : h.mozRequestFullScreen ? this.browserProps = {
          fullscreenChange: "mozfullscreenchange",
          requestFullscreen: "mozRequestFullScreen",
          exitFullscreen: "mozCancelFullScreen"
        } : h.webkitRequestFullScreen ? this.browserProps = {
          fullscreenChange: "webkitfullscreenchange",
          requestFullscreen: "webkitRequestFullScreen",
          exitFullscreen: "webkitExitFullscreen"
        } : h.msRequestFullscreen && (this.browserProps = {
          fullscreenChange: "MSFullscreenChange",
          requestFullscreen: "msRequestFullscreen",
          exitFullscreen: "msExitFullscreen"
        })));
      }

      g.prototype.close = function () {
        var h = this.chart;
        if (this.isOpen && this.browserProps && h.container.ownerDocument instanceof Document) h.container.ownerDocument[this.browserProps.exitFullscreen]();
        this.unbindFullscreenEvent && this.unbindFullscreenEvent();
        this.isOpen = !1;
        this.setButtonText();
      };

      g.prototype.open = function () {
        var h = this,
            g = h.chart;

        if (h.browserProps) {
          h.unbindFullscreenEvent = f.addEvent(g.container.ownerDocument, h.browserProps.fullscreenChange, function () {
            h.isOpen ? (h.isOpen = !1, h.close()) : (h.isOpen = !0, h.setButtonText());
          });

          if (g.container.parentNode instanceof Element) {
            var e = g.container.parentNode[h.browserProps.requestFullscreen]();
            if (e) e["catch"](function () {
              alert("Full screen is not supported inside a frame.");
            });
          }

          f.addEvent(g, "destroy", h.unbindFullscreenEvent);
        }
      };

      g.prototype.setButtonText = function () {
        var h,
            g = this.chart,
            f = g.exportDivElements,
            e = g.options.exporting,
            n = null === (h = null === e || void 0 === e ? void 0 : e.buttons) || void 0 === h ? void 0 : h.contextButton.menuItems;
        h = g.options.lang;
        (null === e || void 0 === e ? 0 : e.menuItemDefinitions) && (null === h || void 0 === h ? 0 : h.exitFullscreen) && h.viewFullscreen && n && f && f.length && (f[n.indexOf("viewFullscreen")].innerHTML = this.isOpen ? h.exitFullscreen : e.menuItemDefinitions.viewFullscreen.text || h.viewFullscreen);
      };

      g.prototype.toggle = function () {
        this.isOpen ? this.close() : this.open();
      };

      return g;
    }();

    f.Fullscreen = n;
    g(e, "beforeRender", function () {
      this.fullscreen = new f.Fullscreen(this);
    });
    return f.Fullscreen;
  });
  m(e, "mixins/navigation.js", [], function () {
    return {
      initUpdate: function (f) {
        f.navigation || (f.navigation = {
          updates: [],
          update: function (g, f) {
            this.updates.forEach(function (e) {
              e.update.call(e.context, g, f);
            });
          }
        });
      },
      addUpdate: function (f, g) {
        g.navigation || this.initUpdate(g);
        g.navigation.updates.push({
          update: f,
          context: g
        });
      }
    };
  });
  m(e, "modules/exporting.src.js", [e["parts/Globals.js"], e["parts/Utilities.js"], e["mixins/navigation.js"]], function (f, g, e) {
    var n = g.addEvent,
        u = g.css,
        h = g.createElement,
        m = g.discardElement,
        x = g.extend,
        I = g.find,
        B = g.fireEvent,
        J = g.isObject,
        p = g.merge,
        E = g.objectEach,
        q = g.pick,
        K = g.removeEvent,
        L = g.uniqueKey,
        w = f.defaultOptions,
        y = f.doc,
        C = f.Chart,
        M = f.isTouchDevice,
        z = f.win,
        G = z.navigator.userAgent,
        F = f.SVGRenderer,
        H = f.Renderer.prototype.symbols,
        N = /Edge\/|Trident\/|MSIE /.test(G),
        O = /firefox/i.test(G);
    x(w.lang, {
      viewFullscreen: "View in full screen",
      exitFullscreen: "Exit from full screen",
      printChart: "Print chart",
      downloadPNG: "Download PNG image",
      downloadJPEG: "Download JPEG image",
      downloadPDF: "Download PDF document",
      downloadSVG: "Download SVG vector image",
      contextButtonTitle: "Chart context menu"
    });
    w.navigation || (w.navigation = {});
    p(!0, w.navigation, {
      buttonOptions: {
        theme: {},
        symbolSize: 14,
        symbolX: 12.5,
        symbolY: 10.5,
        align: "right",
        buttonSpacing: 3,
        height: 22,
        verticalAlign: "top",
        width: 24
      }
    });
    p(!0, w.navigation, {
      menuStyle: {
        border: "1px solid #999999",
        background: "#ffffff",
        padding: "5px 0"
      },
      menuItemStyle: {
        padding: "0.5em 1em",
        color: "#333333",
        background: "none",
        fontSize: M ? "14px" : "11px",
        transition: "background 250ms, color 250ms"
      },
      menuItemHoverStyle: {
        background: "#335cad",
        color: "#ffffff"
      },
      buttonOptions: {
        symbolFill: "#666666",
        symbolStroke: "#666666",
        symbolStrokeWidth: 3,
        theme: {
          padding: 5
        }
      }
    });
    w.exporting = {
      type: "image/png",
      url: "https://export.highcharts.com/",
      printMaxWidth: 780,
      scale: 2,
      buttons: {
        contextButton: {
          className: "highcharts-contextbutton",
          menuClassName: "highcharts-contextmenu",
          symbol: "menu",
          titleKey: "contextButtonTitle",
          menuItems: "viewFullscreen printChart separator downloadPNG downloadJPEG downloadPDF downloadSVG".split(" ")
        }
      },
      menuItemDefinitions: {
        viewFullscreen: {
          textKey: "viewFullscreen",
          onclick: function () {
            this.fullscreen.toggle();
          }
        },
        printChart: {
          textKey: "printChart",
          onclick: function () {
            this.print();
          }
        },
        separator: {
          separator: !0
        },
        downloadPNG: {
          textKey: "downloadPNG",
          onclick: function () {
            this.exportChart();
          }
        },
        downloadJPEG: {
          textKey: "downloadJPEG",
          onclick: function () {
            this.exportChart({
              type: "image/jpeg"
            });
          }
        },
        downloadPDF: {
          textKey: "downloadPDF",
          onclick: function () {
            this.exportChart({
              type: "application/pdf"
            });
          }
        },
        downloadSVG: {
          textKey: "downloadSVG",
          onclick: function () {
            this.exportChart({
              type: "image/svg+xml"
            });
          }
        }
      }
    };

    f.post = function (a, b, c) {
      var d = h("form", p({
        method: "post",
        action: a,
        enctype: "multipart/form-data"
      }, c), {
        display: "none"
      }, y.body);
      E(b, function (a, b) {
        h("input", {
          type: "hidden",
          name: b,
          value: a
        }, null, d);
      });
      d.submit();
      m(d);
    };

    f.isSafari && f.win.matchMedia("print").addListener(function (a) {
      f.printingChart && (a.matches ? f.printingChart.beforePrint() : f.printingChart.afterPrint());
    });
    x(C.prototype, {
      sanitizeSVG: function (a, b) {
        var c = a.indexOf("</svg>") + 6,
            d = a.substr(c);
        a = a.substr(0, c);
        b && b.exporting && b.exporting.allowHTML && d && (d = '<foreignObject x="0" y="0" width="' + b.chart.width + '" height="' + b.chart.height + '"><body xmlns="http://www.w3.org/1999/xhtml">' + d + "</body></foreignObject>", a = a.replace("</svg>", d + "</svg>"));
        a = a.replace(/zIndex="[^"]+"/g, "").replace(/symbolName="[^"]+"/g, "").replace(/jQuery[0-9]+="[^"]+"/g, "").replace(/url\(("|&quot;)(.*?)("|&quot;);?\)/g, "url($2)").replace(/url\([^#]+#/g, "url(#").replace(/<svg /, '<svg xmlns:xlink="http://www.w3.org/1999/xlink" ').replace(/ (|NS[0-9]+:)href=/g, " xlink:href=").replace(/\n/, " ").replace(/(fill|stroke)="rgba\(([ 0-9]+,[ 0-9]+,[ 0-9]+),([ 0-9\.]+)\)"/g, '$1="rgb($2)" $1-opacity="$3"').replace(/&nbsp;/g, "\u00a0").replace(/&shy;/g, "\u00ad");
        this.ieSanitizeSVG && (a = this.ieSanitizeSVG(a));
        return a;
      },
      getChartHTML: function () {
        this.styledMode && this.inlineStyles();
        return this.container.innerHTML;
      },
      getSVG: function (a) {
        var b,
            c = p(this.options, a);
        c.plotOptions = p(this.userOptions.plotOptions, a && a.plotOptions);
        c.time = p(this.userOptions.time, a && a.time);
        var d = h("div", null, {
          position: "absolute",
          top: "-9999em",
          width: this.chartWidth + "px",
          height: this.chartHeight + "px"
        }, y.body);
        var g = this.renderTo.style.width;
        var e = this.renderTo.style.height;
        g = c.exporting.sourceWidth || c.chart.width || /px$/.test(g) && parseInt(g, 10) || (c.isGantt ? 800 : 600);
        e = c.exporting.sourceHeight || c.chart.height || /px$/.test(e) && parseInt(e, 10) || 400;
        x(c.chart, {
          animation: !1,
          renderTo: d,
          forExport: !0,
          renderer: "SVGRenderer",
          width: g,
          height: e
        });
        c.exporting.enabled = !1;
        delete c.data;
        c.series = [];
        this.series.forEach(function (a) {
          b = p(a.userOptions, {
            animation: !1,
            enableMouseTracking: !1,
            showCheckbox: !1,
            visible: a.visible
          });
          b.isInternal || c.series.push(b);
        });
        this.axes.forEach(function (a) {
          a.userOptions.internalKey || (a.userOptions.internalKey = L());
        });
        var r = new f.Chart(c, this.callback);
        a && ["xAxis", "yAxis", "series"].forEach(function (b) {
          var d = {};
          a[b] && (d[b] = a[b], r.update(d));
        });
        this.axes.forEach(function (a) {
          var b = I(r.axes, function (b) {
            return b.options.internalKey === a.userOptions.internalKey;
          }),
              d = a.getExtremes(),
              c = d.userMin;
          d = d.userMax;
          b && ("undefined" !== typeof c && c !== b.min || "undefined" !== typeof d && d !== b.max) && b.setExtremes(c, d, !0, !1);
        });
        g = r.getChartHTML();
        B(this, "getSVG", {
          chartCopy: r
        });
        g = this.sanitizeSVG(g, c);
        c = null;
        r.destroy();
        m(d);
        return g;
      },
      getSVGForExport: function (a, b) {
        var c = this.options.exporting;
        return this.getSVG(p({
          chart: {
            borderRadius: 0
          }
        }, c.chartOptions, b, {
          exporting: {
            sourceWidth: a && a.sourceWidth || c.sourceWidth,
            sourceHeight: a && a.sourceHeight || c.sourceHeight
          }
        }));
      },
      getFilename: function () {
        var a = this.userOptions.title && this.userOptions.title.text,
            b = this.options.exporting.filename;
        if (b) return b.replace(/\//g, "-");
        "string" === typeof a && (b = a.toLowerCase().replace(/<\/?[^>]+(>|$)/g, "").replace(/[\s_]+/g, "-").replace(/[^a-z0-9\-]/g, "").replace(/^[\-]+/g, "").replace(/[\-]+/g, "-").substr(0, 24).replace(/[\-]+$/g, ""));
        if (!b || 5 > b.length) b = "chart";
        return b;
      },
      exportChart: function (a, b) {
        b = this.getSVGForExport(a, b);
        a = p(this.options.exporting, a);
        f.post(a.url, {
          filename: a.filename ? a.filename.replace(/\//g, "-") : this.getFilename(),
          type: a.type,
          width: a.width || 0,
          scale: a.scale,
          svg: b
        }, a.formAttributes);
      },
      moveContainers: function (a) {
        (this.fixedDiv ? [this.fixedDiv, this.scrollingContainer] : [this.container]).forEach(function (b) {
          a.appendChild(b);
        });
      },
      beforePrint: function () {
        var a = y.body,
            b = this.options.exporting.printMaxWidth,
            c = {
          childNodes: a.childNodes,
          origDisplay: [],
          resetParams: void 0
        };
        this.isPrinting = !0;
        this.pointer.reset(null, 0);
        B(this, "beforePrint");
        b && this.chartWidth > b && (c.resetParams = [this.options.chart.width, void 0, !1], this.setSize(b, void 0, !1));
        [].forEach.call(c.childNodes, function (a, b) {
          1 === a.nodeType && (c.origDisplay[b] = a.style.display, a.style.display = "none");
        });
        this.moveContainers(a);
        this.printReverseInfo = c;
      },
      afterPrint: function () {
        if (this.printReverseInfo) {
          var a = this.printReverseInfo.childNodes,
              b = this.printReverseInfo.origDisplay,
              c = this.printReverseInfo.resetParams;
          this.moveContainers(this.renderTo);
          [].forEach.call(a, function (a, c) {
            1 === a.nodeType && (a.style.display = b[c] || "");
          });
          this.isPrinting = !1;
          c && this.setSize.apply(this, c);
          delete this.printReverseInfo;
          delete f.printingChart;
          B(this, "afterPrint");
        }
      },
      print: function () {
        var a = this;
        a.isPrinting || (f.printingChart = a, f.isSafari || a.beforePrint(), setTimeout(function () {
          z.focus();
          z.print();
          f.isSafari || setTimeout(function () {
            a.afterPrint();
          }, 1E3);
        }, 1));
      },
      contextMenu: function (a, b, c, d, e, f, r) {
        var k = this,
            D = k.options.navigation,
            p = k.chartWidth,
            A = k.chartHeight,
            t = "cache-" + a,
            l = k[t],
            v = Math.max(e, f);

        if (!l) {
          k.exportContextMenu = k[t] = l = h("div", {
            className: a
          }, {
            position: "absolute",
            zIndex: 1E3,
            padding: v + "px",
            pointerEvents: "auto"
          }, k.fixedDiv || k.container);
          var m = h("ul", {
            className: "highcharts-menu"
          }, {
            listStyle: "none",
            margin: 0,
            padding: 0
          }, l);
          k.styledMode || u(m, x({
            MozBoxShadow: "3px 3px 10px #888",
            WebkitBoxShadow: "3px 3px 10px #888",
            boxShadow: "3px 3px 10px #888"
          }, D.menuStyle));

          l.hideMenu = function () {
            u(l, {
              display: "none"
            });
            r && r.setState(0);
            k.openMenu = !1;
            u(k.renderTo, {
              overflow: "hidden"
            });
            g.clearTimeout(l.hideTimer);
            B(k, "exportMenuHidden");
          };

          k.exportEvents.push(n(l, "mouseleave", function () {
            l.hideTimer = z.setTimeout(l.hideMenu, 500);
          }), n(l, "mouseenter", function () {
            g.clearTimeout(l.hideTimer);
          }), n(y, "mouseup", function (b) {
            k.pointer.inClass(b.target, a) || l.hideMenu();
          }), n(l, "click", function () {
            k.openMenu && l.hideMenu();
          }));
          b.forEach(function (a) {
            "string" === typeof a && (a = k.options.exporting.menuItemDefinitions[a]);

            if (J(a, !0)) {
              if (a.separator) var b = h("hr", null, null, m);else b = h("li", {
                className: "highcharts-menu-item",
                onclick: function (b) {
                  b && b.stopPropagation();
                  l.hideMenu();
                  a.onclick && a.onclick.apply(k, arguments);
                },
                innerHTML: a.text || k.options.lang[a.textKey]
              }, null, m), k.styledMode || (b.onmouseover = function () {
                u(this, D.menuItemHoverStyle);
              }, b.onmouseout = function () {
                u(this, D.menuItemStyle);
              }, u(b, x({
                cursor: "pointer"
              }, D.menuItemStyle)));
              k.exportDivElements.push(b);
            }
          });
          k.exportDivElements.push(m, l);
          k.exportMenuWidth = l.offsetWidth;
          k.exportMenuHeight = l.offsetHeight;
        }

        b = {
          display: "block"
        };
        c + k.exportMenuWidth > p ? b.right = p - c - e - v + "px" : b.left = c - v + "px";
        d + f + k.exportMenuHeight > A && "top" !== r.alignOptions.verticalAlign ? b.bottom = A - d - v + "px" : b.top = d + f - v + "px";
        u(l, b);
        u(k.renderTo, {
          overflow: ""
        });
        k.openMenu = !0;
        B(k, "exportMenuShown");
      },
      addButton: function (a) {
        var b = this,
            c = b.renderer,
            d = p(b.options.navigation.buttonOptions, a),
            g = d.onclick,
            e = d.menuItems,
            f = d.symbolSize || 12;
        b.btnCount || (b.btnCount = 0);
        b.exportDivElements || (b.exportDivElements = [], b.exportSVGElements = []);

        if (!1 !== d.enabled) {
          var k = d.theme,
              h = k.states,
              m = h && h.hover;
          h = h && h.select;
          var A;
          b.styledMode || (k.fill = q(k.fill, "#ffffff"), k.stroke = q(k.stroke, "none"));
          delete k.states;
          g ? A = function (a) {
            a && a.stopPropagation();
            g.call(b, a);
          } : e && (A = function (a) {
            a && a.stopPropagation();
            b.contextMenu(t.menuClassName, e, t.translateX, t.translateY, t.width, t.height, t);
            t.setState(2);
          });
          d.text && d.symbol ? k.paddingLeft = q(k.paddingLeft, 25) : d.text || x(k, {
            width: d.width,
            height: d.height,
            padding: 0
          });
          b.styledMode || (k["stroke-linecap"] = "round", k.fill = q(k.fill, "#ffffff"), k.stroke = q(k.stroke, "none"));
          var t = c.button(d.text, 0, 0, A, k, m, h).addClass(a.className).attr({
            title: q(b.options.lang[d._titleKey || d.titleKey], "")
          });
          t.menuClassName = a.menuClassName || "highcharts-menu-" + b.btnCount++;

          if (d.symbol) {
            var l = c.symbol(d.symbol, d.symbolX - f / 2, d.symbolY - f / 2, f, f, {
              width: f,
              height: f
            }).addClass("highcharts-button-symbol").attr({
              zIndex: 1
            }).add(t);
            b.styledMode || l.attr({
              stroke: d.symbolStroke,
              fill: d.symbolFill,
              "stroke-width": d.symbolStrokeWidth || 1
            });
          }

          t.add(b.exportingGroup).align(x(d, {
            width: t.width,
            x: q(d.x, b.buttonOffset)
          }), !0, "spacingBox");
          b.buttonOffset += (t.width + d.buttonSpacing) * ("right" === d.align ? -1 : 1);
          b.exportSVGElements.push(t, l);
        }
      },
      destroyExport: function (a) {
        var b = a ? a.target : this;
        a = b.exportSVGElements;
        var c = b.exportDivElements,
            d = b.exportEvents,
            f;
        a && (a.forEach(function (a, d) {
          a && (a.onclick = a.ontouchstart = null, f = "cache-" + a.menuClassName, b[f] && delete b[f], b.exportSVGElements[d] = a.destroy());
        }), a.length = 0);
        b.exportingGroup && (b.exportingGroup.destroy(), delete b.exportingGroup);
        c && (c.forEach(function (a, d) {
          g.clearTimeout(a.hideTimer);
          K(a, "mouseleave");
          b.exportDivElements[d] = a.onmouseout = a.onmouseover = a.ontouchstart = a.onclick = null;
          m(a);
        }), c.length = 0);
        d && (d.forEach(function (a) {
          a();
        }), d.length = 0);
      }
    });
    F.prototype.inlineToAttributes = "fill stroke strokeLinecap strokeLinejoin strokeWidth textAnchor x y".split(" ");
    F.prototype.inlineBlacklist = [/-/, /^(clipPath|cssText|d|height|width)$/, /^font$/, /[lL]ogical(Width|Height)$/, /perspective/, /TapHighlightColor/, /^transition/, /^length$/];
    F.prototype.unstyledElements = ["clipPath", "defs", "desc"];

    C.prototype.inlineStyles = function () {
      function a(a) {
        return a.replace(/([A-Z])/g, function (a, b) {
          return "-" + b.toLowerCase();
        });
      }

      function b(c) {
        function k(b, e) {
          v = u = !1;

          if (g) {
            for (q = g.length; q-- && !u;) u = g[q].test(e);

            v = !u;
          }

          "transform" === e && "none" === b && (v = !0);

          for (q = f.length; q-- && !v;) v = f[q].test(e) || "function" === typeof b;

          v || x[e] === b && "svg" !== c.nodeName || h[c.nodeName][e] === b || (-1 !== d.indexOf(e) ? c.setAttribute(a(e), b) : l += a(e) + ":" + b + ";");
        }

        var l = "",
            v,
            u,
            q;

        if (1 === c.nodeType && -1 === e.indexOf(c.nodeName)) {
          var r = z.getComputedStyle(c, null);
          var x = "svg" === c.nodeName ? {} : z.getComputedStyle(c.parentNode, null);

          if (!h[c.nodeName]) {
            m = n.getElementsByTagName("svg")[0];
            var w = n.createElementNS(c.namespaceURI, c.nodeName);
            m.appendChild(w);
            h[c.nodeName] = p(z.getComputedStyle(w, null));
            "text" === c.nodeName && delete h.text.fill;
            m.removeChild(w);
          }

          if (O || N) for (var y in r) k(r[y], y);else E(r, k);
          l && (r = c.getAttribute("style"), c.setAttribute("style", (r ? r + ";" : "") + l));
          "svg" === c.nodeName && c.setAttribute("stroke-width", "1px");
          "text" !== c.nodeName && [].forEach.call(c.children || c.childNodes, b);
        }
      }

      var c = this.renderer,
          d = c.inlineToAttributes,
          f = c.inlineBlacklist,
          g = c.inlineWhitelist,
          e = c.unstyledElements,
          h = {},
          m;
      c = y.createElement("iframe");
      u(c, {
        width: "1px",
        height: "1px",
        visibility: "hidden"
      });
      y.body.appendChild(c);
      var n = c.contentWindow.document;
      n.open();
      n.write('<svg xmlns="http://www.w3.org/2000/svg"></svg>');
      n.close();
      b(this.container.querySelector("svg"));
      m.parentNode.removeChild(m);
    };

    H.menu = function (a, b, c, d) {
      return ["M", a, b + 2.5, "L", a + c, b + 2.5, "M", a, b + d / 2 + .5, "L", a + c, b + d / 2 + .5, "M", a, b + d - 1.5, "L", a + c, b + d - 1.5];
    };

    H.menuball = function (a, b, c, d) {
      a = [];
      d = d / 3 - 2;
      return a = a.concat(this.circle(c - d, b, d, d), this.circle(c - d, b + d + 4, d, d), this.circle(c - d, b + 2 * (d + 4), d, d));
    };

    C.prototype.renderExporting = function () {
      var a = this,
          b = a.options.exporting,
          c = b.buttons,
          d = a.isDirtyExporting || !a.exportSVGElements;
      a.buttonOffset = 0;
      a.isDirtyExporting && a.destroyExport();
      d && !1 !== b.enabled && (a.exportEvents = [], a.exportingGroup = a.exportingGroup || a.renderer.g("exporting-group").attr({
        zIndex: 3
      }).add(), E(c, function (b) {
        a.addButton(b);
      }), a.isDirtyExporting = !1);
      n(a, "destroy", a.destroyExport);
    };

    n(C, "init", function () {
      var a = this;
      a.exporting = {
        update: function (b, c) {
          a.isDirtyExporting = !0;
          p(!0, a.options.exporting, b);
          q(c, !0) && a.redraw();
        }
      };
      e.addUpdate(function (b, c) {
        a.isDirtyExporting = !0;
        p(!0, a.options.navigation, b);
        q(c, !0) && a.redraw();
      }, a);
    });
    C.prototype.callbacks.push(function (a) {
      a.renderExporting();
      n(a, "redraw", a.renderExporting);
    });
  });
  m(e, "masters/modules/exporting.src.js", [], function () {});
});

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _styles_index_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles/index.scss */ "./src/styles/index.scss");
/* harmony import */ var _styles_index_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_styles_index_scss__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _scripts_card_searcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scripts/card_searcher */ "./src/scripts/card_searcher.js");
/* harmony import */ var _scripts_card_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scripts/card_generator */ "./src/scripts/card_generator.js");



window.addEventListener("DOMContentLoaded", function () {
  var board = document.createElement("div");
  var searchBar = document.createElement("form");
  var inputField = document.createElement("input");
  var submitButton = document.createElement("button");
  var searchIcon = document.createElement("i");
  var titleContainer = document.createElement('div');
  var title = document.createElement("h1");
  var titleImg = document.createElement("img");
  var navContainer = document.createElement('div');
  var gitLinkImg = document.createElement("i");
  var linkedinLinkImg = document.createElement("i");
  var gitLink = document.createElement("a");
  var linkedinLink = document.createElement("a");
  gitLink.append(gitLinkImg);
  gitLink.classList.add('nav-link');
  gitLink.setAttribute("href", "https://github.com/Norton-Design/cardAugury");
  gitLink.setAttribute("target", "_blank");
  linkedinLink.append(linkedinLinkImg);
  linkedinLink.classList.add('nav-link');
  linkedinLink.setAttribute("href", "https://www.linkedin.com/in/michael-norton-5b5559199/");
  linkedinLink.setAttribute("target", "_blank");
  document.body.classList.add("center");
  document.body.append(board);
  board.classList.add("board", "center");
  board.setAttribute('id', "main-board");
  board.append(titleContainer);
  board.append(searchBar);
  board.append(navContainer);
  titleContainer.append(titleImg);
  titleContainer.append(title);
  titleContainer.classList.add("title-container");
  navContainer.append(gitLink);
  navContainer.append(linkedinLink);
  navContainer.classList.add('nav');
  titleImg.setAttribute("src", "./src/images/final-owl2.png");
  title.innerHTML = "Card Augury";
  searchIcon.classList.add("fa");
  searchIcon.classList.add("fa-search");
  linkedinLinkImg.classList.add('fa');
  linkedinLinkImg.classList.add('fa-linkedin');
  gitLinkImg.classList.add('fa');
  gitLinkImg.classList.add('fa-github');
  submitButton.append(searchIcon);
  submitButton.classList.add('search-button');
  inputField.setAttribute("id", "searchbar");
  inputField.setAttribute("placeholder", "Search for a card...");
  inputField.classList.add("searchbar");
  searchBar.classList.add("searchbar-container");
  searchBar.append(inputField);
  searchBar.append(submitButton);
  submitButton.addEventListener('click', function (e) {
    e.preventDefault();
    Object(_scripts_card_searcher__WEBPACK_IMPORTED_MODULE_1__["cardSearcher"])().then(function (card) {
      board.removeChild(navContainer);
      Object(_scripts_card_generator__WEBPACK_IMPORTED_MODULE_2__["default"])(card);
    }).then(function () {
      return board.append(navContainer);
    });
  }); // pass the return value to a function that amends the all components
});

/***/ }),

/***/ "./src/scripts/card_generator.js":
/*!***************************************!*\
  !*** ./src/scripts/card_generator.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _set_fetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./set_fetcher */ "./src/scripts/set_fetcher.js");
/* harmony import */ var _set_stats_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./set_stats_util */ "./src/scripts/set_stats_util.js");
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! babel-polyfill */ "./node_modules/babel-polyfill/lib/index.js");
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(babel_polyfill__WEBPACK_IMPORTED_MODULE_2__);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }





var Highcharts = __webpack_require__(/*! highcharts */ "./node_modules/highcharts/highcharts.js");

__webpack_require__(/*! highcharts/modules/exporting */ "./node_modules/highcharts/modules/exporting.js")(Highcharts); // Create the chart
// Highcharts.chart('container', { /*Highcharts options*/ });


var cardGenerator = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(cardInfo) {
    var board, prevContainer, cardContainer, setStatContainer, imgLink, setBarChartPlaceholder, setPieChartPlaceholder, pieLoadingIcon, barLoadingIcon;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            board = document.getElementById("main-board");
            prevContainer = document.getElementById("card-container");
            cardContainer = document.createElement("div");
            setStatContainer = document.createElement('div');
            imgLink = cardInfo.image_uris.normal;
            setBarChartPlaceholder = document.createElement('div');
            setPieChartPlaceholder = document.createElement('div');
            pieLoadingIcon = document.createElement("i");
            barLoadingIcon = document.createElement("i");
            if (prevContainer) board.removeChild(prevContainer);
            pieLoadingIcon.classList.add("fa");
            pieLoadingIcon.classList.add("fa-spinner");
            barLoadingIcon.classList.add("fa");
            barLoadingIcon.classList.add("fa-spinner");
            setStatContainer.classList.add('set-stats-container');
            setBarChartPlaceholder.setAttribute("id", "set-bar-ph"); // <--- TARGET TO REPLACE THE BARCHART

            setPieChartPlaceholder.setAttribute("id", "set-pie-ph"); // <--- TARGET TO REPLACE THE PIECHART

            setBarChartPlaceholder.append(barLoadingIcon);
            setPieChartPlaceholder.append(pieLoadingIcon);
            board.append(cardContainer);
            setStatContainer.append(setBarChartPlaceholder);
            setStatContainer.append(setPieChartPlaceholder);
            cardContainer.append(imgCreator(imgLink));
            cardContainer.append(statBlockCreator(cardInfo));
            cardContainer.append(setStatContainer);
            cardContainer.setAttribute("id", "card-container");
            cardContainer.classList.add("card-container");
            Object(_set_fetcher__WEBPACK_IMPORTED_MODULE_0__["setFetcher"])(cardInfo).then(function (cardSet) {
              return setStatsCreator(cardInfo, cardSet);
            });

          case 28:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function cardGenerator(_x) {
    return _ref.apply(this, arguments);
  };
}();

var imgCreator = function imgCreator(imgLink) {
  var imgContainer = document.createElement("div");
  imgContainer.classList.add("image-container");
  var img = document.createElement("img");
  img.setAttribute("src", imgLink);
  imgContainer.append(img);
  return imgContainer;
};

var statBlockCreator = function statBlockCreator(cardInfo) {
  var name = cardInfo.name,
      mana_cost = cardInfo.mana_cost,
      rarity = cardInfo.rarity,
      oracle_text = cardInfo.oracle_text,
      set_name = cardInfo.set_name,
      type_line = cardInfo.type_line;
  var statBlockContainer = document.createElement("ul");
  statBlockContainer.classList.add("stat-block-container");
  var cardTitle = document.createElement("li");
  var title = document.createElement("h2");
  var cardCost = document.createElement("div");
  cardCost.innerHTML = mana_cost;
  title.innerHTML = name;
  cardTitle.append(title);
  cardTitle.append(cardCost);
  cardTitle.classList.add("card-title-container");
  statBlockContainer.append(cardTitle); // SET THE LIST VALUES FOR THE CARD

  var hr = document.createElement("hr");
  statBlockContainer.append(hr);
  var cardType = document.createElement("li");
  cardType.innerHTML = type_line;
  statBlockContainer.append(cardType);
  var cardSetName = document.createElement("li");
  cardSetName.innerHTML = set_name;
  statBlockContainer.append(cardSetName);
  var cardRarity = document.createElement("li");
  cardRarity.innerHTML = capitalize(rarity);
  statBlockContainer.append(cardRarity);
  var cardOracle = document.createElement("li");
  cardOracle.innerHTML = oracle_text;
  statBlockContainer.append(cardOracle);
  return statBlockContainer;
};

var setStatsCreator = function setStatsCreator(cardInfo, cardSet) {
  console.log(cardSet);
  Object(_set_stats_util__WEBPACK_IMPORTED_MODULE_1__["typeTotals"])(cardSet).then(function (totalBreakdown) {
    console.log(totalBreakdown);
    var typeChart = Highcharts.chart("set-pie-ph", {
      chart: {
        plotBackgroundColor: null,
        plotBorderWidth: null,
        plotShadow: false,
        type: 'pie'
      },
      title: {
        text: "Card Types (".concat(cardInfo.set_name, ")"),
        style: {
          "font-family": "$title-font",
          "font-size": "1rem"
        }
      },
      tooltip: {
        pointFormat: '{series.name}: {point.percentage:.1f}%',
        footerFormat: '\n ({point.y})'
      },
      accessibility: {
        point: {
          valueSuffix: '%'
        }
      },
      plotOptions: {
        pie: {
          allowPointSelect: true,
          cursor: 'pointer',
          dataLabels: {
            enabled: true,
            format: '{point.name}',
            style: {
              fontWeight: 400,
              fontFamily: "$body-font"
            }
          }
        }
      },
      series: [{
        name: 'Types',
        colorByPoint: true,
        data: Object.entries(totalBreakdown.types).sort(function (a, b) {
          return a[1] - b[1];
        }).reverse().map(function (pair) {
          return {
            name: pair[0],
            y: pair[1]
          };
        })
      }]
    });
    var valueChart = Highcharts.chart("set-bar-ph", {
      chart: {
        type: 'column'
      },
      title: {
        text: "Most Valued (".concat(cardInfo.set_name, ")"),
        style: {
          "font-family": "$title-font",
          "font-size": "1rem"
        }
      },
      xAxis: {
        categories: totalBreakdown.nonPromoTopTen.map(function (card) {
          return card.name;
        }),
        crosshair: true,
        labels: {
          enabled: false
        }
      },
      yAxis: {
        min: 0,
        title: {
          text: 'USD',
          enabled: false
        } // opposite: true

      },
      tooltip: {
        headerFormat: '<span style="font-size:10px">{point.key}</span><table>',
        pointFormat: '<tr><td style="color:{series.color};padding:0">{series.name}: </td>' + '<td style="padding:0"><b>${point.y:.1f}</b></td></tr>',
        footerFormat: '</table>',
        shared: true,
        useHTML: true
      },
      plotOptions: {
        column: {
          pointPadding: 0.2,
          borderWidth: 0
        }
      },
      series: [{
        name: 'Value',
        colorByPoint: true,
        data: totalBreakdown.nonPromoTopTen.map(function (card) {
          return parseFloat(card.prices.usd);
        }),
        showInLegend: false
      }]
    });
  });
};

var capitalize = function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

/* harmony default export */ __webpack_exports__["default"] = (cardGenerator);

/***/ }),

/***/ "./src/scripts/card_searcher.js":
/*!**************************************!*\
  !*** ./src/scripts/card_searcher.js ***!
  \**************************************/
/*! exports provided: card, cardSearcher, validSearchInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "card", function() { return card; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cardSearcher", function() { return cardSearcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validSearchInput", function() { return validSearchInput; });
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-polyfill */ "./node_modules/babel-polyfill/lib/index.js");
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_polyfill__WEBPACK_IMPORTED_MODULE_0__);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var card;

var cardSearcher = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e) {
    var inputStr, url, searchUrl, response, json;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            // e.preventDefault();
            inputStr = document.getElementById("searchbar").value;
            url = 'https://api.scryfall.com/cards/named?fuzzy=';
            searchUrl = url + validSearchInput(inputStr);
            _context.next = 5;
            return fetch(searchUrl);

          case 5:
            response = _context.sent;
            _context.next = 8;
            return response.json();

          case 8:
            json = _context.sent;
            _context.next = 11;
            return json;

          case 11:
            card = _context.sent;
            return _context.abrupt("return", card);

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function cardSearcher(_x) {
    return _ref.apply(this, arguments);
  };
}();
var validSearchInput = function validSearchInput(searchInput) {
  return searchInput.split(' ').join("-");
};

/***/ }),

/***/ "./src/scripts/set_fetcher.js":
/*!************************************!*\
  !*** ./src/scripts/set_fetcher.js ***!
  \************************************/
/*! exports provided: setFetcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setFetcher", function() { return setFetcher; });
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-polyfill */ "./node_modules/babel-polyfill/lib/index.js");
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_polyfill__WEBPACK_IMPORTED_MODULE_0__);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }


var setFetcher = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(cardInfo) {
    var searchUrl, response, json, nextUrl, nextResponse, nextJson, finalUrl, finalResponse, finalJson;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            searchUrl = "https://api.scryfall.com/cards/search?order=usd&q=e%3A".concat(cardInfo.set, "&unique=prints");
            _context.next = 3;
            return fetch(searchUrl);

          case 3:
            response = _context.sent;
            _context.next = 6;
            return response.json();

          case 6:
            json = _context.sent;

            if (!json.has_more) {
              _context.next = 29;
              break;
            }

            nextUrl = json.next_page;
            _context.next = 11;
            return fetch(nextUrl);

          case 11:
            nextResponse = _context.sent;
            _context.next = 14;
            return nextResponse.json();

          case 14:
            nextJson = _context.sent;

            if (!nextJson.has_more) {
              _context.next = 26;
              break;
            }

            finalUrl = nextJson.next_page;
            _context.next = 19;
            return fetch(finalUrl);

          case 19:
            finalResponse = _context.sent;
            _context.next = 22;
            return finalResponse.json();

          case 22:
            finalJson = _context.sent;
            return _context.abrupt("return", setMerge([json, nextJson, finalJson]));

          case 26:
            return _context.abrupt("return", setMerge([json, nextJson]));

          case 27:
            _context.next = 32;
            break;

          case 29:
            _context.next = 31;
            return json;

          case 31:
            return _context.abrupt("return", _context.sent);

          case 32:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function setFetcher(_x) {
    return _ref.apply(this, arguments);
  };
}();

var setMerge = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(arrOfSets) {
    var baseSet, i, mergingSet;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            baseSet = arrOfSets[0];

            for (i = 1; i < arrOfSets.length; i++) {
              mergingSet = arrOfSets[i];
              baseSet.data = baseSet.data.concat(mergingSet.data);
            }

            return _context2.abrupt("return", baseSet);

          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function setMerge(_x2) {
    return _ref2.apply(this, arguments);
  };
}();

/***/ }),

/***/ "./src/scripts/set_stats_util.js":
/*!***************************************!*\
  !*** ./src/scripts/set_stats_util.js ***!
  \***************************************/
/*! exports provided: typeTotals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typeTotals", function() { return typeTotals; });
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-polyfill */ "./node_modules/babel-polyfill/lib/index.js");
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_polyfill__WEBPACK_IMPORTED_MODULE_0__);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }


var typeTotals = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(set) {
    var MTGCARDTYPES, cards, stats, i, card, currentCardTypes, cardValue;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            // return obj with all types as keys except basic lands
            MTGCARDTYPES = ['Artifact', 'Creature', 'Enchantment', 'Instant', 'Land', 'Planeswalker', 'Sorcery', 'Tribal'];
            cards = set.data;
            stats = {
              nonBasicsTotal: 0,
              totalSetValue: 0,
              nonPromoTopTen: [],
              totalSetValueAverage: 0,
              types: {},
              subTypes: {}
            };
            i = 0;

          case 4:
            if (!(i < cards.length)) {
              _context.next = 22;
              break;
            }

            card = cards[i];
            currentCardTypes = void 0; // REMOVE PROMO CARDS FROM THE POOL BECAUSE THEY'RE DUPES

            if (!card.promo) {
              _context.next = 9;
              break;
            }

            return _context.abrupt("continue", 19);

          case 9:
            currentCardTypes = typeLineParser(card.type_line); // <-- 

            if (!currentCardTypes.includes('Basic')) {
              _context.next = 14;
              break;
            }

            return _context.abrupt("continue", 19);

          case 14:
            cardValue = typeof card.prices.usd === "undefined" || card.prices.usd === null ? 0 : parseFloat(card.prices.usd);
            currentCardTypes.forEach(function (type) {
              if (MTGCARDTYPES.includes(type) && typeof stats.types[type] === 'undefined') {
                stats.types[type] = 1;
              } else if (MTGCARDTYPES.includes(type)) {
                stats.types[type] += 1;
              } else if (!MTGCARDTYPES.includes(type) && typeof stats.subTypes[type] === 'undefined') {
                stats.subTypes[type] = 1;
              } else {
                stats.subTypes[type] += 1;
              }
            });
            stats.nonBasicsTotal += 1;
            stats.totalSetValue += cardValue;

            if (stats.nonPromoTopTen.length < 10) {
              stats.nonPromoTopTen.push(card);
            }

          case 19:
            i++;
            _context.next = 4;
            break;

          case 22:
            stats.nonPromoTopTenValueAverage = cardAverager(stats.nonPromoTopTen);
            stats.totalSetValueAverage = stats.totalSetValue / stats.nonBasicsTotal;
            return _context.abrupt("return", stats);

          case 25:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function typeTotals(_x) {
    return _ref.apply(this, arguments);
  };
}();

var cardAverager = function cardAverager(cardArr) {
  var total = 0;
  cardArr.forEach(function (card) {
    return total += parseFloat(card.prices.usd);
  });
  return total / cardArr.length;
};

var typeLineParser = function typeLineParser(typeLineStr) {
  var typeArr = typeLineStr.split(' ');
  return typeArr.filter(function (type) {
    return type.length > 2;
  });
};

var highchartsDigest = function highchartsDigest(stats) {} //check highcharts for formatting...
// document.addEventListener('DOMContentLoaded', function () {
//     var myChart = Highcharts.chart('container', {
//         chart: {
//             type: 'bar'
//         },
//         title: {
//             text: 'Top Ten in {SET NAME}'
//         },
//         xAxis: {
//             categories: ['Apples', 'Bananas', 'Oranges']
//         },
//         yAxis: {
//             title: {
//                 text: 'USD'
//             }
//         },
//         series: [{
//             name: 'Jane',
//             data: [1, 0, 4]
//         }, {
//             name: 'John',
//             data: [5, 7, 3]
//         }]
//     });
// });
;

/***/ }),

/***/ "./src/styles/index.scss":
/*!*******************************!*\
  !*** ./src/styles/index.scss ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXBvbHlmaWxsL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcG9seWZpbGwvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1udW1iZXItdmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkdmFuY2Utc3RyaW5nLWluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1maWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19iaW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1pc28tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhdHRlbi1pbnRvLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mdW5jdGlvbi10by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1mcm91bmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1sb2cxcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLXNjYWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZm9yY2VkLXBhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX293bi1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWZsb2F0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wZXJmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb21pc2UtcmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy1hYnN0cmFjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZXBsYWNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1jb2xsZWN0aW9uLWZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1zcGVjaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaWN0LW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWh0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXBhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcmVwZWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy10cmltLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy13cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190YXNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VzZXItYWdlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdmFsaWRhdGUtY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmluZGV4LW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmpvaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkub2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zbGljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb21lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLm5vdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1qc29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYWNvc2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmF0YW5oLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2JydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY29zaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5pbXVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2luaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRhbmguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lmhhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5leGVjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ibGluay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udGNvbG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDMyLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstc2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmZsYXQtbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXNhcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLm9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguY2xhbXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5kZWctcGVyLXJhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmRlZ3JlZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5mc2NhbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pYWRkaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmltdWxoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaXN1YmguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5yYWQtcGVyLWRlZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnJhZGlhbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5zY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnNpZ25iaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC51bXVsaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnByb21pc2UudHJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC5mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC5vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcuYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLXNldC5mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstc2V0Lm9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudGltZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL3NoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpZ2hjaGFydHMvaGlnaGNoYXJ0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlnaGNoYXJ0cy9tb2R1bGVzL2V4cG9ydGluZy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9jYXJkX2dlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9jYXJkX3NlYXJjaGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3NldF9mZXRjaGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL3NldF9zdGF0c191dGlsLmpzIiwid2VicGFjazovLy8uL3NyYy9zdHlsZXMvaW5kZXguc2Nzcz9jODA3Il0sIm5hbWVzIjpbIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJib2FyZCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNlYXJjaEJhciIsImlucHV0RmllbGQiLCJzdWJtaXRCdXR0b24iLCJzZWFyY2hJY29uIiwidGl0bGVDb250YWluZXIiLCJ0aXRsZSIsInRpdGxlSW1nIiwibmF2Q29udGFpbmVyIiwiZ2l0TGlua0ltZyIsImxpbmtlZGluTGlua0ltZyIsImdpdExpbmsiLCJsaW5rZWRpbkxpbmsiLCJhcHBlbmQiLCJjbGFzc0xpc3QiLCJhZGQiLCJzZXRBdHRyaWJ1dGUiLCJib2R5IiwiaW5uZXJIVE1MIiwiZSIsInByZXZlbnREZWZhdWx0IiwiY2FyZFNlYXJjaGVyIiwidGhlbiIsImNhcmQiLCJyZW1vdmVDaGlsZCIsImNhcmRHZW5lcmF0b3IiLCJIaWdoY2hhcnRzIiwicmVxdWlyZSIsImNhcmRJbmZvIiwiZ2V0RWxlbWVudEJ5SWQiLCJwcmV2Q29udGFpbmVyIiwiY2FyZENvbnRhaW5lciIsInNldFN0YXRDb250YWluZXIiLCJpbWdMaW5rIiwiaW1hZ2VfdXJpcyIsIm5vcm1hbCIsInNldEJhckNoYXJ0UGxhY2Vob2xkZXIiLCJzZXRQaWVDaGFydFBsYWNlaG9sZGVyIiwicGllTG9hZGluZ0ljb24iLCJiYXJMb2FkaW5nSWNvbiIsImltZ0NyZWF0b3IiLCJzdGF0QmxvY2tDcmVhdG9yIiwic2V0RmV0Y2hlciIsImNhcmRTZXQiLCJzZXRTdGF0c0NyZWF0b3IiLCJpbWdDb250YWluZXIiLCJpbWciLCJuYW1lIiwibWFuYV9jb3N0IiwicmFyaXR5Iiwib3JhY2xlX3RleHQiLCJzZXRfbmFtZSIsInR5cGVfbGluZSIsInN0YXRCbG9ja0NvbnRhaW5lciIsImNhcmRUaXRsZSIsImNhcmRDb3N0IiwiaHIiLCJjYXJkVHlwZSIsImNhcmRTZXROYW1lIiwiY2FyZFJhcml0eSIsImNhcGl0YWxpemUiLCJjYXJkT3JhY2xlIiwiY29uc29sZSIsImxvZyIsInR5cGVUb3RhbHMiLCJ0b3RhbEJyZWFrZG93biIsInR5cGVDaGFydCIsImNoYXJ0IiwicGxvdEJhY2tncm91bmRDb2xvciIsInBsb3RCb3JkZXJXaWR0aCIsInBsb3RTaGFkb3ciLCJ0eXBlIiwidGV4dCIsInN0eWxlIiwidG9vbHRpcCIsInBvaW50Rm9ybWF0IiwiZm9vdGVyRm9ybWF0IiwiYWNjZXNzaWJpbGl0eSIsInBvaW50IiwidmFsdWVTdWZmaXgiLCJwbG90T3B0aW9ucyIsInBpZSIsImFsbG93UG9pbnRTZWxlY3QiLCJjdXJzb3IiLCJkYXRhTGFiZWxzIiwiZW5hYmxlZCIsImZvcm1hdCIsImZvbnRXZWlnaHQiLCJmb250RmFtaWx5Iiwic2VyaWVzIiwiY29sb3JCeVBvaW50IiwiZGF0YSIsIk9iamVjdCIsImVudHJpZXMiLCJ0eXBlcyIsInNvcnQiLCJhIiwiYiIsInJldmVyc2UiLCJtYXAiLCJwYWlyIiwieSIsInZhbHVlQ2hhcnQiLCJ4QXhpcyIsImNhdGVnb3JpZXMiLCJub25Qcm9tb1RvcFRlbiIsImNyb3NzaGFpciIsImxhYmVscyIsInlBeGlzIiwibWluIiwiaGVhZGVyRm9ybWF0Iiwic2hhcmVkIiwidXNlSFRNTCIsImNvbHVtbiIsInBvaW50UGFkZGluZyIsImJvcmRlcldpZHRoIiwicGFyc2VGbG9hdCIsInByaWNlcyIsInVzZCIsInNob3dJbkxlZ2VuZCIsInN0ciIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJpbnB1dFN0ciIsInZhbHVlIiwidXJsIiwic2VhcmNoVXJsIiwidmFsaWRTZWFyY2hJbnB1dCIsImZldGNoIiwicmVzcG9uc2UiLCJqc29uIiwic2VhcmNoSW5wdXQiLCJzcGxpdCIsImpvaW4iLCJzZXQiLCJoYXNfbW9yZSIsIm5leHRVcmwiLCJuZXh0X3BhZ2UiLCJuZXh0UmVzcG9uc2UiLCJuZXh0SnNvbiIsImZpbmFsVXJsIiwiZmluYWxSZXNwb25zZSIsImZpbmFsSnNvbiIsInNldE1lcmdlIiwiYXJyT2ZTZXRzIiwiYmFzZVNldCIsImkiLCJsZW5ndGgiLCJtZXJnaW5nU2V0IiwiY29uY2F0IiwiTVRHQ0FSRFRZUEVTIiwiY2FyZHMiLCJzdGF0cyIsIm5vbkJhc2ljc1RvdGFsIiwidG90YWxTZXRWYWx1ZSIsInRvdGFsU2V0VmFsdWVBdmVyYWdlIiwic3ViVHlwZXMiLCJjdXJyZW50Q2FyZFR5cGVzIiwicHJvbW8iLCJ0eXBlTGluZVBhcnNlciIsImluY2x1ZGVzIiwiY2FyZFZhbHVlIiwiZm9yRWFjaCIsInB1c2giLCJub25Qcm9tb1RvcFRlblZhbHVlQXZlcmFnZSIsImNhcmRBdmVyYWdlciIsImNhcmRBcnIiLCJ0b3RhbCIsInR5cGVMaW5lU3RyIiwidHlwZUFyciIsImZpbHRlciIsImhpZ2hjaGFydHNEaWdlc3QiXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRkEsOENBQWE7O0FBRWIsbUJBQU8sQ0FBQyxvREFBYzs7QUFFdEIsbUJBQU8sQ0FBQyw4R0FBNkI7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxD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RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RCxnQ0FBZ0M7QUFDekY7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDZFQUE2RSxZQUFZO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHlCQUF5QjtBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRTs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtB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QkFBaUIsV0FBVztBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUI7QUFDekIsR0FBRztBQUNILHVCQUF1Qjs7QUFFdkIsMEJBQTBCOztBQUUxQiwwQkFBMEI7O0FBRTFCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlEQUFpRCxpQkFBaUI7QUFDbEU7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCOzs7Ozs7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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQixPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJLGVBQWUsSUFBSSxlQUFlLElBQUk7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlDQUFpQyxJQUFJLGVBQWUsSUFBSSxlQUFlLElBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLFdBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxFQUFFLHFDQUFxQyxPQUFPO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7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VztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrVEFBK1Q7QUFDL1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLEdBQUc7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa01BQWtNLHVRQUF1UTtBQUN6YyxnR0FBZ0c7QUFDaEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0MsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsVUFBVTtBQUNoRSwwQ0FBMEMsWUFBWSxpQkFBaUIsWUFBWSxNQUFNLFFBQVE7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDJHQUEyRztBQUMzRzs7QUFFQTtBQUNBOztBQUVBLDhCQUE4QixXQUFXO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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V0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSw0REFBNEQseUNBQXlDO0FBQ3JHLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEVBQTRFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyQkFBMkIsMERBQTBELDBEQUEwRDtBQUM5SyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUdBQXVHO0FBQ3ZHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdHQUF3RyxzQkFBc0IsK0JBQStCLGNBQWM7QUFDM0s7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQixLQUFLLDBCQUEwQjtBQUMzRSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUzs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsR0FBRztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtREFBbUQ7QUFDNUQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztB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Q0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EscUJBQXFCLGNBQWMscUpBQXFKLFdBQVcsY0FBYztBQUNqTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLFdBQVc7O0FBRTVDO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLEtBQUs7O0FBRS9COztBQUVBLDBCQUEwQixLQUFLOztBQUUvQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixvQkFBb0I7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGtJQUFrSSxPQUFPLHdJQUF3STtBQUM3VDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlEQUFpRCxtQkFBbUI7QUFDcEUscUNBQXFDLDRCQUE0QjtBQUNqRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLEtBQUs7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7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QUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsS0FBSztBQUN4QjtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEtBQUs7QUFDekMsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0hBQXdIO0FBQ3hILE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxpTEFBaUw7QUFDakw7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJDQUEyQyxZQUFZLGdEQUFnRCxZQUFZO0FBQ25ILDZCQUE2QixRQUFRLGdCQUFnQixRQUFRO0FBQzdEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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WDtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsT0FBTzs7QUFFeEI7QUFDQTtBQUNBLE9BQU87O0FBRVAsaUJBQWlCLE9BQU87QUFDeEI7O0FBRUEsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQixzQkFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsY0FBYyw4QkFBOEIsb0NBQW9DLGtDQUFrQyxpQkFBaUI7QUFDaE8sU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQyxFOzs7Ozs7Ozs7OztBQ3o3VkQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEtBQTBCLDhEQUE4RCxLQUEwQyxHQUFHLGlDQUF1QyxDQUFDLGdGQUFZLENBQUMsbUNBQUU7QUFDOUw7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUFBLG9HQUFDLEdBQUcsU0FBMEQ7QUFDakUsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SUFBNEksZUFBZSxFQUFFLG1UQUFtVCw0QkFBNEI7QUFDNWU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FB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XHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9kaXN0L1wiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC5qc1wiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9zaGltXCIpO1xuXG5yZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlXCIpO1xuXG5pZiAoZ2xvYmFsLl9iYWJlbFBvbHlmaWxsKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIm9ubHkgb25lIGluc3RhbmNlIG9mIGJhYmVsLXBvbHlmaWxsIGlzIGFsbG93ZWRcIik7XG59XG5cbmdsb2JhbC5fYmFiZWxQb2x5ZmlsbCA9IHRydWU7XG52YXIgREVGSU5FX1BST1BFUlRZID0gXCJkZWZpbmVQcm9wZXJ0eVwiO1xuXG5mdW5jdGlvbiBkZWZpbmUoTywga2V5LCB2YWx1ZSkge1xuICBPW2tleV0gfHwgT2JqZWN0W0RFRklORV9QUk9QRVJUWV0oTywga2V5LCB7XG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn1cblxuZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIFwicGFkTGVmdFwiLCBcIlwiLnBhZFN0YXJ0KTtcbmRlZmluZShTdHJpbmcucHJvdG90eXBlLCBcInBhZFJpZ2h0XCIsIFwiXCIucGFkRW5kKTtcblwicG9wLHJldmVyc2Usc2hpZnQsa2V5cyx2YWx1ZXMsZW50cmllcyxpbmRleE9mLGV2ZXJ5LHNvbWUsZm9yRWFjaCxtYXAsZmlsdGVyLGZpbmQsZmluZEluZGV4LGluY2x1ZGVzLGpvaW4sc2xpY2UsY29uY2F0LHB1c2gsc3BsaWNlLHVuc2hpZnQsc29ydCxsYXN0SW5kZXhPZixyZWR1Y2UscmVkdWNlUmlnaHQsY29weVdpdGhpbixmaWxsXCIuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBbXVtrZXldICYmIGRlZmluZShBcnJheSwga2V5LCBGdW5jdGlvbi5jYWxsLmJpbmQoW11ba2V5XSkpO1xufSk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cbiFmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuXG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH0gLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cblxuXG4gICAgcmV0dXJuO1xuICB9IC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG5cblxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTsgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cblxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG5cbiAgcnVudGltZS53cmFwID0gd3JhcDsgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5vcm1hbFwiLFxuICAgICAgICBhcmc6IGZuLmNhbGwob2JqLCBhcmcpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0aHJvd1wiLFxuICAgICAgICBhcmc6IGVyclxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7IC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307IC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cblxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cblxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9IC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cblxuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcblxuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiYgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjsgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cblxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3IgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcblxuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9OyAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuXG5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX19hd2FpdDogYXJnXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcblxuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGdsb2JhbC5wcm9jZXNzID09PSBcIm9iamVjdFwiICYmIGdsb2JhbC5wcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gZ2xvYmFsLnByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfSAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuXG5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcblxuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yOyAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cblxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSk7XG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH0gLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuXG5cbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcblxuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBHZW5TdGF0ZUNvbXBsZXRlZCA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDsgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9IC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cblxuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuXG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7IC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cblxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYzsgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH0gLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuXG5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfSAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG5cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiOyAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0ge1xuICAgICAgdHJ5TG9jOiBsb2NzWzBdXG4gICAgfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbe1xuICAgICAgdHJ5TG9jOiBcInJvb3RcIlxuICAgIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICBrZXlzLnJldmVyc2UoKTsgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG5cbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9IC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuXG5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuXG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfSAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG5cblxuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiBkb25lUmVzdWx0XG4gICAgfTtcbiAgfVxuXG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBkb25lOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuICAgIHJlc2V0OiBmdW5jdGlvbiAoc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7IC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uICh0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmICh0eXBlID09PSBcImJyZWFrXCIgfHwgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8IHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuICAgIGZpbmlzaDogZnVuY3Rpb24gKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24gKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9IC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSggLy8gQW1vbmcgdGhlIHZhcmlvdXMgdHJpY2tzIGZvciBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbFxuLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4vLyB1c2UgaW5kaXJlY3QgZXZhbCAod2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxudHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0aGlzKTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5SZWdFeHAuZXNjYXBlOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJ2YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnbnVtYmVyJyAmJiBjb2YoaXQpICE9ICdOdW1iZXInKSB0aHJvdyBUeXBlRXJyb3IobXNnKTtcbiAgcmV0dXJuICtpdDtcbn07IiwiLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIFVOU0NPUEFCTEVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3Vuc2NvcGFibGVzJyk7XG5cbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuaWYgKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkgcmVxdWlyZSgnLi9faGlkZScpKEFycmF5UHJvdG8sIFVOU0NPUEFCTEVTLCB7fSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTsgLy8gYEFkdmFuY2VTdHJpbmdJbmRleGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hZHZhbmNlc3RyaW5naW5kZXhcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTLCBpbmRleCwgdW5pY29kZSkge1xuICByZXR1cm4gaW5kZXggKyAodW5pY29kZSA/IGF0KFMsIGluZGV4KS5sZW5ndGggOiAxKTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCkge1xuICBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCBmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfVxuXG4gIHJldHVybiBpdDtcbn07IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gW10uY29weVdpdGhpbiB8fCBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldFxuLyogPSAwICovXG4sIHN0YXJ0XG4vKiA9IDAsIGVuZCA9IEBsZW5ndGggKi9cbikge1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICB2YXIgbGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgdG8gPSB0b0Fic29sdXRlSW5kZXgodGFyZ2V0LCBsZW4pO1xuICB2YXIgZnJvbSA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuKTtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgY291bnQgPSBNYXRoLm1pbigoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW4pKSAtIGZyb20sIGxlbiAtIHRvKTtcbiAgdmFyIGluYyA9IDE7XG5cbiAgaWYgKGZyb20gPCB0byAmJiB0byA8IGZyb20gKyBjb3VudCkge1xuICAgIGluYyA9IC0xO1xuICAgIGZyb20gKz0gY291bnQgLSAxO1xuICAgIHRvICs9IGNvdW50IC0gMTtcbiAgfVxuXG4gIHdoaWxlIChjb3VudC0tID4gMCkge1xuICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byArPSBpbmM7XG4gICAgZnJvbSArPSBpbmM7XG4gIH1cblxuICByZXR1cm4gTztcbn07IiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmlsbCh2YWx1ZVxuLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi9cbikge1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW5ndGgpO1xuXG4gIHdoaWxlIChlbmRQb3MgPiBpbmRleCkgT1tpbmRleCsrXSA9IHZhbHVlO1xuXG4gIHJldHVybiBPO1xufTsiLCJ2YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlciwgSVRFUkFUT1IpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3JPZihpdGVyLCBmYWxzZSwgcmVzdWx0LnB1c2gsIHJlc3VsdCwgSVRFUkFUT1IpO1xuICByZXR1cm4gcmVzdWx0O1xufTsiLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7IC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG5cbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG5cbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7IC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfVxuICAgIHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59OyIsIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcblxudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxudmFyIGFzYyA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRZUEUsICRjcmVhdGUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICB2YXIgY3JlYXRlID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWwsIHJlcztcblxuICAgIGZvciAoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcblxuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgcmVzdWx0W2luZGV4XSA9IHJlczsgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlcykgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgLy8gc29tZVxuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAvLyBmaW5kXG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgLy8gZmluZEluZGV4XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsKTtcbiAgICAgICAgICAgIC8vIGZpbHRlclxuICAgICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTsiLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhTGVuLCBtZW1vLCBpc1JpZ2h0KSB7XG4gIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGF0KTtcbiAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgaW5kZXggPSBpc1JpZ2h0ID8gbGVuZ3RoIC0gMSA6IDA7XG4gIHZhciBpID0gaXNSaWdodCA/IC0xIDogMTtcbiAgaWYgKGFMZW4gPCAyKSBmb3IgKDs7KSB7XG4gICAgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcbiAgICAgIGluZGV4ICs9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpbmRleCArPSBpO1xuXG4gICAgaWYgKGlzUmlnaHQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBpc1JpZ2h0ID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKSBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIHNlbGZbaW5kZXhdLCBpbmRleCwgTyk7XG4gIH1cblxuICByZXR1cm4gbWVtbztcbn07IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcblxudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgQztcblxuICBpZiAoaXNBcnJheShvcmlnaW5hbCkpIHtcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7IC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG5cbiAgICBpZiAodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59OyIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsLCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIGludm9rZSA9IHJlcXVpcmUoJy4vX2ludm9rZScpO1xuXG52YXIgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xudmFyIGZhY3RvcmllcyA9IHt9O1xuXG52YXIgY29uc3RydWN0ID0gZnVuY3Rpb24gKEYsIGxlbiwgYXJncykge1xuICBpZiAoIShsZW4gaW4gZmFjdG9yaWVzKSkge1xuICAgIGZvciAodmFyIG4gPSBbXSwgaSA9IDA7IGkgPCBsZW47IGkrKykgbltpXSA9ICdhWycgKyBpICsgJ10nOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcblxuXG4gICAgZmFjdG9yaWVzW2xlbl0gPSBGdW5jdGlvbignRixhJywgJ3JldHVybiBuZXcgRignICsgbi5qb2luKCcsJykgKyAnKScpO1xuICB9XG5cbiAgcmV0dXJuIGZhY3Rvcmllc1tsZW5dKEYsIGFyZ3MpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5iaW5kIHx8IGZ1bmN0aW9uIGJpbmQodGhhdFxuLyogLCAuLi5hcmdzICovXG4pIHtcbiAgdmFyIGZuID0gYUZ1bmN0aW9uKHRoaXMpO1xuICB2YXIgcGFydEFyZ3MgPSBhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICB2YXIgYm91bmQgPSBmdW5jdGlvbiAoKVxuICAvKiBhcmdzLi4uICovXG4gIHtcbiAgICB2YXIgYXJncyA9IHBhcnRBcmdzLmNvbmNhdChhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZCA/IGNvbnN0cnVjdChmbiwgYXJncy5sZW5ndGgsIGFyZ3MpIDogaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcbiAgfTtcblxuICBpZiAoaXNPYmplY3QoZm4ucHJvdG90eXBlKSkgYm91bmQucHJvdG90eXBlID0gZm4ucHJvdG90eXBlO1xuICByZXR1cm4gYm91bmQ7XG59OyIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5cbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTsgLy8gRVMzIHdyb25nIGhlcmVcblxuXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cztcbn0oKSkgPT0gJ0FyZ3VtZW50cyc7IC8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG5cbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJyAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVCAvLyBidWlsdGluVGFnIGNhc2VcbiAgOiBBUkcgPyBjb2YoTykgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07IiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcblxudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcblxudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG5cbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcblxudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xuXG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxudmFyICRpdGVyRGVmaW5lID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKTtcblxudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcblxudmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpO1xuXG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xuXG52YXIgZmFzdEtleSA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5O1xuXG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG5cbnZhciBTSVpFID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiAodGhhdCwga2V5KSB7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSk7XG4gIHZhciBlbnRyeTtcbiAgaWYgKGluZGV4ICE9PSAnRicpIHJldHVybiB0aGF0Ll9pW2luZGV4XTsgLy8gZnJvemVuIG9iamVjdCBjYXNlXG5cbiAgZm9yIChlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICBpZiAoZW50cnkuayA9PSBrZXkpIHJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgLy8gY29sbGVjdGlvbiB0eXBlXG5cbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG5cbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7IC8vIGZpcnN0IGVudHJ5XG5cbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7IC8vIGxhc3QgZW50cnlcblxuICAgICAgdGhhdFtTSVpFXSA9IDA7IC8vIHNpemVcblxuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBmb3IgKHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSksIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucCkgZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSk7XG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG5cbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uO1xuICAgICAgICAgIHZhciBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdC5faVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJldikgcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZiAobmV4dCkgbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZiAodGhhdC5fZiA9PSBlbnRyeSkgdGhhdC5fZiA9IG5leHQ7XG4gICAgICAgICAgaWYgKHRoYXQuX2wgPT0gZW50cnkpIHRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm5cbiAgICAgIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqL1xuICAgICAgKSB7XG4gICAgICAgIHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMyk7XG4gICAgICAgIHZhciBlbnRyeTtcblxuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKSB7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTsgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG5cbiAgICAgICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodmFsaWRhdGUodGhpcywgTkFNRSksIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKERFU0NSSVBUT1JTKSBkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHRoaXMsIE5BTUUpW1NJWkVdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICB2YXIgcHJldiwgaW5kZXg7IC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7IC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSxcbiAgICAgICAgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LFxuICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsXG4gICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLFxuICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsXG4gICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgLy8gPC0gcmVtb3ZlZFxuXG4gICAgICB9O1xuICAgICAgaWYgKCF0aGF0Ll9mKSB0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZiAocHJldikgcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7IC8vIGFkZCB0byBpbmRleFxuXG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZ2V0RW50cnk6IGdldEVudHJ5LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uIChDLCBOQU1FLCBJU19NQVApIHtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgJGl0ZXJEZWZpbmUoQywgTkFNRSwgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gICAgICB0aGlzLl90ID0gdmFsaWRhdGUoaXRlcmF0ZWQsIE5BTUUpOyAvLyB0YXJnZXRcblxuICAgICAgdGhpcy5fayA9IGtpbmQ7IC8vIGtpbmRcblxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIga2luZCA9IHRoYXQuX2s7XG4gICAgICB2YXIgZW50cnkgPSB0aGF0Ll9sOyAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcblxuICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDsgLy8gZ2V0IG5leHQgZW50cnlcblxuXG4gICAgICBpZiAoIXRoYXQuX3QgfHwgISh0aGF0Ll9sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGF0Ll90Ll9mKSkge1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH0gLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuXG5cbiAgICAgIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnLCAhSVNfTUFQLCB0cnVlKTsgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcblxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG5cbnZhciBmcm9tID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgaWYgKGNsYXNzb2YodGhpcykgIT0gTkFNRSkgdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICByZXR1cm4gZnJvbSh0aGlzKTtcbiAgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcblxudmFyIGdldFdlYWsgPSByZXF1aXJlKCcuL19tZXRhJykuZ2V0V2VhaztcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG5cbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG52YXIgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJyk7XG5cbnZhciAkaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG5cbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcblxudmFyIGFycmF5RmluZCA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpO1xudmFyIGFycmF5RmluZEluZGV4ID0gY3JlYXRlQXJyYXlNZXRob2QoNik7XG52YXIgaWQgPSAwOyAvLyBmYWxsYmFjayBmb3IgdW5jYXVnaHQgZnJvemVuIGtleXNcblxudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAodGhhdCkge1xuICByZXR1cm4gdGhhdC5fbCB8fCAodGhhdC5fbCA9IG5ldyBVbmNhdWdodEZyb3plblN0b3JlKCkpO1xufTtcblxudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYSA9IFtdO1xufTtcblxudmFyIGZpbmRVbmNhdWdodEZyb3plbiA9IGZ1bmN0aW9uIChzdG9yZSwga2V5KSB7XG4gIHJldHVybiBhcnJheUZpbmQoc3RvcmUuYSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gIH0pO1xufTtcblxuVW5jYXVnaHRGcm96ZW5TdG9yZS5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgcmV0dXJuIGVudHJ5WzFdO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gISFmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgZW50cnlbMV0gPSB2YWx1ZTtlbHNlIHRoaXMuYS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0sXG4gICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGluZGV4ID0gYXJyYXlGaW5kSW5kZXgodGhpcy5hLCBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmICh+aW5kZXgpIHRoaXMuYS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiAhIX5pbmRleDtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7IC8vIGNvbGxlY3Rpb24gdHlwZVxuXG4gICAgICB0aGF0Ll9pID0gaWQrKzsgLy8gY29sbGVjdGlvbiBpZFxuXG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAvLyBsZWFrIHN0b3JlIGZvciB1bmNhdWdodCBmcm96ZW4gb2JqZWN0c1xuXG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy40LjMuMyBXZWFrU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSkgJiYgZGVsZXRlIGRhdGFbdGhpcy5faV07XG4gICAgICB9LFxuICAgICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSkuaGFzKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZGF0YSA9IGdldFdlYWsoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XG4gICAgaWYgKGRhdGEgPT09IHRydWUpIHVuY2F1Z2h0RnJvemVuU3RvcmUodGhhdCkuc2V0KGtleSwgdmFsdWUpO2Vsc2UgZGF0YVt0aGF0Ll9pXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGF0O1xuICB9LFxuICB1ZnN0b3JlOiB1bmNhdWdodEZyb3plblN0b3JlXG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xuXG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcblxudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG5cbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG52YXIgJGl0ZXJEZXRlY3QgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpO1xuXG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xuXG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKSB7XG4gIHZhciBCYXNlID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgQyA9IEJhc2U7XG4gIHZhciBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCc7XG4gIHZhciBwcm90byA9IEMgJiYgQy5wcm90b3R5cGU7XG4gIHZhciBPID0ge307XG5cbiAgdmFyIGZpeE1ldGhvZCA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgICB2YXIgZm4gPSBwcm90b1tLRVldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBLRVksIEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICB9IDogS0VZID09ICdoYXMnID8gZnVuY3Rpb24gaGFzKGEpIHtcbiAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgIH0gOiBLRVkgPT0gJ2dldCcgPyBmdW5jdGlvbiBnZXQoYSkge1xuICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gdW5kZWZpbmVkIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgIH0gOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSkge1xuICAgICAgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSA6IGZ1bmN0aW9uIHNldChhLCBiKSB7XG4gICAgICBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSwgYik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfTtcblxuICBpZiAodHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBDKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKSB7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDKCk7IC8vIGVhcmx5IGltcGxlbWVudGF0aW9ucyBub3Qgc3VwcG9ydHMgY2hhaW5pbmdcblxuICAgIHZhciBIQVNOVF9DSEFJTklORyA9IGluc3RhbmNlW0FEREVSXShJU19XRUFLID8ge30gOiAtMCwgMSkgIT0gaW5zdGFuY2U7IC8vIFY4IH4gIENocm9taXVtIDQwLSB3ZWFrLWNvbGxlY3Rpb25zIHRocm93cyBvbiBwcmltaXRpdmVzLCBidXQgc2hvdWxkIHJldHVybiBmYWxzZVxuXG4gICAgdmFyIFRIUk9XU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgaW5zdGFuY2UuaGFzKDEpO1xuICAgIH0pOyAvLyBtb3N0IGVhcmx5IGltcGxlbWVudGF0aW9ucyBkb2Vzbid0IHN1cHBvcnRzIGl0ZXJhYmxlcywgbW9zdCBtb2Rlcm4gLSBub3QgY2xvc2UgaXQgY29ycmVjdGx5XG5cbiAgICB2YXIgQUNDRVBUX0lURVJBQkxFUyA9ICRpdGVyRGV0ZWN0KGZ1bmN0aW9uIChpdGVyKSB7XG4gICAgICBuZXcgQyhpdGVyKTtcbiAgICB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAvLyBmb3IgZWFybHkgaW1wbGVtZW50YXRpb25zIC0wIGFuZCArMCBub3QgdGhlIHNhbWVcblxuICAgIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICB2YXIgJGluc3RhbmNlID0gbmV3IEMoKTtcbiAgICAgIHZhciBpbmRleCA9IDU7XG5cbiAgICAgIHdoaWxlIChpbmRleC0tKSAkaW5zdGFuY2VbQURERVJdKGluZGV4LCBpbmRleCk7XG5cbiAgICAgIHJldHVybiAhJGluc3RhbmNlLmhhcygtMCk7XG4gICAgfSk7XG5cbiAgICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSgpLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSBDO1xuICAgIH1cblxuICAgIGlmIChUSFJPV1NfT05fUFJJTUlUSVZFUyB8fCBCVUdHWV9aRVJPKSB7XG4gICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICAgIH1cblxuICAgIGlmIChCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKSBmaXhNZXRob2QoQURERVIpOyAvLyB3ZWFrIGNvbGxlY3Rpb25zIHNob3VsZCBub3QgY29udGFpbnMgLmNsZWFyIG1ldGhvZFxuXG4gICAgaWYgKElTX1dFQUsgJiYgcHJvdG8uY2xlYXIpIGRlbGV0ZSBwcm90by5jbGVhcjtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoQyAhPSBCYXNlKSwgTyk7XG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuICByZXR1cm4gQztcbn07IiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmVyc2lvbjogJzIuNi4xMSdcbn07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsIid1c2Ugc3RyaWN0JztcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO2Vsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xufTsiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuXG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgICAgfTtcblxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpXG4gIC8qIC4uLmFyZ3MgKi9cbiAge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTsiLCIndXNlIHN0cmljdCc7IC8vIDIwLjMuNC4zNiAvIDE1LjkuNS40MyBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZygpXG5cbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbnZhciBnZXRUaW1lID0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZTtcbnZhciAkdG9JU09TdHJpbmcgPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZztcblxudmFyIGx6ID0gZnVuY3Rpb24gKG51bSkge1xuICByZXR1cm4gbnVtID4gOSA/IG51bSA6ICcwJyArIG51bTtcbn07IC8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJHRvSVNPU3RyaW5nLmNhbGwobmV3IERhdGUoLTVlMTMgLSAxKSkgIT0gJzAzODUtMDctMjVUMDc6MDY6MzkuOTk5Wic7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAkdG9JU09TdHJpbmcuY2FsbChuZXcgRGF0ZShOYU4pKTtcbn0pID8gZnVuY3Rpb24gdG9JU09TdHJpbmcoKSB7XG4gIGlmICghaXNGaW5pdGUoZ2V0VGltZS5jYWxsKHRoaXMpKSkgdGhyb3cgUmFuZ2VFcnJvcignSW52YWxpZCB0aW1lIHZhbHVlJyk7XG4gIHZhciBkID0gdGhpcztcbiAgdmFyIHkgPSBkLmdldFVUQ0Z1bGxZZWFyKCk7XG4gIHZhciBtID0gZC5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgdmFyIHMgPSB5IDwgMCA/ICctJyA6IHkgPiA5OTk5ID8gJysnIDogJyc7XG4gIHJldHVybiBzICsgKCcwMDAwMCcgKyBNYXRoLmFicyh5KSkuc2xpY2UocyA/IC02IDogLTQpICsgJy0nICsgbHooZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBseihkLmdldFVUQ0RhdGUoKSkgKyAnVCcgKyBseihkLmdldFVUQ0hvdXJzKCkpICsgJzonICsgbHooZC5nZXRVVENNaW51dGVzKCkpICsgJzonICsgbHooZC5nZXRVVENTZWNvbmRzKCkpICsgJy4nICsgKG0gPiA5OSA/IG0gOiAnMCcgKyBseihtKSkgKyAnWic7XG59IDogJHRvSVNPU3RyaW5nOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG52YXIgTlVNQkVSID0gJ251bWJlcic7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGhpbnQpIHtcbiAgaWYgKGhpbnQgIT09ICdzdHJpbmcnICYmIGhpbnQgIT09IE5VTUJFUiAmJiBoaW50ICE9PSAnZGVmYXVsdCcpIHRocm93IFR5cGVFcnJvcignSW5jb3JyZWN0IGhpbnQnKTtcbiAgcmV0dXJuIHRvUHJpbWl0aXZlKGFuT2JqZWN0KHRoaXMpLCBoaW50ICE9IE5VTUJFUik7XG59OyIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDc7XG4gICAgfVxuICB9KS5hICE9IDc7XG59KTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7IC8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxuXG5cbnZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07IiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJy5zcGxpdCgnLCcpOyIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcblxudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcblxuICBpZiAoZ2V0U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdCk7XG4gICAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5O1xuXG4gICAgd2hpbGUgKHN5bWJvbHMubGVuZ3RoID4gaSkgaWYgKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKSByZXN1bHQucHVzaChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07IiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcblxudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5cbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5cbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcblxudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KTtcbiAgdmFyIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcblxuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkOyAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTsgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcblxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0OyAvLyBleHRlbmQgZ2xvYmFsXG5cbiAgICBpZiAodGFyZ2V0KSByZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTsgLy8gZXhwb3J0XG5cbiAgICBpZiAoZXhwb3J0c1trZXldICE9IG91dCkgaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYgKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KSBleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuXG5nbG9iYWwuY29yZSA9IGNvcmU7IC8vIHR5cGUgYml0bWFwXG5cbiRleHBvcnQuRiA9IDE7IC8vIGZvcmNlZFxuXG4kZXhwb3J0LkcgPSAyOyAvLyBnbG9iYWxcblxuJGV4cG9ydC5TID0gNDsgLy8gc3RhdGljXG5cbiRleHBvcnQuUCA9IDg7IC8vIHByb3RvXG5cbiRleHBvcnQuQiA9IDE2OyAvLyBiaW5kXG5cbiRleHBvcnQuVyA9IDMyOyAvLyB3cmFwXG5cbiRleHBvcnQuVSA9IDY0OyAvLyBzYWZlXG5cbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxuXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7IiwidmFyIE1BVENIID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgcmUgPSAvLi87XG5cbiAgdHJ5IHtcbiAgICAnLy4vJ1tLRVldKHJlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICByZVtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAhJy8uLydbS0VZXShyZSk7XG4gICAgfSBjYXRjaCAoZikge1xuICAgICAgLyogZW1wdHkgKi9cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9lczYucmVnZXhwLmV4ZWMnKTtcblxudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcblxudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5cbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cbnZhciByZWdleHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMnKTtcblxudmFyIFNQRUNJRVMgPSB3a3MoJ3NwZWNpZXMnKTtcbnZhciBSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vICNyZXBsYWNlIG5lZWRzIGJ1aWx0LWluIHN1cHBvcnQgZm9yIG5hbWVkIGdyb3Vwcy5cbiAgLy8gI21hdGNoIHdvcmtzIGZpbmUgYmVjYXVzZSBpdCBqdXN0IHJldHVybiB0aGUgZXhlYyByZXN1bHRzLCBldmVuIGlmIGl0IGhhc1xuICAvLyBhIFwiZ3JvcHNcIiBwcm9wZXJ0eS5cbiAgdmFyIHJlID0gLy4vO1xuXG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdC5ncm91cHMgPSB7XG4gICAgICBhOiAnNydcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuICcnLnJlcGxhY2UocmUsICckPGE+JykgIT09ICc3Jztcbn0pO1xuXG52YXIgU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDID0gZnVuY3Rpb24gKCkge1xuICAvLyBDaHJvbWUgNTEgaGFzIGEgYnVnZ3kgXCJzcGxpdFwiIGltcGxlbWVudGF0aW9uIHdoZW4gUmVnRXhwI2V4ZWMgIT09IG5hdGl2ZUV4ZWNcbiAgdmFyIHJlID0gLyg/OikvO1xuICB2YXIgb3JpZ2luYWxFeGVjID0gcmUuZXhlYztcblxuICByZS5leGVjID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBvcmlnaW5hbEV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICB2YXIgcmVzdWx0ID0gJ2FiJy5zcGxpdChyZSk7XG4gIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAyICYmIHJlc3VsdFswXSA9PT0gJ2EnICYmIHJlc3VsdFsxXSA9PT0gJ2InO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGxlbmd0aCwgZXhlYykge1xuICB2YXIgU1lNQk9MID0gd2tzKEtFWSk7XG4gIHZhciBERUxFR0FURVNfVE9fU1lNQk9MID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTdHJpbmcgbWV0aG9kcyBjYWxsIHN5bWJvbC1uYW1lZCBSZWdFcCBtZXRob2RzXG4gICAgdmFyIE8gPSB7fTtcblxuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiA3O1xuICAgIH07XG5cbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KTtcbiAgdmFyIERFTEVHQVRFU19UT19FWEVDID0gREVMRUdBVEVTX1RPX1NZTUJPTCA/ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3ltYm9sLW5hbWVkIFJlZ0V4cCBtZXRob2RzIGNhbGwgLmV4ZWNcbiAgICB2YXIgZXhlY0NhbGxlZCA9IGZhbHNlO1xuICAgIHZhciByZSA9IC9hLztcblxuICAgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBleGVjQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBpZiAoS0VZID09PSAnc3BsaXQnKSB7XG4gICAgICAvLyBSZWdFeHBbQEBzcGxpdF0gZG9lc24ndCBjYWxsIHRoZSByZWdleCdzIGV4ZWMgbWV0aG9kLCBidXQgZmlyc3QgY3JlYXRlc1xuICAgICAgLy8gYSBuZXcgb25lLiBXZSBuZWVkIHRvIHJldHVybiB0aGUgcGF0Y2hlZCByZWdleCB3aGVuIGNyZWF0aW5nIHRoZSBuZXcgb25lLlxuICAgICAgcmUuY29uc3RydWN0b3IgPSB7fTtcblxuICAgICAgcmUuY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmVbU1lNQk9MXSgnJyk7XG4gICAgcmV0dXJuICFleGVjQ2FsbGVkO1xuICB9KSA6IHVuZGVmaW5lZDtcblxuICBpZiAoIURFTEVHQVRFU19UT19TWU1CT0wgfHwgIURFTEVHQVRFU19UT19FWEVDIHx8IEtFWSA9PT0gJ3JlcGxhY2UnICYmICFSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyB8fCBLRVkgPT09ICdzcGxpdCcgJiYgIVNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQykge1xuICAgIHZhciBuYXRpdmVSZWdFeHBNZXRob2QgPSAvLi9bU1lNQk9MXTtcbiAgICB2YXIgZm5zID0gZXhlYyhkZWZpbmVkLCBTWU1CT0wsICcnW0tFWV0sIGZ1bmN0aW9uIG1heWJlQ2FsbE5hdGl2ZShuYXRpdmVNZXRob2QsIHJlZ2V4cCwgc3RyLCBhcmcyLCBmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgaWYgKHJlZ2V4cC5leGVjID09PSByZWdleHBFeGVjKSB7XG4gICAgICAgIGlmIChERUxFR0FURVNfVE9fU1lNQk9MICYmICFmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgICAgIC8vIFRoZSBuYXRpdmUgU3RyaW5nIG1ldGhvZCBhbHJlYWR5IGRlbGVnYXRlcyB0byBAQG1ldGhvZCAodGhpc1xuICAgICAgICAgIC8vIHBvbHlmaWxsZWQgZnVuY3Rpb24pLCBsZWFzaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICAgICAgICAvLyBXZSBhdm9pZCBpdCBieSBkaXJlY3RseSBjYWxsaW5nIHRoZSBuYXRpdmUgQEBtZXRob2QgbWV0aG9kLlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5hdGl2ZVJlZ0V4cE1ldGhvZC5jYWxsKHJlZ2V4cCwgc3RyLCBhcmcyKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IG5hdGl2ZU1ldGhvZC5jYWxsKHN0ciwgcmVnZXhwLCBhcmcyKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9KTtcbiAgICB2YXIgc3RyZm4gPSBmbnNbMF07XG4gICAgdmFyIHJ4Zm4gPSBmbnNbMV07XG4gICAgcmVkZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBzdHJmbik7XG4gICAgaGlkZShSZWdFeHAucHJvdG90eXBlLCBTWU1CT0wsIGxlbmd0aCA9PSAyIC8vIDIxLjIuNS44IFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXShzdHJpbmcsIHJlcGxhY2VWYWx1ZSlcbiAgICAvLyAyMS4yLjUuMTEgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XShzdHJpbmcsIGxpbWl0KVxuICAgID8gZnVuY3Rpb24gKHN0cmluZywgYXJnKSB7XG4gICAgICByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcywgYXJnKTtcbiAgICB9IC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcbiAgICA6IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgIHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzKTtcbiAgICB9KTtcbiAgfVxufTsiLCIndXNlIHN0cmljdCc7IC8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzXG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQudW5pY29kZSkgcmVzdWx0ICs9ICd1JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTsiLCIndXNlIHN0cmljdCc7IC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtZmxhdE1hcC8jc2VjLUZsYXR0ZW5JbnRvQXJyYXlcblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcblxudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFID0gcmVxdWlyZSgnLi9fd2tzJykoJ2lzQ29uY2F0U3ByZWFkYWJsZScpO1xuXG5mdW5jdGlvbiBmbGF0dGVuSW50b0FycmF5KHRhcmdldCwgb3JpZ2luYWwsIHNvdXJjZSwgc291cmNlTGVuLCBzdGFydCwgZGVwdGgsIG1hcHBlciwgdGhpc0FyZykge1xuICB2YXIgdGFyZ2V0SW5kZXggPSBzdGFydDtcbiAgdmFyIHNvdXJjZUluZGV4ID0gMDtcbiAgdmFyIG1hcEZuID0gbWFwcGVyID8gY3R4KG1hcHBlciwgdGhpc0FyZywgMykgOiBmYWxzZTtcbiAgdmFyIGVsZW1lbnQsIHNwcmVhZGFibGU7XG5cbiAgd2hpbGUgKHNvdXJjZUluZGV4IDwgc291cmNlTGVuKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4IGluIHNvdXJjZSkge1xuICAgICAgZWxlbWVudCA9IG1hcEZuID8gbWFwRm4oc291cmNlW3NvdXJjZUluZGV4XSwgc291cmNlSW5kZXgsIG9yaWdpbmFsKSA6IHNvdXJjZVtzb3VyY2VJbmRleF07XG4gICAgICBzcHJlYWRhYmxlID0gZmFsc2U7XG5cbiAgICAgIGlmIChpc09iamVjdChlbGVtZW50KSkge1xuICAgICAgICBzcHJlYWRhYmxlID0gZWxlbWVudFtJU19DT05DQVRfU1BSRUFEQUJMRV07XG4gICAgICAgIHNwcmVhZGFibGUgPSBzcHJlYWRhYmxlICE9PSB1bmRlZmluZWQgPyAhIXNwcmVhZGFibGUgOiBpc0FycmF5KGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3ByZWFkYWJsZSAmJiBkZXB0aCA+IDApIHtcbiAgICAgICAgdGFyZ2V0SW5kZXggPSBmbGF0dGVuSW50b0FycmF5KHRhcmdldCwgb3JpZ2luYWwsIGVsZW1lbnQsIHRvTGVuZ3RoKGVsZW1lbnQubGVuZ3RoKSwgdGFyZ2V0SW5kZXgsIGRlcHRoIC0gMSkgLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRhcmdldEluZGV4ID49IDB4MWZmZmZmZmZmZmZmZmYpIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICB0YXJnZXRbdGFyZ2V0SW5kZXhdID0gZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0SW5kZXgrKztcbiAgICB9XG5cbiAgICBzb3VyY2VJbmRleCsrO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldEluZGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW5JbnRvQXJyYXk7IiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xuXG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xuXG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbnZhciBCUkVBSyA9IHt9O1xudmFyIFJFVFVSTiA9IHt9O1xuXG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1IpIHtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpdGVyYWJsZTtcbiAgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTsgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG5cbiAgaWYgKGlzQXJyYXlJdGVyKGl0ZXJGbikpIGZvciAobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7KSB7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbmV4cG9ydHMuQlJFQUsgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ25hdGl2ZS1mdW5jdGlvbi10by1zdHJpbmcnLCBGdW5jdGlvbi50b1N0cmluZyk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aCA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbjogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07IiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTsiLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcblxubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7IiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gNztcbiAgICB9XG4gIH0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHRhcmdldCwgQykge1xuICB2YXIgUyA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgdmFyIFA7XG5cbiAgaWYgKFMgIT09IEMgJiYgdHlwZW9mIFMgPT0gJ2Z1bmN0aW9uJyAmJiAoUCA9IFMucHJvdG90eXBlKSAhPT0gQy5wcm90b3R5cGUgJiYgaXNPYmplY3QoUCkgJiYgc2V0UHJvdG90eXBlT2YpIHtcbiAgICBzZXRQcm90b3R5cGVPZih0aGF0LCBQKTtcbiAgfVxuXG4gIHJldHVybiB0aGF0O1xufTsiLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCBhcmdzLCB0aGF0KSB7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcblxuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIHVuID8gZm4oKSA6IGZuLmNhbGwodGhhdCk7XG5cbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gdW4gPyBmbihhcmdzWzBdKSA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKSA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG5cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKSA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG5cbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKSA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH1cblxuICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJncyk7XG59OyIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07IiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xuXG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcblxudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59OyIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07IiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0ludGVnZXIoaXQpIHtcbiAgcmV0dXJuICFpc09iamVjdChpdCkgJiYgaXNGaW5pdGUoaXQpICYmIGZsb29yKGl0KSA9PT0gaXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59OyIsIi8vIDcuMi44IElzUmVnRXhwKGFyZ3VtZW50KVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcblxudmFyIE1BVENIID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0hdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNvZihpdCkgPT0gJ1JlZ0V4cCcpO1xufTsiLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykge1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7IC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcblxudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9OyAvLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxuXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge1xuICAgIG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dClcbiAgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xuXG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcblxudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xuXG52YXIgJGl0ZXJDcmVhdGUgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpO1xuXG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xuXG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xuXG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcblxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG5cbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgS0VZUzpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTtcbiAgICAgICAgfTtcblxuICAgICAgY2FzZSBWQUxVRVM6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTO1xuICB2YXIgVkFMVUVTX0JVRyA9IGZhbHNlO1xuICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcbiAgdmFyICRuYXRpdmUgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF07XG4gIHZhciAkZGVmYXVsdCA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpO1xuICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkO1xuICB2YXIgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmU7XG4gIHZhciBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlOyAvLyBGaXggbmF0aXZlXG5cbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG5cbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7IC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9IC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcblxuXG4gIGlmIChERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcblxuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICB9IC8vIERlZmluZSBpdGVyYXRvclxuXG5cbiAgaWYgKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKSB7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfSAvLyBQbHVnIGZvciBsaWJyYXJ5XG5cblxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuXG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gcHJvdG8pKSByZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cblxuICByZXR1cm4gbWV0aG9kcztcbn07IiwidmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG5cbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuXG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBTQUZFX0NMT1NJTkcgPSB0cnVlO1xuICB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuXG5cbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24gKCkge1xuICAgIHRocm93IDI7XG4gIH0pO1xufSBjYXRjaCAoZSkge1xuICAvKiBlbXB0eSAqL1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBza2lwQ2xvc2luZykge1xuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcblxuICB0cnkge1xuICAgIHZhciBhcnIgPSBbN107XG4gICAgdmFyIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG5cbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBzYWZlID0gdHJ1ZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpdGVyO1xuICAgIH07XG5cbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9XG5cbiAgcmV0dXJuIHNhZmU7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbmUsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRvbmU6ICEhZG9uZVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHt9OyIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7IiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwbTEgPSBNYXRoLmV4cG0xO1xubW9kdWxlLmV4cG9ydHMgPSAhJGV4cG0xIC8vIE9sZCBGRiBidWdcbnx8ICRleHBtMSgxMCkgPiAyMjAyNS40NjU3OTQ4MDY3MTkgfHwgJGV4cG0xKDEwKSA8IDIyMDI1LjQ2NTc5NDgwNjcxNjUxNjggLy8gVG9yIEJyb3dzZXIgYnVnXG58fCAkZXhwbTEoLTJlLTE3KSAhPSAtMmUtMTcgPyBmdW5jdGlvbiBleHBtMSh4KSB7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IHggPiAtMWUtNiAmJiB4IDwgMWUtNiA/IHggKyB4ICogeCAvIDIgOiBNYXRoLmV4cCh4KSAtIDE7XG59IDogJGV4cG0xOyIsIi8vIDIwLjIuMi4xNiBNYXRoLmZyb3VuZCh4KVxudmFyIHNpZ24gPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKTtcblxudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIEVQU0lMT04gPSBwb3coMiwgLTUyKTtcbnZhciBFUFNJTE9OMzIgPSBwb3coMiwgLTIzKTtcbnZhciBNQVgzMiA9IHBvdygyLCAxMjcpICogKDIgLSBFUFNJTE9OMzIpO1xudmFyIE1JTjMyID0gcG93KDIsIC0xMjYpO1xuXG52YXIgcm91bmRUaWVzVG9FdmVuID0gZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuIG4gKyAxIC8gRVBTSUxPTiAtIDEgLyBFUFNJTE9OO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmZyb3VuZCB8fCBmdW5jdGlvbiBmcm91bmQoeCkge1xuICB2YXIgJGFicyA9IE1hdGguYWJzKHgpO1xuICB2YXIgJHNpZ24gPSBzaWduKHgpO1xuICB2YXIgYSwgcmVzdWx0O1xuICBpZiAoJGFicyA8IE1JTjMyKSByZXR1cm4gJHNpZ24gKiByb3VuZFRpZXNUb0V2ZW4oJGFicyAvIE1JTjMyIC8gRVBTSUxPTjMyKSAqIE1JTjMyICogRVBTSUxPTjMyO1xuICBhID0gKDEgKyBFUFNJTE9OMzIgLyBFUFNJTE9OKSAqICRhYnM7XG4gIHJlc3VsdCA9IGEgLSAoYSAtICRhYnMpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG5cbiAgaWYgKHJlc3VsdCA+IE1BWDMyIHx8IHJlc3VsdCAhPSByZXN1bHQpIHJldHVybiAkc2lnbiAqIEluZmluaXR5O1xuICByZXR1cm4gJHNpZ24gKiByZXN1bHQ7XG59OyIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgubG9nMXAgfHwgZnVuY3Rpb24gbG9nMXAoeCkge1xuICByZXR1cm4gKHggPSAreCkgPiAtMWUtOCAmJiB4IDwgMWUtOCA/IHggLSB4ICogeCAvIDIgOiBNYXRoLmxvZygxICsgeCk7XG59OyIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5zY2FsZSB8fCBmdW5jdGlvbiBzY2FsZSh4LCBpbkxvdywgaW5IaWdoLCBvdXRMb3csIG91dEhpZ2gpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICB8fCB4ICE9IHggLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICB8fCBpbkxvdyAhPSBpbkxvdyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHx8IGluSGlnaCAhPSBpbkhpZ2ggLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICB8fCBvdXRMb3cgIT0gb3V0TG93IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgfHwgb3V0SGlnaCAhPSBvdXRIaWdoKSByZXR1cm4gTmFOO1xuICBpZiAoeCA9PT0gSW5maW5pdHkgfHwgeCA9PT0gLUluZmluaXR5KSByZXR1cm4geDtcbiAgcmV0dXJuICh4IC0gaW5Mb3cpICogKG91dEhpZ2ggLSBvdXRMb3cpIC8gKGluSGlnaCAtIGluTG93KSArIG91dExvdztcbn07IiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gc2lnbih4KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xufTsiLCJ2YXIgTUVUQSA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJyk7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG5cbnZhciBzZXREZXNjID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcblxudmFyIGlkID0gMDtcblxudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcblxudmFyIHNldE1ldGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgc2V0RGVzYyhpdCwgTUVUQSwge1xuICAgIHZhbHVlOiB7XG4gICAgICBpOiAnTycgKyArK2lkLFxuICAgICAgLy8gb2JqZWN0IElEXG4gICAgICB3OiB7fSAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuXG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcblxuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJzsgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcblxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnOyAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuXG4gICAgc2V0TWV0YShpdCk7IC8vIHJldHVybiBvYmplY3QgSURcbiAgfVxuXG4gIHJldHVybiBpdFtNRVRBXS5pO1xufTtcblxudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7IC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG5cbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlOyAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuXG4gICAgc2V0TWV0YShpdCk7IC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH1cblxuICByZXR1cm4gaXRbTUVUQV0udztcbn07IC8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xuXG5cbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKSBzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59OyIsInZhciBNYXAgPSByZXF1aXJlKCcuL2VzNi5tYXAnKTtcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdtZXRhZGF0YScpO1xuXG52YXIgc3RvcmUgPSBzaGFyZWQuc3RvcmUgfHwgKHNoYXJlZC5zdG9yZSA9IG5ldyAocmVxdWlyZSgnLi9lczYud2Vhay1tYXAnKSkoKSk7XG5cbnZhciBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0S2V5LCBjcmVhdGUpIHtcbiAgdmFyIHRhcmdldE1ldGFkYXRhID0gc3RvcmUuZ2V0KHRhcmdldCk7XG5cbiAgaWYgKCF0YXJnZXRNZXRhZGF0YSkge1xuICAgIGlmICghY3JlYXRlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHN0b3JlLnNldCh0YXJnZXQsIHRhcmdldE1ldGFkYXRhID0gbmV3IE1hcCgpKTtcbiAgfVxuXG4gIHZhciBrZXlNZXRhZGF0YSA9IHRhcmdldE1ldGFkYXRhLmdldCh0YXJnZXRLZXkpO1xuXG4gIGlmICgha2V5TWV0YWRhdGEpIHtcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB0YXJnZXRNZXRhZGF0YS5zZXQodGFyZ2V0S2V5LCBrZXlNZXRhZGF0YSA9IG5ldyBNYXAoKSk7XG4gIH1cblxuICByZXR1cm4ga2V5TWV0YWRhdGE7XG59O1xuXG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTywgUCkge1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKTtcbiAgcmV0dXJuIG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG1ldGFkYXRhTWFwLmhhcyhNZXRhZGF0YUtleSk7XG59O1xuXG52YXIgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTywgUCkge1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKTtcbiAgcmV0dXJuIG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBtZXRhZGF0YU1hcC5nZXQoTWV0YWRhdGFLZXkpO1xufTtcblxudmFyIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUsIE8sIFApIHtcbiAgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCB0cnVlKS5zZXQoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUpO1xufTtcblxudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0S2V5KSB7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAodGFyZ2V0LCB0YXJnZXRLZXksIGZhbHNlKTtcbiAgdmFyIGtleXMgPSBbXTtcbiAgaWYgKG1ldGFkYXRhTWFwKSBtZXRhZGF0YU1hcC5mb3JFYWNoKGZ1bmN0aW9uIChfLCBrZXkpIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfSk7XG4gIHJldHVybiBrZXlzO1xufTtcblxudmFyIHRvTWV0YUtleSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6IFN0cmluZyhpdCk7XG59O1xuXG52YXIgZXhwID0gZnVuY3Rpb24gKE8pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgTyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RvcmU6IHN0b3JlLFxuICBtYXA6IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAsXG4gIGhhczogb3JkaW5hcnlIYXNPd25NZXRhZGF0YSxcbiAgZ2V0OiBvcmRpbmFyeUdldE93bk1ldGFkYXRhLFxuICBzZXQ6IG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEsXG4gIGtleXM6IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzLFxuICBrZXk6IHRvTWV0YUtleSxcbiAgZXhwOiBleHBcbn07IiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcblxudmFyIE9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG5cbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSgpO2Vsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9OyAvLyBOb2RlLmpzXG5cblxuICBpZiAoaXNOb2RlKSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTsgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyLCBleGNlcHQgaU9TIFNhZmFyaSAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMzlcblxuICB9IGVsc2UgaWYgKE9ic2VydmVyICYmICEoZ2xvYmFsLm5hdmlnYXRvciAmJiBnbG9iYWwubmF2aWdhdG9yLnN0YW5kYWxvbmUpKSB7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWU7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcblxuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTsgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcblxuICB9IGVsc2UgaWYgKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKSB7XG4gICAgLy8gUHJvbWlzZS5yZXNvbHZlIHdpdGhvdXQgYW4gYXJndW1lbnQgdGhyb3dzIGFuIGVycm9yIGluIExHIFdlYk9TIDJcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuXG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9OyAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAgIC8vIC0gc2V0SW1tZWRpYXRlXG4gICAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAgIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAgIC8vIC0gc2V0VGltZW91dFxuXG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgdGFzayA9IHtcbiAgICAgIGZuOiBmbixcbiAgICAgIG5leHQ6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG5cbiAgICBpZiAoIWhlYWQpIHtcbiAgICAgIGhlYWQgPSB0YXNrO1xuICAgICAgbm90aWZ5KCk7XG4gICAgfVxuXG4gICAgbGFzdCA9IHRhc2s7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JzsgLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcblxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxuZnVuY3Rpb24gUHJvbWlzZUNhcGFiaWxpdHkoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFGdW5jdGlvbihyZWplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07IiwiJ3VzZSBzdHJpY3QnOyAvLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG5cbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG5cbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xuXG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG5cbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjsgLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5cbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICBCW2tdID0gaztcbiAgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHZhciBpc0VudW0gPSBwSUUuZjtcblxuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcblxuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XG4gICAgICBrZXkgPSBrZXlzW2orK107XG4gICAgICBpZiAoIURFU0NSSVBUT1JTIHx8IGlzRW51bS5jYWxsKFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVDtcbn0gOiAkYXNzaWduOyIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG5cbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gIC8qIGVtcHR5ICovXG59O1xuXG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7IC8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcblxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuXG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblxuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcblxuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG5cbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG5cbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuXG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsOyAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG5cbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcblxuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59OyIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xuXG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07IiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcblxuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcblxuICByZXR1cm4gTztcbn07IiwiJ3VzZSBzdHJpY3QnOyAvLyBGb3JjZWQgcmVwbGFjZW1lbnQgcHJvdG90eXBlIGFjY2Vzc29ycyBtZXRob2RzXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fbGlicmFyeScpIHx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEsgPSBNYXRoLnJhbmRvbSgpOyAvLyBJbiBGRiB0aHJvd3Mgb25seSBkZWZpbmUgbWV0aG9kc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWYsIG5vLXVzZWxlc3MtY2FsbFxuXG4gIF9fZGVmaW5lU2V0dGVyX18uY2FsbChudWxsLCBLLCBmdW5jdGlvbiAoKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfSk7XG5cbiAgZGVsZXRlIHJlcXVpcmUoJy4vX2dsb2JhbCcpW0tdO1xufSk7IiwidmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcblxudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG5cbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG5cbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07IiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTsiLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xuXG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07IiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sczsiLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG5cbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH1cblxuICByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07IiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG5cbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcblxuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpOyAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG5cblxuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTsiLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG5cbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07IiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7IiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcblxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBmbigxKTtcbiAgfSksICdPYmplY3QnLCBleHApO1xufTsiLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xuXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbnZhciBpc0VudW0gPSByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXNFbnRyaWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdChpdCk7XG4gICAgdmFyIGtleXMgPSBnZXRLZXlzKE8pO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBrZXk7XG5cbiAgICB3aGlsZSAobGVuZ3RoID4gaSkge1xuICAgICAga2V5ID0ga2V5c1tpKytdO1xuXG4gICAgICBpZiAoIURFU0NSSVBUT1JTIHx8IGlzRW51bS5jYWxsKE8sIGtleSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goaXNFbnRyaWVzID8gW2tleSwgT1trZXldXSA6IE9ba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07IiwiLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpO1xuXG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgUmVmbGVjdCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3Q7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVmbGVjdCAmJiBSZWZsZWN0Lm93bktleXMgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdPUE4uZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTsiLCJ2YXIgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wYXJzZUZsb2F0O1xuXG52YXIgJHRyaW0gPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG5cbm1vZHVsZS5leHBvcnRzID0gMSAvICRwYXJzZUZsb2F0KHJlcXVpcmUoJy4vX3N0cmluZy13cycpICsgJy0wJykgIT09IC1JbmZpbml0eSA/IGZ1bmN0aW9uIHBhcnNlRmxvYXQoc3RyKSB7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMyk7XG4gIHZhciByZXN1bHQgPSAkcGFyc2VGbG9hdChzdHJpbmcpO1xuICByZXR1cm4gcmVzdWx0ID09PSAwICYmIHN0cmluZy5jaGFyQXQoMCkgPT0gJy0nID8gLTAgOiByZXN1bHQ7XG59IDogJHBhcnNlRmxvYXQ7IiwidmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlSW50O1xuXG52YXIgJHRyaW0gPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG5cbnZhciB3cyA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpO1xuXG52YXIgaGV4ID0gL15bLStdPzBbeFhdLztcbm1vZHVsZS5leHBvcnRzID0gJHBhcnNlSW50KHdzICsgJzA4JykgIT09IDggfHwgJHBhcnNlSW50KHdzICsgJzB4MTYnKSAhPT0gMjIgPyBmdW5jdGlvbiBwYXJzZUludChzdHIsIHJhZGl4KSB7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMyk7XG4gIHJldHVybiAkcGFyc2VJbnQoc3RyaW5nLCByYWRpeCA+Pj4gMCB8fCAoaGV4LnRlc3Qoc3RyaW5nKSA/IDE2IDogMTApKTtcbn0gOiAkcGFyc2VJbnQ7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7XG4gICAgICBlOiBmYWxzZSxcbiAgICAgIHY6IGV4ZWMoKVxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZTogdHJ1ZSxcbiAgICAgIHY6IGVcbiAgICB9O1xuICB9XG59OyIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0KEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07IiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBzYWZlKTtcblxuICByZXR1cm4gdGFyZ2V0O1xufTsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xuXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG5cbnZhciBTUkMgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJyk7XG5cbnZhciAkdG9TdHJpbmcgPSByZXF1aXJlKCcuL19mdW5jdGlvbi10by1zdHJpbmcnKTtcblxudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgVFBMID0gKCcnICsgJHRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xuXG5yZXF1aXJlKCcuL19jb3JlJykuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsLCBzYWZlKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgJ25hbWUnKSB8fCBoaWRlKHZhbCwgJ25hbWUnLCBrZXkpO1xuICBpZiAoT1trZXldID09PSB2YWwpIHJldHVybjtcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuXG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfSAvLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcblxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzW1NSQ10gfHwgJHRvU3RyaW5nLmNhbGwodGhpcyk7XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xuXG52YXIgYnVpbHRpbkV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7IC8vIGBSZWdFeHBFeGVjYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cGV4ZWNcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUiwgUykge1xuICB2YXIgZXhlYyA9IFIuZXhlYztcblxuICBpZiAodHlwZW9mIGV4ZWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmVzdWx0ID0gZXhlYy5jYWxsKFIsIFMpO1xuXG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWdFeHAgZXhlYyBtZXRob2QgcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYW4gT2JqZWN0IG9yIG51bGwnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKGNsYXNzb2YoUikgIT09ICdSZWdFeHAnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlcicpO1xuICB9XG5cbiAgcmV0dXJuIGJ1aWx0aW5FeGVjLmNhbGwoUiwgUyk7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlZ2V4cEZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcblxudmFyIG5hdGl2ZUV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWM7IC8vIFRoaXMgYWx3YXlzIHJlZmVycyB0byB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlIHRoZVxuLy8gU3RyaW5nI3JlcGxhY2UgcG9seWZpbGwgdXNlcyAuL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMsXG4vLyB3aGljaCBsb2FkcyB0aGlzIGZpbGUgYmVmb3JlIHBhdGNoaW5nIHRoZSBtZXRob2QuXG5cbnZhciBuYXRpdmVSZXBsYWNlID0gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlO1xudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcbnZhciBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG5cbnZhciBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS8sXG4gICAgICByZTIgPSAvYiovZztcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMSwgJ2EnKTtcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMVtMQVNUX0lOREVYXSAhPT0gMCB8fCByZTJbTEFTVF9JTkRFWF0gIT09IDA7XG59KCk7IC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwLCBjb3BpZWQgZnJvbSBlczUtc2hpbSdzIFN0cmluZyNzcGxpdCBwYXRjaC5cblxuXG52YXIgTlBDR19JTkNMVURFRCA9IC8oKT8/Ly5leGVjKCcnKVsxXSAhPT0gdW5kZWZpbmVkO1xudmFyIFBBVENIID0gVVBEQVRFU19MQVNUX0lOREVYX1dST05HIHx8IE5QQ0dfSU5DTFVERUQ7XG5cbmlmIChQQVRDSCkge1xuICBwYXRjaGVkRXhlYyA9IGZ1bmN0aW9uIGV4ZWMoc3RyKSB7XG4gICAgdmFyIHJlID0gdGhpcztcbiAgICB2YXIgbGFzdEluZGV4LCByZUNvcHksIG1hdGNoLCBpO1xuXG4gICAgaWYgKE5QQ0dfSU5DTFVERUQpIHtcbiAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14nICsgcmUuc291cmNlICsgJyQoPyFcXFxccyknLCByZWdleHBGbGFncy5jYWxsKHJlKSk7XG4gICAgfVxuXG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmVbTEFTVF9JTkRFWF07XG4gICAgbWF0Y2ggPSBuYXRpdmVFeGVjLmNhbGwocmUsIHN0cik7XG5cbiAgICBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HICYmIG1hdGNoKSB7XG4gICAgICByZVtMQVNUX0lOREVYXSA9IHJlLmdsb2JhbCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGFzdEluZGV4O1xuICAgIH1cblxuICAgIGlmIChOUENHX0lOQ0xVREVEICYmIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgICAvLyBmb3IgTlBDRywgbGlrZSBJRTguIE5PVEU6IFRoaXMgZG9lc24nIHdvcmsgZm9yIC8oLj8pPy9cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgIG5hdGl2ZVJlcGxhY2UuY2FsbChtYXRjaFswXSwgcmVDb3B5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKSBtYXRjaFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoZWRFeGVjOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJlZ0V4cCwgcmVwbGFjZSkge1xuICB2YXIgcmVwbGFjZXIgPSByZXBsYWNlID09PSBPYmplY3QocmVwbGFjZSkgPyBmdW5jdGlvbiAocGFydCkge1xuICAgIHJldHVybiByZXBsYWNlW3BhcnRdO1xuICB9IDogcmVwbGFjZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBTdHJpbmcoaXQpLnJlcGxhY2UocmVnRXhwLCByZXBsYWNlcik7XG4gIH07XG59OyIsIi8vIDcuMi45IFNhbWVWYWx1ZSh4LCB5KVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xufTsiLCIndXNlIHN0cmljdCc7IC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS9cblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xuXG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwge1xuICAgIGZyb206IGZ1bmN0aW9uIGZyb20oc291cmNlXG4gICAgLyogLCBtYXBGbiwgdGhpc0FyZyAqL1xuICAgICkge1xuICAgICAgdmFyIG1hcEZuID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIG1hcHBpbmcsIEEsIG4sIGNiO1xuICAgICAgYUZ1bmN0aW9uKHRoaXMpO1xuICAgICAgbWFwcGluZyA9IG1hcEZuICE9PSB1bmRlZmluZWQ7XG4gICAgICBpZiAobWFwcGluZykgYUZ1bmN0aW9uKG1hcEZuKTtcbiAgICAgIGlmIChzb3VyY2UgPT0gdW5kZWZpbmVkKSByZXR1cm4gbmV3IHRoaXMoKTtcbiAgICAgIEEgPSBbXTtcblxuICAgICAgaWYgKG1hcHBpbmcpIHtcbiAgICAgICAgbiA9IDA7XG4gICAgICAgIGNiID0gY3R4KG1hcEZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgICAgICBmb3JPZihzb3VyY2UsIGZhbHNlLCBmdW5jdGlvbiAobmV4dEl0ZW0pIHtcbiAgICAgICAgICBBLnB1c2goY2IobmV4dEl0ZW0sIG4rKykpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIEEucHVzaCwgQSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgICB9XG4gIH0pO1xufTsiLCIndXNlIHN0cmljdCc7IC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS9cblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwge1xuICAgIG9mOiBmdW5jdGlvbiBvZigpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgdmFyIEEgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSBBW2xlbmd0aF0gPSBhcmd1bWVudHNbbGVuZ3RoXTtcblxuICAgICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICAgIH1cbiAgfSk7XG59OyIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkge1xuICAgIHRyeSB7XG4gICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYnVnZ3kgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgaWYgKGJ1Z2d5KSBPLl9fcHJvdG9fXyA9IHByb3RvO2Vsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgIHJldHVybiBPO1xuICAgIH07XG4gIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG5cbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XG4gIGlmIChERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKSBkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xufTsiLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcblxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuXG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB0YWdcbiAgfSk7XG59OyIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpO1xuXG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTsiLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogY29yZS52ZXJzaW9uLFxuICBtb2RlOiByZXF1aXJlKCcuL19saWJyYXJ5JykgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxOSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pOyIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgRCkge1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2FsbFxuICAgIGFyZyA/IG1ldGhvZC5jYWxsKG51bGwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qIGVtcHR5ICovXG4gICAgfSwgMSkgOiBtZXRob2QuY2FsbChudWxsKTtcbiAgfSk7XG59OyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG5cbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpOyAvLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZiA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYSA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07IiwiLy8gaGVscGVyIGZvciBTdHJpbmcje3N0YXJ0c1dpdGgsIGVuZHNXaXRoLCBpbmNsdWRlc31cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xuXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgc2VhcmNoU3RyaW5nLCBOQU1FKSB7XG4gIGlmIChpc1JlZ0V4cChzZWFyY2hTdHJpbmcpKSB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZyMnICsgTkFNRSArIFwiIGRvZXNuJ3QgYWNjZXB0IHJlZ2V4IVwiKTtcbiAgcmV0dXJuIFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbn07IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbnZhciBxdW90ID0gL1wiL2c7IC8vIEIuMi4zLjIuMSBDcmVhdGVIVE1MKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKVxuXG52YXIgY3JlYXRlSFRNTCA9IGZ1bmN0aW9uIChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSkge1xuICB2YXIgUyA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpO1xuICB2YXIgcDEgPSAnPCcgKyB0YWc7XG4gIGlmIChhdHRyaWJ1dGUgIT09ICcnKSBwMSArPSAnICcgKyBhdHRyaWJ1dGUgKyAnPVwiJyArIFN0cmluZyh2YWx1ZSkucmVwbGFjZShxdW90LCAnJnF1b3Q7JykgKyAnXCInO1xuICByZXR1cm4gcDEgKyAnPicgKyBTICsgJzwvJyArIHRhZyArICc+Jztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUsIGV4ZWMpIHtcbiAgdmFyIE8gPSB7fTtcbiAgT1tOQU1FXSA9IGV4ZWMoY3JlYXRlSFRNTCk7XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZXN0ID0gJydbTkFNRV0oJ1wiJyk7XG4gICAgcmV0dXJuIHRlc3QgIT09IHRlc3QudG9Mb3dlckNhc2UoKSB8fCB0ZXN0LnNwbGl0KCdcIicpLmxlbmd0aCA+IDM7XG4gIH0pLCAnU3RyaW5nJywgTyk7XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxudmFyIHJlcGVhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKTtcblxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIG1heExlbmd0aCwgZmlsbFN0cmluZywgbGVmdCkge1xuICB2YXIgUyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgdmFyIHN0cmluZ0xlbmd0aCA9IFMubGVuZ3RoO1xuICB2YXIgZmlsbFN0ciA9IGZpbGxTdHJpbmcgPT09IHVuZGVmaW5lZCA/ICcgJyA6IFN0cmluZyhmaWxsU3RyaW5nKTtcbiAgdmFyIGludE1heExlbmd0aCA9IHRvTGVuZ3RoKG1heExlbmd0aCk7XG4gIGlmIChpbnRNYXhMZW5ndGggPD0gc3RyaW5nTGVuZ3RoIHx8IGZpbGxTdHIgPT0gJycpIHJldHVybiBTO1xuICB2YXIgZmlsbExlbiA9IGludE1heExlbmd0aCAtIHN0cmluZ0xlbmd0aDtcbiAgdmFyIHN0cmluZ0ZpbGxlciA9IHJlcGVhdC5jYWxsKGZpbGxTdHIsIE1hdGguY2VpbChmaWxsTGVuIC8gZmlsbFN0ci5sZW5ndGgpKTtcbiAgaWYgKHN0cmluZ0ZpbGxlci5sZW5ndGggPiBmaWxsTGVuKSBzdHJpbmdGaWxsZXIgPSBzdHJpbmdGaWxsZXIuc2xpY2UoMCwgZmlsbExlbik7XG4gIHJldHVybiBsZWZ0ID8gc3RyaW5nRmlsbGVyICsgUyA6IFMgKyBzdHJpbmdGaWxsZXI7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcblxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwZWF0KGNvdW50KSB7XG4gIHZhciBzdHIgPSBTdHJpbmcoZGVmaW5lZCh0aGlzKSk7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIG4gPSB0b0ludGVnZXIoY291bnQpO1xuICBpZiAobiA8IDAgfHwgbiA9PSBJbmZpbml0eSkgdGhyb3cgUmFuZ2VFcnJvcihcIkNvdW50IGNhbid0IGJlIG5lZ2F0aXZlXCIpO1xuXG4gIGZvciAoOyBuID4gMDsgKG4gPj4+PSAxKSAmJiAoc3RyICs9IHN0cikpIGlmIChuICYgMSkgcmVzICs9IHN0cjtcblxuICByZXR1cm4gcmVzO1xufTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxudmFyIHNwYWNlcyA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpO1xuXG52YXIgc3BhY2UgPSAnWycgKyBzcGFjZXMgKyAnXSc7XG52YXIgbm9uID0gJ1xcdTIwMGJcXHUwMDg1JztcbnZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyBzcGFjZSArIHNwYWNlICsgJyonKTtcbnZhciBydHJpbSA9IFJlZ0V4cChzcGFjZSArIHNwYWNlICsgJyokJyk7XG5cbnZhciBleHBvcnRlciA9IGZ1bmN0aW9uIChLRVksIGV4ZWMsIEFMSUFTKSB7XG4gIHZhciBleHAgPSB7fTtcbiAgdmFyIEZPUkNFID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXNwYWNlc1tLRVldKCkgfHwgbm9uW0tFWV0oKSAhPSBub247XG4gIH0pO1xuICB2YXIgZm4gPSBleHBbS0VZXSA9IEZPUkNFID8gZXhlYyh0cmltKSA6IHNwYWNlc1tLRVldO1xuICBpZiAoQUxJQVMpIGV4cFtBTElBU10gPSBmbjtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRSwgJ1N0cmluZycsIGV4cCk7XG59OyAvLyAxIC0+IFN0cmluZyN0cmltTGVmdFxuLy8gMiAtPiBTdHJpbmcjdHJpbVJpZ2h0XG4vLyAzIC0+IFN0cmluZyN0cmltXG5cblxudmFyIHRyaW0gPSBleHBvcnRlci50cmltID0gZnVuY3Rpb24gKHN0cmluZywgVFlQRSkge1xuICBzdHJpbmcgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKTtcbiAgaWYgKFRZUEUgJiAxKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShsdHJpbSwgJycpO1xuICBpZiAoVFlQRSAmIDIpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVyOyIsIm1vZHVsZS5leHBvcnRzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyArICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJzsiLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG5cbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcblxudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG5cbnZhciBjZWwgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJyk7XG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBzZXRUYXNrID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhclRhc2sgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwuRGlzcGF0Y2g7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBkZWZlciwgY2hhbm5lbCwgcG9ydDtcblxudmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlkID0gK3RoaXM7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcblxuICBpZiAocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcblxudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTsgLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuXG5cbmlmICghc2V0VGFzayB8fCAhY2xlYXJUYXNrKSB7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpID0gMTtcblxuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcblxuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG5cbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9OyAvLyBOb2RlLmpzIDAuOC1cblxuXG4gIGlmIChyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2VzcycpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07IC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07IC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcblxuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7IC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAgIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG5cbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7IC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTsgLy8gUmVzdCBvbGQgYnJvd3NlcnNcblxuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59OyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTsiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2luZGV4XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICB2YXIgbnVtYmVyID0gdG9JbnRlZ2VyKGl0KTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKG51bWJlcik7XG4gIGlmIChudW1iZXIgIT09IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3JvbmcgbGVuZ3RoIScpO1xuICByZXR1cm4gbGVuZ3RoO1xufTsiLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59OyIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG5cbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59OyIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcblxudmFyIG1pbiA9IE1hdGgubWluO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTsiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59OyIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7IC8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpKSB7XG4gIHZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xuXG4gIHZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxuICB2YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG4gIHZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiAgdmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG5cbiAgdmFyICRidWZmZXIgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKTtcblxuICB2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG5cbiAgdmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xuXG4gIHZhciBwcm9wZXJ0eURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbiAgdmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5cbiAgdmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG5cbiAgdmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcblxuICB2YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxuICB2YXIgdG9JbmRleCA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG5cbiAgdmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5cbiAgdmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbiAgdmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuXG4gIHZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xuXG4gIHZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG4gIHZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG4gIHZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcblxuICB2YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xuXG4gIHZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxuICB2YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcblxuICB2YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcblxuICB2YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5cbiAgdmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG4gIHZhciBjcmVhdGVBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKTtcblxuICB2YXIgY3JlYXRlQXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJyk7XG5cbiAgdmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcblxuICB2YXIgQXJyYXlJdGVyYXRvcnMgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xuXG4gIHZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcblxuICB2YXIgJGl0ZXJEZXRlY3QgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpO1xuXG4gIHZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcblxuICB2YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpO1xuXG4gIHZhciBhcnJheUNvcHlXaXRoaW4gPSByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpO1xuXG4gIHZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxuICB2YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xuXG4gIHZhciBkUCA9ICREUC5mO1xuICB2YXIgZ09QRCA9ICRHT1BELmY7XG4gIHZhciBSYW5nZUVycm9yID0gZ2xvYmFsLlJhbmdlRXJyb3I7XG4gIHZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xuICB2YXIgVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5O1xuICB2YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcbiAgdmFyIFNIQVJFRF9CVUZGRVIgPSAnU2hhcmVkJyArIEFSUkFZX0JVRkZFUjtcbiAgdmFyIEJZVEVTX1BFUl9FTEVNRU5UID0gJ0JZVEVTX1BFUl9FTEVNRU5UJztcbiAgdmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuICB2YXIgQXJyYXlQcm90byA9IEFycmF5W1BST1RPVFlQRV07XG4gIHZhciAkQXJyYXlCdWZmZXIgPSAkYnVmZmVyLkFycmF5QnVmZmVyO1xuICB2YXIgJERhdGFWaWV3ID0gJGJ1ZmZlci5EYXRhVmlldztcbiAgdmFyIGFycmF5Rm9yRWFjaCA9IGNyZWF0ZUFycmF5TWV0aG9kKDApO1xuICB2YXIgYXJyYXlGaWx0ZXIgPSBjcmVhdGVBcnJheU1ldGhvZCgyKTtcbiAgdmFyIGFycmF5U29tZSA9IGNyZWF0ZUFycmF5TWV0aG9kKDMpO1xuICB2YXIgYXJyYXlFdmVyeSA9IGNyZWF0ZUFycmF5TWV0aG9kKDQpO1xuICB2YXIgYXJyYXlGaW5kID0gY3JlYXRlQXJyYXlNZXRob2QoNSk7XG4gIHZhciBhcnJheUZpbmRJbmRleCA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpO1xuICB2YXIgYXJyYXlJbmNsdWRlcyA9IGNyZWF0ZUFycmF5SW5jbHVkZXModHJ1ZSk7XG4gIHZhciBhcnJheUluZGV4T2YgPSBjcmVhdGVBcnJheUluY2x1ZGVzKGZhbHNlKTtcbiAgdmFyIGFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvcnMudmFsdWVzO1xuICB2YXIgYXJyYXlLZXlzID0gQXJyYXlJdGVyYXRvcnMua2V5cztcbiAgdmFyIGFycmF5RW50cmllcyA9IEFycmF5SXRlcmF0b3JzLmVudHJpZXM7XG4gIHZhciBhcnJheUxhc3RJbmRleE9mID0gQXJyYXlQcm90by5sYXN0SW5kZXhPZjtcbiAgdmFyIGFycmF5UmVkdWNlID0gQXJyYXlQcm90by5yZWR1Y2U7XG4gIHZhciBhcnJheVJlZHVjZVJpZ2h0ID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodDtcbiAgdmFyIGFycmF5Sm9pbiA9IEFycmF5UHJvdG8uam9pbjtcbiAgdmFyIGFycmF5U29ydCA9IEFycmF5UHJvdG8uc29ydDtcbiAgdmFyIGFycmF5U2xpY2UgPSBBcnJheVByb3RvLnNsaWNlO1xuICB2YXIgYXJyYXlUb1N0cmluZyA9IEFycmF5UHJvdG8udG9TdHJpbmc7XG4gIHZhciBhcnJheVRvTG9jYWxlU3RyaW5nID0gQXJyYXlQcm90by50b0xvY2FsZVN0cmluZztcbiAgdmFyIElURVJBVE9SID0gd2tzKCdpdGVyYXRvcicpO1xuICB2YXIgVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpO1xuICB2YXIgVFlQRURfQ09OU1RSVUNUT1IgPSB1aWQoJ3R5cGVkX2NvbnN0cnVjdG9yJyk7XG4gIHZhciBERUZfQ09OU1RSVUNUT1IgPSB1aWQoJ2RlZl9jb25zdHJ1Y3RvcicpO1xuICB2YXIgQUxMX0NPTlNUUlVDVE9SUyA9ICR0eXBlZC5DT05TVFI7XG4gIHZhciBUWVBFRF9BUlJBWSA9ICR0eXBlZC5UWVBFRDtcbiAgdmFyIFZJRVcgPSAkdHlwZWQuVklFVztcbiAgdmFyIFdST05HX0xFTkdUSCA9ICdXcm9uZyBsZW5ndGghJztcbiAgdmFyICRtYXAgPSBjcmVhdGVBcnJheU1ldGhvZCgxLCBmdW5jdGlvbiAoTywgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsbG9jYXRlKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsZW5ndGgpO1xuICB9KTtcbiAgdmFyIExJVFRMRV9FTkRJQU4gPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBVaW50MTZBcnJheShbMV0pLmJ1ZmZlcilbMF0gPT09IDE7XG4gIH0pO1xuICB2YXIgRk9SQ0VEX1NFVCA9ICEhVWludDhBcnJheSAmJiAhIVVpbnQ4QXJyYXlbUFJPVE9UWVBFXS5zZXQgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBVaW50OEFycmF5KDEpLnNldCh7fSk7XG4gIH0pO1xuXG4gIHZhciB0b09mZnNldCA9IGZ1bmN0aW9uIChpdCwgQllURVMpIHtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGl0KTtcbiAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgaWYgKGlzT2JqZWN0KGl0KSAmJiBUWVBFRF9BUlJBWSBpbiBpdCkgcmV0dXJuIGl0O1xuICAgIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgdHlwZWQgYXJyYXkhJyk7XG4gIH07XG5cbiAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24gKEMsIGxlbmd0aCkge1xuICAgIGlmICghKGlzT2JqZWN0KEMpICYmIFRZUEVEX0NPTlNUUlVDVE9SIGluIEMpKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0l0IGlzIG5vdCBhIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yIScpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQyhsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBzcGVjaWVzRnJvbUxpc3QgPSBmdW5jdGlvbiAoTywgbGlzdCkge1xuICAgIHJldHVybiBmcm9tTGlzdChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGlzdCk7XG4gIH07XG5cbiAgdmFyIGZyb21MaXN0ID0gZnVuY3Rpb24gKEMsIGxpc3QpIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gYWxsb2NhdGUoQywgbGVuZ3RoKTtcblxuICAgIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbiAoaXQsIGtleSwgaW50ZXJuYWwpIHtcbiAgICBkUChpdCwga2V5LCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RbaW50ZXJuYWxdO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciAkZnJvbSA9IGZ1bmN0aW9uIGZyb20oc291cmNlXG4gIC8qICwgbWFwZm4sIHRoaXNBcmcgKi9cbiAgKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdChzb3VyY2UpO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihPKTtcbiAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZXMsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG5cbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhaXNBcnJheUl0ZXIoaXRlckZuKSkge1xuICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCB2YWx1ZXMgPSBbXSwgaSA9IDA7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaSsrKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKHN0ZXAudmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBPID0gdmFsdWVzO1xuICAgIH1cblxuICAgIGlmIChtYXBwaW5nICYmIGFMZW4gPiAyKSBtYXBmbiA9IGN0eChtYXBmbiwgYXJndW1lbnRzWzJdLCAyKTtcblxuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKSwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTsgbGVuZ3RoID4gaTsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyICRvZiA9IGZ1bmN0aW9uIG9mKClcbiAgLyogLi4uaXRlbXMgKi9cbiAge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7XG5cbiAgICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9OyAvLyBpT1MgU2FmYXJpIDYueCBmYWlscyBoZXJlXG5cblxuICB2YXIgVE9fTE9DQUxFX0JVRyA9ICEhVWludDhBcnJheSAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgYXJyYXlUb0xvY2FsZVN0cmluZy5jYWxsKG5ldyBVaW50OEFycmF5KDEpKTtcbiAgfSk7XG5cbiAgdmFyICR0b0xvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIHRvTG9jYWxlU3RyaW5nKCkge1xuICAgIHJldHVybiBhcnJheVRvTG9jYWxlU3RyaW5nLmFwcGx5KFRPX0xPQ0FMRV9CVUcgPyBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcykpIDogdmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIHByb3RvID0ge1xuICAgIGNvcHlXaXRoaW46IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydFxuICAgIC8qICwgZW5kICovXG4gICAgKSB7XG4gICAgICByZXR1cm4gYXJyYXlDb3B5V2l0aGluLmNhbGwodmFsaWRhdGUodGhpcyksIHRhcmdldCwgc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuXG4gICAgLyogLCB0aGlzQXJnICovXG4gICAgKSB7XG4gICAgICByZXR1cm4gYXJyYXlFdmVyeSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmlsbDogZnVuY3Rpb24gZmlsbCh2YWx1ZVxuICAgIC8qICwgc3RhcnQsIGVuZCAqL1xuICAgICkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5RmlsbC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm5cbiAgICAvKiAsIHRoaXNBcmcgKi9cbiAgICApIHtcbiAgICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlGaWx0ZXIodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSk7XG4gICAgfSxcbiAgICBmaW5kOiBmdW5jdGlvbiBmaW5kKHByZWRpY2F0ZVxuICAgIC8qICwgdGhpc0FyZyAqL1xuICAgICkge1xuICAgICAgcmV0dXJuIGFycmF5RmluZCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChwcmVkaWNhdGVcbiAgICAvKiAsIHRoaXNBcmcgKi9cbiAgICApIHtcbiAgICAgIHJldHVybiBhcnJheUZpbmRJbmRleCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm5cbiAgICAvKiAsIHRoaXNBcmcgKi9cbiAgICApIHtcbiAgICAgIGFycmF5Rm9yRWFjaCh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50XG4gICAgLyogLCBmcm9tSW5kZXggKi9cbiAgICApIHtcbiAgICAgIHJldHVybiBhcnJheUluZGV4T2YodmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hFbGVtZW50XG4gICAgLyogLCBmcm9tSW5kZXggKi9cbiAgICApIHtcbiAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50XG4gICAgLyogLCBmcm9tSW5kZXggKi9cbiAgICApIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUxhc3RJbmRleE9mLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiBtYXAobWFwZm5cbiAgICAvKiAsIHRoaXNBcmcgKi9cbiAgICApIHtcbiAgICAgIHJldHVybiAkbWFwKHZhbGlkYXRlKHRoaXMpLCBtYXBmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmblxuICAgIC8qICwgaW5pdGlhbFZhbHVlICovXG4gICAgKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmblxuICAgIC8qICwgaW5pdGlhbFZhbHVlICovXG4gICAgKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2VSaWdodC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgbGVuZ3RoID0gdmFsaWRhdGUodGhhdCkubGVuZ3RoO1xuICAgICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IobGVuZ3RoIC8gMik7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBtaWRkbGUpIHtcbiAgICAgICAgdmFsdWUgPSB0aGF0W2luZGV4XTtcbiAgICAgICAgdGhhdFtpbmRleCsrXSA9IHRoYXRbLS1sZW5ndGhdO1xuICAgICAgICB0aGF0W2xlbmd0aF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfSxcbiAgICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm5cbiAgICAvKiAsIHRoaXNBcmcgKi9cbiAgICApIHtcbiAgICAgIHJldHVybiBhcnJheVNvbWUodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gICAgICByZXR1cm4gYXJyYXlTb3J0LmNhbGwodmFsaWRhdGUodGhpcyksIGNvbXBhcmVmbik7XG4gICAgfSxcbiAgICBzdWJhcnJheTogZnVuY3Rpb24gc3ViYXJyYXkoYmVnaW4sIGVuZCkge1xuICAgICAgdmFyIE8gPSB2YWxpZGF0ZSh0aGlzKTtcbiAgICAgIHZhciBsZW5ndGggPSBPLmxlbmd0aDtcbiAgICAgIHZhciAkYmVnaW4gPSB0b0Fic29sdXRlSW5kZXgoYmVnaW4sIGxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSkoTy5idWZmZXIsIE8uYnl0ZU9mZnNldCArICRiZWdpbiAqIE8uQllURVNfUEVSX0VMRU1FTlQsIHRvTGVuZ3RoKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCkpIC0gJGJlZ2luKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciAkc2xpY2UgPSBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcyksIHN0YXJ0LCBlbmQpKTtcbiAgfTtcblxuICB2YXIgJHNldCA9IGZ1bmN0aW9uIHNldChhcnJheUxpa2VcbiAgLyogLCBvZmZzZXQgKi9cbiAgKSB7XG4gICAgdmFsaWRhdGUodGhpcyk7XG4gICAgdmFyIG9mZnNldCA9IHRvT2Zmc2V0KGFyZ3VtZW50c1sxXSwgMSk7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIHZhciBzcmMgPSB0b09iamVjdChhcnJheUxpa2UpO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aChzcmMubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGlmIChsZW4gKyBvZmZzZXQgPiBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcblxuICAgIHdoaWxlIChpbmRleCA8IGxlbikgdGhpc1tvZmZzZXQgKyBpbmRleF0gPSBzcmNbaW5kZXgrK107XG4gIH07XG5cbiAgdmFyICRpdGVyYXRvcnMgPSB7XG4gICAgZW50cmllczogZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgIHJldHVybiBhcnJheUVudHJpZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgcmV0dXJuIGFycmF5S2V5cy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIGFycmF5VmFsdWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNUQUluZGV4ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHRhcmdldCkgJiYgdGFyZ2V0W1RZUEVEX0FSUkFZXSAmJiB0eXBlb2Yga2V5ICE9ICdzeW1ib2wnICYmIGtleSBpbiB0YXJnZXQgJiYgU3RyaW5nKCtrZXkpID09IFN0cmluZyhrZXkpO1xuICB9O1xuXG4gIHZhciAkZ2V0RGVzYyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkge1xuICAgIHJldHVybiBpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKSA/IHByb3BlcnR5RGVzYygyLCB0YXJnZXRba2V5XSkgOiBnT1BEKHRhcmdldCwga2V5KTtcbiAgfTtcblxuICB2YXIgJHNldERlc2MgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIGlmIChpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKSAmJiBpc09iamVjdChkZXNjKSAmJiBoYXMoZGVzYywgJ3ZhbHVlJykgJiYgIWhhcyhkZXNjLCAnZ2V0JykgJiYgIWhhcyhkZXNjLCAnc2V0JykgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAmJiAhZGVzYy5jb25maWd1cmFibGUgJiYgKCFoYXMoZGVzYywgJ3dyaXRhYmxlJykgfHwgZGVzYy53cml0YWJsZSkgJiYgKCFoYXMoZGVzYywgJ2VudW1lcmFibGUnKSB8fCBkZXNjLmVudW1lcmFibGUpKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IGRlc2MudmFsdWU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBkUCh0YXJnZXQsIGtleSwgZGVzYyk7XG4gIH07XG5cbiAgaWYgKCFBTExfQ09OU1RSVUNUT1JTKSB7XG4gICAgJEdPUEQuZiA9ICRnZXREZXNjO1xuICAgICREUC5mID0gJHNldERlc2M7XG4gIH1cblxuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFBTExfQ09OU1RSVUNUT1JTLCAnT2JqZWN0Jywge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldERlc2MsXG4gICAgZGVmaW5lUHJvcGVydHk6ICRzZXREZXNjXG4gIH0pO1xuXG4gIGlmIChmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgYXJyYXlUb1N0cmluZy5jYWxsKHt9KTtcbiAgfSkpIHtcbiAgICBhcnJheVRvU3RyaW5nID0gYXJyYXlUb0xvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRoaXMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgJFR5cGVkQXJyYXlQcm90b3R5cGUkID0gcmVkZWZpbmVBbGwoe30sIHByb3RvKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAkaXRlcmF0b3JzKTtcbiAgaGlkZSgkVHlwZWRBcnJheVByb3RvdHlwZSQsIElURVJBVE9SLCAkaXRlcmF0b3JzLnZhbHVlcyk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwge1xuICAgIHNsaWNlOiAkc2xpY2UsXG4gICAgc2V0OiAkc2V0LFxuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvKiBub29wICovXG4gICAgfSxcbiAgICB0b1N0cmluZzogYXJyYXlUb1N0cmluZyxcbiAgICB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nXG4gIH0pO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnVmZmVyJywgJ2InKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVPZmZzZXQnLCAnbycpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZUxlbmd0aCcsICdsJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdsZW5ndGgnLCAnZScpO1xuICBkUCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIFRBRywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXNbVFlQRURfQVJSQVldO1xuICAgIH1cbiAgfSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgQllURVMsIHdyYXBwZXIsIENMQU1QRUQpIHtcbiAgICBDTEFNUEVEID0gISFDTEFNUEVEO1xuICAgIHZhciBOQU1FID0gS0VZICsgKENMQU1QRUQgPyAnQ2xhbXBlZCcgOiAnJykgKyAnQXJyYXknO1xuICAgIHZhciBHRVRURVIgPSAnZ2V0JyArIEtFWTtcbiAgICB2YXIgU0VUVEVSID0gJ3NldCcgKyBLRVk7XG4gICAgdmFyIFR5cGVkQXJyYXkgPSBnbG9iYWxbTkFNRV07XG4gICAgdmFyIEJhc2UgPSBUeXBlZEFycmF5IHx8IHt9O1xuICAgIHZhciBUQUMgPSBUeXBlZEFycmF5ICYmIGdldFByb3RvdHlwZU9mKFR5cGVkQXJyYXkpO1xuICAgIHZhciBGT1JDRUQgPSAhVHlwZWRBcnJheSB8fCAhJHR5cGVkLkFCVjtcbiAgICB2YXIgTyA9IHt9O1xuICAgIHZhciBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheSAmJiBUeXBlZEFycmF5W1BST1RPVFlQRV07XG5cbiAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICByZXR1cm4gZGF0YS52W0dFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgTElUVExFX0VORElBTik7XG4gICAgfTtcblxuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICBpZiAoQ0xBTVBFRCkgdmFsdWUgPSAodmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKSkgPCAwID8gMCA6IHZhbHVlID4gMHhmZiA/IDB4ZmYgOiB2YWx1ZSAmIDB4ZmY7XG4gICAgICBkYXRhLnZbU0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCB2YWx1ZSwgTElUVExFX0VORElBTik7XG4gICAgfTtcblxuICAgIHZhciBhZGRFbGVtZW50ID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4KSB7XG4gICAgICBkUCh0aGF0LCBpbmRleCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0dGVyKHRoaXMsIGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gc2V0dGVyKHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoRk9SQ0VEKSB7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUsICdfZCcpO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGJ1ZmZlciwgYnl0ZUxlbmd0aCwgbGVuZ3RoLCBrbGFzcztcblxuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgbGVuZ3RoID0gdG9JbmRleChkYXRhKTtcbiAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XG4gICAgICAgICAgYnVmZmVyID0gbmV3ICRBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKSB7XG4gICAgICAgICAgYnVmZmVyID0gZGF0YTtcbiAgICAgICAgICBvZmZzZXQgPSB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUyk7XG4gICAgICAgICAgdmFyICRsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG5cbiAgICAgICAgICBpZiAoJGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoJGxlbiAlIEJZVEVTKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gJGxlbiAtIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoIDwgMCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdG9MZW5ndGgoJGxlbmd0aCkgKiBCWVRFUztcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoICsgb2Zmc2V0ID4gJGxlbikgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxlbmd0aCA9IGJ5dGVMZW5ndGggLyBCWVRFUztcbiAgICAgICAgfSBlbHNlIGlmIChUWVBFRF9BUlJBWSBpbiBkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGlkZSh0aGF0LCAnX2QnLCB7XG4gICAgICAgICAgYjogYnVmZmVyLFxuICAgICAgICAgIG86IG9mZnNldCxcbiAgICAgICAgICBsOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGU6IGxlbmd0aCxcbiAgICAgICAgICB2OiBuZXcgJERhdGFWaWV3KGJ1ZmZlcilcbiAgICAgICAgfSk7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSBhZGRFbGVtZW50KHRoYXQsIGluZGV4KyspO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gY3JlYXRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCk7XG4gICAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIFR5cGVkQXJyYXkpO1xuICAgIH0gZWxzZSBpZiAoIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIFR5cGVkQXJyYXkoMSk7XG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KC0xKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9KSB8fCAhJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG5cbiAgICAgIG5ldyBUeXBlZEFycmF5KG51bGwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuXG4gICAgICBuZXcgVHlwZWRBcnJheSgxLjUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuXG4gICAgICBuZXcgVHlwZWRBcnJheShpdGVyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9LCB0cnVlKSkge1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FKTtcbiAgICAgICAgdmFyIGtsYXNzOyAvLyBgd3NgIG1vZHVsZSBidWcsIHRlbXBvcmFyaWx5IHJlbW92ZSB2YWxpZGF0aW9uIGxlbmd0aCBmb3IgVWludDhBcnJheVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9wdWxsLzY0NVxuXG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHJldHVybiBuZXcgQmFzZSh0b0luZGV4KGRhdGEpKTtcblxuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUikge1xuICAgICAgICAgIHJldHVybiAkbGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUyksICRsZW5ndGgpIDogJG9mZnNldCAhPT0gdW5kZWZpbmVkID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpKSA6IG5ldyBCYXNlKGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFRZUEVEX0FSUkFZIGluIGRhdGEpIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIGFycmF5Rm9yRWFjaChUQUMgIT09IEZ1bmN0aW9uLnByb3RvdHlwZSA/IGdPUE4oQmFzZSkuY29uY2F0KGdPUE4oVEFDKSkgOiBnT1BOKEJhc2UpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBUeXBlZEFycmF5KSkgaGlkZShUeXBlZEFycmF5LCBrZXksIEJhc2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IFR5cGVkQXJyYXlQcm90b3R5cGU7XG4gICAgICBpZiAoIUxJQlJBUlkpIFR5cGVkQXJyYXlQcm90b3R5cGUuY29uc3RydWN0b3IgPSBUeXBlZEFycmF5O1xuICAgIH1cblxuICAgIHZhciAkbmF0aXZlSXRlcmF0b3IgPSBUeXBlZEFycmF5UHJvdG90eXBlW0lURVJBVE9SXTtcbiAgICB2YXIgQ09SUkVDVF9JVEVSX05BTUUgPSAhISRuYXRpdmVJdGVyYXRvciAmJiAoJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gJ3ZhbHVlcycgfHwgJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gdW5kZWZpbmVkKTtcbiAgICB2YXIgJGl0ZXJhdG9yID0gJGl0ZXJhdG9ycy52YWx1ZXM7XG4gICAgaGlkZShUeXBlZEFycmF5LCBUWVBFRF9DT05TVFJVQ1RPUiwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBUWVBFRF9BUlJBWSwgTkFNRSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIERFRl9DT05TVFJVQ1RPUiwgVHlwZWRBcnJheSk7XG5cbiAgICBpZiAoQ0xBTVBFRCA/IG5ldyBUeXBlZEFycmF5KDEpW1RBR10gIT0gTkFNRSA6ICEoVEFHIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKSB7XG4gICAgICBkUChUeXBlZEFycmF5UHJvdG90eXBlLCBUQUcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIE5BTUU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIE9bTkFNRV0gPSBUeXBlZEFycmF5O1xuICAgICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKFR5cGVkQXJyYXkgIT0gQmFzZSksIE8pO1xuICAgICRleHBvcnQoJGV4cG9ydC5TLCBOQU1FLCB7XG4gICAgICBCWVRFU19QRVJfRUxFTUVOVDogQllURVNcbiAgICB9KTtcbiAgICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIEJhc2Uub2YuY2FsbChUeXBlZEFycmF5LCAxKTtcbiAgICB9KSwgTkFNRSwge1xuICAgICAgZnJvbTogJGZyb20sXG4gICAgICBvZjogJG9mXG4gICAgfSk7XG4gICAgaWYgKCEoQllURVNfUEVSX0VMRU1FTlQgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgQllURVNfUEVSX0VMRU1FTlQsIEJZVEVTKTtcbiAgICAkZXhwb3J0KCRleHBvcnQuUCwgTkFNRSwgcHJvdG8pO1xuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRURfU0VULCBOQU1FLCB7XG4gICAgICBzZXQ6ICRzZXRcbiAgICB9KTtcbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFDT1JSRUNUX0lURVJfTkFNRSwgTkFNRSwgJGl0ZXJhdG9ycyk7XG4gICAgaWYgKCFMSUJSQVJZICYmIFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgIT0gYXJyYXlUb1N0cmluZykgVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyA9IGFycmF5VG9TdHJpbmc7XG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgxKS5zbGljZSgpO1xuICAgIH0pLCBOQU1FLCB7XG4gICAgICBzbGljZTogJHNsaWNlXG4gICAgfSk7XG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFsxLCAyXS50b0xvY2FsZVN0cmluZygpICE9IG5ldyBUeXBlZEFycmF5KFsxLCAyXSkudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZS50b0xvY2FsZVN0cmluZy5jYWxsKFsxLCAyXSk7XG4gICAgfSkpLCBOQU1FLCB7XG4gICAgICB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nXG4gICAgfSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQ09SUkVDVF9JVEVSX05BTUUgPyAkbmF0aXZlSXRlcmF0b3IgOiAkaXRlcmF0b3I7XG4gICAgaWYgKCFMSUJSQVJZICYmICFDT1JSRUNUX0lURVJfTkFNRSkgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBJVEVSQVRPUiwgJGl0ZXJhdG9yKTtcbiAgfTtcbn0gZWxzZSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgLyogZW1wdHkgKi9cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG5cbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xuXG52YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcblxudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5cbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xuXG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG5cbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG52YXIgdG9JbmRleCA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG5cbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xuXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xuXG52YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpO1xuXG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xuXG52YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcbnZhciBEQVRBX1ZJRVcgPSAnRGF0YVZpZXcnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFdST05HX0xFTkdUSCA9ICdXcm9uZyBsZW5ndGghJztcbnZhciBXUk9OR19JTkRFWCA9ICdXcm9uZyBpbmRleCEnO1xudmFyICRBcnJheUJ1ZmZlciA9IGdsb2JhbFtBUlJBWV9CVUZGRVJdO1xudmFyICREYXRhVmlldyA9IGdsb2JhbFtEQVRBX1ZJRVddO1xudmFyIE1hdGggPSBnbG9iYWwuTWF0aDtcbnZhciBSYW5nZUVycm9yID0gZ2xvYmFsLlJhbmdlRXJyb3I7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3ctcmVzdHJpY3RlZC1uYW1lc1xuXG52YXIgSW5maW5pdHkgPSBnbG9iYWwuSW5maW5pdHk7XG52YXIgQmFzZUJ1ZmZlciA9ICRBcnJheUJ1ZmZlcjtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG52YXIgQlVGRkVSID0gJ2J1ZmZlcic7XG52YXIgQllURV9MRU5HVEggPSAnYnl0ZUxlbmd0aCc7XG52YXIgQllURV9PRkZTRVQgPSAnYnl0ZU9mZnNldCc7XG52YXIgJEJVRkZFUiA9IERFU0NSSVBUT1JTID8gJ19iJyA6IEJVRkZFUjtcbnZhciAkTEVOR1RIID0gREVTQ1JJUFRPUlMgPyAnX2wnIDogQllURV9MRU5HVEg7XG52YXIgJE9GRlNFVCA9IERFU0NSSVBUT1JTID8gJ19vJyA6IEJZVEVfT0ZGU0VUOyAvLyBJRUVFNzU0IGNvbnZlcnNpb25zIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaWVlZTc1NFxuXG5mdW5jdGlvbiBwYWNrSUVFRTc1NCh2YWx1ZSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobkJ5dGVzKTtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBydCA9IG1MZW4gPT09IDIzID8gcG93KDIsIC0yNCkgLSBwb3coMiwgLTc3KSA6IDA7XG4gIHZhciBpID0gMDtcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwO1xuICB2YXIgZSwgbSwgYztcbiAgdmFsdWUgPSBhYnModmFsdWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG5cbiAgaWYgKHZhbHVlICE9IHZhbHVlIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBtID0gdmFsdWUgIT0gdmFsdWUgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gZmxvb3IobG9nKHZhbHVlKSAvIExOMik7XG5cbiAgICBpZiAodmFsdWUgKiAoYyA9IHBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIHBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbaSsrXSA9IG0gJiAyNTUsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSBlIDw8IG1MZW4gfCBtO1xuICBlTGVuICs9IG1MZW47XG5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbaSsrXSA9IGUgJiAyNTUsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlclstLWldIHw9IHMgKiAxMjg7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIHVucGFja0lFRUU3NTQoYnVmZmVyLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBuQml0cyA9IGVMZW4gLSA3O1xuICB2YXIgaSA9IG5CeXRlcyAtIDE7XG4gIHZhciBzID0gYnVmZmVyW2ktLV07XG4gIHZhciBlID0gcyAmIDEyNztcbiAgdmFyIG07XG4gIHMgPj49IDc7XG5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoMSA8PCAtbkJpdHMpIC0gMTtcbiAgZSA+Pj0gLW5CaXRzO1xuICBuQml0cyArPSBtTGVuO1xuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiBzID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBwb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuXG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogcG93KDIsIGUgLSBtTGVuKTtcbn1cblxuZnVuY3Rpb24gdW5wYWNrSTMyKGJ5dGVzKSB7XG4gIHJldHVybiBieXRlc1szXSA8PCAyNCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xufVxuXG5mdW5jdGlvbiBwYWNrSTgoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmZdO1xufVxuXG5mdW5jdGlvbiBwYWNrSTE2KGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZl07XG59XG5cbmZ1bmN0aW9uIHBhY2tJMzIoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmLCBpdCA+PiAxNiAmIDB4ZmYsIGl0ID4+IDI0ICYgMHhmZl07XG59XG5cbmZ1bmN0aW9uIHBhY2tGNjQoaXQpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCA1MiwgOCk7XG59XG5cbmZ1bmN0aW9uIHBhY2tGMzIoaXQpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCAyMywgNCk7XG59XG5cbmZ1bmN0aW9uIGFkZEdldHRlcihDLCBrZXksIGludGVybmFsKSB7XG4gIGRQKENbUFJPVE9UWVBFXSwga2V5LCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpc1tpbnRlcm5hbF07XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0KHZpZXcsIGJ5dGVzLCBpbmRleCwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4O1xuICB2YXIgaW50SW5kZXggPSB0b0luZGV4KG51bUluZGV4KTtcbiAgaWYgKGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYjtcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdO1xuICB2YXIgcGFjayA9IHN0b3JlLnNsaWNlKHN0YXJ0LCBzdGFydCArIGJ5dGVzKTtcbiAgcmV0dXJuIGlzTGl0dGxlRW5kaWFuID8gcGFjayA6IHBhY2sucmV2ZXJzZSgpO1xufVxuXG5mdW5jdGlvbiBzZXQodmlldywgYnl0ZXMsIGluZGV4LCBjb252ZXJzaW9uLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4O1xuICB2YXIgaW50SW5kZXggPSB0b0luZGV4KG51bUluZGV4KTtcbiAgaWYgKGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYjtcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdO1xuICB2YXIgcGFjayA9IGNvbnZlcnNpb24oK3ZhbHVlKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzOyBpKyspIHN0b3JlW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGJ5dGVzIC0gaSAtIDFdO1xufVxuXG5pZiAoISR0eXBlZC5BQlYpIHtcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0b0luZGV4KGxlbmd0aCk7XG4gICAgdGhpcy5fYiA9IGFycmF5RmlsbC5jYWxsKG5ldyBBcnJheShieXRlTGVuZ3RoKSwgMCk7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgJERhdGFWaWV3ID0gZnVuY3Rpb24gRGF0YVZpZXcoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkRGF0YVZpZXcsIERBVEFfVklFVyk7XG4gICAgYW5JbnN0YW5jZShidWZmZXIsICRBcnJheUJ1ZmZlciwgREFUQV9WSUVXKTtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYnVmZmVyWyRMRU5HVEhdO1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoYnl0ZU9mZnNldCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoKGJ5dGVMZW5ndGgpO1xuICAgIGlmIChvZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgdGhpc1skQlVGRkVSXSA9IGJ1ZmZlcjtcbiAgICB0aGlzWyRPRkZTRVRdID0gb2Zmc2V0O1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gIGlmIChERVNDUklQVE9SUykge1xuICAgIGFkZEdldHRlcigkQXJyYXlCdWZmZXIsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCVUZGRVIsICdfYicpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX09GRlNFVCwgJ19vJyk7XG4gIH1cblxuICByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIGdldEludDg6IGZ1bmN0aW9uIGdldEludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXSA8PCAyNCA+PiAyNDtcbiAgICB9LFxuICAgIGdldFVpbnQ4OiBmdW5jdGlvbiBnZXRVaW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MTY6IGZ1bmN0aW9uIGdldEludDE2KGJ5dGVPZmZzZXRcbiAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICkge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gKGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXSkgPDwgMTYgPj4gMTY7XG4gICAgfSxcbiAgICBnZXRVaW50MTY6IGZ1bmN0aW9uIGdldFVpbnQxNihieXRlT2Zmc2V0XG4gICAgLyogLCBsaXR0bGVFbmRpYW4gKi9cbiAgICApIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbiAgICB9LFxuICAgIGdldEludDMyOiBmdW5jdGlvbiBnZXRJbnQzMihieXRlT2Zmc2V0XG4gICAgLyogLCBsaXR0bGVFbmRpYW4gKi9cbiAgICApIHtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpO1xuICAgIH0sXG4gICAgZ2V0VWludDMyOiBmdW5jdGlvbiBnZXRVaW50MzIoYnl0ZU9mZnNldFxuICAgIC8qICwgbGl0dGxlRW5kaWFuICovXG4gICAgKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKSA+Pj4gMDtcbiAgICB9LFxuICAgIGdldEZsb2F0MzI6IGZ1bmN0aW9uIGdldEZsb2F0MzIoYnl0ZU9mZnNldFxuICAgIC8qICwgbGl0dGxlRW5kaWFuICovXG4gICAgKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgMjMsIDQpO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQ2NDogZnVuY3Rpb24gZ2V0RmxvYXQ2NChieXRlT2Zmc2V0XG4gICAgLyogLCBsaXR0bGVFbmRpYW4gKi9cbiAgICApIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCA1MiwgOCk7XG4gICAgfSxcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldEludDE2OiBmdW5jdGlvbiBzZXRJbnQxNihieXRlT2Zmc2V0LCB2YWx1ZVxuICAgIC8qICwgbGl0dGxlRW5kaWFuICovXG4gICAgKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MTY6IGZ1bmN0aW9uIHNldFVpbnQxNihieXRlT2Zmc2V0LCB2YWx1ZVxuICAgIC8qICwgbGl0dGxlRW5kaWFuICovXG4gICAgKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRJbnQzMjogZnVuY3Rpb24gc2V0SW50MzIoYnl0ZU9mZnNldCwgdmFsdWVcbiAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICkge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDMyOiBmdW5jdGlvbiBzZXRVaW50MzIoYnl0ZU9mZnNldCwgdmFsdWVcbiAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICkge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQzMjogZnVuY3Rpb24gc2V0RmxvYXQzMihieXRlT2Zmc2V0LCB2YWx1ZVxuICAgIC8qICwgbGl0dGxlRW5kaWFuICovXG4gICAgKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0YzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlXG4gICAgLyogLCBsaXR0bGVFbmRpYW4gKi9cbiAgICApIHtcbiAgICAgIHNldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBwYWNrRjY0LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgaWYgKCFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgJEFycmF5QnVmZmVyKDEpO1xuICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoLTEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICB9KSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3ICRBcnJheUJ1ZmZlcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuXG4gICAgbmV3ICRBcnJheUJ1ZmZlcigxLjUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuXG4gICAgbmV3ICRBcnJheUJ1ZmZlcihOYU4pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuXG4gICAgcmV0dXJuICRBcnJheUJ1ZmZlci5uYW1lICE9IEFSUkFZX0JVRkZFUjtcbiAgfSkpIHtcbiAgICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyKTtcbiAgICAgIHJldHVybiBuZXcgQmFzZUJ1ZmZlcih0b0luZGV4KGxlbmd0aCkpO1xuICAgIH07XG5cbiAgICB2YXIgQXJyYXlCdWZmZXJQcm90byA9ICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdID0gQmFzZUJ1ZmZlcltQUk9UT1RZUEVdO1xuXG4gICAgZm9yICh2YXIga2V5cyA9IGdPUE4oQmFzZUJ1ZmZlciksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajspIHtcbiAgICAgIGlmICghKChrZXkgPSBrZXlzW2orK10pIGluICRBcnJheUJ1ZmZlcikpIGhpZGUoJEFycmF5QnVmZmVyLCBrZXksIEJhc2VCdWZmZXJba2V5XSk7XG4gICAgfVxuXG4gICAgaWYgKCFMSUJSQVJZKSBBcnJheUJ1ZmZlclByb3RvLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICB9IC8vIGlPUyBTYWZhcmkgNy54IGJ1Z1xuXG5cbiAgdmFyIHZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpO1xuICB2YXIgJHNldEludDggPSAkRGF0YVZpZXdbUFJPVE9UWVBFXS5zZXRJbnQ4O1xuICB2aWV3LnNldEludDgoMCwgMjE0NzQ4MzY0OCk7XG4gIHZpZXcuc2V0SW50OCgxLCAyMTQ3NDgzNjQ5KTtcbiAgaWYgKHZpZXcuZ2V0SW50OCgwKSB8fCAhdmlldy5nZXRJbnQ4KDEpKSByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9XG4gIH0sIHRydWUpO1xufVxuXG5zZXRUb1N0cmluZ1RhZygkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG5zZXRUb1N0cmluZ1RhZygkRGF0YVZpZXcsIERBVEFfVklFVyk7XG5oaWRlKCREYXRhVmlld1tQUk9UT1RZUEVdLCAkdHlwZWQuVklFVywgdHJ1ZSk7XG5leHBvcnRzW0FSUkFZX0JVRkZFUl0gPSAkQXJyYXlCdWZmZXI7XG5leHBvcnRzW0RBVEFfVklFV10gPSAkRGF0YVZpZXc7IiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcblxudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xuXG52YXIgVFlQRUQgPSB1aWQoJ3R5cGVkX2FycmF5Jyk7XG52YXIgVklFVyA9IHVpZCgndmlldycpO1xudmFyIEFCViA9ICEhKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBnbG9iYWwuRGF0YVZpZXcpO1xudmFyIENPTlNUUiA9IEFCVjtcbnZhciBpID0gMDtcbnZhciBsID0gOTtcbnZhciBUeXBlZDtcbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzID0gJ0ludDhBcnJheSxVaW50OEFycmF5LFVpbnQ4Q2xhbXBlZEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5Jy5zcGxpdCgnLCcpO1xuXG53aGlsZSAoaSA8IGwpIHtcbiAgaWYgKFR5cGVkID0gZ2xvYmFsW1R5cGVkQXJyYXlDb25zdHJ1Y3RvcnNbaSsrXV0pIHtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVFlQRUQsIHRydWUpO1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBWSUVXLCB0cnVlKTtcbiAgfSBlbHNlIENPTlNUUiA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQUJWOiBBQlYsXG4gIENPTlNUUjogQ09OU1RSLFxuICBUWVBFRDogVFlQRUQsXG4gIFZJRVc6IFZJRVdcbn07IiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciBuYXZpZ2F0b3IgPSBnbG9iYWwubmF2aWdhdG9yO1xubW9kdWxlLmV4cG9ydHMgPSBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJzsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRZUEUpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgfHwgaXQuX3QgIT09IFRZUEUpIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQhJyk7XG4gIHJldHVybiBpdDtcbn07IiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcblxudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG5cbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHtcbiAgICB2YWx1ZTogd2tzRXh0LmYobmFtZSlcbiAgfSk7XG59OyIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpOyIsInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcblxudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xuXG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sO1xuXG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID0gVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7IiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG5cbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xuXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl0gfHwgaXRbJ0BAaXRlcmF0b3InXSB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vYmVuamFtaW5nci9SZXhFeHAuZXNjYXBlXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJHJlID0gcmVxdWlyZSgnLi9fcmVwbGFjZXInKSgvW1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWdFeHAnLCB7XG4gIGVzY2FwZTogZnVuY3Rpb24gZXNjYXBlKGl0KSB7XG4gICAgcmV0dXJuICRyZShpdCk7XG4gIH1cbn0pOyIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgY29weVdpdGhpbjogcmVxdWlyZSgnLi9fYXJyYXktY29weS13aXRoaW4nKVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdjb3B5V2l0aGluJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJGV2ZXJ5ID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDQpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZXZlcnksIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy41IC8gMTUuNC40LjE2IEFycmF5LnByb3RvdHlwZS5ldmVyeShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmblxuICAvKiAsIHRoaXNBcmcgKi9cbiAgKSB7XG4gICAgcmV0dXJuICRldmVyeSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGZpbGw6IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmaWxsJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJGZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgyKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZpbHRlciwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjcgLyAxNS40LjQuMjAgQXJyYXkucHJvdG90eXBlLmZpbHRlcihjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuXG4gIC8qICwgdGhpc0FyZyAqL1xuICApIHtcbiAgICByZXR1cm4gJGZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIDIyLjEuMy45IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJGZpbmQgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNik7XG5cbnZhciBLRVkgPSAnZmluZEluZGV4JztcbnZhciBmb3JjZWQgPSB0cnVlOyAvLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuXG5pZiAoS0VZIGluIFtdKSBBcnJheSgxKVtLRVldKGZ1bmN0aW9uICgpIHtcbiAgZm9yY2VkID0gZmFsc2U7XG59KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KGNhbGxiYWNrZm5cbiAgLyogLCB0aGF0ID0gdW5kZWZpbmVkICovXG4gICkge1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpOyIsIid1c2Ugc3RyaWN0JzsgLy8gMjIuMS4zLjggQXJyYXkucHJvdG90eXBlLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJGZpbmQgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNSk7XG5cbnZhciBLRVkgPSAnZmluZCc7XG52YXIgZm9yY2VkID0gdHJ1ZTsgLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcblxuaWYgKEtFWSBpbiBbXSkgQXJyYXkoMSlbS0VZXShmdW5jdGlvbiAoKSB7XG4gIGZvcmNlZCA9IGZhbHNlO1xufSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kOiBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrZm5cbiAgLyogLCB0aGF0ID0gdW5kZWZpbmVkICovXG4gICkge1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRmb3JFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xuXG52YXIgU1RSSUNUID0gcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZvckVhY2gsIHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFTVFJJQ1QsICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjEwIC8gMTUuNC40LjE4IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmblxuICAvKiAsIHRoaXNBcmcgKi9cbiAgKSB7XG4gICAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcblxudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7XG4gIEFycmF5LmZyb20oaXRlcik7XG59KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlXG4gIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi9cbiAgKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdChhcnJheUxpa2UpO1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIG1hcGZuID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihPKTtcbiAgICB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmIChtYXBwaW5nKSBtYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpOyAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcblxuICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcihpdGVyRm4pKSkge1xuICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQygpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG5cbiAgICAgIGZvciAocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRpbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG5cbnZhciAkbmF0aXZlID0gW10uaW5kZXhPZjtcbnZhciBORUdBVElWRV9aRVJPID0gISEkbmF0aXZlICYmIDEgLyBbMV0uaW5kZXhPZigxLCAtMCkgPCAwO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTEgLyAxNS40LjQuMTQgQXJyYXkucHJvdG90eXBlLmluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnRcbiAgLyogLCBmcm9tSW5kZXggPSAwICovXG4gICkge1xuICAgIHJldHVybiBORUdBVElWRV9aRVJPIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICA/ICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwIDogJGluZGV4T2YodGhpcywgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7IiwiLy8gMjIuMS4yLjIgLyAxNS40LjMuMiBBcnJheS5pc0FycmF5KGFyZylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnQXJyYXknLCB7XG4gIGlzQXJyYXk6IHJlcXVpcmUoJy4vX2lzLWFycmF5Jylcbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKTtcblxudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcblxudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xuXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpOyAvLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuXG4gIHRoaXMuX2kgPSAwOyAvLyBuZXh0IGluZGV4XG5cbiAgdGhpcy5fayA9IGtpbmQ7IC8vIGtpbmRcbiAgLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG5cbiAgaWYgKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKSB7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuXG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7IC8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcblxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpOyIsIid1c2Ugc3RyaWN0JzsgLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5qb2luKHNlcGFyYXRvcilcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxudmFyIGFycmF5Sm9pbiA9IFtdLmpvaW47IC8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBzdHJpbmdzXG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKHJlcXVpcmUoJy4vX2lvYmplY3QnKSAhPSBPYmplY3QgfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShhcnJheUpvaW4pKSwgJ0FycmF5Jywge1xuICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikge1xuICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0b0lPYmplY3QodGhpcyksIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gJywnIDogc2VwYXJhdG9yKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxudmFyICRuYXRpdmUgPSBbXS5sYXN0SW5kZXhPZjtcbnZhciBORUdBVElWRV9aRVJPID0gISEkbmF0aXZlICYmIDEgLyBbMV0ubGFzdEluZGV4T2YoMSwgLTApIDwgMDtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE0IC8gMTUuNC40LjE1IEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50XG4gIC8qICwgZnJvbUluZGV4ID0gQFsqLTFdICovXG4gICkge1xuICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICBpZiAoTkVHQVRJVkVfWkVSTykgcmV0dXJuICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwO1xuICAgIHZhciBPID0gdG9JT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIGluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHRvSW50ZWdlcihhcmd1bWVudHNbMV0pKTtcbiAgICBpZiAoaW5kZXggPCAwKSBpbmRleCA9IGxlbmd0aCArIGluZGV4O1xuXG4gICAgZm9yICg7IGluZGV4ID49IDA7IGluZGV4LS0pIGlmIChpbmRleCBpbiBPKSBpZiAoT1tpbmRleF0gPT09IHNlYXJjaEVsZW1lbnQpIHJldHVybiBpbmRleCB8fCAwO1xuXG4gICAgcmV0dXJuIC0xO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkbWFwID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDEpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ubWFwLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTUgLyAxNS40LjQuMTkgQXJyYXkucHJvdG90eXBlLm1hcChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBtYXA6IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuXG4gIC8qICwgdGhpc0FyZyAqL1xuICApIHtcbiAgICByZXR1cm4gJG1hcCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpOyAvLyBXZWJLaXQgQXJyYXkub2YgaXNuJ3QgZ2VuZXJpY1xuXG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfVxuXG4gIHJldHVybiAhKEFycmF5Lm9mLmNhbGwoRikgaW5zdGFuY2VvZiBGKTtcbn0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4zIEFycmF5Lm9mKCAuLi5pdGVtcylcbiAgb2Y6IGZ1bmN0aW9uIG9mKClcbiAgLyogLi4uYXJncyAqL1xuICB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyAodHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheSkoYUxlbik7XG5cbiAgICB3aGlsZSAoYUxlbiA+IGluZGV4KSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBhcmd1bWVudHNbaW5kZXgrK10pO1xuXG4gICAgcmVzdWx0Lmxlbmd0aCA9IGFMZW47XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlUmlnaHQsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOSAvIDE1LjQuNC4yMiBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmblxuICAvKiAsIGluaXRpYWxWYWx1ZSAqL1xuICApIHtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIHRydWUpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2UsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOCAvIDE1LjQuNC4yMSBBcnJheS5wcm90b3R5cGUucmVkdWNlKGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmblxuICAvKiAsIGluaXRpYWxWYWx1ZSAqL1xuICApIHtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIGZhbHNlKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vX2h0bWwnKTtcblxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuXG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbnZhciBhcnJheVNsaWNlID0gW10uc2xpY2U7IC8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5ncyBhbmQgRE9NIG9iamVjdHNcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgaWYgKGh0bWwpIGFycmF5U2xpY2UuY2FsbChodG1sKTtcbn0pLCAnQXJyYXknLCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKSB7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHRoaXMubGVuZ3RoKTtcbiAgICB2YXIga2xhc3MgPSBjb2YodGhpcyk7XG4gICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQ7XG4gICAgaWYgKGtsYXNzID09ICdBcnJheScpIHJldHVybiBhcnJheVNsaWNlLmNhbGwodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgdmFyIHN0YXJ0ID0gdG9BYnNvbHV0ZUluZGV4KGJlZ2luLCBsZW4pO1xuICAgIHZhciB1cFRvID0gdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKTtcbiAgICB2YXIgc2l6ZSA9IHRvTGVuZ3RoKHVwVG8gLSBzdGFydCk7XG4gICAgdmFyIGNsb25lZCA9IG5ldyBBcnJheShzaXplKTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IHNpemU7IGkrKykgY2xvbmVkW2ldID0ga2xhc3MgPT0gJ1N0cmluZycgPyB0aGlzLmNoYXJBdChzdGFydCArIGkpIDogdGhpc1tzdGFydCArIGldO1xuXG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJHNvbWUgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5zb21lLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjMgLyAxNS40LjQuMTcgQXJyYXkucHJvdG90eXBlLnNvbWUoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuXG4gIC8qICwgdGhpc0FyZyAqL1xuICApIHtcbiAgICByZXR1cm4gJHNvbWUodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxudmFyICRzb3J0ID0gW10uc29ydDtcbnZhciB0ZXN0ID0gWzEsIDIsIDNdO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBJRTgtXG4gIHRlc3Quc29ydCh1bmRlZmluZWQpO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggYnVnXG4gIHRlc3Quc29ydChudWxsKTsgLy8gT2xkIFdlYktpdFxufSkgfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkc29ydCkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4yNSBBcnJheS5wcm90b3R5cGUuc29ydChjb21wYXJlZm4pXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdW5kZWZpbmVkID8gJHNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSkgOiAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpLCBhRnVuY3Rpb24oY29tcGFyZWZuKSk7XG4gIH1cbn0pOyIsInJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ0FycmF5Jyk7IiwiLy8gMjAuMy4zLjEgLyAxNS45LjQuNCBEYXRlLm5vdygpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0RhdGUnLCB7XG4gIG5vdzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxufSk7IiwiLy8gMjAuMy40LjM2IC8gMTUuOS41LjQzIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciB0b0lTT1N0cmluZyA9IHJlcXVpcmUoJy4vX2RhdGUtdG8taXNvLXN0cmluZycpOyAvLyBQaGFudG9tSlMgLyBvbGQgV2ViS2l0IGhhcyBhIGJyb2tlbiBpbXBsZW1lbnRhdGlvbnNcblxuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyAhPT0gdG9JU09TdHJpbmcpLCAnRGF0ZScsIHtcbiAgdG9JU09TdHJpbmc6IHRvSVNPU3RyaW5nXG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKE5hTikudG9KU09OKCkgIT09IG51bGwgfHwgRGF0ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoe1xuICAgIHRvSVNPU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0pICE9PSAxO1xufSksICdEYXRlJywge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oa2V5KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgcHYgPSB0b1ByaW1pdGl2ZShPKTtcbiAgICByZXR1cm4gdHlwZW9mIHB2ID09ICdudW1iZXInICYmICFpc0Zpbml0ZShwdikgPyBudWxsIDogTy50b0lTT1N0cmluZygpO1xuICB9XG59KTsiLCJ2YXIgVE9fUFJJTUlUSVZFID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvUHJpbWl0aXZlJyk7XG5cbnZhciBwcm90byA9IERhdGUucHJvdG90eXBlO1xuaWYgKCEoVE9fUFJJTUlUSVZFIGluIHByb3RvKSkgcmVxdWlyZSgnLi9faGlkZScpKHByb3RvLCBUT19QUklNSVRJVkUsIHJlcXVpcmUoJy4vX2RhdGUtdG8tcHJpbWl0aXZlJykpOyIsInZhciBEYXRlUHJvdG8gPSBEYXRlLnByb3RvdHlwZTtcbnZhciBJTlZBTElEX0RBVEUgPSAnSW52YWxpZCBEYXRlJztcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyICR0b1N0cmluZyA9IERhdGVQcm90b1tUT19TVFJJTkddO1xudmFyIGdldFRpbWUgPSBEYXRlUHJvdG8uZ2V0VGltZTtcblxuaWYgKG5ldyBEYXRlKE5hTikgKyAnJyAhPSBJTlZBTElEX0RBVEUpIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShEYXRlUHJvdG8sIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0VGltZS5jYWxsKHRoaXMpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG5cbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gJHRvU3RyaW5nLmNhbGwodGhpcykgOiBJTlZBTElEX0RBVEU7XG4gIH0pO1xufSIsIi8vIDE5LjIuMy4yIC8gMTUuMy40LjUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQodGhpc0FyZywgYXJncy4uLilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnRnVuY3Rpb24nLCB7XG4gIGJpbmQ6IHJlcXVpcmUoJy4vX2JpbmQnKVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG52YXIgSEFTX0lOU1RBTkNFID0gcmVxdWlyZSgnLi9fd2tzJykoJ2hhc0luc3RhbmNlJyk7XG5cbnZhciBGdW5jdGlvblByb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlOyAvLyAxOS4yLjMuNiBGdW5jdGlvbi5wcm90b3R5cGVbQEBoYXNJbnN0YW5jZV0oVilcblxuaWYgKCEoSEFTX0lOU1RBTkNFIGluIEZ1bmN0aW9uUHJvdG8pKSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKEZ1bmN0aW9uUHJvdG8sIEhBU19JTlNUQU5DRSwge1xuICB2YWx1ZTogZnVuY3Rpb24gKE8pIHtcbiAgICBpZiAodHlwZW9mIHRoaXMgIT0gJ2Z1bmN0aW9uJyB8fCAhaXNPYmplY3QoTykpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWlzT2JqZWN0KHRoaXMucHJvdG90eXBlKSkgcmV0dXJuIE8gaW5zdGFuY2VvZiB0aGlzOyAvLyBmb3IgZW52aXJvbm1lbnQgdy9vIG5hdGl2ZSBgQEBoYXNJbnN0YW5jZWAgbG9naWMgZW5vdWdoIGBpbnN0YW5jZW9mYCwgYnV0IGFkZCB0aGlzOlxuXG4gICAgd2hpbGUgKE8gPSBnZXRQcm90b3R5cGVPZihPKSkgaWYgKHRoaXMucHJvdG90eXBlID09PSBPKSByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSk7IiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcblxudmFyIEZQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBuYW1lUkUgPSAvXlxccypmdW5jdGlvbiAoW14gKF0qKS87XG52YXIgTkFNRSA9ICduYW1lJzsgLy8gMTkuMi40LjIgbmFtZVxuXG5OQU1FIGluIEZQcm90byB8fCByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIGRQKEZQcm90bywgTkFNRSwge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKCcnICsgdGhpcykubWF0Y2gobmFtZVJFKVsxXTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG5cbnZhciBNQVAgPSAnTWFwJzsgLy8gMjMuMSBNYXAgT2JqZWN0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShNQVAsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn0sIHtcbiAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBzdHJvbmcuZ2V0RW50cnkodmFsaWRhdGUodGhpcywgTUFQKSwga2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudjtcbiAgfSxcbiAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTsiLCIvLyAyMC4yLjIuMyBNYXRoLmFjb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgbG9nMXAgPSByZXF1aXJlKCcuL19tYXRoLWxvZzFwJyk7XG5cbnZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xudmFyICRhY29zaCA9IE1hdGguYWNvc2g7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFjb3NoIC8vIFY4IGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM1MDlcbiYmIE1hdGguZmxvb3IoJGFjb3NoKE51bWJlci5NQVhfVkFMVUUpKSA9PSA3MTAgLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFjb3NoKEluZmluaXR5KSAtPiBOYU5cbiYmICRhY29zaChJbmZpbml0eSkgPT0gSW5maW5pdHkpLCAnTWF0aCcsIHtcbiAgYWNvc2g6IGZ1bmN0aW9uIGFjb3NoKHgpIHtcbiAgICByZXR1cm4gKHggPSAreCkgPCAxID8gTmFOIDogeCA+IDk0OTA2MjY1LjYyNDI1MTU2ID8gTWF0aC5sb2coeCkgKyBNYXRoLkxOMiA6IGxvZzFwKHggLSAxICsgc3FydCh4IC0gMSkgKiBzcXJ0KHggKyAxKSk7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi41IE1hdGguYXNpbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkYXNpbmggPSBNYXRoLmFzaW5oO1xuXG5mdW5jdGlvbiBhc2luaCh4KSB7XG4gIHJldHVybiAhaXNGaW5pdGUoeCA9ICt4KSB8fCB4ID09IDAgPyB4IDogeCA8IDAgPyAtYXNpbmgoLXgpIDogTWF0aC5sb2coeCArIE1hdGguc3FydCh4ICogeCArIDEpKTtcbn0gLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFzaW5oKDApIC0+IC0wXG5cblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhc2luaCAmJiAxIC8gJGFzaW5oKDApID4gMCksICdNYXRoJywge1xuICBhc2luaDogYXNpbmhcbn0pOyIsIi8vIDIwLjIuMi43IE1hdGguYXRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkYXRhbmggPSBNYXRoLmF0YW5oOyAvLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXRhbmgoLTApIC0+IDBcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhdGFuaCAmJiAxIC8gJGF0YW5oKC0wKSA8IDApLCAnTWF0aCcsIHtcbiAgYXRhbmg6IGZ1bmN0aW9uIGF0YW5oKHgpIHtcbiAgICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiBNYXRoLmxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuOSBNYXRoLmNicnQoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBzaWduID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2JydDogZnVuY3Rpb24gY2JydCh4KSB7XG4gICAgcmV0dXJuIHNpZ24oeCA9ICt4KSAqIE1hdGgucG93KE1hdGguYWJzKHgpLCAxIC8gMyk7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4xMSBNYXRoLmNsejMyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNsejMyOiBmdW5jdGlvbiBjbHozMih4KSB7XG4gICAgcmV0dXJuICh4ID4+Pj0gMCkgPyAzMSAtIE1hdGguZmxvb3IoTWF0aC5sb2coeCArIDAuNSkgKiBNYXRoLkxPRzJFKSA6IDMyO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMTIgTWF0aC5jb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgZXhwID0gTWF0aC5leHA7XG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNvc2g6IGZ1bmN0aW9uIGNvc2goeCkge1xuICAgIHJldHVybiAoZXhwKHggPSAreCkgKyBleHAoLXgpKSAvIDI7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJGV4cG0xID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICgkZXhwbTEgIT0gTWF0aC5leHBtMSksICdNYXRoJywge1xuICBleHBtMTogJGV4cG0xXG59KTsiLCIvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgZnJvdW5kOiByZXF1aXJlKCcuL19tYXRoLWZyb3VuZCcpXG59KTsiLCIvLyAyMC4yLjIuMTcgTWF0aC5oeXBvdChbdmFsdWUxWywgdmFsdWUyWywg4oCmIF1dXSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBhYnMgPSBNYXRoLmFicztcbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaHlwb3Q6IGZ1bmN0aW9uIGh5cG90KHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGxhcmcgPSAwO1xuICAgIHZhciBhcmcsIGRpdjtcblxuICAgIHdoaWxlIChpIDwgYUxlbikge1xuICAgICAgYXJnID0gYWJzKGFyZ3VtZW50c1tpKytdKTtcblxuICAgICAgaWYgKGxhcmcgPCBhcmcpIHtcbiAgICAgICAgZGl2ID0gbGFyZyAvIGFyZztcbiAgICAgICAgc3VtID0gc3VtICogZGl2ICogZGl2ICsgMTtcbiAgICAgICAgbGFyZyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZiAoYXJnID4gMCkge1xuICAgICAgICBkaXYgPSBhcmcgLyBsYXJnO1xuICAgICAgICBzdW0gKz0gZGl2ICogZGl2O1xuICAgICAgfSBlbHNlIHN1bSArPSBhcmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhcmcgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiBsYXJnICogTWF0aC5zcXJ0KHN1bSk7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4xOCBNYXRoLmltdWwoeCwgeSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkaW11bCA9IE1hdGguaW11bDsgLy8gc29tZSBXZWJLaXQgdmVyc2lvbnMgZmFpbHMgd2l0aCBiaWcgbnVtYmVycywgc29tZSBoYXMgd3JvbmcgYXJpdHlcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICRpbXVsKDB4ZmZmZmZmZmYsIDUpICE9IC01IHx8ICRpbXVsLmxlbmd0aCAhPSAyO1xufSksICdNYXRoJywge1xuICBpbXVsOiBmdW5jdGlvbiBpbXVsKHgsIHkpIHtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmO1xuICAgIHZhciB4biA9ICt4O1xuICAgIHZhciB5biA9ICt5O1xuICAgIHZhciB4bCA9IFVJTlQxNiAmIHhuO1xuICAgIHZhciB5bCA9IFVJTlQxNiAmIHluO1xuICAgIHJldHVybiAwIHwgeGwgKiB5bCArICgoVUlOVDE2ICYgeG4gPj4+IDE2KSAqIHlsICsgeGwgKiAoVUlOVDE2ICYgeW4gPj4+IDE2KSA8PCAxNiA+Pj4gMCk7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4yMSBNYXRoLmxvZzEwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzEwOiBmdW5jdGlvbiBsb2cxMCh4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpICogTWF0aC5MT0cxMEU7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzFwOiByZXF1aXJlKCcuL19tYXRoLWxvZzFwJylcbn0pOyIsIi8vIDIwLjIuMi4yMiBNYXRoLmxvZzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMjogZnVuY3Rpb24gbG9nMih4KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjI7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgc2lnbjogcmVxdWlyZSgnLi9fbWF0aC1zaWduJylcbn0pOyIsIi8vIDIwLjIuMi4zMCBNYXRoLnNpbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBleHBtMSA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcblxudmFyIGV4cCA9IE1hdGguZXhwOyAvLyBWOCBuZWFyIENocm9taXVtIDM4IGhhcyBhIHByb2JsZW0gd2l0aCB2ZXJ5IHNtYWxsIG51bWJlcnNcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFNYXRoLnNpbmgoLTJlLTE3KSAhPSAtMmUtMTc7XG59KSwgJ01hdGgnLCB7XG4gIHNpbmg6IGZ1bmN0aW9uIHNpbmgoeCkge1xuICAgIHJldHVybiBNYXRoLmFicyh4ID0gK3gpIDwgMSA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyIDogKGV4cCh4IC0gMSkgLSBleHAoLXggLSAxKSkgKiAoTWF0aC5FIC8gMik7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4zMyBNYXRoLnRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBleHBtMSA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcblxudmFyIGV4cCA9IE1hdGguZXhwO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0YW5oOiBmdW5jdGlvbiB0YW5oKHgpIHtcbiAgICB2YXIgYSA9IGV4cG0xKHggPSAreCk7XG4gICAgdmFyIGIgPSBleHBtMSgteCk7XG4gICAgcmV0dXJuIGEgPT0gSW5maW5pdHkgPyAxIDogYiA9PSBJbmZpbml0eSA/IC0xIDogKGEgLSBiKSAvIChleHAoeCkgKyBleHAoLXgpKTtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjM0IE1hdGgudHJ1bmMoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdHJ1bmM6IGZ1bmN0aW9uIHRydW5jKGl0KSB7XG4gICAgcmV0dXJuIChpdCA+IDAgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsKShpdCk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG5cbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcblxudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG5cbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xuXG52YXIgJHRyaW0gPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG5cbnZhciBOVU1CRVIgPSAnTnVtYmVyJztcbnZhciAkTnVtYmVyID0gZ2xvYmFsW05VTUJFUl07XG52YXIgQmFzZSA9ICROdW1iZXI7XG52YXIgcHJvdG8gPSAkTnVtYmVyLnByb3RvdHlwZTsgLy8gT3BlcmEgfjEyIGhhcyBicm9rZW4gT2JqZWN0I3RvU3RyaW5nXG5cbnZhciBCUk9LRU5fQ09GID0gY29mKHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKShwcm90bykpID09IE5VTUJFUjtcbnZhciBUUklNID0gKCd0cmltJyBpbiBTdHJpbmcucHJvdG90eXBlKTsgLy8gNy4xLjMgVG9OdW1iZXIoYXJndW1lbnQpXG5cbnZhciB0b051bWJlciA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgaXQgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgZmFsc2UpO1xuXG4gIGlmICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMikge1xuICAgIGl0ID0gVFJJTSA/IGl0LnRyaW0oKSA6ICR0cmltKGl0LCAzKTtcbiAgICB2YXIgZmlyc3QgPSBpdC5jaGFyQ29kZUF0KDApO1xuICAgIHZhciB0aGlyZCwgcmFkaXgsIG1heENvZGU7XG5cbiAgICBpZiAoZmlyc3QgPT09IDQzIHx8IGZpcnN0ID09PSA0NSkge1xuICAgICAgdGhpcmQgPSBpdC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYgKHRoaXJkID09PSA4OCB8fCB0aGlyZCA9PT0gMTIwKSByZXR1cm4gTmFOOyAvLyBOdW1iZXIoJysweDEnKSBzaG91bGQgYmUgTmFOLCBvbGQgVjggZml4XG4gICAgfSBlbHNlIGlmIChmaXJzdCA9PT0gNDgpIHtcbiAgICAgIHN3aXRjaCAoaXQuY2hhckNvZGVBdCgxKSkge1xuICAgICAgICBjYXNlIDY2OlxuICAgICAgICBjYXNlIDk4OlxuICAgICAgICAgIHJhZGl4ID0gMjtcbiAgICAgICAgICBtYXhDb2RlID0gNDk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGZhc3QgZXF1YWwgL14wYlswMV0rJC9pXG5cbiAgICAgICAgY2FzZSA3OTpcbiAgICAgICAgY2FzZSAxMTE6XG4gICAgICAgICAgcmFkaXggPSA4O1xuICAgICAgICAgIG1heENvZGUgPSA1NTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gZmFzdCBlcXVhbCAvXjBvWzAtN10rJC9pXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gK2l0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBkaWdpdHMgPSBpdC5zbGljZSgyKSwgaSA9IDAsIGwgPSBkaWdpdHMubGVuZ3RoLCBjb2RlOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBkaWdpdHMuY2hhckNvZGVBdChpKTsgLy8gcGFyc2VJbnQgcGFyc2VzIGEgc3RyaW5nIHRvIGEgZmlyc3QgdW5hdmFpbGFibGUgc3ltYm9sXG4gICAgICAgIC8vIGJ1dCBUb051bWJlciBzaG91bGQgcmV0dXJuIE5hTiBpZiBhIHN0cmluZyBjb250YWlucyB1bmF2YWlsYWJsZSBzeW1ib2xzXG5cbiAgICAgICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gbWF4Q29kZSkgcmV0dXJuIE5hTjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlSW50KGRpZ2l0cywgcmFkaXgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAraXQ7XG59O1xuXG5pZiAoISROdW1iZXIoJyAwbzEnKSB8fCAhJE51bWJlcignMGIxJykgfHwgJE51bWJlcignKzB4MScpKSB7XG4gICROdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpIHtcbiAgICB2YXIgaXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMSA/IDAgOiB2YWx1ZTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIHRoYXQgaW5zdGFuY2VvZiAkTnVtYmVyIC8vIGNoZWNrIG9uIDEuLmNvbnN0cnVjdG9yKGZvbykgY2FzZVxuICAgICYmIChCUk9LRU5fQ09GID8gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgcHJvdG8udmFsdWVPZi5jYWxsKHRoYXQpO1xuICAgIH0pIDogY29mKHRoYXQpICE9IE5VTUJFUikgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSh0b051bWJlcihpdCkpLCB0aGF0LCAkTnVtYmVyKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcblxuICBmb3IgKHZhciBrZXlzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUE4oQmFzZSkgOiAoIC8vIEVTMzpcbiAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgKyAvLyBFUzYgKGluIGNhc2UsIGlmIG1vZHVsZXMgd2l0aCBFUzYgTnVtYmVyIHN0YXRpY3MgcmVxdWlyZWQgYmVmb3JlKTpcbiAgJ0VQU0lMT04saXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIsTUFYX1NBRkVfSU5URUdFUiwnICsgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXInKS5zcGxpdCgnLCcpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7IGorKykge1xuICAgIGlmIChoYXMoQmFzZSwga2V5ID0ga2V5c1tqXSkgJiYgIWhhcygkTnVtYmVyLCBrZXkpKSB7XG4gICAgICBkUCgkTnVtYmVyLCBrZXksIGdPUEQoQmFzZSwga2V5KSk7XG4gICAgfVxuICB9XG5cbiAgJE51bWJlci5wcm90b3R5cGUgPSBwcm90bztcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkTnVtYmVyO1xuXG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCBOVU1CRVIsICROdW1iZXIpO1xufSIsIi8vIDIwLjEuMi4xIE51bWJlci5FUFNJTE9OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgRVBTSUxPTjogTWF0aC5wb3coMiwgLTUyKVxufSk7IiwiLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBfaXNGaW5pdGUgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5pc0Zpbml0ZTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzRmluaXRlOiBmdW5jdGlvbiBpc0Zpbml0ZShpdCkge1xuICAgIHJldHVybiB0eXBlb2YgaXQgPT0gJ251bWJlcicgJiYgX2lzRmluaXRlKGl0KTtcbiAgfVxufSk7IiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNJbnRlZ2VyOiByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJylcbn0pOyIsIi8vIDIwLjEuMi40IE51bWJlci5pc05hTihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNOYU46IGZ1bmN0aW9uIGlzTmFOKG51bWJlcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByZXR1cm4gbnVtYmVyICE9IG51bWJlcjtcbiAgfVxufSk7IiwiLy8gMjAuMS4yLjUgTnVtYmVyLmlzU2FmZUludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKTtcblxudmFyIGFicyA9IE1hdGguYWJzO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzU2FmZUludGVnZXI6IGZ1bmN0aW9uIGlzU2FmZUludGVnZXIobnVtYmVyKSB7XG4gICAgcmV0dXJuIGlzSW50ZWdlcihudW1iZXIpICYmIGFicyhudW1iZXIpIDw9IDB4MWZmZmZmZmZmZmZmZmY7XG4gIH1cbn0pOyIsIi8vIDIwLjEuMi42IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgTUFYX1NBRkVfSU5URUdFUjogMHgxZmZmZmZmZmZmZmZmZlxufSk7IiwiLy8gMjAuMS4yLjEwIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgTUlOX1NBRkVfSU5URUdFUjogLTB4MWZmZmZmZmZmZmZmZmZcbn0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7IC8vIDIwLjEuMi4xMiBOdW1iZXIucGFyc2VGbG9hdChzdHJpbmcpXG5cblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCAnTnVtYmVyJywge1xuICBwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdFxufSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX3BhcnNlLWludCcpOyAvLyAyMC4xLjIuMTMgTnVtYmVyLnBhcnNlSW50KHN0cmluZywgcmFkaXgpXG5cblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlSW50ICE9ICRwYXJzZUludCksICdOdW1iZXInLCB7XG4gIHBhcnNlSW50OiAkcGFyc2VJbnRcbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcblxudmFyIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJyk7XG5cbnZhciByZXBlYXQgPSByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jyk7XG5cbnZhciAkdG9GaXhlZCA9IDEuMC50b0ZpeGVkO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBkYXRhID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xudmFyIEVSUk9SID0gJ051bWJlci50b0ZpeGVkOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnO1xudmFyIFpFUk8gPSAnMCc7XG5cbnZhciBtdWx0aXBseSA9IGZ1bmN0aW9uIChuLCBjKSB7XG4gIHZhciBpID0gLTE7XG4gIHZhciBjMiA9IGM7XG5cbiAgd2hpbGUgKCsraSA8IDYpIHtcbiAgICBjMiArPSBuICogZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gYzIgJSAxZTc7XG4gICAgYzIgPSBmbG9vcihjMiAvIDFlNyk7XG4gIH1cbn07XG5cbnZhciBkaXZpZGUgPSBmdW5jdGlvbiAobikge1xuICB2YXIgaSA9IDY7XG4gIHZhciBjID0gMDtcblxuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBjICs9IGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGZsb29yKGMgLyBuKTtcbiAgICBjID0gYyAlIG4gKiAxZTc7XG4gIH1cbn07XG5cbnZhciBudW1Ub1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGkgPSA2O1xuICB2YXIgcyA9ICcnO1xuXG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIGlmIChzICE9PSAnJyB8fCBpID09PSAwIHx8IGRhdGFbaV0gIT09IDApIHtcbiAgICAgIHZhciB0ID0gU3RyaW5nKGRhdGFbaV0pO1xuICAgICAgcyA9IHMgPT09ICcnID8gdCA6IHMgKyByZXBlYXQuY2FsbChaRVJPLCA3IC0gdC5sZW5ndGgpICsgdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcztcbn07XG5cbnZhciBwb3cgPSBmdW5jdGlvbiAoeCwgbiwgYWNjKSB7XG4gIHJldHVybiBuID09PSAwID8gYWNjIDogbiAlIDIgPT09IDEgPyBwb3coeCwgbiAtIDEsIGFjYyAqIHgpIDogcG93KHggKiB4LCBuIC8gMiwgYWNjKTtcbn07XG5cbnZhciBsb2cgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbiA9IDA7XG4gIHZhciB4MiA9IHg7XG5cbiAgd2hpbGUgKHgyID49IDQwOTYpIHtcbiAgICBuICs9IDEyO1xuICAgIHgyIC89IDQwOTY7XG4gIH1cblxuICB3aGlsZSAoeDIgPj0gMikge1xuICAgIG4gKz0gMTtcbiAgICB4MiAvPSAyO1xuICB9XG5cbiAgcmV0dXJuIG47XG59O1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICghISR0b0ZpeGVkICYmICgwLjAwMDA4LnRvRml4ZWQoMykgIT09ICcwLjAwMCcgfHwgMC45LnRvRml4ZWQoMCkgIT09ICcxJyB8fCAxLjI1NS50b0ZpeGVkKDIpICE9PSAnMS4yNScgfHwgMTAwMDAwMDAwMDAwMDAwMDEyOC4wLnRvRml4ZWQoMCkgIT09ICcxMDAwMDAwMDAwMDAwMDAwMTI4JykgfHwgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9GaXhlZC5jYWxsKHt9KTtcbn0pKSwgJ051bWJlcicsIHtcbiAgdG9GaXhlZDogZnVuY3Rpb24gdG9GaXhlZChmcmFjdGlvbkRpZ2l0cykge1xuICAgIHZhciB4ID0gYU51bWJlclZhbHVlKHRoaXMsIEVSUk9SKTtcbiAgICB2YXIgZiA9IHRvSW50ZWdlcihmcmFjdGlvbkRpZ2l0cyk7XG4gICAgdmFyIHMgPSAnJztcbiAgICB2YXIgbSA9IFpFUk87XG4gICAgdmFyIGUsIHosIGosIGs7XG4gICAgaWYgKGYgPCAwIHx8IGYgPiAyMCkgdGhyb3cgUmFuZ2VFcnJvcihFUlJPUik7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcblxuICAgIGlmICh4ICE9IHgpIHJldHVybiAnTmFOJztcbiAgICBpZiAoeCA8PSAtMWUyMSB8fCB4ID49IDFlMjEpIHJldHVybiBTdHJpbmcoeCk7XG5cbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIHMgPSAnLSc7XG4gICAgICB4ID0gLXg7XG4gICAgfVxuXG4gICAgaWYgKHggPiAxZS0yMSkge1xuICAgICAgZSA9IGxvZyh4ICogcG93KDIsIDY5LCAxKSkgLSA2OTtcbiAgICAgIHogPSBlIDwgMCA/IHggKiBwb3coMiwgLWUsIDEpIDogeCAvIHBvdygyLCBlLCAxKTtcbiAgICAgIHogKj0gMHgxMDAwMDAwMDAwMDAwMDtcbiAgICAgIGUgPSA1MiAtIGU7XG5cbiAgICAgIGlmIChlID4gMCkge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgaiA9IGY7XG5cbiAgICAgICAgd2hpbGUgKGogPj0gNykge1xuICAgICAgICAgIG11bHRpcGx5KDFlNywgMCk7XG4gICAgICAgICAgaiAtPSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgbXVsdGlwbHkocG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgIGogPSBlIC0gMTtcblxuICAgICAgICB3aGlsZSAoaiA+PSAyMykge1xuICAgICAgICAgIGRpdmlkZSgxIDw8IDIzKTtcbiAgICAgICAgICBqIC09IDIzO1xuICAgICAgICB9XG5cbiAgICAgICAgZGl2aWRlKDEgPDwgaik7XG4gICAgICAgIG11bHRpcGx5KDEsIDEpO1xuICAgICAgICBkaXZpZGUoMik7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIG11bHRpcGx5KDEgPDwgLWUsIDApO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKSArIHJlcGVhdC5jYWxsKFpFUk8sIGYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmID4gMCkge1xuICAgICAgayA9IG0ubGVuZ3RoO1xuICAgICAgbSA9IHMgKyAoayA8PSBmID8gJzAuJyArIHJlcGVhdC5jYWxsKFpFUk8sIGYgLSBrKSArIG0gOiBtLnNsaWNlKDAsIGsgLSBmKSArICcuJyArIG0uc2xpY2UoayAtIGYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHMgKyBtO1xuICAgIH1cblxuICAgIHJldHVybiBtO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG52YXIgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKTtcblxudmFyICR0b1ByZWNpc2lvbiA9IDEuMC50b1ByZWNpc2lvbjtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKCRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIElFNy1cbiAgcmV0dXJuICR0b1ByZWNpc2lvbi5jYWxsKDEsIHVuZGVmaW5lZCkgIT09ICcxJztcbn0pIHx8ICEkZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9QcmVjaXNpb24uY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvUHJlY2lzaW9uOiBmdW5jdGlvbiB0b1ByZWNpc2lvbihwcmVjaXNpb24pIHtcbiAgICB2YXIgdGhhdCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCAnTnVtYmVyI3RvUHJlY2lzaW9uOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgICByZXR1cm4gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyAkdG9QcmVjaXNpb24uY2FsbCh0aGF0KSA6ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQsIHByZWNpc2lvbik7XG4gIH1cbn0pOyIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHtcbiAgYXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJylcbn0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7IC8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuXG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxufSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTsgLy8gMTkuMS4yLjMgLyAxNS4yLjMuNyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuXG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7XG4gIGRlZmluZVByb3BlcnRpZXM6IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKVxufSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTsgLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcblxuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0Jywge1xuICBkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxufSk7IiwiLy8gMTkuMS4yLjUgT2JqZWN0LmZyZWV6ZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2ZyZWV6ZScsIGZ1bmN0aW9uICgkZnJlZXplKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmcmVlemUoaXQpIHtcbiAgICByZXR1cm4gJGZyZWV6ZSAmJiBpc09iamVjdChpdCkgPyAkZnJlZXplKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b0lPYmplY3QoaXQpLCBrZXkpO1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlOYW1lcycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpLmY7XG59KTsiLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG52YXIgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpIHtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTEgT2JqZWN0LmlzRXh0ZW5zaWJsZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNFeHRlbnNpYmxlJywgZnVuY3Rpb24gKCRpc0V4dGVuc2libGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZShpdCkgOiB0cnVlIDogZmFsc2U7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTIgT2JqZWN0LmlzRnJvemVuKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0Zyb3plbicsIGZ1bmN0aW9uICgkaXNGcm96ZW4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRnJvemVuKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0Zyb3plbiA/ICRpc0Zyb3plbihpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTMgT2JqZWN0LmlzU2VhbGVkKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc1NlYWxlZCcsIGZ1bmN0aW9uICgkaXNTZWFsZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzU2VhbGVkKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc1NlYWxlZCA/ICRpc1NlYWxlZChpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTsiLCIvLyAxOS4xLjMuMTAgT2JqZWN0LmlzKHZhbHVlMSwgdmFsdWUyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGlzOiByZXF1aXJlKCcuL19zYW1lLXZhbHVlJylcbn0pOyIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xNSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdwcmV2ZW50RXh0ZW5zaW9ucycsIGZ1bmN0aW9uICgkcHJldmVudEV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKGl0KSB7XG4gICAgcmV0dXJuICRwcmV2ZW50RXh0ZW5zaW9ucyAmJiBpc09iamVjdChpdCkgPyAkcHJldmVudEV4dGVuc2lvbnMobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTcgT2JqZWN0LnNlYWwoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdzZWFsJywgZnVuY3Rpb24gKCRzZWFsKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzZWFsKGl0KSB7XG4gICAgcmV0dXJuICRzZWFsICYmIGlzT2JqZWN0KGl0KSA/ICRzZWFsKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7IiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxuXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcblxudmFyIHRlc3QgPSB7fTtcbnRlc3RbcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyldID0gJ3onO1xuXG5pZiAodGVzdCArICcnICE9ICdbb2JqZWN0IHpdJykge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbiAgfSwgdHJ1ZSk7XG59IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTsgLy8gMTguMi40IHBhcnNlRmxvYXQoc3RyaW5nKVxuXG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCB7XG4gIHBhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0XG59KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7IC8vIDE4LjIuNSBwYXJzZUludChzdHJpbmcsIHJhZGl4KVxuXG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlSW50ICE9ICRwYXJzZUludCksIHtcbiAgcGFyc2VJbnQ6ICRwYXJzZUludFxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG5cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xuXG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcblxudmFyIHRhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xuXG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcblxudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcblxudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4vX3VzZXItYWdlbnQnKTtcblxudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG5cbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjggfHwgJyc7XG52YXIgJFByb21pc2UgPSBnbG9iYWxbUFJPTUlTRV07XG52YXIgaXNOb2RlID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbnZhciBlbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgLyogZW1wdHkgKi9cbn07XG5cbnZhciBJbnRlcm5hbCwgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmY7XG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlID0gJFByb21pc2UucmVzb2x2ZSgxKTtcblxuICAgIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgIGV4ZWMoZW1wdHksIGVtcHR5KTtcbiAgICB9OyAvLyB1bmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG5cblxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlIC8vIHY4IDYuNiAoTm9kZSAxMCBhbmQgQ2hyb21lIDY2KSBoYXZlIGEgYnVnIHdpdGggcmVzb2x2aW5nIGN1c3RvbSB0aGVuYWJsZXNcbiAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04MzA1NjVcbiAgICAvLyB3ZSBjYW4ndCBkZXRlY3QgaXQgc3luY2hyb25vdXNseSwgc28ganVzdCBjaGVjayB2ZXJzaW9uc1xuICAgICYmIHY4LmluZGV4T2YoJzYuNicpICE9PSAwICYmIHVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUvNjYnKSA9PT0gLTE7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9XG59KCk7IC8vIGhlbHBlcnNcblxudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG5cbnZhciBub3RpZnkgPSBmdW5jdGlvbiAocHJvbWlzZSwgaXNSZWplY3QpIHtcbiAgaWYgKHByb21pc2UuX24pIHJldHVybjtcbiAgcHJvbWlzZS5fbiA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2M7XG4gIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgb2sgPSBwcm9taXNlLl9zID09IDE7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChyZWFjdGlvbikge1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgICAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9oID09IDIpIG9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhbmRsZXIgPT09IHRydWUpIHJlc3VsdCA9IHZhbHVlO2Vsc2Uge1xuICAgICAgICAgICAgaWYgKGRvbWFpbikgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTsgLy8gbWF5IHRocm93XG5cbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgZXhpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XG4gICAgICAgICAgICByZWplY3QoVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGRvbWFpbiAmJiAhZXhpdGVkKSBkb21haW4uZXhpdCgpO1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSBydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG5cblxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKSBvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xuXG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdjtcbiAgICB2YXIgdW5oYW5kbGVkID0gaXNVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgdmFyIHJlc3VsdCwgaGFuZGxlciwgY29uc29sZTtcblxuICAgIGlmICh1bmhhbmRsZWQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbikge1xuICAgICAgICAgIGhhbmRsZXIoe1xuICAgICAgICAgICAgcHJvbWlzZTogcHJvbWlzZSxcbiAgICAgICAgICAgIHJlYXNvbjogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcblxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH1cblxuICAgIHByb21pc2UuX2EgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHVuaGFuZGxlZCAmJiByZXN1bHQuZSkgdGhyb3cgcmVzdWx0LnY7XG4gIH0pO1xufTtcblxudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgcmV0dXJuIHByb21pc2UuX2ggIT09IDEgJiYgKHByb21pc2UuX2EgfHwgcHJvbWlzZS5fYykubGVuZ3RoID09PSAwO1xufTtcblxudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGVyO1xuXG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCkge1xuICAgICAgaGFuZGxlcih7XG4gICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgIHJlYXNvbjogcHJvbWlzZS5fdlxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmICghcHJvbWlzZS5fYSkgcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcblxudmFyICRyZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgdmFyIHRoZW47XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcblxuICB0cnkge1xuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG5cbiAgICBpZiAodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHtcbiAgICAgICAgICBfdzogcHJvbWlzZSxcbiAgICAgICAgICBfZDogZmFsc2VcbiAgICAgICAgfTsgLy8gd3JhcFxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fcyA9IDE7XG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgICRyZWplY3QuY2FsbCh7XG4gICAgICBfdzogcHJvbWlzZSxcbiAgICAgIF9kOiBmYWxzZVxuICAgIH0sIGUpOyAvLyB3cmFwXG4gIH1cbn07IC8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5cblxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gICRQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJFByb21pc2UsIFBST01JU0UsICdfaCcpO1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcblxuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHRoaXMuX2MgPSBbXTsgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG5cbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuXG4gICAgdGhpcy5fcyA9IDA7IC8vIDwtIHN0YXRlXG5cbiAgICB0aGlzLl9kID0gZmFsc2U7IC8vIDwtIGRvbmVcblxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7IC8vIDwtIHZhbHVlXG5cbiAgICB0aGlzLl9oID0gMDsgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcblxuICAgIHRoaXMuX24gPSBmYWxzZTsgLy8gPC0gbm90aWZ5XG4gIH07XG5cbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJykoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG5cbiAgICAgIGlmICh0aGlzLl9hKSB0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX3MpIG5vdGlmeSh0aGlzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuXG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xuXG4gIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09ICRQcm9taXNlIHx8IEMgPT09IFdyYXBwZXIgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQykgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtcbiAgUHJvbWlzZTogJFByb21pc2Vcbn0pO1xuXG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcblxuV3JhcHBlciA9IHJlcXVpcmUoJy4vX2NvcmUnKVtQUk9NSVNFXTsgLy8gc3RhdGljc1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpO1xuICAgIHZhciAkJHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShMSUJSQVJZICYmIHRoaXMgPT09IFdyYXBwZXIgPyAkUHJvbWlzZSA6IHRoaXMsIHgpO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgJFByb21pc2UuYWxsKGl0ZXIpWydjYXRjaCddKGVtcHR5KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgJGluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pOyIsIi8vIDI2LjEuMSBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciByQXBwbHkgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuYXBwbHk7XG52YXIgZkFwcGx5ID0gRnVuY3Rpb24uYXBwbHk7IC8vIE1TIEVkZ2UgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgckFwcGx5KGZ1bmN0aW9uICgpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KSB7XG4gICAgdmFyIFQgPSBhRnVuY3Rpb24odGFyZ2V0KTtcbiAgICB2YXIgTCA9IGFuT2JqZWN0KGFyZ3VtZW50c0xpc3QpO1xuICAgIHJldHVybiByQXBwbHkgPyByQXBwbHkoVCwgdGhpc0FyZ3VtZW50LCBMKSA6IGZBcHBseS5jYWxsKFQsIHRoaXNBcmd1bWVudCwgTCk7XG4gIH1cbn0pOyIsIi8vIDI2LjEuMiBSZWZsZWN0LmNvbnN0cnVjdCh0YXJnZXQsIGFyZ3VtZW50c0xpc3QgWywgbmV3VGFyZ2V0XSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG5cbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL19iaW5kJyk7XG5cbnZhciByQ29uc3RydWN0ID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmNvbnN0cnVjdDsgLy8gTVMgRWRnZSBzdXBwb3J0cyBvbmx5IDIgYXJndW1lbnRzIGFuZCBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4vLyBGRiBOaWdodGx5IHNldHMgdGhpcmQgYXJndW1lbnQgYXMgYG5ldy50YXJnZXRgLCBidXQgZG9lcyBub3QgY3JlYXRlIGB0aGlzYCBmcm9tIGl0XG5cbnZhciBORVdfVEFSR0VUX0JVRyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9XG5cbiAgcmV0dXJuICEockNvbnN0cnVjdChmdW5jdGlvbiAoKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfSwgW10sIEYpIGluc3RhbmNlb2YgRik7XG59KTtcbnZhciBBUkdTX0JVRyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJDb25zdHJ1Y3QoZnVuY3Rpb24gKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH0pO1xufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChORVdfVEFSR0VUX0JVRyB8fCBBUkdTX0JVRyksICdSZWZsZWN0Jywge1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIGNvbnN0cnVjdChUYXJnZXQsIGFyZ3NcbiAgLyogLCBuZXdUYXJnZXQgKi9cbiAgKSB7XG4gICAgYUZ1bmN0aW9uKFRhcmdldCk7XG4gICAgYW5PYmplY3QoYXJncyk7XG4gICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUZ1bmN0aW9uKGFyZ3VtZW50c1syXSk7XG4gICAgaWYgKEFSR1NfQlVHICYmICFORVdfVEFSR0VUX0JVRykgcmV0dXJuIHJDb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzLCBuZXdUYXJnZXQpO1xuXG4gICAgaWYgKFRhcmdldCA9PSBuZXdUYXJnZXQpIHtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldCgpO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSk7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIH0gLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2VcblxuXG4gICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICAkYXJncy5wdXNoLmFwcGx5KCRhcmdzLCBhcmdzKTtcbiAgICAgIHJldHVybiBuZXcgKGJpbmQuYXBwbHkoVGFyZ2V0LCAkYXJncykpKCk7XG4gICAgfSAvLyB3aXRoIGFsdGVyZWQgbmV3VGFyZ2V0LCBub3Qgc3VwcG9ydCBidWlsdC1pbiBjb25zdHJ1Y3RvcnNcblxuXG4gICAgdmFyIHByb3RvID0gbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGUoaXNPYmplY3QocHJvdG8pID8gcHJvdG8gOiBPYmplY3QucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gRnVuY3Rpb24uYXBwbHkuY2FsbChUYXJnZXQsIGluc3RhbmNlLCBhcmdzKTtcbiAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IGluc3RhbmNlO1xuICB9XG59KTsiLCIvLyAyNi4xLjMgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKVxudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTsgLy8gTVMgRWRnZSBoYXMgYnJva2VuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkgLSB0aHJvd2luZyBpbnN0ZWFkIG9mIHJldHVybmluZyBmYWxzZVxuXG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KGRQLmYoe30sIDEsIHtcbiAgICB2YWx1ZTogMVxuICB9KSwgMSwge1xuICAgIHZhbHVlOiAyXG4gIH0pO1xufSksICdSZWZsZWN0Jywge1xuICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcykge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcHJvcGVydHlLZXkgPSB0b1ByaW1pdGl2ZShwcm9wZXJ0eUtleSwgdHJ1ZSk7XG4gICAgYW5PYmplY3QoYXR0cmlidXRlcyk7XG5cbiAgICB0cnkge1xuICAgICAgZFAuZih0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pOyIsIi8vIDI2LjEuNCBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICB2YXIgZGVzYyA9IGdPUEQoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICAgIHJldHVybiBkZXNjICYmICFkZXNjLmNvbmZpZ3VyYWJsZSA/IGZhbHNlIDogZGVsZXRlIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gMjYuMS41IFJlZmxlY3QuZW51bWVyYXRlKHRhcmdldClcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBFbnVtZXJhdGUgPSBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IGFuT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG5cbiAgdGhpcy5faSA9IDA7IC8vIG5leHQgaW5kZXhcblxuICB2YXIga2V5cyA9IHRoaXMuX2sgPSBbXTsgLy8ga2V5c1xuXG4gIHZhciBrZXk7XG5cbiAgZm9yIChrZXkgaW4gaXRlcmF0ZWQpIGtleXMucHVzaChrZXkpO1xufTtcblxucmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKShFbnVtZXJhdGUsICdPYmplY3QnLCBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gdGhpcztcbiAgdmFyIGtleXMgPSB0aGF0Ll9rO1xuICB2YXIga2V5O1xuXG4gIGRvIHtcbiAgICBpZiAodGhhdC5faSA+PSBrZXlzLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBkb25lOiB0cnVlXG4gICAgfTtcbiAgfSB3aGlsZSAoISgoa2V5ID0ga2V5c1t0aGF0Ll9pKytdKSBpbiB0aGF0Ll90KSk7XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZToga2V5LFxuICAgIGRvbmU6IGZhbHNlXG4gIH07XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBlbnVtZXJhdGU6IGZ1bmN0aW9uIGVudW1lcmF0ZSh0YXJnZXQpIHtcbiAgICByZXR1cm4gbmV3IEVudW1lcmF0ZSh0YXJnZXQpO1xuICB9XG59KTsiLCIvLyAyNi4xLjcgUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHJldHVybiBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICB9XG59KTsiLCIvLyAyNi4xLjggUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgZ2V0UHJvdG8gPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZih0YXJnZXQpIHtcbiAgICByZXR1cm4gZ2V0UHJvdG8oYW5PYmplY3QodGFyZ2V0KSk7XG4gIH1cbn0pOyIsIi8vIDI2LjEuNiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5S2V5IFssIHJlY2VpdmVyXSlcbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcblxudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuZnVuY3Rpb24gZ2V0KHRhcmdldCwgcHJvcGVydHlLZXlcbi8qICwgcmVjZWl2ZXIgKi9cbikge1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXTtcbiAgdmFyIGRlc2MsIHByb3RvO1xuICBpZiAoYW5PYmplY3QodGFyZ2V0KSA9PT0gcmVjZWl2ZXIpIHJldHVybiB0YXJnZXRbcHJvcGVydHlLZXldO1xuICBpZiAoZGVzYyA9IGdPUEQuZih0YXJnZXQsIHByb3BlcnR5S2V5KSkgcmV0dXJuIGhhcyhkZXNjLCAndmFsdWUnKSA/IGRlc2MudmFsdWUgOiBkZXNjLmdldCAhPT0gdW5kZWZpbmVkID8gZGVzYy5nZXQuY2FsbChyZWNlaXZlcikgOiB1bmRlZmluZWQ7XG4gIGlmIChpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKSByZXR1cm4gZ2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgcmVjZWl2ZXIpO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldDogZ2V0XG59KTsiLCIvLyAyNi4xLjkgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHJldHVybiBwcm9wZXJ0eUtleSBpbiB0YXJnZXQ7XG4gIH1cbn0pOyIsIi8vIDI2LjEuMTAgUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciAkaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaXNFeHRlbnNpYmxlOiBmdW5jdGlvbiBpc0V4dGVuc2libGUodGFyZ2V0KSB7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICByZXR1cm4gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUodGFyZ2V0KSA6IHRydWU7XG4gIH1cbn0pOyIsIi8vIDI2LjEuMTEgUmVmbGVjdC5vd25LZXlzKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgb3duS2V5czogcmVxdWlyZSgnLi9fb3duLWtleXMnKVxufSk7IiwiLy8gMjYuMS4xMiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgJHByZXZlbnRFeHRlbnNpb25zID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KSB7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoJHByZXZlbnRFeHRlbnNpb25zKSAkcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pOyIsIi8vIDI2LjEuMTQgUmVmbGVjdC5zZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHNldFByb3RvID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJyk7XG5cbmlmIChzZXRQcm90bykgJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBzZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bykge1xuICAgIHNldFByb3RvLmNoZWNrKHRhcmdldCwgcHJvdG8pO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldFByb3RvLnNldCh0YXJnZXQsIHByb3RvKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pOyIsIi8vIDI2LjEuMTMgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViBbLCByZWNlaXZlcl0pXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xuXG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxuZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFZcbi8qICwgcmVjZWl2ZXIgKi9cbikge1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgNCA/IHRhcmdldCA6IGFyZ3VtZW50c1szXTtcbiAgdmFyIG93bkRlc2MgPSBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICB2YXIgZXhpc3RpbmdEZXNjcmlwdG9yLCBwcm90bztcblxuICBpZiAoIW93bkRlc2MpIHtcbiAgICBpZiAoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSkge1xuICAgICAgcmV0dXJuIHNldChwcm90bywgcHJvcGVydHlLZXksIFYsIHJlY2VpdmVyKTtcbiAgICB9XG5cbiAgICBvd25EZXNjID0gY3JlYXRlRGVzYygwKTtcbiAgfVxuXG4gIGlmIChoYXMob3duRGVzYywgJ3ZhbHVlJykpIHtcbiAgICBpZiAob3duRGVzYy53cml0YWJsZSA9PT0gZmFsc2UgfHwgIWlzT2JqZWN0KHJlY2VpdmVyKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKGV4aXN0aW5nRGVzY3JpcHRvciA9IGdPUEQuZihyZWNlaXZlciwgcHJvcGVydHlLZXkpKSB7XG4gICAgICBpZiAoZXhpc3RpbmdEZXNjcmlwdG9yLmdldCB8fCBleGlzdGluZ0Rlc2NyaXB0b3Iuc2V0IHx8IGV4aXN0aW5nRGVzY3JpcHRvci53cml0YWJsZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIGV4aXN0aW5nRGVzY3JpcHRvci52YWx1ZSA9IFY7XG4gICAgICBkUC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgZXhpc3RpbmdEZXNjcmlwdG9yKTtcbiAgICB9IGVsc2UgZFAuZihyZWNlaXZlciwgcHJvcGVydHlLZXksIGNyZWF0ZURlc2MoMCwgVikpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gb3duRGVzYy5zZXQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogKG93bkRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIFYpLCB0cnVlKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBzZXQ6IHNldFxufSk7IiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG5cbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5cbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xuXG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcblxudmFyICRmbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG5cbnZhciAkUmVnRXhwID0gZ2xvYmFsLlJlZ0V4cDtcbnZhciBCYXNlID0gJFJlZ0V4cDtcbnZhciBwcm90byA9ICRSZWdFeHAucHJvdG90eXBlO1xudmFyIHJlMSA9IC9hL2c7XG52YXIgcmUyID0gL2EvZzsgLy8gXCJuZXdcIiBjcmVhdGVzIGEgbmV3IG9iamVjdCwgb2xkIHdlYmtpdCBidWdneSBoZXJlXG5cbnZhciBDT1JSRUNUX05FVyA9IG5ldyAkUmVnRXhwKHJlMSkgIT09IHJlMTtcblxuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgKCFDT1JSRUNUX05FVyB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmUyW3JlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpXSA9IGZhbHNlOyAvLyBSZWdFeHAgY29uc3RydWN0b3IgY2FuIGFsdGVyIGZsYWdzIGFuZCBJc1JlZ0V4cCB3b3JrcyBjb3JyZWN0IHdpdGggQEBtYXRjaFxuXG4gIHJldHVybiAkUmVnRXhwKHJlMSkgIT0gcmUxIHx8ICRSZWdFeHAocmUyKSA9PSByZTIgfHwgJFJlZ0V4cChyZTEsICdpJykgIT0gJy9hL2knO1xufSkpKSB7XG4gICRSZWdFeHAgPSBmdW5jdGlvbiBSZWdFeHAocCwgZikge1xuICAgIHZhciB0aVJFID0gdGhpcyBpbnN0YW5jZW9mICRSZWdFeHA7XG4gICAgdmFyIHBpUkUgPSBpc1JlZ0V4cChwKTtcbiAgICB2YXIgZmlVID0gZiA9PT0gdW5kZWZpbmVkO1xuICAgIHJldHVybiAhdGlSRSAmJiBwaVJFICYmIHAuY29uc3RydWN0b3IgPT09ICRSZWdFeHAgJiYgZmlVID8gcCA6IGluaGVyaXRJZlJlcXVpcmVkKENPUlJFQ1RfTkVXID8gbmV3IEJhc2UocGlSRSAmJiAhZmlVID8gcC5zb3VyY2UgOiBwLCBmKSA6IEJhc2UoKHBpUkUgPSBwIGluc3RhbmNlb2YgJFJlZ0V4cCkgPyBwLnNvdXJjZSA6IHAsIHBpUkUgJiYgZmlVID8gJGZsYWdzLmNhbGwocCkgOiBmKSwgdGlSRSA/IHRoaXMgOiBwcm90bywgJFJlZ0V4cCk7XG4gIH07XG5cbiAgdmFyIHByb3h5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGtleSBpbiAkUmVnRXhwIHx8IGRQKCRSZWdFeHAsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBCYXNlW2tleV07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoaXQpIHtcbiAgICAgICAgQmFzZVtrZXldID0gaXQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIga2V5cyA9IGdPUE4oQmFzZSksIGkgPSAwOyBrZXlzLmxlbmd0aCA+IGk7KSBwcm94eShrZXlzW2krK10pO1xuXG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJFJlZ0V4cDtcbiAgJFJlZ0V4cC5wcm90b3R5cGUgPSBwcm90bztcblxuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgJ1JlZ0V4cCcsICRSZWdFeHApO1xufVxuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdSZWdFeHAnKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciByZWdleHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMnKTtcblxucmVxdWlyZSgnLi9fZXhwb3J0Jykoe1xuICB0YXJnZXQ6ICdSZWdFeHAnLFxuICBwcm90bzogdHJ1ZSxcbiAgZm9yY2VkOiByZWdleHBFeGVjICE9PSAvLi8uZXhlY1xufSwge1xuICBleGVjOiByZWdleHBFeGVjXG59KTsiLCIvLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFncygpXG5pZiAocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAvLi9nLmZsYWdzICE9ICdnJykgcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihSZWdFeHAucHJvdG90eXBlLCAnZmxhZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiByZXF1aXJlKCcuL19mbGFncycpXG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IHJlcXVpcmUoJy4vX2FkdmFuY2Utc3RyaW5nLWluZGV4Jyk7XG5cbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTsgLy8gQEBtYXRjaCBsb2dpY1xuXG5cbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnbWF0Y2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgTUFUQ0gsICRtYXRjaCwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHJldHVybiBbLy8gYFN0cmluZy5wcm90b3R5cGUubWF0Y2hgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLm1hdGNoXG4gIGZ1bmN0aW9uIG1hdGNoKHJlZ2V4cCkge1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW01BVENIXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtNQVRDSF0oU3RyaW5nKE8pKTtcbiAgfSwgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF1gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAbWF0Y2hcbiAgZnVuY3Rpb24gKHJlZ2V4cCkge1xuICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoJG1hdGNoLCByZWdleHAsIHRoaXMpO1xuICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgIGlmICghcnguZ2xvYmFsKSByZXR1cm4gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBBID0gW107XG4gICAgdmFyIG4gPSAwO1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICB3aGlsZSAoKHJlc3VsdCA9IHJlZ0V4cEV4ZWMocngsIFMpKSAhPT0gbnVsbCkge1xuICAgICAgdmFyIG1hdGNoU3RyID0gU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICBBW25dID0gbWF0Y2hTdHI7XG4gICAgICBpZiAobWF0Y2hTdHIgPT09ICcnKSByeC5sYXN0SW5kZXggPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgdG9MZW5ndGgocngubGFzdEluZGV4KSwgZnVsbFVuaWNvZGUpO1xuICAgICAgbisrO1xuICAgIH1cblxuICAgIHJldHVybiBuID09PSAwID8gbnVsbCA6IEE7XG4gIH1dO1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xuXG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi9fYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcblxudmFyIHJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIFNVQlNUSVRVVElPTl9TWU1CT0xTID0gL1xcJChbJCZgJ118XFxkXFxkP3w8W14+XSo+KS9nO1xudmFyIFNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEID0gL1xcJChbJCZgJ118XFxkXFxkPykvZztcblxudmFyIG1heWJlVG9TdHJpbmcgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyBpdCA6IFN0cmluZyhpdCk7XG59OyAvLyBAQHJlcGxhY2UgbG9naWNcblxuXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgUkVQTEFDRSwgJHJlcGxhY2UsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICByZXR1cm4gWy8vIGBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGxhY2VcbiAgZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSB7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBmbiA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChzZWFyY2hWYWx1ZSwgTywgcmVwbGFjZVZhbHVlKSA6ICRyZXBsYWNlLmNhbGwoU3RyaW5nKE8pLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcbiAgfSwgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEByZXBsYWNlXG4gIGZ1bmN0aW9uIChyZWdleHAsIHJlcGxhY2VWYWx1ZSkge1xuICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoJHJlcGxhY2UsIHJlZ2V4cCwgdGhpcywgcmVwbGFjZVZhbHVlKTtcbiAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG4gICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcbiAgICB2YXIgZnVuY3Rpb25hbFJlcGxhY2UgPSB0eXBlb2YgcmVwbGFjZVZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgIGlmICghZnVuY3Rpb25hbFJlcGxhY2UpIHJlcGxhY2VWYWx1ZSA9IFN0cmluZyhyZXBsYWNlVmFsdWUpO1xuICAgIHZhciBnbG9iYWwgPSByeC5nbG9iYWw7XG5cbiAgICBpZiAoZ2xvYmFsKSB7XG4gICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGJyZWFrO1xuICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICBpZiAoIWdsb2JhbCkgYnJlYWs7XG4gICAgICB2YXIgbWF0Y2hTdHIgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgIGlmIChtYXRjaFN0ciA9PT0gJycpIHJ4Lmxhc3RJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCB0b0xlbmd0aChyeC5sYXN0SW5kZXgpLCBmdWxsVW5pY29kZSk7XG4gICAgfVxuXG4gICAgdmFyIGFjY3VtdWxhdGVkUmVzdWx0ID0gJyc7XG4gICAgdmFyIG5leHRTb3VyY2VQb3NpdGlvbiA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdHNbaV07XG4gICAgICB2YXIgbWF0Y2hlZCA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgdmFyIHBvc2l0aW9uID0gbWF4KG1pbih0b0ludGVnZXIocmVzdWx0LmluZGV4KSwgUy5sZW5ndGgpLCAwKTtcbiAgICAgIHZhciBjYXB0dXJlcyA9IFtdOyAvLyBOT1RFOiBUaGlzIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgIC8vICAgY2FwdHVyZXMgPSByZXN1bHQuc2xpY2UoMSkubWFwKG1heWJlVG9TdHJpbmcpXG4gICAgICAvLyBidXQgZm9yIHNvbWUgcmVhc29uIGBuYXRpdmVTbGljZS5jYWxsKHJlc3VsdCwgMSwgcmVzdWx0Lmxlbmd0aClgIChjYWxsZWQgaW5cbiAgICAgIC8vIHRoZSBzbGljZSBwb2x5ZmlsbCB3aGVuIHNsaWNpbmcgbmF0aXZlIGFycmF5cykgXCJkb2Vzbid0IHdvcmtcIiBpbiBzYWZhcmkgOSBhbmRcbiAgICAgIC8vIGNhdXNlcyBhIGNyYXNoIChodHRwczovL3Bhc3RlYmluLmNvbS9OMjFRemVRQSkgd2hlbiB0cnlpbmcgdG8gZGVidWcgaXQuXG5cbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgcmVzdWx0Lmxlbmd0aDsgaisrKSBjYXB0dXJlcy5wdXNoKG1heWJlVG9TdHJpbmcocmVzdWx0W2pdKSk7XG5cbiAgICAgIHZhciBuYW1lZENhcHR1cmVzID0gcmVzdWx0Lmdyb3VwcztcblxuICAgICAgaWYgKGZ1bmN0aW9uYWxSZXBsYWNlKSB7XG4gICAgICAgIHZhciByZXBsYWNlckFyZ3MgPSBbbWF0Y2hlZF0uY29uY2F0KGNhcHR1cmVzLCBwb3NpdGlvbiwgUyk7XG4gICAgICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHJlcGxhY2VyQXJncy5wdXNoKG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBTdHJpbmcocmVwbGFjZVZhbHVlLmFwcGx5KHVuZGVmaW5lZCwgcmVwbGFjZXJBcmdzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXBsYWNlbWVudCA9IGdldFN1YnN0aXR1dGlvbihtYXRjaGVkLCBTLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NpdGlvbiA+PSBuZXh0U291cmNlUG9zaXRpb24pIHtcbiAgICAgICAgYWNjdW11bGF0ZWRSZXN1bHQgKz0gUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24sIHBvc2l0aW9uKSArIHJlcGxhY2VtZW50O1xuICAgICAgICBuZXh0U291cmNlUG9zaXRpb24gPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhY2N1bXVsYXRlZFJlc3VsdCArIFMuc2xpY2UobmV4dFNvdXJjZVBvc2l0aW9uKTtcbiAgfV07IC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldHN1YnN0aXR1dGlvblxuXG4gIGZ1bmN0aW9uIGdldFN1YnN0aXR1dGlvbihtYXRjaGVkLCBzdHIsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZW1lbnQpIHtcbiAgICB2YXIgdGFpbFBvcyA9IHBvc2l0aW9uICsgbWF0Y2hlZC5sZW5ndGg7XG4gICAgdmFyIG0gPSBjYXB0dXJlcy5sZW5ndGg7XG4gICAgdmFyIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRDtcblxuICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5hbWVkQ2FwdHVyZXMgPSB0b09iamVjdChuYW1lZENhcHR1cmVzKTtcbiAgICAgIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MUztcbiAgICB9XG5cbiAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChyZXBsYWNlbWVudCwgc3ltYm9scywgZnVuY3Rpb24gKG1hdGNoLCBjaCkge1xuICAgICAgdmFyIGNhcHR1cmU7XG5cbiAgICAgIHN3aXRjaCAoY2guY2hhckF0KDApKSB7XG4gICAgICAgIGNhc2UgJyQnOlxuICAgICAgICAgIHJldHVybiAnJCc7XG5cbiAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG5cbiAgICAgICAgY2FzZSAnYCc6XG4gICAgICAgICAgcmV0dXJuIHN0ci5zbGljZSgwLCBwb3NpdGlvbik7XG5cbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICByZXR1cm4gc3RyLnNsaWNlKHRhaWxQb3MpO1xuXG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgIGNhcHR1cmUgPSBuYW1lZENhcHR1cmVzW2NoLnNsaWNlKDEsIC0xKV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBcXGRcXGQ/XG4gICAgICAgICAgdmFyIG4gPSArY2g7XG4gICAgICAgICAgaWYgKG4gPT09IDApIHJldHVybiBtYXRjaDtcblxuICAgICAgICAgIGlmIChuID4gbSkge1xuICAgICAgICAgICAgdmFyIGYgPSBmbG9vcihuIC8gMTApO1xuICAgICAgICAgICAgaWYgKGYgPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgIGlmIChmIDw9IG0pIHJldHVybiBjYXB0dXJlc1tmIC0gMV0gPT09IHVuZGVmaW5lZCA/IGNoLmNoYXJBdCgxKSA6IGNhcHR1cmVzW2YgLSAxXSArIGNoLmNoYXJBdCgxKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXB0dXJlID0gY2FwdHVyZXNbbiAtIDFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FwdHVyZSA9PT0gdW5kZWZpbmVkID8gJycgOiBjYXB0dXJlO1xuICAgIH0pO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgc2FtZVZhbHVlID0gcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpO1xuXG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7IC8vIEBAc2VhcmNoIGxvZ2ljXG5cblxucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzZWFyY2gnLCAxLCBmdW5jdGlvbiAoZGVmaW5lZCwgU0VBUkNILCAkc2VhcmNoLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgcmV0dXJuIFsvLyBgU3RyaW5nLnByb3RvdHlwZS5zZWFyY2hgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnNlYXJjaFxuICBmdW5jdGlvbiBzZWFyY2gocmVnZXhwKSB7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbU0VBUkNIXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtTRUFSQ0hdKFN0cmluZyhPKSk7XG4gIH0sIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBzZWFyY2hcbiAgZnVuY3Rpb24gKHJlZ2V4cCkge1xuICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoJHNlYXJjaCwgcmVnZXhwLCB0aGlzKTtcbiAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG4gICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcbiAgICB2YXIgcHJldmlvdXNMYXN0SW5kZXggPSByeC5sYXN0SW5kZXg7XG4gICAgaWYgKCFzYW1lVmFsdWUocHJldmlvdXNMYXN0SW5kZXgsIDApKSByeC5sYXN0SW5kZXggPSAwO1xuICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICBpZiAoIXNhbWVWYWx1ZShyeC5sYXN0SW5kZXgsIHByZXZpb3VzTGFzdEluZGV4KSkgcngubGFzdEluZGV4ID0gcHJldmlvdXNMYXN0SW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IC0xIDogcmVzdWx0LmluZGV4O1xuICB9XTtcbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi9fYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbnZhciBjYWxsUmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG5cbnZhciByZWdleHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMnKTtcblxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxudmFyICRtaW4gPSBNYXRoLm1pbjtcbnZhciAkcHVzaCA9IFtdLnB1c2g7XG52YXIgJFNQTElUID0gJ3NwbGl0JztcbnZhciBMRU5HVEggPSAnbGVuZ3RoJztcbnZhciBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG52YXIgTUFYX1VJTlQzMiA9IDB4ZmZmZmZmZmY7IC8vIGJhYmVsLW1pbmlmeSB0cmFuc3BpbGVzIFJlZ0V4cCgneCcsICd5JykgLT4gL3gveSBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG5cbnZhciBTVVBQT1JUU19ZID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgUmVnRXhwKE1BWF9VSU5UMzIsICd5Jyk7XG59KTsgLy8gQEBzcGxpdCBsb2dpY1xuXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NwbGl0JywgMiwgZnVuY3Rpb24gKGRlZmluZWQsIFNQTElULCAkc3BsaXQsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICB2YXIgaW50ZXJuYWxTcGxpdDtcblxuICBpZiAoJ2FiYmMnWyRTUExJVF0oLyhiKSovKVsxXSA9PSAnYycgfHwgJ3Rlc3QnWyRTUExJVF0oLyg/OikvLCAtMSlbTEVOR1RIXSAhPSA0IHx8ICdhYidbJFNQTElUXSgvKD86YWIpKi8pW0xFTkdUSF0gIT0gMiB8fCAnLidbJFNQTElUXSgvKC4/KSguPykvKVtMRU5HVEhdICE9IDQgfHwgJy4nWyRTUExJVF0oLygpKCkvKVtMRU5HVEhdID4gMSB8fCAnJ1skU1BMSVRdKC8uPy8pW0xFTkdUSF0pIHtcbiAgICAvLyBiYXNlZCBvbiBlczUtc2hpbSBpbXBsZW1lbnRhdGlvbiwgbmVlZCB0byByZXdvcmsgaXRcbiAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDApIHJldHVybiBbXTsgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcblxuICAgICAgaWYgKCFpc1JlZ0V4cChzZXBhcmF0b3IpKSByZXR1cm4gJHNwbGl0LmNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICsgKHNlcGFyYXRvci51bmljb2RlID8gJ3UnIDogJycpICsgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgc3BsaXRMaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfVUlOVDMyIDogbGltaXQgPj4+IDA7IC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG5cbiAgICAgIHZhciBzZXBhcmF0b3JDb3B5ID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICB2YXIgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcblxuICAgICAgd2hpbGUgKG1hdGNoID0gcmVnZXhwRXhlYy5jYWxsKHNlcGFyYXRvckNvcHksIHN0cmluZykpIHtcbiAgICAgICAgbGFzdEluZGV4ID0gc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXTtcblxuICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIGlmIChtYXRjaFtMRU5HVEhdID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZ1tMRU5HVEhdKSAkcHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF1bTEVOR1RIXTtcbiAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgIGlmIChvdXRwdXRbTEVOR1RIXSA+PSBzcGxpdExpbWl0KSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdID09PSBtYXRjaC5pbmRleCkgc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG5cbiAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmdbTEVOR1RIXSkge1xuICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yQ29weS50ZXN0KCcnKSkgb3V0cHV0LnB1c2goJycpO1xuICAgICAgfSBlbHNlIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG5cbiAgICAgIHJldHVybiBvdXRwdXRbTEVOR1RIXSA+IHNwbGl0TGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgc3BsaXRMaW1pdCkgOiBvdXRwdXQ7XG4gICAgfTsgLy8gQ2hha3JhLCBWOFxuXG4gIH0gZWxzZSBpZiAoJzAnWyRTUExJVF0odW5kZWZpbmVkLCAwKVtMRU5HVEhdKSB7XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICByZXR1cm4gc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDAgPyBbXSA6ICRzcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaW50ZXJuYWxTcGxpdCA9ICRzcGxpdDtcbiAgfVxuXG4gIHJldHVybiBbLy8gYFN0cmluZy5wcm90b3R5cGUuc3BsaXRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnNwbGl0XG4gIGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIHNwbGl0dGVyID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlcGFyYXRvcltTUExJVF07XG4gICAgcmV0dXJuIHNwbGl0dGVyICE9PSB1bmRlZmluZWQgPyBzcGxpdHRlci5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpIDogaW50ZXJuYWxTcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gIH0sIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHNwbGl0XG4gIC8vXG4gIC8vIE5PVEU6IFRoaXMgY2Fubm90IGJlIHByb3Blcmx5IHBvbHlmaWxsZWQgaW4gZW5naW5lcyB0aGF0IGRvbid0IHN1cHBvcnRcbiAgLy8gdGhlICd5JyBmbGFnLlxuICBmdW5jdGlvbiAocmVnZXhwLCBsaW1pdCkge1xuICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoaW50ZXJuYWxTcGxpdCwgcmVnZXhwLCB0aGlzLCBsaW1pdCwgaW50ZXJuYWxTcGxpdCAhPT0gJHNwbGl0KTtcbiAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG4gICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcbiAgICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3RvcihyeCwgUmVnRXhwKTtcbiAgICB2YXIgdW5pY29kZU1hdGNoaW5nID0gcngudW5pY29kZTtcbiAgICB2YXIgZmxhZ3MgPSAocnguaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArIChyeC5tdWx0aWxpbmUgPyAnbScgOiAnJykgKyAocngudW5pY29kZSA/ICd1JyA6ICcnKSArIChTVVBQT1JUU19ZID8gJ3knIDogJ2cnKTsgLy8gXig/ICsgcnggKyApIGlzIG5lZWRlZCwgaW4gY29tYmluYXRpb24gd2l0aCBzb21lIFMgc2xpY2luZywgdG9cbiAgICAvLyBzaW11bGF0ZSB0aGUgJ3knIGZsYWcuXG5cbiAgICB2YXIgc3BsaXR0ZXIgPSBuZXcgQyhTVVBQT1JUU19ZID8gcnggOiAnXig/OicgKyByeC5zb3VyY2UgKyAnKScsIGZsYWdzKTtcbiAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICBpZiAobGltID09PSAwKSByZXR1cm4gW107XG4gICAgaWYgKFMubGVuZ3RoID09PSAwKSByZXR1cm4gY2FsbFJlZ0V4cEV4ZWMoc3BsaXR0ZXIsIFMpID09PSBudWxsID8gW1NdIDogW107XG4gICAgdmFyIHAgPSAwO1xuICAgIHZhciBxID0gMDtcbiAgICB2YXIgQSA9IFtdO1xuXG4gICAgd2hpbGUgKHEgPCBTLmxlbmd0aCkge1xuICAgICAgc3BsaXR0ZXIubGFzdEluZGV4ID0gU1VQUE9SVFNfWSA/IHEgOiAwO1xuICAgICAgdmFyIHogPSBjYWxsUmVnRXhwRXhlYyhzcGxpdHRlciwgU1VQUE9SVFNfWSA/IFMgOiBTLnNsaWNlKHEpKTtcbiAgICAgIHZhciBlO1xuXG4gICAgICBpZiAoeiA9PT0gbnVsbCB8fCAoZSA9ICRtaW4odG9MZW5ndGgoc3BsaXR0ZXIubGFzdEluZGV4ICsgKFNVUFBPUlRTX1kgPyAwIDogcSkpLCBTLmxlbmd0aCkpID09PSBwKSB7XG4gICAgICAgIHEgPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgcSwgdW5pY29kZU1hdGNoaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEEucHVzaChTLnNsaWNlKHAsIHEpKTtcbiAgICAgICAgaWYgKEEubGVuZ3RoID09PSBsaW0pIHJldHVybiBBO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHoubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgQS5wdXNoKHpbaV0pO1xuICAgICAgICAgIGlmIChBLmxlbmd0aCA9PT0gbGltKSByZXR1cm4gQTtcbiAgICAgICAgfVxuXG4gICAgICAgIHEgPSBwID0gZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBBLnB1c2goUy5zbGljZShwKSk7XG4gICAgcmV0dXJuIEE7XG4gIH1dO1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL2VzNi5yZWdleHAuZmxhZ3MnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciAkZmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xuXG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xuXG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSAvLi9bVE9fU1RSSU5HXTtcblxudmFyIGRlZmluZSA9IGZ1bmN0aW9uIChmbikge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZm4sIHRydWUpO1xufTsgLy8gMjEuMi41LjE0IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcoKVxuXG5cbmlmIChyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICR0b1N0cmluZy5jYWxsKHtcbiAgICBzb3VyY2U6ICdhJyxcbiAgICBmbGFnczogJ2InXG4gIH0pICE9ICcvYS9iJztcbn0pKSB7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHJldHVybiAnLycuY29uY2F0KFIuc291cmNlLCAnLycsICdmbGFncycgaW4gUiA/IFIuZmxhZ3MgOiAhREVTQ1JJUFRPUlMgJiYgUiBpbnN0YW5jZW9mIFJlZ0V4cCA/ICRmbGFncy5jYWxsKFIpIDogdW5kZWZpbmVkKTtcbiAgfSk7IC8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG59IGVsc2UgaWYgKCR0b1N0cmluZy5uYW1lICE9IFRPX1NUUklORykge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICR0b1N0cmluZy5jYWxsKHRoaXMpO1xuICB9KTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG5cbnZhciBTRVQgPSAnU2V0JzsgLy8gMjMuMiBTZXQgT2JqZWN0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShTRVQsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgU0VUKSwgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpOyIsIid1c2Ugc3RyaWN0JzsgLy8gQi4yLjMuMiBTdHJpbmcucHJvdG90eXBlLmFuY2hvcihuYW1lKVxuXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdhbmNob3InLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYW5jaG9yKG5hbWUpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICduYW1lJywgbmFtZSk7XG4gIH07XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIEIuMi4zLjMgU3RyaW5nLnByb3RvdHlwZS5iaWcoKVxuXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdiaWcnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYmlnKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdiaWcnLCAnJywgJycpO1xuICB9O1xufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBCLjIuMy40IFN0cmluZy5wcm90b3R5cGUuYmxpbmsoKVxuXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdibGluaycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBibGluaygpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmxpbmsnLCAnJywgJycpO1xuICB9O1xufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBCLjIuMy41IFN0cmluZy5wcm90b3R5cGUuYm9sZCgpXG5cbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JvbGQnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYm9sZCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYicsICcnLCAnJyk7XG4gIH07XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKShmYWxzZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMyBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KHBvcylcbiAgY29kZVBvaW50QXQ6IGZ1bmN0aW9uIGNvZGVQb2ludEF0KHBvcykge1xuICAgIHJldHVybiAkYXQodGhpcywgcG9zKTtcbiAgfVxufSk7IiwiLy8gMjEuMS4zLjYgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aChzZWFyY2hTdHJpbmcgWywgZW5kUG9zaXRpb25dKVxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xuXG52YXIgRU5EU19XSVRIID0gJ2VuZHNXaXRoJztcbnZhciAkZW5kc1dpdGggPSAnJ1tFTkRTX1dJVEhdO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShFTkRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBlbmRzV2l0aDogZnVuY3Rpb24gZW5kc1dpdGgoc2VhcmNoU3RyaW5nXG4gIC8qICwgZW5kUG9zaXRpb24gPSBAbGVuZ3RoICovXG4gICkge1xuICAgIHZhciB0aGF0ID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIEVORFNfV0lUSCk7XG4gICAgdmFyIGVuZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHRoYXQubGVuZ3RoKTtcbiAgICB2YXIgZW5kID0gZW5kUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGxlbiA6IE1hdGgubWluKHRvTGVuZ3RoKGVuZFBvc2l0aW9uKSwgbGVuKTtcbiAgICB2YXIgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuICRlbmRzV2l0aCA/ICRlbmRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgZW5kKSA6IHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIEIuMi4zLjYgU3RyaW5nLnByb3RvdHlwZS5maXhlZCgpXG5cbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZpeGVkJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZpeGVkKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICd0dCcsICcnLCAnJyk7XG4gIH07XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIEIuMi4zLjcgU3RyaW5nLnByb3RvdHlwZS5mb250Y29sb3IoY29sb3IpXG5cbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRjb2xvcicsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb250Y29sb3IoY29sb3IpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdjb2xvcicsIGNvbG9yKTtcbiAgfTtcbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gQi4yLjMuOCBTdHJpbmcucHJvdG90eXBlLmZvbnRzaXplKHNpemUpXG5cbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRzaXplJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRzaXplKHNpemUpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdzaXplJywgc2l6ZSk7XG4gIH07XG59KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcblxudmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG52YXIgJGZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludDsgLy8gbGVuZ3RoIHNob3VsZCBiZSAxLCBvbGQgRkYgcHJvYmxlbVxuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghISRmcm9tQ29kZVBvaW50ICYmICRmcm9tQ29kZVBvaW50Lmxlbmd0aCAhPSAxKSwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjIgU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY29kZVBvaW50cylcbiAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24gZnJvbUNvZGVQb2ludCh4KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBjb2RlO1xuXG4gICAgd2hpbGUgKGFMZW4gPiBpKSB7XG4gICAgICBjb2RlID0gK2FyZ3VtZW50c1tpKytdO1xuICAgICAgaWYgKHRvQWJzb2x1dGVJbmRleChjb2RlLCAweDEwZmZmZikgIT09IGNvZGUpIHRocm93IFJhbmdlRXJyb3IoY29kZSArICcgaXMgbm90IGEgdmFsaWQgY29kZSBwb2ludCcpO1xuICAgICAgcmVzLnB1c2goY29kZSA8IDB4MTAwMDAgPyBmcm9tQ2hhckNvZGUoY29kZSkgOiBmcm9tQ2hhckNvZGUoKChjb2RlIC09IDB4MTAwMDApID4+IDEwKSArIDB4ZDgwMCwgY29kZSAlIDB4NDAwICsgMHhkYzAwKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7IiwiLy8gMjEuMS4zLjcgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyhzZWFyY2hTdHJpbmcsIHBvc2l0aW9uID0gMClcbid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xuXG52YXIgSU5DTFVERVMgPSAnaW5jbHVkZXMnO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShJTkNMVURFUyksICdTdHJpbmcnLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmdcbiAgLyogLCBwb3NpdGlvbiA9IDAgKi9cbiAgKSB7XG4gICAgcmV0dXJuICEhfmNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBJTkNMVURFUykuaW5kZXhPZihzZWFyY2hTdHJpbmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBCLjIuMy45IFN0cmluZy5wcm90b3R5cGUuaXRhbGljcygpXG5cbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2l0YWxpY3MnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gaXRhbGljcygpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnaScsICcnLCAnJyk7XG4gIH07XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTsgLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxuXG5cbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcblxuICB0aGlzLl9pID0gMDsgLy8gbmV4dCBpbmRleFxuICAvLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGluZGV4ID0gdGhpcy5faTtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBkb25lOiB0cnVlXG4gIH07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHBvaW50LFxuICAgIGRvbmU6IGZhbHNlXG4gIH07XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIEIuMi4zLjEwIFN0cmluZy5wcm90b3R5cGUubGluayh1cmwpXG5cbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2xpbmsnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gbGluayh1cmwpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICdocmVmJywgdXJsKTtcbiAgfTtcbn0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjQgU3RyaW5nLnJhdyhjYWxsU2l0ZSwgLi4uc3Vic3RpdHV0aW9ucylcbiAgcmF3OiBmdW5jdGlvbiByYXcoY2FsbFNpdGUpIHtcbiAgICB2YXIgdHBsID0gdG9JT2JqZWN0KGNhbGxTaXRlLnJhdyk7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHRwbC5sZW5ndGgpO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGxlbiA+IGkpIHtcbiAgICAgIHJlcy5wdXNoKFN0cmluZyh0cGxbaSsrXSkpO1xuICAgICAgaWYgKGkgPCBhTGVuKSByZXMucHVzaChTdHJpbmcoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4xMyBTdHJpbmcucHJvdG90eXBlLnJlcGVhdChjb3VudClcbiAgcmVwZWF0OiByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jylcbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gQi4yLjMuMTEgU3RyaW5nLnByb3RvdHlwZS5zbWFsbCgpXG5cbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3NtYWxsJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNtYWxsKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzbWFsbCcsICcnLCAnJyk7XG4gIH07XG59KTsiLCIvLyAyMS4xLjMuMTggU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyBbLCBwb3NpdGlvbiBdKVxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpO1xuXG52YXIgU1RBUlRTX1dJVEggPSAnc3RhcnRzV2l0aCc7XG52YXIgJHN0YXJ0c1dpdGggPSAnJ1tTVEFSVFNfV0lUSF07XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKFNUQVJUU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmdcbiAgLyogLCBwb3NpdGlvbiA9IDAgKi9cbiAgKSB7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgU1RBUlRTX1dJVEgpO1xuICAgIHZhciBpbmRleCA9IHRvTGVuZ3RoKE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0aGF0Lmxlbmd0aCkpO1xuICAgIHZhciBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJHN0YXJ0c1dpdGggPyAkc3RhcnRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgaW5kZXgpIDogdGhhdC5zbGljZShpbmRleCwgaW5kZXggKyBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIEIuMi4zLjEyIFN0cmluZy5wcm90b3R5cGUuc3RyaWtlKClcblxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3RyaWtlJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0cmlrZSgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3RyaWtlJywgJycsICcnKTtcbiAgfTtcbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gQi4yLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5zdWIoKVxuXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdWInLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc3ViKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdWInLCAnJywgJycpO1xuICB9O1xufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBCLjIuMy4xNCBTdHJpbmcucHJvdG90eXBlLnN1cCgpXG5cbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N1cCcsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdXAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N1cCcsICcnLCAnJyk7XG4gIH07XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIDIxLjEuMy4yNSBTdHJpbmcucHJvdG90eXBlLnRyaW0oKVxuXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltJywgZnVuY3Rpb24gKCR0cmltKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltKCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAzKTtcbiAgfTtcbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcblxudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcblxudmFyIE1FVEEgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZO1xuXG52YXIgJGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpO1xuXG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xuXG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5cbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcblxudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcblxudmFyIHdrc0RlZmluZSA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKTtcblxudmFyIGVudW1LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJyk7XG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuXG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcblxudmFyIGdPUE5FeHQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKTtcblxudmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcblxudmFyICRHT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcblxudmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG52YXIgZ09QRCA9ICRHT1BELmY7XG52YXIgZFAgPSAkRFAuZjtcbnZhciBnT1BOID0gZ09QTkV4dC5mO1xudmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyICRKU09OID0gZ2xvYmFsLkpTT047XG5cbnZhciBfc3RyaW5naWZ5ID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5O1xuXG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJyAmJiAhISRHT1BTLmY7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0OyAvLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcblxudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7IC8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xuXG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkUCh0aGlzLCAnYScsIHtcbiAgICAgICAgdmFsdWU6IDdcbiAgICAgIH0pLmE7XG4gICAgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkge1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZiAocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bykgZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG5cbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpIHtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90bykgJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcblxuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtcbiAgICAgICAgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9XG5cbiAgcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcblxuICB3aGlsZSAobCA+IGkpICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuXG4gIHJldHVybiBpdDtcbn07XG5cbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgaXQgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYgKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkgRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87XG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG5cbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKSByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07IC8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuXG5cbmlmICghVVNFX05BVElWRSkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG5cbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvKSAkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcblxuICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgc2V0OiAkc2V0XG4gICAgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcblxuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gICRHT1BTLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1xuICBTeW1ib2w6ICRTeW1ib2xcbn0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbidoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcycuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspIHdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpID8gU3ltYm9sUmVnaXN0cnlba2V5XSA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcblxuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgc2V0dGVyID0gdHJ1ZTtcbiAgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7XG4gICAgc2V0dGVyID0gZmFsc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7IC8vIENocm9tZSAzOCBhbmQgMzkgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIGZhaWxzIG9uIHByaW1pdGl2ZXNcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM0NDNcblxudmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICAkR09QUy5mKDEpO1xufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIEZBSUxTX09OX1BSSU1JVElWRVMsICdPYmplY3QnLCB7XG4gIGdldE93blByb3BlcnR5U3ltYm9sczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gICAgcmV0dXJuICRHT1BTLmYodG9PYmplY3QoaXQpKTtcbiAgfVxufSk7IC8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgUyA9ICRTeW1ib2woKTsgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG5cbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHtcbiAgICBhOiBTXG4gIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG5cbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG5cbiAgICAkcmVwbGFjZXIgPSByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYgKCFpc09iamVjdChyZXBsYWNlcikgJiYgaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuXG4gICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTsgLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTsgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7IC8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cblxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTsgLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cblxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcblxudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIEFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuQXJyYXlCdWZmZXI7XG5cbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbnZhciAkQXJyYXlCdWZmZXIgPSBidWZmZXIuQXJyYXlCdWZmZXI7XG52YXIgJERhdGFWaWV3ID0gYnVmZmVyLkRhdGFWaWV3O1xudmFyICRpc1ZpZXcgPSAkdHlwZWQuQUJWICYmIEFycmF5QnVmZmVyLmlzVmlldztcbnZhciAkc2xpY2UgPSAkQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlO1xudmFyIFZJRVcgPSAkdHlwZWQuVklFVztcbnZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoQXJyYXlCdWZmZXIgIT09ICRBcnJheUJ1ZmZlciksIHtcbiAgQXJyYXlCdWZmZXI6ICRBcnJheUJ1ZmZlclxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEkdHlwZWQuQ09OU1RSLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS4zLjEgQXJyYXlCdWZmZXIuaXNWaWV3KGFyZylcbiAgaXNWaWV3OiBmdW5jdGlvbiBpc1ZpZXcoaXQpIHtcbiAgICByZXR1cm4gJGlzVmlldyAmJiAkaXNWaWV3KGl0KSB8fCBpc09iamVjdChpdCkgJiYgVklFVyBpbiBpdDtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuVSArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIW5ldyAkQXJyYXlCdWZmZXIoMikuc2xpY2UoMSwgdW5kZWZpbmVkKS5ieXRlTGVuZ3RoO1xufSksIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjQuMyBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2Uoc3RhcnQsIGVuZClcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoJHNsaWNlICE9PSB1bmRlZmluZWQgJiYgZW5kID09PSB1bmRlZmluZWQpIHJldHVybiAkc2xpY2UuY2FsbChhbk9iamVjdCh0aGlzKSwgc3RhcnQpOyAvLyBGRiBmaXhcblxuICAgIHZhciBsZW4gPSBhbk9iamVjdCh0aGlzKS5ieXRlTGVuZ3RoO1xuICAgIHZhciBmaXJzdCA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuKTtcbiAgICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kLCBsZW4pO1xuICAgIHZhciByZXN1bHQgPSBuZXcgKHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkQXJyYXlCdWZmZXIpKSh0b0xlbmd0aChmaW4gLSBmaXJzdCkpO1xuICAgIHZhciB2aWV3UyA9IG5ldyAkRGF0YVZpZXcodGhpcyk7XG4gICAgdmFyIHZpZXdUID0gbmV3ICREYXRhVmlldyhyZXN1bHQpO1xuICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICB3aGlsZSAoZmlyc3QgPCBmaW4pIHtcbiAgICAgIHZpZXdULnNldFVpbnQ4KGluZGV4KyssIHZpZXdTLmdldFVpbnQ4KGZpcnN0KyspKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShBUlJBWV9CVUZGRVIpOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3R5cGVkJykuQUJWLCB7XG4gIERhdGFWaWV3OiByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKS5EYXRhVmlld1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnRmxvYXQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0NjQnLCA4LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQ2NEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQxNicsIDIsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDE2JywgMiwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4Q2xhbXBlZEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59LCB0cnVlKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyIGVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG5cbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5cbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xuXG52YXIgTkFUSVZFX1dFQUtfTUFQID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xuXG52YXIgSVNfSUUxMSA9ICFnbG9iYWwuQWN0aXZlWE9iamVjdCAmJiAnQWN0aXZlWE9iamVjdCcgaW4gZ2xvYmFsO1xudmFyIFdFQUtfTUFQID0gJ1dlYWtNYXAnO1xudmFyIGdldFdlYWsgPSBtZXRhLmdldFdlYWs7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gd2Vhay51ZnN0b3JlO1xudmFyIEludGVybmFsTWFwO1xuXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59O1xuXG52YXIgbWV0aG9kcyA9IHtcbiAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIFdFQUtfTUFQKSkuZ2V0KGtleSk7XG4gICAgICByZXR1cm4gZGF0YSA/IGRhdGFbdGhpcy5faV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuICAvLyAyMy4zLjMuNSBXZWFrTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB3ZWFrLmRlZih2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCksIGtleSwgdmFsdWUpO1xuICB9XG59OyAvLyAyMy4zIFdlYWtNYXAgT2JqZWN0c1xuXG52YXIgJFdlYWtNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShXRUFLX01BUCwgd3JhcHBlciwgbWV0aG9kcywgd2VhaywgdHJ1ZSwgdHJ1ZSk7IC8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcblxuXG5pZiAoTkFUSVZFX1dFQUtfTUFQICYmIElTX0lFMTEpIHtcbiAgSW50ZXJuYWxNYXAgPSB3ZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIFdFQUtfTUFQKTtcbiAgYXNzaWduKEludGVybmFsTWFwLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gIG1ldGEuTkVFRCA9IHRydWU7XG4gIGVhY2goWydkZWxldGUnLCAnaGFzJywgJ2dldCcsICdzZXQnXSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBwcm90byA9ICRXZWFrTWFwLnByb3RvdHlwZTtcbiAgICB2YXIgbWV0aG9kID0gcHJvdG9ba2V5XTtcbiAgICByZWRlZmluZShwcm90bywga2V5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgLy8gc3RvcmUgZnJvemVuIG9iamVjdHMgb24gaW50ZXJuYWwgd2Vha21hcCBzaGltXG4gICAgICBpZiAoaXNPYmplY3QoYSkgJiYgIWlzRXh0ZW5zaWJsZShhKSkge1xuICAgICAgICBpZiAoIXRoaXMuX2YpIHRoaXMuX2YgPSBuZXcgSW50ZXJuYWxNYXAoKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZltrZXldKGEsIGIpO1xuXG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0OyAvLyBzdG9yZSBhbGwgdGhlIHJlc3Qgb24gbmF0aXZlIHdlYWttYXBcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xuICAgIH0pO1xuICB9KTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG5cbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcblxudmFyIFdFQUtfU0VUID0gJ1dlYWtTZXQnOyAvLyAyMy40IFdlYWtTZXQgT2JqZWN0c1xuXG5yZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoV0VBS19TRVQsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtTZXQoKSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59LCB7XG4gIC8vIDIzLjQuMy4xIFdlYWtTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICByZXR1cm4gd2Vhay5kZWYodmFsaWRhdGUodGhpcywgV0VBS19TRVQpLCB2YWx1ZSwgdHJ1ZSk7XG4gIH1cbn0sIHdlYWssIGZhbHNlLCB0cnVlKTsiLCIndXNlIHN0cmljdCc7IC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtZmxhdE1hcC8jc2VjLUFycmF5LnByb3RvdHlwZS5mbGF0TWFwXG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBmbGF0dGVuSW50b0FycmF5ID0gcmVxdWlyZSgnLi9fZmxhdHRlbi1pbnRvLWFycmF5Jyk7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGZsYXRNYXA6IGZ1bmN0aW9uIGZsYXRNYXAoY2FsbGJhY2tmblxuICAvKiAsIHRoaXNBcmcgKi9cbiAgKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgc291cmNlTGVuLCBBO1xuICAgIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgICBzb3VyY2VMZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcbiAgICBmbGF0dGVuSW50b0FycmF5KEEsIE8sIE8sIHNvdXJjZUxlbiwgMCwgMSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmbGF0TWFwJyk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLWZsYXRNYXAvI3NlYy1BcnJheS5wcm90b3R5cGUuZmxhdHRlblxuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgZmxhdHRlbkludG9BcnJheSA9IHJlcXVpcmUoJy4vX2ZsYXR0ZW4taW50by1hcnJheScpO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG5cbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBmbGF0dGVuOiBmdW5jdGlvbiBmbGF0dGVuKClcbiAgLyogZGVwdGhBcmcgPSAxICovXG4gIHtcbiAgICB2YXIgZGVwdGhBcmcgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgc291cmNlTGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xuICAgIGZsYXR0ZW5JbnRvQXJyYXkoQSwgTywgTywgc291cmNlTGVuLCAwLCBkZXB0aEFyZyA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aEFyZykpO1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2ZsYXR0ZW4nKTsiLCIndXNlIHN0cmljdCc7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L0FycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJGluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKGVsXG4gIC8qICwgZnJvbUluZGV4ID0gMCAqL1xuICApIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnaW5jbHVkZXMnKTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vcndhbGRyb24vdGMzOS1ub3Rlcy9ibG9iL21hc3Rlci9lczYvMjAxNC0wOS9zZXB0LTI1Lm1kIzUxMC1nbG9iYWxhc2FwLWZvci1lbnF1ZXVpbmctYS1taWNyb3Rhc2tcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpO1xuXG52YXIgcHJvY2VzcyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnByb2Nlc3M7XG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG4kZXhwb3J0KCRleHBvcnQuRywge1xuICBhc2FwOiBmdW5jdGlvbiBhc2FwKGZuKSB7XG4gICAgdmFyIGRvbWFpbiA9IGlzTm9kZSAmJiBwcm9jZXNzLmRvbWFpbjtcbiAgICBtaWNyb3Rhc2soZG9tYWluID8gZG9tYWluLmJpbmQoZm4pIDogZm4pO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL3Byb3Bvc2FsLWlzLWVycm9yXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRXJyb3InLCB7XG4gIGlzRXJyb3I6IGZ1bmN0aW9uIGlzRXJyb3IoaXQpIHtcbiAgICByZXR1cm4gY29mKGl0KSA9PT0gJ0Vycm9yJztcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZ2xvYmFsXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuRywge1xuICBnbG9iYWw6IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG59KTsiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1tYXAuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdNYXAnKTsiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1tYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ01hcCcpOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnTWFwJywge1xuICB0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKVxufSk7IiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjbGFtcDogZnVuY3Rpb24gY2xhbXAoeCwgbG93ZXIsIHVwcGVyKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKHVwcGVyLCBNYXRoLm1heChsb3dlciwgeCkpO1xuICB9XG59KTsiLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIERFR19QRVJfUkFEOiBNYXRoLlBJIC8gMTgwXG59KTsiLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgUkFEX1BFUl9ERUcgPSAxODAgLyBNYXRoLlBJO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBkZWdyZWVzOiBmdW5jdGlvbiBkZWdyZWVzKHJhZGlhbnMpIHtcbiAgICByZXR1cm4gcmFkaWFucyAqIFJBRF9QRVJfREVHO1xuICB9XG59KTsiLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgc2NhbGUgPSByZXF1aXJlKCcuL19tYXRoLXNjYWxlJyk7XG5cbnZhciBmcm91bmQgPSByZXF1aXJlKCcuL19tYXRoLWZyb3VuZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGZzY2FsZTogZnVuY3Rpb24gZnNjYWxlKHgsIGluTG93LCBpbkhpZ2gsIG91dExvdywgb3V0SGlnaCkge1xuICAgIHJldHVybiBmcm91bmQoc2NhbGUoeCwgaW5Mb3csIGluSGlnaCwgb3V0TG93LCBvdXRIaWdoKSk7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlhZGRoOiBmdW5jdGlvbiBpYWRkaCh4MCwgeDEsIHkwLCB5MSkge1xuICAgIHZhciAkeDAgPSB4MCA+Pj4gMDtcbiAgICB2YXIgJHgxID0geDEgPj4+IDA7XG4gICAgdmFyICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgKyAoeTEgPj4+IDApICsgKCgkeDAgJiAkeTAgfCAoJHgwIHwgJHkwKSAmIH4oJHgwICsgJHkwID4+PiAwKSkgPj4+IDMxKSB8IDA7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGltdWxoOiBmdW5jdGlvbiBpbXVsaCh1LCB2KSB7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZjtcbiAgICB2YXIgJHUgPSArdTtcbiAgICB2YXIgJHYgPSArdjtcbiAgICB2YXIgdTAgPSAkdSAmIFVJTlQxNjtcbiAgICB2YXIgdjAgPSAkdiAmIFVJTlQxNjtcbiAgICB2YXIgdTEgPSAkdSA+PiAxNjtcbiAgICB2YXIgdjEgPSAkdiA+PiAxNjtcbiAgICB2YXIgdCA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+PiAxNikgKyAoKHUwICogdjEgPj4+IDApICsgKHQgJiBVSU5UMTYpID4+IDE2KTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaXN1Ymg6IGZ1bmN0aW9uIGlzdWJoKHgwLCB4MSwgeTAsIHkxKSB7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwO1xuICAgIHZhciAkeDEgPSB4MSA+Pj4gMDtcbiAgICB2YXIgJHkwID0geTAgPj4+IDA7XG4gICAgcmV0dXJuICR4MSAtICh5MSA+Pj4gMCkgLSAoKH4keDAgJiAkeTAgfCB+KCR4MCBeICR5MCkgJiAkeDAgLSAkeTAgPj4+IDApID4+PiAzMSkgfCAwO1xuICB9XG59KTsiLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIFJBRF9QRVJfREVHOiAxODAgLyBNYXRoLlBJXG59KTsiLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgREVHX1BFUl9SQUQgPSBNYXRoLlBJIC8gMTgwO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICByYWRpYW5zOiBmdW5jdGlvbiByYWRpYW5zKGRlZ3JlZXMpIHtcbiAgICByZXR1cm4gZGVncmVlcyAqIERFR19QRVJfUkFEO1xuICB9XG59KTsiLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHNjYWxlOiByZXF1aXJlKCcuL19tYXRoLXNjYWxlJylcbn0pOyIsIi8vIGh0dHA6Ly9qZmJhc3RpZW4uZ2l0aHViLmlvL3BhcGVycy9NYXRoLnNpZ25iaXQuaHRtbFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBzaWduYml0OiBmdW5jdGlvbiBzaWduYml0KHgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmV0dXJuICh4ID0gK3gpICE9IHggPyB4IDogeCA9PSAwID8gMSAvIHggPT0gSW5maW5pdHkgOiB4ID4gMDtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdW11bGg6IGZ1bmN0aW9uIHVtdWxoKHUsIHYpIHtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmO1xuICAgIHZhciAkdSA9ICt1O1xuICAgIHZhciAkdiA9ICt2O1xuICAgIHZhciB1MCA9ICR1ICYgVUlOVDE2O1xuICAgIHZhciB2MCA9ICR2ICYgVUlOVDE2O1xuICAgIHZhciB1MSA9ICR1ID4+PiAxNjtcbiAgICB2YXIgdjEgPSAkdiA+Pj4gMTY7XG4gICAgdmFyIHQgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4+IDE2KSArICgodTAgKiB2MSA+Pj4gMCkgKyAodCAmIFVJTlQxNikgPj4+IDE2KTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpOyAvLyBCLjIuMi4yIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpXG5cblxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fZGVmaW5lR2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKSB7XG4gICAgJGRlZmluZVByb3BlcnR5LmYodG9PYmplY3QodGhpcyksIFAsIHtcbiAgICAgIGdldDogYUZ1bmN0aW9uKGdldHRlciksXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTsgLy8gQi4yLjIuMyBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lU2V0dGVyX18oUCwgc2V0dGVyKVxuXG5cbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2RlZmluZVNldHRlcl9fOiBmdW5jdGlvbiBfX2RlZmluZVNldHRlcl9fKFAsIHNldHRlcikge1xuICAgICRkZWZpbmVQcm9wZXJ0eS5mKHRvT2JqZWN0KHRoaXMpLCBQLCB7XG4gICAgICBzZXQ6IGFGdW5jdGlvbihzZXR0ZXIpLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkZW50cmllcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcyhpdCkge1xuICAgIHJldHVybiAkZW50cmllcyhpdCk7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgb3duS2V5cyA9IHJlcXVpcmUoJy4vX293bi1rZXlzJyk7XG5cbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcblxudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gICAgdmFyIGdldERlc2MgPSBnT1BELmY7XG4gICAgdmFyIGtleXMgPSBvd25LZXlzKE8pO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleSwgZGVzYztcblxuICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IGkpIHtcbiAgICAgIGRlc2MgPSBnZXREZXNjKE8sIGtleSA9IGtleXNbaSsrXSk7XG4gICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGtleSwgZGVzYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjsgLy8gQi4yLjIuNCBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwR2V0dGVyX18oUClcblxuXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19sb29rdXBHZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBHZXR0ZXJfXyhQKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgSyA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICAgIHZhciBEO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKEQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgSykpIHJldHVybiBELmdldDtcbiAgICB9IHdoaWxlIChPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mOyAvLyBCLjIuMi41IE9iamVjdC5wcm90b3R5cGUuX19sb29rdXBTZXR0ZXJfXyhQKVxuXG5cbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cFNldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cFNldHRlcl9fKFApIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gICAgdmFyIEQ7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoRCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBLKSkgcmV0dXJuIEQuc2V0O1xuICAgIH0gd2hpbGUgKE8gPSBnZXRQcm90b3R5cGVPZihPKSk7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICR2YWx1ZXMgPSByZXF1aXJlKCcuL19vYmplY3QtdG8tYXJyYXknKShmYWxzZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcyhpdCkge1xuICAgIHJldHVybiAkdmFsdWVzKGl0KTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlXG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG5cbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpO1xuXG52YXIgT0JTRVJWQUJMRSA9IHJlcXVpcmUoJy4vX3drcycpKCdvYnNlcnZhYmxlJyk7XG5cbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG5cbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xuXG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcblxudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbnZhciBSRVRVUk4gPSBmb3JPZi5SRVRVUk47XG5cbnZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZuID09IG51bGwgPyB1bmRlZmluZWQgOiBhRnVuY3Rpb24oZm4pO1xufTtcblxudmFyIGNsZWFudXBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gIHZhciBjbGVhbnVwID0gc3Vic2NyaXB0aW9uLl9jO1xuXG4gIGlmIChjbGVhbnVwKSB7XG4gICAgc3Vic2NyaXB0aW9uLl9jID0gdW5kZWZpbmVkO1xuICAgIGNsZWFudXAoKTtcbiAgfVxufTtcblxudmFyIHN1YnNjcmlwdGlvbkNsb3NlZCA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgcmV0dXJuIHN1YnNjcmlwdGlvbi5fbyA9PT0gdW5kZWZpbmVkO1xufTtcblxudmFyIGNsb3NlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICBpZiAoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKSB7XG4gICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgfVxufTtcblxudmFyIFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc3Vic2NyaWJlcikge1xuICBhbk9iamVjdChvYnNlcnZlcik7XG4gIHRoaXMuX2MgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX28gPSBvYnNlcnZlcjtcbiAgb2JzZXJ2ZXIgPSBuZXcgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIodGhpcyk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgY2xlYW51cCA9IHN1YnNjcmliZXIob2JzZXJ2ZXIpO1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSBjbGVhbnVwO1xuXG4gICAgaWYgKGNsZWFudXAgIT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBjbGVhbnVwLnVuc3Vic2NyaWJlID09PSAnZnVuY3Rpb24nKSBjbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIH07ZWxzZSBhRnVuY3Rpb24oY2xlYW51cCk7XG4gICAgICB0aGlzLl9jID0gY2xlYW51cDtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3Vic2NyaXB0aW9uQ2xvc2VkKHRoaXMpKSBjbGVhbnVwU3Vic2NyaXB0aW9uKHRoaXMpO1xufTtcblxuU3Vic2NyaXB0aW9uLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKHt9LCB7XG4gIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICBjbG9zZVN1YnNjcmlwdGlvbih0aGlzKTtcbiAgfVxufSk7XG5cbnZhciBTdWJzY3JpcHRpb25PYnNlcnZlciA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgdGhpcy5fcyA9IHN1YnNjcmlwdGlvbjtcbn07XG5cblN1YnNjcmlwdGlvbk9ic2VydmVyLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKHt9LCB7XG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQodmFsdWUpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcblxuICAgIGlmICghc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHtcbiAgICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZiAoc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHRocm93IHZhbHVlO1xuICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIuZXJyb3IpO1xuICAgICAgaWYgKCFtKSB0aHJvdyB2YWx1ZTtcbiAgICAgIHZhbHVlID0gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUodmFsdWUpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcblxuICAgIGlmICghc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHtcbiAgICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIuY29tcGxldGUpO1xuICAgICAgICB2YWx1ZSA9IG0gPyBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59KTtcblxudmFyICRPYnNlcnZhYmxlID0gZnVuY3Rpb24gT2JzZXJ2YWJsZShzdWJzY3JpYmVyKSB7XG4gIGFuSW5zdGFuY2UodGhpcywgJE9ic2VydmFibGUsICdPYnNlcnZhYmxlJywgJ19mJykuX2YgPSBhRnVuY3Rpb24oc3Vic2NyaWJlcik7XG59O1xuXG5yZWRlZmluZUFsbCgkT2JzZXJ2YWJsZS5wcm90b3R5cGUsIHtcbiAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbihvYnNlcnZlciwgdGhpcy5fZik7XG4gIH0sXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyAoY29yZS5Qcm9taXNlIHx8IGdsb2JhbC5Qcm9taXNlKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBhRnVuY3Rpb24oZm4pO1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoYXQuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbih2YWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogcmVqZWN0LFxuICAgICAgICBjb21wbGV0ZTogcmVzb2x2ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xucmVkZWZpbmVBbGwoJE9ic2VydmFibGUsIHtcbiAgZnJvbTogZnVuY3Rpb24gZnJvbSh4KSB7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiAkT2JzZXJ2YWJsZTtcbiAgICB2YXIgbWV0aG9kID0gZ2V0TWV0aG9kKGFuT2JqZWN0KHgpW09CU0VSVkFCTEVdKTtcblxuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gYW5PYmplY3QobWV0aG9kLmNhbGwoeCkpO1xuICAgICAgcmV0dXJuIG9ic2VydmFibGUuY29uc3RydWN0b3IgPT09IEMgPyBvYnNlcnZhYmxlIDogbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmb3JPZih4LCBmYWxzZSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXQpO1xuICAgICAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuIFJFVFVSTjtcbiAgICAgICAgICAgIH0pID09PSBSRVRVUk4pIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkgdGhyb3cgZTtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICB9O1xuICAgIH0pO1xuICB9LFxuICBvZjogZnVuY3Rpb24gb2YoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVtcyA9IG5ldyBBcnJheShsKTsgaSA8IGw7KSBpdGVtc1tpXSA9IGFyZ3VtZW50c1tpKytdO1xuXG4gICAgcmV0dXJuIG5ldyAodHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGUpKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXRlbXNbal0pO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufSk7XG5oaWRlKCRPYnNlcnZhYmxlLnByb3RvdHlwZSwgT0JTRVJWQUJMRSwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0pO1xuJGV4cG9ydCgkZXhwb3J0LkcsIHtcbiAgT2JzZXJ2YWJsZTogJE9ic2VydmFibGVcbn0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdPYnNlcnZhYmxlJyk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS1maW5hbGx5XG4ndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1Byb21pc2UnLCB7XG4gICdmaW5hbGx5JzogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuICAgIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSk7XG4gICAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2Ygb25GaW5hbGx5ID09ICdmdW5jdGlvbic7XG4gICAgcmV0dXJuIHRoaXMudGhlbihpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfSk7XG4gICAgfSA6IG9uRmluYWxseSwgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSk7XG4gICAgfSA6IG9uRmluYWxseSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS10cnlcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdQcm9taXNlJywge1xuICAndHJ5JzogZnVuY3Rpb24gKGNhbGxiYWNrZm4pIHtcbiAgICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKHRoaXMpO1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGNhbGxiYWNrZm4pO1xuICAgIChyZXN1bHQuZSA/IHByb21pc2VDYXBhYmlsaXR5LnJlamVjdCA6IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmUpKHJlc3VsdC52KTtcbiAgICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7IiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG52YXIgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IG1ldGFkYXRhLnNldDtcbm1ldGFkYXRhLmV4cCh7XG4gIGRlZmluZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWZpbmVNZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCB0YXJnZXRLZXkpIHtcbiAgICBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCBhbk9iamVjdCh0YXJnZXQpLCB0b01ldGFLZXkodGFyZ2V0S2V5KSk7XG4gIH1cbn0pOyIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xudmFyIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAgPSBtZXRhZGF0YS5tYXA7XG52YXIgc3RvcmUgPSBtZXRhZGF0YS5zdG9yZTtcbm1ldGFkYXRhLmV4cCh7XG4gIGRlbGV0ZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWxldGVNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0XG4gIC8qICwgdGFyZ2V0S2V5ICovXG4gICkge1xuICAgIHZhciB0YXJnZXRLZXkgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pO1xuICAgIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoYW5PYmplY3QodGFyZ2V0KSwgdGFyZ2V0S2V5LCBmYWxzZSk7XG4gICAgaWYgKG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgfHwgIW1ldGFkYXRhTWFwWydkZWxldGUnXShtZXRhZGF0YUtleSkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAobWV0YWRhdGFNYXAuc2l6ZSkgcmV0dXJuIHRydWU7XG4gICAgdmFyIHRhcmdldE1ldGFkYXRhID0gc3RvcmUuZ2V0KHRhcmdldCk7XG4gICAgdGFyZ2V0TWV0YWRhdGFbJ2RlbGV0ZSddKHRhcmdldEtleSk7XG4gICAgcmV0dXJuICEhdGFyZ2V0TWV0YWRhdGEuc2l6ZSB8fCBzdG9yZVsnZGVsZXRlJ10odGFyZ2V0KTtcbiAgfVxufSk7IiwidmFyIFNldCA9IHJlcXVpcmUoJy4vZXM2LnNldCcpO1xuXG52YXIgZnJvbSA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcblxudmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5cztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeU1ldGFkYXRhS2V5cyA9IGZ1bmN0aW9uIChPLCBQKSB7XG4gIHZhciBvS2V5cyA9IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIGlmIChwYXJlbnQgPT09IG51bGwpIHJldHVybiBvS2V5cztcbiAgdmFyIHBLZXlzID0gb3JkaW5hcnlNZXRhZGF0YUtleXMocGFyZW50LCBQKTtcbiAgcmV0dXJuIHBLZXlzLmxlbmd0aCA/IG9LZXlzLmxlbmd0aCA/IGZyb20obmV3IFNldChvS2V5cy5jb25jYXQocEtleXMpKSkgOiBwS2V5cyA6IG9LZXlzO1xufTtcblxubWV0YWRhdGEuZXhwKHtcbiAgZ2V0TWV0YWRhdGFLZXlzOiBmdW5jdGlvbiBnZXRNZXRhZGF0YUtleXModGFyZ2V0XG4gIC8qICwgdGFyZ2V0S2V5ICovXG4gICkge1xuICAgIHJldHVybiBvcmRpbmFyeU1ldGFkYXRhS2V5cyhhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMV0pKTtcbiAgfVxufSk7IiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXM7XG52YXIgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmdldDtcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUdldE1ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gIHZhciBoYXNPd24gPSBvcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgaWYgKGhhc093bikgcmV0dXJuIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBvcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApIDogdW5kZWZpbmVkO1xufTtcblxubWV0YWRhdGEuZXhwKHtcbiAgZ2V0TWV0YWRhdGE6IGZ1bmN0aW9uIGdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXRcbiAgLyogLCB0YXJnZXRLZXkgKi9cbiAgKSB7XG4gICAgcmV0dXJuIG9yZGluYXJ5R2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xuICB9XG59KTsiLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5cztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5tZXRhZGF0YS5leHAoe1xuICBnZXRPd25NZXRhZGF0YUtleXM6IGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhS2V5cyh0YXJnZXRcbiAgLyogLCB0YXJnZXRLZXkgKi9cbiAgKSB7XG4gICAgcmV0dXJuIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1sxXSkpO1xuICB9XG59KTsiLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXQ7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xubWV0YWRhdGEuZXhwKHtcbiAgZ2V0T3duTWV0YWRhdGE6IGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXRcbiAgLyogLCB0YXJnZXRLZXkgKi9cbiAgKSB7XG4gICAgcmV0dXJuIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xuICB9XG59KTsiLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhcztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUhhc01ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gIHZhciBoYXNPd24gPSBvcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgaWYgKGhhc093bikgcmV0dXJuIHRydWU7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IG9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCkgOiBmYWxzZTtcbn07XG5cbm1ldGFkYXRhLmV4cCh7XG4gIGhhc01ldGFkYXRhOiBmdW5jdGlvbiBoYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0XG4gIC8qICwgdGFyZ2V0S2V5ICovXG4gICkge1xuICAgIHJldHVybiBvcmRpbmFyeUhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbiAgfVxufSk7IiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcbm1ldGFkYXRhLmV4cCh7XG4gIGhhc093bk1ldGFkYXRhOiBmdW5jdGlvbiBoYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0XG4gIC8qICwgdGFyZ2V0S2V5ICovXG4gICkge1xuICAgIHJldHVybiBvcmRpbmFyeUhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbiAgfVxufSk7IiwidmFyICRtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG52YXIgdG9NZXRhS2V5ID0gJG1ldGFkYXRhLmtleTtcbnZhciBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gJG1ldGFkYXRhLnNldDtcbiRtZXRhZGF0YS5leHAoe1xuICBtZXRhZGF0YTogZnVuY3Rpb24gbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVjb3JhdG9yKHRhcmdldCwgdGFyZ2V0S2V5KSB7XG4gICAgICBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCAodGFyZ2V0S2V5ICE9PSB1bmRlZmluZWQgPyBhbk9iamVjdCA6IGFGdW5jdGlvbikodGFyZ2V0KSwgdG9NZXRhS2V5KHRhcmdldEtleSkpO1xuICAgIH07XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXNldC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1NldCcpOyIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXNldC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnU2V0Jyk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7XG4gIHRvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ1NldCcpXG59KTsiLCIndXNlIHN0cmljdCc7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgYXQ6IGZ1bmN0aW9uIGF0KHBvcykge1xuICAgIHJldHVybiAkYXQodGhpcywgcG9zKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL1N0cmluZy5wcm90b3R5cGUubWF0Y2hBbGwvXG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG5cbnZhciBnZXRGbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG5cbnZhciBSZWdFeHBQcm90byA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbnZhciAkUmVnRXhwU3RyaW5nSXRlcmF0b3IgPSBmdW5jdGlvbiAocmVnZXhwLCBzdHJpbmcpIHtcbiAgdGhpcy5fciA9IHJlZ2V4cDtcbiAgdGhpcy5fcyA9IHN0cmluZztcbn07XG5cbnJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJykoJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yLCAnUmVnRXhwIFN0cmluZycsIGZ1bmN0aW9uIG5leHQoKSB7XG4gIHZhciBtYXRjaCA9IHRoaXMuX3IuZXhlYyh0aGlzLl9zKTtcblxuICByZXR1cm4ge1xuICAgIHZhbHVlOiBtYXRjaCxcbiAgICBkb25lOiBtYXRjaCA9PT0gbnVsbFxuICB9O1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBtYXRjaEFsbDogZnVuY3Rpb24gbWF0Y2hBbGwocmVnZXhwKSB7XG4gICAgZGVmaW5lZCh0aGlzKTtcbiAgICBpZiAoIWlzUmVnRXhwKHJlZ2V4cCkpIHRocm93IFR5cGVFcnJvcihyZWdleHAgKyAnIGlzIG5vdCBhIHJlZ2V4cCEnKTtcbiAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcbiAgICB2YXIgZmxhZ3MgPSAnZmxhZ3MnIGluIFJlZ0V4cFByb3RvID8gU3RyaW5nKHJlZ2V4cC5mbGFncykgOiBnZXRGbGFncy5jYWxsKHJlZ2V4cCk7XG4gICAgdmFyIHJ4ID0gbmV3IFJlZ0V4cChyZWdleHAuc291cmNlLCB+ZmxhZ3MuaW5kZXhPZignZycpID8gZmxhZ3MgOiAnZycgKyBmbGFncyk7XG4gICAgcngubGFzdEluZGV4ID0gdG9MZW5ndGgocmVnZXhwLmxhc3RJbmRleCk7XG4gICAgcmV0dXJuIG5ldyAkUmVnRXhwU3RyaW5nSXRlcmF0b3IocngsIFMpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkcGFkID0gcmVxdWlyZSgnLi9fc3RyaW5nLXBhZCcpO1xuXG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi9fdXNlci1hZ2VudCcpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMjgwXG5cblxudmFyIFdFQktJVF9CVUcgPSAvVmVyc2lvblxcLzEwXFwuXFxkKyhcXC5cXGQrKT8oIE1vYmlsZVxcL1xcdyspPyBTYWZhcmlcXC8vLnRlc3QodXNlckFnZW50KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogV0VCS0lUX0JVRywgJ1N0cmluZycsIHtcbiAgcGFkRW5kOiBmdW5jdGlvbiBwYWRFbmQobWF4TGVuZ3RoXG4gIC8qICwgZmlsbFN0cmluZyA9ICcgJyAqL1xuICApIHtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBmYWxzZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRwYWQgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG5cbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8yODBcblxuXG52YXIgV0VCS0lUX0JVRyA9IC9WZXJzaW9uXFwvMTBcXC5cXGQrKFxcLlxcZCspPyggTW9iaWxlXFwvXFx3Kyk/IFNhZmFyaVxcLy8udGVzdCh1c2VyQWdlbnQpO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBXRUJLSVRfQlVHLCAnU3RyaW5nJywge1xuICBwYWRTdGFydDogZnVuY3Rpb24gcGFkU3RhcnQobWF4TGVuZ3RoXG4gIC8qICwgZmlsbFN0cmluZyA9ICcgJyAqL1xuICApIHtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0cnVlKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBodHRwczovL2dpdGh1Yi5jb20vc2VibWFya2JhZ2UvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5cbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW1MZWZ0JywgZnVuY3Rpb24gKCR0cmltKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltTGVmdCgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMSk7XG4gIH07XG59LCAndHJpbVN0YXJ0Jyk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBodHRwczovL2dpdGh1Yi5jb20vc2VibWFya2JhZ2UvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5cbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW1SaWdodCcsIGZ1bmN0aW9uICgkdHJpbSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbVJpZ2h0KCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAyKTtcbiAgfTtcbn0sICd0cmltRW5kJyk7IiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7IiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZ2xvYmFsXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N5c3RlbScsIHtcbiAgZ2xvYmFsOiByZXF1aXJlKCcuL19nbG9iYWwnKVxufSk7IiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha21hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1dlYWtNYXAnKTsiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrbWFwLm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdXZWFrTWFwJyk7IiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha3NldC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1dlYWtTZXQnKTsiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrc2V0Lm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdXZWFrU2V0Jyk7IiwidmFyICRpdGVyYXRvcnMgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xuXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5cbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcblxudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG52YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheTtcbnZhciBET01JdGVyYWJsZXMgPSB7XG4gIENTU1J1bGVMaXN0OiB0cnVlLFxuICAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogZmFsc2UsXG4gIENTU1ZhbHVlTGlzdDogZmFsc2UsXG4gIENsaWVudFJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NUmVjdExpc3Q6IGZhbHNlLFxuICBET01TdHJpbmdMaXN0OiBmYWxzZSxcbiAgRE9NVG9rZW5MaXN0OiB0cnVlLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogZmFsc2UsXG4gIEZpbGVMaXN0OiBmYWxzZSxcbiAgSFRNTEFsbENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxGb3JtRWxlbWVudDogZmFsc2UsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiBmYWxzZSxcbiAgTWVkaWFMaXN0OiB0cnVlLFxuICAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgTWltZVR5cGVBcnJheTogZmFsc2UsXG4gIE5hbWVkTm9kZU1hcDogZmFsc2UsXG4gIE5vZGVMaXN0OiB0cnVlLFxuICBQYWludFJlcXVlc3RMaXN0OiBmYWxzZSxcbiAgUGx1Z2luOiBmYWxzZSxcbiAgUGx1Z2luQXJyYXk6IGZhbHNlLFxuICBTVkdMZW5ndGhMaXN0OiBmYWxzZSxcbiAgU1ZHTnVtYmVyTGlzdDogZmFsc2UsXG4gIFNWR1BhdGhTZWdMaXN0OiBmYWxzZSxcbiAgU1ZHUG9pbnRMaXN0OiBmYWxzZSxcbiAgU1ZHU3RyaW5nTGlzdDogZmFsc2UsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IGZhbHNlLFxuICBTb3VyY2VCdWZmZXJMaXN0OiBmYWxzZSxcbiAgU3R5bGVTaGVldExpc3Q6IHRydWUsXG4gIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBUZXh0VHJhY2tDdWVMaXN0OiBmYWxzZSxcbiAgVGV4dFRyYWNrTGlzdDogZmFsc2UsXG4gIFRvdWNoTGlzdDogZmFsc2Vcbn07XG5cbmZvciAodmFyIGNvbGxlY3Rpb25zID0gZ2V0S2V5cyhET01JdGVyYWJsZXMpLCBpID0gMDsgaSA8IGNvbGxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBOQU1FID0gY29sbGVjdGlvbnNbaV07XG4gIHZhciBleHBsaWNpdCA9IERPTUl0ZXJhYmxlc1tOQU1FXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIHZhciBrZXk7XG5cbiAgaWYgKHByb3RvKSB7XG4gICAgaWYgKCFwcm90b1tJVEVSQVRPUl0pIGhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgaWYgKGV4cGxpY2l0KSBmb3IgKGtleSBpbiAkaXRlcmF0b3JzKSBpZiAoIXByb3RvW2tleV0pIHJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn0iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJHRhc2sgPSByZXF1aXJlKCcuL190YXNrJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CLCB7XG4gIHNldEltbWVkaWF0ZTogJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pOyIsIi8vIGllOS0gc2V0VGltZW91dCAmIHNldEludGVydmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4vX3VzZXItYWdlbnQnKTtcblxudmFyIHNsaWNlID0gW10uc2xpY2U7XG52YXIgTVNJRSA9IC9NU0lFIC5cXC4vLnRlc3QodXNlckFnZW50KTsgLy8gPC0gZGlydHkgaWU5LSBjaGVja1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChmbiwgdGltZVxuICAvKiAsIC4uLmFyZ3MgKi9cbiAgKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIHZhciBhcmdzID0gYm91bmRBcmdzID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogZmFsc2U7XG4gICAgcmV0dXJuIHNldChib3VuZEFyZ3MgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgICh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pKS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IDogZm4sIHRpbWUpO1xuICB9O1xufTtcblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIgKyAkZXhwb3J0LkYgKiBNU0lFLCB7XG4gIHNldFRpbWVvdXQ6IHdyYXAoZ2xvYmFsLnNldFRpbWVvdXQpLFxuICBzZXRJbnRlcnZhbDogd3JhcChnbG9iYWwuc2V0SW50ZXJ2YWwpXG59KTsiLCJyZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmtleXMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1leHRlbnNpYmxlJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucGFyc2UtaW50Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucGFyc2UtZmxvYXQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3InKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIudG8tZml4ZWQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24nKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXInKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXInKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hY29zaCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXNpbmgnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmF0YW5oJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jYnJ0Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jbHozMicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY29zaCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmltdWwnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cxcCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguc2lnbicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguc2luaCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudGFuaCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJhdycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy50cmltJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3InKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udGNvbG9yJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcubGluaycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN1cCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUubm93Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1qc29uJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lm9mJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuam9pbicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc29ydCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubWFwJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc29tZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5sYXN0LWluZGV4LW9mJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4nKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWxsJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXgnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3InKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuY29uc3RydWN0b3InKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuZXhlYycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2gnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2gnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wcm9taXNlJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWFwJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc2V0Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1tYXAnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLXNldCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXknKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXknKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQxNi1hcnJheScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDMyLWFycmF5Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0NjQtYXJyYXknKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5oYXMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXJyYXkuZmxhdC1tYXAnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hcnJheS5mbGF0dGVuJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLmF0Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tbGVmdCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXInKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0LnRvLWpzb24nKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXAub2YnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zZXQub2YnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LndlYWstc2V0Lm9mJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWFwLmZyb20nKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zZXQuZnJvbScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LndlYWstbWFwLmZyb20nKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy53ZWFrLXNldC5mcm9tJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuZ2xvYmFsJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmVycm9yLmlzLWVycm9yJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5jbGFtcCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguZGVnLXBlci1yYWQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmRlZ3JlZXMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmZzY2FsZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaWFkZGgnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlzdWJoJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pbXVsaCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGgucmFkLXBlci1kZWcnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnJhZGlhbnMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnNjYWxlJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC51bXVsaCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguc2lnbmJpdCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnByb21pc2UudHJ5Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5kZWZpbmUtbWV0YWRhdGEnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtbWV0YWRhdGEnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXNhcCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9ic2VydmFibGUnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi50aW1lcnMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi5pbW1lZGlhdGUnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21vZHVsZXMvX2NvcmUnKTsiLCIvKlxuIEhpZ2hjaGFydHMgSlMgdjguMC40ICgyMDIwLTAzLTEwKVxuXG4gKGMpIDIwMDktMjAxOCBUb3JzdGVpbiBIb25zaVxuXG4gTGljZW5zZTogd3d3LmhpZ2hjaGFydHMuY29tL2xpY2Vuc2VcbiovXG4oZnVuY3Rpb24gKGFhLCBTKSB7XG4gIFwib2JqZWN0XCIgPT09IHR5cGVvZiBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMgPyAoU1tcImRlZmF1bHRcIl0gPSBTLCBtb2R1bGUuZXhwb3J0cyA9IGFhLmRvY3VtZW50ID8gUyhhYSkgOiBTKSA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFwiaGlnaGNoYXJ0cy9oaWdoY2hhcnRzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUyhhYSk7XG4gIH0pIDogKGFhLkhpZ2hjaGFydHMgJiYgYWEuSGlnaGNoYXJ0cy5lcnJvcigxNiwgITApLCBhYS5IaWdoY2hhcnRzID0gUyhhYSkpO1xufSkoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHdpbmRvdyA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uIChhYSkge1xuICBmdW5jdGlvbiBTKGQsIGcsIFcsIHUpIHtcbiAgICBkLmhhc093blByb3BlcnR5KGcpIHx8IChkW2ddID0gdS5hcHBseShudWxsLCBXKSk7XG4gIH1cblxuICB2YXIgciA9IHt9O1xuICBTKHIsIFwicGFydHMvR2xvYmFscy5qc1wiLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBkID0gXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGFhID8gYWEgOiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2Ygd2luZG93ID8gd2luZG93IDoge30sXG4gICAgICAgIGcgPSBkLmRvY3VtZW50LFxuICAgICAgICBXID0gZC5uYXZpZ2F0b3IgJiYgZC5uYXZpZ2F0b3IudXNlckFnZW50IHx8IFwiXCIsXG4gICAgICAgIHUgPSBnICYmIGcuY3JlYXRlRWxlbWVudE5TICYmICEhZy5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKS5jcmVhdGVTVkdSZWN0LFxuICAgICAgICByID0gLyhlZGdlfG1zaWV8dHJpZGVudCkvaS50ZXN0KFcpICYmICFkLm9wZXJhLFxuICAgICAgICBNID0gLTEgIT09IFcuaW5kZXhPZihcIkZpcmVmb3hcIiksXG4gICAgICAgIEUgPSAtMSAhPT0gVy5pbmRleE9mKFwiQ2hyb21lXCIpLFxuICAgICAgICBBID0gTSAmJiA0ID4gcGFyc2VJbnQoVy5zcGxpdChcIkZpcmVmb3gvXCIpWzFdLCAxMCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb2R1Y3Q6IFwiSGlnaGNoYXJ0c1wiLFxuICAgICAgdmVyc2lvbjogXCI4LjAuNFwiLFxuICAgICAgZGVnMnJhZDogMiAqIE1hdGguUEkgLyAzNjAsXG4gICAgICBkb2M6IGcsXG4gICAgICBoYXNCaWRpQnVnOiBBLFxuICAgICAgaGFzVG91Y2g6ICEhZC5Ub3VjaEV2ZW50LFxuICAgICAgaXNNUzogcixcbiAgICAgIGlzV2ViS2l0OiAtMSAhPT0gVy5pbmRleE9mKFwiQXBwbGVXZWJLaXRcIiksXG4gICAgICBpc0ZpcmVmb3g6IE0sXG4gICAgICBpc0Nocm9tZTogRSxcbiAgICAgIGlzU2FmYXJpOiAhRSAmJiAtMSAhPT0gVy5pbmRleE9mKFwiU2FmYXJpXCIpLFxuICAgICAgaXNUb3VjaERldmljZTogLyhNb2JpbGV8QW5kcm9pZHxXaW5kb3dzIFBob25lKS8udGVzdChXKSxcbiAgICAgIFNWR19OUzogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgICAgY2hhcnRDb3VudDogMCxcbiAgICAgIHNlcmllc1R5cGVzOiB7fSxcbiAgICAgIHN5bWJvbFNpemVzOiB7fSxcbiAgICAgIHN2ZzogdSxcbiAgICAgIHdpbjogZCxcbiAgICAgIG1hcmdpbk5hbWVzOiBbXCJwbG90VG9wXCIsIFwibWFyZ2luUmlnaHRcIiwgXCJtYXJnaW5Cb3R0b21cIiwgXCJwbG90TGVmdFwiXSxcbiAgICAgIG5vb3A6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgY2hhcnRzOiBbXSxcbiAgICAgIGRhdGVGb3JtYXRzOiB7fVxuICAgIH07XG4gIH0pO1xuICBTKHIsIFwicGFydHMvVXRpbGl0aWVzLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXV0sIGZ1bmN0aW9uIChkKSB7XG4gICAgZnVuY3Rpb24gZygpIHtcbiAgICAgIHZhciBiLFxuICAgICAgICAgIGEgPSBhcmd1bWVudHMsXG4gICAgICAgICAgbSA9IHt9LFxuICAgICAgICAgIGYgPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2YgYiAmJiAoYiA9IHt9KTtcbiAgICAgICAgWShhLCBmdW5jdGlvbiAobSwgYykge1xuICAgICAgICAgICFoKG0sICEwKSB8fCBxKG0pIHx8IE4obSkgPyBiW2NdID0gYVtjXSA6IGJbY10gPSBmKGJbY10gfHwge30sIG0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9O1xuXG4gICAgICAhMCA9PT0gYVswXSAmJiAobSA9IGFbMV0sIGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhLCAyKSk7XG4gICAgICB2YXIgYyA9IGEubGVuZ3RoO1xuXG4gICAgICBmb3IgKGIgPSAwOyBiIDwgYzsgYisrKSBtID0gZihtLCBhW2JdKTtcblxuICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVyhiLCBhLCBtKSB7XG4gICAgICB2YXIgZjtcbiAgICAgIHQoYSkgPyBjKG0pID8gYi5zZXRBdHRyaWJ1dGUoYSwgbSkgOiBiICYmIGIuZ2V0QXR0cmlidXRlICYmICgoZiA9IGIuZ2V0QXR0cmlidXRlKGEpKSB8fCBcImNsYXNzXCIgIT09IGEgfHwgKGYgPSBiLmdldEF0dHJpYnV0ZShhICsgXCJOYW1lXCIpKSkgOiBZKGEsIGZ1bmN0aW9uIChhLCBtKSB7XG4gICAgICAgIGIuc2V0QXR0cmlidXRlKG0sIGEpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1KCkge1xuICAgICAgZm9yICh2YXIgYiA9IGFyZ3VtZW50cywgYSA9IGIubGVuZ3RoLCBtID0gMDsgbSA8IGE7IG0rKykge1xuICAgICAgICB2YXIgZiA9IGJbbV07XG4gICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZiAmJiBudWxsICE9PSBmKSByZXR1cm4gZjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByKGIsIGEpIHtcbiAgICAgIGlmICghYikgcmV0dXJuIGE7XG4gICAgICB2YXIgbSA9IGIuc3BsaXQoXCIuXCIpLnJldmVyc2UoKTtcbiAgICAgIGlmICgxID09PSBtLmxlbmd0aCkgcmV0dXJuIGFbYl07XG5cbiAgICAgIGZvciAoYiA9IG0ucG9wKCk7IFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBiICYmIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBhICYmIG51bGwgIT09IGE7KSBhID0gYVtiXSwgYiA9IG0ucG9wKCk7XG5cbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGQudGltZXJzID0gW107XG5cbiAgICB2YXIgTSA9IGQuY2hhcnRzLFxuICAgICAgICBFID0gZC5kb2MsXG4gICAgICAgIEEgPSBkLndpbixcbiAgICAgICAgRyA9IGQuZXJyb3IgPSBmdW5jdGlvbiAoYiwgYSwgbSwgZikge1xuICAgICAgdmFyIGMgPSBQKGIpLFxuICAgICAgICAgIHAgPSBjID8gXCJIaWdoY2hhcnRzIGVycm9yICNcIiArIGIgKyBcIjogd3d3LmhpZ2hjaGFydHMuY29tL2Vycm9ycy9cIiArIGIgKyBcIi9cIiA6IGIudG9TdHJpbmcoKSxcbiAgICAgICAgICBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoYSkgdGhyb3cgRXJyb3IocCk7XG4gICAgICAgIEEuY29uc29sZSAmJiBjb25zb2xlLmxvZyhwKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZikge1xuICAgICAgICB2YXIgeCA9IFwiXCI7XG4gICAgICAgIGMgJiYgKHAgKz0gXCI/XCIpO1xuICAgICAgICBkLm9iamVjdEVhY2goZiwgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICB4ICs9IFwiXFxuXCIgKyBhICsgXCI6IFwiICsgYjtcbiAgICAgICAgICBjICYmIChwICs9IGVuY29kZVVSSShhKSArIFwiPVwiICsgZW5jb2RlVVJJKGIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHAgKz0geDtcbiAgICAgIH1cblxuICAgICAgbSA/IGQuZmlyZUV2ZW50KG0sIFwiZGlzcGxheUVycm9yXCIsIHtcbiAgICAgICAgY29kZTogYixcbiAgICAgICAgbWVzc2FnZTogcCxcbiAgICAgICAgcGFyYW1zOiBmXG4gICAgICB9LCBlKSA6IGUoKTtcbiAgICB9LFxuICAgICAgICBKID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gYihiLCBhLCBtKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGE7XG4gICAgICAgIHRoaXMuZWxlbSA9IGI7XG4gICAgICAgIHRoaXMucHJvcCA9IG07XG4gICAgICB9XG5cbiAgICAgIGIucHJvdG90eXBlLmRTZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5wYXRoc1swXSxcbiAgICAgICAgICAgIGEgPSB0aGlzLnBhdGhzWzFdLFxuICAgICAgICAgICAgbSA9IFtdLFxuICAgICAgICAgICAgZiA9IHRoaXMubm93LFxuICAgICAgICAgICAgYyA9IGIubGVuZ3RoO1xuICAgICAgICBpZiAoMSA9PT0gZikgbSA9IHRoaXMudG9EO2Vsc2UgaWYgKGMgPT09IGEubGVuZ3RoICYmIDEgPiBmKSBmb3IgKDsgYy0tOykge1xuICAgICAgICAgIHZhciBwID0gcGFyc2VGbG9hdChiW2NdKTtcbiAgICAgICAgICBtW2NdID0gaXNOYU4ocCkgfHwgXCJBXCIgPT09IGFbYyAtIDRdIHx8IFwiQVwiID09PSBhW2MgLSA1XSA/IGFbY10gOiBmICogcGFyc2VGbG9hdChcIlwiICsgKGFbY10gLSBwKSkgKyBwO1xuICAgICAgICB9IGVsc2UgbSA9IGE7XG4gICAgICAgIHRoaXMuZWxlbS5hdHRyKFwiZFwiLCBtLCBudWxsLCAhMCk7XG4gICAgICB9O1xuXG4gICAgICBiLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5lbGVtLFxuICAgICAgICAgICAgYSA9IHRoaXMucHJvcCxcbiAgICAgICAgICAgIG0gPSB0aGlzLm5vdyxcbiAgICAgICAgICAgIGYgPSB0aGlzLm9wdGlvbnMuc3RlcDtcbiAgICAgICAgaWYgKHRoaXNbYSArIFwiU2V0dGVyXCJdKSB0aGlzW2EgKyBcIlNldHRlclwiXSgpO2Vsc2UgYi5hdHRyID8gYi5lbGVtZW50ICYmIGIuYXR0cihhLCBtLCBudWxsLCAhMCkgOiBiLnN0eWxlW2FdID0gbSArIHRoaXMudW5pdDtcbiAgICAgICAgZiAmJiBmLmNhbGwoYiwgbSwgdGhpcyk7XG4gICAgICB9O1xuXG4gICAgICBiLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoYiwgYSwgbSkge1xuICAgICAgICB2YXIgZiA9IHRoaXMsXG4gICAgICAgICAgICBjID0gZi5vcHRpb25zLFxuICAgICAgICAgICAgcCA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgcmV0dXJuIHAuc3RvcHBlZCA/ICExIDogZi5zdGVwKGIpO1xuICAgICAgICB9LFxuICAgICAgICAgICAgZSA9IEEucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgc2V0VGltZW91dChiLCAxMyk7XG4gICAgICAgIH0sXG4gICAgICAgICAgICB4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgZC50aW1lcnMubGVuZ3RoOyBiKyspIGQudGltZXJzW2JdKCkgfHwgZC50aW1lcnMuc3BsaWNlKGItLSwgMSk7XG5cbiAgICAgICAgICBkLnRpbWVycy5sZW5ndGggJiYgZSh4KTtcbiAgICAgICAgfTtcblxuICAgICAgICBiICE9PSBhIHx8IHRoaXMuZWxlbVtcImZvcmNlQW5pbWF0ZTpcIiArIHRoaXMucHJvcF0gPyAodGhpcy5zdGFydFRpbWUgPSArbmV3IERhdGUoKSwgdGhpcy5zdGFydCA9IGIsIHRoaXMuZW5kID0gYSwgdGhpcy51bml0ID0gbSwgdGhpcy5ub3cgPSB0aGlzLnN0YXJ0LCB0aGlzLnBvcyA9IDAsIHAuZWxlbSA9IHRoaXMuZWxlbSwgcC5wcm9wID0gdGhpcy5wcm9wLCBwKCkgJiYgMSA9PT0gZC50aW1lcnMucHVzaChwKSAmJiBlKHgpKSA6IChkZWxldGUgYy5jdXJBbmltW3RoaXMucHJvcF0sIGMuY29tcGxldGUgJiYgMCA9PT0gT2JqZWN0LmtleXMoYy5jdXJBbmltKS5sZW5ndGggJiYgYy5jb21wbGV0ZS5jYWxsKHRoaXMuZWxlbSkpO1xuICAgICAgfTtcblxuICAgICAgYi5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gK25ldyBEYXRlKCksXG4gICAgICAgICAgICBtID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgZiA9IHRoaXMuZWxlbSxcbiAgICAgICAgICAgIGMgPSBtLmNvbXBsZXRlLFxuICAgICAgICAgICAgcCA9IG0uZHVyYXRpb24sXG4gICAgICAgICAgICBlID0gbS5jdXJBbmltO1xuICAgICAgICBpZiAoZi5hdHRyICYmICFmLmVsZW1lbnQpIGIgPSAhMTtlbHNlIGlmIChiIHx8IGEgPj0gcCArIHRoaXMuc3RhcnRUaW1lKSB7XG4gICAgICAgICAgdGhpcy5ub3cgPSB0aGlzLmVuZDtcbiAgICAgICAgICB0aGlzLnBvcyA9IDE7XG4gICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICB2YXIgeCA9IGVbdGhpcy5wcm9wXSA9ICEwO1xuICAgICAgICAgIFkoZSwgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICEwICE9PSBiICYmICh4ID0gITEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHggJiYgYyAmJiBjLmNhbGwoZik7XG4gICAgICAgICAgYiA9ICExO1xuICAgICAgICB9IGVsc2UgdGhpcy5wb3MgPSBtLmVhc2luZygoYSAtIHRoaXMuc3RhcnRUaW1lKSAvIHApLCB0aGlzLm5vdyA9IHRoaXMuc3RhcnQgKyAodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIHRoaXMucG9zLCB0aGlzLnVwZGF0ZSgpLCBiID0gITA7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfTtcblxuICAgICAgYi5wcm90b3R5cGUuaW5pdFBhdGggPSBmdW5jdGlvbiAoYiwgYSwgbSkge1xuICAgICAgICBmdW5jdGlvbiBmKGIpIHtcbiAgICAgICAgICBmb3IgKEMgPSBiLmxlbmd0aDsgQy0tOykge1xuICAgICAgICAgICAgdmFyIGEgPSBcIk1cIiA9PT0gYltDXSB8fCBcIkxcIiA9PT0gYltDXTtcbiAgICAgICAgICAgIHZhciBtID0gL1thLXpBLVpdLy50ZXN0KGJbQyArIDNdKTtcbiAgICAgICAgICAgIGEgJiYgbSAmJiBiLnNwbGljZShDICsgMSwgMCwgYltDICsgMV0sIGJbQyArIDJdLCBiW0MgKyAxXSwgYltDICsgMl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGMoYiwgYSkge1xuICAgICAgICAgIGZvciAoOyBiLmxlbmd0aCA8IHY7KSB7XG4gICAgICAgICAgICBiWzBdID0gYVt2IC0gYi5sZW5ndGhdO1xuICAgICAgICAgICAgdmFyIG0gPSBiLnNsaWNlKDAsIFQpO1xuICAgICAgICAgICAgW10uc3BsaWNlLmFwcGx5KGIsIFswLCAwXS5jb25jYXQobSkpO1xuICAgICAgICAgICAgayAmJiAobSA9IGIuc2xpY2UoYi5sZW5ndGggLSBUKSwgW10uc3BsaWNlLmFwcGx5KGIsIFtiLmxlbmd0aCwgMF0uY29uY2F0KG0pKSwgQy0tKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBiWzBdID0gXCJNXCI7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwKGIsIGEpIHtcbiAgICAgICAgICBmb3IgKHZhciBtID0gKHYgLSBiLmxlbmd0aCkgLyBUOyAwIDwgbSAmJiBtLS07KSBsID0gYi5zbGljZSgpLnNwbGljZShiLmxlbmd0aCAvIG4gLSBULCBUICogbiksIGxbMF0gPSBhW3YgLSBUIC0gbSAqIFRdLCBGICYmIChsW1QgLSA2XSA9IGxbVCAtIDJdLCBsW1QgLSA1XSA9IGxbVCAtIDFdKSwgW10uc3BsaWNlLmFwcGx5KGIsIFtiLmxlbmd0aCAvIG4sIDBdLmNvbmNhdChsKSksIGsgJiYgbS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgYSA9IGEgfHwgXCJcIjtcbiAgICAgICAgdmFyIGUgPSBiLnN0YXJ0WCxcbiAgICAgICAgICAgIHggPSBiLmVuZFgsXG4gICAgICAgICAgICBGID0gLTEgPCBhLmluZGV4T2YoXCJDXCIpLFxuICAgICAgICAgICAgVCA9IEYgPyA3IDogMyxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBDO1xuICAgICAgICBhID0gYS5zcGxpdChcIiBcIik7XG4gICAgICAgIG0gPSBtLnNsaWNlKCk7XG4gICAgICAgIHZhciBrID0gYi5pc0FyZWEsXG4gICAgICAgICAgICBuID0gayA/IDIgOiAxO1xuICAgICAgICBGICYmIChmKGEpLCBmKG0pKTtcblxuICAgICAgICBpZiAoZSAmJiB4KSB7XG4gICAgICAgICAgZm9yIChDID0gMDsgQyA8IGUubGVuZ3RoOyBDKyspIGlmIChlW0NdID09PSB4WzBdKSB7XG4gICAgICAgICAgICB2YXIgViA9IEM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGVbMF0gPT09IHhbeC5sZW5ndGggLSBlLmxlbmd0aCArIENdKSB7XG4gICAgICAgICAgICBWID0gQztcbiAgICAgICAgICAgIHZhciB3ID0gITA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGVbZS5sZW5ndGggLSAxXSA9PT0geFt4Lmxlbmd0aCAtIGUubGVuZ3RoICsgQ10pIHtcbiAgICAgICAgICAgIFYgPSBlLmxlbmd0aCAtIEM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgViAmJiAoYSA9IFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhLmxlbmd0aCAmJiBQKFYpKSB7XG4gICAgICAgICAgdmFyIHYgPSBtLmxlbmd0aCArIFYgKiBuICogVDtcbiAgICAgICAgICB3ID8gKGMoYSwgbSksIHAobSwgYSkpIDogKGMobSwgYSksIHAoYSwgbSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFthLCBtXTtcbiAgICAgIH07XG5cbiAgICAgIGIucHJvdG90eXBlLmZpbGxTZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGQuRngucHJvdG90eXBlLnN0cm9rZVNldHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcblxuICAgICAgYi5wcm90b3R5cGUuc3Ryb2tlU2V0dGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVsZW0uYXR0cih0aGlzLnByb3AsIGQuY29sb3IodGhpcy5zdGFydCkudHdlZW5UbyhkLmNvbG9yKHRoaXMuZW5kKSwgdGhpcy5wb3MpLCBudWxsLCAhMCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gYjtcbiAgICB9KCk7XG5cbiAgICBkLkZ4ID0gSjtcbiAgICBkLm1lcmdlID0gZztcblxuICAgIHZhciB5ID0gZC5wSW50ID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChiLCBhIHx8IDEwKTtcbiAgICB9LFxuICAgICAgICB0ID0gZC5pc1N0cmluZyA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGI7XG4gICAgfSxcbiAgICAgICAgRCA9IGQuaXNBcnJheSA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICBiID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpO1xuICAgICAgcmV0dXJuIFwiW29iamVjdCBBcnJheV1cIiA9PT0gYiB8fCBcIltvYmplY3QgQXJyYXkgSXRlcmF0b3JdXCIgPT09IGI7XG4gICAgfSxcbiAgICAgICAgaCA9IGQuaXNPYmplY3QgPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgcmV0dXJuICEhYiAmJiBcIm9iamVjdFwiID09PSB0eXBlb2YgYiAmJiAoIWEgfHwgIUQoYikpO1xuICAgIH0sXG4gICAgICAgIE4gPSBkLmlzRE9NRWxlbWVudCA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICByZXR1cm4gaChiKSAmJiBcIm51bWJlclwiID09PSB0eXBlb2YgYi5ub2RlVHlwZTtcbiAgICB9LFxuICAgICAgICBxID0gZC5pc0NsYXNzID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIHZhciBhID0gYiAmJiBiLmNvbnN0cnVjdG9yO1xuICAgICAgcmV0dXJuICEoIWgoYiwgITApIHx8IE4oYikgfHwgIWEgfHwgIWEubmFtZSB8fCBcIk9iamVjdFwiID09PSBhLm5hbWUpO1xuICAgIH0sXG4gICAgICAgIFAgPSBkLmlzTnVtYmVyID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIHJldHVybiBcIm51bWJlclwiID09PSB0eXBlb2YgYiAmJiAhaXNOYU4oYikgJiYgSW5maW5pdHkgPiBiICYmIC1JbmZpbml0eSA8IGI7XG4gICAgfSxcbiAgICAgICAgZSA9IGQuZXJhc2UgPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgZm9yICh2YXIgbSA9IGIubGVuZ3RoOyBtLS07KSBpZiAoYlttXSA9PT0gYSkge1xuICAgICAgICBiLnNwbGljZShtLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgYyA9IGQuZGVmaW5lZCA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGIgJiYgbnVsbCAhPT0gYjtcbiAgICB9O1xuXG4gICAgZC5hdHRyID0gVztcblxuICAgIHZhciBrID0gZC5zcGxhdCA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICByZXR1cm4gRChiKSA/IGIgOiBbYl07XG4gICAgfSxcbiAgICAgICAgbiA9IGQuc3luY1RpbWVvdXQgPSBmdW5jdGlvbiAoYiwgYSwgbSkge1xuICAgICAgaWYgKDAgPCBhKSByZXR1cm4gc2V0VGltZW91dChiLCBhLCBtKTtcbiAgICAgIGIuY2FsbCgwLCBtKTtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9LFxuICAgICAgICBmID0gZC5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoYikge1xuICAgICAgYyhiKSAmJiBjbGVhclRpbWVvdXQoYik7XG4gICAgfSxcbiAgICAgICAgYSA9IGQuZXh0ZW5kID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgIHZhciBtO1xuICAgICAgYiB8fCAoYiA9IHt9KTtcblxuICAgICAgZm9yIChtIGluIGEpIGJbbV0gPSBhW21dO1xuXG4gICAgICByZXR1cm4gYjtcbiAgICB9O1xuXG4gICAgZC5waWNrID0gdTtcblxuICAgIHZhciBsID0gZC5jc3MgPSBmdW5jdGlvbiAoYiwgbSkge1xuICAgICAgZC5pc01TICYmICFkLnN2ZyAmJiBtICYmIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBtLm9wYWNpdHkgJiYgKG0uZmlsdGVyID0gXCJhbHBoYShvcGFjaXR5PVwiICsgMTAwICogbS5vcGFjaXR5ICsgXCIpXCIpO1xuICAgICAgYShiLnN0eWxlLCBtKTtcbiAgICB9LFxuICAgICAgICB2ID0gZC5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGIsIG0sIGYsIGMsIHApIHtcbiAgICAgIGIgPSBFLmNyZWF0ZUVsZW1lbnQoYik7XG4gICAgICBtICYmIGEoYiwgbSk7XG4gICAgICBwICYmIGwoYiwge1xuICAgICAgICBwYWRkaW5nOiBcIjBcIixcbiAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgbWFyZ2luOiBcIjBcIlxuICAgICAgfSk7XG4gICAgICBmICYmIGwoYiwgZik7XG4gICAgICBjICYmIGMuYXBwZW5kQ2hpbGQoYik7XG4gICAgICByZXR1cm4gYjtcbiAgICB9LFxuICAgICAgICB6ID0gZC5leHRlbmRDbGFzcyA9IGZ1bmN0aW9uIChiLCBtKSB7XG4gICAgICB2YXIgZiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICBmLnByb3RvdHlwZSA9IG5ldyBiKCk7XG4gICAgICBhKGYucHJvdG90eXBlLCBtKTtcbiAgICAgIHJldHVybiBmO1xuICAgIH0sXG4gICAgICAgIHcgPSBkLnBhZCA9IGZ1bmN0aW9uIChiLCBhLCBtKSB7XG4gICAgICByZXR1cm4gQXJyYXkoKGEgfHwgMikgKyAxIC0gU3RyaW5nKGIpLnJlcGxhY2UoXCItXCIsIFwiXCIpLmxlbmd0aCkuam9pbihtIHx8IFwiMFwiKSArIGI7XG4gICAgfSxcbiAgICAgICAgQiA9IGQucmVsYXRpdmVMZW5ndGggPSBmdW5jdGlvbiAoYiwgYSwgbSkge1xuICAgICAgcmV0dXJuIC8lJC8udGVzdChiKSA/IGEgKiBwYXJzZUZsb2F0KGIpIC8gMTAwICsgKG0gfHwgMCkgOiBwYXJzZUZsb2F0KGIpO1xuICAgIH0sXG4gICAgICAgIEwgPSBkLndyYXAgPSBmdW5jdGlvbiAoYiwgYSwgbSkge1xuICAgICAgdmFyIGYgPSBiW2FdO1xuXG4gICAgICBiW2FdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICBhID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgYyA9IHRoaXM7XG5cbiAgICAgICAgYy5wcm9jZWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGYuYXBwbHkoYywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50cyA6IGEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGIudW5zaGlmdChmKTtcbiAgICAgICAgYiA9IG0uYXBwbHkodGhpcywgYik7XG4gICAgICAgIGMucHJvY2VlZCA9IG51bGw7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBRID0gZC5mb3JtYXQgPSBmdW5jdGlvbiAoYiwgYSwgbSkge1xuICAgICAgdmFyIGYgPSBcIntcIixcbiAgICAgICAgICBjID0gITEsXG4gICAgICAgICAgcCA9IFtdLFxuICAgICAgICAgIGUgPSAvZiQvLFxuICAgICAgICAgIHggPSAvXFwuKFswLTldKS8sXG4gICAgICAgICAgRiA9IGQuZGVmYXVsdE9wdGlvbnMubGFuZyxcbiAgICAgICAgICBDID0gbSAmJiBtLnRpbWUgfHwgZC50aW1lO1xuXG4gICAgICBmb3IgKG0gPSBtICYmIG0ubnVtYmVyRm9ybWF0dGVyIHx8IFQ7IGI7KSB7XG4gICAgICAgIHZhciBsID0gYi5pbmRleE9mKGYpO1xuICAgICAgICBpZiAoLTEgPT09IGwpIGJyZWFrO1xuICAgICAgICB2YXIgayA9IGIuc2xpY2UoMCwgbCk7XG5cbiAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICBrID0gay5zcGxpdChcIjpcIik7XG4gICAgICAgICAgZiA9IHIoay5zaGlmdCgpIHx8IFwiXCIsIGEpO1xuICAgICAgICAgIGlmIChrLmxlbmd0aCAmJiBcIm51bWJlclwiID09PSB0eXBlb2YgZikgaWYgKGsgPSBrLmpvaW4oXCI6XCIpLCBlLnRlc3QoaykpIHtcbiAgICAgICAgICAgIHZhciBuID0gcGFyc2VJbnQoKGsubWF0Y2goeCkgfHwgW1wiXCIsIFwiLTFcIl0pWzFdLCAxMCk7XG4gICAgICAgICAgICBudWxsICE9PSBmICYmIChmID0gbShmLCBuLCBGLmRlY2ltYWxQb2ludCwgLTEgPCBrLmluZGV4T2YoXCIsXCIpID8gRi50aG91c2FuZHNTZXAgOiBcIlwiKSk7XG4gICAgICAgICAgfSBlbHNlIGYgPSBDLmRhdGVGb3JtYXQoaywgZik7XG4gICAgICAgICAgcC5wdXNoKGYpO1xuICAgICAgICB9IGVsc2UgcC5wdXNoKGspO1xuXG4gICAgICAgIGIgPSBiLnNsaWNlKGwgKyAxKTtcbiAgICAgICAgZiA9IChjID0gIWMpID8gXCJ9XCIgOiBcIntcIjtcbiAgICAgIH1cblxuICAgICAgcC5wdXNoKGIpO1xuICAgICAgcmV0dXJuIHAuam9pbihcIlwiKTtcbiAgICB9LFxuICAgICAgICBIID0gZC5nZXRNYWduaXR1ZGUgPSBmdW5jdGlvbiAoYikge1xuICAgICAgcmV0dXJuIE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKGIpIC8gTWF0aC5MTjEwKSk7XG4gICAgfSxcbiAgICAgICAgSyA9IGQubm9ybWFsaXplVGlja0ludGVydmFsID0gZnVuY3Rpb24gKGIsIGEsIG0sIGYsIGMpIHtcbiAgICAgIHZhciBwID0gYjtcbiAgICAgIG0gPSB1KG0sIDEpO1xuICAgICAgdmFyIGUgPSBiIC8gbTtcbiAgICAgIGEgfHwgKGEgPSBjID8gWzEsIDEuMiwgMS41LCAyLCAyLjUsIDMsIDQsIDUsIDYsIDgsIDEwXSA6IFsxLCAyLCAyLjUsIDUsIDEwXSwgITEgPT09IGYgJiYgKDEgPT09IG0gPyBhID0gYS5maWx0ZXIoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIDAgPT09IGIgJSAxO1xuICAgICAgfSkgOiAuMSA+PSBtICYmIChhID0gWzEgLyBtXSkpKTtcblxuICAgICAgZm9yIChmID0gMDsgZiA8IGEubGVuZ3RoICYmICEocCA9IGFbZl0sIGMgJiYgcCAqIG0gPj0gYiB8fCAhYyAmJiBlIDw9IChhW2ZdICsgKGFbZiArIDFdIHx8IGFbZl0pKSAvIDIpOyBmKyspO1xuXG4gICAgICByZXR1cm4gcCA9IE8ocCAqIG0sIC1NYXRoLnJvdW5kKE1hdGgubG9nKC4wMDEpIC8gTWF0aC5MTjEwKSk7XG4gICAgfSxcbiAgICAgICAgcCA9IGQuc3RhYmxlU29ydCA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICB2YXIgbSA9IGIubGVuZ3RoLFxuICAgICAgICAgIGYsXG4gICAgICAgICAgYztcblxuICAgICAgZm9yIChjID0gMDsgYyA8IG07IGMrKykgYltjXS5zYWZlSSA9IGM7XG5cbiAgICAgIGIuc29ydChmdW5jdGlvbiAoYiwgbSkge1xuICAgICAgICBmID0gYShiLCBtKTtcbiAgICAgICAgcmV0dXJuIDAgPT09IGYgPyBiLnNhZmVJIC0gbS5zYWZlSSA6IGY7XG4gICAgICB9KTtcblxuICAgICAgZm9yIChjID0gMDsgYyA8IG07IGMrKykgZGVsZXRlIGJbY10uc2FmZUk7XG4gICAgfSxcbiAgICAgICAgYiA9IGQuYXJyYXlNaW4gPSBmdW5jdGlvbiAoYikge1xuICAgICAgZm9yICh2YXIgYSA9IGIubGVuZ3RoLCBtID0gYlswXTsgYS0tOykgYlthXSA8IG0gJiYgKG0gPSBiW2FdKTtcblxuICAgICAgcmV0dXJuIG07XG4gICAgfSxcbiAgICAgICAgQyA9IGQuYXJyYXlNYXggPSBmdW5jdGlvbiAoYikge1xuICAgICAgZm9yICh2YXIgYSA9IGIubGVuZ3RoLCBtID0gYlswXTsgYS0tOykgYlthXSA+IG0gJiYgKG0gPSBiW2FdKTtcblxuICAgICAgcmV0dXJuIG07XG4gICAgfSxcbiAgICAgICAgeCA9IGQuZGVzdHJveU9iamVjdFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgWShiLCBmdW5jdGlvbiAobSwgZikge1xuICAgICAgICBtICYmIG0gIT09IGEgJiYgbS5kZXN0cm95ICYmIG0uZGVzdHJveSgpO1xuICAgICAgICBkZWxldGUgYltmXTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgICAgIFIgPSBkLmRpc2NhcmRFbGVtZW50ID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIHZhciBhID0gZC5nYXJiYWdlQmluO1xuICAgICAgYSB8fCAoYSA9IHYoXCJkaXZcIikpO1xuICAgICAgYiAmJiBhLmFwcGVuZENoaWxkKGIpO1xuICAgICAgYS5pbm5lckhUTUwgPSBcIlwiO1xuICAgIH0sXG4gICAgICAgIE8gPSBkLmNvcnJlY3RGbG9hdCA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChiLnRvUHJlY2lzaW9uKGEgfHwgMTQpKTtcbiAgICB9LFxuICAgICAgICBYID0gZC5zZXRBbmltYXRpb24gPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgYS5yZW5kZXJlci5nbG9iYWxBbmltYXRpb24gPSB1KGIsIGEub3B0aW9ucy5jaGFydC5hbmltYXRpb24sICEwKTtcbiAgICB9LFxuICAgICAgICBVID0gZC5hbmltT2JqZWN0ID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIHJldHVybiBoKGIpID8gZyhiKSA6IHtcbiAgICAgICAgZHVyYXRpb246IGIgPyA1MDAgOiAwXG4gICAgICB9O1xuICAgIH0sXG4gICAgICAgIG0gPSBkLnRpbWVVbml0cyA9IHtcbiAgICAgIG1pbGxpc2Vjb25kOiAxLFxuICAgICAgc2Vjb25kOiAxRTMsXG4gICAgICBtaW51dGU6IDZFNCxcbiAgICAgIGhvdXI6IDM2RTUsXG4gICAgICBkYXk6IDg2NEU1LFxuICAgICAgd2VlazogNjA0OEU1LFxuICAgICAgbW9udGg6IDI0MTkyRTUsXG4gICAgICB5ZWFyOiAzMTQ0OTZFNVxuICAgIH0sXG4gICAgICAgIFQgPSBkLm51bWJlckZvcm1hdCA9IGZ1bmN0aW9uIChiLCBhLCBtLCBmKSB7XG4gICAgICBiID0gK2IgfHwgMDtcbiAgICAgIGEgPSArYTtcbiAgICAgIHZhciBjID0gZC5kZWZhdWx0T3B0aW9ucy5sYW5nLFxuICAgICAgICAgIHAgPSAoYi50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5zcGxpdChcImVcIilbMF0ubGVuZ3RoLFxuICAgICAgICAgIGUgPSBiLnRvU3RyaW5nKCkuc3BsaXQoXCJlXCIpO1xuICAgICAgaWYgKC0xID09PSBhKSBhID0gTWF0aC5taW4ocCwgMjApO2Vsc2UgaWYgKCFQKGEpKSBhID0gMjtlbHNlIGlmIChhICYmIGVbMV0gJiYgMCA+IGVbMV0pIHtcbiAgICAgICAgdmFyIHggPSBhICsgK2VbMV07XG4gICAgICAgIDAgPD0geCA/IChlWzBdID0gKCtlWzBdKS50b0V4cG9uZW50aWFsKHgpLnNwbGl0KFwiZVwiKVswXSwgYSA9IHgpIDogKGVbMF0gPSBlWzBdLnNwbGl0KFwiLlwiKVswXSB8fCAwLCBiID0gMjAgPiBhID8gKGVbMF0gKiBNYXRoLnBvdygxMCwgZVsxXSkpLnRvRml4ZWQoYSkgOiAwLCBlWzFdID0gMCk7XG4gICAgICB9XG4gICAgICB2YXIgRiA9IChNYXRoLmFicyhlWzFdID8gZVswXSA6IGIpICsgTWF0aC5wb3coMTAsIC1NYXRoLm1heChhLCBwKSAtIDEpKS50b0ZpeGVkKGEpO1xuICAgICAgcCA9IFN0cmluZyh5KEYpKTtcbiAgICAgIHggPSAzIDwgcC5sZW5ndGggPyBwLmxlbmd0aCAlIDMgOiAwO1xuICAgICAgbSA9IHUobSwgYy5kZWNpbWFsUG9pbnQpO1xuICAgICAgZiA9IHUoZiwgYy50aG91c2FuZHNTZXApO1xuICAgICAgYiA9ICgwID4gYiA/IFwiLVwiIDogXCJcIikgKyAoeCA/IHAuc3Vic3RyKDAsIHgpICsgZiA6IFwiXCIpO1xuICAgICAgYiArPSBwLnN1YnN0cih4KS5yZXBsYWNlKC8oXFxkezN9KSg/PVxcZCkvZywgXCIkMVwiICsgZik7XG4gICAgICBhICYmIChiICs9IG0gKyBGLnNsaWNlKC1hKSk7XG4gICAgICBlWzFdICYmIDAgIT09ICtiICYmIChiICs9IFwiZVwiICsgZVsxXSk7XG4gICAgICByZXR1cm4gYjtcbiAgICB9O1xuXG4gICAgTWF0aC5lYXNlSW5PdXRTaW5lID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIHJldHVybiAtLjUgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIGIpIC0gMSk7XG4gICAgfTtcblxuICAgIHZhciBaID0gZC5nZXRTdHlsZSA9IGZ1bmN0aW9uIChiLCBhLCBtKSB7XG4gICAgICBpZiAoXCJ3aWR0aFwiID09PSBhKSByZXR1cm4gYSA9IE1hdGgubWluKGIub2Zmc2V0V2lkdGgsIGIuc2Nyb2xsV2lkdGgpLCBtID0gYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCwgbSA8IGEgJiYgbSA+PSBhIC0gMSAmJiAoYSA9IE1hdGguZmxvb3IobSkpLCBNYXRoLm1heCgwLCBhIC0gZC5nZXRTdHlsZShiLCBcInBhZGRpbmctbGVmdFwiKSAtIGQuZ2V0U3R5bGUoYiwgXCJwYWRkaW5nLXJpZ2h0XCIpKTtcbiAgICAgIGlmIChcImhlaWdodFwiID09PSBhKSByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oYi5vZmZzZXRIZWlnaHQsIGIuc2Nyb2xsSGVpZ2h0KSAtIGQuZ2V0U3R5bGUoYiwgXCJwYWRkaW5nLXRvcFwiKSAtIGQuZ2V0U3R5bGUoYiwgXCJwYWRkaW5nLWJvdHRvbVwiKSk7XG4gICAgICBBLmdldENvbXB1dGVkU3R5bGUgfHwgRygyNywgITApO1xuICAgICAgaWYgKGIgPSBBLmdldENvbXB1dGVkU3R5bGUoYiwgdm9pZCAwKSkgYiA9IGIuZ2V0UHJvcGVydHlWYWx1ZShhKSwgdShtLCBcIm9wYWNpdHlcIiAhPT0gYSkgJiYgKGIgPSB5KGIpKTtcbiAgICAgIHJldHVybiBiO1xuICAgIH0sXG4gICAgICAgIGNhID0gZC5pbkFycmF5ID0gZnVuY3Rpb24gKGIsIGEsIG0pIHtcbiAgICAgIHJldHVybiBhLmluZGV4T2YoYiwgbSk7XG4gICAgfSxcbiAgICAgICAgRiA9IGQuZmluZCA9IEFycmF5LnByb3RvdHlwZS5maW5kID8gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgIHJldHVybiBiLmZpbmQoYSk7XG4gICAgfSA6IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICB2YXIgbSxcbiAgICAgICAgICBmID0gYi5sZW5ndGg7XG5cbiAgICAgIGZvciAobSA9IDA7IG0gPCBmOyBtKyspIGlmIChhKGJbbV0sIG0pKSByZXR1cm4gYlttXTtcbiAgICB9O1xuXG4gICAgZC5rZXlzID0gT2JqZWN0LmtleXM7XG5cbiAgICB2YXIgViA9IGQub2Zmc2V0ID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIHZhciBhID0gRS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICBiID0gYi5wYXJlbnRFbGVtZW50IHx8IGIucGFyZW50Tm9kZSA/IGIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7XG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMFxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogYi50b3AgKyAoQS5wYWdlWU9mZnNldCB8fCBhLnNjcm9sbFRvcCkgLSAoYS5jbGllbnRUb3AgfHwgMCksXG4gICAgICAgIGxlZnQ6IGIubGVmdCArIChBLnBhZ2VYT2Zmc2V0IHx8IGEuc2Nyb2xsTGVmdCkgLSAoYS5jbGllbnRMZWZ0IHx8IDApXG4gICAgICB9O1xuICAgIH0sXG4gICAgICAgIGJhID0gZC5zdG9wID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgIGZvciAodmFyIG0gPSBkLnRpbWVycy5sZW5ndGg7IG0tLTspIGQudGltZXJzW21dLmVsZW0gIT09IGIgfHwgYSAmJiBhICE9PSBkLnRpbWVyc1ttXS5wcm9wIHx8IChkLnRpbWVyc1ttXS5zdG9wcGVkID0gITApO1xuICAgIH0sXG4gICAgICAgIFkgPSBkLm9iamVjdEVhY2ggPSBmdW5jdGlvbiAoYiwgYSwgbSkge1xuICAgICAgZm9yICh2YXIgZiBpbiBiKSBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChiLCBmKSAmJiBhLmNhbGwobSB8fCBiW2ZdLCBiW2ZdLCBmLCBiKTtcbiAgICB9O1xuXG4gICAgWSh7XG4gICAgICBtYXA6IFwibWFwXCIsXG4gICAgICBlYWNoOiBcImZvckVhY2hcIixcbiAgICAgIGdyZXA6IFwiZmlsdGVyXCIsXG4gICAgICByZWR1Y2U6IFwicmVkdWNlXCIsXG4gICAgICBzb21lOiBcInNvbWVcIlxuICAgIH0sIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICBkW2FdID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZVtiXS5hcHBseShhLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHZhciBmYSA9IGQuYWRkRXZlbnQgPSBmdW5jdGlvbiAoYiwgYSwgbSwgZikge1xuICAgICAgdm9pZCAwID09PSBmICYmIChmID0ge30pO1xuICAgICAgdmFyIGMgPSBiLmFkZEV2ZW50TGlzdGVuZXIgfHwgZC5hZGRFdmVudExpc3RlbmVyUG9seWZpbGw7XG4gICAgICB2YXIgcCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGIgJiYgYi5wcm90b3R5cGUgPyBiLnByb3RvdHlwZS5wcm90b0V2ZW50cyA9IGIucHJvdG90eXBlLnByb3RvRXZlbnRzIHx8IHt9IDogYi5oY0V2ZW50cyA9IGIuaGNFdmVudHMgfHwge307XG4gICAgICBkLlBvaW50ICYmIGIgaW5zdGFuY2VvZiBkLlBvaW50ICYmIGIuc2VyaWVzICYmIGIuc2VyaWVzLmNoYXJ0ICYmIChiLnNlcmllcy5jaGFydC5ydW5UcmFja2VyQ2xpY2sgPSAhMCk7XG4gICAgICBjICYmIGMuY2FsbChiLCBhLCBtLCAhMSk7XG4gICAgICBwW2FdIHx8IChwW2FdID0gW10pO1xuICAgICAgcFthXS5wdXNoKHtcbiAgICAgICAgZm46IG0sXG4gICAgICAgIG9yZGVyOiBcIm51bWJlclwiID09PSB0eXBlb2YgZi5vcmRlciA/IGYub3JkZXIgOiBJbmZpbml0eVxuICAgICAgfSk7XG4gICAgICBwW2FdLnNvcnQoZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgcmV0dXJuIGIub3JkZXIgLSBhLm9yZGVyO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBkYShiLCBhLCBtKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgZGEgPSBkLnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24gKGIsIGEsIG0pIHtcbiAgICAgIGZ1bmN0aW9uIGYoYSwgbSkge1xuICAgICAgICB2YXIgZiA9IGIucmVtb3ZlRXZlbnRMaXN0ZW5lciB8fCBkLnJlbW92ZUV2ZW50TGlzdGVuZXJQb2x5ZmlsbDtcbiAgICAgICAgZiAmJiBmLmNhbGwoYiwgYSwgbSwgITEpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjKG0pIHtcbiAgICAgICAgdmFyIGM7XG5cbiAgICAgICAgaWYgKGIubm9kZU5hbWUpIHtcbiAgICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgdmFyIHAgPSB7fTtcbiAgICAgICAgICAgIHBbYV0gPSAhMDtcbiAgICAgICAgICB9IGVsc2UgcCA9IG07XG5cbiAgICAgICAgICBZKHAsIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgICBpZiAobVthXSkgZm9yIChjID0gbVthXS5sZW5ndGg7IGMtLTspIGYoYSwgbVthXVtjXS5mbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHA7XG4gICAgICBbXCJwcm90b0V2ZW50c1wiLCBcImhjRXZlbnRzXCJdLmZvckVhY2goZnVuY3Rpb24gKGUsIHgpIHtcbiAgICAgICAgdmFyIEYgPSAoeCA9IHggPyBiIDogYi5wcm90b3R5cGUpICYmIHhbZV07XG4gICAgICAgIEYgJiYgKGEgPyAocCA9IEZbYV0gfHwgW10sIG0gPyAoRlthXSA9IHAuZmlsdGVyKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgcmV0dXJuIG0gIT09IGIuZm47XG4gICAgICAgIH0pLCBmKGEsIG0pKSA6IChjKEYpLCBGW2FdID0gW10pKSA6IChjKEYpLCB4W2VdID0ge30pKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgICAgIGhhID0gZC5maXJlRXZlbnQgPSBmdW5jdGlvbiAoYiwgbSwgZiwgYykge1xuICAgICAgdmFyIHA7XG4gICAgICBmID0gZiB8fCB7fTtcblxuICAgICAgaWYgKEUuY3JlYXRlRXZlbnQgJiYgKGIuZGlzcGF0Y2hFdmVudCB8fCBiLmZpcmVFdmVudCkpIHtcbiAgICAgICAgdmFyIGUgPSBFLmNyZWF0ZUV2ZW50KFwiRXZlbnRzXCIpO1xuICAgICAgICBlLmluaXRFdmVudChtLCAhMCwgITApO1xuICAgICAgICBhKGUsIGYpO1xuICAgICAgICBiLmRpc3BhdGNoRXZlbnQgPyBiLmRpc3BhdGNoRXZlbnQoZSkgOiBiLmZpcmVFdmVudChtLCBlKTtcbiAgICAgIH0gZWxzZSBmLnRhcmdldCB8fCBhKGYsIHtcbiAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmLmRlZmF1bHRQcmV2ZW50ZWQgPSAhMDtcbiAgICAgICAgfSxcbiAgICAgICAgdGFyZ2V0OiBiLFxuICAgICAgICB0eXBlOiBtXG4gICAgICB9KSwgZnVuY3Rpb24gKGEsIG0pIHtcbiAgICAgICAgdm9pZCAwID09PSBhICYmIChhID0gW10pO1xuICAgICAgICB2b2lkIDAgPT09IG0gJiYgKG0gPSBbXSk7XG4gICAgICAgIHZhciBjID0gMCxcbiAgICAgICAgICAgIGUgPSAwLFxuICAgICAgICAgICAgeCA9IGEubGVuZ3RoICsgbS5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChwID0gMDsgcCA8IHg7IHArKykgITEgPT09IChhW2NdID8gbVtlXSA/IGFbY10ub3JkZXIgPD0gbVtlXS5vcmRlciA/IGFbYysrXSA6IG1bZSsrXSA6IGFbYysrXSA6IG1bZSsrXSkuZm4uY2FsbChiLCBmKSAmJiBmLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KGIucHJvdG9FdmVudHMgJiYgYi5wcm90b0V2ZW50c1ttXSwgYi5oY0V2ZW50cyAmJiBiLmhjRXZlbnRzW21dKTtcblxuICAgICAgYyAmJiAhZi5kZWZhdWx0UHJldmVudGVkICYmIGMuY2FsbChiLCBmKTtcbiAgICB9LFxuICAgICAgICBpYSA9IGQuYW5pbWF0ZSA9IGZ1bmN0aW9uIChiLCBhLCBtKSB7XG4gICAgICB2YXIgZixcbiAgICAgICAgICBjID0gXCJcIixcbiAgICAgICAgICBwLFxuICAgICAgICAgIGU7XG5cbiAgICAgIGlmICghaChtKSkge1xuICAgICAgICB2YXIgeCA9IGFyZ3VtZW50cztcbiAgICAgICAgbSA9IHtcbiAgICAgICAgICBkdXJhdGlvbjogeFsyXSxcbiAgICAgICAgICBlYXNpbmc6IHhbM10sXG4gICAgICAgICAgY29tcGxldGU6IHhbNF1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgUChtLmR1cmF0aW9uKSB8fCAobS5kdXJhdGlvbiA9IDQwMCk7XG4gICAgICBtLmVhc2luZyA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG0uZWFzaW5nID8gbS5lYXNpbmcgOiBNYXRoW20uZWFzaW5nXSB8fCBNYXRoLmVhc2VJbk91dFNpbmU7XG4gICAgICBtLmN1ckFuaW0gPSBnKGEpO1xuICAgICAgWShhLCBmdW5jdGlvbiAoeCwgRikge1xuICAgICAgICBiYShiLCBGKTtcbiAgICAgICAgZSA9IG5ldyBKKGIsIG0sIEYpO1xuICAgICAgICBwID0gbnVsbDtcbiAgICAgICAgXCJkXCIgPT09IEYgPyAoZS5wYXRocyA9IGUuaW5pdFBhdGgoYiwgYi5kLCBhLmQpLCBlLnRvRCA9IGEuZCwgZiA9IDAsIHAgPSAxKSA6IGIuYXR0ciA/IGYgPSBiLmF0dHIoRikgOiAoZiA9IHBhcnNlRmxvYXQoWihiLCBGKSkgfHwgMCwgXCJvcGFjaXR5XCIgIT09IEYgJiYgKGMgPSBcInB4XCIpKTtcbiAgICAgICAgcCB8fCAocCA9IHgpO1xuICAgICAgICBwICYmIHAubWF0Y2ggJiYgcC5tYXRjaChcInB4XCIpICYmIChwID0gcC5yZXBsYWNlKC9weC9nLCBcIlwiKSk7XG4gICAgICAgIGUucnVuKGYsIHAsIGMpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAgICAgamEgPSBkLnNlcmllc1R5cGUgPSBmdW5jdGlvbiAoYiwgYSwgbSwgZiwgYykge1xuICAgICAgdmFyIHAgPSBkLmdldE9wdGlvbnMoKSxcbiAgICAgICAgICBlID0gZC5zZXJpZXNUeXBlcztcbiAgICAgIHAucGxvdE9wdGlvbnNbYl0gPSBnKHAucGxvdE9wdGlvbnNbYV0sIG0pO1xuICAgICAgZVtiXSA9IHooZVthXSB8fCBmdW5jdGlvbiAoKSB7fSwgZik7XG4gICAgICBlW2JdLnByb3RvdHlwZS50eXBlID0gYjtcbiAgICAgIGMgJiYgKGVbYl0ucHJvdG90eXBlLnBvaW50Q2xhc3MgPSB6KGQuUG9pbnQsIGMpKTtcbiAgICAgIHJldHVybiBlW2JdO1xuICAgIH0sXG4gICAgICAgIGVhID0gZC51bmlxdWVLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYiA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA5KSxcbiAgICAgICAgICBhID0gMDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcImhpZ2hjaGFydHMtXCIgKyBiICsgXCItXCIgKyBhKys7XG4gICAgICB9O1xuICAgIH0oKSxcbiAgICAgICAga2EgPSBkLmlzRnVuY3Rpb24gPSBmdW5jdGlvbiAoYikge1xuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGI7XG4gICAgfTtcblxuICAgIEEualF1ZXJ5ICYmIChBLmpRdWVyeS5mbi5oaWdoY2hhcnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGIgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpc1swXSkgcmV0dXJuIGJbMF0gPyAobmV3IGRbdChiWzBdKSA/IGIuc2hpZnQoKSA6IFwiQ2hhcnRcIl0odGhpc1swXSwgYlswXSwgYlsxXSksIHRoaXMpIDogTVtXKHRoaXNbMF0sIFwiZGF0YS1oaWdoY2hhcnRzLWNoYXJ0XCIpXTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgRng6IEosXG4gICAgICBhZGRFdmVudDogZmEsXG4gICAgICBhbmltYXRlOiBpYSxcbiAgICAgIGFuaW1PYmplY3Q6IFUsXG4gICAgICBhcnJheU1heDogQyxcbiAgICAgIGFycmF5TWluOiBiLFxuICAgICAgYXR0cjogVyxcbiAgICAgIGNsYW1wOiBmdW5jdGlvbiAoYiwgYSwgbSkge1xuICAgICAgICByZXR1cm4gYiA+IGEgPyBiIDwgbSA/IGIgOiBtIDogYTtcbiAgICAgIH0sXG4gICAgICBjbGVhclRpbWVvdXQ6IGYsXG4gICAgICBjb3JyZWN0RmxvYXQ6IE8sXG4gICAgICBjcmVhdGVFbGVtZW50OiB2LFxuICAgICAgY3NzOiBsLFxuICAgICAgZGVmaW5lZDogYyxcbiAgICAgIGRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzOiB4LFxuICAgICAgZGlzY2FyZEVsZW1lbnQ6IFIsXG4gICAgICBlcmFzZTogZSxcbiAgICAgIGVycm9yOiBHLFxuICAgICAgZXh0ZW5kOiBhLFxuICAgICAgZXh0ZW5kQ2xhc3M6IHosXG4gICAgICBmaW5kOiBGLFxuICAgICAgZmlyZUV2ZW50OiBoYSxcbiAgICAgIGZvcm1hdDogUSxcbiAgICAgIGdldE1hZ25pdHVkZTogSCxcbiAgICAgIGdldE5lc3RlZFByb3BlcnR5OiByLFxuICAgICAgZ2V0U3R5bGU6IFosXG4gICAgICBpbkFycmF5OiBjYSxcbiAgICAgIGlzQXJyYXk6IEQsXG4gICAgICBpc0NsYXNzOiBxLFxuICAgICAgaXNET01FbGVtZW50OiBOLFxuICAgICAgaXNGdW5jdGlvbjoga2EsXG4gICAgICBpc051bWJlcjogUCxcbiAgICAgIGlzT2JqZWN0OiBoLFxuICAgICAgaXNTdHJpbmc6IHQsXG4gICAgICBtZXJnZTogZyxcbiAgICAgIG5vcm1hbGl6ZVRpY2tJbnRlcnZhbDogSyxcbiAgICAgIG51bWJlckZvcm1hdDogVCxcbiAgICAgIG9iamVjdEVhY2g6IFksXG4gICAgICBvZmZzZXQ6IFYsXG4gICAgICBwYWQ6IHcsXG4gICAgICBwaWNrOiB1LFxuICAgICAgcEludDogeSxcbiAgICAgIHJlbGF0aXZlTGVuZ3RoOiBCLFxuICAgICAgcmVtb3ZlRXZlbnQ6IGRhLFxuICAgICAgc2VyaWVzVHlwZTogamEsXG4gICAgICBzZXRBbmltYXRpb246IFgsXG4gICAgICBzcGxhdDogayxcbiAgICAgIHN0YWJsZVNvcnQ6IHAsXG4gICAgICBzdG9wOiBiYSxcbiAgICAgIHN5bmNUaW1lb3V0OiBuLFxuICAgICAgdGltZVVuaXRzOiBtLFxuICAgICAgdW5pcXVlS2V5OiBlYSxcbiAgICAgIHdyYXA6IExcbiAgICB9O1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL0NvbG9yLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgdmFyIFcgPSBnLmlzTnVtYmVyLFxuICAgICAgICB1ID0gZy5tZXJnZSxcbiAgICAgICAgciA9IGcucEludDtcblxuICAgIGcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBkKGcpIHtcbiAgICAgICAgdGhpcy5wYXJzZXJzID0gW3tcbiAgICAgICAgICByZWdleDogL3JnYmFcXChcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldPyg/OlxcLlswLTldKyk/KVxccypcXCkvLFxuICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtyKGRbMV0pLCByKGRbMl0pLCByKGRbM10pLCBwYXJzZUZsb2F0KGRbNF0sIDEwKV07XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgcmVnZXg6IC9yZ2JcXChcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKlxcKS8sXG4gICAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gW3IoZFsxXSksIHIoZFsyXSksIHIoZFszXSksIDFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfV07XG4gICAgICAgIHRoaXMucmdiYSA9IFtdO1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgZCkpIHJldHVybiBuZXcgZChnKTtcbiAgICAgICAgdGhpcy5pbml0KGcpO1xuICAgICAgfVxuXG4gICAgICBkLnBhcnNlID0gZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBkKGcpO1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIHZhciBBLCBHO1xuICAgICAgICBpZiAoKHRoaXMuaW5wdXQgPSBnID0gZC5uYW1lc1tnICYmIGcudG9Mb3dlckNhc2UgPyBnLnRvTG93ZXJDYXNlKCkgOiBcIlwiXSB8fCBnKSAmJiBnLnN0b3BzKSB0aGlzLnN0b3BzID0gZy5zdG9wcy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IGQodFsxXSk7XG4gICAgICAgIH0pO2Vsc2Uge1xuICAgICAgICAgIGlmIChnICYmIGcuY2hhckF0ICYmIFwiI1wiID09PSBnLmNoYXJBdCgpKSB7XG4gICAgICAgICAgICB2YXIgdSA9IGcubGVuZ3RoO1xuICAgICAgICAgICAgZyA9IHBhcnNlSW50KGcuc3Vic3RyKDEpLCAxNik7XG4gICAgICAgICAgICA3ID09PSB1ID8gQSA9IFsoZyAmIDE2NzExNjgwKSA+PiAxNiwgKGcgJiA2NTI4MCkgPj4gOCwgZyAmIDI1NSwgMV0gOiA0ID09PSB1ICYmIChBID0gWyhnICYgMzg0MCkgPj4gNCB8IChnICYgMzg0MCkgPj4gOCwgKGcgJiAyNDApID4+IDQgfCBnICYgMjQwLCAoZyAmIDE1KSA8PCA0IHwgZyAmIDE1LCAxXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFBKSBmb3IgKEcgPSB0aGlzLnBhcnNlcnMubGVuZ3RoOyBHLS0gJiYgIUE7KSB7XG4gICAgICAgICAgICB2YXIgeSA9IHRoaXMucGFyc2Vyc1tHXTtcbiAgICAgICAgICAgICh1ID0geS5yZWdleC5leGVjKGcpKSAmJiAoQSA9IHkucGFyc2UodSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJnYmEgPSBBIHx8IFtdO1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIGcgPSB0aGlzLmlucHV0LFxuICAgICAgICAgICAgRyA9IHRoaXMucmdiYTtcblxuICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHRoaXMuc3RvcHMpIHtcbiAgICAgICAgICB2YXIgRSA9IHUoZyk7XG4gICAgICAgICAgRS5zdG9wcyA9IFtdLmNvbmNhdChFLnN0b3BzKTtcbiAgICAgICAgICB0aGlzLnN0b3BzLmZvckVhY2goZnVuY3Rpb24gKGcsIHQpIHtcbiAgICAgICAgICAgIEUuc3RvcHNbdF0gPSBbRS5zdG9wc1t0XVswXSwgZy5nZXQoZCldO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgRSA9IEcgJiYgVyhHWzBdKSA/IFwicmdiXCIgPT09IGQgfHwgIWQgJiYgMSA9PT0gR1szXSA/IFwicmdiKFwiICsgR1swXSArIFwiLFwiICsgR1sxXSArIFwiLFwiICsgR1syXSArIFwiKVwiIDogXCJhXCIgPT09IGQgPyBHWzNdIDogXCJyZ2JhKFwiICsgRy5qb2luKFwiLFwiKSArIFwiKVwiIDogZztcblxuICAgICAgICByZXR1cm4gRTtcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLmJyaWdodGVuID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIGcsXG4gICAgICAgICAgICB1ID0gdGhpcy5yZ2JhO1xuICAgICAgICBpZiAodGhpcy5zdG9wcykgdGhpcy5zdG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7XG4gICAgICAgICAgZy5icmlnaHRlbihkKTtcbiAgICAgICAgfSk7ZWxzZSBpZiAoVyhkKSAmJiAwICE9PSBkKSBmb3IgKGcgPSAwOyAzID4gZzsgZysrKSB1W2ddICs9IHIoMjU1ICogZCksIDAgPiB1W2ddICYmICh1W2ddID0gMCksIDI1NSA8IHVbZ10gJiYgKHVbZ10gPSAyNTUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLnNldE9wYWNpdHkgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB0aGlzLnJnYmFbM10gPSBkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLnR3ZWVuVG8gPSBmdW5jdGlvbiAoZCwgZykge1xuICAgICAgICB2YXIgdSA9IHRoaXMucmdiYSxcbiAgICAgICAgICAgIEEgPSBkLnJnYmE7XG4gICAgICAgIEEubGVuZ3RoICYmIHUgJiYgdS5sZW5ndGggPyAoZCA9IDEgIT09IEFbM10gfHwgMSAhPT0gdVszXSwgZyA9IChkID8gXCJyZ2JhKFwiIDogXCJyZ2IoXCIpICsgTWF0aC5yb3VuZChBWzBdICsgKHVbMF0gLSBBWzBdKSAqICgxIC0gZykpICsgXCIsXCIgKyBNYXRoLnJvdW5kKEFbMV0gKyAodVsxXSAtIEFbMV0pICogKDEgLSBnKSkgKyBcIixcIiArIE1hdGgucm91bmQoQVsyXSArICh1WzJdIC0gQVsyXSkgKiAoMSAtIGcpKSArIChkID8gXCIsXCIgKyAoQVszXSArICh1WzNdIC0gQVszXSkgKiAoMSAtIGcpKSA6IFwiXCIpICsgXCIpXCIpIDogZyA9IGQuaW5wdXQgfHwgXCJub25lXCI7XG4gICAgICAgIHJldHVybiBnO1xuICAgICAgfTtcblxuICAgICAgZC5uYW1lcyA9IHtcbiAgICAgICAgd2hpdGU6IFwiI2ZmZmZmZlwiLFxuICAgICAgICBibGFjazogXCIjMDAwMDAwXCJcbiAgICAgIH07XG4gICAgICByZXR1cm4gZDtcbiAgICB9KCk7XG5cbiAgICBkLkNvbG9yID0gZztcbiAgICBkLmNvbG9yID0gZy5wYXJzZTtcbiAgICByZXR1cm4gZC5Db2xvcjtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9TdmdSZW5kZXJlci5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9Db2xvci5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnLCByKSB7XG4gICAgdmFyIHUgPSBnLnBhcnNlLFxuICAgICAgICBJID0gci5hZGRFdmVudCxcbiAgICAgICAgTSA9IHIuYW5pbWF0ZSxcbiAgICAgICAgRSA9IHIuYW5pbU9iamVjdCxcbiAgICAgICAgQSA9IHIuYXR0cixcbiAgICAgICAgRyA9IHIuY3JlYXRlRWxlbWVudCxcbiAgICAgICAgSiA9IHIuY3NzLFxuICAgICAgICB5ID0gci5kZWZpbmVkLFxuICAgICAgICB0ID0gci5kZXN0cm95T2JqZWN0UHJvcGVydGllcyxcbiAgICAgICAgRCA9IHIuZXJhc2UsXG4gICAgICAgIGggPSByLmV4dGVuZCxcbiAgICAgICAgTiA9IHIuaW5BcnJheSxcbiAgICAgICAgcSA9IHIuaXNBcnJheSxcbiAgICAgICAgUCA9IHIuaXNOdW1iZXIsXG4gICAgICAgIGUgPSByLmlzT2JqZWN0LFxuICAgICAgICBjID0gci5pc1N0cmluZyxcbiAgICAgICAgayA9IHIubWVyZ2UsXG4gICAgICAgIG4gPSByLm9iamVjdEVhY2gsXG4gICAgICAgIGYgPSByLnBpY2ssXG4gICAgICAgIGEgPSByLnBJbnQsXG4gICAgICAgIGwgPSByLnJlbW92ZUV2ZW50LFxuICAgICAgICB2ID0gci5zcGxhdCxcbiAgICAgICAgeiA9IHIuc3RvcCxcbiAgICAgICAgdyA9IHIudW5pcXVlS2V5LFxuICAgICAgICBCID0gZC5jaGFydHMsXG4gICAgICAgIEwgPSBkLmRlZzJyYWQsXG4gICAgICAgIFEgPSBkLmRvYyxcbiAgICAgICAgSCA9IGQuaGFzVG91Y2gsXG4gICAgICAgIEsgPSBkLmlzRmlyZWZveCxcbiAgICAgICAgcCA9IGQuaXNNUyxcbiAgICAgICAgYiA9IGQuaXNXZWJLaXQsXG4gICAgICAgIEMgPSBkLm5vb3AsXG4gICAgICAgIHggPSBkLnN2ZyxcbiAgICAgICAgUiA9IGQuU1ZHX05TLFxuICAgICAgICBPID0gZC5zeW1ib2xTaXplcyxcbiAgICAgICAgWCA9IGQud2luO1xuXG4gICAgdmFyIFUgPSBkLlNWR0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgaChVLnByb3RvdHlwZSwge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIFNWR19OUzogUixcbiAgICAgIHRleHRQcm9wczogXCJkaXJlY3Rpb24gZm9udFNpemUgZm9udFdlaWdodCBmb250RmFtaWx5IGZvbnRTdHlsZSBjb2xvciBsaW5lSGVpZ2h0IHdpZHRoIHRleHRBbGlnbiB0ZXh0RGVjb3JhdGlvbiB0ZXh0T3ZlcmZsb3cgdGV4dE91dGxpbmUgY3Vyc29yXCIuc3BsaXQoXCIgXCIpLFxuICAgICAgaW5pdDogZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gXCJzcGFuXCIgPT09IGEgPyBHKGEpIDogUS5jcmVhdGVFbGVtZW50TlModGhpcy5TVkdfTlMsIGEpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gYjtcbiAgICAgICAgZC5maXJlRXZlbnQodGhpcywgXCJhZnRlckluaXRcIik7XG4gICAgICB9LFxuICAgICAgYW5pbWF0ZTogZnVuY3Rpb24gKGIsIGEsIGMpIHtcbiAgICAgICAgdmFyIG0gPSBFKGYoYSwgdGhpcy5yZW5kZXJlci5nbG9iYWxBbmltYXRpb24sICEwKSk7XG4gICAgICAgIGYoUS5oaWRkZW4sIFEubXNIaWRkZW4sIFEud2Via2l0SGlkZGVuLCAhMSkgJiYgKG0uZHVyYXRpb24gPSAwKTtcbiAgICAgICAgMCAhPT0gbS5kdXJhdGlvbiA/IChjICYmIChtLmNvbXBsZXRlID0gYyksIE0odGhpcywgYiwgbSkpIDogKHRoaXMuYXR0cihiLCB2b2lkIDAsIGMpLCBuKGIsIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgbS5zdGVwICYmIG0uc3RlcC5jYWxsKHRoaXMsIGIsIHtcbiAgICAgICAgICAgIHByb3A6IGEsXG4gICAgICAgICAgICBwb3M6IDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBjb21wbGV4Q29sb3I6IGZ1bmN0aW9uIChiLCBhLCBmKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5yZW5kZXJlcixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBwLFxuICAgICAgICAgICAgZSxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICBULFxuICAgICAgICAgICAgQyxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgeixcbiAgICAgICAgICAgIFosXG4gICAgICAgICAgICBPLFxuICAgICAgICAgICAgUiA9IFtdLFxuICAgICAgICAgICAgQjtcbiAgICAgICAgZC5maXJlRXZlbnQodGhpcy5yZW5kZXJlciwgXCJjb21wbGV4Q29sb3JcIiwge1xuICAgICAgICAgIGFyZ3M6IGFyZ3VtZW50c1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYi5yYWRpYWxHcmFkaWVudCA/IHAgPSBcInJhZGlhbEdyYWRpZW50XCIgOiBiLmxpbmVhckdyYWRpZW50ICYmIChwID0gXCJsaW5lYXJHcmFkaWVudFwiKTtcbiAgICAgICAgICBwICYmIChlID0gYltwXSwgVCA9IG0uZ3JhZGllbnRzLCBsID0gYi5zdG9wcywgWiA9IGYucmFkaWFsUmVmZXJlbmNlLCBxKGUpICYmIChiW3BdID0gZSA9IHtcbiAgICAgICAgICAgIHgxOiBlWzBdLFxuICAgICAgICAgICAgeTE6IGVbMV0sXG4gICAgICAgICAgICB4MjogZVsyXSxcbiAgICAgICAgICAgIHkyOiBlWzNdLFxuICAgICAgICAgICAgZ3JhZGllbnRVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiXG4gICAgICAgICAgfSksIFwicmFkaWFsR3JhZGllbnRcIiA9PT0gcCAmJiBaICYmICF5KGUuZ3JhZGllbnRVbml0cykgJiYgKHggPSBlLCBlID0gayhlLCBtLmdldFJhZGlhbEF0dHIoWiwgeCksIHtcbiAgICAgICAgICAgIGdyYWRpZW50VW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIlxuICAgICAgICAgIH0pKSwgbihlLCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgICAgXCJpZFwiICE9PSBhICYmIFIucHVzaChhLCBiKTtcbiAgICAgICAgICB9KSwgbihsLCBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgUi5wdXNoKGIpO1xuICAgICAgICAgIH0pLCBSID0gUi5qb2luKFwiLFwiKSwgVFtSXSA/IE8gPSBUW1JdLmF0dHIoXCJpZFwiKSA6IChlLmlkID0gTyA9IHcoKSwgVFtSXSA9IEMgPSBtLmNyZWF0ZUVsZW1lbnQocCkuYXR0cihlKS5hZGQobS5kZWZzKSwgQy5yYWRBdHRyID0geCwgQy5zdG9wcyA9IFtdLCBsLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIDAgPT09IGJbMV0uaW5kZXhPZihcInJnYmFcIikgPyAoYyA9IHUoYlsxXSksIHYgPSBjLmdldChcInJnYlwiKSwgeiA9IGMuZ2V0KFwiYVwiKSkgOiAodiA9IGJbMV0sIHogPSAxKTtcbiAgICAgICAgICAgIGIgPSBtLmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIpLmF0dHIoe1xuICAgICAgICAgICAgICBvZmZzZXQ6IGJbMF0sXG4gICAgICAgICAgICAgIFwic3RvcC1jb2xvclwiOiB2LFxuICAgICAgICAgICAgICBcInN0b3Atb3BhY2l0eVwiOiB6XG4gICAgICAgICAgICB9KS5hZGQoQyk7XG4gICAgICAgICAgICBDLnN0b3BzLnB1c2goYik7XG4gICAgICAgICAgfSkpLCBCID0gXCJ1cmwoXCIgKyBtLnVybCArIFwiI1wiICsgTyArIFwiKVwiLCBmLnNldEF0dHJpYnV0ZShhLCBCKSwgZi5ncmFkaWVudCA9IFIsIGIudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gQjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgYXBwbHlUZXh0T3V0bGluZTogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgICBtO1xuICAgICAgICAtMSAhPT0gYi5pbmRleE9mKFwiY29udHJhc3RcIikgJiYgKGIgPSBiLnJlcGxhY2UoL2NvbnRyYXN0L2csIHRoaXMucmVuZGVyZXIuZ2V0Q29udHJhc3QoYS5zdHlsZS5maWxsKSkpO1xuICAgICAgICBiID0gYi5zcGxpdChcIiBcIik7XG4gICAgICAgIHZhciBmID0gYltiLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmICgobSA9IGJbMF0pICYmIFwibm9uZVwiICE9PSBtICYmIGQuc3ZnKSB7XG4gICAgICAgICAgdGhpcy5mYWtlVFMgPSAhMDtcbiAgICAgICAgICBiID0gW10uc2xpY2UuY2FsbChhLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidHNwYW5cIikpO1xuICAgICAgICAgIHRoaXMueVNldHRlciA9IHRoaXMueFNldHRlcjtcbiAgICAgICAgICBtID0gbS5yZXBsYWNlKC8oXltcXGRcXC5dKykoLio/KSQvZywgZnVuY3Rpb24gKGIsIGEsIG0pIHtcbiAgICAgICAgICAgIHJldHVybiAyICogYSArIG07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5yZW1vdmVUZXh0T3V0bGluZShiKTtcbiAgICAgICAgICB2YXIgYyA9IGEudGV4dENvbnRlbnQgPyAvXltcXHUwNTkxLVxcdTA2NUZcXHUwNjZBLVxcdTA3RkZcXHVGQjFELVxcdUZERkRcXHVGRTcwLVxcdUZFRkNdLy50ZXN0KGEudGV4dENvbnRlbnQpIDogITE7XG4gICAgICAgICAgdmFyIHAgPSBhLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgYi5mb3JFYWNoKGZ1bmN0aW9uIChiLCBlKSB7XG4gICAgICAgICAgICAwID09PSBlICYmIChiLnNldEF0dHJpYnV0ZShcInhcIiwgYS5nZXRBdHRyaWJ1dGUoXCJ4XCIpKSwgZSA9IGEuZ2V0QXR0cmlidXRlKFwieVwiKSwgYi5zZXRBdHRyaWJ1dGUoXCJ5XCIsIGUgfHwgMCksIG51bGwgPT09IGUgJiYgYS5zZXRBdHRyaWJ1dGUoXCJ5XCIsIDApKTtcbiAgICAgICAgICAgIGUgPSBiLmNsb25lTm9kZSghMCk7XG4gICAgICAgICAgICBBKGMgJiYgIUsgPyBiIDogZSwge1xuICAgICAgICAgICAgICBcImNsYXNzXCI6IFwiaGlnaGNoYXJ0cy10ZXh0LW91dGxpbmVcIixcbiAgICAgICAgICAgICAgZmlsbDogZixcbiAgICAgICAgICAgICAgc3Ryb2tlOiBmLFxuICAgICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBtLFxuICAgICAgICAgICAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInJvdW5kXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYS5pbnNlcnRCZWZvcmUoZSwgcCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYyAmJiBLICYmIGJbMF0gJiYgKGIgPSBiWzBdLmNsb25lTm9kZSghMCksIGIudGV4dENvbnRlbnQgPSBcIiBcIiwgYS5pbnNlcnRCZWZvcmUoYiwgcCkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVtb3ZlVGV4dE91dGxpbmU6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIGZvciAodmFyIGEgPSBiLmxlbmd0aCwgbTsgYS0tOykgbSA9IGJbYV0sIFwiaGlnaGNoYXJ0cy10ZXh0LW91dGxpbmVcIiA9PT0gbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSAmJiBEKGIsIHRoaXMuZWxlbWVudC5yZW1vdmVDaGlsZChtKSk7XG4gICAgICB9LFxuICAgICAgc3ltYm9sQ3VzdG9tQXR0cmliczogXCJ4IHkgd2lkdGggaGVpZ2h0IHIgc3RhcnQgZW5kIGlubmVyUiBhbmNob3JYIGFuY2hvclkgcm91bmRlZFwiLnNwbGl0KFwiIFwiKSxcbiAgICAgIGF0dHI6IGZ1bmN0aW9uIChiLCBhLCBmLCBjKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgcCxcbiAgICAgICAgICAgIGUgPSB0aGlzLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIEMsXG4gICAgICAgICAgICBsID0gdGhpcy5zeW1ib2xDdXN0b21BdHRyaWJzO1xuXG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgYiAmJiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYSkge1xuICAgICAgICAgIHZhciBUID0gYjtcbiAgICAgICAgICBiID0ge307XG4gICAgICAgICAgYltUXSA9IGE7XG4gICAgICAgIH1cblxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgYiA/IGUgPSAodGhpc1tiICsgXCJHZXR0ZXJcIl0gfHwgdGhpcy5fZGVmYXVsdEdldHRlcikuY2FsbCh0aGlzLCBiLCBtKSA6IChuKGIsIGZ1bmN0aW9uIChhLCBmKSB7XG4gICAgICAgICAgeCA9ICExO1xuICAgICAgICAgIGMgfHwgeih0aGlzLCBmKTtcbiAgICAgICAgICB0aGlzLnN5bWJvbE5hbWUgJiYgLTEgIT09IE4oZiwgbCkgJiYgKHAgfHwgKHRoaXMuc3ltYm9sQXR0cihiKSwgcCA9ICEwKSwgeCA9ICEwKTtcbiAgICAgICAgICAhdGhpcy5yb3RhdGlvbiB8fCBcInhcIiAhPT0gZiAmJiBcInlcIiAhPT0gZiB8fCAodGhpcy5kb1RyYW5zZm9ybSA9ICEwKTtcbiAgICAgICAgICB4IHx8IChDID0gdGhpc1tmICsgXCJTZXR0ZXJcIl0gfHwgdGhpcy5fZGVmYXVsdFNldHRlciwgQy5jYWxsKHRoaXMsIGEsIGYsIG0pLCAhdGhpcy5zdHlsZWRNb2RlICYmIHRoaXMuc2hhZG93cyAmJiAvXih3aWR0aHxoZWlnaHR8dmlzaWJpbGl0eXx4fHl8ZHx0cmFuc2Zvcm18Y3h8Y3l8cikkLy50ZXN0KGYpICYmIHRoaXMudXBkYXRlU2hhZG93cyhmLCBhLCBDKSk7XG4gICAgICAgIH0sIHRoaXMpLCB0aGlzLmFmdGVyU2V0dGVycygpKTtcbiAgICAgICAgZiAmJiBmLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfSxcbiAgICAgIGFmdGVyU2V0dGVyczogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRvVHJhbnNmb3JtICYmICh0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpLCB0aGlzLmRvVHJhbnNmb3JtID0gITEpO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZVNoYWRvd3M6IGZ1bmN0aW9uIChiLCBhLCBmKSB7XG4gICAgICAgIGZvciAodmFyIG0gPSB0aGlzLnNoYWRvd3MsIGMgPSBtLmxlbmd0aDsgYy0tOykgZi5jYWxsKG1bY10sIFwiaGVpZ2h0XCIgPT09IGIgPyBNYXRoLm1heChhIC0gKG1bY10uY3V0SGVpZ2h0IHx8IDApLCAwKSA6IFwiZFwiID09PSBiID8gdGhpcy5kIDogYSwgYiwgbVtjXSk7XG4gICAgICB9LFxuICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIHZhciBtID0gYSA/IFwiXCIgOiB0aGlzLmF0dHIoXCJjbGFzc1wiKSB8fCBcIlwiO1xuICAgICAgICBiID0gKGIgfHwgXCJcIikuc3BsaXQoLyAvZykucmVkdWNlKGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgLTEgPT09IG0uaW5kZXhPZihhKSAmJiBiLnB1c2goYSk7XG4gICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH0sIG0gPyBbbV0gOiBbXSkuam9pbihcIiBcIik7XG4gICAgICAgIGIgIT09IG0gJiYgdGhpcy5hdHRyKFwiY2xhc3NcIiwgYik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGhhc0NsYXNzOiBmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gLTEgIT09ICh0aGlzLmF0dHIoXCJjbGFzc1wiKSB8fCBcIlwiKS5zcGxpdChcIiBcIikuaW5kZXhPZihiKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cihcImNsYXNzXCIsICh0aGlzLmF0dHIoXCJjbGFzc1wiKSB8fCBcIlwiKS5yZXBsYWNlKGMoYikgPyBuZXcgUmVnRXhwKFwiID9cIiArIGIgKyBcIiA/XCIpIDogYiwgXCJcIikpO1xuICAgICAgfSxcbiAgICAgIHN5bWJvbEF0dHI6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgXCJ4IHkgciBzdGFydCBlbmQgd2lkdGggaGVpZ2h0IGlubmVyUiBhbmNob3JYIGFuY2hvclkgY2xvY2t3aXNlXCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICBhW21dID0gZihiW21dLCBhW21dKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGEuYXR0cih7XG4gICAgICAgICAgZDogYS5yZW5kZXJlci5zeW1ib2xzW2Euc3ltYm9sTmFtZV0oYS54LCBhLnksIGEud2lkdGgsIGEuaGVpZ2h0LCBhKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBjbGlwOiBmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKFwiY2xpcC1wYXRoXCIsIGIgPyBcInVybChcIiArIHRoaXMucmVuZGVyZXIudXJsICsgXCIjXCIgKyBiLmlkICsgXCIpXCIgOiBcIm5vbmVcIik7XG4gICAgICB9LFxuICAgICAgY3Jpc3A6IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIGEgPSBhIHx8IGIuc3Ryb2tlV2lkdGggfHwgMDtcbiAgICAgICAgdmFyIG0gPSBNYXRoLnJvdW5kKGEpICUgMiAvIDI7XG4gICAgICAgIGIueCA9IE1hdGguZmxvb3IoYi54IHx8IHRoaXMueCB8fCAwKSArIG07XG4gICAgICAgIGIueSA9IE1hdGguZmxvb3IoYi55IHx8IHRoaXMueSB8fCAwKSArIG07XG4gICAgICAgIGIud2lkdGggPSBNYXRoLmZsb29yKChiLndpZHRoIHx8IHRoaXMud2lkdGggfHwgMCkgLSAyICogbSk7XG4gICAgICAgIGIuaGVpZ2h0ID0gTWF0aC5mbG9vcigoYi5oZWlnaHQgfHwgdGhpcy5oZWlnaHQgfHwgMCkgLSAyICogbSk7XG4gICAgICAgIHkoYi5zdHJva2VXaWR0aCkgJiYgKGIuc3Ryb2tlV2lkdGggPSBhKTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9LFxuICAgICAgY3NzOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgbSA9IHRoaXMuc3R5bGVzLFxuICAgICAgICAgICAgZiA9IHt9LFxuICAgICAgICAgICAgYyA9IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgIHAgPSBcIlwiLFxuICAgICAgICAgICAgZSA9ICFtLFxuICAgICAgICAgICAgQyA9IFtcInRleHRPdXRsaW5lXCIsIFwidGV4dE92ZXJmbG93XCIsIFwid2lkdGhcIl07XG4gICAgICAgIGIgJiYgYi5jb2xvciAmJiAoYi5maWxsID0gYi5jb2xvcik7XG4gICAgICAgIG0gJiYgbihiLCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIGIgIT09IG1bYV0gJiYgKGZbYV0gPSBiLCBlID0gITApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIG0gJiYgKGIgPSBoKG0sIGYpKTtcbiAgICAgICAgICBpZiAoYikgaWYgKG51bGwgPT09IGIud2lkdGggfHwgXCJhdXRvXCIgPT09IGIud2lkdGgpIGRlbGV0ZSB0aGlzLnRleHRXaWR0aDtlbHNlIGlmIChcInRleHRcIiA9PT0gYy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICYmIGIud2lkdGgpIHZhciBsID0gdGhpcy50ZXh0V2lkdGggPSBhKGIud2lkdGgpO1xuICAgICAgICAgIHRoaXMuc3R5bGVzID0gYjtcbiAgICAgICAgICBsICYmICF4ICYmIHRoaXMucmVuZGVyZXIuZm9yRXhwb3J0ICYmIGRlbGV0ZSBiLndpZHRoO1xuXG4gICAgICAgICAgaWYgKGMubmFtZXNwYWNlVVJJID09PSB0aGlzLlNWR19OUykge1xuICAgICAgICAgICAgdmFyIGsgPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCItXCIgKyBhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBuKGIsIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgICAgIC0xID09PSBDLmluZGV4T2YoYSkgJiYgKHAgKz0gYS5yZXBsYWNlKC8oW0EtWl0pL2csIGspICsgXCI6XCIgKyBiICsgXCI7XCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwICYmIEEoYywgXCJzdHlsZVwiLCBwKTtcbiAgICAgICAgICB9IGVsc2UgSihjLCBiKTtcblxuICAgICAgICAgIHRoaXMuYWRkZWQgJiYgKFwidGV4dFwiID09PSB0aGlzLmVsZW1lbnQubm9kZU5hbWUgJiYgdGhpcy5yZW5kZXJlci5idWlsZFRleHQodGhpcyksIGIgJiYgYi50ZXh0T3V0bGluZSAmJiB0aGlzLmFwcGx5VGV4dE91dGxpbmUoYi50ZXh0T3V0bGluZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZ2V0U3R5bGU6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHJldHVybiBYLmdldENvbXB1dGVkU3R5bGUodGhpcy5lbGVtZW50IHx8IHRoaXMsIFwiXCIpLmdldFByb3BlcnR5VmFsdWUoYik7XG4gICAgICB9LFxuICAgICAgc3Ryb2tlV2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVyLnN0eWxlZE1vZGUpIHJldHVybiB0aGlzW1wic3Ryb2tlLXdpZHRoXCJdIHx8IDA7XG4gICAgICAgIHZhciBiID0gdGhpcy5nZXRTdHlsZShcInN0cm9rZS13aWR0aFwiKSxcbiAgICAgICAgICAgIGYgPSAwO1xuICAgICAgICBpZiAoYi5pbmRleE9mKFwicHhcIikgPT09IGIubGVuZ3RoIC0gMikgZiA9IGEoYik7ZWxzZSBpZiAoXCJcIiAhPT0gYikge1xuICAgICAgICAgIHZhciBjID0gUS5jcmVhdGVFbGVtZW50TlMoUiwgXCJyZWN0XCIpO1xuICAgICAgICAgIEEoYywge1xuICAgICAgICAgICAgd2lkdGg6IGIsXG4gICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgZiA9IGMuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICAgIGMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH0sXG4gICAgICBvbjogZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgdmFyIG0sXG4gICAgICAgICAgICBmLFxuICAgICAgICAgICAgYyA9IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgIHA7XG4gICAgICAgIEggJiYgXCJjbGlja1wiID09PSBiID8gKGMub250b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBtID0gYi50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgICAgZiA9IGIudG91Y2hlc1swXS5jbGllbnRZO1xuICAgICAgICB9LCBjLm9udG91Y2hlbmQgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIG0gJiYgNCA8PSBNYXRoLnNxcnQoTWF0aC5wb3cobSAtIGIuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCwgMikgKyBNYXRoLnBvdyhmIC0gYi5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZLCAyKSkgfHwgYS5jYWxsKGMsIGIpO1xuICAgICAgICAgIHAgPSAhMDtcbiAgICAgICAgICBiLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0sIGMub25jbGljayA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgcCB8fCBhLmNhbGwoYywgYik7XG4gICAgICAgIH0pIDogY1tcIm9uXCIgKyBiXSA9IGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHNldFJhZGlhbFJlZmVyZW5jZTogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLnJlbmRlcmVyLmdyYWRpZW50c1t0aGlzLmVsZW1lbnQuZ3JhZGllbnRdO1xuICAgICAgICB0aGlzLmVsZW1lbnQucmFkaWFsUmVmZXJlbmNlID0gYjtcbiAgICAgICAgYSAmJiBhLnJhZEF0dHIgJiYgYS5hbmltYXRlKHRoaXMucmVuZGVyZXIuZ2V0UmFkaWFsQXR0cihiLCBhLnJhZEF0dHIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKHtcbiAgICAgICAgICB0cmFuc2xhdGVYOiBiLFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IGFcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgaW52ZXJ0OiBmdW5jdGlvbiAoYikge1xuICAgICAgICB0aGlzLmludmVydGVkID0gYjtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgdXBkYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy50cmFuc2xhdGVYIHx8IDAsXG4gICAgICAgICAgICBhID0gdGhpcy50cmFuc2xhdGVZIHx8IDAsXG4gICAgICAgICAgICBjID0gdGhpcy5zY2FsZVgsXG4gICAgICAgICAgICBwID0gdGhpcy5zY2FsZVksXG4gICAgICAgICAgICBlID0gdGhpcy5pbnZlcnRlZCxcbiAgICAgICAgICAgIHggPSB0aGlzLnJvdGF0aW9uLFxuICAgICAgICAgICAgQyA9IHRoaXMubWF0cml4LFxuICAgICAgICAgICAgbCA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgZSAmJiAoYiArPSB0aGlzLndpZHRoLCBhICs9IHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgYiA9IFtcInRyYW5zbGF0ZShcIiArIGIgKyBcIixcIiArIGEgKyBcIilcIl07XG4gICAgICAgIHkoQykgJiYgYi5wdXNoKFwibWF0cml4KFwiICsgQy5qb2luKFwiLFwiKSArIFwiKVwiKTtcbiAgICAgICAgZSA/IGIucHVzaChcInJvdGF0ZSg5MCkgc2NhbGUoLTEsMSlcIikgOiB4ICYmIGIucHVzaChcInJvdGF0ZShcIiArIHggKyBcIiBcIiArIGYodGhpcy5yb3RhdGlvbk9yaWdpblgsIGwuZ2V0QXR0cmlidXRlKFwieFwiKSwgMCkgKyBcIiBcIiArIGYodGhpcy5yb3RhdGlvbk9yaWdpblksIGwuZ2V0QXR0cmlidXRlKFwieVwiKSB8fCAwKSArIFwiKVwiKTtcbiAgICAgICAgKHkoYykgfHwgeShwKSkgJiYgYi5wdXNoKFwic2NhbGUoXCIgKyBmKGMsIDEpICsgXCIgXCIgKyBmKHAsIDEpICsgXCIpXCIpO1xuICAgICAgICBiLmxlbmd0aCAmJiBsLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBiLmpvaW4oXCIgXCIpKTtcbiAgICAgIH0sXG4gICAgICB0b0Zyb250OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBiLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoYik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGFsaWduOiBmdW5jdGlvbiAoYiwgYSwgcCkge1xuICAgICAgICB2YXIgbSxcbiAgICAgICAgICAgIGUgPSB7fTtcbiAgICAgICAgdmFyIHggPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICB2YXIgQyA9IHguYWxpZ25lZE9iamVjdHM7XG4gICAgICAgIHZhciBsLCBrO1xuXG4gICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYWxpZ25PcHRpb25zID0gYiwgdGhpcy5hbGlnbkJ5VHJhbnNsYXRlID0gYSwgIXAgfHwgYyhwKSkgdGhpcy5hbGlnblRvID0gbSA9IHAgfHwgXCJyZW5kZXJlclwiLCBEKEMsIHRoaXMpLCBDLnB1c2godGhpcyksIHAgPSBudWxsO1xuICAgICAgICB9IGVsc2UgYiA9IHRoaXMuYWxpZ25PcHRpb25zLCBhID0gdGhpcy5hbGlnbkJ5VHJhbnNsYXRlLCBtID0gdGhpcy5hbGlnblRvO1xuXG4gICAgICAgIHAgPSBmKHAsIHhbbV0sIHgpO1xuICAgICAgICBtID0gYi5hbGlnbjtcbiAgICAgICAgeCA9IGIudmVydGljYWxBbGlnbjtcbiAgICAgICAgQyA9IChwLnggfHwgMCkgKyAoYi54IHx8IDApO1xuICAgICAgICB2YXIgVCA9IChwLnkgfHwgMCkgKyAoYi55IHx8IDApO1xuICAgICAgICBcInJpZ2h0XCIgPT09IG0gPyBsID0gMSA6IFwiY2VudGVyXCIgPT09IG0gJiYgKGwgPSAyKTtcbiAgICAgICAgbCAmJiAoQyArPSAocC53aWR0aCAtIChiLndpZHRoIHx8IDApKSAvIGwpO1xuICAgICAgICBlW2EgPyBcInRyYW5zbGF0ZVhcIiA6IFwieFwiXSA9IE1hdGgucm91bmQoQyk7XG4gICAgICAgIFwiYm90dG9tXCIgPT09IHggPyBrID0gMSA6IFwibWlkZGxlXCIgPT09IHggJiYgKGsgPSAyKTtcbiAgICAgICAgayAmJiAoVCArPSAocC5oZWlnaHQgLSAoYi5oZWlnaHQgfHwgMCkpIC8gayk7XG4gICAgICAgIGVbYSA/IFwidHJhbnNsYXRlWVwiIDogXCJ5XCJdID0gTWF0aC5yb3VuZChUKTtcbiAgICAgICAgdGhpc1t0aGlzLnBsYWNlZCA/IFwiYW5pbWF0ZVwiIDogXCJhdHRyXCJdKGUpO1xuICAgICAgICB0aGlzLnBsYWNlZCA9ICEwO1xuICAgICAgICB0aGlzLmFsaWduQXR0ciA9IGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGdldEJCb3g6IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIHZhciBtLFxuICAgICAgICAgICAgYyA9IHRoaXMucmVuZGVyZXIsXG4gICAgICAgICAgICBwID0gdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgZSA9IHRoaXMuc3R5bGVzLFxuICAgICAgICAgICAgeCA9IHRoaXMudGV4dFN0cixcbiAgICAgICAgICAgIEMsXG4gICAgICAgICAgICBsID0gYy5jYWNoZSxcbiAgICAgICAgICAgIGsgPSBjLmNhY2hlS2V5cyxcbiAgICAgICAgICAgIFQgPSBwLm5hbWVzcGFjZVVSSSA9PT0gdGhpcy5TVkdfTlM7XG4gICAgICAgIGEgPSBmKGEsIHRoaXMucm90YXRpb24sIDApO1xuICAgICAgICB2YXIgbiA9IGMuc3R5bGVkTW9kZSA/IHAgJiYgVS5wcm90b3R5cGUuZ2V0U3R5bGUuY2FsbChwLCBcImZvbnQtc2l6ZVwiKSA6IGUgJiYgZS5mb250U2l6ZTtcblxuICAgICAgICBpZiAoeSh4KSkge1xuICAgICAgICAgIHZhciB2ID0geC50b1N0cmluZygpO1xuICAgICAgICAgIC0xID09PSB2LmluZGV4T2YoXCI8XCIpICYmICh2ID0gdi5yZXBsYWNlKC9bMC05XS9nLCBcIjBcIikpO1xuICAgICAgICAgIHYgKz0gW1wiXCIsIGEsIG4sIHRoaXMudGV4dFdpZHRoLCBlICYmIGUudGV4dE92ZXJmbG93XS5qb2luKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2ICYmICFiICYmIChtID0gbFt2XSk7XG5cbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgaWYgKFQgfHwgYy5mb3JFeHBvcnQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIChDID0gdGhpcy5mYWtlVFMgJiYgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgICBbXS5mb3JFYWNoLmNhbGwocC5xdWVyeVNlbGVjdG9yQWxsKFwiLmhpZ2hjaGFydHMtdGV4dC1vdXRsaW5lXCIpLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgYS5zdHlsZS5kaXNwbGF5ID0gYjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSkgJiYgQyhcIm5vbmVcIiksIG0gPSBwLmdldEJCb3ggPyBoKHt9LCBwLmdldEJCb3goKSkgOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHAub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBwLm9mZnNldEhlaWdodFxuICAgICAgICAgICAgICB9LCBDICYmIEMoXCJcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChlYSkge1xuICAgICAgICAgICAgICBcIlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW0gfHwgMCA+IG0ud2lkdGgpIG0gPSB7XG4gICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIG0gPSB0aGlzLmh0bWxHZXRCQm94KCk7XG5cbiAgICAgICAgICBjLmlzU1ZHICYmIChiID0gbS53aWR0aCwgYyA9IG0uaGVpZ2h0LCBUICYmIChtLmhlaWdodCA9IGMgPSB7XG4gICAgICAgICAgICBcIjExcHgsMTdcIjogMTQsXG4gICAgICAgICAgICBcIjEzcHgsMjBcIjogMTZcbiAgICAgICAgICB9W2UgJiYgZS5mb250U2l6ZSArIFwiLFwiICsgTWF0aC5yb3VuZChjKV0gfHwgYyksIGEgJiYgKGUgPSBhICogTCwgbS53aWR0aCA9IE1hdGguYWJzKGMgKiBNYXRoLnNpbihlKSkgKyBNYXRoLmFicyhiICogTWF0aC5jb3MoZSkpLCBtLmhlaWdodCA9IE1hdGguYWJzKGMgKiBNYXRoLmNvcyhlKSkgKyBNYXRoLmFicyhiICogTWF0aC5zaW4oZSkpKSk7XG5cbiAgICAgICAgICBpZiAodiAmJiAwIDwgbS5oZWlnaHQpIHtcbiAgICAgICAgICAgIGZvciAoOyAyNTAgPCBrLmxlbmd0aDspIGRlbGV0ZSBsW2suc2hpZnQoKV07XG5cbiAgICAgICAgICAgIGxbdl0gfHwgay5wdXNoKHYpO1xuICAgICAgICAgICAgbFt2XSA9IG07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgICB9LFxuICAgICAgc2hvdzogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cih7XG4gICAgICAgICAgdmlzaWJpbGl0eTogYiA/IFwiaW5oZXJpdFwiIDogXCJ2aXNpYmxlXCJcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgaGlkZTogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgYiA/IHRoaXMuYXR0cih7XG4gICAgICAgICAgeTogLTk5OTlcbiAgICAgICAgfSkgOiB0aGlzLmF0dHIoe1xuICAgICAgICAgIHZpc2liaWxpdHk6IFwiaGlkZGVuXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGZhZGVPdXQ6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgYS5hbmltYXRlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogYiB8fCAxNTAsXG4gICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGEuYXR0cih7XG4gICAgICAgICAgICAgIHk6IC05OTk5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGFkZDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLnJlbmRlcmVyLFxuICAgICAgICAgICAgbSA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgYiAmJiAodGhpcy5wYXJlbnRHcm91cCA9IGIpO1xuICAgICAgICB0aGlzLnBhcmVudEludmVydGVkID0gYiAmJiBiLmludmVydGVkO1xuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgdGhpcy50ZXh0U3RyICYmIGEuYnVpbGRUZXh0KHRoaXMpO1xuICAgICAgICB0aGlzLmFkZGVkID0gITA7XG4gICAgICAgIGlmICghYiB8fCBiLmhhbmRsZVogfHwgdGhpcy56SW5kZXgpIHZhciBmID0gdGhpcy56SW5kZXhTZXR0ZXIoKTtcbiAgICAgICAgZiB8fCAoYiA/IGIuZWxlbWVudCA6IGEuYm94KS5hcHBlbmRDaGlsZChtKTtcbiAgICAgICAgaWYgKHRoaXMub25BZGQpIHRoaXMub25BZGQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgc2FmZVJlbW92ZUNoaWxkOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IGIucGFyZW50Tm9kZTtcbiAgICAgICAgYSAmJiBhLnJlbW92ZUNoaWxkKGIpO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICAgICAgYSA9IGIuZWxlbWVudCB8fCB7fSxcbiAgICAgICAgICAgIGYgPSBiLnJlbmRlcmVyLFxuICAgICAgICAgICAgYyA9IGYuaXNTVkcgJiYgXCJTUEFOXCIgPT09IGEubm9kZU5hbWUgJiYgYi5wYXJlbnRHcm91cCxcbiAgICAgICAgICAgIHAgPSBhLm93bmVyU1ZHRWxlbWVudCxcbiAgICAgICAgICAgIGUgPSBiLmNsaXBQYXRoO1xuICAgICAgICBhLm9uY2xpY2sgPSBhLm9ubW91c2VvdXQgPSBhLm9ubW91c2VvdmVyID0gYS5vbm1vdXNlbW92ZSA9IGEucG9pbnQgPSBudWxsO1xuICAgICAgICB6KGIpO1xuICAgICAgICBlICYmIHAgJiYgKFtdLmZvckVhY2guY2FsbChwLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbY2xpcC1wYXRoXSxbQ0xJUC1QQVRIXVwiKSwgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAtMSA8IGIuZ2V0QXR0cmlidXRlKFwiY2xpcC1wYXRoXCIpLmluZGV4T2YoZS5lbGVtZW50LmlkKSAmJiBiLnJlbW92ZUF0dHJpYnV0ZShcImNsaXAtcGF0aFwiKTtcbiAgICAgICAgfSksIGIuY2xpcFBhdGggPSBlLmRlc3Ryb3koKSk7XG5cbiAgICAgICAgaWYgKGIuc3RvcHMpIHtcbiAgICAgICAgICBmb3IgKHAgPSAwOyBwIDwgYi5zdG9wcy5sZW5ndGg7IHArKykgYi5zdG9wc1twXSA9IGIuc3RvcHNbcF0uZGVzdHJveSgpO1xuXG4gICAgICAgICAgYi5zdG9wcyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBiLnNhZmVSZW1vdmVDaGlsZChhKTtcblxuICAgICAgICBmb3IgKGYuc3R5bGVkTW9kZSB8fCBiLmRlc3Ryb3lTaGFkb3dzKCk7IGMgJiYgYy5kaXYgJiYgMCA9PT0gYy5kaXYuY2hpbGROb2Rlcy5sZW5ndGg7KSBhID0gYy5wYXJlbnRHcm91cCwgYi5zYWZlUmVtb3ZlQ2hpbGQoYy5kaXYpLCBkZWxldGUgYy5kaXYsIGMgPSBhO1xuXG4gICAgICAgIGIuYWxpZ25UbyAmJiBEKGYuYWxpZ25lZE9iamVjdHMsIGIpO1xuICAgICAgICBuKGIsIGZ1bmN0aW9uIChhLCBtKSB7XG4gICAgICAgICAgYlttXSAmJiBiW21dLnBhcmVudEdyb3VwID09PSBiICYmIGJbbV0uZGVzdHJveSAmJiBiW21dLmRlc3Ryb3koKTtcbiAgICAgICAgICBkZWxldGUgYlttXTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc2hhZG93OiBmdW5jdGlvbiAoYiwgYSwgYykge1xuICAgICAgICB2YXIgbSA9IFtdLFxuICAgICAgICAgICAgcCxcbiAgICAgICAgICAgIGUgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIGlmICghYikgdGhpcy5kZXN0cm95U2hhZG93cygpO2Vsc2UgaWYgKCF0aGlzLnNoYWRvd3MpIHtcbiAgICAgICAgICB2YXIgeCA9IGYoYi53aWR0aCwgMyk7XG4gICAgICAgICAgdmFyIEMgPSAoYi5vcGFjaXR5IHx8IC4xNSkgLyB4O1xuICAgICAgICAgIHZhciBsID0gdGhpcy5wYXJlbnRJbnZlcnRlZCA/IFwiKC0xLC0xKVwiIDogXCIoXCIgKyBmKGIub2Zmc2V0WCwgMSkgKyBcIiwgXCIgKyBmKGIub2Zmc2V0WSwgMSkgKyBcIilcIjtcblxuICAgICAgICAgIGZvciAocCA9IDE7IHAgPD0geDsgcCsrKSB7XG4gICAgICAgICAgICB2YXIgayA9IGUuY2xvbmVOb2RlKDApO1xuICAgICAgICAgICAgdmFyIG4gPSAyICogeCArIDEgLSAyICogcDtcbiAgICAgICAgICAgIEEoaywge1xuICAgICAgICAgICAgICBzdHJva2U6IGIuY29sb3IgfHwgXCIjMDAwMDAwXCIsXG4gICAgICAgICAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogQyAqIHAsXG4gICAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IG4sXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVcIiArIGwsXG4gICAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGsuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgKGsuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIikgKyBcIiBoaWdoY2hhcnRzLXNoYWRvd1wiKTtcbiAgICAgICAgICAgIGMgJiYgKEEoaywgXCJoZWlnaHRcIiwgTWF0aC5tYXgoQShrLCBcImhlaWdodFwiKSAtIG4sIDApKSwgay5jdXRIZWlnaHQgPSBuKTtcbiAgICAgICAgICAgIGEgPyBhLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaykgOiBlLnBhcmVudE5vZGUgJiYgZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShrLCBlKTtcbiAgICAgICAgICAgIG0ucHVzaChrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnNoYWRvd3MgPSBtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3lTaGFkb3dzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICh0aGlzLnNoYWRvd3MgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICB0aGlzLnNhZmVSZW1vdmVDaGlsZChiKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuc2hhZG93cyA9IHZvaWQgMDtcbiAgICAgIH0sXG4gICAgICB4R2V0dGVyOiBmdW5jdGlvbiAoYikge1xuICAgICAgICBcImNpcmNsZVwiID09PSB0aGlzLmVsZW1lbnQubm9kZU5hbWUgJiYgKFwieFwiID09PSBiID8gYiA9IFwiY3hcIiA6IFwieVwiID09PSBiICYmIChiID0gXCJjeVwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0R2V0dGVyKGIpO1xuICAgICAgfSxcbiAgICAgIF9kZWZhdWx0R2V0dGVyOiBmdW5jdGlvbiAoYikge1xuICAgICAgICBiID0gZih0aGlzW2IgKyBcIlZhbHVlXCJdLCB0aGlzW2JdLCB0aGlzLmVsZW1lbnQgPyB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKGIpIDogbnVsbCwgMCk7XG4gICAgICAgIC9eW1xcLTAtOVxcLl0rJC8udGVzdChiKSAmJiAoYiA9IHBhcnNlRmxvYXQoYikpO1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0sXG4gICAgICBkU2V0dGVyOiBmdW5jdGlvbiAoYiwgYSwgZikge1xuICAgICAgICBiICYmIGIuam9pbiAmJiAoYiA9IGIuam9pbihcIiBcIikpO1xuICAgICAgICAvKE5hTnwgezJ9fF4kKS8udGVzdChiKSAmJiAoYiA9IFwiTSAwIDBcIik7XG4gICAgICAgIHRoaXNbYV0gIT09IGIgJiYgKGYuc2V0QXR0cmlidXRlKGEsIGIpLCB0aGlzW2FdID0gYik7XG4gICAgICB9LFxuICAgICAgZGFzaHN0eWxlU2V0dGVyOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgZixcbiAgICAgICAgICAgIGMgPSB0aGlzW1wic3Ryb2tlLXdpZHRoXCJdO1xuICAgICAgICBcImluaGVyaXRcIiA9PT0gYyAmJiAoYyA9IDEpO1xuXG4gICAgICAgIGlmIChiID0gYiAmJiBiLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICBiID0gYi5yZXBsYWNlKFwic2hvcnRkYXNoZG90ZG90XCIsIFwiMywxLDEsMSwxLDEsXCIpLnJlcGxhY2UoXCJzaG9ydGRhc2hkb3RcIiwgXCIzLDEsMSwxXCIpLnJlcGxhY2UoXCJzaG9ydGRvdFwiLCBcIjEsMSxcIikucmVwbGFjZShcInNob3J0ZGFzaFwiLCBcIjMsMSxcIikucmVwbGFjZShcImxvbmdkYXNoXCIsIFwiOCwzLFwiKS5yZXBsYWNlKC9kb3QvZywgXCIxLDMsXCIpLnJlcGxhY2UoXCJkYXNoXCIsIFwiNCwzLFwiKS5yZXBsYWNlKC8sJC8sIFwiXCIpLnNwbGl0KFwiLFwiKTtcblxuICAgICAgICAgIGZvciAoZiA9IGIubGVuZ3RoOyBmLS07KSBiW2ZdID0gYShiW2ZdKSAqIGM7XG5cbiAgICAgICAgICBiID0gYi5qb2luKFwiLFwiKS5yZXBsYWNlKC9OYU4vZywgXCJub25lXCIpO1xuICAgICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIGIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWxpZ25TZXR0ZXI6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0ge1xuICAgICAgICAgIGxlZnQ6IFwic3RhcnRcIixcbiAgICAgICAgICBjZW50ZXI6IFwibWlkZGxlXCIsXG4gICAgICAgICAgcmlnaHQ6IFwiZW5kXCJcbiAgICAgICAgfTtcbiAgICAgICAgYVtiXSAmJiAodGhpcy5hbGlnblZhbHVlID0gYiwgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcInRleHQtYW5jaG9yXCIsIGFbYl0pKTtcbiAgICAgIH0sXG4gICAgICBvcGFjaXR5U2V0dGVyOiBmdW5jdGlvbiAoYiwgYSwgZikge1xuICAgICAgICB0aGlzW2FdID0gYjtcbiAgICAgICAgZi5zZXRBdHRyaWJ1dGUoYSwgYik7XG4gICAgICB9LFxuICAgICAgdGl0bGVTZXR0ZXI6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5lbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGl0bGVcIilbMF07XG4gICAgICAgIGEgfHwgKGEgPSBRLmNyZWF0ZUVsZW1lbnROUyh0aGlzLlNWR19OUywgXCJ0aXRsZVwiKSwgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGEpKTtcbiAgICAgICAgYS5maXJzdENoaWxkICYmIGEucmVtb3ZlQ2hpbGQoYS5maXJzdENoaWxkKTtcbiAgICAgICAgYS5hcHBlbmRDaGlsZChRLmNyZWF0ZVRleHROb2RlKFN0cmluZyhmKGIsIFwiXCIpKS5yZXBsYWNlKC88W14+XSo+L2csIFwiXCIpLnJlcGxhY2UoLyZsdDsvZywgXCI8XCIpLnJlcGxhY2UoLyZndDsvZywgXCI+XCIpKSk7XG4gICAgICB9LFxuICAgICAgdGV4dFNldHRlcjogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgYiAhPT0gdGhpcy50ZXh0U3RyICYmIChkZWxldGUgdGhpcy5iQm94LCBkZWxldGUgdGhpcy50ZXh0UHhMZW5ndGgsIHRoaXMudGV4dFN0ciA9IGIsIHRoaXMuYWRkZWQgJiYgdGhpcy5yZW5kZXJlci5idWlsZFRleHQodGhpcykpO1xuICAgICAgfSxcbiAgICAgIHNldFRleHRQYXRoOiBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICB2YXIgZiA9IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgIGMgPSB7XG4gICAgICAgICAgdGV4dEFuY2hvcjogXCJ0ZXh0LWFuY2hvclwiXG4gICAgICAgIH0sXG4gICAgICAgICAgICBtID0gITEsXG4gICAgICAgICAgICBwID0gdGhpcy50ZXh0UGF0aFdyYXBwZXIsXG4gICAgICAgICAgICBlID0gIXA7XG4gICAgICAgIGEgPSBrKCEwLCB7XG4gICAgICAgICAgZW5hYmxlZDogITAsXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgZHk6IC01LFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IFwiNTAlXCIsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiBcIm1pZGRsZVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LCBhKTtcbiAgICAgICAgdmFyIHggPSBhLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgaWYgKGIgJiYgYSAmJiBhLmVuYWJsZWQpIHtcbiAgICAgICAgICBwICYmIG51bGwgPT09IHAuZWxlbWVudC5wYXJlbnROb2RlID8gKGUgPSAhMCwgcCA9IHAuZGVzdHJveSgpKSA6IHAgJiYgdGhpcy5yZW1vdmVUZXh0T3V0bGluZS5jYWxsKHAucGFyZW50R3JvdXAsIFtdLnNsaWNlLmNhbGwoZi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRzcGFuXCIpKSk7XG4gICAgICAgICAgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5wYWRkaW5nICYmICh4LmR4ID0gLXRoaXMub3B0aW9ucy5wYWRkaW5nKTtcbiAgICAgICAgICBwIHx8ICh0aGlzLnRleHRQYXRoV3JhcHBlciA9IHAgPSB0aGlzLnJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0UGF0aFwiKSwgbSA9ICEwKTtcbiAgICAgICAgICB2YXIgbCA9IHAuZWxlbWVudDtcbiAgICAgICAgICAoYSA9IGIuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJpZFwiKSkgfHwgYi5lbGVtZW50LnNldEF0dHJpYnV0ZShcImlkXCIsIGEgPSB3KCkpO1xuICAgICAgICAgIGlmIChlKSBmb3IgKGIgPSBmLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidHNwYW5cIik7IGIubGVuZ3RoOykgYlswXS5zZXRBdHRyaWJ1dGUoXCJ5XCIsIDApLCBQKHguZHgpICYmIGJbMF0uc2V0QXR0cmlidXRlKFwieFwiLCAteC5keCksIGwuYXBwZW5kQ2hpbGQoYlswXSk7XG4gICAgICAgICAgbSAmJiBwLmFkZCh7XG4gICAgICAgICAgICBlbGVtZW50OiB0aGlzLnRleHQgPyB0aGlzLnRleHQuZWxlbWVudCA6IGZcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsLnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBcImhyZWZcIiwgdGhpcy5yZW5kZXJlci51cmwgKyBcIiNcIiArIGEpO1xuICAgICAgICAgIHkoeC5keSkgJiYgKGwucGFyZW50Tm9kZS5zZXRBdHRyaWJ1dGUoXCJkeVwiLCB4LmR5KSwgZGVsZXRlIHguZHkpO1xuICAgICAgICAgIHkoeC5keCkgJiYgKGwucGFyZW50Tm9kZS5zZXRBdHRyaWJ1dGUoXCJkeFwiLCB4LmR4KSwgZGVsZXRlIHguZHgpO1xuICAgICAgICAgIG4oeCwgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICAgIGwuc2V0QXR0cmlidXRlKGNbYV0gfHwgYSwgYik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZi5yZW1vdmVBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG4gICAgICAgICAgdGhpcy5yZW1vdmVUZXh0T3V0bGluZS5jYWxsKHAsIFtdLnNsaWNlLmNhbGwoZi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRzcGFuXCIpKSk7XG4gICAgICAgICAgdGhpcy50ZXh0ICYmICF0aGlzLnJlbmRlcmVyLnN0eWxlZE1vZGUgJiYgdGhpcy5hdHRyKHtcbiAgICAgICAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYXBwbHlUZXh0T3V0bGluZSA9IHRoaXMudXBkYXRlVHJhbnNmb3JtID0gQztcbiAgICAgICAgfSBlbHNlIHAgJiYgKGRlbGV0ZSB0aGlzLnVwZGF0ZVRyYW5zZm9ybSwgZGVsZXRlIHRoaXMuYXBwbHlUZXh0T3V0bGluZSwgdGhpcy5kZXN0cm95VGV4dFBhdGgoZiwgYiksIHRoaXMudXBkYXRlVHJhbnNmb3JtKCksIHRoaXMub3B0aW9ucy5yb3RhdGlvbiAmJiB0aGlzLmFwcGx5VGV4dE91dGxpbmUodGhpcy5vcHRpb25zLnN0eWxlLnRleHRPdXRsaW5lKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZGVzdHJveVRleHRQYXRoOiBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICB2YXIgZiA9IGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0ZXh0XCIpWzBdO1xuXG4gICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgaWYgKGYucmVtb3ZlQXR0cmlidXRlKFwiZHhcIiksIGYucmVtb3ZlQXR0cmlidXRlKFwiZHlcIiksIGEuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcIlwiKSwgZi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRleHRQYXRoXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChiID0gdGhpcy50ZXh0UGF0aFdyYXBwZXIuZWxlbWVudC5jaGlsZE5vZGVzOyBiLmxlbmd0aDspIGYuYXBwZW5kQ2hpbGQoYlswXSk7XG5cbiAgICAgICAgICAgIGYucmVtb3ZlQ2hpbGQodGhpcy50ZXh0UGF0aFdyYXBwZXIuZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGIuZ2V0QXR0cmlidXRlKFwiZHhcIikgfHwgYi5nZXRBdHRyaWJ1dGUoXCJkeVwiKSkgYi5yZW1vdmVBdHRyaWJ1dGUoXCJkeFwiKSwgYi5yZW1vdmVBdHRyaWJ1dGUoXCJkeVwiKTtcblxuICAgICAgICB0aGlzLnRleHRQYXRoV3JhcHBlciA9IHRoaXMudGV4dFBhdGhXcmFwcGVyLmRlc3Ryb3koKTtcbiAgICAgIH0sXG4gICAgICBmaWxsU2V0dGVyOiBmdW5jdGlvbiAoYiwgYSwgZikge1xuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgYiA/IGYuc2V0QXR0cmlidXRlKGEsIGIpIDogYiAmJiB0aGlzLmNvbXBsZXhDb2xvcihiLCBhLCBmKTtcbiAgICAgIH0sXG4gICAgICB2aXNpYmlsaXR5U2V0dGVyOiBmdW5jdGlvbiAoYiwgYSwgZikge1xuICAgICAgICBcImluaGVyaXRcIiA9PT0gYiA/IGYucmVtb3ZlQXR0cmlidXRlKGEpIDogdGhpc1thXSAhPT0gYiAmJiBmLnNldEF0dHJpYnV0ZShhLCBiKTtcbiAgICAgICAgdGhpc1thXSA9IGI7XG4gICAgICB9LFxuICAgICAgekluZGV4U2V0dGVyOiBmdW5jdGlvbiAoYiwgZikge1xuICAgICAgICB2YXIgYyA9IHRoaXMucmVuZGVyZXIsXG4gICAgICAgICAgICBtID0gdGhpcy5wYXJlbnRHcm91cCxcbiAgICAgICAgICAgIHAgPSAobSB8fCBjKS5lbGVtZW50IHx8IGMuYm94LFxuICAgICAgICAgICAgZSA9IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgIHggPSAhMTtcbiAgICAgICAgYyA9IHAgPT09IGMuYm94O1xuICAgICAgICB2YXIgQyA9IHRoaXMuYWRkZWQ7XG4gICAgICAgIHZhciBsO1xuICAgICAgICB5KGIpID8gKGUuc2V0QXR0cmlidXRlKFwiZGF0YS16LWluZGV4XCIsIGIpLCBiID0gK2IsIHRoaXNbZl0gPT09IGIgJiYgKEMgPSAhMSkpIDogeSh0aGlzW2ZdKSAmJiBlLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtei1pbmRleFwiKTtcbiAgICAgICAgdGhpc1tmXSA9IGI7XG5cbiAgICAgICAgaWYgKEMpIHtcbiAgICAgICAgICAoYiA9IHRoaXMuekluZGV4KSAmJiBtICYmIChtLmhhbmRsZVogPSAhMCk7XG4gICAgICAgICAgZiA9IHAuY2hpbGROb2RlcztcblxuICAgICAgICAgIGZvciAobCA9IGYubGVuZ3RoIC0gMTsgMCA8PSBsICYmICF4OyBsLS0pIHtcbiAgICAgICAgICAgIG0gPSBmW2xdO1xuICAgICAgICAgICAgQyA9IG0uZ2V0QXR0cmlidXRlKFwiZGF0YS16LWluZGV4XCIpO1xuICAgICAgICAgICAgdmFyIGsgPSAheShDKTtcbiAgICAgICAgICAgIGlmIChtICE9PSBlKSBpZiAoMCA+IGIgJiYgayAmJiAhYyAmJiAhbCkgcC5pbnNlcnRCZWZvcmUoZSwgZltsXSksIHggPSAhMDtlbHNlIGlmIChhKEMpIDw9IGIgfHwgayAmJiAoIXkoYikgfHwgMCA8PSBiKSkgcC5pbnNlcnRCZWZvcmUoZSwgZltsICsgMV0gfHwgbnVsbCksIHggPSAhMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4IHx8IChwLmluc2VydEJlZm9yZShlLCBmW2MgPyAzIDogMF0gfHwgbnVsbCksIHggPSAhMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geDtcbiAgICAgIH0sXG4gICAgICBfZGVmYXVsdFNldHRlcjogZnVuY3Rpb24gKGIsIGEsIGYpIHtcbiAgICAgICAgZi5zZXRBdHRyaWJ1dGUoYSwgYik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgVS5wcm90b3R5cGUueUdldHRlciA9IFUucHJvdG90eXBlLnhHZXR0ZXI7XG5cbiAgICBVLnByb3RvdHlwZS50cmFuc2xhdGVYU2V0dGVyID0gVS5wcm90b3R5cGUudHJhbnNsYXRlWVNldHRlciA9IFUucHJvdG90eXBlLnJvdGF0aW9uU2V0dGVyID0gVS5wcm90b3R5cGUudmVydGljYWxBbGlnblNldHRlciA9IFUucHJvdG90eXBlLnJvdGF0aW9uT3JpZ2luWFNldHRlciA9IFUucHJvdG90eXBlLnJvdGF0aW9uT3JpZ2luWVNldHRlciA9IFUucHJvdG90eXBlLnNjYWxlWFNldHRlciA9IFUucHJvdG90eXBlLnNjYWxlWVNldHRlciA9IFUucHJvdG90eXBlLm1hdHJpeFNldHRlciA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICB0aGlzW2FdID0gYjtcbiAgICAgIHRoaXMuZG9UcmFuc2Zvcm0gPSAhMDtcbiAgICB9O1xuXG4gICAgVS5wcm90b3R5cGVbXCJzdHJva2Utd2lkdGhTZXR0ZXJcIl0gPSBVLnByb3RvdHlwZS5zdHJva2VTZXR0ZXIgPSBmdW5jdGlvbiAoYiwgYSwgZikge1xuICAgICAgdGhpc1thXSA9IGI7XG4gICAgICB0aGlzLnN0cm9rZSAmJiB0aGlzW1wic3Ryb2tlLXdpZHRoXCJdID8gKFUucHJvdG90eXBlLmZpbGxTZXR0ZXIuY2FsbCh0aGlzLCB0aGlzLnN0cm9rZSwgXCJzdHJva2VcIiwgZiksIGYuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIHRoaXNbXCJzdHJva2Utd2lkdGhcIl0pLCB0aGlzLmhhc1N0cm9rZSA9ICEwKSA6IFwic3Ryb2tlLXdpZHRoXCIgPT09IGEgJiYgMCA9PT0gYiAmJiB0aGlzLmhhc1N0cm9rZSA/IChmLnJlbW92ZUF0dHJpYnV0ZShcInN0cm9rZVwiKSwgdGhpcy5oYXNTdHJva2UgPSAhMSkgOiB0aGlzLnJlbmRlcmVyLnN0eWxlZE1vZGUgJiYgdGhpc1tcInN0cm9rZS13aWR0aFwiXSAmJiAoZi5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgdGhpc1tcInN0cm9rZS13aWR0aFwiXSksIHRoaXMuaGFzU3Ryb2tlID0gITApO1xuICAgIH07XG5cbiAgICBnID0gZC5TVkdSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBoKGcucHJvdG90eXBlLCB7XG4gICAgICBFbGVtZW50OiBVLFxuICAgICAgU1ZHX05TOiBSLFxuICAgICAgaW5pdDogZnVuY3Rpb24gKGEsIGYsIGMsIHAsIGUsIHgsIEMpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIikuYXR0cih7XG4gICAgICAgICAgdmVyc2lvbjogXCIxLjFcIixcbiAgICAgICAgICBcImNsYXNzXCI6IFwiaGlnaGNoYXJ0cy1yb290XCJcbiAgICAgICAgfSk7XG4gICAgICAgIEMgfHwgbS5jc3ModGhpcy5nZXRTdHlsZShwKSk7XG4gICAgICAgIHAgPSBtLmVsZW1lbnQ7XG4gICAgICAgIGEuYXBwZW5kQ2hpbGQocCk7XG4gICAgICAgIEEoYSwgXCJkaXJcIiwgXCJsdHJcIik7XG4gICAgICAgIC0xID09PSBhLmlubmVySFRNTC5pbmRleE9mKFwieG1sbnNcIikgJiYgQShwLCBcInhtbG5zXCIsIHRoaXMuU1ZHX05TKTtcbiAgICAgICAgdGhpcy5pc1NWRyA9ICEwO1xuICAgICAgICB0aGlzLmJveCA9IHA7XG4gICAgICAgIHRoaXMuYm94V3JhcHBlciA9IG07XG4gICAgICAgIHRoaXMuYWxpZ25lZE9iamVjdHMgPSBbXTtcbiAgICAgICAgdGhpcy51cmwgPSAoSyB8fCBiKSAmJiBRLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYmFzZVwiKS5sZW5ndGggPyBYLmxvY2F0aW9uLmhyZWYuc3BsaXQoXCIjXCIpWzBdLnJlcGxhY2UoLzxbXj5dKj4vZywgXCJcIikucmVwbGFjZSgvKFtcXCgnXFwpXSkvZywgXCJcXFxcJDFcIikucmVwbGFjZSgvIC9nLCBcIiUyMFwiKSA6IFwiXCI7XG4gICAgICAgIHRoaXMuY3JlYXRlRWxlbWVudChcImRlc2NcIikuYWRkKCkuZWxlbWVudC5hcHBlbmRDaGlsZChRLmNyZWF0ZVRleHROb2RlKFwiQ3JlYXRlZCB3aXRoIEhpZ2hjaGFydHMgOC4wLjRcIikpO1xuICAgICAgICB0aGlzLmRlZnMgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIpLmFkZCgpO1xuICAgICAgICB0aGlzLmFsbG93SFRNTCA9IHg7XG4gICAgICAgIHRoaXMuZm9yRXhwb3J0ID0gZTtcbiAgICAgICAgdGhpcy5zdHlsZWRNb2RlID0gQztcbiAgICAgICAgdGhpcy5ncmFkaWVudHMgPSB7fTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLmNhY2hlS2V5cyA9IFtdO1xuICAgICAgICB0aGlzLmltZ0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5zZXRTaXplKGYsIGMsICExKTtcbiAgICAgICAgdmFyIGw7XG4gICAgICAgIEsgJiYgYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgKGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgSihhLCB7XG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgdG9wOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbCA9IGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgSihhLCB7XG4gICAgICAgICAgICBsZWZ0OiBNYXRoLmNlaWwobC5sZWZ0KSAtIGwubGVmdCArIFwicHhcIixcbiAgICAgICAgICAgIHRvcDogTWF0aC5jZWlsKGwudG9wKSAtIGwudG9wICsgXCJweFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGYoKSwgdGhpcy51blN1YlBpeGVsRml4ID0gSShYLCBcInJlc2l6ZVwiLCBmKSk7XG4gICAgICB9LFxuICAgICAgZGVmaW5pdGlvbjogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgZnVuY3Rpb24gYShiLCBjKSB7XG4gICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgdihiKS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICB2YXIgbSA9IGYuY3JlYXRlRWxlbWVudChiLnRhZ05hbWUpLFxuICAgICAgICAgICAgICAgIGUgPSB7fTtcbiAgICAgICAgICAgIG4oYiwgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICAgICAgXCJ0YWdOYW1lXCIgIT09IGEgJiYgXCJjaGlsZHJlblwiICE9PSBhICYmIFwidGV4dENvbnRlbnRcIiAhPT0gYSAmJiAoZVthXSA9IGIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtLmF0dHIoZSk7XG4gICAgICAgICAgICBtLmFkZChjIHx8IGYuZGVmcyk7XG4gICAgICAgICAgICBiLnRleHRDb250ZW50ICYmIG0uZWxlbWVudC5hcHBlbmRDaGlsZChRLmNyZWF0ZVRleHROb2RlKGIudGV4dENvbnRlbnQpKTtcbiAgICAgICAgICAgIGEoYi5jaGlsZHJlbiB8fCBbXSwgbSk7XG4gICAgICAgICAgICBwID0gbTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGEoYik7XG4gICAgICB9LFxuICAgICAgZ2V0U3R5bGU6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlID0gaCh7XG4gICAgICAgICAgZm9udEZhbWlseTogJ1wiTHVjaWRhIEdyYW5kZVwiLCBcIkx1Y2lkYSBTYW5zIFVuaWNvZGVcIiwgQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZicsXG4gICAgICAgICAgZm9udFNpemU6IFwiMTJweFwiXG4gICAgICAgIH0sIGIpO1xuICAgICAgfSxcbiAgICAgIHNldFN0eWxlOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB0aGlzLmJveFdyYXBwZXIuY3NzKHRoaXMuZ2V0U3R5bGUoYikpO1xuICAgICAgfSxcbiAgICAgIGlzSGlkZGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5ib3hXcmFwcGVyLmdldEJCb3goKS53aWR0aDtcbiAgICAgIH0sXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5kZWZzO1xuICAgICAgICB0aGlzLmJveCA9IG51bGw7XG4gICAgICAgIHRoaXMuYm94V3JhcHBlciA9IHRoaXMuYm94V3JhcHBlci5kZXN0cm95KCk7XG4gICAgICAgIHQodGhpcy5ncmFkaWVudHMgfHwge30pO1xuICAgICAgICB0aGlzLmdyYWRpZW50cyA9IG51bGw7XG4gICAgICAgIGIgJiYgKHRoaXMuZGVmcyA9IGIuZGVzdHJveSgpKTtcbiAgICAgICAgdGhpcy51blN1YlBpeGVsRml4ICYmIHRoaXMudW5TdWJQaXhlbEZpeCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5hbGlnbmVkT2JqZWN0cyA9IG51bGw7XG4gICAgICB9LFxuICAgICAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSBuZXcgdGhpcy5FbGVtZW50KCk7XG4gICAgICAgIGEuaW5pdCh0aGlzLCBiKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9LFxuICAgICAgZHJhdzogQyxcbiAgICAgIGdldFJhZGlhbEF0dHI6IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY3g6IGJbMF0gLSBiWzJdIC8gMiArIGEuY3ggKiBiWzJdLFxuICAgICAgICAgIGN5OiBiWzFdIC0gYlsyXSAvIDIgKyBhLmN5ICogYlsyXSxcbiAgICAgICAgICByOiBhLnIgKiBiWzJdXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdHJ1bmNhdGU6IGZ1bmN0aW9uIChiLCBhLCBmLCBjLCBwLCBlLCB4KSB7XG4gICAgICAgIHZhciBtID0gdGhpcyxcbiAgICAgICAgICAgIEMgPSBiLnJvdGF0aW9uLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGsgPSBjID8gMSA6IDAsXG4gICAgICAgICAgICBGID0gKGYgfHwgYykubGVuZ3RoLFxuICAgICAgICAgICAgbiA9IEYsXG4gICAgICAgICAgICB2ID0gW10sXG4gICAgICAgICAgICB3ID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBhLmZpcnN0Q2hpbGQgJiYgYS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIGIgJiYgYS5hcHBlbmRDaGlsZChRLmNyZWF0ZVRleHROb2RlKGIpKTtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIHogPSBmdW5jdGlvbiAoZSwgbCkge1xuICAgICAgICAgIGwgPSBsIHx8IGU7XG4gICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiB2W2xdKSBpZiAoYS5nZXRTdWJTdHJpbmdMZW5ndGgpIHRyeSB7XG4gICAgICAgICAgICB2W2xdID0gcCArIGEuZ2V0U3ViU3RyaW5nTGVuZ3RoKDAsIGMgPyBsICsgMSA6IGwpO1xuICAgICAgICAgIH0gY2F0Y2ggKGxhKSB7XG4gICAgICAgICAgICBcIlwiO1xuICAgICAgICAgIH0gZWxzZSBtLmdldFNwYW5XaWR0aCAmJiAodyh4KGYgfHwgYywgZSkpLCB2W2xdID0gcCArIG0uZ2V0U3BhbldpZHRoKGIsIGEpKTtcbiAgICAgICAgICByZXR1cm4gdltsXTtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIE87XG5cbiAgICAgICAgYi5yb3RhdGlvbiA9IDA7XG4gICAgICAgIHZhciBUID0geihhLnRleHRDb250ZW50Lmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKE8gPSBwICsgVCA+IGUpIHtcbiAgICAgICAgICBmb3IgKDsgayA8PSBGOykgbiA9IE1hdGguY2VpbCgoayArIEYpIC8gMiksIGMgJiYgKGwgPSB4KGMsIG4pKSwgVCA9IHoobiwgbCAmJiBsLmxlbmd0aCAtIDEpLCBrID09PSBGID8gayA9IEYgKyAxIDogVCA+IGUgPyBGID0gbiAtIDEgOiBrID0gbjtcblxuICAgICAgICAgIDAgPT09IEYgPyB3KFwiXCIpIDogZiAmJiBGID09PSBmLmxlbmd0aCAtIDEgfHwgdyhsIHx8IHgoZiB8fCBjLCBuKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjICYmIGMuc3BsaWNlKDAsIG4pO1xuICAgICAgICBiLmFjdHVhbFdpZHRoID0gVDtcbiAgICAgICAgYi5yb3RhdGlvbiA9IEM7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfSxcbiAgICAgIGVzY2FwZXM6IHtcbiAgICAgICAgXCImXCI6IFwiJmFtcDtcIixcbiAgICAgICAgXCI8XCI6IFwiJmx0O1wiLFxuICAgICAgICBcIj5cIjogXCImZ3Q7XCIsXG4gICAgICAgIFwiJ1wiOiBcIiYjMzk7XCIsXG4gICAgICAgICdcIic6IFwiJnF1b3Q7XCJcbiAgICAgIH0sXG4gICAgICBidWlsZFRleHQ6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBjID0gYi5lbGVtZW50LFxuICAgICAgICAgICAgcCA9IHRoaXMsXG4gICAgICAgICAgICBlID0gcC5mb3JFeHBvcnQsXG4gICAgICAgICAgICBtID0gZihiLnRleHRTdHIsIFwiXCIpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBsID0gLTEgIT09IG0uaW5kZXhPZihcIjxcIiksXG4gICAgICAgICAgICBDID0gYy5jaGlsZE5vZGVzLFxuICAgICAgICAgICAgayxcbiAgICAgICAgICAgIHYgPSBBKGMsIFwieFwiKSxcbiAgICAgICAgICAgIHcgPSBiLnN0eWxlcyxcbiAgICAgICAgICAgIHogPSBiLnRleHRXaWR0aCxcbiAgICAgICAgICAgIE8gPSB3ICYmIHcubGluZUhlaWdodCxcbiAgICAgICAgICAgIHEgPSB3ICYmIHcudGV4dE91dGxpbmUsXG4gICAgICAgICAgICBCID0gdyAmJiBcImVsbGlwc2lzXCIgPT09IHcudGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgZCA9IHcgJiYgXCJub3dyYXBcIiA9PT0gdy53aGl0ZVNwYWNlLFxuICAgICAgICAgICAgTiA9IHcgJiYgdy5mb250U2l6ZSxcbiAgICAgICAgICAgIFgsXG4gICAgICAgICAgICBoID0gQy5sZW5ndGg7XG4gICAgICAgIHcgPSB6ICYmICFiLmFkZGVkICYmIHRoaXMuYm94O1xuXG4gICAgICAgIHZhciBMID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICB2YXIgZjtcbiAgICAgICAgICBwLnN0eWxlZE1vZGUgfHwgKGYgPSAvKHB4fGVtKSQvLnRlc3QoYiAmJiBiLnN0eWxlLmZvbnRTaXplKSA/IGIuc3R5bGUuZm9udFNpemUgOiBOIHx8IHAuc3R5bGUuZm9udFNpemUgfHwgMTIpO1xuICAgICAgICAgIHJldHVybiBPID8gYShPKSA6IHAuZm9udE1ldHJpY3MoZiwgYi5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSA/IGIgOiBjKS5oO1xuICAgICAgICB9LFxuICAgICAgICAgICAgdCA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgbihwLmVzY2FwZXMsIGZ1bmN0aW9uIChmLCBjKSB7XG4gICAgICAgICAgICBhICYmIC0xICE9PSBhLmluZGV4T2YoZikgfHwgKGIgPSBiLnRvU3RyaW5nKCkucmVwbGFjZShuZXcgUmVnRXhwKGYsIFwiZ1wiKSwgYykpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9LFxuICAgICAgICAgICAgVSA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgdmFyIGYgPSBiLmluZGV4T2YoXCI8XCIpO1xuICAgICAgICAgIGIgPSBiLnN1YnN0cmluZyhmLCBiLmluZGV4T2YoXCI+XCIpIC0gZik7XG4gICAgICAgICAgZiA9IGIuaW5kZXhPZihhICsgXCI9XCIpO1xuICAgICAgICAgIGlmICgtMSAhPT0gZiAmJiAoZiA9IGYgKyBhLmxlbmd0aCArIDEsIGEgPSBiLmNoYXJBdChmKSwgJ1wiJyA9PT0gYSB8fCBcIidcIiA9PT0gYSkpIHJldHVybiBiID0gYi5zdWJzdHJpbmcoZiArIDEpLCBiLnN1YnN0cmluZygwLCBiLmluZGV4T2YoYSkpO1xuICAgICAgICB9LFxuICAgICAgICAgICAgUCA9IC88YnIuKj8+L2c7XG5cbiAgICAgICAgdmFyIGcgPSBbbSwgQiwgZCwgTywgcSwgTiwgel0uam9pbigpO1xuXG4gICAgICAgIGlmIChnICE9PSBiLnRleHRDYWNoZSkge1xuICAgICAgICAgIGZvciAoYi50ZXh0Q2FjaGUgPSBnOyBoLS07KSBjLnJlbW92ZUNoaWxkKENbaF0pO1xuXG4gICAgICAgICAgbCB8fCBxIHx8IEIgfHwgeiB8fCAtMSAhPT0gbS5pbmRleE9mKFwiIFwiKSAmJiAoIWQgfHwgUC50ZXN0KG0pKSA/ICh3ICYmIHcuYXBwZW5kQ2hpbGQoYyksIGwgPyAobSA9IHAuc3R5bGVkTW9kZSA/IG0ucmVwbGFjZSgvPChifHN0cm9uZyk+L2csICc8c3BhbiBjbGFzcz1cImhpZ2hjaGFydHMtc3Ryb25nXCI+JykucmVwbGFjZSgvPChpfGVtKT4vZywgJzxzcGFuIGNsYXNzPVwiaGlnaGNoYXJ0cy1lbXBoYXNpemVkXCI+JykgOiBtLnJlcGxhY2UoLzwoYnxzdHJvbmcpPi9nLCAnPHNwYW4gc3R5bGU9XCJmb250LXdlaWdodDpib2xkXCI+JykucmVwbGFjZSgvPChpfGVtKT4vZywgJzxzcGFuIHN0eWxlPVwiZm9udC1zdHlsZTppdGFsaWNcIj4nKSwgbSA9IG0ucmVwbGFjZSgvPGEvZywgXCI8c3BhblwiKS5yZXBsYWNlKC88XFwvKGJ8c3Ryb25nfGl8ZW18YSk+L2csIFwiPC9zcGFuPlwiKS5zcGxpdChQKSkgOiBtID0gW21dLCBtID0gbS5maWx0ZXIoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiICE9PSBiO1xuICAgICAgICAgIH0pLCBtLmZvckVhY2goZnVuY3Rpb24gKGEsIGYpIHtcbiAgICAgICAgICAgIHZhciBtID0gMCxcbiAgICAgICAgICAgICAgICBsID0gMDtcbiAgICAgICAgICAgIGEgPSBhLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpLnJlcGxhY2UoLzxzcGFuL2csIFwifHx8PHNwYW5cIikucmVwbGFjZSgvPFxcL3NwYW4+L2csIFwiPC9zcGFuPnx8fFwiKTtcbiAgICAgICAgICAgIHZhciBDID0gYS5zcGxpdChcInx8fFwiKTtcbiAgICAgICAgICAgIEMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICBpZiAoXCJcIiAhPT0gYSB8fCAxID09PSBDLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBuID0ge30sXG4gICAgICAgICAgICAgICAgICAgIEYgPSBRLmNyZWF0ZUVsZW1lbnROUyhwLlNWR19OUywgXCJ0c3BhblwiKSxcbiAgICAgICAgICAgICAgICAgICAgdyxcbiAgICAgICAgICAgICAgICAgICAgTztcbiAgICAgICAgICAgICAgICAodyA9IFUoYSwgXCJjbGFzc1wiKSkgJiYgQShGLCBcImNsYXNzXCIsIHcpO1xuICAgICAgICAgICAgICAgIGlmICh3ID0gVShhLCBcInN0eWxlXCIpKSB3ID0gdy5yZXBsYWNlKC8oO3wgfF4pY29sb3IoWyA6XSkvLCBcIiQxZmlsbCQyXCIpLCBBKEYsIFwic3R5bGVcIiwgdyk7XG4gICAgICAgICAgICAgICAgKE8gPSBVKGEsIFwiaHJlZlwiKSkgJiYgIWUgJiYgKEEoRiwgXCJvbmNsaWNrXCIsICdsb2NhdGlvbi5ocmVmPVwiJyArIE8gKyAnXCInKSwgQShGLCBcImNsYXNzXCIsIFwiaGlnaGNoYXJ0cy1hbmNob3JcIiksIHAuc3R5bGVkTW9kZSB8fCBKKEYsIHtcbiAgICAgICAgICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgYSA9IHQoYS5yZXBsYWNlKC88W2EtekEtWlxcL10oLnxcXG4pKj8+L2csIFwiXCIpIHx8IFwiIFwiKTtcblxuICAgICAgICAgICAgICAgIGlmIChcIiBcIiAhPT0gYSkge1xuICAgICAgICAgICAgICAgICAgRi5hcHBlbmRDaGlsZChRLmNyZWF0ZVRleHROb2RlKGEpKTtcbiAgICAgICAgICAgICAgICAgIG0gPyBuLmR4ID0gMCA6IGYgJiYgbnVsbCAhPT0gdiAmJiAobi54ID0gdik7XG4gICAgICAgICAgICAgICAgICBBKEYsIG4pO1xuICAgICAgICAgICAgICAgICAgYy5hcHBlbmRDaGlsZChGKTtcbiAgICAgICAgICAgICAgICAgICFtICYmIFggJiYgKCF4ICYmIGUgJiYgSihGLCB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgICAgICAgICAgICAgICAgfSksIEEoRiwgXCJkeVwiLCBMKEYpKSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICh6KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxID0gYS5yZXBsYWNlKC8oW15cXF5dKS0vZywgXCIkMS0gXCIpLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbiA9ICFkICYmICgxIDwgQy5sZW5ndGggfHwgZiB8fCAxIDwgcS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBPID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFQgPSBMKEYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQikgayA9IHAudHJ1bmNhdGUoYiwgRiwgYSwgdm9pZCAwLCAwLCBNYXRoLm1heCgwLCB6IC0gcGFyc2VJbnQoTiB8fCAxMiwgMTApKSwgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYi5zdWJzdHJpbmcoMCwgYSkgKyBcIlxcdTIwMjZcIjtcbiAgICAgICAgICAgICAgICAgICAgfSk7ZWxzZSBpZiAobikgZm9yICg7IHEubGVuZ3RoOykgcS5sZW5ndGggJiYgIWQgJiYgMCA8IE8gJiYgKEYgPSBRLmNyZWF0ZUVsZW1lbnROUyhSLCBcInRzcGFuXCIpLCBBKEYsIHtcbiAgICAgICAgICAgICAgICAgICAgICBkeTogVCxcbiAgICAgICAgICAgICAgICAgICAgICB4OiB2XG4gICAgICAgICAgICAgICAgICAgIH0pLCB3ICYmIEEoRiwgXCJzdHlsZVwiLCB3KSwgRi5hcHBlbmRDaGlsZChRLmNyZWF0ZVRleHROb2RlKHEuam9pbihcIiBcIikucmVwbGFjZSgvLSAvZywgXCItXCIpKSksIGMuYXBwZW5kQ2hpbGQoRikpLCBwLnRydW5jYXRlKGIsIEYsIG51bGwsIHEsIDAgPT09IE8gPyBsIDogMCwgeiwgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcS5zbGljZSgwLCBhKS5qb2luKFwiIFwiKS5yZXBsYWNlKC8tIC9nLCBcIi1cIik7XG4gICAgICAgICAgICAgICAgICAgIH0pLCBsID0gYi5hY3R1YWxXaWR0aCwgTysrO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBtKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFggPSBYIHx8IGMuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgfSksIEIgJiYgayAmJiBiLmF0dHIoXCJ0aXRsZVwiLCB0KGIudGV4dFN0ciwgW1wiJmx0O1wiLCBcIiZndDtcIl0pKSwgdyAmJiB3LnJlbW92ZUNoaWxkKGMpLCBxICYmIGIuYXBwbHlUZXh0T3V0bGluZSAmJiBiLmFwcGx5VGV4dE91dGxpbmUocSkpIDogYy5hcHBlbmRDaGlsZChRLmNyZWF0ZVRleHROb2RlKHQobSkpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldENvbnRyYXN0OiBmdW5jdGlvbiAoYikge1xuICAgICAgICBiID0gdShiKS5yZ2JhO1xuICAgICAgICBiWzBdICo9IDE7XG4gICAgICAgIGJbMV0gKj0gMS4yO1xuICAgICAgICBiWzJdICo9IC41O1xuICAgICAgICByZXR1cm4gNDU5IDwgYlswXSArIGJbMV0gKyBiWzJdID8gXCIjMDAwMDAwXCIgOiBcIiNGRkZGRkZcIjtcbiAgICAgIH0sXG4gICAgICBidXR0b246IGZ1bmN0aW9uIChiLCBhLCBmLCBjLCBlLCB4LCBsLCBDLCBuLCB3KSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5sYWJlbChiLCBhLCBmLCBuLCBudWxsLCBudWxsLCB3LCBudWxsLCBcImJ1dHRvblwiKSxcbiAgICAgICAgICAgIEYgPSAwLFxuICAgICAgICAgICAgdiA9IHRoaXMuc3R5bGVkTW9kZTtcbiAgICAgICAgbS5hdHRyKGsoe1xuICAgICAgICAgIHBhZGRpbmc6IDgsXG4gICAgICAgICAgcjogMlxuICAgICAgICB9LCBlKSk7XG5cbiAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgZSA9IGsoe1xuICAgICAgICAgICAgZmlsbDogXCIjZjdmN2Y3XCIsXG4gICAgICAgICAgICBzdHJva2U6IFwiI2NjY2NjY1wiLFxuICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogMSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIGNvbG9yOiBcIiMzMzMzMzNcIixcbiAgICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIixcbiAgICAgICAgICAgICAgZm9udFdlaWdodDogXCJub3JtYWxcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGUpO1xuICAgICAgICAgIHZhciB6ID0gZS5zdHlsZTtcbiAgICAgICAgICBkZWxldGUgZS5zdHlsZTtcbiAgICAgICAgICB4ID0gayhlLCB7XG4gICAgICAgICAgICBmaWxsOiBcIiNlNmU2ZTZcIlxuICAgICAgICAgIH0sIHgpO1xuICAgICAgICAgIHZhciBPID0geC5zdHlsZTtcbiAgICAgICAgICBkZWxldGUgeC5zdHlsZTtcbiAgICAgICAgICBsID0gayhlLCB7XG4gICAgICAgICAgICBmaWxsOiBcIiNlNmViZjVcIixcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIGNvbG9yOiBcIiMwMDAwMDBcIixcbiAgICAgICAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBsKTtcbiAgICAgICAgICB2YXIgcSA9IGwuc3R5bGU7XG4gICAgICAgICAgZGVsZXRlIGwuc3R5bGU7XG4gICAgICAgICAgQyA9IGsoZSwge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgY29sb3I6IFwiI2NjY2NjY1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgQyk7XG4gICAgICAgICAgdmFyIFIgPSBDLnN0eWxlO1xuICAgICAgICAgIGRlbGV0ZSBDLnN0eWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgSShtLmVsZW1lbnQsIHAgPyBcIm1vdXNlb3ZlclwiIDogXCJtb3VzZWVudGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAzICE9PSBGICYmIG0uc2V0U3RhdGUoMSk7XG4gICAgICAgIH0pO1xuICAgICAgICBJKG0uZWxlbWVudCwgcCA/IFwibW91c2VvdXRcIiA6IFwibW91c2VsZWF2ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgMyAhPT0gRiAmJiBtLnNldFN0YXRlKEYpO1xuICAgICAgICB9KTtcblxuICAgICAgICBtLnNldFN0YXRlID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAxICE9PSBiICYmIChtLnN0YXRlID0gRiA9IGIpO1xuICAgICAgICAgIG0ucmVtb3ZlQ2xhc3MoL2hpZ2hjaGFydHMtYnV0dG9uLShub3JtYWx8aG92ZXJ8cHJlc3NlZHxkaXNhYmxlZCkvKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtYnV0dG9uLVwiICsgW1wibm9ybWFsXCIsIFwiaG92ZXJcIiwgXCJwcmVzc2VkXCIsIFwiZGlzYWJsZWRcIl1bYiB8fCAwXSk7XG4gICAgICAgICAgdiB8fCBtLmF0dHIoW2UsIHgsIGwsIENdW2IgfHwgMF0pLmNzcyhbeiwgTywgcSwgUl1bYiB8fCAwXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdiB8fCBtLmF0dHIoZSkuY3NzKGgoe1xuICAgICAgICAgIGN1cnNvcjogXCJkZWZhdWx0XCJcbiAgICAgICAgfSwgeikpO1xuICAgICAgICByZXR1cm4gbS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgMyAhPT0gRiAmJiBjLmNhbGwobSwgYik7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGNyaXNwTGluZTogZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgYlsxXSA9PT0gYls0XSAmJiAoYlsxXSA9IGJbNF0gPSBNYXRoLnJvdW5kKGJbMV0pIC0gYSAlIDIgLyAyKTtcbiAgICAgICAgYlsyXSA9PT0gYls1XSAmJiAoYlsyXSA9IGJbNV0gPSBNYXRoLnJvdW5kKGJbMl0pICsgYSAlIDIgLyAyKTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9LFxuICAgICAgcGF0aDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLnN0eWxlZE1vZGUgPyB7fSA6IHtcbiAgICAgICAgICBmaWxsOiBcIm5vbmVcIlxuICAgICAgICB9O1xuICAgICAgICBxKGIpID8gYS5kID0gYiA6IGUoYikgJiYgaChhLCBiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRWxlbWVudChcInBhdGhcIikuYXR0cihhKTtcbiAgICAgIH0sXG4gICAgICBjaXJjbGU6IGZ1bmN0aW9uIChiLCBhLCBmKSB7XG4gICAgICAgIGIgPSBlKGIpID8gYiA6IFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBiID8ge30gOiB7XG4gICAgICAgICAgeDogYixcbiAgICAgICAgICB5OiBhLFxuICAgICAgICAgIHI6IGZcbiAgICAgICAgfTtcbiAgICAgICAgYSA9IHRoaXMuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiKTtcblxuICAgICAgICBhLnhTZXR0ZXIgPSBhLnlTZXR0ZXIgPSBmdW5jdGlvbiAoYiwgYSwgZikge1xuICAgICAgICAgIGYuc2V0QXR0cmlidXRlKFwiY1wiICsgYSwgYik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGEuYXR0cihiKTtcbiAgICAgIH0sXG4gICAgICBhcmM6IGZ1bmN0aW9uIChiLCBhLCBmLCBjLCBwLCB4KSB7XG4gICAgICAgIGUoYikgPyAoYyA9IGIsIGEgPSBjLnksIGYgPSBjLnIsIGIgPSBjLngpIDogYyA9IHtcbiAgICAgICAgICBpbm5lclI6IGMsXG4gICAgICAgICAgc3RhcnQ6IHAsXG4gICAgICAgICAgZW5kOiB4XG4gICAgICAgIH07XG4gICAgICAgIGIgPSB0aGlzLnN5bWJvbChcImFyY1wiLCBiLCBhLCBmLCBmLCBjKTtcbiAgICAgICAgYi5yID0gZjtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9LFxuICAgICAgcmVjdDogZnVuY3Rpb24gKGIsIGEsIGYsIGMsIHAsIHgpIHtcbiAgICAgICAgcCA9IGUoYikgPyBiLnIgOiBwO1xuICAgICAgICB2YXIgbSA9IHRoaXMuY3JlYXRlRWxlbWVudChcInJlY3RcIik7XG4gICAgICAgIGIgPSBlKGIpID8gYiA6IFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBiID8ge30gOiB7XG4gICAgICAgICAgeDogYixcbiAgICAgICAgICB5OiBhLFxuICAgICAgICAgIHdpZHRoOiBNYXRoLm1heChmLCAwKSxcbiAgICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KGMsIDApXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3R5bGVkTW9kZSB8fCAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHggJiYgKGIuc3Ryb2tlV2lkdGggPSB4LCBiID0gbS5jcmlzcChiKSksIGIuZmlsbCA9IFwibm9uZVwiKTtcbiAgICAgICAgcCAmJiAoYi5yID0gcCk7XG5cbiAgICAgICAgbS5yU2V0dGVyID0gZnVuY3Rpb24gKGIsIGEsIGYpIHtcbiAgICAgICAgICBtLnIgPSBiO1xuICAgICAgICAgIEEoZiwge1xuICAgICAgICAgICAgcng6IGIsXG4gICAgICAgICAgICByeTogYlxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIG0uckdldHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbS5yO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBtLmF0dHIoYik7XG4gICAgICB9LFxuICAgICAgc2V0U2l6ZTogZnVuY3Rpb24gKGIsIGEsIGMpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLmFsaWduZWRPYmplY3RzLFxuICAgICAgICAgICAgZSA9IHAubGVuZ3RoO1xuICAgICAgICB0aGlzLndpZHRoID0gYjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBhO1xuXG4gICAgICAgIGZvciAodGhpcy5ib3hXcmFwcGVyLmFuaW1hdGUoe1xuICAgICAgICAgIHdpZHRoOiBiLFxuICAgICAgICAgIGhlaWdodDogYVxuICAgICAgICB9LCB7XG4gICAgICAgICAgc3RlcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hdHRyKHtcbiAgICAgICAgICAgICAgdmlld0JveDogXCIwIDAgXCIgKyB0aGlzLmF0dHIoXCJ3aWR0aFwiKSArIFwiIFwiICsgdGhpcy5hdHRyKFwiaGVpZ2h0XCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiBmKGMsICEwKSA/IHZvaWQgMCA6IDBcbiAgICAgICAgfSk7IGUtLTspIHBbZV0uYWxpZ24oKTtcbiAgICAgIH0sXG4gICAgICBnOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY3JlYXRlRWxlbWVudChcImdcIik7XG4gICAgICAgIHJldHVybiBiID8gYS5hdHRyKHtcbiAgICAgICAgICBcImNsYXNzXCI6IFwiaGlnaGNoYXJ0cy1cIiArIGJcbiAgICAgICAgfSkgOiBhO1xuICAgICAgfSxcbiAgICAgIGltYWdlOiBmdW5jdGlvbiAoYiwgYSwgZiwgYywgcCwgZSkge1xuICAgICAgICB2YXIgeCA9IHtcbiAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBcIm5vbmVcIlxuICAgICAgICB9LFxuICAgICAgICAgICAgbSA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgYi5zZXRBdHRyaWJ1dGVOUyA/IGIuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsIFwiaHJlZlwiLCBhKSA6IGIuc2V0QXR0cmlidXRlKFwiaGMtc3ZnLWhyZWZcIiwgYSk7XG4gICAgICAgIH0sXG4gICAgICAgICAgICBsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBtKEMuZWxlbWVudCwgYik7XG4gICAgICAgICAgZS5jYWxsKEMsIGEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIDEgPCBhcmd1bWVudHMubGVuZ3RoICYmIGgoeCwge1xuICAgICAgICAgIHg6IGEsXG4gICAgICAgICAgeTogZixcbiAgICAgICAgICB3aWR0aDogYyxcbiAgICAgICAgICBoZWlnaHQ6IHBcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBDID0gdGhpcy5jcmVhdGVFbGVtZW50KFwiaW1hZ2VcIikuYXR0cih4KTtcbiAgICAgICAgZSA/IChtKEMuZWxlbWVudCwgXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PVwiKSwgeCA9IG5ldyBYLkltYWdlKCksIEkoeCwgXCJsb2FkXCIsIGwpLCB4LnNyYyA9IGIsIHguY29tcGxldGUgJiYgbCh7fSkpIDogbShDLmVsZW1lbnQsIGIpO1xuICAgICAgICByZXR1cm4gQztcbiAgICAgIH0sXG4gICAgICBzeW1ib2w6IGZ1bmN0aW9uIChiLCBhLCBjLCBwLCBlLCB4KSB7XG4gICAgICAgIHZhciBtID0gdGhpcyxcbiAgICAgICAgICAgIGwgPSAvXnVybFxcKCguKj8pXFwpJC8sXG4gICAgICAgICAgICBDID0gbC50ZXN0KGIpLFxuICAgICAgICAgICAgayA9ICFDICYmICh0aGlzLnN5bWJvbHNbYl0gPyBiIDogXCJjaXJjbGVcIiksXG4gICAgICAgICAgICBuID0gayAmJiB0aGlzLnN5bWJvbHNba10sXG4gICAgICAgICAgICBGID0geShhKSAmJiBuICYmIG4uY2FsbCh0aGlzLnN5bWJvbHMsIE1hdGgucm91bmQoYSksIE1hdGgucm91bmQoYyksIHAsIGUsIHgpO1xuXG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgdmFyIHcgPSB0aGlzLnBhdGgoRik7XG4gICAgICAgICAgbS5zdHlsZWRNb2RlIHx8IHcuYXR0cihcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgICAgIGgodywge1xuICAgICAgICAgICAgc3ltYm9sTmFtZTogayxcbiAgICAgICAgICAgIHg6IGEsXG4gICAgICAgICAgICB5OiBjLFxuICAgICAgICAgICAgd2lkdGg6IHAsXG4gICAgICAgICAgICBoZWlnaHQ6IGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB4ICYmIGgodywgeCk7XG4gICAgICAgIH0gZWxzZSBpZiAoQykge1xuICAgICAgICAgIHZhciB2ID0gYi5tYXRjaChsKVsxXTtcbiAgICAgICAgICB3ID0gdGhpcy5pbWFnZSh2KTtcbiAgICAgICAgICB3LmltZ3dpZHRoID0gZihPW3ZdICYmIE9bdl0ud2lkdGgsIHggJiYgeC53aWR0aCk7XG4gICAgICAgICAgdy5pbWdoZWlnaHQgPSBmKE9bdl0gJiYgT1t2XS5oZWlnaHQsIHggJiYgeC5oZWlnaHQpO1xuXG4gICAgICAgICAgdmFyIHogPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3LmF0dHIoe1xuICAgICAgICAgICAgICB3aWR0aDogdy53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiB3LmhlaWdodFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIFtcIndpZHRoXCIsIFwiaGVpZ2h0XCJdLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIHdbYiArIFwiU2V0dGVyXCJdID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICAgICAgdmFyIGYgPSB7fSxcbiAgICAgICAgICAgICAgICAgIGMgPSB0aGlzW1wiaW1nXCIgKyBhXSxcbiAgICAgICAgICAgICAgICAgIHAgPSBcIndpZHRoXCIgPT09IGEgPyBcInRyYW5zbGF0ZVhcIiA6IFwidHJhbnNsYXRlWVwiO1xuICAgICAgICAgICAgICB0aGlzW2FdID0gYjtcbiAgICAgICAgICAgICAgeShjKSAmJiAoeCAmJiBcIndpdGhpblwiID09PSB4LmJhY2tncm91bmRTaXplICYmIHRoaXMud2lkdGggJiYgdGhpcy5oZWlnaHQgJiYgKGMgPSBNYXRoLnJvdW5kKGMgKiBNYXRoLm1pbih0aGlzLndpZHRoIC8gdGhpcy5pbWd3aWR0aCwgdGhpcy5oZWlnaHQgLyB0aGlzLmltZ2hlaWdodCkpKSwgdGhpcy5lbGVtZW50ICYmIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoYSwgYyksIHRoaXMuYWxpZ25CeVRyYW5zbGF0ZSB8fCAoZltwXSA9ICgodGhpc1thXSB8fCAwKSAtIGMpIC8gMiwgdGhpcy5hdHRyKGYpKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHkoYSkgJiYgdy5hdHRyKHtcbiAgICAgICAgICAgIHg6IGEsXG4gICAgICAgICAgICB5OiBjXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdy5pc0ltZyA9ICEwO1xuICAgICAgICAgIHkody5pbWd3aWR0aCkgJiYgeSh3LmltZ2hlaWdodCkgPyB6KCkgOiAody5hdHRyKHtcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgICAgfSksIEcoXCJpbWdcIiwge1xuICAgICAgICAgICAgb25sb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBiID0gQlttLmNoYXJ0SW5kZXhdO1xuICAgICAgICAgICAgICAwID09PSB0aGlzLndpZHRoICYmIChKKHRoaXMsIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgIHRvcDogXCItOTk5ZW1cIlxuICAgICAgICAgICAgICB9KSwgUS5ib2R5LmFwcGVuZENoaWxkKHRoaXMpKTtcbiAgICAgICAgICAgICAgT1t2XSA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHcuaW1nd2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICAgICAgICB3LmltZ2hlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgICB3LmVsZW1lbnQgJiYgeigpO1xuICAgICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUgJiYgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICAgICAgICBtLmltZ0NvdW50LS07XG4gICAgICAgICAgICAgIGlmICghbS5pbWdDb3VudCAmJiBiICYmICFiLmhhc0xvYWRlZCkgYi5vbmxvYWQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzcmM6IHZcbiAgICAgICAgICB9KSwgdGhpcy5pbWdDb3VudCsrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB3O1xuICAgICAgfSxcbiAgICAgIHN5bWJvbHM6IHtcbiAgICAgICAgY2lyY2xlOiBmdW5jdGlvbiAoYiwgYSwgZiwgYykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFyYyhiICsgZiAvIDIsIGEgKyBjIC8gMiwgZiAvIDIsIGMgLyAyLCB7XG4gICAgICAgICAgICBzdGFydDogLjUgKiBNYXRoLlBJLFxuICAgICAgICAgICAgZW5kOiAyLjUgKiBNYXRoLlBJLFxuICAgICAgICAgICAgb3BlbjogITFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc3F1YXJlOiBmdW5jdGlvbiAoYiwgYSwgZiwgYykge1xuICAgICAgICAgIHJldHVybiBbXCJNXCIsIGIsIGEsIFwiTFwiLCBiICsgZiwgYSwgYiArIGYsIGEgKyBjLCBiLCBhICsgYywgXCJaXCJdO1xuICAgICAgICB9LFxuICAgICAgICB0cmlhbmdsZTogZnVuY3Rpb24gKGIsIGEsIGYsIGMpIHtcbiAgICAgICAgICByZXR1cm4gW1wiTVwiLCBiICsgZiAvIDIsIGEsIFwiTFwiLCBiICsgZiwgYSArIGMsIGIsIGEgKyBjLCBcIlpcIl07XG4gICAgICAgIH0sXG4gICAgICAgIFwidHJpYW5nbGUtZG93blwiOiBmdW5jdGlvbiAoYiwgYSwgZiwgYykge1xuICAgICAgICAgIHJldHVybiBbXCJNXCIsIGIsIGEsIFwiTFwiLCBiICsgZiwgYSwgYiArIGYgLyAyLCBhICsgYywgXCJaXCJdO1xuICAgICAgICB9LFxuICAgICAgICBkaWFtb25kOiBmdW5jdGlvbiAoYiwgYSwgZiwgYykge1xuICAgICAgICAgIHJldHVybiBbXCJNXCIsIGIgKyBmIC8gMiwgYSwgXCJMXCIsIGIgKyBmLCBhICsgYyAvIDIsIGIgKyBmIC8gMiwgYSArIGMsIGIsIGEgKyBjIC8gMiwgXCJaXCJdO1xuICAgICAgICB9LFxuICAgICAgICBhcmM6IGZ1bmN0aW9uIChiLCBhLCBjLCBwLCBlKSB7XG4gICAgICAgICAgdmFyIHggPSBlLnN0YXJ0LFxuICAgICAgICAgICAgICBtID0gZS5yIHx8IGMsXG4gICAgICAgICAgICAgIGwgPSBlLnIgfHwgcCB8fCBjLFxuICAgICAgICAgICAgICBDID0gZS5lbmQgLSAuMDAxO1xuICAgICAgICAgIGMgPSBlLmlubmVyUjtcbiAgICAgICAgICBwID0gZihlLm9wZW4sIC4wMDEgPiBNYXRoLmFicyhlLmVuZCAtIGUuc3RhcnQgLSAyICogTWF0aC5QSSkpO1xuICAgICAgICAgIHZhciBrID0gTWF0aC5jb3MoeCksXG4gICAgICAgICAgICAgIG4gPSBNYXRoLnNpbih4KSxcbiAgICAgICAgICAgICAgdyA9IE1hdGguY29zKEMpO1xuICAgICAgICAgIEMgPSBNYXRoLnNpbihDKTtcbiAgICAgICAgICB4ID0gZihlLmxvbmdBcmMsIC4wMDEgPiBlLmVuZCAtIHggLSBNYXRoLlBJID8gMCA6IDEpO1xuICAgICAgICAgIG0gPSBbXCJNXCIsIGIgKyBtICogaywgYSArIGwgKiBuLCBcIkFcIiwgbSwgbCwgMCwgeCwgZihlLmNsb2Nrd2lzZSwgMSksIGIgKyBtICogdywgYSArIGwgKiBDXTtcbiAgICAgICAgICB5KGMpICYmIG0ucHVzaChwID8gXCJNXCIgOiBcIkxcIiwgYiArIGMgKiB3LCBhICsgYyAqIEMsIFwiQVwiLCBjLCBjLCAwLCB4LCB5KGUuY2xvY2t3aXNlKSA/IDEgLSBlLmNsb2Nrd2lzZSA6IDAsIGIgKyBjICogaywgYSArIGMgKiBuKTtcbiAgICAgICAgICBtLnB1c2gocCA/IFwiXCIgOiBcIlpcIik7XG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGxvdXQ6IGZ1bmN0aW9uIChiLCBhLCBmLCBjLCBwKSB7XG4gICAgICAgICAgdmFyIGUgPSBNYXRoLm1pbihwICYmIHAuciB8fCAwLCBmLCBjKSxcbiAgICAgICAgICAgICAgeCA9IGUgKyA2LFxuICAgICAgICAgICAgICBsID0gcCAmJiBwLmFuY2hvclg7XG4gICAgICAgICAgcCA9IHAgJiYgcC5hbmNob3JZO1xuICAgICAgICAgIHZhciBtID0gW1wiTVwiLCBiICsgZSwgYSwgXCJMXCIsIGIgKyBmIC0gZSwgYSwgXCJDXCIsIGIgKyBmLCBhLCBiICsgZiwgYSwgYiArIGYsIGEgKyBlLCBcIkxcIiwgYiArIGYsIGEgKyBjIC0gZSwgXCJDXCIsIGIgKyBmLCBhICsgYywgYiArIGYsIGEgKyBjLCBiICsgZiAtIGUsIGEgKyBjLCBcIkxcIiwgYiArIGUsIGEgKyBjLCBcIkNcIiwgYiwgYSArIGMsIGIsIGEgKyBjLCBiLCBhICsgYyAtIGUsIFwiTFwiLCBiLCBhICsgZSwgXCJDXCIsIGIsIGEsIGIsIGEsIGIgKyBlLCBhXTtcbiAgICAgICAgICBsICYmIGwgPiBmID8gcCA+IGEgKyB4ICYmIHAgPCBhICsgYyAtIHggPyBtLnNwbGljZSgxMywgMywgXCJMXCIsIGIgKyBmLCBwIC0gNiwgYiArIGYgKyA2LCBwLCBiICsgZiwgcCArIDYsIGIgKyBmLCBhICsgYyAtIGUpIDogbS5zcGxpY2UoMTMsIDMsIFwiTFwiLCBiICsgZiwgYyAvIDIsIGwsIHAsIGIgKyBmLCBjIC8gMiwgYiArIGYsIGEgKyBjIC0gZSkgOiBsICYmIDAgPiBsID8gcCA+IGEgKyB4ICYmIHAgPCBhICsgYyAtIHggPyBtLnNwbGljZSgzMywgMywgXCJMXCIsIGIsIHAgKyA2LCBiIC0gNiwgcCwgYiwgcCAtIDYsIGIsIGEgKyBlKSA6IG0uc3BsaWNlKDMzLCAzLCBcIkxcIiwgYiwgYyAvIDIsIGwsIHAsIGIsIGMgLyAyLCBiLCBhICsgZSkgOiBwICYmIHAgPiBjICYmIGwgPiBiICsgeCAmJiBsIDwgYiArIGYgLSB4ID8gbS5zcGxpY2UoMjMsIDMsIFwiTFwiLCBsICsgNiwgYSArIGMsIGwsIGEgKyBjICsgNiwgbCAtIDYsIGEgKyBjLCBiICsgZSwgYSArIGMpIDogcCAmJiAwID4gcCAmJiBsID4gYiArIHggJiYgbCA8IGIgKyBmIC0geCAmJiBtLnNwbGljZSgzLCAzLCBcIkxcIiwgbCAtIDYsIGEsIGwsIGEgLSA2LCBsICsgNiwgYSwgZiAtIGUsIGEpO1xuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2xpcFJlY3Q6IGZ1bmN0aW9uIChiLCBhLCBmLCBjKSB7XG4gICAgICAgIHZhciBwID0gdygpICsgXCItXCIsXG4gICAgICAgICAgICBlID0gdGhpcy5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIikuYXR0cih7XG4gICAgICAgICAgaWQ6IHBcbiAgICAgICAgfSkuYWRkKHRoaXMuZGVmcyk7XG4gICAgICAgIGIgPSB0aGlzLnJlY3QoYiwgYSwgZiwgYywgMCkuYWRkKGUpO1xuICAgICAgICBiLmlkID0gcDtcbiAgICAgICAgYi5jbGlwUGF0aCA9IGU7XG4gICAgICAgIGIuY291bnQgPSAwO1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0sXG4gICAgICB0ZXh0OiBmdW5jdGlvbiAoYiwgYSwgZiwgYykge1xuICAgICAgICB2YXIgcCA9IHt9O1xuICAgICAgICBpZiAoYyAmJiAodGhpcy5hbGxvd0hUTUwgfHwgIXRoaXMuZm9yRXhwb3J0KSkgcmV0dXJuIHRoaXMuaHRtbChiLCBhLCBmKTtcbiAgICAgICAgcC54ID0gTWF0aC5yb3VuZChhIHx8IDApO1xuICAgICAgICBmICYmIChwLnkgPSBNYXRoLnJvdW5kKGYpKTtcbiAgICAgICAgeShiKSAmJiAocC50ZXh0ID0gYik7XG4gICAgICAgIGIgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0XCIpLmF0dHIocCk7XG4gICAgICAgIGMgfHwgKGIueFNldHRlciA9IGZ1bmN0aW9uIChiLCBhLCBmKSB7XG4gICAgICAgICAgdmFyIGMgPSBmLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidHNwYW5cIiksXG4gICAgICAgICAgICAgIHAgPSBmLmdldEF0dHJpYnV0ZShhKSxcbiAgICAgICAgICAgICAgZTtcblxuICAgICAgICAgIGZvciAoZSA9IDA7IGUgPCBjLmxlbmd0aDsgZSsrKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGNbZV07XG4gICAgICAgICAgICB4LmdldEF0dHJpYnV0ZShhKSA9PT0gcCAmJiB4LnNldEF0dHJpYnV0ZShhLCBiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmLnNldEF0dHJpYnV0ZShhLCBiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSxcbiAgICAgIGZvbnRNZXRyaWNzOiBmdW5jdGlvbiAoYiwgZikge1xuICAgICAgICBiID0gIXRoaXMuc3R5bGVkTW9kZSAmJiAvcHgvLnRlc3QoYikgfHwgIVguZ2V0Q29tcHV0ZWRTdHlsZSA/IGIgfHwgZiAmJiBmLnN0eWxlICYmIGYuc3R5bGUuZm9udFNpemUgfHwgdGhpcy5zdHlsZSAmJiB0aGlzLnN0eWxlLmZvbnRTaXplIDogZiAmJiBVLnByb3RvdHlwZS5nZXRTdHlsZS5jYWxsKGYsIFwiZm9udC1zaXplXCIpO1xuICAgICAgICBiID0gL3B4Ly50ZXN0KGIpID8gYShiKSA6IDEyO1xuICAgICAgICBmID0gMjQgPiBiID8gYiArIDMgOiBNYXRoLnJvdW5kKDEuMiAqIGIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGg6IGYsXG4gICAgICAgICAgYjogTWF0aC5yb3VuZCguOCAqIGYpLFxuICAgICAgICAgIGY6IGJcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICByb3RDb3JyOiBmdW5jdGlvbiAoYiwgYSwgZikge1xuICAgICAgICB2YXIgYyA9IGI7XG4gICAgICAgIGEgJiYgZiAmJiAoYyA9IE1hdGgubWF4KGMgKiBNYXRoLmNvcyhhICogTCksIDQpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiAtYiAvIDMgKiBNYXRoLnNpbihhICogTCksXG4gICAgICAgICAgeTogY1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGxhYmVsOiBmdW5jdGlvbiAoYiwgYSwgZiwgYywgcCwgZSwgeCwgQywgbikge1xuICAgICAgICB2YXIgbSA9IHRoaXMsXG4gICAgICAgICAgICB3ID0gbS5zdHlsZWRNb2RlLFxuICAgICAgICAgICAgdiA9IG0uZyhcImJ1dHRvblwiICE9PSBuICYmIFwibGFiZWxcIiksXG4gICAgICAgICAgICBGID0gdi50ZXh0ID0gbS50ZXh0KFwiXCIsIDAsIDAsIHgpLmF0dHIoe1xuICAgICAgICAgIHpJbmRleDogMVxuICAgICAgICB9KSxcbiAgICAgICAgICAgIHosXG4gICAgICAgICAgICBPLFxuICAgICAgICAgICAgcSA9IDAsXG4gICAgICAgICAgICBSID0gMyxcbiAgICAgICAgICAgIEIgPSAwLFxuICAgICAgICAgICAgZCxcbiAgICAgICAgICAgIE4sXG4gICAgICAgICAgICBYLFxuICAgICAgICAgICAgVixcbiAgICAgICAgICAgIEwsXG4gICAgICAgICAgICB0ID0ge30sXG4gICAgICAgICAgICBULFxuICAgICAgICAgICAgZyxcbiAgICAgICAgICAgIFEgPSAvXnVybFxcKCguKj8pXFwpJC8udGVzdChjKSxcbiAgICAgICAgICAgIEggPSB3IHx8IFEsXG4gICAgICAgICAgICBLID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB3ID8gei5zdHJva2VXaWR0aCgpICUgMiAvIDIgOiAoVCA/IHBhcnNlSW50KFQsIDEwKSA6IDApICUgMiAvIDI7XG4gICAgICAgIH07XG5cbiAgICAgICAgbiAmJiB2LmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIiArIG4pO1xuXG4gICAgICAgIHZhciBiYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYiA9IEYuZWxlbWVudC5zdHlsZSxcbiAgICAgICAgICAgICAgYSA9IHt9O1xuICAgICAgICAgIE8gPSAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGQgfHwgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIE4gfHwgTCkgJiYgeShGLnRleHRTdHIpICYmIEYuZ2V0QkJveCgpO1xuICAgICAgICAgIHYud2lkdGggPSAoZCB8fCBPLndpZHRoIHx8IDApICsgMiAqIFIgKyBCO1xuICAgICAgICAgIHYuaGVpZ2h0ID0gKE4gfHwgTy5oZWlnaHQgfHwgMCkgKyAyICogUjtcbiAgICAgICAgICBnID0gUiArIE1hdGgubWluKG0uZm9udE1ldHJpY3MoYiAmJiBiLmZvbnRTaXplLCBGKS5iLCBPID8gTy5oZWlnaHQgOiBJbmZpbml0eSk7XG4gICAgICAgICAgSCAmJiAoeiB8fCAodi5ib3ggPSB6ID0gbS5zeW1ib2xzW2NdIHx8IFEgPyBtLnN5bWJvbChjKSA6IG0ucmVjdCgpLCB6LmFkZENsYXNzKChcImJ1dHRvblwiID09PSBuID8gXCJcIiA6IFwiaGlnaGNoYXJ0cy1sYWJlbC1ib3hcIikgKyAobiA/IFwiIGhpZ2hjaGFydHMtXCIgKyBuICsgXCItYm94XCIgOiBcIlwiKSksIHouYWRkKHYpLCBiID0gSygpLCBhLnggPSBiLCBhLnkgPSAoQyA/IC1nIDogMCkgKyBiKSwgYS53aWR0aCA9IE1hdGgucm91bmQodi53aWR0aCksIGEuaGVpZ2h0ID0gTWF0aC5yb3VuZCh2LmhlaWdodCksIHouYXR0cihoKGEsIHQpKSwgdCA9IHt9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYiA9IEIgKyBSO1xuICAgICAgICAgIHZhciBhID0gQyA/IDAgOiBnO1xuICAgICAgICAgIHkoZCkgJiYgTyAmJiAoXCJjZW50ZXJcIiA9PT0gTCB8fCBcInJpZ2h0XCIgPT09IEwpICYmIChiICs9IHtcbiAgICAgICAgICAgIGNlbnRlcjogLjUsXG4gICAgICAgICAgICByaWdodDogMVxuICAgICAgICAgIH1bTF0gKiAoZCAtIE8ud2lkdGgpKTtcbiAgICAgICAgICBpZiAoYiAhPT0gRi54IHx8IGEgIT09IEYueSkgRi5hdHRyKFwieFwiLCBiKSwgRi5oYXNCb3hXaWR0aENoYW5nZWQgJiYgKE8gPSBGLmdldEJCb3goITApLCBiYSgpKSwgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGEgJiYgRi5hdHRyKFwieVwiLCBhKTtcbiAgICAgICAgICBGLnggPSBiO1xuICAgICAgICAgIEYueSA9IGE7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIFkgPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIHogPyB6LmF0dHIoYiwgYSkgOiB0W2JdID0gYTtcbiAgICAgICAgfTtcblxuICAgICAgICB2Lm9uQWRkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIEYuYWRkKHYpO1xuICAgICAgICAgIHYuYXR0cih7XG4gICAgICAgICAgICB0ZXh0OiBiIHx8IDAgPT09IGIgPyBiIDogXCJcIixcbiAgICAgICAgICAgIHg6IGEsXG4gICAgICAgICAgICB5OiBmXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgeiAmJiB5KHApICYmIHYuYXR0cih7XG4gICAgICAgICAgICBhbmNob3JYOiBwLFxuICAgICAgICAgICAgYW5jaG9yWTogZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHYud2lkdGhTZXR0ZXIgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGQgPSBQKGIpID8gYiA6IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgdi5oZWlnaHRTZXR0ZXIgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIE4gPSBiO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZbXCJ0ZXh0LWFsaWduU2V0dGVyXCJdID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBMID0gYjtcbiAgICAgICAgfTtcblxuICAgICAgICB2LnBhZGRpbmdTZXR0ZXIgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHkoYikgJiYgYiAhPT0gUiAmJiAoUiA9IHYucGFkZGluZyA9IGIsIHUoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdi5wYWRkaW5nTGVmdFNldHRlciA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgeShiKSAmJiBiICE9PSBCICYmIChCID0gYiwgdSgpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2LmFsaWduU2V0dGVyID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBiID0ge1xuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIGNlbnRlcjogLjUsXG4gICAgICAgICAgICByaWdodDogMVxuICAgICAgICAgIH1bYl07XG4gICAgICAgICAgYiAhPT0gcSAmJiAocSA9IGIsIE8gJiYgdi5hdHRyKHtcbiAgICAgICAgICAgIHg6IFhcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdi50ZXh0U2V0dGVyID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYiAmJiBGLmF0dHIoe1xuICAgICAgICAgICAgdGV4dDogYlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJhKCk7XG4gICAgICAgICAgdSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZbXCJzdHJva2Utd2lkdGhTZXR0ZXJcIl0gPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIGIgJiYgKEggPSAhMCk7XG4gICAgICAgICAgVCA9IHRoaXNbXCJzdHJva2Utd2lkdGhcIl0gPSBiO1xuICAgICAgICAgIFkoYSwgYik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdyA/IHYuclNldHRlciA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgWShhLCBiKTtcbiAgICAgICAgfSA6IHYuc3Ryb2tlU2V0dGVyID0gdi5maWxsU2V0dGVyID0gdi5yU2V0dGVyID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBcInJcIiAhPT0gYSAmJiAoXCJmaWxsXCIgPT09IGEgJiYgYiAmJiAoSCA9ICEwKSwgdlthXSA9IGIpO1xuICAgICAgICAgIFkoYSwgYik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdi5hbmNob3JYU2V0dGVyID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBwID0gdi5hbmNob3JYID0gYjtcbiAgICAgICAgICBZKGEsIE1hdGgucm91bmQoYikgLSBLKCkgLSBYKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2LmFuY2hvcllTZXR0ZXIgPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIGUgPSB2LmFuY2hvclkgPSBiO1xuICAgICAgICAgIFkoYSwgYiAtIFYpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHYueFNldHRlciA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgdi54ID0gYjtcbiAgICAgICAgICBxICYmIChiIC09IHEgKiAoKGQgfHwgTy53aWR0aCkgKyAyICogUiksIHZbXCJmb3JjZUFuaW1hdGU6eFwiXSA9ICEwKTtcbiAgICAgICAgICBYID0gTWF0aC5yb3VuZChiKTtcbiAgICAgICAgICB2LmF0dHIoXCJ0cmFuc2xhdGVYXCIsIFgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHYueVNldHRlciA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgViA9IHYueSA9IE1hdGgucm91bmQoYik7XG4gICAgICAgICAgdi5hdHRyKFwidHJhbnNsYXRlWVwiLCBWKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgRCA9IHYuY3NzO1xuICAgICAgICB4ID0ge1xuICAgICAgICAgIGNzczogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICAgIHZhciBhID0ge307XG4gICAgICAgICAgICAgIGIgPSBrKGIpO1xuICAgICAgICAgICAgICB2LnRleHRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGJbZl0gJiYgKGFbZl0gPSBiW2ZdLCBkZWxldGUgYltmXSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBGLmNzcyhhKTtcbiAgICAgICAgICAgICAgXCJ3aWR0aFwiIGluIGEgJiYgYmEoKTtcbiAgICAgICAgICAgICAgXCJmb250U2l6ZVwiIGluIGEgJiYgKGJhKCksIHUoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBELmNhbGwodiwgYik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXRCQm94OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB3aWR0aDogTy53aWR0aCArIDIgKiBSLFxuICAgICAgICAgICAgICBoZWlnaHQ6IE8uaGVpZ2h0ICsgMiAqIFIsXG4gICAgICAgICAgICAgIHg6IE8ueCAtIFIsXG4gICAgICAgICAgICAgIHk6IE8ueSAtIFJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsKHYuZWxlbWVudCwgXCJtb3VzZWVudGVyXCIpO1xuICAgICAgICAgICAgbCh2LmVsZW1lbnQsIFwibW91c2VsZWF2ZVwiKTtcbiAgICAgICAgICAgIEYgJiYgKEYgPSBGLmRlc3Ryb3koKSk7XG4gICAgICAgICAgICB6ICYmICh6ID0gei5kZXN0cm95KCkpO1xuICAgICAgICAgICAgVS5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHYpO1xuICAgICAgICAgICAgdiA9IG0gPSBiYSA9IHUgPSBZID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHcgfHwgKHguc2hhZG93ID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBiICYmIChiYSgpLCB6ICYmIHouc2hhZG93KGIpKTtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoKHYsIHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGQuUmVuZGVyZXIgPSBnO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL0h0bWwuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcpIHtcbiAgICB2YXIgciA9IGcuYXR0cixcbiAgICAgICAgdSA9IGcuY3JlYXRlRWxlbWVudCxcbiAgICAgICAgSSA9IGcuY3NzLFxuICAgICAgICBNID0gZy5kZWZpbmVkLFxuICAgICAgICBFID0gZy5leHRlbmQsXG4gICAgICAgIEEgPSBnLnBpY2ssXG4gICAgICAgIEcgPSBnLnBJbnQsXG4gICAgICAgIEogPSBkLmlzRmlyZWZveCxcbiAgICAgICAgeSA9IGQuaXNNUyxcbiAgICAgICAgdCA9IGQuaXNXZWJLaXQsXG4gICAgICAgIEQgPSBkLlNWR0VsZW1lbnQ7XG4gICAgZyA9IGQuU1ZHUmVuZGVyZXI7XG4gICAgdmFyIGggPSBkLndpbjtcbiAgICBFKEQucHJvdG90eXBlLCB7XG4gICAgICBodG1sQ3NzOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgcSA9IFwiU1BBTlwiID09PSB0aGlzLmVsZW1lbnQudGFnTmFtZSAmJiBkICYmIFwid2lkdGhcIiBpbiBkLFxuICAgICAgICAgICAgTiA9IEEocSAmJiBkLndpZHRoLCB2b2lkIDApO1xuXG4gICAgICAgIGlmIChxKSB7XG4gICAgICAgICAgZGVsZXRlIGQud2lkdGg7XG4gICAgICAgICAgdGhpcy50ZXh0V2lkdGggPSBOO1xuICAgICAgICAgIHZhciBlID0gITA7XG4gICAgICAgIH1cblxuICAgICAgICBkICYmIFwiZWxsaXBzaXNcIiA9PT0gZC50ZXh0T3ZlcmZsb3cgJiYgKGQud2hpdGVTcGFjZSA9IFwibm93cmFwXCIsIGQub3ZlcmZsb3cgPSBcImhpZGRlblwiKTtcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBFKHRoaXMuc3R5bGVzLCBkKTtcbiAgICAgICAgSSh0aGlzLmVsZW1lbnQsIGQpO1xuICAgICAgICBlICYmIHRoaXMuaHRtbFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBodG1sR2V0QkJveDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZCA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBkLm9mZnNldExlZnQsXG4gICAgICAgICAgeTogZC5vZmZzZXRUb3AsXG4gICAgICAgICAgd2lkdGg6IGQub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBkLm9mZnNldEhlaWdodFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGh0bWxVcGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWRkZWQpIHtcbiAgICAgICAgICB2YXIgZCA9IHRoaXMucmVuZGVyZXIsXG4gICAgICAgICAgICAgIHEgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgICAgIGggPSB0aGlzLnRyYW5zbGF0ZVggfHwgMCxcbiAgICAgICAgICAgICAgZSA9IHRoaXMudHJhbnNsYXRlWSB8fCAwLFxuICAgICAgICAgICAgICBjID0gdGhpcy54IHx8IDAsXG4gICAgICAgICAgICAgIGsgPSB0aGlzLnkgfHwgMCxcbiAgICAgICAgICAgICAgbiA9IHRoaXMudGV4dEFsaWduIHx8IFwibGVmdFwiLFxuICAgICAgICAgICAgICBmID0ge1xuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIGNlbnRlcjogLjUsXG4gICAgICAgICAgICByaWdodDogMVxuICAgICAgICAgIH1bbl0sXG4gICAgICAgICAgICAgIGEgPSB0aGlzLnN0eWxlcyxcbiAgICAgICAgICAgICAgbCA9IGEgJiYgYS53aGl0ZVNwYWNlO1xuICAgICAgICAgIEkocSwge1xuICAgICAgICAgICAgbWFyZ2luTGVmdDogaCxcbiAgICAgICAgICAgIG1hcmdpblRvcDogZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgICFkLnN0eWxlZE1vZGUgJiYgdGhpcy5zaGFkb3dzICYmIHRoaXMuc2hhZG93cy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBJKGEsIHtcbiAgICAgICAgICAgICAgbWFyZ2luTGVmdDogaCArIDEsXG4gICAgICAgICAgICAgIG1hcmdpblRvcDogZSArIDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuaW52ZXJ0ZWQgJiYgW10uZm9yRWFjaC5jYWxsKHEuY2hpbGROb2RlcywgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGQuaW52ZXJ0Q2hpbGQoYSwgcSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoXCJTUEFOXCIgPT09IHEudGFnTmFtZSkge1xuICAgICAgICAgICAgYSA9IHRoaXMucm90YXRpb247XG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMudGV4dFdpZHRoICYmIEcodGhpcy50ZXh0V2lkdGgpLFxuICAgICAgICAgICAgICAgIHogPSBbYSwgbiwgcS5pbm5lckhUTUwsIHRoaXMudGV4dFdpZHRoLCB0aGlzLnRleHRBbGlnbl0uam9pbigpLFxuICAgICAgICAgICAgICAgIHc7XG4gICAgICAgICAgICAodyA9IHYgIT09IHRoaXMub2xkVGV4dFdpZHRoKSAmJiAhKHcgPSB2ID4gdGhpcy5vbGRUZXh0V2lkdGgpICYmICgodyA9IHRoaXMudGV4dFB4TGVuZ3RoKSB8fCAoSShxLCB7XG4gICAgICAgICAgICAgIHdpZHRoOiBcIlwiLFxuICAgICAgICAgICAgICB3aGl0ZVNwYWNlOiBsIHx8IFwibm93cmFwXCJcbiAgICAgICAgICAgIH0pLCB3ID0gcS5vZmZzZXRXaWR0aCksIHcgPSB3ID4gdik7XG4gICAgICAgICAgICB3ICYmICgvWyBcXC1dLy50ZXN0KHEudGV4dENvbnRlbnQgfHwgcS5pbm5lclRleHQpIHx8IFwiZWxsaXBzaXNcIiA9PT0gcS5zdHlsZS50ZXh0T3ZlcmZsb3cpID8gKEkocSwge1xuICAgICAgICAgICAgICB3aWR0aDogdiArIFwicHhcIixcbiAgICAgICAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICAgICAgICB3aGl0ZVNwYWNlOiBsIHx8IFwibm9ybWFsXCJcbiAgICAgICAgICAgIH0pLCB0aGlzLm9sZFRleHRXaWR0aCA9IHYsIHRoaXMuaGFzQm94V2lkdGhDaGFuZ2VkID0gITApIDogdGhpcy5oYXNCb3hXaWR0aENoYW5nZWQgPSAhMTtcbiAgICAgICAgICAgIHogIT09IHRoaXMuY1RUICYmIChsID0gZC5mb250TWV0cmljcyhxLnN0eWxlLmZvbnRTaXplLCBxKS5iLCAhTShhKSB8fCBhID09PSAodGhpcy5vbGRSb3RhdGlvbiB8fCAwKSAmJiBuID09PSB0aGlzLm9sZEFsaWduIHx8IHRoaXMuc2V0U3BhblJvdGF0aW9uKGEsIGYsIGwpLCB0aGlzLmdldFNwYW5Db3JyZWN0aW9uKCFNKGEpICYmIHRoaXMudGV4dFB4TGVuZ3RoIHx8IHEub2Zmc2V0V2lkdGgsIGwsIGYsIGEsIG4pKTtcbiAgICAgICAgICAgIEkocSwge1xuICAgICAgICAgICAgICBsZWZ0OiBjICsgKHRoaXMueENvcnIgfHwgMCkgKyBcInB4XCIsXG4gICAgICAgICAgICAgIHRvcDogayArICh0aGlzLnlDb3JyIHx8IDApICsgXCJweFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY1RUID0gejtcbiAgICAgICAgICAgIHRoaXMub2xkUm90YXRpb24gPSBhO1xuICAgICAgICAgICAgdGhpcy5vbGRBbGlnbiA9IG47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgdGhpcy5hbGlnbk9uQWRkID0gITA7XG4gICAgICB9LFxuICAgICAgc2V0U3BhblJvdGF0aW9uOiBmdW5jdGlvbiAoZCwgcSwgaCkge1xuICAgICAgICB2YXIgZSA9IHt9LFxuICAgICAgICAgICAgYyA9IHRoaXMucmVuZGVyZXIuZ2V0VHJhbnNmb3JtS2V5KCk7XG4gICAgICAgIGVbY10gPSBlLnRyYW5zZm9ybSA9IFwicm90YXRlKFwiICsgZCArIFwiZGVnKVwiO1xuICAgICAgICBlW2MgKyAoSiA/IFwiT3JpZ2luXCIgOiBcIi1vcmlnaW5cIildID0gZS50cmFuc2Zvcm1PcmlnaW4gPSAxMDAgKiBxICsgXCIlIFwiICsgaCArIFwicHhcIjtcbiAgICAgICAgSSh0aGlzLmVsZW1lbnQsIGUpO1xuICAgICAgfSxcbiAgICAgIGdldFNwYW5Db3JyZWN0aW9uOiBmdW5jdGlvbiAoZCwgcSwgaCkge1xuICAgICAgICB0aGlzLnhDb3JyID0gLWQgKiBoO1xuICAgICAgICB0aGlzLnlDb3JyID0gLXE7XG4gICAgICB9XG4gICAgfSk7XG4gICAgRShnLnByb3RvdHlwZSwge1xuICAgICAgZ2V0VHJhbnNmb3JtS2V5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB5ICYmICEvRWRnZS8udGVzdChoLm5hdmlnYXRvci51c2VyQWdlbnQpID8gXCItbXMtdHJhbnNmb3JtXCIgOiB0ID8gXCItd2Via2l0LXRyYW5zZm9ybVwiIDogSiA/IFwiTW96VHJhbnNmb3JtXCIgOiBoLm9wZXJhID8gXCItby10cmFuc2Zvcm1cIiA6IFwiXCI7XG4gICAgICB9LFxuICAgICAgaHRtbDogZnVuY3Rpb24gKGQsIHEsIGgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpLFxuICAgICAgICAgICAgYyA9IGUuZWxlbWVudCxcbiAgICAgICAgICAgIGsgPSBlLnJlbmRlcmVyLFxuICAgICAgICAgICAgbiA9IGsuaXNTVkcsXG4gICAgICAgICAgICBmID0gZnVuY3Rpb24gKGEsIGYpIHtcbiAgICAgICAgICBbXCJvcGFjaXR5XCIsIFwidmlzaWJpbGl0eVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBhW2MgKyBcIlNldHRlclwiXSA9IGZ1bmN0aW9uIChlLCBsLCBrKSB7XG4gICAgICAgICAgICAgIHZhciB2ID0gYS5kaXYgPyBhLmRpdi5zdHlsZSA6IGY7XG4gICAgICAgICAgICAgIEQucHJvdG90eXBlW2MgKyBcIlNldHRlclwiXS5jYWxsKHRoaXMsIGUsIGwsIGspO1xuICAgICAgICAgICAgICB2ICYmICh2W2xdID0gZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGEuYWRkZWRTZXR0ZXJzID0gITA7XG4gICAgICAgIH07XG5cbiAgICAgICAgZS50ZXh0U2V0dGVyID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhICE9PSBjLmlubmVySFRNTCAmJiAoZGVsZXRlIHRoaXMuYkJveCwgZGVsZXRlIHRoaXMub2xkVGV4dFdpZHRoKTtcbiAgICAgICAgICB0aGlzLnRleHRTdHIgPSBhO1xuICAgICAgICAgIGMuaW5uZXJIVE1MID0gQShhLCBcIlwiKTtcbiAgICAgICAgICBlLmRvVHJhbnNmb3JtID0gITA7XG4gICAgICAgIH07XG5cbiAgICAgICAgbiAmJiBmKGUsIGUuZWxlbWVudC5zdHlsZSk7XG5cbiAgICAgICAgZS54U2V0dGVyID0gZS55U2V0dGVyID0gZS5hbGlnblNldHRlciA9IGUucm90YXRpb25TZXR0ZXIgPSBmdW5jdGlvbiAoYSwgZikge1xuICAgICAgICAgIFwiYWxpZ25cIiA9PT0gZiAmJiAoZiA9IFwidGV4dEFsaWduXCIpO1xuICAgICAgICAgIGVbZl0gPSBhO1xuICAgICAgICAgIGUuZG9UcmFuc2Zvcm0gPSAhMDtcbiAgICAgICAgfTtcblxuICAgICAgICBlLmFmdGVyU2V0dGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLmRvVHJhbnNmb3JtICYmICh0aGlzLmh0bWxVcGRhdGVUcmFuc2Zvcm0oKSwgdGhpcy5kb1RyYW5zZm9ybSA9ICExKTtcbiAgICAgICAgfTtcblxuICAgICAgICBlLmF0dHIoe1xuICAgICAgICAgIHRleHQ6IGQsXG4gICAgICAgICAgeDogTWF0aC5yb3VuZChxKSxcbiAgICAgICAgICB5OiBNYXRoLnJvdW5kKGgpXG4gICAgICAgIH0pLmNzcyh7XG4gICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgICAgICB9KTtcbiAgICAgICAgay5zdHlsZWRNb2RlIHx8IGUuY3NzKHtcbiAgICAgICAgICBmb250RmFtaWx5OiB0aGlzLnN0eWxlLmZvbnRGYW1pbHksXG4gICAgICAgICAgZm9udFNpemU6IHRoaXMuc3R5bGUuZm9udFNpemVcbiAgICAgICAgfSk7XG4gICAgICAgIGMuc3R5bGUud2hpdGVTcGFjZSA9IFwibm93cmFwXCI7XG4gICAgICAgIGUuY3NzID0gZS5odG1sQ3NzO1xuICAgICAgICBuICYmIChlLmFkZCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgdmFyIGwgPSBrLmJveC5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICB2ID0gW107XG5cbiAgICAgICAgICBpZiAodGhpcy5wYXJlbnRHcm91cCA9IGEpIHtcbiAgICAgICAgICAgIHZhciBuID0gYS5kaXY7XG5cbiAgICAgICAgICAgIGlmICghbikge1xuICAgICAgICAgICAgICBmb3IgKDsgYTspIHYucHVzaChhKSwgYSA9IGEucGFyZW50R3JvdXA7XG5cbiAgICAgICAgICAgICAgdi5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGMoZiwgYykge1xuICAgICAgICAgICAgICAgICAgYVtjXSA9IGY7XG4gICAgICAgICAgICAgICAgICBcInRyYW5zbGF0ZVhcIiA9PT0gYyA/IHcubGVmdCA9IGYgKyBcInB4XCIgOiB3LnRvcCA9IGYgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICBhLmRvVHJhbnNmb3JtID0gITA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGsgPSByKGEuZWxlbWVudCwgXCJjbGFzc1wiKTtcbiAgICAgICAgICAgICAgICBuID0gYS5kaXYgPSBhLmRpdiB8fCB1KFwiZGl2XCIsIGsgPyB7XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGtcbiAgICAgICAgICAgICAgICB9IDogdm9pZCAwLCB7XG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgICAgbGVmdDogKGEudHJhbnNsYXRlWCB8fCAwKSArIFwicHhcIixcbiAgICAgICAgICAgICAgICAgIHRvcDogKGEudHJhbnNsYXRlWSB8fCAwKSArIFwicHhcIixcbiAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGEuZGlzcGxheSxcbiAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IGEub3BhY2l0eSxcbiAgICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IGEuc3R5bGVzICYmIGEuc3R5bGVzLnBvaW50ZXJFdmVudHNcbiAgICAgICAgICAgICAgICB9LCBuIHx8IGwpO1xuICAgICAgICAgICAgICAgIHZhciB3ID0gbi5zdHlsZTtcbiAgICAgICAgICAgICAgICBFKGEsIHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzU2V0dGVyOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZik7XG4gICAgICAgICAgICAgICAgICAgICAgYS5jbGFzc05hbWUgPSBmO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfShuKSxcbiAgICAgICAgICAgICAgICAgIG9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZbMF0uZGl2ICYmIGUub24uYXBwbHkoe1xuICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHZbMF0uZGl2XG4gICAgICAgICAgICAgICAgICAgIH0sIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVhTZXR0ZXI6IGMsXG4gICAgICAgICAgICAgICAgICB0cmFuc2xhdGVZU2V0dGVyOiBjXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYS5hZGRlZFNldHRlcnMgfHwgZihhKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIG4gPSBsO1xuXG4gICAgICAgICAgbi5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICBlLmFkZGVkID0gITA7XG4gICAgICAgICAgZS5hbGlnbk9uQWRkICYmIGUuaHRtbFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvVGljay5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZykge1xuICAgIHZhciByID0gZy5jbGFtcCxcbiAgICAgICAgdSA9IGcuY29ycmVjdEZsb2F0LFxuICAgICAgICBJID0gZy5kZWZpbmVkLFxuICAgICAgICBNID0gZy5kZXN0cm95T2JqZWN0UHJvcGVydGllcyxcbiAgICAgICAgRSA9IGcuZXh0ZW5kLFxuICAgICAgICBBID0gZy5pc051bWJlcixcbiAgICAgICAgRyA9IGcubWVyZ2UsXG4gICAgICAgIEogPSBnLm9iamVjdEVhY2gsXG4gICAgICAgIHkgPSBnLnBpY2ssXG4gICAgICAgIHQgPSBkLmZpcmVFdmVudCxcbiAgICAgICAgRCA9IGQuZGVnMnJhZDtcblxuICAgIGcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBoKGQsIHEsIGgsIGUsIGMpIHtcbiAgICAgICAgdGhpcy5pc05ld0xhYmVsID0gdGhpcy5pc05ldyA9ICEwO1xuICAgICAgICB0aGlzLmF4aXMgPSBkO1xuICAgICAgICB0aGlzLnBvcyA9IHE7XG4gICAgICAgIHRoaXMudHlwZSA9IGggfHwgXCJcIjtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0gYyB8fCB7fTtcbiAgICAgICAgdGhpcy50aWNrbWFya09mZnNldCA9IHRoaXMucGFyYW1ldGVycy50aWNrbWFya09mZnNldDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5wYXJhbWV0ZXJzLm9wdGlvbnM7XG4gICAgICAgIGggfHwgZSB8fCB0aGlzLmFkZExhYmVsKCk7XG4gICAgICB9XG5cbiAgICAgIGgucHJvdG90eXBlLmFkZExhYmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgICBxID0gZC5heGlzLFxuICAgICAgICAgICAgaCA9IHEub3B0aW9ucyxcbiAgICAgICAgICAgIGUgPSBxLmNoYXJ0LFxuICAgICAgICAgICAgYyA9IHEuY2F0ZWdvcmllcyxcbiAgICAgICAgICAgIGsgPSBxLm5hbWVzLFxuICAgICAgICAgICAgbiA9IGQucG9zLFxuICAgICAgICAgICAgZiA9IHkoZC5vcHRpb25zICYmIGQub3B0aW9ucy5sYWJlbHMsIGgubGFiZWxzKSxcbiAgICAgICAgICAgIGEgPSBxLnRpY2tQb3NpdGlvbnMsXG4gICAgICAgICAgICBsID0gbiA9PT0gYVswXSxcbiAgICAgICAgICAgIHYgPSBuID09PSBhW2EubGVuZ3RoIC0gMV07XG4gICAgICAgIGsgPSB0aGlzLnBhcmFtZXRlcnMuY2F0ZWdvcnkgfHwgKGMgPyB5KGNbbl0sIGtbbl0sIG4pIDogbik7XG4gICAgICAgIHZhciB6ID0gZC5sYWJlbDtcbiAgICAgICAgYyA9ICghZi5zdGVwIHx8IDEgPT09IGYuc3RlcCkgJiYgMSA9PT0gcS50aWNrSW50ZXJ2YWw7XG4gICAgICAgIGEgPSBhLmluZm87XG4gICAgICAgIHZhciB3LCBCO1xuXG4gICAgICAgIGlmIChxLmlzRGF0ZXRpbWVBeGlzICYmIGEpIHtcbiAgICAgICAgICB2YXIgTCA9IGUudGltZS5yZXNvbHZlRFRMRm9ybWF0KGguZGF0ZVRpbWVMYWJlbEZvcm1hdHNbIWguZ3JpZCAmJiBhLmhpZ2hlclJhbmtzW25dIHx8IGEudW5pdE5hbWVdKTtcbiAgICAgICAgICB2YXIgdCA9IEwubWFpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGQuaXNGaXJzdCA9IGw7XG4gICAgICAgIGQuaXNMYXN0ID0gdjtcbiAgICAgICAgZC5mb3JtYXRDdHggPSB7XG4gICAgICAgICAgYXhpczogcSxcbiAgICAgICAgICBjaGFydDogZSxcbiAgICAgICAgICBpc0ZpcnN0OiBsLFxuICAgICAgICAgIGlzTGFzdDogdixcbiAgICAgICAgICBkYXRlVGltZUxhYmVsRm9ybWF0OiB0LFxuICAgICAgICAgIHRpY2tQb3NpdGlvbkluZm86IGEsXG4gICAgICAgICAgdmFsdWU6IHEuaXNMb2cgPyB1KHEubGluMmxvZyhrKSkgOiBrLFxuICAgICAgICAgIHBvczogblxuICAgICAgICB9O1xuICAgICAgICBoID0gcS5sYWJlbEZvcm1hdHRlci5jYWxsKGQuZm9ybWF0Q3R4LCB0aGlzLmZvcm1hdEN0eCk7XG4gICAgICAgIGlmIChCID0gTCAmJiBMLmxpc3QpIGQuc2hvcnRlbkxhYmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZvciAodyA9IDA7IHcgPCBCLmxlbmd0aDsgdysrKSBpZiAoei5hdHRyKHtcbiAgICAgICAgICAgIHRleHQ6IHEubGFiZWxGb3JtYXR0ZXIuY2FsbChFKGQuZm9ybWF0Q3R4LCB7XG4gICAgICAgICAgICAgIGRhdGVUaW1lTGFiZWxGb3JtYXQ6IEJbd11cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIH0pLCB6LmdldEJCb3goKS53aWR0aCA8IHEuZ2V0U2xvdFdpZHRoKGQpIC0gMiAqIHkoZi5wYWRkaW5nLCA1KSkgcmV0dXJuO1xuXG4gICAgICAgICAgei5hdHRyKHtcbiAgICAgICAgICAgIHRleHQ6IFwiXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgYyAmJiBxLl9hZGRlZFBsb3RMQiAmJiBxLmlzWEF4aXMgJiYgZC5tb3ZlTGFiZWwoaCwgZik7XG4gICAgICAgIEkoeikgfHwgZC5tb3ZlZExhYmVsID8geiAmJiB6LnRleHRTdHIgIT09IGggJiYgIWMgJiYgKCF6LnRleHRXaWR0aCB8fCBmLnN0eWxlICYmIGYuc3R5bGUud2lkdGggfHwgei5zdHlsZXMud2lkdGggfHwgei5jc3Moe1xuICAgICAgICAgIHdpZHRoOiBudWxsXG4gICAgICAgIH0pLCB6LmF0dHIoe1xuICAgICAgICAgIHRleHQ6IGhcbiAgICAgICAgfSksIHoudGV4dFB4TGVuZ3RoID0gei5nZXRCQm94KCkud2lkdGgpIDogKGQubGFiZWwgPSB6ID0gZC5jcmVhdGVMYWJlbCh7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sIGgsIGYpLCBkLnJvdGF0aW9uID0gMCk7XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5jcmVhdGVMYWJlbCA9IGZ1bmN0aW9uIChkLCBxLCBoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5heGlzLFxuICAgICAgICAgICAgYyA9IGUuY2hhcnQ7XG4gICAgICAgIGlmIChkID0gSShxKSAmJiBoLmVuYWJsZWQgPyBjLnJlbmRlcmVyLnRleHQocSwgZC54LCBkLnksIGgudXNlSFRNTCkuYWRkKGUubGFiZWxHcm91cCkgOiBudWxsKSBjLnN0eWxlZE1vZGUgfHwgZC5jc3MoRyhoLnN0eWxlKSksIGQudGV4dFB4TGVuZ3RoID0gZC5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgIHJldHVybiBkO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgTSh0aGlzLCB0aGlzLmF4aXMpO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoZCwgcSwgaCwgZSkge1xuICAgICAgICB2YXIgYyA9IHRoaXMuYXhpcyxcbiAgICAgICAgICAgIGsgPSBjLmNoYXJ0LFxuICAgICAgICAgICAgbiA9IGUgJiYgay5vbGRDaGFydEhlaWdodCB8fCBrLmNoYXJ0SGVpZ2h0O1xuICAgICAgICBkID0ge1xuICAgICAgICAgIHg6IGQgPyB1KGMudHJhbnNsYXRlKHEgKyBoLCBudWxsLCBudWxsLCBlKSArIGMudHJhbnNCKSA6IGMubGVmdCArIGMub2Zmc2V0ICsgKGMub3Bwb3NpdGUgPyAoZSAmJiBrLm9sZENoYXJ0V2lkdGggfHwgay5jaGFydFdpZHRoKSAtIGMucmlnaHQgLSBjLmxlZnQgOiAwKSxcbiAgICAgICAgICB5OiBkID8gbiAtIGMuYm90dG9tICsgYy5vZmZzZXQgLSAoYy5vcHBvc2l0ZSA/IGMuaGVpZ2h0IDogMCkgOiB1KG4gLSBjLnRyYW5zbGF0ZShxICsgaCwgbnVsbCwgbnVsbCwgZSkgLSBjLnRyYW5zQilcbiAgICAgICAgfTtcbiAgICAgICAgZC55ID0gcihkLnksIC0xRTUsIDFFNSk7XG4gICAgICAgIHQodGhpcywgXCJhZnRlckdldFBvc2l0aW9uXCIsIHtcbiAgICAgICAgICBwb3M6IGRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUuZ2V0TGFiZWxQb3NpdGlvbiA9IGZ1bmN0aW9uIChkLCBxLCBoLCBlLCBjLCBrLCBuLCBmKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5heGlzLFxuICAgICAgICAgICAgbCA9IGEudHJhbnNBLFxuICAgICAgICAgICAgdiA9IGEuaXNMaW5rZWQgJiYgYS5saW5rZWRQYXJlbnQgPyBhLmxpbmtlZFBhcmVudC5yZXZlcnNlZCA6IGEucmV2ZXJzZWQsXG4gICAgICAgICAgICB6ID0gYS5zdGFnZ2VyTGluZXMsXG4gICAgICAgICAgICB3ID0gYS50aWNrUm90Q29yciB8fCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sXG4gICAgICAgICAgICBCID0gYy55LFxuICAgICAgICAgICAgTCA9IGUgfHwgYS5yZXNlcnZlU3BhY2VEZWZhdWx0ID8gMCA6IC1hLmxhYmVsT2Zmc2V0ICogKFwiY2VudGVyXCIgPT09IGEubGFiZWxBbGlnbiA/IC41IDogMSksXG4gICAgICAgICAgICBOID0ge307XG4gICAgICAgIEkoQikgfHwgKEIgPSAwID09PSBhLnNpZGUgPyBoLnJvdGF0aW9uID8gLTggOiAtaC5nZXRCQm94KCkuaGVpZ2h0IDogMiA9PT0gYS5zaWRlID8gdy55ICsgOCA6IE1hdGguY29zKGgucm90YXRpb24gKiBEKSAqICh3LnkgLSBoLmdldEJCb3goITEsIDApLmhlaWdodCAvIDIpKTtcbiAgICAgICAgZCA9IGQgKyBjLnggKyBMICsgdy54IC0gKGsgJiYgZSA/IGsgKiBsICogKHYgPyAtMSA6IDEpIDogMCk7XG4gICAgICAgIHEgPSBxICsgQiAtIChrICYmICFlID8gayAqIGwgKiAodiA/IDEgOiAtMSkgOiAwKTtcbiAgICAgICAgeiAmJiAoaCA9IG4gLyAoZiB8fCAxKSAlIHosIGEub3Bwb3NpdGUgJiYgKGggPSB6IC0gaCAtIDEpLCBxICs9IGEubGFiZWxPZmZzZXQgLyB6ICogaCk7XG4gICAgICAgIE4ueCA9IGQ7XG4gICAgICAgIE4ueSA9IE1hdGgucm91bmQocSk7XG4gICAgICAgIHQodGhpcywgXCJhZnRlckdldExhYmVsUG9zaXRpb25cIiwge1xuICAgICAgICAgIHBvczogTixcbiAgICAgICAgICB0aWNrbWFya09mZnNldDogayxcbiAgICAgICAgICBpbmRleDogblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE47XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5nZXRMYWJlbFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsID8gdGhpcy5sYWJlbC5nZXRCQm94KClbdGhpcy5heGlzLmhvcml6ID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIl0gOiAwO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUuZ2V0TWFya1BhdGggPSBmdW5jdGlvbiAoZCwgcSwgaCwgZSwgYywgaykge1xuICAgICAgICByZXR1cm4gay5jcmlzcExpbmUoW1wiTVwiLCBkLCBxLCBcIkxcIiwgZCArIChjID8gMCA6IC1oKSwgcSArIChjID8gaCA6IDApXSwgZSk7XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5oYW5kbGVPdmVyZmxvdyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBxID0gdGhpcy5heGlzLFxuICAgICAgICAgICAgaCA9IHEub3B0aW9ucy5sYWJlbHMsXG4gICAgICAgICAgICBlID0gZC54LFxuICAgICAgICAgICAgYyA9IHEuY2hhcnQuY2hhcnRXaWR0aCxcbiAgICAgICAgICAgIGsgPSBxLmNoYXJ0LnNwYWNpbmcsXG4gICAgICAgICAgICBuID0geShxLmxhYmVsTGVmdCwgTWF0aC5taW4ocS5wb3MsIGtbM10pKTtcbiAgICAgICAgayA9IHkocS5sYWJlbFJpZ2h0LCBNYXRoLm1heChxLmlzUmFkaWFsID8gMCA6IHEucG9zICsgcS5sZW4sIGMgLSBrWzFdKSk7XG4gICAgICAgIHZhciBmID0gdGhpcy5sYWJlbCxcbiAgICAgICAgICAgIGEgPSB0aGlzLnJvdGF0aW9uLFxuICAgICAgICAgICAgbCA9IHtcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIGNlbnRlcjogLjUsXG4gICAgICAgICAgcmlnaHQ6IDFcbiAgICAgICAgfVtxLmxhYmVsQWxpZ24gfHwgZi5hdHRyKFwiYWxpZ25cIildLFxuICAgICAgICAgICAgdiA9IGYuZ2V0QkJveCgpLndpZHRoLFxuICAgICAgICAgICAgeiA9IHEuZ2V0U2xvdFdpZHRoKHRoaXMpLFxuICAgICAgICAgICAgdyA9IHosXG4gICAgICAgICAgICBCID0gMSxcbiAgICAgICAgICAgIEwsXG4gICAgICAgICAgICB0ID0ge307XG4gICAgICAgIGlmIChhIHx8IFwianVzdGlmeVwiICE9PSB5KGgub3ZlcmZsb3csIFwianVzdGlmeVwiKSkgMCA+IGEgJiYgZSAtIGwgKiB2IDwgbiA/IEwgPSBNYXRoLnJvdW5kKGUgLyBNYXRoLmNvcyhhICogRCkgLSBuKSA6IDAgPCBhICYmIGUgKyBsICogdiA+IGsgJiYgKEwgPSBNYXRoLnJvdW5kKChjIC0gZSkgLyBNYXRoLmNvcyhhICogRCkpKTtlbHNlIGlmIChjID0gZSArICgxIC0gbCkgKiB2LCBlIC0gbCAqIHYgPCBuID8gdyA9IGQueCArIHcgKiAoMSAtIGwpIC0gbiA6IGMgPiBrICYmICh3ID0gayAtIGQueCArIHcgKiBsLCBCID0gLTEpLCB3ID0gTWF0aC5taW4oeiwgdyksIHcgPCB6ICYmIFwiY2VudGVyXCIgPT09IHEubGFiZWxBbGlnbiAmJiAoZC54ICs9IEIgKiAoeiAtIHcgLSBsICogKHogLSBNYXRoLm1pbih2LCB3KSkpKSwgdiA+IHcgfHwgcS5hdXRvUm90YXRpb24gJiYgKGYuc3R5bGVzIHx8IHt9KS53aWR0aCkgTCA9IHc7XG4gICAgICAgIEwgJiYgKHRoaXMuc2hvcnRlbkxhYmVsID8gdGhpcy5zaG9ydGVuTGFiZWwoKSA6ICh0LndpZHRoID0gTWF0aC5mbG9vcihMKSwgKGguc3R5bGUgfHwge30pLnRleHRPdmVyZmxvdyB8fCAodC50ZXh0T3ZlcmZsb3cgPSBcImVsbGlwc2lzXCIpLCBmLmNzcyh0KSkpO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUubW92ZUxhYmVsID0gZnVuY3Rpb24gKGQsIHEpIHtcbiAgICAgICAgdmFyIGggPSB0aGlzLFxuICAgICAgICAgICAgZSA9IGgubGFiZWwsXG4gICAgICAgICAgICBjID0gITEsXG4gICAgICAgICAgICBrID0gaC5heGlzLFxuICAgICAgICAgICAgbiA9IGsucmV2ZXJzZWQsXG4gICAgICAgICAgICBmID0gay5jaGFydC5pbnZlcnRlZDtcbiAgICAgICAgZSAmJiBlLnRleHRTdHIgPT09IGQgPyAoaC5tb3ZlZExhYmVsID0gZSwgYyA9ICEwLCBkZWxldGUgaC5sYWJlbCkgOiBKKGsudGlja3MsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYyB8fCBhLmlzTmV3IHx8IGEgPT09IGggfHwgIWEubGFiZWwgfHwgYS5sYWJlbC50ZXh0U3RyICE9PSBkIHx8IChoLm1vdmVkTGFiZWwgPSBhLmxhYmVsLCBjID0gITAsIGEubGFiZWxQb3MgPSBoLm1vdmVkTGFiZWwueHksIGRlbGV0ZSBhLmxhYmVsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFjICYmIChoLmxhYmVsUG9zIHx8IGUpKSB7XG4gICAgICAgICAgdmFyIGEgPSBoLmxhYmVsUG9zIHx8IGUueHk7XG4gICAgICAgICAgZSA9IGYgPyBhLnggOiBuID8gMCA6IGsud2lkdGggKyBrLmxlZnQ7XG4gICAgICAgICAgayA9IGYgPyBuID8gay53aWR0aCArIGsubGVmdCA6IDAgOiBhLnk7XG4gICAgICAgICAgaC5tb3ZlZExhYmVsID0gaC5jcmVhdGVMYWJlbCh7XG4gICAgICAgICAgICB4OiBlLFxuICAgICAgICAgICAgeToga1xuICAgICAgICAgIH0sIGQsIHEpO1xuICAgICAgICAgIGgubW92ZWRMYWJlbCAmJiBoLm1vdmVkTGFiZWwuYXR0cih7XG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChoLCBxLCB0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5heGlzLFxuICAgICAgICAgICAgYyA9IGUuaG9yaXosXG4gICAgICAgICAgICBrID0gdGhpcy5wb3MsXG4gICAgICAgICAgICBuID0geSh0aGlzLnRpY2ttYXJrT2Zmc2V0LCBlLnRpY2ttYXJrT2Zmc2V0KTtcbiAgICAgICAgayA9IHRoaXMuZ2V0UG9zaXRpb24oYywgaywgbiwgcSk7XG4gICAgICAgIG4gPSBrLng7XG4gICAgICAgIHZhciBmID0gay55O1xuICAgICAgICBlID0gYyAmJiBuID09PSBlLnBvcyArIGUubGVuIHx8ICFjICYmIGYgPT09IGUucG9zID8gLTEgOiAxO1xuICAgICAgICB0ID0geSh0LCAxKTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9ICEwO1xuICAgICAgICB0aGlzLnJlbmRlckdyaWRMaW5lKHEsIHQsIGUpO1xuICAgICAgICB0aGlzLnJlbmRlck1hcmsoaywgdCwgZSk7XG4gICAgICAgIHRoaXMucmVuZGVyTGFiZWwoaywgcSwgdCwgaCk7XG4gICAgICAgIHRoaXMuaXNOZXcgPSAhMTtcbiAgICAgICAgZC5maXJlRXZlbnQodGhpcywgXCJhZnRlclJlbmRlclwiKTtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLnJlbmRlckdyaWRMaW5lID0gZnVuY3Rpb24gKGQsIHEsIGgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmF4aXMsXG4gICAgICAgICAgICBjID0gZS5vcHRpb25zLFxuICAgICAgICAgICAgayA9IHRoaXMuZ3JpZExpbmUsXG4gICAgICAgICAgICBuID0ge30sXG4gICAgICAgICAgICBmID0gdGhpcy5wb3MsXG4gICAgICAgICAgICBhID0gdGhpcy50eXBlLFxuICAgICAgICAgICAgbCA9IHkodGhpcy50aWNrbWFya09mZnNldCwgZS50aWNrbWFya09mZnNldCksXG4gICAgICAgICAgICB2ID0gZS5jaGFydC5yZW5kZXJlcixcbiAgICAgICAgICAgIHogPSBhID8gYSArIFwiR3JpZFwiIDogXCJncmlkXCIsXG4gICAgICAgICAgICB3ID0gY1t6ICsgXCJMaW5lV2lkdGhcIl0sXG4gICAgICAgICAgICBCID0gY1t6ICsgXCJMaW5lQ29sb3JcIl07XG4gICAgICAgIGMgPSBjW3ogKyBcIkxpbmVEYXNoU3R5bGVcIl07XG4gICAgICAgIGsgfHwgKGUuY2hhcnQuc3R5bGVkTW9kZSB8fCAobi5zdHJva2UgPSBCLCBuW1wic3Ryb2tlLXdpZHRoXCJdID0gdywgYyAmJiAobi5kYXNoc3R5bGUgPSBjKSksIGEgfHwgKG4uekluZGV4ID0gMSksIGQgJiYgKHEgPSAwKSwgdGhpcy5ncmlkTGluZSA9IGsgPSB2LnBhdGgoKS5hdHRyKG4pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIiArIChhID8gYSArIFwiLVwiIDogXCJcIikgKyBcImdyaWQtbGluZVwiKS5hZGQoZS5ncmlkR3JvdXApKTtcbiAgICAgICAgaWYgKGsgJiYgKGggPSBlLmdldFBsb3RMaW5lUGF0aCh7XG4gICAgICAgICAgdmFsdWU6IGYgKyBsLFxuICAgICAgICAgIGxpbmVXaWR0aDogay5zdHJva2VXaWR0aCgpICogaCxcbiAgICAgICAgICBmb3JjZTogXCJwYXNzXCIsXG4gICAgICAgICAgb2xkOiBkXG4gICAgICAgIH0pKSkga1tkIHx8IHRoaXMuaXNOZXcgPyBcImF0dHJcIiA6IFwiYW5pbWF0ZVwiXSh7XG4gICAgICAgICAgZDogaCxcbiAgICAgICAgICBvcGFjaXR5OiBxXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUucmVuZGVyTWFyayA9IGZ1bmN0aW9uIChkLCBxLCBoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5heGlzLFxuICAgICAgICAgICAgYyA9IGUub3B0aW9ucyxcbiAgICAgICAgICAgIGsgPSBlLmNoYXJ0LnJlbmRlcmVyLFxuICAgICAgICAgICAgbiA9IHRoaXMudHlwZSxcbiAgICAgICAgICAgIGYgPSBuID8gbiArIFwiVGlja1wiIDogXCJ0aWNrXCIsXG4gICAgICAgICAgICBhID0gZS50aWNrU2l6ZShmKSxcbiAgICAgICAgICAgIGwgPSB0aGlzLm1hcmssXG4gICAgICAgICAgICB2ID0gIWwsXG4gICAgICAgICAgICB6ID0gZC54O1xuICAgICAgICBkID0gZC55O1xuICAgICAgICB2YXIgdyA9IHkoY1tmICsgXCJXaWR0aFwiXSwgIW4gJiYgZS5pc1hBeGlzID8gMSA6IDApO1xuICAgICAgICBjID0gY1tmICsgXCJDb2xvclwiXTtcbiAgICAgICAgYSAmJiAoZS5vcHBvc2l0ZSAmJiAoYVswXSA9IC1hWzBdKSwgdiAmJiAodGhpcy5tYXJrID0gbCA9IGsucGF0aCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIiArIChuID8gbiArIFwiLVwiIDogXCJcIikgKyBcInRpY2tcIikuYWRkKGUuYXhpc0dyb3VwKSwgZS5jaGFydC5zdHlsZWRNb2RlIHx8IGwuYXR0cih7XG4gICAgICAgICAgc3Ryb2tlOiBjLFxuICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHdcbiAgICAgICAgfSkpLCBsW3YgPyBcImF0dHJcIiA6IFwiYW5pbWF0ZVwiXSh7XG4gICAgICAgICAgZDogdGhpcy5nZXRNYXJrUGF0aCh6LCBkLCBhWzBdLCBsLnN0cm9rZVdpZHRoKCkgKiBoLCBlLmhvcml6LCBrKSxcbiAgICAgICAgICBvcGFjaXR5OiBxXG4gICAgICAgIH0pKTtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLnJlbmRlckxhYmVsID0gZnVuY3Rpb24gKGQsIHEsIGgsIGUpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmF4aXMsXG4gICAgICAgICAgICBrID0gYy5ob3JpeixcbiAgICAgICAgICAgIG4gPSBjLm9wdGlvbnMsXG4gICAgICAgICAgICBmID0gdGhpcy5sYWJlbCxcbiAgICAgICAgICAgIGEgPSBuLmxhYmVscyxcbiAgICAgICAgICAgIGwgPSBhLnN0ZXA7XG4gICAgICAgIGMgPSB5KHRoaXMudGlja21hcmtPZmZzZXQsIGMudGlja21hcmtPZmZzZXQpO1xuICAgICAgICB2YXIgdiA9ICEwLFxuICAgICAgICAgICAgeiA9IGQueDtcbiAgICAgICAgZCA9IGQueTtcbiAgICAgICAgZiAmJiBBKHopICYmIChmLnh5ID0gZCA9IHRoaXMuZ2V0TGFiZWxQb3NpdGlvbih6LCBkLCBmLCBrLCBhLCBjLCBlLCBsKSwgdGhpcy5pc0ZpcnN0ICYmICF0aGlzLmlzTGFzdCAmJiAheShuLnNob3dGaXJzdExhYmVsLCAxKSB8fCB0aGlzLmlzTGFzdCAmJiAhdGhpcy5pc0ZpcnN0ICYmICF5KG4uc2hvd0xhc3RMYWJlbCwgMSkgPyB2ID0gITEgOiAhayB8fCBhLnN0ZXAgfHwgYS5yb3RhdGlvbiB8fCBxIHx8IDAgPT09IGggfHwgdGhpcy5oYW5kbGVPdmVyZmxvdyhkKSwgbCAmJiBlICUgbCAmJiAodiA9ICExKSwgdiAmJiBBKGQueSkgPyAoZC5vcGFjaXR5ID0gaCwgZlt0aGlzLmlzTmV3TGFiZWwgPyBcImF0dHJcIiA6IFwiYW5pbWF0ZVwiXShkKSwgdGhpcy5pc05ld0xhYmVsID0gITEpIDogKGYuYXR0cihcInlcIiwgLTk5OTkpLCB0aGlzLmlzTmV3TGFiZWwgPSAhMCkpO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUucmVwbGFjZU1vdmVkTGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkID0gdGhpcy5sYWJlbCxcbiAgICAgICAgICAgIHEgPSB0aGlzLmF4aXMsXG4gICAgICAgICAgICBoID0gcS5yZXZlcnNlZCxcbiAgICAgICAgICAgIGUgPSB0aGlzLmF4aXMuY2hhcnQuaW52ZXJ0ZWQ7XG5cbiAgICAgICAgaWYgKGQgJiYgIXRoaXMuaXNOZXcpIHtcbiAgICAgICAgICB2YXIgYyA9IGUgPyBkLnh5LnggOiBoID8gcS5sZWZ0IDogcS53aWR0aCArIHEubGVmdDtcbiAgICAgICAgICBoID0gZSA/IGggPyBxLndpZHRoICsgcS50b3AgOiBxLnRvcCA6IGQueHkueTtcbiAgICAgICAgICBkLmFuaW1hdGUoe1xuICAgICAgICAgICAgeDogYyxcbiAgICAgICAgICAgIHk6IGgsXG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSwgdm9pZCAwLCBkLmRlc3Ryb3kpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmxhYmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgcS5pc0RpcnR5ID0gITA7XG4gICAgICAgIHRoaXMubGFiZWwgPSB0aGlzLm1vdmVkTGFiZWw7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1vdmVkTGFiZWw7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gaDtcbiAgICB9KCk7XG5cbiAgICBkLlRpY2sgPSBnO1xuICAgIHJldHVybiBkLlRpY2s7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvVGltZS5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZykge1xuICAgIHZhciByID0gZy5kZWZpbmVkLFxuICAgICAgICB1ID0gZy5lcnJvcixcbiAgICAgICAgSSA9IGcuZXh0ZW5kLFxuICAgICAgICBNID0gZy5pc09iamVjdCxcbiAgICAgICAgRSA9IGcubWVyZ2UsXG4gICAgICAgIEEgPSBnLm9iamVjdEVhY2gsXG4gICAgICAgIEcgPSBnLnBhZCxcbiAgICAgICAgSiA9IGcucGljayxcbiAgICAgICAgeSA9IGcuc3BsYXQsXG4gICAgICAgIHQgPSBnLnRpbWVVbml0cyxcbiAgICAgICAgRCA9IGQud2luO1xuXG4gICAgZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIGgoZCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy52YXJpYWJsZVRpbWV6b25lID0gdGhpcy51c2VVVEMgPSAhMTtcbiAgICAgICAgdGhpcy5EYXRlID0gRC5EYXRlO1xuICAgICAgICB0aGlzLmdldFRpbWV6b25lT2Zmc2V0ID0gdGhpcy50aW1lem9uZU9mZnNldEZ1bmN0aW9uKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKGQpO1xuICAgICAgfVxuXG4gICAgICBoLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoZCwgcSkge1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZVRpbWV6b25lIHx8IHRoaXMudGltZXpvbmVPZmZzZXQpIHtcbiAgICAgICAgICB2YXIgaCA9IHEuZ2V0VGltZSgpLFxuICAgICAgICAgICAgICBlID0gaCAtIHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQocSk7XG4gICAgICAgICAgcS5zZXRUaW1lKGUpO1xuICAgICAgICAgIGQgPSBxW1wiZ2V0VVRDXCIgKyBkXSgpO1xuICAgICAgICAgIHEuc2V0VGltZShoKTtcbiAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnVzZVVUQyA/IHFbXCJnZXRVVENcIiArIGRdKCkgOiBxW1wiZ2V0XCIgKyBkXSgpO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGQsIHEsIGgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGVUaW1lem9uZSB8fCB0aGlzLnRpbWV6b25lT2Zmc2V0KSB7XG4gICAgICAgICAgaWYgKFwiTWlsbGlzZWNvbmRzXCIgPT09IGQgfHwgXCJTZWNvbmRzXCIgPT09IGQgfHwgXCJNaW51dGVzXCIgPT09IGQpIHJldHVybiBxW1wic2V0VVRDXCIgKyBkXShoKTtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQocSk7XG4gICAgICAgICAgZSA9IHEuZ2V0VGltZSgpIC0gZTtcbiAgICAgICAgICBxLnNldFRpbWUoZSk7XG4gICAgICAgICAgcVtcInNldFVUQ1wiICsgZF0oaCk7XG4gICAgICAgICAgZCA9IHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQocSk7XG4gICAgICAgICAgZSA9IHEuZ2V0VGltZSgpICsgZDtcbiAgICAgICAgICByZXR1cm4gcS5zZXRUaW1lKGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXNlVVRDID8gcVtcInNldFVUQ1wiICsgZF0oaCkgOiBxW1wic2V0XCIgKyBkXShoKTtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBxID0gSihkICYmIGQudXNlVVRDLCAhMCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGQgPSBFKCEwLCB0aGlzLm9wdGlvbnMgfHwge30sIGQpO1xuICAgICAgICB0aGlzLkRhdGUgPSBkLkRhdGUgfHwgRC5EYXRlIHx8IERhdGU7XG4gICAgICAgIHRoaXMudGltZXpvbmVPZmZzZXQgPSAodGhpcy51c2VVVEMgPSBxKSAmJiBkLnRpbWV6b25lT2Zmc2V0O1xuICAgICAgICB0aGlzLmdldFRpbWV6b25lT2Zmc2V0ID0gdGhpcy50aW1lem9uZU9mZnNldEZ1bmN0aW9uKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVUaW1lem9uZSA9ICEocSAmJiAhZC5nZXRUaW1lem9uZU9mZnNldCAmJiAhZC50aW1lem9uZSk7XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5tYWtlVGltZSA9IGZ1bmN0aW9uIChoLCBxLCB0LCBlLCBjLCBrKSB7XG4gICAgICAgIGlmICh0aGlzLnVzZVVUQykge1xuICAgICAgICAgIHZhciBuID0gdGhpcy5EYXRlLlVUQy5hcHBseSgwLCBhcmd1bWVudHMpO1xuICAgICAgICAgIHZhciBmID0gdGhpcy5nZXRUaW1lem9uZU9mZnNldChuKTtcbiAgICAgICAgICBuICs9IGY7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLmdldFRpbWV6b25lT2Zmc2V0KG4pO1xuICAgICAgICAgIGYgIT09IGEgPyBuICs9IGEgLSBmIDogZiAtIDM2RTUgIT09IHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQobiAtIDM2RTUpIHx8IGQuaXNTYWZhcmkgfHwgKG4gLT0gMzZFNSk7XG4gICAgICAgIH0gZWxzZSBuID0gbmV3IHRoaXMuRGF0ZShoLCBxLCBKKHQsIDEpLCBKKGUsIDApLCBKKGMsIDApLCBKKGssIDApKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS50aW1lem9uZU9mZnNldEZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgICBxID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgaCA9IEQubW9tZW50O1xuICAgICAgICBpZiAoIXRoaXMudXNlVVRDKSByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gNkU0ICogbmV3IERhdGUoZS50b1N0cmluZygpKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChxLnRpbWV6b25lKSB7XG4gICAgICAgICAgaWYgKGgpIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIDZFNCAqIC1oLnR6KGUsIHEudGltZXpvbmUpLnV0Y09mZnNldCgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdSgyNSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy51c2VVVEMgJiYgcS5nZXRUaW1lem9uZU9mZnNldCA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIDZFNCAqIHEuZ2V0VGltZXpvbmVPZmZzZXQoZS52YWx1ZU9mKCkpO1xuICAgICAgICB9IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiA2RTQgKiAoZC50aW1lem9uZU9mZnNldCB8fCAwKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLmRhdGVGb3JtYXQgPSBmdW5jdGlvbiAoaCwgcSwgdCkge1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgaWYgKCFyKHEpIHx8IGlzTmFOKHEpKSByZXR1cm4gKG51bGwgPT09IChlID0gZC5kZWZhdWx0T3B0aW9ucy5sYW5nKSB8fCB2b2lkIDAgPT09IGUgPyB2b2lkIDAgOiBlLmludmFsaWREYXRlKSB8fCBcIlwiO1xuICAgICAgICBoID0gSihoLCBcIiVZLSVtLSVkICVIOiVNOiVTXCIpO1xuICAgICAgICB2YXIgYyA9IHRoaXM7XG4gICAgICAgIGUgPSBuZXcgdGhpcy5EYXRlKHEpO1xuICAgICAgICB2YXIgayA9IHRoaXMuZ2V0KFwiSG91cnNcIiwgZSksXG4gICAgICAgICAgICBuID0gdGhpcy5nZXQoXCJEYXlcIiwgZSksXG4gICAgICAgICAgICBmID0gdGhpcy5nZXQoXCJEYXRlXCIsIGUpLFxuICAgICAgICAgICAgYSA9IHRoaXMuZ2V0KFwiTW9udGhcIiwgZSksXG4gICAgICAgICAgICBsID0gdGhpcy5nZXQoXCJGdWxsWWVhclwiLCBlKSxcbiAgICAgICAgICAgIHYgPSBkLmRlZmF1bHRPcHRpb25zLmxhbmcsXG4gICAgICAgICAgICB6ID0gbnVsbCA9PT0gdiB8fCB2b2lkIDAgPT09IHYgPyB2b2lkIDAgOiB2LndlZWtkYXlzLFxuICAgICAgICAgICAgdyA9IG51bGwgPT09IHYgfHwgdm9pZCAwID09PSB2ID8gdm9pZCAwIDogdi5zaG9ydFdlZWtkYXlzO1xuICAgICAgICBlID0gSSh7XG4gICAgICAgICAgYTogdyA/IHdbbl0gOiB6W25dLnN1YnN0cigwLCAzKSxcbiAgICAgICAgICBBOiB6W25dLFxuICAgICAgICAgIGQ6IEcoZiksXG4gICAgICAgICAgZTogRyhmLCAyLCBcIiBcIiksXG4gICAgICAgICAgdzogbixcbiAgICAgICAgICBiOiB2LnNob3J0TW9udGhzW2FdLFxuICAgICAgICAgIEI6IHYubW9udGhzW2FdLFxuICAgICAgICAgIG06IEcoYSArIDEpLFxuICAgICAgICAgIG86IGEgKyAxLFxuICAgICAgICAgIHk6IGwudG9TdHJpbmcoKS5zdWJzdHIoMiwgMiksXG4gICAgICAgICAgWTogbCxcbiAgICAgICAgICBIOiBHKGspLFxuICAgICAgICAgIGs6IGssXG4gICAgICAgICAgSTogRyhrICUgMTIgfHwgMTIpLFxuICAgICAgICAgIGw6IGsgJSAxMiB8fCAxMixcbiAgICAgICAgICBNOiBHKHRoaXMuZ2V0KFwiTWludXRlc1wiLCBlKSksXG4gICAgICAgICAgcDogMTIgPiBrID8gXCJBTVwiIDogXCJQTVwiLFxuICAgICAgICAgIFA6IDEyID4gayA/IFwiYW1cIiA6IFwicG1cIixcbiAgICAgICAgICBTOiBHKGUuZ2V0U2Vjb25kcygpKSxcbiAgICAgICAgICBMOiBHKE1hdGguZmxvb3IocSAlIDFFMyksIDMpXG4gICAgICAgIH0sIGQuZGF0ZUZvcm1hdHMpO1xuICAgICAgICBBKGUsIGZ1bmN0aW9uIChhLCBmKSB7XG4gICAgICAgICAgZm9yICg7IC0xICE9PSBoLmluZGV4T2YoXCIlXCIgKyBmKTspIGggPSBoLnJlcGxhY2UoXCIlXCIgKyBmLCBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhID8gYS5jYWxsKGMsIHEpIDogYSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdCA/IGguc3Vic3RyKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBoLnN1YnN0cigxKSA6IGg7XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5yZXNvbHZlRFRMRm9ybWF0ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIE0oZCwgITApID8gZCA6IChkID0geShkKSwge1xuICAgICAgICAgIG1haW46IGRbMF0sXG4gICAgICAgICAgZnJvbTogZFsxXSxcbiAgICAgICAgICB0bzogZFsyXVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLmdldFRpbWVUaWNrcyA9IGZ1bmN0aW9uIChkLCBoLCBnLCBlKSB7XG4gICAgICAgIHZhciBjID0gdGhpcyxcbiAgICAgICAgICAgIGsgPSBbXSxcbiAgICAgICAgICAgIG4gPSB7fTtcbiAgICAgICAgdmFyIGYgPSBuZXcgYy5EYXRlKGgpO1xuICAgICAgICB2YXIgYSA9IGQudW5pdFJhbmdlLFxuICAgICAgICAgICAgbCA9IGQuY291bnQgfHwgMSxcbiAgICAgICAgICAgIHY7XG4gICAgICAgIGUgPSBKKGUsIDEpO1xuXG4gICAgICAgIGlmIChyKGgpKSB7XG4gICAgICAgICAgYy5zZXQoXCJNaWxsaXNlY29uZHNcIiwgZiwgYSA+PSB0LnNlY29uZCA/IDAgOiBsICogTWF0aC5mbG9vcihjLmdldChcIk1pbGxpc2Vjb25kc1wiLCBmKSAvIGwpKTtcbiAgICAgICAgICBhID49IHQuc2Vjb25kICYmIGMuc2V0KFwiU2Vjb25kc1wiLCBmLCBhID49IHQubWludXRlID8gMCA6IGwgKiBNYXRoLmZsb29yKGMuZ2V0KFwiU2Vjb25kc1wiLCBmKSAvIGwpKTtcbiAgICAgICAgICBhID49IHQubWludXRlICYmIGMuc2V0KFwiTWludXRlc1wiLCBmLCBhID49IHQuaG91ciA/IDAgOiBsICogTWF0aC5mbG9vcihjLmdldChcIk1pbnV0ZXNcIiwgZikgLyBsKSk7XG4gICAgICAgICAgYSA+PSB0LmhvdXIgJiYgYy5zZXQoXCJIb3Vyc1wiLCBmLCBhID49IHQuZGF5ID8gMCA6IGwgKiBNYXRoLmZsb29yKGMuZ2V0KFwiSG91cnNcIiwgZikgLyBsKSk7XG4gICAgICAgICAgYSA+PSB0LmRheSAmJiBjLnNldChcIkRhdGVcIiwgZiwgYSA+PSB0Lm1vbnRoID8gMSA6IE1hdGgubWF4KDEsIGwgKiBNYXRoLmZsb29yKGMuZ2V0KFwiRGF0ZVwiLCBmKSAvIGwpKSk7XG5cbiAgICAgICAgICBpZiAoYSA+PSB0Lm1vbnRoKSB7XG4gICAgICAgICAgICBjLnNldChcIk1vbnRoXCIsIGYsIGEgPj0gdC55ZWFyID8gMCA6IGwgKiBNYXRoLmZsb29yKGMuZ2V0KFwiTW9udGhcIiwgZikgLyBsKSk7XG4gICAgICAgICAgICB2YXIgeiA9IGMuZ2V0KFwiRnVsbFllYXJcIiwgZik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYSA+PSB0LnllYXIgJiYgYy5zZXQoXCJGdWxsWWVhclwiLCBmLCB6IC0geiAlIGwpO1xuICAgICAgICAgIGEgPT09IHQud2VlayAmJiAoeiA9IGMuZ2V0KFwiRGF5XCIsIGYpLCBjLnNldChcIkRhdGVcIiwgZiwgYy5nZXQoXCJEYXRlXCIsIGYpIC0geiArIGUgKyAoeiA8IGUgPyAtNyA6IDApKSk7XG4gICAgICAgICAgeiA9IGMuZ2V0KFwiRnVsbFllYXJcIiwgZik7XG4gICAgICAgICAgZSA9IGMuZ2V0KFwiTW9udGhcIiwgZik7XG4gICAgICAgICAgdmFyIHcgPSBjLmdldChcIkRhdGVcIiwgZiksXG4gICAgICAgICAgICAgIHEgPSBjLmdldChcIkhvdXJzXCIsIGYpO1xuICAgICAgICAgIGggPSBmLmdldFRpbWUoKTtcbiAgICAgICAgICBjLnZhcmlhYmxlVGltZXpvbmUgJiYgKHYgPSBnIC0gaCA+IDQgKiB0Lm1vbnRoIHx8IGMuZ2V0VGltZXpvbmVPZmZzZXQoaCkgIT09IGMuZ2V0VGltZXpvbmVPZmZzZXQoZykpO1xuICAgICAgICAgIGggPSBmLmdldFRpbWUoKTtcblxuICAgICAgICAgIGZvciAoZiA9IDE7IGggPCBnOykgay5wdXNoKGgpLCBoID0gYSA9PT0gdC55ZWFyID8gYy5tYWtlVGltZSh6ICsgZiAqIGwsIDApIDogYSA9PT0gdC5tb250aCA/IGMubWFrZVRpbWUoeiwgZSArIGYgKiBsKSA6ICF2IHx8IGEgIT09IHQuZGF5ICYmIGEgIT09IHQud2VlayA/IHYgJiYgYSA9PT0gdC5ob3VyICYmIDEgPCBsID8gYy5tYWtlVGltZSh6LCBlLCB3LCBxICsgZiAqIGwpIDogaCArIGEgKiBsIDogYy5tYWtlVGltZSh6LCBlLCB3ICsgZiAqIGwgKiAoYSA9PT0gdC5kYXkgPyAxIDogNykpLCBmKys7XG5cbiAgICAgICAgICBrLnB1c2goaCk7XG4gICAgICAgICAgYSA8PSB0LmhvdXIgJiYgMUU0ID4gay5sZW5ndGggJiYgay5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAwID09PSBhICUgMThFNSAmJiBcIjAwMDAwMDAwMFwiID09PSBjLmRhdGVGb3JtYXQoXCIlSCVNJVMlTFwiLCBhKSAmJiAoblthXSA9IFwiZGF5XCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgay5pbmZvID0gSShkLCB7XG4gICAgICAgICAgaGlnaGVyUmFua3M6IG4sXG4gICAgICAgICAgdG90YWxSYW5nZTogYSAqIGxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBrO1xuICAgICAgfTtcblxuICAgICAgaC5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgRGF0ZTogdm9pZCAwLFxuICAgICAgICBnZXRUaW1lem9uZU9mZnNldDogdm9pZCAwLFxuICAgICAgICB0aW1lem9uZTogdm9pZCAwLFxuICAgICAgICB0aW1lem9uZU9mZnNldDogMCxcbiAgICAgICAgdXNlVVRDOiAhMFxuICAgICAgfTtcbiAgICAgIHJldHVybiBoO1xuICAgIH0oKTtcblxuICAgIGQuVGltZSA9IGc7XG4gICAgcmV0dXJuIGQuVGltZTtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9PcHRpb25zLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1RpbWUuanNcIl0sIHJbXCJwYXJ0cy9Db2xvci5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnLCByLCB1KSB7XG4gICAgciA9IHIucGFyc2U7XG4gICAgdmFyIEkgPSB1Lm1lcmdlO1xuICAgIGQuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBjb2xvcnM6IFwiIzdjYjVlYyAjNDM0MzQ4ICM5MGVkN2QgI2Y3YTM1YyAjODA4NWU5ICNmMTVjODAgI2U0ZDM1NCAjMmI5MDhmICNmNDViNWIgIzkxZThlMVwiLnNwbGl0KFwiIFwiKSxcbiAgICAgIHN5bWJvbHM6IFtcImNpcmNsZVwiLCBcImRpYW1vbmRcIiwgXCJzcXVhcmVcIiwgXCJ0cmlhbmdsZVwiLCBcInRyaWFuZ2xlLWRvd25cIl0sXG4gICAgICBsYW5nOiB7XG4gICAgICAgIGxvYWRpbmc6IFwiTG9hZGluZy4uLlwiLFxuICAgICAgICBtb250aHM6IFwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgc2hvcnRNb250aHM6IFwiSmFuIEZlYiBNYXIgQXByIE1heSBKdW4gSnVsIEF1ZyBTZXAgT2N0IE5vdiBEZWNcIi5zcGxpdChcIiBcIiksXG4gICAgICAgIHdlZWtkYXlzOiBcIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLFxuICAgICAgICBkZWNpbWFsUG9pbnQ6IFwiLlwiLFxuICAgICAgICBudW1lcmljU3ltYm9sczogXCJrTUdUUEVcIi5zcGxpdChcIlwiKSxcbiAgICAgICAgcmVzZXRab29tOiBcIlJlc2V0IHpvb21cIixcbiAgICAgICAgcmVzZXRab29tVGl0bGU6IFwiUmVzZXQgem9vbSBsZXZlbCAxOjFcIixcbiAgICAgICAgdGhvdXNhbmRzU2VwOiBcIiBcIlxuICAgICAgfSxcbiAgICAgIGdsb2JhbDoge30sXG4gICAgICB0aW1lOiBnLmRlZmF1bHRPcHRpb25zLFxuICAgICAgY2hhcnQ6IHtcbiAgICAgICAgc3R5bGVkTW9kZTogITEsXG4gICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgY29sb3JDb3VudDogMTAsXG4gICAgICAgIGRlZmF1bHRTZXJpZXNUeXBlOiBcImxpbmVcIixcbiAgICAgICAgaWdub3JlSGlkZGVuU2VyaWVzOiAhMCxcbiAgICAgICAgc3BhY2luZzogWzEwLCAxMCwgMTUsIDEwXSxcbiAgICAgICAgcmVzZXRab29tQnV0dG9uOiB7XG4gICAgICAgICAgdGhlbWU6IHtcbiAgICAgICAgICAgIHpJbmRleDogNlxuICAgICAgICAgIH0sXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIGFsaWduOiBcInJpZ2h0XCIsXG4gICAgICAgICAgICB4OiAtMTAsXG4gICAgICAgICAgICB5OiAxMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd2lkdGg6IG51bGwsXG4gICAgICAgIGhlaWdodDogbnVsbCxcbiAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzMzNWNhZFwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmZmZmZlwiLFxuICAgICAgICBwbG90Qm9yZGVyQ29sb3I6IFwiI2NjY2NjY1wiXG4gICAgICB9LFxuICAgICAgdGl0bGU6IHtcbiAgICAgICAgdGV4dDogXCJDaGFydCB0aXRsZVwiLFxuICAgICAgICBhbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgbWFyZ2luOiAxNSxcbiAgICAgICAgd2lkdGhBZGp1c3Q6IC00NFxuICAgICAgfSxcbiAgICAgIHN1YnRpdGxlOiB7XG4gICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgIGFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICB3aWR0aEFkanVzdDogLTQ0XG4gICAgICB9LFxuICAgICAgY2FwdGlvbjoge1xuICAgICAgICBtYXJnaW46IDE1LFxuICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICBhbGlnbjogXCJsZWZ0XCIsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwiYm90dG9tXCJcbiAgICAgIH0sXG4gICAgICBwbG90T3B0aW9uczoge30sXG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgIGNvbG9yOiBcIiMzMzMzMzNcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGVuYWJsZWQ6ICEwLFxuICAgICAgICBhbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgYWxpZ25Db2x1bW5zOiAhMCxcbiAgICAgICAgbGF5b3V0OiBcImhvcml6b250YWxcIixcbiAgICAgICAgbGFiZWxGb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBib3JkZXJDb2xvcjogXCIjOTk5OTk5XCIsXG4gICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgbmF2aWdhdGlvbjoge1xuICAgICAgICAgIGFjdGl2ZUNvbG9yOiBcIiMwMDMzOTlcIixcbiAgICAgICAgICBpbmFjdGl2ZUNvbG9yOiBcIiNjY2NjY2NcIlxuICAgICAgICB9LFxuICAgICAgICBpdGVtU3R5bGU6IHtcbiAgICAgICAgICBjb2xvcjogXCIjMzMzMzMzXCIsXG4gICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIixcbiAgICAgICAgICBmb250U2l6ZTogXCIxMnB4XCIsXG4gICAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIsXG4gICAgICAgICAgdGV4dE92ZXJmbG93OiBcImVsbGlwc2lzXCJcbiAgICAgICAgfSxcbiAgICAgICAgaXRlbUhvdmVyU3R5bGU6IHtcbiAgICAgICAgICBjb2xvcjogXCIjMDAwMDAwXCJcbiAgICAgICAgfSxcbiAgICAgICAgaXRlbUhpZGRlblN0eWxlOiB7XG4gICAgICAgICAgY29sb3I6IFwiI2NjY2NjY1wiXG4gICAgICAgIH0sXG4gICAgICAgIHNoYWRvdzogITEsXG4gICAgICAgIGl0ZW1DaGVja2JveFN0eWxlOiB7XG4gICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICB3aWR0aDogXCIxM3B4XCIsXG4gICAgICAgICAgaGVpZ2h0OiBcIjEzcHhcIlxuICAgICAgICB9LFxuICAgICAgICBzcXVhcmVTeW1ib2w6ICEwLFxuICAgICAgICBzeW1ib2xQYWRkaW5nOiA1LFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcImJvdHRvbVwiLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxvYWRpbmc6IHtcbiAgICAgICAgbGFiZWxTdHlsZToge1xuICAgICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgdG9wOiBcIjQ1JVwiXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmZmZmZlwiLFxuICAgICAgICAgIG9wYWNpdHk6IC41LFxuICAgICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9vbHRpcDoge1xuICAgICAgICBlbmFibGVkOiAhMCxcbiAgICAgICAgYW5pbWF0aW9uOiBkLnN2ZyxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAzLFxuICAgICAgICBkYXRlVGltZUxhYmVsRm9ybWF0czoge1xuICAgICAgICAgIG1pbGxpc2Vjb25kOiBcIiVBLCAlYiAlZSwgJUg6JU06JVMuJUxcIixcbiAgICAgICAgICBzZWNvbmQ6IFwiJUEsICViICVlLCAlSDolTTolU1wiLFxuICAgICAgICAgIG1pbnV0ZTogXCIlQSwgJWIgJWUsICVIOiVNXCIsXG4gICAgICAgICAgaG91cjogXCIlQSwgJWIgJWUsICVIOiVNXCIsXG4gICAgICAgICAgZGF5OiBcIiVBLCAlYiAlZSwgJVlcIixcbiAgICAgICAgICB3ZWVrOiBcIldlZWsgZnJvbSAlQSwgJWIgJWUsICVZXCIsXG4gICAgICAgICAgbW9udGg6IFwiJUIgJVlcIixcbiAgICAgICAgICB5ZWFyOiBcIiVZXCJcbiAgICAgICAgfSxcbiAgICAgICAgZm9vdGVyRm9ybWF0OiBcIlwiLFxuICAgICAgICBwYWRkaW5nOiA4LFxuICAgICAgICBzbmFwOiBkLmlzVG91Y2hEZXZpY2UgPyAyNSA6IDEwLFxuICAgICAgICBoZWFkZXJGb3JtYXQ6ICc8c3BhbiBzdHlsZT1cImZvbnQtc2l6ZTogMTBweFwiPntwb2ludC5rZXl9PC9zcGFuPjxici8+JyxcbiAgICAgICAgcG9pbnRGb3JtYXQ6ICc8c3BhbiBzdHlsZT1cImNvbG9yOntwb2ludC5jb2xvcn1cIj5cXHUyNWNmPC9zcGFuPiB7c2VyaWVzLm5hbWV9OiA8Yj57cG9pbnQueX08L2I+PGJyLz4nLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHIoXCIjZjdmN2Y3XCIpLnNldE9wYWNpdHkoLjg1KS5nZXQoKSxcbiAgICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICAgIHNoYWRvdzogITAsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgY29sb3I6IFwiIzMzMzMzM1wiLFxuICAgICAgICAgIGN1cnNvcjogXCJkZWZhdWx0XCIsXG4gICAgICAgICAgZm9udFNpemU6IFwiMTJweFwiLFxuICAgICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNyZWRpdHM6IHtcbiAgICAgICAgZW5hYmxlZDogITAsXG4gICAgICAgIGhyZWY6IFwiaHR0cHM6Ly93d3cuaGlnaGNoYXJ0cy5jb20/Y3JlZGl0c1wiLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIGFsaWduOiBcInJpZ2h0XCIsXG4gICAgICAgICAgeDogLTEwLFxuICAgICAgICAgIHZlcnRpY2FsQWxpZ246IFwiYm90dG9tXCIsXG4gICAgICAgICAgeTogLTVcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgICAgICAgIGNvbG9yOiBcIiM5OTk5OTlcIixcbiAgICAgICAgICBmb250U2l6ZTogXCI5cHhcIlxuICAgICAgICB9LFxuICAgICAgICB0ZXh0OiBcIkhpZ2hjaGFydHMuY29tXCJcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZC5zZXRPcHRpb25zID0gZnVuY3Rpb24gKGcpIHtcbiAgICAgIGQuZGVmYXVsdE9wdGlvbnMgPSBJKCEwLCBkLmRlZmF1bHRPcHRpb25zLCBnKTtcbiAgICAgIChnLnRpbWUgfHwgZy5nbG9iYWwpICYmIGQudGltZS51cGRhdGUoSShkLmRlZmF1bHRPcHRpb25zLmdsb2JhbCwgZC5kZWZhdWx0T3B0aW9ucy50aW1lLCBnLmdsb2JhbCwgZy50aW1lKSk7XG4gICAgICByZXR1cm4gZC5kZWZhdWx0T3B0aW9ucztcbiAgICB9O1xuXG4gICAgZC5nZXRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGQuZGVmYXVsdE9wdGlvbnM7XG4gICAgfTtcblxuICAgIGQuZGVmYXVsdFBsb3RPcHRpb25zID0gZC5kZWZhdWx0T3B0aW9ucy5wbG90T3B0aW9ucztcbiAgICBkLnRpbWUgPSBuZXcgZyhJKGQuZGVmYXVsdE9wdGlvbnMuZ2xvYmFsLCBkLmRlZmF1bHRPcHRpb25zLnRpbWUpKTtcblxuICAgIGQuZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIChnLCB1LCBBKSB7XG4gICAgICByZXR1cm4gZC50aW1lLmRhdGVGb3JtYXQoZywgdSwgQSk7XG4gICAgfTtcblxuICAgIFwiXCI7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvQXhpcy5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9Db2xvci5qc1wiXSwgcltcInBhcnRzL1RpY2suanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZywgciwgdSkge1xuICAgIHZhciBJID0gZy5wYXJzZSxcbiAgICAgICAgTSA9IHUuYWRkRXZlbnQsXG4gICAgICAgIEUgPSB1LmFuaW1PYmplY3QsXG4gICAgICAgIEEgPSB1LmFycmF5TWF4LFxuICAgICAgICBHID0gdS5hcnJheU1pbixcbiAgICAgICAgSiA9IHUuY2xhbXAsXG4gICAgICAgIHkgPSB1LmNvcnJlY3RGbG9hdCxcbiAgICAgICAgdCA9IHUuZGVmaW5lZCxcbiAgICAgICAgRCA9IHUuZGVzdHJveU9iamVjdFByb3BlcnRpZXMsXG4gICAgICAgIGggPSB1LmVycm9yLFxuICAgICAgICBOID0gdS5leHRlbmQsXG4gICAgICAgIHEgPSB1LmZpcmVFdmVudCxcbiAgICAgICAgUCA9IHUuZm9ybWF0LFxuICAgICAgICBlID0gdS5nZXRNYWduaXR1ZGUsXG4gICAgICAgIGMgPSB1LmlzQXJyYXksXG4gICAgICAgIGsgPSB1LmlzRnVuY3Rpb24sXG4gICAgICAgIG4gPSB1LmlzTnVtYmVyLFxuICAgICAgICBmID0gdS5pc1N0cmluZyxcbiAgICAgICAgYSA9IHUubWVyZ2UsXG4gICAgICAgIGwgPSB1Lm5vcm1hbGl6ZVRpY2tJbnRlcnZhbCxcbiAgICAgICAgdiA9IHUub2JqZWN0RWFjaCxcbiAgICAgICAgeiA9IHUucGljayxcbiAgICAgICAgdyA9IHUucmVsYXRpdmVMZW5ndGgsXG4gICAgICAgIEIgPSB1LnJlbW92ZUV2ZW50LFxuICAgICAgICBMID0gdS5zcGxhdCxcbiAgICAgICAgUSA9IHUuc3luY1RpbWVvdXQsXG4gICAgICAgIEggPSBkLmRlZmF1bHRPcHRpb25zLFxuICAgICAgICBLID0gZC5kZWcycmFkO1xuXG4gICAgZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBOKGcucHJvdG90eXBlLCB7XG4gICAgICBkZWZhdWx0T3B0aW9uczoge1xuICAgICAgICBkYXRlVGltZUxhYmVsRm9ybWF0czoge1xuICAgICAgICAgIG1pbGxpc2Vjb25kOiB7XG4gICAgICAgICAgICBtYWluOiBcIiVIOiVNOiVTLiVMXCIsXG4gICAgICAgICAgICByYW5nZTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNlY29uZDoge1xuICAgICAgICAgICAgbWFpbjogXCIlSDolTTolU1wiLFxuICAgICAgICAgICAgcmFuZ2U6ICExXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtaW51dGU6IHtcbiAgICAgICAgICAgIG1haW46IFwiJUg6JU1cIixcbiAgICAgICAgICAgIHJhbmdlOiAhMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaG91cjoge1xuICAgICAgICAgICAgbWFpbjogXCIlSDolTVwiLFxuICAgICAgICAgICAgcmFuZ2U6ICExXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkYXk6IHtcbiAgICAgICAgICAgIG1haW46IFwiJWUuICViXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdlZWs6IHtcbiAgICAgICAgICAgIG1haW46IFwiJWUuICViXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1vbnRoOiB7XG4gICAgICAgICAgICBtYWluOiBcIiViICcleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICB5ZWFyOiB7XG4gICAgICAgICAgICBtYWluOiBcIiVZXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVuZE9uVGljazogITEsXG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgIGVuYWJsZWQ6ICEwLFxuICAgICAgICAgIGluZGVudGF0aW9uOiAxMCxcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBjb2xvcjogXCIjNjY2NjY2XCIsXG4gICAgICAgICAgICBjdXJzb3I6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgZm9udFNpemU6IFwiMTFweFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtYXhQYWRkaW5nOiAuMDEsXG4gICAgICAgIG1pbm9yVGlja0xlbmd0aDogMixcbiAgICAgICAgbWlub3JUaWNrUG9zaXRpb246IFwib3V0c2lkZVwiLFxuICAgICAgICBtaW5QYWRkaW5nOiAuMDEsXG4gICAgICAgIHNob3dFbXB0eTogITAsXG4gICAgICAgIHN0YXJ0T2ZXZWVrOiAxLFxuICAgICAgICBzdGFydE9uVGljazogITEsXG4gICAgICAgIHRpY2tMZW5ndGg6IDEwLFxuICAgICAgICB0aWNrUGl4ZWxJbnRlcnZhbDogMTAwLFxuICAgICAgICB0aWNrbWFya1BsYWNlbWVudDogXCJiZXR3ZWVuXCIsXG4gICAgICAgIHRpY2tQb3NpdGlvbjogXCJvdXRzaWRlXCIsXG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgYWxpZ246IFwibWlkZGxlXCIsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGNvbG9yOiBcIiM2NjY2NjZcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogXCJsaW5lYXJcIixcbiAgICAgICAgbWlub3JHcmlkTGluZUNvbG9yOiBcIiNmMmYyZjJcIixcbiAgICAgICAgbWlub3JHcmlkTGluZVdpZHRoOiAxLFxuICAgICAgICBtaW5vclRpY2tDb2xvcjogXCIjOTk5OTk5XCIsXG4gICAgICAgIGxpbmVDb2xvcjogXCIjY2NkNmViXCIsXG4gICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgZ3JpZExpbmVDb2xvcjogXCIjZTZlNmU2XCIsXG4gICAgICAgIHRpY2tDb2xvcjogXCIjY2NkNmViXCJcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0WUF4aXNPcHRpb25zOiB7XG4gICAgICAgIGVuZE9uVGljazogITAsXG4gICAgICAgIG1heFBhZGRpbmc6IC4wNSxcbiAgICAgICAgbWluUGFkZGluZzogLjA1LFxuICAgICAgICB0aWNrUGl4ZWxJbnRlcnZhbDogNzIsXG4gICAgICAgIHNob3dMYXN0TGFiZWw6ICEwLFxuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICB4OiAtOFxuICAgICAgICB9LFxuICAgICAgICBzdGFydE9uVGljazogITAsXG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgcm90YXRpb246IDI3MCxcbiAgICAgICAgICB0ZXh0OiBcIlZhbHVlc1wiXG4gICAgICAgIH0sXG4gICAgICAgIHN0YWNrTGFiZWxzOiB7XG4gICAgICAgICAgYWxsb3dPdmVybGFwOiAhMSxcbiAgICAgICAgICBlbmFibGVkOiAhMSxcbiAgICAgICAgICBjcm9wOiAhMCxcbiAgICAgICAgICBvdmVyZmxvdzogXCJqdXN0aWZ5XCIsXG4gICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuYXhpcy5jaGFydC5udW1iZXJGb3JtYXR0ZXI7XG4gICAgICAgICAgICByZXR1cm4gYSh0aGlzLnRvdGFsLCAtMSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgY29sb3I6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgICAgZm9udFNpemU6IFwiMTFweFwiLFxuICAgICAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIsXG4gICAgICAgICAgICB0ZXh0T3V0bGluZTogXCIxcHggY29udHJhc3RcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ3JpZExpbmVXaWR0aDogMSxcbiAgICAgICAgbGluZVdpZHRoOiAwXG4gICAgICB9LFxuICAgICAgZGVmYXVsdExlZnRBeGlzT3B0aW9uczoge1xuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICB4OiAtMTVcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICByb3RhdGlvbjogMjcwXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZWZhdWx0UmlnaHRBeGlzT3B0aW9uczoge1xuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICB4OiAxNVxuICAgICAgICB9LFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgIHJvdGF0aW9uOiA5MFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVmYXVsdEJvdHRvbUF4aXNPcHRpb25zOiB7XG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgIGF1dG9Sb3RhdGlvbjogWy00NV0sXG4gICAgICAgICAgeDogMFxuICAgICAgICB9LFxuICAgICAgICBtYXJnaW46IDE1LFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgIHJvdGF0aW9uOiAwXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZWZhdWx0VG9wQXhpc09wdGlvbnM6IHtcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgYXV0b1JvdGF0aW9uOiBbLTQ1XSxcbiAgICAgICAgICB4OiAwXG4gICAgICAgIH0sXG4gICAgICAgIG1hcmdpbjogMTUsXG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgcm90YXRpb246IDBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGluaXQ6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBmID0gYi5pc1gsXG4gICAgICAgICAgICBjID0gdGhpcztcbiAgICAgICAgYy5jaGFydCA9IGE7XG4gICAgICAgIGMuaG9yaXogPSBhLmludmVydGVkICYmICFjLmlzWkF4aXMgPyAhZiA6IGY7XG4gICAgICAgIGMuaXNYQXhpcyA9IGY7XG4gICAgICAgIGMuY29sbCA9IGMuY29sbCB8fCAoZiA/IFwieEF4aXNcIiA6IFwieUF4aXNcIik7XG4gICAgICAgIHEodGhpcywgXCJpbml0XCIsIHtcbiAgICAgICAgICB1c2VyT3B0aW9uczogYlxuICAgICAgICB9KTtcbiAgICAgICAgYy5vcHBvc2l0ZSA9IGIub3Bwb3NpdGU7XG4gICAgICAgIGMuc2lkZSA9IGIuc2lkZSB8fCAoYy5ob3JpeiA/IGMub3Bwb3NpdGUgPyAwIDogMiA6IGMub3Bwb3NpdGUgPyAxIDogMyk7XG4gICAgICAgIGMuc2V0T3B0aW9ucyhiKTtcbiAgICAgICAgdmFyIHAgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBlID0gcC50eXBlO1xuICAgICAgICBjLmxhYmVsRm9ybWF0dGVyID0gcC5sYWJlbHMuZm9ybWF0dGVyIHx8IGMuZGVmYXVsdExhYmVsRm9ybWF0dGVyO1xuICAgICAgICBjLnVzZXJPcHRpb25zID0gYjtcbiAgICAgICAgYy5taW5QaXhlbFBhZGRpbmcgPSAwO1xuICAgICAgICBjLnJldmVyc2VkID0gcC5yZXZlcnNlZDtcbiAgICAgICAgYy52aXNpYmxlID0gITEgIT09IHAudmlzaWJsZTtcbiAgICAgICAgYy56b29tRW5hYmxlZCA9ICExICE9PSBwLnpvb21FbmFibGVkO1xuICAgICAgICBjLmhhc05hbWVzID0gXCJjYXRlZ29yeVwiID09PSBlIHx8ICEwID09PSBwLmNhdGVnb3JpZXM7XG4gICAgICAgIGMuY2F0ZWdvcmllcyA9IHAuY2F0ZWdvcmllcyB8fCBjLmhhc05hbWVzO1xuICAgICAgICBjLm5hbWVzIHx8IChjLm5hbWVzID0gW10sIGMubmFtZXMua2V5cyA9IHt9KTtcbiAgICAgICAgYy5wbG90TGluZXNBbmRCYW5kc0dyb3VwcyA9IHt9O1xuICAgICAgICBjLmlzTG9nID0gXCJsb2dhcml0aG1pY1wiID09PSBlO1xuICAgICAgICBjLmlzRGF0ZXRpbWVBeGlzID0gXCJkYXRldGltZVwiID09PSBlO1xuICAgICAgICBjLnBvc2l0aXZlVmFsdWVzT25seSA9IGMuaXNMb2cgJiYgIWMuYWxsb3dOZWdhdGl2ZUxvZztcbiAgICAgICAgYy5pc0xpbmtlZCA9IHQocC5saW5rZWRUbyk7XG4gICAgICAgIGMudGlja3MgPSB7fTtcbiAgICAgICAgYy5sYWJlbEVkZ2UgPSBbXTtcbiAgICAgICAgYy5taW5vclRpY2tzID0ge307XG4gICAgICAgIGMucGxvdExpbmVzQW5kQmFuZHMgPSBbXTtcbiAgICAgICAgYy5hbHRlcm5hdGVCYW5kcyA9IHt9O1xuICAgICAgICBjLmxlbiA9IDA7XG4gICAgICAgIGMubWluUmFuZ2UgPSBjLnVzZXJNaW5SYW5nZSA9IHAubWluUmFuZ2UgfHwgcC5tYXhab29tO1xuICAgICAgICBjLnJhbmdlID0gcC5yYW5nZTtcbiAgICAgICAgYy5vZmZzZXQgPSBwLm9mZnNldCB8fCAwO1xuICAgICAgICBjLnN0YWNrcyA9IHt9O1xuICAgICAgICBjLm9sZFN0YWNrcyA9IHt9O1xuICAgICAgICBjLnN0YWNrc1RvdWNoZWQgPSAwO1xuICAgICAgICBjLm1heCA9IG51bGw7XG4gICAgICAgIGMubWluID0gbnVsbDtcbiAgICAgICAgYy5jcm9zc2hhaXIgPSB6KHAuY3Jvc3NoYWlyLCBMKGEub3B0aW9ucy50b29sdGlwLmNyb3NzaGFpcnMpW2YgPyAwIDogMV0sICExKTtcbiAgICAgICAgYiA9IGMub3B0aW9ucy5ldmVudHM7XG4gICAgICAgIC0xID09PSBhLmF4ZXMuaW5kZXhPZihjKSAmJiAoZiA/IGEuYXhlcy5zcGxpY2UoYS54QXhpcy5sZW5ndGgsIDAsIGMpIDogYS5heGVzLnB1c2goYyksIGFbYy5jb2xsXS5wdXNoKGMpKTtcbiAgICAgICAgYy5zZXJpZXMgPSBjLnNlcmllcyB8fCBbXTtcbiAgICAgICAgYS5pbnZlcnRlZCAmJiAhYy5pc1pBeGlzICYmIGYgJiYgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGMucmV2ZXJzZWQgJiYgKGMucmV2ZXJzZWQgPSAhMCk7XG4gICAgICAgIHYoYiwgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBrKGIpICYmIE0oYywgYSwgYik7XG4gICAgICAgIH0pO1xuICAgICAgICBjLmxpbjJsb2cgPSBwLmxpbmVhclRvTG9nQ29udmVydGVyIHx8IGMubGluMmxvZztcbiAgICAgICAgYy5pc0xvZyAmJiAoYy52YWwybGluID0gYy5sb2cybGluLCBjLmxpbjJ2YWwgPSBjLmxpbjJsb2cpO1xuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJJbml0XCIpO1xuICAgICAgfSxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGEodGhpcy5kZWZhdWx0T3B0aW9ucywgXCJ5QXhpc1wiID09PSB0aGlzLmNvbGwgJiYgdGhpcy5kZWZhdWx0WUF4aXNPcHRpb25zLCBbdGhpcy5kZWZhdWx0VG9wQXhpc09wdGlvbnMsIHRoaXMuZGVmYXVsdFJpZ2h0QXhpc09wdGlvbnMsIHRoaXMuZGVmYXVsdEJvdHRvbUF4aXNPcHRpb25zLCB0aGlzLmRlZmF1bHRMZWZ0QXhpc09wdGlvbnNdW3RoaXMuc2lkZV0sIGEoSFt0aGlzLmNvbGxdLCBjKSk7XG4gICAgICAgIHEodGhpcywgXCJhZnRlclNldE9wdGlvbnNcIiwge1xuICAgICAgICAgIHVzZXJPcHRpb25zOiBjXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGRlZmF1bHRMYWJlbEZvcm1hdHRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuYXhpcyxcbiAgICAgICAgICAgIGIgPSB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgYyA9IGEuY2hhcnQudGltZSxcbiAgICAgICAgICAgIGYgPSBhLmNhdGVnb3JpZXMsXG4gICAgICAgICAgICBlID0gdGhpcy5kYXRlVGltZUxhYmVsRm9ybWF0LFxuICAgICAgICAgICAgbCA9IEgubGFuZyxcbiAgICAgICAgICAgIGsgPSBsLm51bWVyaWNTeW1ib2xzO1xuICAgICAgICBsID0gbC5udW1lcmljU3ltYm9sTWFnbml0dWRlIHx8IDFFMztcbiAgICAgICAgdmFyIHYgPSBrICYmIGsubGVuZ3RoLFxuICAgICAgICAgICAgbSA9IGEub3B0aW9ucy5sYWJlbHMuZm9ybWF0O1xuICAgICAgICBhID0gYS5pc0xvZyA/IE1hdGguYWJzKGIpIDogYS50aWNrSW50ZXJ2YWw7XG4gICAgICAgIHZhciBuID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGQgPSBuLm51bWJlckZvcm1hdHRlcjtcbiAgICAgICAgaWYgKG0pIHZhciB3ID0gUChtLCB0aGlzLCBuKTtlbHNlIGlmIChmKSB3ID0gYjtlbHNlIGlmIChlKSB3ID0gYy5kYXRlRm9ybWF0KGUsIGIpO2Vsc2UgaWYgKHYgJiYgMUUzIDw9IGEpIGZvciAoOyB2LS0gJiYgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHc7KSBjID0gTWF0aC5wb3cobCwgdiArIDEpLCBhID49IGMgJiYgMCA9PT0gMTAgKiBiICUgYyAmJiBudWxsICE9PSBrW3ZdICYmIDAgIT09IGIgJiYgKHcgPSBkKGIgLyBjLCAtMSkgKyBrW3ZdKTtcbiAgICAgICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHcgJiYgKHcgPSAxRTQgPD0gTWF0aC5hYnMoYikgPyBkKGIsIC0xKSA6IGQoYiwgLTEsIHZvaWQgMCwgXCJcIikpO1xuICAgICAgICByZXR1cm4gdztcbiAgICAgIH0sXG4gICAgICBnZXRTZXJpZXNFeHRyZW1lczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICBiID0gYS5jaGFydCxcbiAgICAgICAgICAgIGM7XG4gICAgICAgIHEodGhpcywgXCJnZXRTZXJpZXNFeHRyZW1lc1wiLCBudWxsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYS5oYXNWaXNpYmxlU2VyaWVzID0gITE7XG4gICAgICAgICAgYS5kYXRhTWluID0gYS5kYXRhTWF4ID0gYS50aHJlc2hvbGQgPSBudWxsO1xuICAgICAgICAgIGEuc29mdFRocmVzaG9sZCA9ICFhLmlzWEF4aXM7XG4gICAgICAgICAgYS5idWlsZFN0YWNrcyAmJiBhLmJ1aWxkU3RhY2tzKCk7XG4gICAgICAgICAgYS5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgaWYgKGYudmlzaWJsZSB8fCAhYi5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcykge1xuICAgICAgICAgICAgICB2YXIgZSA9IGYub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgIHAgPSBlLnRocmVzaG9sZDtcbiAgICAgICAgICAgICAgYS5oYXNWaXNpYmxlU2VyaWVzID0gITA7XG4gICAgICAgICAgICAgIGEucG9zaXRpdmVWYWx1ZXNPbmx5ICYmIDAgPj0gcCAmJiAocCA9IG51bGwpO1xuXG4gICAgICAgICAgICAgIGlmIChhLmlzWEF4aXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSA9IGYueERhdGEsIGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBjID0gZi5nZXRYRXh0cmVtZXMoZSk7XG4gICAgICAgICAgICAgICAgICB2YXIgeCA9IGMubWluO1xuICAgICAgICAgICAgICAgICAgdmFyIGwgPSBjLm1heDtcbiAgICAgICAgICAgICAgICAgIG4oeCkgfHwgeCBpbnN0YW5jZW9mIERhdGUgfHwgKGUgPSBlLmZpbHRlcihuKSwgYyA9IGYuZ2V0WEV4dHJlbWVzKGUpLCB4ID0gYy5taW4sIGwgPSBjLm1heCk7XG4gICAgICAgICAgICAgICAgICBlLmxlbmd0aCAmJiAoYS5kYXRhTWluID0gTWF0aC5taW4oeihhLmRhdGFNaW4sIHgpLCB4KSwgYS5kYXRhTWF4ID0gTWF0aC5tYXgoeihhLmRhdGFNYXgsIGwpLCBsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGYuZ2V0RXh0cmVtZXMoKSwgbCA9IGYuZGF0YU1heCwgeCA9IGYuZGF0YU1pbiwgdCh4KSAmJiB0KGwpICYmIChhLmRhdGFNaW4gPSBNYXRoLm1pbih6KGEuZGF0YU1pbiwgeCksIHgpLCBhLmRhdGFNYXggPSBNYXRoLm1heCh6KGEuZGF0YU1heCwgbCksIGwpKSwgdChwKSAmJiAoYS50aHJlc2hvbGQgPSBwKSwgIWUuc29mdFRocmVzaG9sZCB8fCBhLnBvc2l0aXZlVmFsdWVzT25seSkgYS5zb2Z0VGhyZXNob2xkID0gITE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJHZXRTZXJpZXNFeHRyZW1lc1wiKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uIChhLCBiLCBjLCBmLCBlLCBsKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5saW5rZWRQYXJlbnQgfHwgdGhpcyxcbiAgICAgICAgICAgIHggPSAxLFxuICAgICAgICAgICAgbSA9IDAsXG4gICAgICAgICAgICBDID0gZiA/IHAub2xkVHJhbnNBIDogcC50cmFuc0E7XG4gICAgICAgIGYgPSBmID8gcC5vbGRNaW4gOiBwLm1pbjtcbiAgICAgICAgdmFyIGsgPSBwLm1pblBpeGVsUGFkZGluZztcbiAgICAgICAgZSA9IChwLmlzT3JkaW5hbCB8fCBwLmlzQnJva2VuIHx8IHAuaXNMb2cgJiYgZSkgJiYgcC5saW4ydmFsO1xuICAgICAgICBDIHx8IChDID0gcC50cmFuc0EpO1xuICAgICAgICBjICYmICh4ICo9IC0xLCBtID0gcC5sZW4pO1xuICAgICAgICBwLnJldmVyc2VkICYmICh4ICo9IC0xLCBtIC09IHggKiAocC5zZWN0b3IgfHwgcC5sZW4pKTtcbiAgICAgICAgYiA/IChhID0gKGEgKiB4ICsgbSAtIGspIC8gQyArIGYsIGUgJiYgKGEgPSBwLmxpbjJ2YWwoYSkpKSA6IChlICYmIChhID0gcC52YWwybGluKGEpKSwgYSA9IG4oZikgPyB4ICogKGEgLSBmKSAqIEMgKyBtICsgeCAqIGsgKyAobihsKSA/IEMgKiBsIDogMCkgOiB2b2lkIDApO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sXG4gICAgICB0b1BpeGVsczogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlKGEsICExLCAhdGhpcy5ob3JpeiwgbnVsbCwgITApICsgKGIgPyAwIDogdGhpcy5wb3MpO1xuICAgICAgfSxcbiAgICAgIHRvVmFsdWU6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZShhIC0gKGIgPyAwIDogdGhpcy5wb3MpLCAhMCwgIXRoaXMuaG9yaXosIG51bGwsICEwKTtcbiAgICAgIH0sXG4gICAgICBnZXRQbG90TGluZVBhdGg6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBiID0gdGhpcyxcbiAgICAgICAgICAgIGMgPSBiLmNoYXJ0LFxuICAgICAgICAgICAgZiA9IGIubGVmdCxcbiAgICAgICAgICAgIGUgPSBiLnRvcCxcbiAgICAgICAgICAgIHAgPSBhLm9sZCxcbiAgICAgICAgICAgIGwgPSBhLnZhbHVlLFxuICAgICAgICAgICAgayA9IGEudHJhbnNsYXRlZFZhbHVlLFxuICAgICAgICAgICAgbSA9IGEubGluZVdpZHRoLFxuICAgICAgICAgICAgdiA9IGEuZm9yY2UsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgdyxcbiAgICAgICAgICAgIEYsXG4gICAgICAgICAgICBoLFxuICAgICAgICAgICAgQiA9IHAgJiYgYy5vbGRDaGFydEhlaWdodCB8fCBjLmNoYXJ0SGVpZ2h0LFxuICAgICAgICAgICAgTCA9IHAgJiYgYy5vbGRDaGFydFdpZHRoIHx8IGMuY2hhcnRXaWR0aCxcbiAgICAgICAgICAgIHQsXG4gICAgICAgICAgICBnID0gYi50cmFuc0IsXG4gICAgICAgICAgICBIID0gZnVuY3Rpb24gKGIsIGEsIGMpIHtcbiAgICAgICAgICBpZiAoXCJwYXNzXCIgIT09IHYgJiYgYiA8IGEgfHwgYiA+IGMpIHYgPyBiID0gSihiLCBhLCBjKSA6IHQgPSAhMDtcbiAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfTtcblxuICAgICAgICBhID0ge1xuICAgICAgICAgIHZhbHVlOiBsLFxuICAgICAgICAgIGxpbmVXaWR0aDogbSxcbiAgICAgICAgICBvbGQ6IHAsXG4gICAgICAgICAgZm9yY2U6IHYsXG4gICAgICAgICAgYWNyb3NzUGFuZXM6IGEuYWNyb3NzUGFuZXMsXG4gICAgICAgICAgdHJhbnNsYXRlZFZhbHVlOiBrXG4gICAgICAgIH07XG4gICAgICAgIHEodGhpcywgXCJnZXRQbG90TGluZVBhdGhcIiwgYSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBrID0geihrLCBiLnRyYW5zbGF0ZShsLCBudWxsLCBudWxsLCBwKSk7XG4gICAgICAgICAgayA9IEooaywgLTFFNSwgMUU1KTtcbiAgICAgICAgICBkID0gRiA9IE1hdGgucm91bmQoayArIGcpO1xuICAgICAgICAgIHcgPSBoID0gTWF0aC5yb3VuZChCIC0gayAtIGcpO1xuICAgICAgICAgIG4oaykgPyBiLmhvcml6ID8gKHcgPSBlLCBoID0gQiAtIGIuYm90dG9tLCBkID0gRiA9IEgoZCwgZiwgZiArIGIud2lkdGgpKSA6IChkID0gZiwgRiA9IEwgLSBiLnJpZ2h0LCB3ID0gaCA9IEgodywgZSwgZSArIGIuaGVpZ2h0KSkgOiAodCA9ICEwLCB2ID0gITEpO1xuICAgICAgICAgIGEucGF0aCA9IHQgJiYgIXYgPyBudWxsIDogYy5yZW5kZXJlci5jcmlzcExpbmUoW1wiTVwiLCBkLCB3LCBcIkxcIiwgRiwgaF0sIG0gfHwgMSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYS5wYXRoO1xuICAgICAgfSxcbiAgICAgIGdldExpbmVhclRpY2tQb3NpdGlvbnM6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgIHZhciBmID0geShNYXRoLmZsb29yKGIgLyBhKSAqIGEpO1xuICAgICAgICBjID0geShNYXRoLmNlaWwoYyAvIGEpICogYSk7XG4gICAgICAgIHZhciBlID0gW10sXG4gICAgICAgICAgICBwO1xuICAgICAgICB5KGYgKyBhKSA9PT0gZiAmJiAocCA9IDIwKTtcbiAgICAgICAgaWYgKHRoaXMuc2luZ2xlKSByZXR1cm4gW2JdO1xuXG4gICAgICAgIGZvciAoYiA9IGY7IGIgPD0gYzspIHtcbiAgICAgICAgICBlLnB1c2goYik7XG4gICAgICAgICAgYiA9IHkoYiArIGEsIHApO1xuICAgICAgICAgIGlmIChiID09PSBsKSBicmVhaztcbiAgICAgICAgICB2YXIgbCA9IGI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0sXG4gICAgICBnZXRNaW5vclRpY2tJbnRlcnZhbDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgcmV0dXJuICEwID09PSBhLm1pbm9yVGlja3MgPyB6KGEubWlub3JUaWNrSW50ZXJ2YWwsIFwiYXV0b1wiKSA6ICExID09PSBhLm1pbm9yVGlja3MgPyBudWxsIDogYS5taW5vclRpY2tJbnRlcnZhbDtcbiAgICAgIH0sXG4gICAgICBnZXRNaW5vclRpY2tQb3NpdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgYiA9IGEub3B0aW9ucyxcbiAgICAgICAgICAgIGMgPSBhLnRpY2tQb3NpdGlvbnMsXG4gICAgICAgICAgICBmID0gYS5taW5vclRpY2tJbnRlcnZhbCxcbiAgICAgICAgICAgIGUgPSBbXSxcbiAgICAgICAgICAgIGwgPSBhLnBvaW50UmFuZ2VQYWRkaW5nIHx8IDAsXG4gICAgICAgICAgICBrID0gYS5taW4gLSBsO1xuICAgICAgICBsID0gYS5tYXggKyBsO1xuICAgICAgICB2YXIgdiA9IGwgLSBrO1xuICAgICAgICBpZiAodiAmJiB2IC8gZiA8IGEubGVuIC8gMykgaWYgKGEuaXNMb2cpIHRoaXMucGFkZGVkVGlja3MuZm9yRWFjaChmdW5jdGlvbiAoYiwgYywgcCkge1xuICAgICAgICAgIGMgJiYgZS5wdXNoLmFwcGx5KGUsIGEuZ2V0TG9nVGlja1Bvc2l0aW9ucyhmLCBwW2MgLSAxXSwgcFtjXSwgITApKTtcbiAgICAgICAgfSk7ZWxzZSBpZiAoYS5pc0RhdGV0aW1lQXhpcyAmJiBcImF1dG9cIiA9PT0gdGhpcy5nZXRNaW5vclRpY2tJbnRlcnZhbCgpKSBlID0gZS5jb25jYXQoYS5nZXRUaW1lVGlja3MoYS5ub3JtYWxpemVUaW1lVGlja0ludGVydmFsKGYpLCBrLCBsLCBiLnN0YXJ0T2ZXZWVrKSk7ZWxzZSBmb3IgKGIgPSBrICsgKGNbMF0gLSBrKSAlIGY7IGIgPD0gbCAmJiBiICE9PSBlWzBdOyBiICs9IGYpIGUucHVzaChiKTtcbiAgICAgICAgMCAhPT0gZS5sZW5ndGggJiYgYS50cmltVGlja3MoZSk7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfSxcbiAgICAgIGFkanVzdEZvck1pblJhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgYiA9IHRoaXMubWluLFxuICAgICAgICAgICAgYyA9IHRoaXMubWF4LFxuICAgICAgICAgICAgZixcbiAgICAgICAgICAgIGUsXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgayxcbiAgICAgICAgICAgIHY7XG4gICAgICAgIHRoaXMuaXNYQXhpcyAmJiBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgdGhpcy5taW5SYW5nZSAmJiAhdGhpcy5pc0xvZyAmJiAodChhLm1pbikgfHwgdChhLm1heCkgPyB0aGlzLm1pblJhbmdlID0gbnVsbCA6ICh0aGlzLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgayA9IGIueERhdGE7XG5cbiAgICAgICAgICBmb3IgKGUgPSB2ID0gYi54SW5jcmVtZW50ID8gMSA6IGsubGVuZ3RoIC0gMTsgMCA8IGU7IGUtLSkgaWYgKGwgPSBrW2VdIC0ga1tlIC0gMV0sIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBmIHx8IGwgPCBmKSBmID0gbDtcbiAgICAgICAgfSksIHRoaXMubWluUmFuZ2UgPSBNYXRoLm1pbig1ICogZiwgdGhpcy5kYXRhTWF4IC0gdGhpcy5kYXRhTWluKSkpO1xuXG4gICAgICAgIGlmIChjIC0gYiA8IHRoaXMubWluUmFuZ2UpIHtcbiAgICAgICAgICB2YXIgbSA9IHRoaXMuZGF0YU1heCAtIHRoaXMuZGF0YU1pbiA+PSB0aGlzLm1pblJhbmdlO1xuICAgICAgICAgIHZhciBuID0gdGhpcy5taW5SYW5nZTtcbiAgICAgICAgICB2YXIgZCA9IChuIC0gYyArIGIpIC8gMjtcbiAgICAgICAgICBkID0gW2IgLSBkLCB6KGEubWluLCBiIC0gZCldO1xuICAgICAgICAgIG0gJiYgKGRbMl0gPSB0aGlzLmlzTG9nID8gdGhpcy5sb2cybGluKHRoaXMuZGF0YU1pbikgOiB0aGlzLmRhdGFNaW4pO1xuICAgICAgICAgIGIgPSBBKGQpO1xuICAgICAgICAgIGMgPSBbYiArIG4sIHooYS5tYXgsIGIgKyBuKV07XG4gICAgICAgICAgbSAmJiAoY1syXSA9IHRoaXMuaXNMb2cgPyB0aGlzLmxvZzJsaW4odGhpcy5kYXRhTWF4KSA6IHRoaXMuZGF0YU1heCk7XG4gICAgICAgICAgYyA9IEcoYyk7XG4gICAgICAgICAgYyAtIGIgPCBuICYmIChkWzBdID0gYyAtIG4sIGRbMV0gPSB6KGEubWluLCBjIC0gbiksIGIgPSBBKGQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWluID0gYjtcbiAgICAgICAgdGhpcy5tYXggPSBjO1xuICAgICAgfSxcbiAgICAgIGdldENsb3Nlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGE7XG4gICAgICAgIHRoaXMuY2F0ZWdvcmllcyA/IGEgPSAxIDogdGhpcy5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHZhciBjID0gYi5jbG9zZXN0UG9pbnRSYW5nZSxcbiAgICAgICAgICAgICAgZiA9IGIudmlzaWJsZSB8fCAhYi5jaGFydC5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcztcbiAgICAgICAgICAhYi5ub1NoYXJlZFRvb2x0aXAgJiYgdChjKSAmJiBmICYmIChhID0gdChhKSA/IE1hdGgubWluKGEsIGMpIDogYyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sXG4gICAgICBuYW1lVG9YOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYiA9IGModGhpcy5jYXRlZ29yaWVzKSxcbiAgICAgICAgICAgIGYgPSBiID8gdGhpcy5jYXRlZ29yaWVzIDogdGhpcy5uYW1lcyxcbiAgICAgICAgICAgIGUgPSBhLm9wdGlvbnMueDtcbiAgICAgICAgYS5zZXJpZXMucmVxdWlyZVNvcnRpbmcgPSAhMTtcbiAgICAgICAgdChlKSB8fCAoZSA9ICExID09PSB0aGlzLm9wdGlvbnMudW5pcXVlTmFtZXMgPyBhLnNlcmllcy5hdXRvSW5jcmVtZW50KCkgOiBiID8gZi5pbmRleE9mKGEubmFtZSkgOiB6KGYua2V5c1thLm5hbWVdLCAtMSkpO1xuXG4gICAgICAgIGlmICgtMSA9PT0gZSkge1xuICAgICAgICAgIGlmICghYikgdmFyIHAgPSBmLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHAgPSBlO1xuXG4gICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBwICYmICh0aGlzLm5hbWVzW3BdID0gYS5uYW1lLCB0aGlzLm5hbWVzLmtleXNbYS5uYW1lXSA9IHApO1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVOYW1lczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICBiID0gdGhpcy5uYW1lcztcbiAgICAgICAgMCA8IGIubGVuZ3RoICYmIChPYmplY3Qua2V5cyhiLmtleXMpLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBkZWxldGUgYi5rZXlzW2FdO1xuICAgICAgICB9KSwgYi5sZW5ndGggPSAwLCB0aGlzLm1pblJhbmdlID0gdGhpcy51c2VyTWluUmFuZ2UsICh0aGlzLnNlcmllcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGIueEluY3JlbWVudCA9IG51bGw7XG4gICAgICAgICAgaWYgKCFiLnBvaW50cyB8fCBiLmlzRGlydHlEYXRhKSBhLm1heCA9IE1hdGgubWF4KGEubWF4LCBiLnhEYXRhLmxlbmd0aCAtIDEpLCBiLnByb2Nlc3NEYXRhKCksIGIuZ2VuZXJhdGVQb2ludHMoKTtcbiAgICAgICAgICBiLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoYywgZikge1xuICAgICAgICAgICAgaWYgKGMgJiYgYy5vcHRpb25zICYmIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBjLm5hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIGUgPSBhLm5hbWVUb1goYyk7XG4gICAgICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBlICYmIGUgIT09IGMueCAmJiAoYy54ID0gZSwgYi54RGF0YVtmXSA9IGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgICAgc2V0QXhpc1RyYW5zbGF0aW9uOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgICAgICBjID0gYi5tYXggLSBiLm1pbixcbiAgICAgICAgICAgIGUgPSBiLmF4aXNQb2ludFJhbmdlIHx8IDAsXG4gICAgICAgICAgICBwID0gMCxcbiAgICAgICAgICAgIGwgPSAwLFxuICAgICAgICAgICAgayA9IGIubGlua2VkUGFyZW50LFxuICAgICAgICAgICAgdiA9ICEhYi5jYXRlZ29yaWVzLFxuICAgICAgICAgICAgbSA9IGIudHJhbnNBLFxuICAgICAgICAgICAgZCA9IGIuaXNYQXhpcztcblxuICAgICAgICBpZiAoZCB8fCB2IHx8IGUpIHtcbiAgICAgICAgICB2YXIgbiA9IGIuZ2V0Q2xvc2VzdCgpO1xuICAgICAgICAgIGsgPyAocCA9IGsubWluUG9pbnRPZmZzZXQsIGwgPSBrLnBvaW50UmFuZ2VQYWRkaW5nKSA6IGIuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHZhciBjID0gdiA/IDEgOiBkID8geihhLm9wdGlvbnMucG9pbnRSYW5nZSwgbiwgMCkgOiBiLmF4aXNQb2ludFJhbmdlIHx8IDAsXG4gICAgICAgICAgICAgICAgeCA9IGEub3B0aW9ucy5wb2ludFBsYWNlbWVudDtcbiAgICAgICAgICAgIGUgPSBNYXRoLm1heChlLCBjKTtcbiAgICAgICAgICAgIGlmICghYi5zaW5nbGUgfHwgdikgYSA9IGEuaXMoXCJ4cmFuZ2VcIikgPyAhZCA6IGQsIHAgPSBNYXRoLm1heChwLCBhICYmIGYoeCkgPyAwIDogYyAvIDIpLCBsID0gTWF0aC5tYXgobCwgYSAmJiBcIm9uXCIgPT09IHggPyAwIDogYyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgayA9IGIub3JkaW5hbFNsb3BlICYmIG4gPyBiLm9yZGluYWxTbG9wZSAvIG4gOiAxO1xuICAgICAgICAgIGIubWluUG9pbnRPZmZzZXQgPSBwICo9IGs7XG4gICAgICAgICAgYi5wb2ludFJhbmdlUGFkZGluZyA9IGwgKj0gaztcbiAgICAgICAgICBiLnBvaW50UmFuZ2UgPSBNYXRoLm1pbihlLCBiLnNpbmdsZSAmJiB2ID8gMSA6IGMpO1xuICAgICAgICAgIGQgJiYgKGIuY2xvc2VzdFBvaW50UmFuZ2UgPSBuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGEgJiYgKGIub2xkVHJhbnNBID0gbSk7XG4gICAgICAgIGIudHJhbnNsYXRpb25TbG9wZSA9IGIudHJhbnNBID0gbSA9IGIuc3RhdGljU2NhbGUgfHwgYi5sZW4gLyAoYyArIGwgfHwgMSk7XG4gICAgICAgIGIudHJhbnNCID0gYi5ob3JpeiA/IGIubGVmdCA6IGIuYm90dG9tO1xuICAgICAgICBiLm1pblBpeGVsUGFkZGluZyA9IG0gKiBwO1xuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJTZXRBeGlzVHJhbnNsYXRpb25cIik7XG4gICAgICB9LFxuICAgICAgbWluRnJvbVJhbmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heCAtIHRoaXMucmFuZ2U7XG4gICAgICB9LFxuICAgICAgc2V0VGlja0ludGVydmFsOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgICAgICBjID0gYi5jaGFydCxcbiAgICAgICAgICAgIGYgPSBiLm9wdGlvbnMsXG4gICAgICAgICAgICBwID0gYi5pc0xvZyxcbiAgICAgICAgICAgIGsgPSBiLmlzRGF0ZXRpbWVBeGlzLFxuICAgICAgICAgICAgdiA9IGIuaXNYQXhpcyxcbiAgICAgICAgICAgIGQgPSBiLmlzTGlua2VkLFxuICAgICAgICAgICAgbSA9IGYubWF4UGFkZGluZyxcbiAgICAgICAgICAgIHcgPSBmLm1pblBhZGRpbmcsXG4gICAgICAgICAgICBCID0gZi50aWNrSW50ZXJ2YWwsXG4gICAgICAgICAgICBMID0gZi50aWNrUGl4ZWxJbnRlcnZhbCxcbiAgICAgICAgICAgIEYgPSBiLmNhdGVnb3JpZXMsXG4gICAgICAgICAgICBWID0gbihiLnRocmVzaG9sZCkgPyBiLnRocmVzaG9sZCA6IG51bGwsXG4gICAgICAgICAgICBnID0gYi5zb2Z0VGhyZXNob2xkO1xuICAgICAgICBrIHx8IEYgfHwgZCB8fCB0aGlzLmdldFRpY2tBbW91bnQoKTtcbiAgICAgICAgdmFyIEggPSB6KGIudXNlck1pbiwgZi5taW4pO1xuICAgICAgICB2YXIgSyA9IHooYi51c2VyTWF4LCBmLm1heCk7XG5cbiAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICBiLmxpbmtlZFBhcmVudCA9IGNbYi5jb2xsXVtmLmxpbmtlZFRvXTtcbiAgICAgICAgICB2YXIgUSA9IGIubGlua2VkUGFyZW50LmdldEV4dHJlbWVzKCk7XG4gICAgICAgICAgYi5taW4gPSB6KFEubWluLCBRLmRhdGFNaW4pO1xuICAgICAgICAgIGIubWF4ID0geihRLm1heCwgUS5kYXRhTWF4KTtcbiAgICAgICAgICBmLnR5cGUgIT09IGIubGlua2VkUGFyZW50Lm9wdGlvbnMudHlwZSAmJiBoKDExLCAxLCBjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWcgJiYgdChWKSkgaWYgKGIuZGF0YU1pbiA+PSBWKSBRID0gViwgdyA9IDA7ZWxzZSBpZiAoYi5kYXRhTWF4IDw9IFYpIHtcbiAgICAgICAgICAgIHZhciB1ID0gVjtcbiAgICAgICAgICAgIG0gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiLm1pbiA9IHooSCwgUSwgYi5kYXRhTWluKTtcbiAgICAgICAgICBiLm1heCA9IHooSywgdSwgYi5kYXRhTWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHAgJiYgKGIucG9zaXRpdmVWYWx1ZXNPbmx5ICYmICFhICYmIDAgPj0gTWF0aC5taW4oYi5taW4sIHooYi5kYXRhTWluLCBiLm1pbikpICYmIGgoMTAsIDEsIGMpLCBiLm1pbiA9IHkoYi5sb2cybGluKGIubWluKSwgMTYpLCBiLm1heCA9IHkoYi5sb2cybGluKGIubWF4KSwgMTYpKTtcbiAgICAgICAgYi5yYW5nZSAmJiB0KGIubWF4KSAmJiAoYi51c2VyTWluID0gYi5taW4gPSBIID0gTWF0aC5tYXgoYi5kYXRhTWluLCBiLm1pbkZyb21SYW5nZSgpKSwgYi51c2VyTWF4ID0gSyA9IGIubWF4LCBiLnJhbmdlID0gbnVsbCk7XG4gICAgICAgIHEoYiwgXCJmb3VuZEV4dHJlbWVzXCIpO1xuICAgICAgICBiLmJlZm9yZVBhZGRpbmcgJiYgYi5iZWZvcmVQYWRkaW5nKCk7XG4gICAgICAgIGIuYWRqdXN0Rm9yTWluUmFuZ2UoKTtcbiAgICAgICAgIShGIHx8IGIuYXhpc1BvaW50UmFuZ2UgfHwgYi51c2VQZXJjZW50YWdlIHx8IGQpICYmIHQoYi5taW4pICYmIHQoYi5tYXgpICYmIChjID0gYi5tYXggLSBiLm1pbikgJiYgKCF0KEgpICYmIHcgJiYgKGIubWluIC09IGMgKiB3KSwgIXQoSykgJiYgbSAmJiAoYi5tYXggKz0gYyAqIG0pKTtcbiAgICAgICAgbihiLnVzZXJNaW4pIHx8IChuKGYuc29mdE1pbikgJiYgZi5zb2Z0TWluIDwgYi5taW4gJiYgKGIubWluID0gSCA9IGYuc29mdE1pbiksIG4oZi5mbG9vcikgJiYgKGIubWluID0gTWF0aC5tYXgoYi5taW4sIGYuZmxvb3IpKSk7XG4gICAgICAgIG4oYi51c2VyTWF4KSB8fCAobihmLnNvZnRNYXgpICYmIGYuc29mdE1heCA+IGIubWF4ICYmIChiLm1heCA9IEsgPSBmLnNvZnRNYXgpLCBuKGYuY2VpbGluZykgJiYgKGIubWF4ID0gTWF0aC5taW4oYi5tYXgsIGYuY2VpbGluZykpKTtcbiAgICAgICAgZyAmJiB0KGIuZGF0YU1pbikgJiYgKFYgPSBWIHx8IDAsICF0KEgpICYmIGIubWluIDwgViAmJiBiLmRhdGFNaW4gPj0gViA/IGIubWluID0gYi5vcHRpb25zLm1pblJhbmdlID8gTWF0aC5taW4oViwgYi5tYXggLSBiLm1pblJhbmdlKSA6IFYgOiAhdChLKSAmJiBiLm1heCA+IFYgJiYgYi5kYXRhTWF4IDw9IFYgJiYgKGIubWF4ID0gYi5vcHRpb25zLm1pblJhbmdlID8gTWF0aC5tYXgoViwgYi5taW4gKyBiLm1pblJhbmdlKSA6IFYpKTtcbiAgICAgICAgYi50aWNrSW50ZXJ2YWwgPSBiLm1pbiA9PT0gYi5tYXggfHwgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGIubWluIHx8IFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBiLm1heCA/IDEgOiBkICYmICFCICYmIEwgPT09IGIubGlua2VkUGFyZW50Lm9wdGlvbnMudGlja1BpeGVsSW50ZXJ2YWwgPyBCID0gYi5saW5rZWRQYXJlbnQudGlja0ludGVydmFsIDogeihCLCB0aGlzLnRpY2tBbW91bnQgPyAoYi5tYXggLSBiLm1pbikgLyBNYXRoLm1heCh0aGlzLnRpY2tBbW91bnQgLSAxLCAxKSA6IHZvaWQgMCwgRiA/IDEgOiAoYi5tYXggLSBiLm1pbikgKiBMIC8gTWF0aC5tYXgoYi5sZW4sIEwpKTtcbiAgICAgICAgdiAmJiAhYSAmJiBiLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYS5wcm9jZXNzRGF0YShiLm1pbiAhPT0gYi5vbGRNaW4gfHwgYi5tYXggIT09IGIub2xkTWF4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGIuc2V0QXhpc1RyYW5zbGF0aW9uKCEwKTtcbiAgICAgICAgYi5iZWZvcmVTZXRUaWNrUG9zaXRpb25zICYmIGIuYmVmb3JlU2V0VGlja1Bvc2l0aW9ucygpO1xuICAgICAgICBiLnBvc3RQcm9jZXNzVGlja0ludGVydmFsICYmIChiLnRpY2tJbnRlcnZhbCA9IGIucG9zdFByb2Nlc3NUaWNrSW50ZXJ2YWwoYi50aWNrSW50ZXJ2YWwpKTtcbiAgICAgICAgYi5wb2ludFJhbmdlICYmICFCICYmIChiLnRpY2tJbnRlcnZhbCA9IE1hdGgubWF4KGIucG9pbnRSYW5nZSwgYi50aWNrSW50ZXJ2YWwpKTtcbiAgICAgICAgYSA9IHooZi5taW5UaWNrSW50ZXJ2YWwsIGIuaXNEYXRldGltZUF4aXMgJiYgYi5jbG9zZXN0UG9pbnRSYW5nZSk7XG4gICAgICAgICFCICYmIGIudGlja0ludGVydmFsIDwgYSAmJiAoYi50aWNrSW50ZXJ2YWwgPSBhKTtcbiAgICAgICAgayB8fCBwIHx8IEIgfHwgKGIudGlja0ludGVydmFsID0gbChiLnRpY2tJbnRlcnZhbCwgbnVsbCwgZShiLnRpY2tJbnRlcnZhbCksIHooZi5hbGxvd0RlY2ltYWxzLCAhKC41IDwgYi50aWNrSW50ZXJ2YWwgJiYgNSA+IGIudGlja0ludGVydmFsICYmIDFFMyA8IGIubWF4ICYmIDk5OTkgPiBiLm1heCkpLCAhIXRoaXMudGlja0Ftb3VudCkpO1xuICAgICAgICB0aGlzLnRpY2tBbW91bnQgfHwgKGIudGlja0ludGVydmFsID0gYi51bnNxdWlzaCgpKTtcbiAgICAgICAgdGhpcy5zZXRUaWNrUG9zaXRpb25zKCk7XG4gICAgICB9LFxuICAgICAgc2V0VGlja1Bvc2l0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGIgPSBhLnRpY2tQb3NpdGlvbnM7XG4gICAgICAgIHZhciBjID0gdGhpcy5nZXRNaW5vclRpY2tJbnRlcnZhbCgpO1xuICAgICAgICB2YXIgZiA9IGEudGlja1Bvc2l0aW9uZXIsXG4gICAgICAgICAgICBlID0gYS5zdGFydE9uVGljayxcbiAgICAgICAgICAgIGwgPSBhLmVuZE9uVGljaztcbiAgICAgICAgdGhpcy50aWNrbWFya09mZnNldCA9IHRoaXMuY2F0ZWdvcmllcyAmJiBcImJldHdlZW5cIiA9PT0gYS50aWNrbWFya1BsYWNlbWVudCAmJiAxID09PSB0aGlzLnRpY2tJbnRlcnZhbCA/IC41IDogMDtcbiAgICAgICAgdGhpcy5taW5vclRpY2tJbnRlcnZhbCA9IFwiYXV0b1wiID09PSBjICYmIHRoaXMudGlja0ludGVydmFsID8gdGhpcy50aWNrSW50ZXJ2YWwgLyA1IDogYztcbiAgICAgICAgdGhpcy5zaW5nbGUgPSB0aGlzLm1pbiA9PT0gdGhpcy5tYXggJiYgdCh0aGlzLm1pbikgJiYgIXRoaXMudGlja0Ftb3VudCAmJiAocGFyc2VJbnQodGhpcy5taW4sIDEwKSA9PT0gdGhpcy5taW4gfHwgITEgIT09IGEuYWxsb3dEZWNpbWFscyk7XG4gICAgICAgIHRoaXMudGlja1Bvc2l0aW9ucyA9IGMgPSBiICYmIGIuc2xpY2UoKTtcbiAgICAgICAgIWMgJiYgKCF0aGlzLm9yZGluYWxQb3NpdGlvbnMgJiYgKHRoaXMubWF4IC0gdGhpcy5taW4pIC8gdGhpcy50aWNrSW50ZXJ2YWwgPiBNYXRoLm1heCgyICogdGhpcy5sZW4sIDIwMCkgPyAoYyA9IFt0aGlzLm1pbiwgdGhpcy5tYXhdLCBoKDE5LCAhMSwgdGhpcy5jaGFydCkpIDogYyA9IHRoaXMuaXNEYXRldGltZUF4aXMgPyB0aGlzLmdldFRpbWVUaWNrcyh0aGlzLm5vcm1hbGl6ZVRpbWVUaWNrSW50ZXJ2YWwodGhpcy50aWNrSW50ZXJ2YWwsIGEudW5pdHMpLCB0aGlzLm1pbiwgdGhpcy5tYXgsIGEuc3RhcnRPZldlZWssIHRoaXMub3JkaW5hbFBvc2l0aW9ucywgdGhpcy5jbG9zZXN0UG9pbnRSYW5nZSwgITApIDogdGhpcy5pc0xvZyA/IHRoaXMuZ2V0TG9nVGlja1Bvc2l0aW9ucyh0aGlzLnRpY2tJbnRlcnZhbCwgdGhpcy5taW4sIHRoaXMubWF4KSA6IHRoaXMuZ2V0TGluZWFyVGlja1Bvc2l0aW9ucyh0aGlzLnRpY2tJbnRlcnZhbCwgdGhpcy5taW4sIHRoaXMubWF4KSwgYy5sZW5ndGggPiB0aGlzLmxlbiAmJiAoYyA9IFtjWzBdLCBjLnBvcCgpXSwgY1swXSA9PT0gY1sxXSAmJiAoYy5sZW5ndGggPSAxKSksIHRoaXMudGlja1Bvc2l0aW9ucyA9IGMsIGYgJiYgKGYgPSBmLmFwcGx5KHRoaXMsIFt0aGlzLm1pbiwgdGhpcy5tYXhdKSkpICYmICh0aGlzLnRpY2tQb3NpdGlvbnMgPSBjID0gZik7XG4gICAgICAgIHRoaXMucGFkZGVkVGlja3MgPSBjLnNsaWNlKDApO1xuICAgICAgICB0aGlzLnRyaW1UaWNrcyhjLCBlLCBsKTtcbiAgICAgICAgdGhpcy5pc0xpbmtlZCB8fCAodGhpcy5zaW5nbGUgJiYgMiA+IGMubGVuZ3RoICYmICF0aGlzLmNhdGVnb3JpZXMgJiYgIXRoaXMuc2VyaWVzLnNvbWUoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICByZXR1cm4gYi5pcyhcImhlYXRtYXBcIikgJiYgXCJiZXR3ZWVuXCIgPT09IGIub3B0aW9ucy5wb2ludFBsYWNlbWVudDtcbiAgICAgICAgfSkgJiYgKHRoaXMubWluIC09IC41LCB0aGlzLm1heCArPSAuNSksIGIgfHwgZiB8fCB0aGlzLmFkanVzdFRpY2tBbW91bnQoKSk7XG4gICAgICAgIHEodGhpcywgXCJhZnRlclNldFRpY2tQb3NpdGlvbnNcIik7XG4gICAgICB9LFxuICAgICAgdHJpbVRpY2tzOiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICB2YXIgZiA9IGFbMF0sXG4gICAgICAgICAgICBlID0gYVthLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcCA9ICF0aGlzLmlzT3JkaW5hbCAmJiB0aGlzLm1pblBvaW50T2Zmc2V0IHx8IDA7XG4gICAgICAgIHEodGhpcywgXCJ0cmltVGlja3NcIik7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzTGlua2VkKSB7XG4gICAgICAgICAgaWYgKGIgJiYgLUluZmluaXR5ICE9PSBmKSB0aGlzLm1pbiA9IGY7ZWxzZSBmb3IgKDsgdGhpcy5taW4gLSBwID4gYVswXTspIGEuc2hpZnQoKTtcbiAgICAgICAgICBpZiAoYykgdGhpcy5tYXggPSBlO2Vsc2UgZm9yICg7IHRoaXMubWF4ICsgcCA8IGFbYS5sZW5ndGggLSAxXTspIGEucG9wKCk7XG4gICAgICAgICAgMCA9PT0gYS5sZW5ndGggJiYgdChmKSAmJiAhdGhpcy5vcHRpb25zLnRpY2tQb3NpdGlvbnMgJiYgYS5wdXNoKChlICsgZikgLyAyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFsaWduVG9PdGhlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB7fSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAhMSA9PT0gdGhpcy5jaGFydC5vcHRpb25zLmNoYXJ0LmFsaWduVGlja3MgfHwgITEgPT09IGMuYWxpZ25UaWNrcyB8fCAhMSA9PT0gYy5zdGFydE9uVGljayB8fCAhMSA9PT0gYy5lbmRPblRpY2sgfHwgdGhpcy5pc0xvZyB8fCB0aGlzLmNoYXJ0W3RoaXMuY29sbF0uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHZhciBmID0gYy5vcHRpb25zO1xuICAgICAgICAgIGYgPSBbYy5ob3JpeiA/IGYubGVmdCA6IGYudG9wLCBmLndpZHRoLCBmLmhlaWdodCwgZi5wYW5lXS5qb2luKCk7XG4gICAgICAgICAgYy5zZXJpZXMubGVuZ3RoICYmIChhW2ZdID8gYiA9ICEwIDogYVtmXSA9IDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9LFxuICAgICAgZ2V0VGlja0Ftb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGIgPSBhLnRpY2tBbW91bnQsXG4gICAgICAgICAgICBjID0gYS50aWNrUGl4ZWxJbnRlcnZhbDtcbiAgICAgICAgIXQoYS50aWNrSW50ZXJ2YWwpICYmIHRoaXMubGVuIDwgYyAmJiAhdGhpcy5pc1JhZGlhbCAmJiAhdGhpcy5pc0xvZyAmJiBhLnN0YXJ0T25UaWNrICYmIGEuZW5kT25UaWNrICYmIChiID0gMik7XG4gICAgICAgICFiICYmIHRoaXMuYWxpZ25Ub090aGVycygpICYmIChiID0gTWF0aC5jZWlsKHRoaXMubGVuIC8gYykgKyAxKTtcbiAgICAgICAgNCA+IGIgJiYgKHRoaXMuZmluYWxUaWNrQW10ID0gYiwgYiA9IDUpO1xuICAgICAgICB0aGlzLnRpY2tBbW91bnQgPSBiO1xuICAgICAgfSxcbiAgICAgIGFkanVzdFRpY2tBbW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBiID0gdGhpcy50aWNrSW50ZXJ2YWwsXG4gICAgICAgICAgICBjID0gdGhpcy50aWNrUG9zaXRpb25zLFxuICAgICAgICAgICAgZiA9IHRoaXMudGlja0Ftb3VudCxcbiAgICAgICAgICAgIGUgPSB0aGlzLmZpbmFsVGlja0FtdCxcbiAgICAgICAgICAgIGwgPSBjICYmIGMubGVuZ3RoLFxuICAgICAgICAgICAgayA9IHoodGhpcy50aHJlc2hvbGQsIHRoaXMuc29mdFRocmVzaG9sZCA/IDAgOiBudWxsKSxcbiAgICAgICAgICAgIHY7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzRGF0YSgpKSB7XG4gICAgICAgICAgaWYgKGwgPCBmKSB7XG4gICAgICAgICAgICBmb3IgKHYgPSB0aGlzLm1pbjsgYy5sZW5ndGggPCBmOykgYy5sZW5ndGggJSAyIHx8IHYgPT09IGsgPyBjLnB1c2goeShjW2MubGVuZ3RoIC0gMV0gKyBiKSkgOiBjLnVuc2hpZnQoeShjWzBdIC0gYikpO1xuXG4gICAgICAgICAgICB0aGlzLnRyYW5zQSAqPSAobCAtIDEpIC8gKGYgLSAxKTtcbiAgICAgICAgICAgIHRoaXMubWluID0gYS5zdGFydE9uVGljayA/IGNbMF0gOiBNYXRoLm1pbih0aGlzLm1pbiwgY1swXSk7XG4gICAgICAgICAgICB0aGlzLm1heCA9IGEuZW5kT25UaWNrID8gY1tjLmxlbmd0aCAtIDFdIDogTWF0aC5tYXgodGhpcy5tYXgsIGNbYy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgfSBlbHNlIGwgPiBmICYmICh0aGlzLnRpY2tJbnRlcnZhbCAqPSAyLCB0aGlzLnNldFRpY2tQb3NpdGlvbnMoKSk7XG5cbiAgICAgICAgICBpZiAodChlKSkge1xuICAgICAgICAgICAgZm9yIChiID0gYSA9IGMubGVuZ3RoOyBiLS07KSAoMyA9PT0gZSAmJiAxID09PSBiICUgMiB8fCAyID49IGUgJiYgMCA8IGIgJiYgYiA8IGEgLSAxKSAmJiBjLnNwbGljZShiLCAxKTtcblxuICAgICAgICAgICAgdGhpcy5maW5hbFRpY2tBbXQgPSB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0U2NhbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLnNlcmllcy5zb21lKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgcmV0dXJuIGIuaXNEaXJ0eURhdGEgfHwgYi5pc0RpcnR5IHx8IGIueEF4aXMgJiYgYi54QXhpcy5pc0RpcnR5O1xuICAgICAgICB9KSxcbiAgICAgICAgICAgIGI7XG4gICAgICAgIHRoaXMub2xkTWluID0gdGhpcy5taW47XG4gICAgICAgIHRoaXMub2xkTWF4ID0gdGhpcy5tYXg7XG4gICAgICAgIHRoaXMub2xkQXhpc0xlbmd0aCA9IHRoaXMubGVuO1xuICAgICAgICB0aGlzLnNldEF4aXNTaXplKCk7XG4gICAgICAgIChiID0gdGhpcy5sZW4gIT09IHRoaXMub2xkQXhpc0xlbmd0aCkgfHwgYSB8fCB0aGlzLmlzTGlua2VkIHx8IHRoaXMuZm9yY2VSZWRyYXcgfHwgdGhpcy51c2VyTWluICE9PSB0aGlzLm9sZFVzZXJNaW4gfHwgdGhpcy51c2VyTWF4ICE9PSB0aGlzLm9sZFVzZXJNYXggfHwgdGhpcy5hbGlnblRvT3RoZXJzKCkgPyAodGhpcy5yZXNldFN0YWNrcyAmJiB0aGlzLnJlc2V0U3RhY2tzKCksIHRoaXMuZm9yY2VSZWRyYXcgPSAhMSwgdGhpcy5nZXRTZXJpZXNFeHRyZW1lcygpLCB0aGlzLnNldFRpY2tJbnRlcnZhbCgpLCB0aGlzLm9sZFVzZXJNaW4gPSB0aGlzLnVzZXJNaW4sIHRoaXMub2xkVXNlck1heCA9IHRoaXMudXNlck1heCwgdGhpcy5pc0RpcnR5IHx8ICh0aGlzLmlzRGlydHkgPSBiIHx8IHRoaXMubWluICE9PSB0aGlzLm9sZE1pbiB8fCB0aGlzLm1heCAhPT0gdGhpcy5vbGRNYXgpKSA6IHRoaXMuY2xlYW5TdGFja3MgJiYgdGhpcy5jbGVhblN0YWNrcygpO1xuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJTZXRTY2FsZVwiKTtcbiAgICAgIH0sXG4gICAgICBzZXRFeHRyZW1lczogZnVuY3Rpb24gKGEsIGIsIGMsIGYsIGUpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLFxuICAgICAgICAgICAgbCA9IHAuY2hhcnQ7XG4gICAgICAgIGMgPSB6KGMsICEwKTtcbiAgICAgICAgcC5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGRlbGV0ZSBiLmtkVHJlZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGUgPSBOKGUsIHtcbiAgICAgICAgICBtaW46IGEsXG4gICAgICAgICAgbWF4OiBiXG4gICAgICAgIH0pO1xuICAgICAgICBxKHAsIFwic2V0RXh0cmVtZXNcIiwgZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHAudXNlck1pbiA9IGE7XG4gICAgICAgICAgcC51c2VyTWF4ID0gYjtcbiAgICAgICAgICBwLmV2ZW50QXJncyA9IGU7XG4gICAgICAgICAgYyAmJiBsLnJlZHJhdyhmKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgem9vbTogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmRhdGFNaW4sXG4gICAgICAgICAgICBmID0gdGhpcy5kYXRhTWF4LFxuICAgICAgICAgICAgZSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIHAgPSBNYXRoLm1pbihjLCB6KGUubWluLCBjKSksXG4gICAgICAgICAgICBsID0gTWF0aC5tYXgoZiwgeihlLm1heCwgZikpO1xuICAgICAgICBhID0ge1xuICAgICAgICAgIG5ld01pbjogYSxcbiAgICAgICAgICBuZXdNYXg6IGJcbiAgICAgICAgfTtcbiAgICAgICAgcSh0aGlzLCBcInpvb21cIiwgYSwgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICB2YXIgYSA9IGIubmV3TWluLFxuICAgICAgICAgICAgICBlID0gYi5uZXdNYXg7XG4gICAgICAgICAgaWYgKGEgIT09IHRoaXMubWluIHx8IGUgIT09IHRoaXMubWF4KSB0aGlzLmFsbG93Wm9vbU91dHNpZGUgfHwgKHQoYykgJiYgKGEgPCBwICYmIChhID0gcCksIGEgPiBsICYmIChhID0gbCkpLCB0KGYpICYmIChlIDwgcCAmJiAoZSA9IHApLCBlID4gbCAmJiAoZSA9IGwpKSksIHRoaXMuZGlzcGxheUJ0biA9IFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBhIHx8IFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBlLCB0aGlzLnNldEV4dHJlbWVzKGEsIGUsICExLCB2b2lkIDAsIHtcbiAgICAgICAgICAgIHRyaWdnZXI6IFwiem9vbVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYi56b29tZWQgPSAhMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhLnpvb21lZDtcbiAgICAgIH0sXG4gICAgICBzZXRBeGlzU2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBiID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgYyA9IGIub2Zmc2V0cyB8fCBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICBmID0gdGhpcy5ob3JpeixcbiAgICAgICAgICAgIGUgPSB0aGlzLndpZHRoID0gTWF0aC5yb3VuZCh3KHooYi53aWR0aCwgYS5wbG90V2lkdGggLSBjWzNdICsgY1sxXSksIGEucGxvdFdpZHRoKSksXG4gICAgICAgICAgICBsID0gdGhpcy5oZWlnaHQgPSBNYXRoLnJvdW5kKHcoeihiLmhlaWdodCwgYS5wbG90SGVpZ2h0IC0gY1swXSArIGNbMl0pLCBhLnBsb3RIZWlnaHQpKSxcbiAgICAgICAgICAgIGsgPSB0aGlzLnRvcCA9IE1hdGgucm91bmQodyh6KGIudG9wLCBhLnBsb3RUb3AgKyBjWzBdKSwgYS5wbG90SGVpZ2h0LCBhLnBsb3RUb3ApKTtcbiAgICAgICAgYiA9IHRoaXMubGVmdCA9IE1hdGgucm91bmQodyh6KGIubGVmdCwgYS5wbG90TGVmdCArIGNbM10pLCBhLnBsb3RXaWR0aCwgYS5wbG90TGVmdCkpO1xuICAgICAgICB0aGlzLmJvdHRvbSA9IGEuY2hhcnRIZWlnaHQgLSBsIC0gaztcbiAgICAgICAgdGhpcy5yaWdodCA9IGEuY2hhcnRXaWR0aCAtIGUgLSBiO1xuICAgICAgICB0aGlzLmxlbiA9IE1hdGgubWF4KGYgPyBlIDogbCwgMCk7XG4gICAgICAgIHRoaXMucG9zID0gZiA/IGIgOiBrO1xuICAgICAgfSxcbiAgICAgIGdldEV4dHJlbWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5pc0xvZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtaW46IGEgPyB5KHRoaXMubGluMmxvZyh0aGlzLm1pbikpIDogdGhpcy5taW4sXG4gICAgICAgICAgbWF4OiBhID8geSh0aGlzLmxpbjJsb2codGhpcy5tYXgpKSA6IHRoaXMubWF4LFxuICAgICAgICAgIGRhdGFNaW46IHRoaXMuZGF0YU1pbixcbiAgICAgICAgICBkYXRhTWF4OiB0aGlzLmRhdGFNYXgsXG4gICAgICAgICAgdXNlck1pbjogdGhpcy51c2VyTWluLFxuICAgICAgICAgIHVzZXJNYXg6IHRoaXMudXNlck1heFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGdldFRocmVzaG9sZDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmlzTG9nLFxuICAgICAgICAgICAgYyA9IGIgPyB0aGlzLmxpbjJsb2codGhpcy5taW4pIDogdGhpcy5taW47XG4gICAgICAgIGIgPSBiID8gdGhpcy5saW4ybG9nKHRoaXMubWF4KSA6IHRoaXMubWF4O1xuICAgICAgICBudWxsID09PSBhIHx8IC1JbmZpbml0eSA9PT0gYSA/IGEgPSBjIDogSW5maW5pdHkgPT09IGEgPyBhID0gYiA6IGMgPiBhID8gYSA9IGMgOiBiIDwgYSAmJiAoYSA9IGIpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGUoYSwgMCwgMSwgMCwgMSk7XG4gICAgICB9LFxuICAgICAgYXV0b0xhYmVsQWxpZ246IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBiID0gKHooYSwgMCkgLSA5MCAqIHRoaXMuc2lkZSArIDcyMCkgJSAzNjA7XG4gICAgICAgIGEgPSB7XG4gICAgICAgICAgYWxpZ246IFwiY2VudGVyXCJcbiAgICAgICAgfTtcbiAgICAgICAgcSh0aGlzLCBcImF1dG9MYWJlbEFsaWduXCIsIGEsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgMTUgPCBiICYmIDE2NSA+IGIgPyBhLmFsaWduID0gXCJyaWdodFwiIDogMTk1IDwgYiAmJiAzNDUgPiBiICYmIChhLmFsaWduID0gXCJsZWZ0XCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGEuYWxpZ247XG4gICAgICB9LFxuICAgICAgdGlja1NpemU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgYyA9IGJbYSArIFwiTGVuZ3RoXCJdLFxuICAgICAgICAgICAgZiA9IHooYlthICsgXCJXaWR0aFwiXSwgXCJ0aWNrXCIgPT09IGEgJiYgdGhpcy5pc1hBeGlzICYmICF0aGlzLmNhdGVnb3JpZXMgPyAxIDogMCk7XG5cbiAgICAgICAgaWYgKGYgJiYgYykge1xuICAgICAgICAgIFwiaW5zaWRlXCIgPT09IGJbYSArIFwiUG9zaXRpb25cIl0gJiYgKGMgPSAtYyk7XG4gICAgICAgICAgdmFyIGUgPSBbYywgZl07XG4gICAgICAgIH1cblxuICAgICAgICBhID0ge1xuICAgICAgICAgIHRpY2tTaXplOiBlXG4gICAgICAgIH07XG4gICAgICAgIHEodGhpcywgXCJhZnRlclRpY2tTaXplXCIsIGEpO1xuICAgICAgICByZXR1cm4gYS50aWNrU2l6ZTtcbiAgICAgIH0sXG4gICAgICBsYWJlbE1ldHJpY3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLnRpY2tQb3NpdGlvbnMgJiYgdGhpcy50aWNrUG9zaXRpb25zWzBdIHx8IDA7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYXJ0LnJlbmRlcmVyLmZvbnRNZXRyaWNzKHRoaXMub3B0aW9ucy5sYWJlbHMuc3R5bGUgJiYgdGhpcy5vcHRpb25zLmxhYmVscy5zdHlsZS5mb250U2l6ZSwgdGhpcy50aWNrc1thXSAmJiB0aGlzLnRpY2tzW2FdLmxhYmVsKTtcbiAgICAgIH0sXG4gICAgICB1bnNxdWlzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMub3B0aW9ucy5sYWJlbHMsXG4gICAgICAgICAgICBiID0gdGhpcy5ob3JpeixcbiAgICAgICAgICAgIGMgPSB0aGlzLnRpY2tJbnRlcnZhbCxcbiAgICAgICAgICAgIGYgPSBjLFxuICAgICAgICAgICAgZSA9IHRoaXMubGVuIC8gKCgodGhpcy5jYXRlZ29yaWVzID8gMSA6IDApICsgdGhpcy5tYXggLSB0aGlzLm1pbikgLyBjKSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBrID0gYS5yb3RhdGlvbixcbiAgICAgICAgICAgIHYgPSB0aGlzLmxhYmVsTWV0cmljcygpLFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIGQgPSBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgbixcbiAgICAgICAgICAgIHcgPSB0aGlzLm1heCAtIHRoaXMubWluLFxuICAgICAgICAgICAgRiA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgdmFyIGEgPSBiIC8gKGUgfHwgMSk7XG4gICAgICAgICAgYSA9IDEgPCBhID8gTWF0aC5jZWlsKGEpIDogMTtcbiAgICAgICAgICBhICogYyA+IHcgJiYgSW5maW5pdHkgIT09IGIgJiYgSW5maW5pdHkgIT09IGUgJiYgdyAmJiAoYSA9IE1hdGguY2VpbCh3IC8gYykpO1xuICAgICAgICAgIHJldHVybiB5KGEgKiBjKTtcbiAgICAgICAgfTtcblxuICAgICAgICBiID8gKG4gPSAhYS5zdGFnZ2VyTGluZXMgJiYgIWEuc3RlcCAmJiAodChrKSA/IFtrXSA6IGUgPCB6KGEuYXV0b1JvdGF0aW9uTGltaXQsIDgwKSAmJiBhLmF1dG9Sb3RhdGlvbikpICYmIG4uZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGlmIChiID09PSBrIHx8IGIgJiYgLTkwIDw9IGIgJiYgOTAgPj0gYikge1xuICAgICAgICAgICAgbSA9IEYoTWF0aC5hYnModi5oIC8gTWF0aC5zaW4oSyAqIGIpKSk7XG4gICAgICAgICAgICB2YXIgYSA9IG0gKyBNYXRoLmFicyhiIC8gMzYwKTtcbiAgICAgICAgICAgIGEgPCBkICYmIChkID0gYSwgbCA9IGIsIGYgPSBtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pIDogYS5zdGVwIHx8IChmID0gRih2LmgpKTtcbiAgICAgICAgdGhpcy5hdXRvUm90YXRpb24gPSBuO1xuICAgICAgICB0aGlzLmxhYmVsUm90YXRpb24gPSB6KGwsIGspO1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH0sXG4gICAgICBnZXRTbG90V2lkdGg6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGMgPSB0aGlzLmhvcml6LFxuICAgICAgICAgICAgZiA9IHRoaXMub3B0aW9ucy5sYWJlbHMsXG4gICAgICAgICAgICBlID0gTWF0aC5tYXgodGhpcy50aWNrUG9zaXRpb25zLmxlbmd0aCAtICh0aGlzLmNhdGVnb3JpZXMgPyAwIDogMSksIDEpLFxuICAgICAgICAgICAgbCA9IGIubWFyZ2luWzNdO1xuICAgICAgICByZXR1cm4gYSAmJiBhLnNsb3RXaWR0aCB8fCBjICYmIDIgPiAoZi5zdGVwIHx8IDApICYmICFmLnJvdGF0aW9uICYmICh0aGlzLnN0YWdnZXJMaW5lcyB8fCAxKSAqIHRoaXMubGVuIC8gZSB8fCAhYyAmJiAoZi5zdHlsZSAmJiBwYXJzZUludChmLnN0eWxlLndpZHRoLCAxMCkgfHwgbCAmJiBsIC0gYi5zcGFjaW5nWzNdIHx8IC4zMyAqIGIuY2hhcnRXaWR0aCk7XG4gICAgICB9LFxuICAgICAgcmVuZGVyVW5zcXVpc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgYiA9IGEucmVuZGVyZXIsXG4gICAgICAgICAgICBjID0gdGhpcy50aWNrUG9zaXRpb25zLFxuICAgICAgICAgICAgZSA9IHRoaXMudGlja3MsXG4gICAgICAgICAgICBsID0gdGhpcy5vcHRpb25zLmxhYmVscyxcbiAgICAgICAgICAgIGsgPSBsICYmIGwuc3R5bGUgfHwge30sXG4gICAgICAgICAgICB2ID0gdGhpcy5ob3JpeixcbiAgICAgICAgICAgIGQgPSB0aGlzLmdldFNsb3RXaWR0aCgpLFxuICAgICAgICAgICAgbSA9IE1hdGgubWF4KDEsIE1hdGgucm91bmQoZCAtIDIgKiAobC5wYWRkaW5nIHx8IDUpKSksXG4gICAgICAgICAgICBuID0ge30sXG4gICAgICAgICAgICB3ID0gdGhpcy5sYWJlbE1ldHJpY3MoKSxcbiAgICAgICAgICAgIGggPSBsLnN0eWxlICYmIGwuc3R5bGUudGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgRiA9IDA7XG4gICAgICAgIGYobC5yb3RhdGlvbikgfHwgKG4ucm90YXRpb24gPSBsLnJvdGF0aW9uIHx8IDApO1xuICAgICAgICBjLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBiID0gZVtiXTtcbiAgICAgICAgICBiLm1vdmVkTGFiZWwgJiYgYi5yZXBsYWNlTW92ZWRMYWJlbCgpO1xuICAgICAgICAgIGIgJiYgYi5sYWJlbCAmJiBiLmxhYmVsLnRleHRQeExlbmd0aCA+IEYgJiYgKEYgPSBiLmxhYmVsLnRleHRQeExlbmd0aCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1heExhYmVsTGVuZ3RoID0gRjtcbiAgICAgICAgaWYgKHRoaXMuYXV0b1JvdGF0aW9uKSBGID4gbSAmJiBGID4gdy5oID8gbi5yb3RhdGlvbiA9IHRoaXMubGFiZWxSb3RhdGlvbiA6IHRoaXMubGFiZWxSb3RhdGlvbiA9IDA7ZWxzZSBpZiAoZCkge1xuICAgICAgICAgIHZhciB6ID0gbTtcblxuICAgICAgICAgIGlmICghaCkge1xuICAgICAgICAgICAgdmFyIHEgPSBcImNsaXBcIjtcblxuICAgICAgICAgICAgZm9yIChtID0gYy5sZW5ndGg7ICF2ICYmIG0tLTspIHtcbiAgICAgICAgICAgICAgdmFyIEIgPSBjW21dO1xuICAgICAgICAgICAgICBpZiAoQiA9IGVbQl0ubGFiZWwpIEIuc3R5bGVzICYmIFwiZWxsaXBzaXNcIiA9PT0gQi5zdHlsZXMudGV4dE92ZXJmbG93ID8gQi5jc3Moe1xuICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogXCJjbGlwXCJcbiAgICAgICAgICAgICAgfSkgOiBCLnRleHRQeExlbmd0aCA+IGQgJiYgQi5jc3Moe1xuICAgICAgICAgICAgICAgIHdpZHRoOiBkICsgXCJweFwiXG4gICAgICAgICAgICAgIH0pLCBCLmdldEJCb3goKS5oZWlnaHQgPiB0aGlzLmxlbiAvIGMubGVuZ3RoIC0gKHcuaCAtIHcuZikgJiYgKEIuc3BlY2lmaWNUZXh0T3ZlcmZsb3cgPSBcImVsbGlwc2lzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuLnJvdGF0aW9uICYmICh6ID0gRiA+IC41ICogYS5jaGFydEhlaWdodCA/IC4zMyAqIGEuY2hhcnRIZWlnaHQgOiBGLCBoIHx8IChxID0gXCJlbGxpcHNpc1wiKSk7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsQWxpZ24gPSBsLmFsaWduIHx8IHRoaXMuYXV0b0xhYmVsQWxpZ24odGhpcy5sYWJlbFJvdGF0aW9uKSkgbi5hbGlnbiA9IHRoaXMubGFiZWxBbGlnbjtcbiAgICAgICAgYy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgdmFyIGEgPSAoYiA9IGVbYl0pICYmIGIubGFiZWwsXG4gICAgICAgICAgICAgIGMgPSBrLndpZHRoLFxuICAgICAgICAgICAgICBmID0ge307XG4gICAgICAgICAgYSAmJiAoYS5hdHRyKG4pLCBiLnNob3J0ZW5MYWJlbCA/IGIuc2hvcnRlbkxhYmVsKCkgOiB6ICYmICFjICYmIFwibm93cmFwXCIgIT09IGsud2hpdGVTcGFjZSAmJiAoeiA8IGEudGV4dFB4TGVuZ3RoIHx8IFwiU1BBTlwiID09PSBhLmVsZW1lbnQudGFnTmFtZSkgPyAoZi53aWR0aCA9IHosIGggfHwgKGYudGV4dE92ZXJmbG93ID0gYS5zcGVjaWZpY1RleHRPdmVyZmxvdyB8fCBxKSwgYS5jc3MoZikpIDogYS5zdHlsZXMgJiYgYS5zdHlsZXMud2lkdGggJiYgIWYud2lkdGggJiYgIWMgJiYgYS5jc3Moe1xuICAgICAgICAgICAgd2lkdGg6IG51bGxcbiAgICAgICAgICB9KSwgZGVsZXRlIGEuc3BlY2lmaWNUZXh0T3ZlcmZsb3csIGIucm90YXRpb24gPSBuLnJvdGF0aW9uKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMudGlja1JvdENvcnIgPSBiLnJvdENvcnIody5iLCB0aGlzLmxhYmVsUm90YXRpb24gfHwgMCwgMCAhPT0gdGhpcy5zaWRlKTtcbiAgICAgIH0sXG4gICAgICBoYXNEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcmllcy5zb21lKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgcmV0dXJuIGEuaGFzRGF0YSgpO1xuICAgICAgICB9KSB8fCB0aGlzLm9wdGlvbnMuc2hvd0VtcHR5ICYmIHQodGhpcy5taW4pICYmIHQodGhpcy5tYXgpO1xuICAgICAgfSxcbiAgICAgIGFkZFRpdGxlOiBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgYiA9IHRoaXMuY2hhcnQucmVuZGVyZXIsXG4gICAgICAgICAgICBmID0gdGhpcy5ob3JpeixcbiAgICAgICAgICAgIGUgPSB0aGlzLm9wcG9zaXRlLFxuICAgICAgICAgICAgbCA9IHRoaXMub3B0aW9ucy50aXRsZSxcbiAgICAgICAgICAgIHAsXG4gICAgICAgICAgICBrID0gdGhpcy5jaGFydC5zdHlsZWRNb2RlO1xuICAgICAgICB0aGlzLmF4aXNUaXRsZSB8fCAoKHAgPSBsLnRleHRBbGlnbikgfHwgKHAgPSAoZiA/IHtcbiAgICAgICAgICBsb3c6IFwibGVmdFwiLFxuICAgICAgICAgIG1pZGRsZTogXCJjZW50ZXJcIixcbiAgICAgICAgICBoaWdoOiBcInJpZ2h0XCJcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBsb3c6IGUgPyBcInJpZ2h0XCIgOiBcImxlZnRcIixcbiAgICAgICAgICBtaWRkbGU6IFwiY2VudGVyXCIsXG4gICAgICAgICAgaGlnaDogZSA/IFwibGVmdFwiIDogXCJyaWdodFwiXG4gICAgICAgIH0pW2wuYWxpZ25dKSwgdGhpcy5heGlzVGl0bGUgPSBiLnRleHQobC50ZXh0LCAwLCAwLCBsLnVzZUhUTUwpLmF0dHIoe1xuICAgICAgICAgIHpJbmRleDogNyxcbiAgICAgICAgICByb3RhdGlvbjogbC5yb3RhdGlvbiB8fCAwLFxuICAgICAgICAgIGFsaWduOiBwXG4gICAgICAgIH0pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1heGlzLXRpdGxlXCIpLCBrIHx8IHRoaXMuYXhpc1RpdGxlLmNzcyhhKGwuc3R5bGUpKSwgdGhpcy5heGlzVGl0bGUuYWRkKHRoaXMuYXhpc0dyb3VwKSwgdGhpcy5heGlzVGl0bGUuaXNOZXcgPSAhMCk7XG4gICAgICAgIGsgfHwgbC5zdHlsZS53aWR0aCB8fCB0aGlzLmlzUmFkaWFsIHx8IHRoaXMuYXhpc1RpdGxlLmNzcyh7XG4gICAgICAgICAgd2lkdGg6IHRoaXMubGVuXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmF4aXNUaXRsZVtjID8gXCJzaG93XCIgOiBcImhpZGVcIl0oYyk7XG4gICAgICB9LFxuICAgICAgZ2VuZXJhdGVUaWNrOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYiA9IHRoaXMudGlja3M7XG4gICAgICAgIGJbYV0gPyBiW2FdLmFkZExhYmVsKCkgOiBiW2FdID0gbmV3IHIodGhpcywgYSk7XG4gICAgICB9LFxuICAgICAgZ2V0T2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIGIgPSBhLmNoYXJ0LFxuICAgICAgICAgICAgYyA9IGIucmVuZGVyZXIsXG4gICAgICAgICAgICBmID0gYS5vcHRpb25zLFxuICAgICAgICAgICAgZSA9IGEudGlja1Bvc2l0aW9ucyxcbiAgICAgICAgICAgIGwgPSBhLnRpY2tzLFxuICAgICAgICAgICAgayA9IGEuaG9yaXosXG4gICAgICAgICAgICBkID0gYS5zaWRlLFxuICAgICAgICAgICAgbSA9IGIuaW52ZXJ0ZWQgJiYgIWEuaXNaQXhpcyA/IFsxLCAwLCAzLCAyXVtkXSA6IGQsXG4gICAgICAgICAgICBuLFxuICAgICAgICAgICAgdyA9IDAsXG4gICAgICAgICAgICBoID0gMCxcbiAgICAgICAgICAgIEYgPSBmLnRpdGxlLFxuICAgICAgICAgICAgQiA9IGYubGFiZWxzLFxuICAgICAgICAgICAgTCA9IDAsXG4gICAgICAgICAgICBnID0gYi5heGlzT2Zmc2V0O1xuICAgICAgICBiID0gYi5jbGlwT2Zmc2V0O1xuICAgICAgICB2YXIgSCA9IFstMSwgMSwgMSwgLTFdW2RdLFxuICAgICAgICAgICAgSyA9IGYuY2xhc3NOYW1lLFxuICAgICAgICAgICAgUSA9IGEuYXhpc1BhcmVudDtcbiAgICAgICAgdmFyIHkgPSBhLmhhc0RhdGEoKTtcbiAgICAgICAgYS5zaG93QXhpcyA9IG4gPSB5IHx8IHooZi5zaG93RW1wdHksICEwKTtcbiAgICAgICAgYS5zdGFnZ2VyTGluZXMgPSBhLmhvcml6ICYmIEIuc3RhZ2dlckxpbmVzO1xuICAgICAgICBhLmF4aXNHcm91cCB8fCAoYS5ncmlkR3JvdXAgPSBjLmcoXCJncmlkXCIpLmF0dHIoe1xuICAgICAgICAgIHpJbmRleDogZi5ncmlkWkluZGV4IHx8IDFcbiAgICAgICAgfSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLVwiICsgdGhpcy5jb2xsLnRvTG93ZXJDYXNlKCkgKyBcIi1ncmlkIFwiICsgKEsgfHwgXCJcIikpLmFkZChRKSwgYS5heGlzR3JvdXAgPSBjLmcoXCJheGlzXCIpLmF0dHIoe1xuICAgICAgICAgIHpJbmRleDogZi56SW5kZXggfHwgMlxuICAgICAgICB9KS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtXCIgKyB0aGlzLmNvbGwudG9Mb3dlckNhc2UoKSArIFwiIFwiICsgKEsgfHwgXCJcIikpLmFkZChRKSwgYS5sYWJlbEdyb3VwID0gYy5nKFwiYXhpcy1sYWJlbHNcIikuYXR0cih7XG4gICAgICAgICAgekluZGV4OiBCLnpJbmRleCB8fCA3XG4gICAgICAgIH0pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIiArIGEuY29sbC50b0xvd2VyQ2FzZSgpICsgXCItbGFiZWxzIFwiICsgKEsgfHwgXCJcIikpLmFkZChRKSk7XG4gICAgICAgIHkgfHwgYS5pc0xpbmtlZCA/IChlLmZvckVhY2goZnVuY3Rpb24gKGIsIGMpIHtcbiAgICAgICAgICBhLmdlbmVyYXRlVGljayhiLCBjKTtcbiAgICAgICAgfSksIGEucmVuZGVyVW5zcXVpc2goKSwgYS5yZXNlcnZlU3BhY2VEZWZhdWx0ID0gMCA9PT0gZCB8fCAyID09PSBkIHx8IHtcbiAgICAgICAgICAxOiBcImxlZnRcIixcbiAgICAgICAgICAzOiBcInJpZ2h0XCJcbiAgICAgICAgfVtkXSA9PT0gYS5sYWJlbEFsaWduLCB6KEIucmVzZXJ2ZVNwYWNlLCBcImNlbnRlclwiID09PSBhLmxhYmVsQWxpZ24gPyAhMCA6IG51bGwsIGEucmVzZXJ2ZVNwYWNlRGVmYXVsdCkgJiYgZS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgTCA9IE1hdGgubWF4KGxbYl0uZ2V0TGFiZWxTaXplKCksIEwpO1xuICAgICAgICB9KSwgYS5zdGFnZ2VyTGluZXMgJiYgKEwgKj0gYS5zdGFnZ2VyTGluZXMpLCBhLmxhYmVsT2Zmc2V0ID0gTCAqIChhLm9wcG9zaXRlID8gLTEgOiAxKSkgOiB2KGwsIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgYi5kZXN0cm95KCk7XG4gICAgICAgICAgZGVsZXRlIGxbYV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChGICYmIEYudGV4dCAmJiAhMSAhPT0gRi5lbmFibGVkICYmIChhLmFkZFRpdGxlKG4pLCBuICYmICExICE9PSBGLnJlc2VydmVTcGFjZSkpIHtcbiAgICAgICAgICBhLnRpdGxlT2Zmc2V0ID0gdyA9IGEuYXhpc1RpdGxlLmdldEJCb3goKVtrID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIl07XG4gICAgICAgICAgdmFyIHUgPSBGLm9mZnNldDtcbiAgICAgICAgICBoID0gdCh1KSA/IDAgOiB6KEYubWFyZ2luLCBrID8gNSA6IDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGEucmVuZGVyTGluZSgpO1xuICAgICAgICBhLm9mZnNldCA9IEggKiB6KGYub2Zmc2V0LCBnW2RdID8gZ1tkXSArIChmLm1hcmdpbiB8fCAwKSA6IDApO1xuICAgICAgICBhLnRpY2tSb3RDb3JyID0gYS50aWNrUm90Q29yciB8fCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIGMgPSAwID09PSBkID8gLWEubGFiZWxNZXRyaWNzKCkuaCA6IDIgPT09IGQgPyBhLnRpY2tSb3RDb3JyLnkgOiAwO1xuICAgICAgICBoID0gTWF0aC5hYnMoTCkgKyBoO1xuICAgICAgICBMICYmIChoID0gaCAtIGMgKyBIICogKGsgPyB6KEIueSwgYS50aWNrUm90Q29yci55ICsgOCAqIEgpIDogQi54KSk7XG4gICAgICAgIGEuYXhpc1RpdGxlTWFyZ2luID0geih1LCBoKTtcbiAgICAgICAgYS5nZXRNYXhMYWJlbERpbWVuc2lvbnMgJiYgKGEubWF4TGFiZWxEaW1lbnNpb25zID0gYS5nZXRNYXhMYWJlbERpbWVuc2lvbnMobCwgZSkpO1xuICAgICAgICBrID0gdGhpcy50aWNrU2l6ZShcInRpY2tcIik7XG4gICAgICAgIGdbZF0gPSBNYXRoLm1heChnW2RdLCBhLmF4aXNUaXRsZU1hcmdpbiArIHcgKyBIICogYS5vZmZzZXQsIGgsIGUgJiYgZS5sZW5ndGggJiYgayA/IGtbMF0gKyBIICogYS5vZmZzZXQgOiAwKTtcbiAgICAgICAgZiA9IGYub2Zmc2V0ID8gMCA6IDIgKiBNYXRoLmZsb29yKGEuYXhpc0xpbmUuc3Ryb2tlV2lkdGgoKSAvIDIpO1xuICAgICAgICBiW21dID0gTWF0aC5tYXgoYlttXSwgZik7XG4gICAgICAgIHEodGhpcywgXCJhZnRlckdldE9mZnNldFwiKTtcbiAgICAgIH0sXG4gICAgICBnZXRMaW5lUGF0aDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgYyA9IHRoaXMub3Bwb3NpdGUsXG4gICAgICAgICAgICBmID0gdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICBlID0gdGhpcy5ob3JpeixcbiAgICAgICAgICAgIGwgPSB0aGlzLmxlZnQgKyAoYyA/IHRoaXMud2lkdGggOiAwKSArIGY7XG4gICAgICAgIGYgPSBiLmNoYXJ0SGVpZ2h0IC0gdGhpcy5ib3R0b20gLSAoYyA/IHRoaXMuaGVpZ2h0IDogMCkgKyBmO1xuICAgICAgICBjICYmIChhICo9IC0xKTtcbiAgICAgICAgcmV0dXJuIGIucmVuZGVyZXIuY3Jpc3BMaW5lKFtcIk1cIiwgZSA/IHRoaXMubGVmdCA6IGwsIGUgPyBmIDogdGhpcy50b3AsIFwiTFwiLCBlID8gYi5jaGFydFdpZHRoIC0gdGhpcy5yaWdodCA6IGwsIGUgPyBmIDogYi5jaGFydEhlaWdodCAtIHRoaXMuYm90dG9tXSwgYSk7XG4gICAgICB9LFxuICAgICAgcmVuZGVyTGluZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmF4aXNMaW5lIHx8ICh0aGlzLmF4aXNMaW5lID0gdGhpcy5jaGFydC5yZW5kZXJlci5wYXRoKCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWF4aXMtbGluZVwiKS5hZGQodGhpcy5heGlzR3JvdXApLCB0aGlzLmNoYXJ0LnN0eWxlZE1vZGUgfHwgdGhpcy5heGlzTGluZS5hdHRyKHtcbiAgICAgICAgICBzdHJva2U6IHRoaXMub3B0aW9ucy5saW5lQ29sb3IsXG4gICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogdGhpcy5vcHRpb25zLmxpbmVXaWR0aCxcbiAgICAgICAgICB6SW5kZXg6IDdcbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIGdldFRpdGxlUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmhvcml6LFxuICAgICAgICAgICAgYiA9IHRoaXMubGVmdCxcbiAgICAgICAgICAgIGMgPSB0aGlzLnRvcCxcbiAgICAgICAgICAgIGYgPSB0aGlzLmxlbixcbiAgICAgICAgICAgIGUgPSB0aGlzLm9wdGlvbnMudGl0bGUsXG4gICAgICAgICAgICBsID0gYSA/IGIgOiBjLFxuICAgICAgICAgICAgayA9IHRoaXMub3Bwb3NpdGUsXG4gICAgICAgICAgICBkID0gdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICBtID0gZS54IHx8IDAsXG4gICAgICAgICAgICB2ID0gZS55IHx8IDAsXG4gICAgICAgICAgICBuID0gdGhpcy5heGlzVGl0bGUsXG4gICAgICAgICAgICB3ID0gdGhpcy5jaGFydC5yZW5kZXJlci5mb250TWV0cmljcyhlLnN0eWxlICYmIGUuc3R5bGUuZm9udFNpemUsIG4pO1xuICAgICAgICBuID0gTWF0aC5tYXgobi5nZXRCQm94KG51bGwsIDApLmhlaWdodCAtIHcuaCAtIDEsIDApO1xuICAgICAgICBmID0ge1xuICAgICAgICAgIGxvdzogbCArIChhID8gMCA6IGYpLFxuICAgICAgICAgIG1pZGRsZTogbCArIGYgLyAyLFxuICAgICAgICAgIGhpZ2g6IGwgKyAoYSA/IGYgOiAwKVxuICAgICAgICB9W2UuYWxpZ25dO1xuICAgICAgICBiID0gKGEgPyBjICsgdGhpcy5oZWlnaHQgOiBiKSArIChhID8gMSA6IC0xKSAqIChrID8gLTEgOiAxKSAqIHRoaXMuYXhpc1RpdGxlTWFyZ2luICsgWy1uLCBuLCB3LmYsIC1uXVt0aGlzLnNpZGVdO1xuICAgICAgICBhID0ge1xuICAgICAgICAgIHg6IGEgPyBmICsgbSA6IGIgKyAoayA/IHRoaXMud2lkdGggOiAwKSArIGQgKyBtLFxuICAgICAgICAgIHk6IGEgPyBiICsgdiAtIChrID8gdGhpcy5oZWlnaHQgOiAwKSArIGQgOiBmICsgdlxuICAgICAgICB9O1xuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJHZXRUaXRsZVBvc2l0aW9uXCIsIHtcbiAgICAgICAgICB0aXRsZVBvc2l0aW9uOiBhXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sXG4gICAgICByZW5kZXJNaW5vclRpY2s6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5jaGFydC5oYXNSZW5kZXJlZCAmJiBuKHRoaXMub2xkTWluKSxcbiAgICAgICAgICAgIGMgPSB0aGlzLm1pbm9yVGlja3M7XG4gICAgICAgIGNbYV0gfHwgKGNbYV0gPSBuZXcgcih0aGlzLCBhLCBcIm1pbm9yXCIpKTtcbiAgICAgICAgYiAmJiBjW2FdLmlzTmV3ICYmIGNbYV0ucmVuZGVyKG51bGwsICEwKTtcbiAgICAgICAgY1thXS5yZW5kZXIobnVsbCwgITEsIDEpO1xuICAgICAgfSxcbiAgICAgIHJlbmRlclRpY2s6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5pc0xpbmtlZCxcbiAgICAgICAgICAgIGYgPSB0aGlzLnRpY2tzLFxuICAgICAgICAgICAgZSA9IHRoaXMuY2hhcnQuaGFzUmVuZGVyZWQgJiYgbih0aGlzLm9sZE1pbik7XG4gICAgICAgIGlmICghYyB8fCBhID49IHRoaXMubWluICYmIGEgPD0gdGhpcy5tYXgpIGZbYV0gfHwgKGZbYV0gPSBuZXcgcih0aGlzLCBhKSksIGUgJiYgZlthXS5pc05ldyAmJiBmW2FdLnJlbmRlcihiLCAhMCwgLTEpLCBmW2FdLnJlbmRlcihiKTtcbiAgICAgIH0sXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgYiA9IGEuY2hhcnQsXG4gICAgICAgICAgICBjID0gYS5vcHRpb25zLFxuICAgICAgICAgICAgZiA9IGEuaXNMb2csXG4gICAgICAgICAgICBlID0gYS5pc0xpbmtlZCxcbiAgICAgICAgICAgIGwgPSBhLnRpY2tQb3NpdGlvbnMsXG4gICAgICAgICAgICBrID0gYS5heGlzVGl0bGUsXG4gICAgICAgICAgICB3ID0gYS50aWNrcyxcbiAgICAgICAgICAgIG0gPSBhLm1pbm9yVGlja3MsXG4gICAgICAgICAgICBoID0gYS5hbHRlcm5hdGVCYW5kcyxcbiAgICAgICAgICAgIHogPSBjLnN0YWNrTGFiZWxzLFxuICAgICAgICAgICAgQiA9IGMuYWx0ZXJuYXRlR3JpZENvbG9yLFxuICAgICAgICAgICAgRiA9IGEudGlja21hcmtPZmZzZXQsXG4gICAgICAgICAgICBMID0gYS5heGlzTGluZSxcbiAgICAgICAgICAgIHQgPSBhLnNob3dBeGlzLFxuICAgICAgICAgICAgZyA9IEUoYi5yZW5kZXJlci5nbG9iYWxBbmltYXRpb24pLFxuICAgICAgICAgICAgSCxcbiAgICAgICAgICAgIEs7XG4gICAgICAgIGEubGFiZWxFZGdlLmxlbmd0aCA9IDA7XG4gICAgICAgIGEub3ZlcmxhcCA9ICExO1xuICAgICAgICBbdywgbSwgaF0uZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHYoYiwgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIGIuaXNBY3RpdmUgPSAhMTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhLmhhc0RhdGEoKSB8fCBlKSBhLm1pbm9yVGlja0ludGVydmFsICYmICFhLmNhdGVnb3JpZXMgJiYgYS5nZXRNaW5vclRpY2tQb3NpdGlvbnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYS5yZW5kZXJNaW5vclRpY2soYik7XG4gICAgICAgIH0pLCBsLmxlbmd0aCAmJiAobC5mb3JFYWNoKGZ1bmN0aW9uIChiLCBjKSB7XG4gICAgICAgICAgYS5yZW5kZXJUaWNrKGIsIGMpO1xuICAgICAgICB9KSwgRiAmJiAoMCA9PT0gYS5taW4gfHwgYS5zaW5nbGUpICYmICh3Wy0xXSB8fCAod1stMV0gPSBuZXcgcihhLCAtMSwgbnVsbCwgITApKSwgd1stMV0ucmVuZGVyKC0xKSkpLCBCICYmIGwuZm9yRWFjaChmdW5jdGlvbiAoYywgZSkge1xuICAgICAgICAgIEsgPSBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgbFtlICsgMV0gPyBsW2UgKyAxXSArIEYgOiBhLm1heCAtIEY7XG4gICAgICAgICAgMCA9PT0gZSAlIDIgJiYgYyA8IGEubWF4ICYmIEsgPD0gYS5tYXggKyAoYi5wb2xhciA/IC1GIDogRikgJiYgKGhbY10gfHwgKGhbY10gPSBuZXcgZC5QbG90TGluZU9yQmFuZChhKSksIEggPSBjICsgRiwgaFtjXS5vcHRpb25zID0ge1xuICAgICAgICAgICAgZnJvbTogZiA/IGEubGluMmxvZyhIKSA6IEgsXG4gICAgICAgICAgICB0bzogZiA/IGEubGluMmxvZyhLKSA6IEssXG4gICAgICAgICAgICBjb2xvcjogQlxuICAgICAgICAgIH0sIGhbY10ucmVuZGVyKCksIGhbY10uaXNBY3RpdmUgPSAhMCk7XG4gICAgICAgIH0pLCBhLl9hZGRlZFBsb3RMQiB8fCAoKGMucGxvdExpbmVzIHx8IFtdKS5jb25jYXQoYy5wbG90QmFuZHMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBhLmFkZFBsb3RCYW5kT3JMaW5lKGIpO1xuICAgICAgICB9KSwgYS5fYWRkZWRQbG90TEIgPSAhMCk7XG4gICAgICAgIFt3LCBtLCBoXS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgdmFyIGMsXG4gICAgICAgICAgICAgIGYgPSBbXSxcbiAgICAgICAgICAgICAgZSA9IGcuZHVyYXRpb247XG4gICAgICAgICAgdihhLCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgICAgYi5pc0FjdGl2ZSB8fCAoYi5yZW5kZXIoYSwgITEsIDApLCBiLmlzQWN0aXZlID0gITEsIGYucHVzaChhKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgUShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKGMgPSBmLmxlbmd0aDsgYy0tOykgYVtmW2NdXSAmJiAhYVtmW2NdXS5pc0FjdGl2ZSAmJiAoYVtmW2NdXS5kZXN0cm95KCksIGRlbGV0ZSBhW2ZbY11dKTtcbiAgICAgICAgICB9LCBhICE9PSBoICYmIGIuaGFzUmVuZGVyZWQgJiYgZSA/IGUgOiAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIEwgJiYgKExbTC5pc1BsYWNlZCA/IFwiYW5pbWF0ZVwiIDogXCJhdHRyXCJdKHtcbiAgICAgICAgICBkOiB0aGlzLmdldExpbmVQYXRoKEwuc3Ryb2tlV2lkdGgoKSlcbiAgICAgICAgfSksIEwuaXNQbGFjZWQgPSAhMCwgTFt0ID8gXCJzaG93XCIgOiBcImhpZGVcIl0odCkpO1xuICAgICAgICBrICYmIHQgJiYgKGMgPSBhLmdldFRpdGxlUG9zaXRpb24oKSwgbihjLnkpID8gKGtbay5pc05ldyA/IFwiYXR0clwiIDogXCJhbmltYXRlXCJdKGMpLCBrLmlzTmV3ID0gITEpIDogKGsuYXR0cihcInlcIiwgLTk5OTkpLCBrLmlzTmV3ID0gITApKTtcbiAgICAgICAgeiAmJiB6LmVuYWJsZWQgJiYgYS5yZW5kZXJTdGFja1RvdGFscygpO1xuICAgICAgICBhLmlzRGlydHkgPSAhMTtcbiAgICAgICAgcSh0aGlzLCBcImFmdGVyUmVuZGVyXCIpO1xuICAgICAgfSxcbiAgICAgIHJlZHJhdzogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpc2libGUgJiYgKHRoaXMucmVuZGVyKCksIHRoaXMucGxvdExpbmVzQW5kQmFuZHMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEucmVuZGVyKCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEuaXNEaXJ0eSA9ICEwO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBrZWVwUHJvcHM6IFwiZXh0S2V5IGhjRXZlbnRzIG5hbWVzIHNlcmllcyB1c2VyTWF4IHVzZXJNaW5cIi5zcGxpdChcIiBcIiksXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgICAgICBjID0gYi5zdGFja3MsXG4gICAgICAgICAgICBmID0gYi5wbG90TGluZXNBbmRCYW5kcyxcbiAgICAgICAgICAgIGU7XG4gICAgICAgIHEodGhpcywgXCJkZXN0cm95XCIsIHtcbiAgICAgICAgICBrZWVwRXZlbnRzOiBhXG4gICAgICAgIH0pO1xuICAgICAgICBhIHx8IEIoYik7XG4gICAgICAgIHYoYywgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBEKGIpO1xuICAgICAgICAgIGNbYV0gPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgW2IudGlja3MsIGIubWlub3JUaWNrcywgYi5hbHRlcm5hdGVCYW5kc10uZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIEQoYik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZikgZm9yIChhID0gZi5sZW5ndGg7IGEtLTspIGZbYV0uZGVzdHJveSgpO1xuICAgICAgICBcInN0YWNrVG90YWxHcm91cCBheGlzTGluZSBheGlzVGl0bGUgYXhpc0dyb3VwIGdyaWRHcm91cCBsYWJlbEdyb3VwIGNyb3NzIHNjcm9sbGJhclwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYlthXSAmJiAoYlthXSA9IGJbYV0uZGVzdHJveSgpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yIChlIGluIGIucGxvdExpbmVzQW5kQmFuZHNHcm91cHMpIGIucGxvdExpbmVzQW5kQmFuZHNHcm91cHNbZV0gPSBiLnBsb3RMaW5lc0FuZEJhbmRzR3JvdXBzW2VdLmRlc3Ryb3koKTtcblxuICAgICAgICB2KGIsIGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgICAgLTEgPT09IGIua2VlcFByb3BzLmluZGV4T2YoYykgJiYgZGVsZXRlIGJbY107XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGRyYXdDcm9zc2hhaXI6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5jcm9zc2hhaXIsXG4gICAgICAgICAgICBmID0geihjLnNuYXAsICEwKSxcbiAgICAgICAgICAgIGUsXG4gICAgICAgICAgICBsID0gdGhpcy5jcm9zcyxcbiAgICAgICAgICAgIGsgPSB0aGlzLmNoYXJ0O1xuICAgICAgICBxKHRoaXMsIFwiZHJhd0Nyb3NzaGFpclwiLCB7XG4gICAgICAgICAgZTogYSxcbiAgICAgICAgICBwb2ludDogYlxuICAgICAgICB9KTtcbiAgICAgICAgYSB8fCAoYSA9IHRoaXMuY3Jvc3MgJiYgdGhpcy5jcm9zcy5lKTtcblxuICAgICAgICBpZiAodGhpcy5jcm9zc2hhaXIgJiYgITEgIT09ICh0KGIpIHx8ICFmKSkge1xuICAgICAgICAgIGYgPyB0KGIpICYmIChlID0geihcImNvbG9yQXhpc1wiICE9PSB0aGlzLmNvbGwgPyBiLmNyb3NzaGFpclBvcyA6IG51bGwsIHRoaXMuaXNYQXhpcyA/IGIucGxvdFggOiB0aGlzLmxlbiAtIGIucGxvdFkpKSA6IGUgPSBhICYmICh0aGlzLmhvcml6ID8gYS5jaGFydFggLSB0aGlzLnBvcyA6IHRoaXMubGVuIC0gYS5jaGFydFkgKyB0aGlzLnBvcyk7XG5cbiAgICAgICAgICBpZiAodChlKSkge1xuICAgICAgICAgICAgdmFyIGQgPSB7XG4gICAgICAgICAgICAgIHZhbHVlOiBiICYmICh0aGlzLmlzWEF4aXMgPyBiLnggOiB6KGIuc3RhY2tZLCBiLnkpKSxcbiAgICAgICAgICAgICAgdHJhbnNsYXRlZFZhbHVlOiBlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgay5wb2xhciAmJiBOKGQsIHtcbiAgICAgICAgICAgICAgaXNDcm9zc2hhaXI6ICEwLFxuICAgICAgICAgICAgICBjaGFydFg6IGEgJiYgYS5jaGFydFgsXG4gICAgICAgICAgICAgIGNoYXJ0WTogYSAmJiBhLmNoYXJ0WSxcbiAgICAgICAgICAgICAgcG9pbnQ6IGJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZCA9IHRoaXMuZ2V0UGxvdExpbmVQYXRoKGQpIHx8IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0KGQpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVDcm9zc2hhaXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmID0gdGhpcy5jYXRlZ29yaWVzICYmICF0aGlzLmlzUmFkaWFsO1xuICAgICAgICAgIGwgfHwgKHRoaXMuY3Jvc3MgPSBsID0gay5yZW5kZXJlci5wYXRoKCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWNyb3NzaGFpciBoaWdoY2hhcnRzLWNyb3NzaGFpci1cIiArIChmID8gXCJjYXRlZ29yeSBcIiA6IFwidGhpbiBcIikgKyBjLmNsYXNzTmFtZSkuYXR0cih7XG4gICAgICAgICAgICB6SW5kZXg6IHooYy56SW5kZXgsIDIpXG4gICAgICAgICAgfSkuYWRkKCksIGsuc3R5bGVkTW9kZSB8fCAobC5hdHRyKHtcbiAgICAgICAgICAgIHN0cm9rZTogYy5jb2xvciB8fCAoZiA/IEkoXCIjY2NkNmViXCIpLnNldE9wYWNpdHkoLjI1KS5nZXQoKSA6IFwiI2NjY2NjY1wiKSxcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHooYy53aWR0aCwgMSlcbiAgICAgICAgICB9KS5jc3Moe1xuICAgICAgICAgICAgXCJwb2ludGVyLWV2ZW50c1wiOiBcIm5vbmVcIlxuICAgICAgICAgIH0pLCBjLmRhc2hTdHlsZSAmJiBsLmF0dHIoe1xuICAgICAgICAgICAgZGFzaHN0eWxlOiBjLmRhc2hTdHlsZVxuICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgbC5zaG93KCkuYXR0cih7XG4gICAgICAgICAgICBkOiBkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZiAmJiAhYy53aWR0aCAmJiBsLmF0dHIoe1xuICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogdGhpcy50cmFuc0FcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmNyb3NzLmUgPSBhO1xuICAgICAgICB9IGVsc2UgdGhpcy5oaWRlQ3Jvc3NoYWlyKCk7XG5cbiAgICAgICAgcSh0aGlzLCBcImFmdGVyRHJhd0Nyb3NzaGFpclwiLCB7XG4gICAgICAgICAgZTogYSxcbiAgICAgICAgICBwb2ludDogYlxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBoaWRlQ3Jvc3NoYWlyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY3Jvc3MgJiYgdGhpcy5jcm9zcy5oaWRlKCk7XG4gICAgICAgIHEodGhpcywgXCJhZnRlckhpZGVDcm9zc2hhaXJcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGQuQXhpcyA9IGc7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvRGF0ZVRpbWVBeGlzLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgdmFyIHIgPSBnLmdldE1hZ25pdHVkZSxcbiAgICAgICAgdSA9IGcubm9ybWFsaXplVGlja0ludGVydmFsLFxuICAgICAgICBJID0gZy50aW1lVW5pdHM7XG4gICAgZCA9IGQuQXhpcztcblxuICAgIGQucHJvdG90eXBlLmdldFRpbWVUaWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoYXJ0LnRpbWUuZ2V0VGltZVRpY2tzLmFwcGx5KHRoaXMuY2hhcnQudGltZSwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgZC5wcm90b3R5cGUubm9ybWFsaXplVGltZVRpY2tJbnRlcnZhbCA9IGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgICB2YXIgQSA9IGcgfHwgW1tcIm1pbGxpc2Vjb25kXCIsIFsxLCAyLCA1LCAxMCwgMjAsIDI1LCA1MCwgMTAwLCAyMDAsIDUwMF1dLCBbXCJzZWNvbmRcIiwgWzEsIDIsIDUsIDEwLCAxNSwgMzBdXSwgW1wibWludXRlXCIsIFsxLCAyLCA1LCAxMCwgMTUsIDMwXV0sIFtcImhvdXJcIiwgWzEsIDIsIDMsIDQsIDYsIDgsIDEyXV0sIFtcImRheVwiLCBbMSwgMl1dLCBbXCJ3ZWVrXCIsIFsxLCAyXV0sIFtcIm1vbnRoXCIsIFsxLCAyLCAzLCA0LCA2XV0sIFtcInllYXJcIiwgbnVsbF1dO1xuICAgICAgZyA9IEFbQS5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBHID0gSVtnWzBdXSxcbiAgICAgICAgICBFID0gZ1sxXSxcbiAgICAgICAgICB5O1xuXG4gICAgICBmb3IgKHkgPSAwOyB5IDwgQS5sZW5ndGggJiYgIShnID0gQVt5XSwgRyA9IElbZ1swXV0sIEUgPSBnWzFdLCBBW3kgKyAxXSAmJiBkIDw9IChHICogRVtFLmxlbmd0aCAtIDFdICsgSVtBW3kgKyAxXVswXV0pIC8gMik7IHkrKyk7XG5cbiAgICAgIEcgPT09IEkueWVhciAmJiBkIDwgNSAqIEcgJiYgKEUgPSBbMSwgMiwgNV0pO1xuICAgICAgZCA9IHUoZCAvIEcsIEUsIFwieWVhclwiID09PSBnWzBdID8gTWF0aC5tYXgocihkIC8gRyksIDEpIDogMSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1bml0UmFuZ2U6IEcsXG4gICAgICAgIGNvdW50OiBkLFxuICAgICAgICB1bml0TmFtZTogZ1swXVxuICAgICAgfTtcbiAgICB9O1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL0xvZ2FyaXRobWljQXhpcy5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZykge1xuICAgIHZhciByID0gZy5nZXRNYWduaXR1ZGUsXG4gICAgICAgIHUgPSBnLm5vcm1hbGl6ZVRpY2tJbnRlcnZhbCxcbiAgICAgICAgSSA9IGcucGljaztcbiAgICBkID0gZC5BeGlzO1xuXG4gICAgZC5wcm90b3R5cGUuZ2V0TG9nVGlja1Bvc2l0aW9ucyA9IGZ1bmN0aW9uIChkLCBnLCBBLCBHKSB7XG4gICAgICB2YXIgRSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICB5ID0gdGhpcy5sZW4sXG4gICAgICAgICAgdCA9IFtdO1xuICAgICAgRyB8fCAodGhpcy5fbWlub3JBdXRvSW50ZXJ2YWwgPSBudWxsKTtcbiAgICAgIGlmICguNSA8PSBkKSBkID0gTWF0aC5yb3VuZChkKSwgdCA9IHRoaXMuZ2V0TGluZWFyVGlja1Bvc2l0aW9ucyhkLCBnLCBBKTtlbHNlIGlmICguMDggPD0gZCkge1xuICAgICAgICB5ID0gTWF0aC5mbG9vcihnKTtcbiAgICAgICAgdmFyIEQsIGg7XG5cbiAgICAgICAgZm9yIChFID0gLjMgPCBkID8gWzEsIDIsIDRdIDogLjE1IDwgZCA/IFsxLCAyLCA0LCA2LCA4XSA6IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XTsgeSA8IEEgKyAxICYmICFoOyB5KyspIHtcbiAgICAgICAgICB2YXIgTiA9IEUubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChEID0gMDsgRCA8IE4gJiYgIWg7IEQrKykge1xuICAgICAgICAgICAgdmFyIHEgPSB0aGlzLmxvZzJsaW4odGhpcy5saW4ybG9nKHkpICogRVtEXSk7XG4gICAgICAgICAgICBxID4gZyAmJiAoIUcgfHwgUCA8PSBBKSAmJiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgUCAmJiB0LnB1c2goUCk7XG4gICAgICAgICAgICBQID4gQSAmJiAoaCA9ICEwKTtcbiAgICAgICAgICAgIHZhciBQID0gcTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBnID0gdGhpcy5saW4ybG9nKGcpLCBBID0gdGhpcy5saW4ybG9nKEEpLCBkID0gRyA/IHRoaXMuZ2V0TWlub3JUaWNrSW50ZXJ2YWwoKSA6IEUudGlja0ludGVydmFsLCBkID0gSShcImF1dG9cIiA9PT0gZCA/IG51bGwgOiBkLCB0aGlzLl9taW5vckF1dG9JbnRlcnZhbCwgRS50aWNrUGl4ZWxJbnRlcnZhbCAvIChHID8gNSA6IDEpICogKEEgLSBnKSAvICgoRyA/IHkgLyB0aGlzLnRpY2tQb3NpdGlvbnMubGVuZ3RoIDogeSkgfHwgMSkpLCBkID0gdShkLCBudWxsLCByKGQpKSwgdCA9IHRoaXMuZ2V0TGluZWFyVGlja1Bvc2l0aW9ucyhkLCBnLCBBKS5tYXAodGhpcy5sb2cybGluKSwgRyB8fCAodGhpcy5fbWlub3JBdXRvSW50ZXJ2YWwgPSBkIC8gNSk7XG4gICAgICBHIHx8ICh0aGlzLnRpY2tJbnRlcnZhbCA9IGQpO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcblxuICAgIGQucHJvdG90eXBlLmxvZzJsaW4gPSBmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIE1hdGgubG9nKGQpIC8gTWF0aC5MTjEwO1xuICAgIH07XG5cbiAgICBkLnByb3RvdHlwZS5saW4ybG9nID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdygxMCwgZCk7XG4gICAgfTtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9QbG90TGluZU9yQmFuZC5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9BeGlzLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcsIHIpIHtcbiAgICB2YXIgdSA9IHIuYXJyYXlNYXgsXG4gICAgICAgIEkgPSByLmFycmF5TWluLFxuICAgICAgICBNID0gci5kZWZpbmVkLFxuICAgICAgICBFID0gci5kZXN0cm95T2JqZWN0UHJvcGVydGllcyxcbiAgICAgICAgQSA9IHIuZXJhc2UsXG4gICAgICAgIEcgPSByLmV4dGVuZCxcbiAgICAgICAgSiA9IHIubWVyZ2UsXG4gICAgICAgIHkgPSByLm9iamVjdEVhY2gsXG4gICAgICAgIHQgPSByLnBpY2ssXG4gICAgICAgIEQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBoKGQsIGgpIHtcbiAgICAgICAgdGhpcy5heGlzID0gZDtcbiAgICAgICAgaCAmJiAodGhpcy5vcHRpb25zID0gaCwgdGhpcy5pZCA9IGguaWQpO1xuICAgICAgfVxuXG4gICAgICBoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGQuZmlyZUV2ZW50KHRoaXMsIFwicmVuZGVyXCIpO1xuICAgICAgICB2YXIgaCA9IHRoaXMsXG4gICAgICAgICAgICBxID0gaC5heGlzLFxuICAgICAgICAgICAgZyA9IHEuaG9yaXosXG4gICAgICAgICAgICBlID0gaC5vcHRpb25zLFxuICAgICAgICAgICAgYyA9IGUubGFiZWwsXG4gICAgICAgICAgICBrID0gaC5sYWJlbCxcbiAgICAgICAgICAgIG4gPSBlLnRvLFxuICAgICAgICAgICAgZiA9IGUuZnJvbSxcbiAgICAgICAgICAgIGEgPSBlLnZhbHVlLFxuICAgICAgICAgICAgbCA9IE0oZikgJiYgTShuKSxcbiAgICAgICAgICAgIHYgPSBNKGEpLFxuICAgICAgICAgICAgeiA9IGguc3ZnRWxlbSxcbiAgICAgICAgICAgIHcgPSAheixcbiAgICAgICAgICAgIEIgPSBbXSxcbiAgICAgICAgICAgIEwgPSBlLmNvbG9yLFxuICAgICAgICAgICAgUSA9IHQoZS56SW5kZXgsIDApLFxuICAgICAgICAgICAgSCA9IGUuZXZlbnRzO1xuICAgICAgICBCID0ge1xuICAgICAgICAgIFwiY2xhc3NcIjogXCJoaWdoY2hhcnRzLXBsb3QtXCIgKyAobCA/IFwiYmFuZCBcIiA6IFwibGluZSBcIikgKyAoZS5jbGFzc05hbWUgfHwgXCJcIilcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIEsgPSB7fSxcbiAgICAgICAgICAgIHAgPSBxLmNoYXJ0LnJlbmRlcmVyLFxuICAgICAgICAgICAgYiA9IGwgPyBcImJhbmRzXCIgOiBcImxpbmVzXCI7XG4gICAgICAgIHEuaXNMb2cgJiYgKGYgPSBxLmxvZzJsaW4oZiksIG4gPSBxLmxvZzJsaW4obiksIGEgPSBxLmxvZzJsaW4oYSkpO1xuICAgICAgICBxLmNoYXJ0LnN0eWxlZE1vZGUgfHwgKHYgPyAoQi5zdHJva2UgPSBMIHx8IFwiIzk5OTk5OVwiLCBCW1wic3Ryb2tlLXdpZHRoXCJdID0gdChlLndpZHRoLCAxKSwgZS5kYXNoU3R5bGUgJiYgKEIuZGFzaHN0eWxlID0gZS5kYXNoU3R5bGUpKSA6IGwgJiYgKEIuZmlsbCA9IEwgfHwgXCIjZTZlYmY1XCIsIGUuYm9yZGVyV2lkdGggJiYgKEIuc3Ryb2tlID0gZS5ib3JkZXJDb2xvciwgQltcInN0cm9rZS13aWR0aFwiXSA9IGUuYm9yZGVyV2lkdGgpKSk7XG4gICAgICAgIEsuekluZGV4ID0gUTtcbiAgICAgICAgYiArPSBcIi1cIiArIFE7XG4gICAgICAgIChMID0gcS5wbG90TGluZXNBbmRCYW5kc0dyb3Vwc1tiXSkgfHwgKHEucGxvdExpbmVzQW5kQmFuZHNHcm91cHNbYl0gPSBMID0gcC5nKFwicGxvdC1cIiArIGIpLmF0dHIoSykuYWRkKCkpO1xuICAgICAgICB3ICYmIChoLnN2Z0VsZW0gPSB6ID0gcC5wYXRoKCkuYXR0cihCKS5hZGQoTCkpO1xuICAgICAgICBpZiAodikgQiA9IHEuZ2V0UGxvdExpbmVQYXRoKHtcbiAgICAgICAgICB2YWx1ZTogYSxcbiAgICAgICAgICBsaW5lV2lkdGg6IHouc3Ryb2tlV2lkdGgoKSxcbiAgICAgICAgICBhY3Jvc3NQYW5lczogZS5hY3Jvc3NQYW5lc1xuICAgICAgICB9KTtlbHNlIGlmIChsKSBCID0gcS5nZXRQbG90QmFuZFBhdGgoZiwgbiwgZSk7ZWxzZSByZXR1cm47XG4gICAgICAgICh3IHx8ICF6LmQpICYmIEIgJiYgQi5sZW5ndGggPyAoei5hdHRyKHtcbiAgICAgICAgICBkOiBCXG4gICAgICAgIH0pLCBIICYmIHkoSCwgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICB6Lm9uKGEsIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICBIW2FdLmFwcGx5KGgsIFtiXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKSA6IHogJiYgKEIgPyAoei5zaG93KCEwKSwgei5hbmltYXRlKHtcbiAgICAgICAgICBkOiBCXG4gICAgICAgIH0pKSA6IHouZCAmJiAoei5oaWRlKCksIGsgJiYgKGgubGFiZWwgPSBrID0gay5kZXN0cm95KCkpKSk7XG4gICAgICAgIGMgJiYgKE0oYy50ZXh0KSB8fCBNKGMuZm9ybWF0dGVyKSkgJiYgQiAmJiBCLmxlbmd0aCAmJiAwIDwgcS53aWR0aCAmJiAwIDwgcS5oZWlnaHQgJiYgIUIuaXNGbGF0ID8gKGMgPSBKKHtcbiAgICAgICAgICBhbGlnbjogZyAmJiBsICYmIFwiY2VudGVyXCIsXG4gICAgICAgICAgeDogZyA/ICFsICYmIDQgOiAxMCxcbiAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiAhZyAmJiBsICYmIFwibWlkZGxlXCIsXG4gICAgICAgICAgeTogZyA/IGwgPyAxNiA6IDEwIDogbCA/IDYgOiAtNCxcbiAgICAgICAgICByb3RhdGlvbjogZyAmJiAhbCAmJiA5MFxuICAgICAgICB9LCBjKSwgdGhpcy5yZW5kZXJMYWJlbChjLCBCLCBsLCBRKSkgOiBrICYmIGsuaGlkZSgpO1xuICAgICAgICByZXR1cm4gaDtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLnJlbmRlckxhYmVsID0gZnVuY3Rpb24gKGQsIGgsIGcsIGUpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmxhYmVsLFxuICAgICAgICAgICAgayA9IHRoaXMuYXhpcy5jaGFydC5yZW5kZXJlcjtcbiAgICAgICAgYyB8fCAoYyA9IHtcbiAgICAgICAgICBhbGlnbjogZC50ZXh0QWxpZ24gfHwgZC5hbGlnbixcbiAgICAgICAgICByb3RhdGlvbjogZC5yb3RhdGlvbixcbiAgICAgICAgICBcImNsYXNzXCI6IFwiaGlnaGNoYXJ0cy1wbG90LVwiICsgKGcgPyBcImJhbmRcIiA6IFwibGluZVwiKSArIFwiLWxhYmVsIFwiICsgKGQuY2xhc3NOYW1lIHx8IFwiXCIpXG4gICAgICAgIH0sIGMuekluZGV4ID0gZSwgZSA9IHRoaXMuZ2V0TGFiZWxUZXh0KGQpLCB0aGlzLmxhYmVsID0gYyA9IGsudGV4dChlLCAwLCAwLCBkLnVzZUhUTUwpLmF0dHIoYykuYWRkKCksIHRoaXMuYXhpcy5jaGFydC5zdHlsZWRNb2RlIHx8IGMuY3NzKGQuc3R5bGUpKTtcbiAgICAgICAgayA9IGgueEJvdW5kcyB8fCBbaFsxXSwgaFs0XSwgZyA/IGhbNl0gOiBoWzFdXTtcbiAgICAgICAgaCA9IGgueUJvdW5kcyB8fCBbaFsyXSwgaFs1XSwgZyA/IGhbN10gOiBoWzJdXTtcbiAgICAgICAgZyA9IEkoayk7XG4gICAgICAgIGUgPSBJKGgpO1xuICAgICAgICBjLmFsaWduKGQsICExLCB7XG4gICAgICAgICAgeDogZyxcbiAgICAgICAgICB5OiBlLFxuICAgICAgICAgIHdpZHRoOiB1KGspIC0gZyxcbiAgICAgICAgICBoZWlnaHQ6IHUoaCkgLSBlXG4gICAgICAgIH0pO1xuICAgICAgICBjLnNob3coITApO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUuZ2V0TGFiZWxUZXh0ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIE0oZC5mb3JtYXR0ZXIpID8gZC5mb3JtYXR0ZXIuY2FsbCh0aGlzKSA6IGQudGV4dDtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIEEodGhpcy5heGlzLnBsb3RMaW5lc0FuZEJhbmRzLCB0aGlzKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuYXhpcztcbiAgICAgICAgRSh0aGlzKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBoO1xuICAgIH0oKTtcblxuICAgIEcoZy5wcm90b3R5cGUsIHtcbiAgICAgIGdldFBsb3RCYW5kUGF0aDogZnVuY3Rpb24gKGQsIGcpIHtcbiAgICAgICAgdmFyIGggPSB0aGlzLmdldFBsb3RMaW5lUGF0aCh7XG4gICAgICAgICAgdmFsdWU6IGcsXG4gICAgICAgICAgZm9yY2U6ICEwLFxuICAgICAgICAgIGFjcm9zc1BhbmVzOiB0aGlzLm9wdGlvbnMuYWNyb3NzUGFuZXNcbiAgICAgICAgfSksXG4gICAgICAgICAgICB0ID0gdGhpcy5nZXRQbG90TGluZVBhdGgoe1xuICAgICAgICAgIHZhbHVlOiBkLFxuICAgICAgICAgIGZvcmNlOiAhMCxcbiAgICAgICAgICBhY3Jvc3NQYW5lczogdGhpcy5vcHRpb25zLmFjcm9zc1BhbmVzXG4gICAgICAgIH0pLFxuICAgICAgICAgICAgZSA9IFtdLFxuICAgICAgICAgICAgYyA9IHRoaXMuaG9yaXosXG4gICAgICAgICAgICBrID0gMTtcbiAgICAgICAgZCA9IGQgPCB0aGlzLm1pbiAmJiBnIDwgdGhpcy5taW4gfHwgZCA+IHRoaXMubWF4ICYmIGcgPiB0aGlzLm1heDtcblxuICAgICAgICBpZiAodCAmJiBoKSB7XG4gICAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAgIHZhciBuID0gdC50b1N0cmluZygpID09PSBoLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGQgPSAwOyBkIDwgdC5sZW5ndGg7IGQgKz0gNikgYyAmJiBoW2QgKyAxXSA9PT0gdFtkICsgMV0gPyAoaFtkICsgMV0gKz0gaywgaFtkICsgNF0gKz0gaykgOiBjIHx8IGhbZCArIDJdICE9PSB0W2QgKyAyXSB8fCAoaFtkICsgMl0gKz0gaywgaFtkICsgNV0gKz0gayksIGUucHVzaChcIk1cIiwgdFtkICsgMV0sIHRbZCArIDJdLCBcIkxcIiwgdFtkICsgNF0sIHRbZCArIDVdLCBoW2QgKyA0XSwgaFtkICsgNV0sIGhbZCArIDFdLCBoW2QgKyAyXSwgXCJ6XCIpLCBlLmlzRmxhdCA9IG47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0sXG4gICAgICBhZGRQbG90QmFuZDogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkUGxvdEJhbmRPckxpbmUoZCwgXCJwbG90QmFuZHNcIik7XG4gICAgICB9LFxuICAgICAgYWRkUGxvdExpbmU6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFBsb3RCYW5kT3JMaW5lKGQsIFwicGxvdExpbmVzXCIpO1xuICAgICAgfSxcbiAgICAgIGFkZFBsb3RCYW5kT3JMaW5lOiBmdW5jdGlvbiAoZCwgZykge1xuICAgICAgICB2YXIgaCA9IG5ldyBEKHRoaXMsIGQpLnJlbmRlcigpLFxuICAgICAgICAgICAgdCA9IHRoaXMudXNlck9wdGlvbnM7XG5cbiAgICAgICAgaWYgKGgpIHtcbiAgICAgICAgICBpZiAoZykge1xuICAgICAgICAgICAgdmFyIGUgPSB0W2ddIHx8IFtdO1xuICAgICAgICAgICAgZS5wdXNoKGQpO1xuICAgICAgICAgICAgdFtnXSA9IGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5wbG90TGluZXNBbmRCYW5kcy5wdXNoKGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGg7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlUGxvdEJhbmRPckxpbmU6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGZvciAodmFyIGggPSB0aGlzLnBsb3RMaW5lc0FuZEJhbmRzLCBxID0gdGhpcy5vcHRpb25zLCBnID0gdGhpcy51c2VyT3B0aW9ucywgZSA9IGgubGVuZ3RoOyBlLS07KSBoW2VdLmlkID09PSBkICYmIGhbZV0uZGVzdHJveSgpO1xuXG4gICAgICAgIFtxLnBsb3RMaW5lcyB8fCBbXSwgZy5wbG90TGluZXMgfHwgW10sIHEucGxvdEJhbmRzIHx8IFtdLCBnLnBsb3RCYW5kcyB8fCBbXV0uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGZvciAoZSA9IGMubGVuZ3RoOyBlLS07KSBjW2VdLmlkID09PSBkICYmIEEoYywgY1tlXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZVBsb3RCYW5kOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICB0aGlzLnJlbW92ZVBsb3RCYW5kT3JMaW5lKGQpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZVBsb3RMaW5lOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICB0aGlzLnJlbW92ZVBsb3RCYW5kT3JMaW5lKGQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGQuUGxvdExpbmVPckJhbmQgPSBEO1xuICAgIHJldHVybiBkLlBsb3RMaW5lT3JCYW5kO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL1Rvb2x0aXAuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcpIHtcbiAgICB2YXIgciA9IGcuY2xhbXAsXG4gICAgICAgIHUgPSBnLmNzcyxcbiAgICAgICAgSSA9IGcuZGVmaW5lZCxcbiAgICAgICAgTSA9IGcuZGlzY2FyZEVsZW1lbnQsXG4gICAgICAgIEUgPSBnLmV4dGVuZCxcbiAgICAgICAgQSA9IGcuZm9ybWF0LFxuICAgICAgICBHID0gZy5pc051bWJlcixcbiAgICAgICAgSiA9IGcuaXNTdHJpbmcsXG4gICAgICAgIHkgPSBnLm1lcmdlLFxuICAgICAgICB0ID0gZy5waWNrLFxuICAgICAgICBEID0gZy5zcGxhdCxcbiAgICAgICAgaCA9IGcuc3luY1RpbWVvdXQsXG4gICAgICAgIE4gPSBnLnRpbWVVbml0cztcbiAgICBcIlwiO1xuXG4gICAgdmFyIHEgPSBkLmRvYyxcbiAgICAgICAgUCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIGUoYywgZSkge1xuICAgICAgICB0aGlzLmNyb3NzaGFpcnMgPSBbXTtcbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IDA7XG4gICAgICAgIHRoaXMuaXNIaWRkZW4gPSAhMDtcbiAgICAgICAgdGhpcy5pc1N0aWNreSA9ICExO1xuICAgICAgICB0aGlzLm5vdyA9IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5vdXRzaWRlID0gITE7XG4gICAgICAgIHRoaXMuY2hhcnQgPSBjO1xuICAgICAgICB0aGlzLmluaXQoYywgZSk7XG4gICAgICB9XG5cbiAgICAgIGUucHJvdG90eXBlLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYyA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIGMucmVuZGVyZXIuZGVmaW5pdGlvbih7XG4gICAgICAgICAgdGFnTmFtZTogXCJmaWx0ZXJcIixcbiAgICAgICAgICBpZDogXCJkcm9wLXNoYWRvdy1cIiArIGMuaW5kZXgsXG4gICAgICAgICAgb3BhY2l0eTogLjUsXG4gICAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgICB0YWdOYW1lOiBcImZlR2F1c3NpYW5CbHVyXCIsXG4gICAgICAgICAgICBcImluXCI6IFwiU291cmNlQWxwaGFcIixcbiAgICAgICAgICAgIHN0ZERldmlhdGlvbjogMVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRhZ05hbWU6IFwiZmVPZmZzZXRcIixcbiAgICAgICAgICAgIGR4OiAxLFxuICAgICAgICAgICAgZHk6IDFcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB0YWdOYW1lOiBcImZlQ29tcG9uZW50VHJhbnNmZXJcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgICAgICB0YWdOYW1lOiBcImZlRnVuY0FcIixcbiAgICAgICAgICAgICAgdHlwZTogXCJsaW5lYXJcIixcbiAgICAgICAgICAgICAgc2xvcGU6IC4zXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRhZ05hbWU6IFwiZmVNZXJnZVwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgICAgIHRhZ05hbWU6IFwiZmVNZXJnZU5vZGVcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICB0YWdOYW1lOiBcImZlTWVyZ2VOb2RlXCIsXG4gICAgICAgICAgICAgIFwiaW5cIjogXCJTb3VyY2VHcmFwaGljXCJcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfV1cbiAgICAgICAgfSk7XG4gICAgICAgIGMucmVuZGVyZXIuZGVmaW5pdGlvbih7XG4gICAgICAgICAgdGFnTmFtZTogXCJzdHlsZVwiLFxuICAgICAgICAgIHRleHRDb250ZW50OiBcIi5oaWdoY2hhcnRzLXRvb2x0aXAtXCIgKyBjLmluZGV4ICsgXCJ7ZmlsdGVyOnVybCgjZHJvcC1zaGFkb3ctXCIgKyBjLmluZGV4ICsgXCIpfVwiXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUuYm9keUZvcm1hdHRlciA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHZhciBlID0gYy5zZXJpZXMudG9vbHRpcE9wdGlvbnM7XG4gICAgICAgICAgcmV0dXJuIChlWyhjLnBvaW50LmZvcm1hdFByZWZpeCB8fCBcInBvaW50XCIpICsgXCJGb3JtYXR0ZXJcIl0gfHwgYy5wb2ludC50b29sdGlwRm9ybWF0dGVyKS5jYWxsKGMucG9pbnQsIGVbKGMucG9pbnQuZm9ybWF0UHJlZml4IHx8IFwicG9pbnRcIikgKyBcIkZvcm1hdFwiXSB8fCBcIlwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS5jbGVhblNwbGl0ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdGhpcy5jaGFydC5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBkID0gZSAmJiBlLnR0O1xuICAgICAgICAgIGQgJiYgKCFkLmlzQWN0aXZlIHx8IGMgPyBlLnR0ID0gZC5kZXN0cm95KCkgOiBkLmlzQWN0aXZlID0gITEpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLmRlZmF1bHRGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgZSA9IHRoaXMucG9pbnRzIHx8IEQodGhpcyk7XG4gICAgICAgIHZhciBkID0gW2MudG9vbHRpcEZvb3RlckhlYWRlckZvcm1hdHRlcihlWzBdKV07XG4gICAgICAgIGQgPSBkLmNvbmNhdChjLmJvZHlGb3JtYXR0ZXIoZSkpO1xuICAgICAgICBkLnB1c2goYy50b29sdGlwRm9vdGVySGVhZGVyRm9ybWF0dGVyKGVbMF0sICEwKSk7XG4gICAgICAgIHJldHVybiBkO1xuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sYWJlbCAmJiAodGhpcy5sYWJlbCA9IHRoaXMubGFiZWwuZGVzdHJveSgpKTtcbiAgICAgICAgdGhpcy5zcGxpdCAmJiB0aGlzLnR0ICYmICh0aGlzLmNsZWFuU3BsaXQodGhpcy5jaGFydCwgITApLCB0aGlzLnR0ID0gdGhpcy50dC5kZXN0cm95KCkpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyICYmICh0aGlzLnJlbmRlcmVyID0gdGhpcy5yZW5kZXJlci5kZXN0cm95KCksIE0odGhpcy5jb250YWluZXIpKTtcbiAgICAgICAgZy5jbGVhclRpbWVvdXQodGhpcy5oaWRlVGltZXIpO1xuICAgICAgICBnLmNsZWFyVGltZW91dCh0aGlzLnRvb2x0aXBUaW1lb3V0KTtcbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLmdldEFuY2hvciA9IGZ1bmN0aW9uIChjLCBlKSB7XG4gICAgICAgIHZhciBkID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGYgPSBkLnBvaW50ZXIsXG4gICAgICAgICAgICBhID0gZC5pbnZlcnRlZCxcbiAgICAgICAgICAgIGwgPSBkLnBsb3RUb3AsXG4gICAgICAgICAgICBrID0gZC5wbG90TGVmdCxcbiAgICAgICAgICAgIGggPSAwLFxuICAgICAgICAgICAgdyA9IDAsXG4gICAgICAgICAgICBCLFxuICAgICAgICAgICAgcTtcbiAgICAgICAgYyA9IEQoYyk7XG4gICAgICAgIHRoaXMuZm9sbG93UG9pbnRlciAmJiBlID8gKFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBlLmNoYXJ0WCAmJiAoZSA9IGYubm9ybWFsaXplKGUpKSwgYyA9IFtlLmNoYXJ0WCAtIGssIGUuY2hhcnRZIC0gbF0pIDogY1swXS50b29sdGlwUG9zID8gYyA9IGNbMF0udG9vbHRpcFBvcyA6IChjLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBCID0gYy5zZXJpZXMueUF4aXM7XG4gICAgICAgICAgcSA9IGMuc2VyaWVzLnhBeGlzO1xuICAgICAgICAgIGggKz0gYy5wbG90WCArICghYSAmJiBxID8gcS5sZWZ0IC0gayA6IDApO1xuICAgICAgICAgIHcgKz0gKGMucGxvdExvdyA/IChjLnBsb3RMb3cgKyBjLnBsb3RIaWdoKSAvIDIgOiBjLnBsb3RZKSArICghYSAmJiBCID8gQi50b3AgLSBsIDogMCk7XG4gICAgICAgIH0pLCBoIC89IGMubGVuZ3RoLCB3IC89IGMubGVuZ3RoLCBjID0gW2EgPyBkLnBsb3RXaWR0aCAtIHcgOiBoLCB0aGlzLnNoYXJlZCAmJiAhYSAmJiAxIDwgYy5sZW5ndGggJiYgZSA/IGUuY2hhcnRZIC0gbCA6IGEgPyBkLnBsb3RIZWlnaHQgLSBoIDogd10pO1xuICAgICAgICByZXR1cm4gYy5tYXAoTWF0aC5yb3VuZCk7XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS5nZXREYXRlRm9ybWF0ID0gZnVuY3Rpb24gKGMsIGUsIGQsIGYpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNoYXJ0LnRpbWUsXG4gICAgICAgICAgICBsID0gYS5kYXRlRm9ybWF0KFwiJW0tJWQgJUg6JU06JVMuJUxcIiwgZSksXG4gICAgICAgICAgICBrID0ge1xuICAgICAgICAgIG1pbGxpc2Vjb25kOiAxNSxcbiAgICAgICAgICBzZWNvbmQ6IDEyLFxuICAgICAgICAgIG1pbnV0ZTogOSxcbiAgICAgICAgICBob3VyOiA2LFxuICAgICAgICAgIGRheTogM1xuICAgICAgICB9LFxuICAgICAgICAgICAgbiA9IFwibWlsbGlzZWNvbmRcIjtcblxuICAgICAgICBmb3IgKHcgaW4gTikge1xuICAgICAgICAgIGlmIChjID09PSBOLndlZWsgJiYgK2EuZGF0ZUZvcm1hdChcIiV3XCIsIGUpID09PSBkICYmIFwiMDA6MDA6MDAuMDAwXCIgPT09IGwuc3Vic3RyKDYpKSB7XG4gICAgICAgICAgICB2YXIgdyA9IFwid2Vla1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKE5bd10gPiBjKSB7XG4gICAgICAgICAgICB3ID0gbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChrW3ddICYmIGwuc3Vic3RyKGtbd10pICE9PSBcIjAxLTAxIDAwOjAwOjAwLjAwMFwiLnN1YnN0cihrW3ddKSkgYnJlYWs7XG4gICAgICAgICAgXCJ3ZWVrXCIgIT09IHcgJiYgKG4gPSB3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3KSB2YXIgaCA9IGEucmVzb2x2ZURUTEZvcm1hdChmW3ddKS5tYWluO1xuICAgICAgICByZXR1cm4gaDtcbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLmdldExhYmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYyxcbiAgICAgICAgICAgIGUgPSB0aGlzLFxuICAgICAgICAgICAgbiA9IHRoaXMuY2hhcnQucmVuZGVyZXIsXG4gICAgICAgICAgICBmID0gdGhpcy5jaGFydC5zdHlsZWRNb2RlLFxuICAgICAgICAgICAgYSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGwgPSBcInRvb2x0aXBcIiArIChJKGEuY2xhc3NOYW1lKSA/IFwiIFwiICsgYS5jbGFzc05hbWUgOiBcIlwiKSxcbiAgICAgICAgICAgIHYgPSAobnVsbCA9PT0gKGMgPSBhLnN0eWxlKSB8fCB2b2lkIDAgPT09IGMgPyB2b2lkIDAgOiBjLnBvaW50ZXJFdmVudHMpIHx8ICghdGhpcy5mb2xsb3dQb2ludGVyICYmIGEuc3RpY2tPbkNvbnRhY3QgPyBcImF1dG9cIiA6IFwibm9uZVwiKSxcbiAgICAgICAgICAgIGg7XG5cbiAgICAgICAgYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlLmluQ29udGFjdCA9ICEwO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhID0gZS5jaGFydC5ob3ZlclNlcmllcztcbiAgICAgICAgICBlLmluQ29udGFjdCA9ICExO1xuICAgICAgICAgIGlmIChhICYmIGEub25Nb3VzZU91dCkgYS5vbk1vdXNlT3V0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCF0aGlzLmxhYmVsKSB7XG4gICAgICAgICAgdGhpcy5vdXRzaWRlICYmICh0aGlzLmNvbnRhaW5lciA9IGggPSBkLmRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBoLmNsYXNzTmFtZSA9IFwiaGlnaGNoYXJ0cy10b29sdGlwLWNvbnRhaW5lclwiLCB1KGgsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB0b3A6IFwiMXB4XCIsXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiB2LFxuICAgICAgICAgICAgekluZGV4OiAzXG4gICAgICAgICAgfSksIGQuZG9jLmJvZHkuYXBwZW5kQ2hpbGQoaCksIHRoaXMucmVuZGVyZXIgPSBuID0gbmV3IGQuUmVuZGVyZXIoaCwgMCwgMCwge30sIHZvaWQgMCwgdm9pZCAwLCBuLnN0eWxlZE1vZGUpKTtcbiAgICAgICAgICB0aGlzLnNwbGl0ID8gdGhpcy5sYWJlbCA9IG4uZyhsKSA6ICh0aGlzLmxhYmVsID0gbi5sYWJlbChcIlwiLCAwLCAwLCBhLnNoYXBlIHx8IFwiY2FsbG91dFwiLCBudWxsLCBudWxsLCBhLnVzZUhUTUwsIG51bGwsIGwpLmF0dHIoe1xuICAgICAgICAgICAgcGFkZGluZzogYS5wYWRkaW5nLFxuICAgICAgICAgICAgcjogYS5ib3JkZXJSYWRpdXNcbiAgICAgICAgICB9KSwgZiB8fCB0aGlzLmxhYmVsLmF0dHIoe1xuICAgICAgICAgICAgZmlsbDogYS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBhLmJvcmRlcldpZHRoXG4gICAgICAgICAgfSkuY3NzKGEuc3R5bGUpLmNzcyh7XG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiB2XG4gICAgICAgICAgfSkuc2hhZG93KGEuc2hhZG93KSk7XG4gICAgICAgICAgZiAmJiAodGhpcy5hcHBseUZpbHRlcigpLCB0aGlzLmxhYmVsLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy10b29sdGlwLVwiICsgdGhpcy5jaGFydC5pbmRleCkpO1xuXG4gICAgICAgICAgaWYgKGUub3V0c2lkZSAmJiAhZS5zcGxpdCkge1xuICAgICAgICAgICAgdmFyIEIgPSB7XG4gICAgICAgICAgICAgIHg6IHRoaXMubGFiZWwueFNldHRlcixcbiAgICAgICAgICAgICAgeTogdGhpcy5sYWJlbC55U2V0dGVyXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmxhYmVsLnhTZXR0ZXIgPSBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICAgICAgICBCW2NdLmNhbGwodGhpcy5sYWJlbCwgZS5kaXN0YW5jZSk7XG4gICAgICAgICAgICAgIGguc3R5bGUubGVmdCA9IGEgKyBcInB4XCI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmxhYmVsLnlTZXR0ZXIgPSBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICAgICAgICBCW2NdLmNhbGwodGhpcy5sYWJlbCwgZS5kaXN0YW5jZSk7XG4gICAgICAgICAgICAgIGguc3R5bGUudG9wID0gYSArIFwicHhcIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5sYWJlbC5vbihcIm1vdXNlZW50ZXJcIiwgYykub24oXCJtb3VzZWxlYXZlXCIsIHcpLmF0dHIoe1xuICAgICAgICAgICAgekluZGV4OiA4XG4gICAgICAgICAgfSkuYWRkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbDtcbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKGMsIGUsIGQpIHtcbiAgICAgICAgdmFyIGYgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgYSA9IHRoaXMuZGlzdGFuY2UsXG4gICAgICAgICAgICBsID0ge30sXG4gICAgICAgICAgICBrID0gZi5pbnZlcnRlZCAmJiBkLmggfHwgMCxcbiAgICAgICAgICAgIG4sXG4gICAgICAgICAgICB3ID0gdGhpcy5vdXRzaWRlLFxuICAgICAgICAgICAgaCA9IHcgPyBxLmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCAtIDIgKiBhIDogZi5jaGFydFdpZHRoLFxuICAgICAgICAgICAgZyA9IHcgPyBNYXRoLm1heChxLmJvZHkuc2Nyb2xsSGVpZ2h0LCBxLmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQsIHEuYm9keS5vZmZzZXRIZWlnaHQsIHEuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodCwgcS5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSA6IGYuY2hhcnRIZWlnaHQsXG4gICAgICAgICAgICBRID0gZi5wb2ludGVyLmdldENoYXJ0UG9zaXRpb24oKSxcbiAgICAgICAgICAgIEggPSBmLmNvbnRhaW5lclNjYWxpbmcsXG4gICAgICAgICAgICBLID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICByZXR1cm4gSCA/IGIgKiBILnNjYWxlWCA6IGI7XG4gICAgICAgIH0sXG4gICAgICAgICAgICBwID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICByZXR1cm4gSCA/IGIgKiBILnNjYWxlWSA6IGI7XG4gICAgICAgIH0sXG4gICAgICAgICAgICBiID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICB2YXIgbCA9IFwieFwiID09PSBiO1xuICAgICAgICAgIHJldHVybiBbYiwgbCA/IGggOiBnLCBsID8gYyA6IGVdLmNvbmNhdCh3ID8gW2wgPyBLKGMpIDogcChlKSwgbCA/IFEubGVmdCAtIGEgKyBLKGQucGxvdFggKyBmLnBsb3RMZWZ0KSA6IFEudG9wIC0gYSArIHAoZC5wbG90WSArIGYucGxvdFRvcCksIDAsIGwgPyBoIDogZ10gOiBbbCA/IGMgOiBlLCBsID8gZC5wbG90WCArIGYucGxvdExlZnQgOiBkLnBsb3RZICsgZi5wbG90VG9wLCBsID8gZi5wbG90TGVmdCA6IGYucGxvdFRvcCwgbCA/IGYucGxvdExlZnQgKyBmLnBsb3RXaWR0aCA6IGYucGxvdFRvcCArIGYucGxvdEhlaWdodF0pO1xuICAgICAgICB9LFxuICAgICAgICAgICAgQyA9IGIoXCJ5XCIpLFxuICAgICAgICAgICAgeCA9IGIoXCJ4XCIpLFxuICAgICAgICAgICAgUiA9ICF0aGlzLmZvbGxvd1BvaW50ZXIgJiYgdChkLnR0QmVsb3csICFmLmludmVydGVkID09PSAhIWQubmVnYXRpdmUpLFxuICAgICAgICAgICAgTyA9IGZ1bmN0aW9uIChiLCBjLCBmLCBlLCBkLCBtLCB2KSB7XG4gICAgICAgICAgdmFyIG4gPSBcInlcIiA9PT0gYiA/IHAoYSkgOiBLKGEpLFxuICAgICAgICAgICAgICB3ID0gKGYgLSBlKSAvIDIsXG4gICAgICAgICAgICAgIHggPSBlIDwgZCAtIGEsXG4gICAgICAgICAgICAgIGggPSBkICsgYSArIGUgPCBjLFxuICAgICAgICAgICAgICBGID0gZCAtIG4gLSBmICsgdztcbiAgICAgICAgICBkID0gZCArIG4gLSB3O1xuICAgICAgICAgIGlmIChSICYmIGgpIGxbYl0gPSBkO2Vsc2UgaWYgKCFSICYmIHgpIGxbYl0gPSBGO2Vsc2UgaWYgKHgpIGxbYl0gPSBNYXRoLm1pbih2IC0gZSwgMCA+IEYgLSBrID8gRiA6IEYgLSBrKTtlbHNlIGlmIChoKSBsW2JdID0gTWF0aC5tYXgobSwgZCArIGsgKyBmID4gYyA/IGQgOiBkICsgayk7ZWxzZSByZXR1cm4gITE7XG4gICAgICAgIH0sXG4gICAgICAgICAgICB5ID0gZnVuY3Rpb24gKGIsIGMsIGYsIGUsIGQpIHtcbiAgICAgICAgICB2YXIgaztcbiAgICAgICAgICBkIDwgYSB8fCBkID4gYyAtIGEgPyBrID0gITEgOiBsW2JdID0gZCA8IGYgLyAyID8gMSA6IGQgPiBjIC0gZSAvIDIgPyBjIC0gZSAtIDIgOiBkIC0gZiAvIDI7XG4gICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgIH0sXG4gICAgICAgICAgICB1ID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICB2YXIgYSA9IEM7XG4gICAgICAgICAgQyA9IHg7XG4gICAgICAgICAgeCA9IGE7XG4gICAgICAgICAgbiA9IGI7XG4gICAgICAgIH0sXG4gICAgICAgICAgICBtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICExICE9PSBPLmFwcGx5KDAsIEMpID8gITEgIT09IHkuYXBwbHkoMCwgeCkgfHwgbiB8fCAodSghMCksIG0oKSkgOiBuID8gbC54ID0gbC55ID0gMCA6ICh1KCEwKSwgbSgpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAoZi5pbnZlcnRlZCB8fCAxIDwgdGhpcy5sZW4pICYmIHUoKTtcbiAgICAgICAgbSgpO1xuICAgICAgICByZXR1cm4gbDtcbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLmdldFhEYXRlRm9ybWF0ID0gZnVuY3Rpb24gKGMsIGUsIGQpIHtcbiAgICAgICAgZSA9IGUuZGF0ZVRpbWVMYWJlbEZvcm1hdHM7XG4gICAgICAgIHZhciBmID0gZCAmJiBkLmNsb3Nlc3RQb2ludFJhbmdlO1xuICAgICAgICByZXR1cm4gKGYgPyB0aGlzLmdldERhdGVGb3JtYXQoZiwgYy54LCBkLm9wdGlvbnMuc3RhcnRPZldlZWssIGUpIDogZS5kYXkpIHx8IGUueWVhcjtcbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICAgIGcuY2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVyKTtcbiAgICAgICAgYyA9IHQoYywgdGhpcy5vcHRpb25zLmhpZGVEZWxheSwgNTAwKTtcbiAgICAgICAgdGhpcy5pc0hpZGRlbiB8fCAodGhpcy5oaWRlVGltZXIgPSBoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlLmdldExhYmVsKClbYyA/IFwiZmFkZU91dFwiIDogXCJoaWRlXCJdKCk7XG4gICAgICAgICAgZS5pc0hpZGRlbiA9ICEwO1xuICAgICAgICB9LCBjKSk7XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGMsIGUpIHtcbiAgICAgICAgdGhpcy5jaGFydCA9IGM7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGU7XG4gICAgICAgIHRoaXMuY3Jvc3NoYWlycyA9IFtdO1xuICAgICAgICB0aGlzLm5vdyA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc0hpZGRlbiA9ICEwO1xuICAgICAgICB0aGlzLnNwbGl0ID0gZS5zcGxpdCAmJiAhYy5pbnZlcnRlZCAmJiAhYy5wb2xhcjtcbiAgICAgICAgdGhpcy5zaGFyZWQgPSBlLnNoYXJlZCB8fCB0aGlzLnNwbGl0O1xuICAgICAgICB0aGlzLm91dHNpZGUgPSB0KGUub3V0c2lkZSwgISghYy5zY3JvbGxhYmxlUGl4ZWxzWCAmJiAhYy5zY3JvbGxhYmxlUGl4ZWxzWSkpO1xuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUuaXNTdGlja3lPbkNvbnRhY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhKHRoaXMuZm9sbG93UG9pbnRlciB8fCAhdGhpcy5vcHRpb25zLnN0aWNrT25Db250YWN0IHx8ICF0aGlzLmluQ29udGFjdCk7XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKGMsIGUsIGQsIGYpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgbCA9IGEubm93LFxuICAgICAgICAgICAgayA9ICExICE9PSBhLm9wdGlvbnMuYW5pbWF0aW9uICYmICFhLmlzSGlkZGVuICYmICgxIDwgTWF0aC5hYnMoYyAtIGwueCkgfHwgMSA8IE1hdGguYWJzKGUgLSBsLnkpKSxcbiAgICAgICAgICAgIG4gPSBhLmZvbGxvd1BvaW50ZXIgfHwgMSA8IGEubGVuO1xuICAgICAgICBFKGwsIHtcbiAgICAgICAgICB4OiBrID8gKDIgKiBsLnggKyBjKSAvIDMgOiBjLFxuICAgICAgICAgIHk6IGsgPyAobC55ICsgZSkgLyAyIDogZSxcbiAgICAgICAgICBhbmNob3JYOiBuID8gdm9pZCAwIDogayA/ICgyICogbC5hbmNob3JYICsgZCkgLyAzIDogZCxcbiAgICAgICAgICBhbmNob3JZOiBuID8gdm9pZCAwIDogayA/IChsLmFuY2hvclkgKyBmKSAvIDIgOiBmXG4gICAgICAgIH0pO1xuICAgICAgICBhLmdldExhYmVsKCkuYXR0cihsKTtcbiAgICAgICAgYS5kcmF3VHJhY2tlcigpO1xuICAgICAgICBrICYmIChnLmNsZWFyVGltZW91dCh0aGlzLnRvb2x0aXBUaW1lb3V0KSwgdGhpcy50b29sdGlwVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGEgJiYgYS5tb3ZlKGMsIGUsIGQsIGYpO1xuICAgICAgICB9LCAzMikpO1xuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIChjLCBlKSB7XG4gICAgICAgIHZhciBrID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGYgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBhID0gYyxcbiAgICAgICAgICAgIGwgPSB7fSxcbiAgICAgICAgICAgIHYgPSBbXSxcbiAgICAgICAgICAgIGggPSBmLmZvcm1hdHRlciB8fCB0aGlzLmRlZmF1bHRGb3JtYXR0ZXI7XG4gICAgICAgIGwgPSB0aGlzLnNoYXJlZDtcbiAgICAgICAgdmFyIHcgPSBrLnN0eWxlZE1vZGU7XG5cbiAgICAgICAgaWYgKGYuZW5hYmxlZCkge1xuICAgICAgICAgIGcuY2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVyKTtcbiAgICAgICAgICB0aGlzLmZvbGxvd1BvaW50ZXIgPSBEKGEpWzBdLnNlcmllcy50b29sdGlwT3B0aW9ucy5mb2xsb3dQb2ludGVyO1xuICAgICAgICAgIHZhciBCID0gdGhpcy5nZXRBbmNob3IoYSwgZSk7XG4gICAgICAgICAgZSA9IEJbMF07XG4gICAgICAgICAgdmFyIHEgPSBCWzFdO1xuICAgICAgICAgICFsIHx8IGEuc2VyaWVzICYmIGEuc2VyaWVzLm5vU2hhcmVkVG9vbHRpcCA/IGwgPSBhLmdldExhYmVsQ29uZmlnKCkgOiAoay5wb2ludGVyLmFwcGx5SW5hY3RpdmVTdGF0ZShhKSwgYS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBhLnNldFN0YXRlKFwiaG92ZXJcIik7XG4gICAgICAgICAgICB2LnB1c2goYS5nZXRMYWJlbENvbmZpZygpKTtcbiAgICAgICAgICB9KSwgbCA9IHtcbiAgICAgICAgICAgIHg6IGFbMF0uY2F0ZWdvcnksXG4gICAgICAgICAgICB5OiBhWzBdLnlcbiAgICAgICAgICB9LCBsLnBvaW50cyA9IHYsIGEgPSBhWzBdKTtcbiAgICAgICAgICB0aGlzLmxlbiA9IHYubGVuZ3RoO1xuICAgICAgICAgIGsgPSBoLmNhbGwobCwgdGhpcyk7XG4gICAgICAgICAgaCA9IGEuc2VyaWVzO1xuICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSB0KGgudG9vbHRpcE9wdGlvbnMuZGlzdGFuY2UsIDE2KTtcbiAgICAgICAgICAhMSA9PT0gayA/IHRoaXMuaGlkZSgpIDogKHRoaXMuc3BsaXQgPyB0aGlzLnJlbmRlclNwbGl0KGssIEQoYykpIDogKGMgPSB0aGlzLmdldExhYmVsKCksIGYuc3R5bGUud2lkdGggJiYgIXcgfHwgYy5jc3Moe1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMuY2hhcnQuc3BhY2luZ0JveC53aWR0aFxuICAgICAgICAgIH0pLCBjLmF0dHIoe1xuICAgICAgICAgICAgdGV4dDogayAmJiBrLmpvaW4gPyBrLmpvaW4oXCJcIikgOiBrXG4gICAgICAgICAgfSksIGMucmVtb3ZlQ2xhc3MoL2hpZ2hjaGFydHMtY29sb3ItW1xcZF0rL2cpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1jb2xvci1cIiArIHQoYS5jb2xvckluZGV4LCBoLmNvbG9ySW5kZXgpKSwgdyB8fCBjLmF0dHIoe1xuICAgICAgICAgICAgc3Ryb2tlOiBmLmJvcmRlckNvbG9yIHx8IGEuY29sb3IgfHwgaC5jb2xvciB8fCBcIiM2NjY2NjZcIlxuICAgICAgICAgIH0pLCB0aGlzLnVwZGF0ZVBvc2l0aW9uKHtcbiAgICAgICAgICAgIHBsb3RYOiBlLFxuICAgICAgICAgICAgcGxvdFk6IHEsXG4gICAgICAgICAgICBuZWdhdGl2ZTogYS5uZWdhdGl2ZSxcbiAgICAgICAgICAgIHR0QmVsb3c6IGEudHRCZWxvdyxcbiAgICAgICAgICAgIGg6IEJbMl0gfHwgMFxuICAgICAgICAgIH0pKSwgdGhpcy5pc0hpZGRlbiAmJiB0aGlzLmxhYmVsICYmIHRoaXMubGFiZWwuYXR0cih7XG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSkuc2hvdygpLCB0aGlzLmlzSGlkZGVuID0gITEpO1xuICAgICAgICAgIGQuZmlyZUV2ZW50KHRoaXMsIFwicmVmcmVzaFwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUucmVuZGVyU3BsaXQgPSBmdW5jdGlvbiAoYywgZSkge1xuICAgICAgICBmdW5jdGlvbiBrKGIsIGEsIGMsIGYsIGUpIHtcbiAgICAgICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSAhMCk7XG4gICAgICAgICAgYyA/IChhID0gdSA/IDAgOiBBLCBiID0gcihiIC0gZiAvIDIsIE8ubGVmdCwgTy5yaWdodCAtIGYpKSA6IChhIC09IG0sIGIgPSBlID8gYiAtIGYgLSBDIDogYiArIEMsIGIgPSByKGIsIGUgPyBiIDogTy5sZWZ0LCBPLnJpZ2h0KSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGIsXG4gICAgICAgICAgICB5OiBhXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmID0gdGhpcyxcbiAgICAgICAgICAgIGEgPSBmLmNoYXJ0LFxuICAgICAgICAgICAgbCA9IGYuY2hhcnQsXG4gICAgICAgICAgICB2ID0gbC5wbG90SGVpZ2h0LFxuICAgICAgICAgICAgaCA9IGwucGxvdExlZnQsXG4gICAgICAgICAgICB3ID0gbC5wbG90VG9wLFxuICAgICAgICAgICAgQiA9IGwucG9pbnRlcixcbiAgICAgICAgICAgIHEgPSBsLnJlbmRlcmVyLFxuICAgICAgICAgICAgZyA9IGwuc2Nyb2xsYWJsZVBpeGVsc1ksXG4gICAgICAgICAgICBIID0gdm9pZCAwID09PSBnID8gMCA6IGc7XG4gICAgICAgIGcgPSBsLnNjcm9sbGluZ0NvbnRhaW5lcjtcbiAgICAgICAgZyA9IHZvaWQgMCA9PT0gZyA/IHtcbiAgICAgICAgICBzY3JvbGxMZWZ0OiAwLFxuICAgICAgICAgIHNjcm9sbFRvcDogMFxuICAgICAgICB9IDogZztcbiAgICAgICAgdmFyIEsgPSBnLnNjcm9sbExlZnQsXG4gICAgICAgICAgICBwID0gZy5zY3JvbGxUb3AsXG4gICAgICAgICAgICBiID0gbC5zdHlsZWRNb2RlLFxuICAgICAgICAgICAgQyA9IGYuZGlzdGFuY2UsXG4gICAgICAgICAgICB4ID0gZi5vcHRpb25zLFxuICAgICAgICAgICAgUiA9IGYub3B0aW9ucy5wb3NpdGlvbmVyLFxuICAgICAgICAgICAgTyA9IHtcbiAgICAgICAgICBsZWZ0OiBLLFxuICAgICAgICAgIHJpZ2h0OiBLICsgbC5jaGFydFdpZHRoLFxuICAgICAgICAgIHRvcDogcCxcbiAgICAgICAgICBib3R0b206IHAgKyBsLmNoYXJ0SGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgICAgICB5ID0gZi5nZXRMYWJlbCgpLFxuICAgICAgICAgICAgdSA9ICEoIWEueEF4aXNbMF0gfHwgIWEueEF4aXNbMF0ub3Bwb3NpdGUpLFxuICAgICAgICAgICAgbSA9IHcgKyBwLFxuICAgICAgICAgICAgRCA9IDAsXG4gICAgICAgICAgICBBID0gdiAtIEg7XG4gICAgICAgIEooYykgJiYgKGMgPSBbITEsIGNdKTtcbiAgICAgICAgYyA9IGMuc2xpY2UoMCwgZS5sZW5ndGggKyAxKS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGMsIGwpIHtcbiAgICAgICAgICBpZiAoITEgIT09IGMgJiYgXCJcIiAhPT0gYykge1xuICAgICAgICAgICAgbCA9IGVbbCAtIDFdIHx8IHtcbiAgICAgICAgICAgICAgaXNIZWFkZXI6ICEwLFxuICAgICAgICAgICAgICBwbG90WDogZVswXS5wbG90WCxcbiAgICAgICAgICAgICAgcGxvdFk6IHYsXG4gICAgICAgICAgICAgIHNlcmllczoge31cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZCA9IGwuaXNIZWFkZXIsXG4gICAgICAgICAgICAgICAgbiA9IGQgPyBmIDogbC5zZXJpZXMsXG4gICAgICAgICAgICAgICAgRiA9IG4udHQsXG4gICAgICAgICAgICAgICAgeiA9IGwuaXNIZWFkZXI7XG4gICAgICAgICAgICB2YXIgQiA9IGwuc2VyaWVzO1xuICAgICAgICAgICAgdmFyIGcgPSBcImhpZ2hjaGFydHMtY29sb3ItXCIgKyB0KGwuY29sb3JJbmRleCwgQi5jb2xvckluZGV4LCBcIm5vbmVcIik7XG4gICAgICAgICAgICBGIHx8IChGID0ge1xuICAgICAgICAgICAgICBwYWRkaW5nOiB4LnBhZGRpbmcsXG4gICAgICAgICAgICAgIHI6IHguYm9yZGVyUmFkaXVzXG4gICAgICAgICAgICB9LCBiIHx8IChGLmZpbGwgPSB4LmJhY2tncm91bmRDb2xvciwgRltcInN0cm9rZS13aWR0aFwiXSA9IHguYm9yZGVyV2lkdGgpLCBGID0gcS5sYWJlbChcIlwiLCAwLCAwLCB4W3ogPyBcImhlYWRlclNoYXBlXCIgOiBcInNoYXBlXCJdIHx8IFwiY2FsbG91dFwiLCB2b2lkIDAsIHZvaWQgMCwgeC51c2VIVE1MKS5hZGRDbGFzcygoeiA/IFwiaGlnaGNoYXJ0cy10b29sdGlwLWhlYWRlciBcIiA6IFwiXCIpICsgXCJoaWdoY2hhcnRzLXRvb2x0aXAtYm94IFwiICsgZykuYXR0cihGKS5hZGQoeSkpO1xuICAgICAgICAgICAgRi5pc0FjdGl2ZSA9ICEwO1xuICAgICAgICAgICAgRi5hdHRyKHtcbiAgICAgICAgICAgICAgdGV4dDogY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBiIHx8IEYuY3NzKHguc3R5bGUpLnNoYWRvdyh4LnNoYWRvdykuYXR0cih7XG4gICAgICAgICAgICAgIHN0cm9rZTogeC5ib3JkZXJDb2xvciB8fCBsLmNvbG9yIHx8IEIuY29sb3IgfHwgXCIjMzMzMzMzXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYyA9IG4udHQgPSBGO1xuICAgICAgICAgICAgeiA9IGMuZ2V0QkJveCgpO1xuICAgICAgICAgICAgbiA9IHoud2lkdGggKyBjLnN0cm9rZVdpZHRoKCk7XG4gICAgICAgICAgICBkICYmIChEID0gei5oZWlnaHQsIEEgKz0gRCwgdSAmJiAobSAtPSBEKSk7XG4gICAgICAgICAgICBCID0gbC5wbG90WDtcbiAgICAgICAgICAgIEIgPSB2b2lkIDAgPT09IEIgPyAwIDogQjtcbiAgICAgICAgICAgIGcgPSBsLnBsb3RZO1xuICAgICAgICAgICAgZyA9IHZvaWQgMCA9PT0gZyA/IDAgOiBnO1xuICAgICAgICAgICAgdmFyIEwgPSBsLnNlcmllcztcblxuICAgICAgICAgICAgaWYgKGwuaXNIZWFkZXIpIHtcbiAgICAgICAgICAgICAgQiA9IGggKyBCO1xuICAgICAgICAgICAgICB2YXIgSyA9IHcgKyB2IC8gMjtcbiAgICAgICAgICAgIH0gZWxzZSBGID0gTC54QXhpcywgTCA9IEwueUF4aXMsIEIgPSBGLnBvcyArIHIoQiwgLUMsIEYubGVuICsgQyksIEwucG9zICsgZyA+PSBwICsgdyAmJiBMLnBvcyArIGcgPD0gcCArIHcgKyB2IC0gSCAmJiAoSyA9IEwucG9zICsgZyk7XG5cbiAgICAgICAgICAgIEIgPSByKEIsIE8ubGVmdCAtIEMsIE8ucmlnaHQgKyBDKTtcbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBLID8gKHogPSB6LmhlaWdodCArIDEsIGcgPSBSID8gUi5jYWxsKGYsIG4sIHosIGwpIDogayhCLCBLLCBkLCBuKSwgYS5wdXNoKHtcbiAgICAgICAgICAgICAgYWxpZ246IFIgPyAwIDogdm9pZCAwLFxuICAgICAgICAgICAgICBhbmNob3JYOiBCLFxuICAgICAgICAgICAgICBhbmNob3JZOiBLLFxuICAgICAgICAgICAgICBib3hXaWR0aDogbixcbiAgICAgICAgICAgICAgcG9pbnQ6IGwsXG4gICAgICAgICAgICAgIHJhbms6IHQoZy5yYW5rLCBkID8gMSA6IDApLFxuICAgICAgICAgICAgICBzaXplOiB6LFxuICAgICAgICAgICAgICB0YXJnZXQ6IGcueSxcbiAgICAgICAgICAgICAgdHQ6IGMsXG4gICAgICAgICAgICAgIHg6IGcueFxuICAgICAgICAgICAgfSkpIDogYy5pc0FjdGl2ZSA9ICExO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgICFSICYmIGMuc29tZShmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHJldHVybiBiLnggPCBPLmxlZnQ7XG4gICAgICAgIH0pICYmIChjID0gYy5tYXAoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICB2YXIgYSA9IGsoYi5hbmNob3JYLCBiLmFuY2hvclksIGIucG9pbnQuaXNIZWFkZXIsIGIuYm94V2lkdGgsICExKTtcbiAgICAgICAgICByZXR1cm4gRShiLCB7XG4gICAgICAgICAgICB0YXJnZXQ6IGEueSxcbiAgICAgICAgICAgIHg6IGEueFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgICAgIGYuY2xlYW5TcGxpdCgpO1xuICAgICAgICBkLmRpc3RyaWJ1dGUoYywgQSk7XG4gICAgICAgIGMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHZhciBhID0gYi5wb3M7XG4gICAgICAgICAgYi50dC5hdHRyKHtcbiAgICAgICAgICAgIHZpc2liaWxpdHk6IFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBhID8gXCJoaWRkZW5cIiA6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgeDogYi54LFxuICAgICAgICAgICAgeTogYSArIG0sXG4gICAgICAgICAgICBhbmNob3JYOiBiLmFuY2hvclgsXG4gICAgICAgICAgICBhbmNob3JZOiBiLmFuY2hvcllcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGMgPSBmLmNvbnRhaW5lcjtcbiAgICAgICAgYSA9IGYucmVuZGVyZXI7XG4gICAgICAgIGYub3V0c2lkZSAmJiBjICYmIGEgJiYgKGwgPSB5LmdldEJCb3goKSwgYS5zZXRTaXplKGwud2lkdGggKyBsLngsIGwuaGVpZ2h0ICsgbC55LCAhMSksIEIgPSBCLmdldENoYXJ0UG9zaXRpb24oKSwgYy5zdHlsZS5sZWZ0ID0gQi5sZWZ0ICsgXCJweFwiLCBjLnN0eWxlLnRvcCA9IEIudG9wICsgXCJweFwiKTtcbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLmRyYXdUcmFja2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5mb2xsb3dQb2ludGVyIHx8ICF0aGlzLm9wdGlvbnMuc3RpY2tPbkNvbnRhY3QpIHRoaXMudHJhY2tlciAmJiB0aGlzLnRyYWNrZXIuZGVzdHJveSgpO2Vsc2Uge1xuICAgICAgICAgIHZhciBjID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgICAgZSA9IHRoaXMubGFiZWwsXG4gICAgICAgICAgICAgIGQgPSBjLmhvdmVyUG9pbnQ7XG5cbiAgICAgICAgICBpZiAoZSAmJiBkKSB7XG4gICAgICAgICAgICB2YXIgZiA9IHtcbiAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGQgPSB0aGlzLmdldEFuY2hvcihkKTtcbiAgICAgICAgICAgIHZhciBhID0gZS5nZXRCQm94KCk7XG4gICAgICAgICAgICBkWzBdICs9IGMucGxvdExlZnQgLSBlLnRyYW5zbGF0ZVg7XG4gICAgICAgICAgICBkWzFdICs9IGMucGxvdFRvcCAtIGUudHJhbnNsYXRlWTtcbiAgICAgICAgICAgIGYueCA9IE1hdGgubWluKDAsIGRbMF0pO1xuICAgICAgICAgICAgZi55ID0gTWF0aC5taW4oMCwgZFsxXSk7XG4gICAgICAgICAgICBmLndpZHRoID0gMCA+IGRbMF0gPyBNYXRoLm1heChNYXRoLmFicyhkWzBdKSwgYS53aWR0aCAtIGRbMF0pIDogTWF0aC5tYXgoTWF0aC5hYnMoZFswXSksIGEud2lkdGgpO1xuICAgICAgICAgICAgZi5oZWlnaHQgPSAwID4gZFsxXSA/IE1hdGgubWF4KE1hdGguYWJzKGRbMV0pLCBhLmhlaWdodCAtIE1hdGguYWJzKGRbMV0pKSA6IE1hdGgubWF4KE1hdGguYWJzKGRbMV0pLCBhLmhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLnRyYWNrZXIgPyB0aGlzLnRyYWNrZXIuYXR0cihmKSA6ICh0aGlzLnRyYWNrZXIgPSBlLnJlbmRlcmVyLnJlY3QoZikuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikuYWRkKGUpLCBjLnN0eWxlZE1vZGUgfHwgdGhpcy50cmFja2VyLmF0dHIoe1xuICAgICAgICAgICAgICBmaWxsOiBcInJnYmEoMCwwLDAsMClcIlxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUuc3R5bGVkTW9kZUZvcm1hdCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjLnJlcGxhY2UoJ3N0eWxlPVwiZm9udC1zaXplOiAxMHB4XCInLCAnY2xhc3M9XCJoaWdoY2hhcnRzLWhlYWRlclwiJykucmVwbGFjZSgvc3R5bGU9XCJjb2xvcjp7KHBvaW50fHNlcmllcylcXC5jb2xvcn1cIi9nLCAnY2xhc3M9XCJoaWdoY2hhcnRzLWNvbG9yLXskMS5jb2xvckluZGV4fVwiJyk7XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS50b29sdGlwRm9vdGVySGVhZGVyRm9ybWF0dGVyID0gZnVuY3Rpb24gKGMsIGUpIHtcbiAgICAgICAgdmFyIGsgPSBlID8gXCJmb290ZXJcIiA6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBmID0gYy5zZXJpZXMsXG4gICAgICAgICAgICBhID0gZi50b29sdGlwT3B0aW9ucyxcbiAgICAgICAgICAgIGwgPSBhLnhEYXRlRm9ybWF0LFxuICAgICAgICAgICAgdiA9IGYueEF4aXMsXG4gICAgICAgICAgICBoID0gdiAmJiBcImRhdGV0aW1lXCIgPT09IHYub3B0aW9ucy50eXBlICYmIEcoYy5rZXkpLFxuICAgICAgICAgICAgdyA9IGFbayArIFwiRm9ybWF0XCJdO1xuICAgICAgICBlID0ge1xuICAgICAgICAgIGlzRm9vdGVyOiBlLFxuICAgICAgICAgIGxhYmVsQ29uZmlnOiBjXG4gICAgICAgIH07XG4gICAgICAgIGQuZmlyZUV2ZW50KHRoaXMsIFwiaGVhZGVyRm9ybWF0dGVyXCIsIGUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaCAmJiAhbCAmJiAobCA9IHRoaXMuZ2V0WERhdGVGb3JtYXQoYywgYSwgdikpO1xuICAgICAgICAgIGggJiYgbCAmJiAoYy5wb2ludCAmJiBjLnBvaW50LnRvb2x0aXBEYXRlS2V5cyB8fCBbXCJrZXlcIl0pLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHcgPSB3LnJlcGxhY2UoXCJ7cG9pbnQuXCIgKyBhICsgXCJ9XCIsIFwie3BvaW50LlwiICsgYSArIFwiOlwiICsgbCArIFwifVwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmLmNoYXJ0LnN0eWxlZE1vZGUgJiYgKHcgPSB0aGlzLnN0eWxlZE1vZGVGb3JtYXQodykpO1xuICAgICAgICAgIGUudGV4dCA9IEEodywge1xuICAgICAgICAgICAgcG9pbnQ6IGMsXG4gICAgICAgICAgICBzZXJpZXM6IGZcbiAgICAgICAgICB9LCB0aGlzLmNoYXJ0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlLnRleHQ7XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgeSghMCwgdGhpcy5jaGFydC5vcHRpb25zLnRvb2x0aXAudXNlck9wdGlvbnMsIGMpO1xuICAgICAgICB0aGlzLmluaXQodGhpcy5jaGFydCwgeSghMCwgdGhpcy5vcHRpb25zLCBjKSk7XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS51cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGQgPSBlLnBvaW50ZXIsXG4gICAgICAgICAgICBmID0gdGhpcy5nZXRMYWJlbCgpLFxuICAgICAgICAgICAgYSA9IGMucGxvdFggKyBlLnBsb3RMZWZ0LFxuICAgICAgICAgICAgbCA9IGMucGxvdFkgKyBlLnBsb3RUb3A7XG4gICAgICAgIGQgPSBkLmdldENoYXJ0UG9zaXRpb24oKTtcbiAgICAgICAgYyA9ICh0aGlzLm9wdGlvbnMucG9zaXRpb25lciB8fCB0aGlzLmdldFBvc2l0aW9uKS5jYWxsKHRoaXMsIGYud2lkdGgsIGYuaGVpZ2h0LCBjKTtcblxuICAgICAgICBpZiAodGhpcy5vdXRzaWRlKSB7XG4gICAgICAgICAgdmFyIHYgPSAodGhpcy5vcHRpb25zLmJvcmRlcldpZHRoIHx8IDApICsgMiAqIHRoaXMuZGlzdGFuY2U7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKGYud2lkdGggKyB2LCBmLmhlaWdodCArIHYsICExKTtcbiAgICAgICAgICBpZiAoZSA9IGUuY29udGFpbmVyU2NhbGluZykgdSh0aGlzLmNvbnRhaW5lciwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKFwiICsgZS5zY2FsZVggKyBcIiwgXCIgKyBlLnNjYWxlWSArIFwiKVwiXG4gICAgICAgICAgfSksIGEgKj0gZS5zY2FsZVgsIGwgKj0gZS5zY2FsZVk7XG4gICAgICAgICAgYSArPSBkLmxlZnQgLSBjLng7XG4gICAgICAgICAgbCArPSBkLnRvcCAtIGMueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW92ZShNYXRoLnJvdW5kKGMueCksIE1hdGgucm91bmQoYy55IHx8IDApLCBhLCBsKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBlO1xuICAgIH0oKTtcblxuICAgIGQuVG9vbHRpcCA9IFA7XG4gICAgcmV0dXJuIGQuVG9vbHRpcDtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9Qb2ludGVyLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXSwgcltcInBhcnRzL1Rvb2x0aXAuanNcIl0sIHJbXCJwYXJ0cy9Db2xvci5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnLCByLCB1KSB7XG4gICAgdmFyIEkgPSBnLmFkZEV2ZW50LFxuICAgICAgICBNID0gZy5hdHRyLFxuICAgICAgICBFID0gZy5jc3MsXG4gICAgICAgIEEgPSBnLmRlZmluZWQsXG4gICAgICAgIEcgPSBnLmV4dGVuZCxcbiAgICAgICAgSiA9IGcuZmluZCxcbiAgICAgICAgeSA9IGcuZmlyZUV2ZW50LFxuICAgICAgICB0ID0gZy5pc051bWJlcixcbiAgICAgICAgRCA9IGcuaXNPYmplY3QsXG4gICAgICAgIGggPSBnLm9iamVjdEVhY2gsXG4gICAgICAgIE4gPSBnLm9mZnNldCxcbiAgICAgICAgcSA9IGcucGljayxcbiAgICAgICAgUCA9IGcuc3BsYXQsXG4gICAgICAgIGUgPSB1LnBhcnNlLFxuICAgICAgICBjID0gZC5jaGFydHMsXG4gICAgICAgIGsgPSBkLm5vb3A7XG5cbiAgICBnID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gbihjLCBhKSB7XG4gICAgICAgIHRoaXMubGFzdFZhbGlkVG91Y2ggPSB7fTtcbiAgICAgICAgdGhpcy5waW5jaERvd24gPSBbXTtcbiAgICAgICAgdGhpcy5ydW5DaGFydENsaWNrID0gITE7XG4gICAgICAgIHRoaXMuY2hhcnQgPSBjO1xuICAgICAgICB0aGlzLmhhc0RyYWdnZWQgPSAhMTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gYTtcblxuICAgICAgICB0aGlzLnVuYmluZENvbnRhaW5lck1vdXNlTGVhdmUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgICB0aGlzLmluaXQoYywgYSk7XG4gICAgICB9XG5cbiAgICAgIG4ucHJvdG90eXBlLmFwcGx5SW5hY3RpdmVTdGF0ZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBhID0gW10sXG4gICAgICAgICAgICBmO1xuICAgICAgICAoYyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGYgPSBjLnNlcmllcztcbiAgICAgICAgICBhLnB1c2goZik7XG4gICAgICAgICAgZi5saW5rZWRQYXJlbnQgJiYgYS5wdXNoKGYubGlua2VkUGFyZW50KTtcbiAgICAgICAgICBmLmxpbmtlZFNlcmllcyAmJiAoYSA9IGEuY29uY2F0KGYubGlua2VkU2VyaWVzKSk7XG4gICAgICAgICAgZi5uYXZpZ2F0b3JTZXJpZXMgJiYgYS5wdXNoKGYubmF2aWdhdG9yU2VyaWVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2hhcnQuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAtMSA9PT0gYS5pbmRleE9mKGMpID8gYy5zZXRTdGF0ZShcImluYWN0aXZlXCIsICEwKSA6IGMub3B0aW9ucy5pbmFjdGl2ZU90aGVyUG9pbnRzICYmIGMuc2V0QWxsUG9pbnRzVG9TdGF0ZShcImluYWN0aXZlXCIpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjID0gdGhpcztcbiAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGMudW5Eb2NNb3VzZU1vdmUgJiYgYy51bkRvY01vdXNlTW92ZSgpO1xuICAgICAgICB0aGlzLnVuYmluZENvbnRhaW5lck1vdXNlTGVhdmUoKTtcbiAgICAgICAgZC5jaGFydENvdW50IHx8IChkLnVuYmluZERvY3VtZW50TW91c2VVcCAmJiAoZC51bmJpbmREb2N1bWVudE1vdXNlVXAgPSBkLnVuYmluZERvY3VtZW50TW91c2VVcCgpKSwgZC51bmJpbmREb2N1bWVudFRvdWNoRW5kICYmIChkLnVuYmluZERvY3VtZW50VG91Y2hFbmQgPSBkLnVuYmluZERvY3VtZW50VG91Y2hFbmQoKSkpO1xuICAgICAgICBjbGVhckludGVydmFsKGMudG9vbHRpcFRpbWVvdXQpO1xuICAgICAgICBoKGMsIGZ1bmN0aW9uIChhLCBmKSB7XG4gICAgICAgICAgY1tmXSA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUuZHJhZyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGYgPSBhLm9wdGlvbnMuY2hhcnQsXG4gICAgICAgICAgICBkID0gYy5jaGFydFgsXG4gICAgICAgICAgICBrID0gYy5jaGFydFksXG4gICAgICAgICAgICB3ID0gdGhpcy56b29tSG9yLFxuICAgICAgICAgICAgbiA9IHRoaXMuem9vbVZlcnQsXG4gICAgICAgICAgICBoID0gYS5wbG90TGVmdCxcbiAgICAgICAgICAgIHEgPSBhLnBsb3RUb3AsXG4gICAgICAgICAgICBnID0gYS5wbG90V2lkdGgsXG4gICAgICAgICAgICB0ID0gYS5wbG90SGVpZ2h0LFxuICAgICAgICAgICAgcCA9IHRoaXMuc2VsZWN0aW9uTWFya2VyLFxuICAgICAgICAgICAgYiA9IHRoaXMubW91c2VEb3duWCB8fCAwLFxuICAgICAgICAgICAgQyA9IHRoaXMubW91c2VEb3duWSB8fCAwLFxuICAgICAgICAgICAgeCA9IEQoZi5wYW5uaW5nKSA/IGYucGFubmluZyAmJiBmLnBhbm5pbmcuZW5hYmxlZCA6IGYucGFubmluZyxcbiAgICAgICAgICAgIHkgPSBmLnBhbktleSAmJiBjW2YucGFuS2V5ICsgXCJLZXlcIl07XG4gICAgICAgIGlmICghcCB8fCAhcC50b3VjaCkgaWYgKGQgPCBoID8gZCA9IGggOiBkID4gaCArIGcgJiYgKGQgPSBoICsgZyksIGsgPCBxID8gayA9IHEgOiBrID4gcSArIHQgJiYgKGsgPSBxICsgdCksIHRoaXMuaGFzRHJhZ2dlZCA9IE1hdGguc3FydChNYXRoLnBvdyhiIC0gZCwgMikgKyBNYXRoLnBvdyhDIC0gaywgMikpLCAxMCA8IHRoaXMuaGFzRHJhZ2dlZCkge1xuICAgICAgICAgIHZhciBPID0gYS5pc0luc2lkZVBsb3QoYiAtIGgsIEMgLSBxKTtcbiAgICAgICAgICBhLmhhc0NhcnRlc2lhblNlcmllcyAmJiAodGhpcy56b29tWCB8fCB0aGlzLnpvb21ZKSAmJiBPICYmICF5ICYmICFwICYmICh0aGlzLnNlbGVjdGlvbk1hcmtlciA9IHAgPSBhLnJlbmRlcmVyLnJlY3QoaCwgcSwgdyA/IDEgOiBnLCBuID8gMSA6IHQsIDApLmF0dHIoe1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBcImhpZ2hjaGFydHMtc2VsZWN0aW9uLW1hcmtlclwiLFxuICAgICAgICAgICAgekluZGV4OiA3XG4gICAgICAgICAgfSkuYWRkKCksIGEuc3R5bGVkTW9kZSB8fCBwLmF0dHIoe1xuICAgICAgICAgICAgZmlsbDogZi5zZWxlY3Rpb25NYXJrZXJGaWxsIHx8IGUoXCIjMzM1Y2FkXCIpLnNldE9wYWNpdHkoLjI1KS5nZXQoKVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBwICYmIHcgJiYgKGQgLT0gYiwgcC5hdHRyKHtcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLmFicyhkKSxcbiAgICAgICAgICAgIHg6ICgwIDwgZCA/IDAgOiBkKSArIGJcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcCAmJiBuICYmIChkID0gayAtIEMsIHAuYXR0cih7XG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGguYWJzKGQpLFxuICAgICAgICAgICAgeTogKDAgPCBkID8gMCA6IGQpICsgQ1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBPICYmICFwICYmIHggJiYgYS5wYW4oYywgZi5wYW5uaW5nKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUuZHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNoYXJ0O1xuICAgICAgICBhLm1vdXNlSXNEb3duID0gYy50eXBlO1xuICAgICAgICBhLmNhbmNlbENsaWNrID0gITE7XG4gICAgICAgIGEubW91c2VEb3duWCA9IHRoaXMubW91c2VEb3duWCA9IGMuY2hhcnRYO1xuICAgICAgICBhLm1vdXNlRG93blkgPSB0aGlzLm1vdXNlRG93blkgPSBjLmNoYXJ0WTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLmRyb3AgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICBmID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGUgPSB0aGlzLmhhc1BpbmNoZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTWFya2VyKSB7XG4gICAgICAgICAgdmFyIGQgPSB7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBjLFxuICAgICAgICAgICAgeEF4aXM6IFtdLFxuICAgICAgICAgICAgeUF4aXM6IFtdXG4gICAgICAgICAgfSxcbiAgICAgICAgICAgICAgayA9IHRoaXMuc2VsZWN0aW9uTWFya2VyLFxuICAgICAgICAgICAgICBuID0gay5hdHRyID8gay5hdHRyKFwieFwiKSA6IGsueCxcbiAgICAgICAgICAgICAgaCA9IGsuYXR0ciA/IGsuYXR0cihcInlcIikgOiBrLnksXG4gICAgICAgICAgICAgIHEgPSBrLmF0dHIgPyBrLmF0dHIoXCJ3aWR0aFwiKSA6IGsud2lkdGgsXG4gICAgICAgICAgICAgIGcgPSBrLmF0dHIgPyBrLmF0dHIoXCJoZWlnaHRcIikgOiBrLmhlaWdodCxcbiAgICAgICAgICAgICAgSztcbiAgICAgICAgICBpZiAodGhpcy5oYXNEcmFnZ2VkIHx8IGUpIGYuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICBpZiAoZi56b29tRW5hYmxlZCAmJiBBKGYubWluKSAmJiAoZSB8fCBhW3tcbiAgICAgICAgICAgICAgeEF4aXM6IFwiem9vbVhcIixcbiAgICAgICAgICAgICAgeUF4aXM6IFwiem9vbVlcIlxuICAgICAgICAgICAgfVtmLmNvbGxdXSkpIHtcbiAgICAgICAgICAgICAgdmFyIGIgPSBmLmhvcml6LFxuICAgICAgICAgICAgICAgICAgbCA9IFwidG91Y2hlbmRcIiA9PT0gYy50eXBlID8gZi5taW5QaXhlbFBhZGRpbmcgOiAwLFxuICAgICAgICAgICAgICAgICAgayA9IGYudG9WYWx1ZSgoYiA/IG4gOiBoKSArIGwpO1xuICAgICAgICAgICAgICBiID0gZi50b1ZhbHVlKChiID8gbiArIHEgOiBoICsgZykgLSBsKTtcbiAgICAgICAgICAgICAgZFtmLmNvbGxdLnB1c2goe1xuICAgICAgICAgICAgICAgIGF4aXM6IGYsXG4gICAgICAgICAgICAgICAgbWluOiBNYXRoLm1pbihrLCBiKSxcbiAgICAgICAgICAgICAgICBtYXg6IE1hdGgubWF4KGssIGIpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBLID0gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIEsgJiYgeShmLCBcInNlbGVjdGlvblwiLCBkLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZi56b29tKEcoYSwgZSA/IHtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uOiAhMVxuICAgICAgICAgICAgfSA6IG51bGwpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0KGYuaW5kZXgpICYmICh0aGlzLnNlbGVjdGlvbk1hcmtlciA9IHRoaXMuc2VsZWN0aW9uTWFya2VyLmRlc3Ryb3koKSk7XG4gICAgICAgICAgZSAmJiB0aGlzLnNjYWxlR3JvdXBzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmICYmIHQoZi5pbmRleCkgJiYgKEUoZi5jb250YWluZXIsIHtcbiAgICAgICAgICBjdXJzb3I6IGYuX2N1cnNvclxuICAgICAgICB9KSwgZi5jYW5jZWxDbGljayA9IDEwIDwgdGhpcy5oYXNEcmFnZ2VkLCBmLm1vdXNlSXNEb3duID0gdGhpcy5oYXNEcmFnZ2VkID0gdGhpcy5oYXNQaW5jaGVkID0gITEsIHRoaXMucGluY2hEb3duID0gW10pO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUuZmluZE5lYXJlc3RLRFBvaW50ID0gZnVuY3Rpb24gKGMsIGEsIGUpIHtcbiAgICAgICAgdmFyIGYgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZCA9IGYuaG92ZXJQb2ludDtcbiAgICAgICAgZiA9IGYudG9vbHRpcDtcbiAgICAgICAgaWYgKGQgJiYgZiAmJiBmLmlzU3RpY2t5T25Db250YWN0KCkpIHJldHVybiBkO1xuICAgICAgICB2YXIgbDtcbiAgICAgICAgYy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgdmFyIGYgPSAhKGMubm9TaGFyZWRUb29sdGlwICYmIGEpICYmIDAgPiBjLm9wdGlvbnMuZmluZE5lYXJlc3RQb2ludEJ5LmluZGV4T2YoXCJ5XCIpO1xuICAgICAgICAgIGMgPSBjLnNlYXJjaFBvaW50KGUsIGYpO1xuXG4gICAgICAgICAgaWYgKChmID0gRChjLCAhMCkpICYmICEoZiA9ICFEKGwsICEwKSkpIHtcbiAgICAgICAgICAgIGYgPSBsLmRpc3RYIC0gYy5kaXN0WDtcbiAgICAgICAgICAgIHZhciBkID0gbC5kaXN0IC0gYy5kaXN0LFxuICAgICAgICAgICAgICAgIGsgPSAoYy5zZXJpZXMuZ3JvdXAgJiYgYy5zZXJpZXMuZ3JvdXAuekluZGV4KSAtIChsLnNlcmllcy5ncm91cCAmJiBsLnNlcmllcy5ncm91cC56SW5kZXgpO1xuICAgICAgICAgICAgZiA9IDAgPCAoMCAhPT0gZiAmJiBhID8gZiA6IDAgIT09IGQgPyBkIDogMCAhPT0gayA/IGsgOiBsLnNlcmllcy5pbmRleCA+IGMuc2VyaWVzLmluZGV4ID8gLTEgOiAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmICYmIChsID0gYyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbDtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLmdldENoYXJ0Q29vcmRpbmF0ZXNGcm9tUG9pbnQgPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICB2YXIgZiA9IGMuc2VyaWVzLFxuICAgICAgICAgICAgZSA9IGYueEF4aXM7XG4gICAgICAgIGYgPSBmLnlBeGlzO1xuICAgICAgICB2YXIgZCA9IHEoYy5jbGllbnRYLCBjLnBsb3RYKSxcbiAgICAgICAgICAgIGsgPSBjLnNoYXBlQXJncztcbiAgICAgICAgaWYgKGUgJiYgZikgcmV0dXJuIGEgPyB7XG4gICAgICAgICAgY2hhcnRYOiBlLmxlbiArIGUucG9zIC0gZCxcbiAgICAgICAgICBjaGFydFk6IGYubGVuICsgZi5wb3MgLSBjLnBsb3RZXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgY2hhcnRYOiBkICsgZS5wb3MsXG4gICAgICAgICAgY2hhcnRZOiBjLnBsb3RZICsgZi5wb3NcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGsgJiYgay54ICYmIGsueSkgcmV0dXJuIHtcbiAgICAgICAgICBjaGFydFg6IGsueCxcbiAgICAgICAgICBjaGFydFk6IGsueVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUuZ2V0Q2hhcnRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhcnRQb3NpdGlvbiB8fCAodGhpcy5jaGFydFBvc2l0aW9uID0gTih0aGlzLmNoYXJ0LmNvbnRhaW5lcikpO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgYSA9IHtcbiAgICAgICAgICB4QXhpczogW10sXG4gICAgICAgICAgeUF4aXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hhcnQuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgYVtmLmlzWEF4aXMgPyBcInhBeGlzXCIgOiBcInlBeGlzXCJdLnB1c2goe1xuICAgICAgICAgICAgYXhpczogZixcbiAgICAgICAgICAgIHZhbHVlOiBmLnRvVmFsdWUoY1tmLmhvcml6ID8gXCJjaGFydFhcIiA6IFwiY2hhcnRZXCJdKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5nZXRIb3ZlckRhdGEgPSBmdW5jdGlvbiAoYywgYSwgZSwgZCwgaywgbikge1xuICAgICAgICB2YXIgZixcbiAgICAgICAgICAgIGwgPSBbXTtcbiAgICAgICAgZCA9ICEoIWQgfHwgIWMpO1xuICAgICAgICB2YXIgdiA9IGEgJiYgIWEuc3RpY2t5VHJhY2tpbmcsXG4gICAgICAgICAgICBoID0ge1xuICAgICAgICAgIGNoYXJ0WDogbiA/IG4uY2hhcnRYIDogdm9pZCAwLFxuICAgICAgICAgIGNoYXJ0WTogbiA/IG4uY2hhcnRZIDogdm9pZCAwLFxuICAgICAgICAgIHNoYXJlZDoga1xuICAgICAgICB9O1xuICAgICAgICB5KHRoaXMsIFwiYmVmb3JlR2V0SG92ZXJEYXRhXCIsIGgpO1xuICAgICAgICB2ID0gdiA/IFthXSA6IGUuZmlsdGVyKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgcmV0dXJuIGguZmlsdGVyID8gaC5maWx0ZXIoYSkgOiBhLnZpc2libGUgJiYgISghayAmJiBhLmRpcmVjdFRvdWNoKSAmJiBxKGEub3B0aW9ucy5lbmFibGVNb3VzZVRyYWNraW5nLCAhMCkgJiYgYS5zdGlja3lUcmFja2luZztcbiAgICAgICAgfSk7XG4gICAgICAgIGEgPSAoZiA9IGQgfHwgIW4gPyBjIDogdGhpcy5maW5kTmVhcmVzdEtEUG9pbnQodiwgaywgbikpICYmIGYuc2VyaWVzO1xuICAgICAgICBmICYmIChrICYmICFhLm5vU2hhcmVkVG9vbHRpcCA/ICh2ID0gZS5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICByZXR1cm4gaC5maWx0ZXIgPyBoLmZpbHRlcihhKSA6IGEudmlzaWJsZSAmJiAhKCFrICYmIGEuZGlyZWN0VG91Y2gpICYmIHEoYS5vcHRpb25zLmVuYWJsZU1vdXNlVHJhY2tpbmcsICEwKSAmJiAhYS5ub1NoYXJlZFRvb2x0aXA7XG4gICAgICAgIH0pLCB2LmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICB2YXIgYyA9IEooYS5wb2ludHMsIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi54ID09PSBmLnggJiYgIWIuaXNOdWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIEQoYykgJiYgKGEuY2hhcnQuaXNCb29zdGluZyAmJiAoYyA9IGEuZ2V0UG9pbnQoYykpLCBsLnB1c2goYykpO1xuICAgICAgICB9KSkgOiBsLnB1c2goZikpO1xuICAgICAgICBoID0ge1xuICAgICAgICAgIGhvdmVyUG9pbnQ6IGZcbiAgICAgICAgfTtcbiAgICAgICAgeSh0aGlzLCBcImFmdGVyR2V0SG92ZXJEYXRhXCIsIGgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhvdmVyUG9pbnQ6IGguaG92ZXJQb2ludCxcbiAgICAgICAgICBob3ZlclNlcmllczogYSxcbiAgICAgICAgICBob3ZlclBvaW50czogbFxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUuZ2V0UG9pbnRGcm9tRXZlbnQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBjID0gYy50YXJnZXQ7XG5cbiAgICAgICAgZm9yICh2YXIgYTsgYyAmJiAhYTspIGEgPSBjLnBvaW50LCBjID0gYy5wYXJlbnROb2RlO1xuXG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUub25UcmFja2VyTW91c2VPdXQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2hhcnQuaG92ZXJTZXJpZXM7XG4gICAgICAgIGMgPSBjLnJlbGF0ZWRUYXJnZXQgfHwgYy50b0VsZW1lbnQ7XG4gICAgICAgIHRoaXMuaXNEaXJlY3RUb3VjaCA9ICExO1xuICAgICAgICBpZiAoISghYSB8fCAhYyB8fCBhLnN0aWNreVRyYWNraW5nIHx8IHRoaXMuaW5DbGFzcyhjLCBcImhpZ2hjaGFydHMtdG9vbHRpcFwiKSB8fCB0aGlzLmluQ2xhc3MoYywgXCJoaWdoY2hhcnRzLXNlcmllcy1cIiArIGEuaW5kZXgpICYmIHRoaXMuaW5DbGFzcyhjLCBcImhpZ2hjaGFydHMtdHJhY2tlclwiKSkpIGEub25Nb3VzZU91dCgpO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUuaW5DbGFzcyA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIGZvciAodmFyIGY7IGM7KSB7XG4gICAgICAgICAgaWYgKGYgPSBNKGMsIFwiY2xhc3NcIikpIHtcbiAgICAgICAgICAgIGlmICgtMSAhPT0gZi5pbmRleE9mKGEpKSByZXR1cm4gITA7XG4gICAgICAgICAgICBpZiAoLTEgIT09IGYuaW5kZXhPZihcImhpZ2hjaGFydHMtY29udGFpbmVyXCIpKSByZXR1cm4gITE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYyA9IGMucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGE7XG4gICAgICAgIHRoaXMuY2hhcnQgPSBjO1xuICAgICAgICB0aGlzLnJ1bkNoYXJ0Q2xpY2sgPSBhLmNoYXJ0LmV2ZW50cyAmJiAhIWEuY2hhcnQuZXZlbnRzLmNsaWNrO1xuICAgICAgICB0aGlzLnBpbmNoRG93biA9IFtdO1xuICAgICAgICB0aGlzLmxhc3RWYWxpZFRvdWNoID0ge307XG4gICAgICAgIHIgJiYgKGMudG9vbHRpcCA9IG5ldyByKGMsIGEudG9vbHRpcCksIHRoaXMuZm9sbG93VG91Y2hNb3ZlID0gcShhLnRvb2x0aXAuZm9sbG93VG91Y2hNb3ZlLCAhMCkpO1xuICAgICAgICB0aGlzLnNldERPTUV2ZW50cygpO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgdmFyIGYgPSBjLnRvdWNoZXMsXG4gICAgICAgICAgICBlID0gZiA/IGYubGVuZ3RoID8gZi5pdGVtKDApIDogZi5jaGFuZ2VkVG91Y2hlc1swXSA6IGM7XG4gICAgICAgIGEgfHwgKGEgPSB0aGlzLmdldENoYXJ0UG9zaXRpb24oKSk7XG4gICAgICAgIGYgPSBlLnBhZ2VYIC0gYS5sZWZ0O1xuICAgICAgICBhID0gZS5wYWdlWSAtIGEudG9wO1xuICAgICAgICBpZiAoZSA9IHRoaXMuY2hhcnQuY29udGFpbmVyU2NhbGluZykgZiAvPSBlLnNjYWxlWCwgYSAvPSBlLnNjYWxlWTtcbiAgICAgICAgcmV0dXJuIEcoYywge1xuICAgICAgICAgIGNoYXJ0WDogTWF0aC5yb3VuZChmKSxcbiAgICAgICAgICBjaGFydFk6IE1hdGgucm91bmQoYSlcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5vbkNvbnRhaW5lckNsaWNrID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZiA9IGEuaG92ZXJQb2ludCxcbiAgICAgICAgICAgIGUgPSBhLnBsb3RMZWZ0LFxuICAgICAgICAgICAgZCA9IGEucGxvdFRvcDtcbiAgICAgICAgYyA9IHRoaXMubm9ybWFsaXplKGMpO1xuICAgICAgICBhLmNhbmNlbENsaWNrIHx8IChmICYmIHRoaXMuaW5DbGFzcyhjLnRhcmdldCwgXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikgPyAoeShmLnNlcmllcywgXCJjbGlja1wiLCBHKGMsIHtcbiAgICAgICAgICBwb2ludDogZlxuICAgICAgICB9KSksIGEuaG92ZXJQb2ludCAmJiBmLmZpcmVQb2ludEV2ZW50KFwiY2xpY2tcIiwgYykpIDogKEcoYywgdGhpcy5nZXRDb29yZGluYXRlcyhjKSksIGEuaXNJbnNpZGVQbG90KGMuY2hhcnRYIC0gZSwgYy5jaGFydFkgLSBkKSAmJiB5KGEsIFwiY2xpY2tcIiwgYykpKTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLm9uQ29udGFpbmVyTW91c2VEb3duID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgYyA9IHRoaXMubm9ybWFsaXplKGMpO1xuICAgICAgICAyICE9PSBjLmJ1dHRvbiAmJiAodGhpcy56b29tT3B0aW9uKGMpLCBjLnByZXZlbnREZWZhdWx0ICYmIGMucHJldmVudERlZmF1bHQoKSwgdGhpcy5kcmFnU3RhcnQoYykpO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUub25Db250YWluZXJNb3VzZUxlYXZlID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdmFyIGEgPSBjW2QuaG92ZXJDaGFydEluZGV4XTtcbiAgICAgICAgYSAmJiAoZi5yZWxhdGVkVGFyZ2V0IHx8IGYudG9FbGVtZW50KSAmJiAoYS5wb2ludGVyLnJlc2V0KCksIGEucG9pbnRlci5jaGFydFBvc2l0aW9uID0gdm9pZCAwKTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLm9uQ29udGFpbmVyTW91c2VNb3ZlID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNoYXJ0O1xuICAgICAgICBBKGQuaG92ZXJDaGFydEluZGV4KSAmJiBjW2QuaG92ZXJDaGFydEluZGV4XSAmJiBjW2QuaG92ZXJDaGFydEluZGV4XS5tb3VzZUlzRG93biB8fCAoZC5ob3ZlckNoYXJ0SW5kZXggPSBhLmluZGV4KTtcbiAgICAgICAgZiA9IHRoaXMubm9ybWFsaXplKGYpO1xuICAgICAgICBmLnByZXZlbnREZWZhdWx0IHx8IChmLnJldHVyblZhbHVlID0gITEpO1xuICAgICAgICBcIm1vdXNlZG93blwiID09PSBhLm1vdXNlSXNEb3duICYmIHRoaXMuZHJhZyhmKTtcbiAgICAgICAgYS5vcGVuTWVudSB8fCAhdGhpcy5pbkNsYXNzKGYudGFyZ2V0LCBcImhpZ2hjaGFydHMtdHJhY2tlclwiKSAmJiAhYS5pc0luc2lkZVBsb3QoZi5jaGFydFggLSBhLnBsb3RMZWZ0LCBmLmNoYXJ0WSAtIGEucGxvdFRvcCkgfHwgdGhpcy5ydW5Qb2ludEFjdGlvbnMoZik7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5vbkRvY3VtZW50VG91Y2hFbmQgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICBjW2QuaG92ZXJDaGFydEluZGV4XSAmJiBjW2QuaG92ZXJDaGFydEluZGV4XS5wb2ludGVyLmRyb3AoZik7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5vbkNvbnRhaW5lclRvdWNoTW92ZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHRoaXMudG91Y2goYyk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5vbkNvbnRhaW5lclRvdWNoU3RhcnQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB0aGlzLnpvb21PcHRpb24oYyk7XG4gICAgICAgIHRoaXMudG91Y2goYywgITApO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUub25Eb2N1bWVudE1vdXNlTW92ZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGYgPSB0aGlzLmNoYXJ0UG9zaXRpb24sXG4gICAgICAgICAgICBlID0gYS50b29sdGlwO1xuICAgICAgICBjID0gdGhpcy5ub3JtYWxpemUoYywgZik7XG4gICAgICAgICFmIHx8IGUgJiYgZS5pc1N0aWNreU9uQ29udGFjdCgpIHx8IGEuaXNJbnNpZGVQbG90KGMuY2hhcnRYIC0gYS5wbG90TGVmdCwgYy5jaGFydFkgLSBhLnBsb3RUb3ApIHx8IHRoaXMuaW5DbGFzcyhjLnRhcmdldCwgXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikgfHwgdGhpcy5yZXNldCgpO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUub25Eb2N1bWVudE1vdXNlVXAgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICBjW2QuaG92ZXJDaGFydEluZGV4XSAmJiBjW2QuaG92ZXJDaGFydEluZGV4XS5wb2ludGVyLmRyb3AoZik7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5waW5jaCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIGYgPSBhLmNoYXJ0LFxuICAgICAgICAgICAgZSA9IGEucGluY2hEb3duLFxuICAgICAgICAgICAgZCA9IGMudG91Y2hlcyB8fCBbXSxcbiAgICAgICAgICAgIG4gPSBkLmxlbmd0aCxcbiAgICAgICAgICAgIGggPSBhLmxhc3RWYWxpZFRvdWNoLFxuICAgICAgICAgICAgZyA9IGEuaGFzWm9vbSxcbiAgICAgICAgICAgIHQgPSBhLnNlbGVjdGlvbk1hcmtlcixcbiAgICAgICAgICAgIEggPSB7fSxcbiAgICAgICAgICAgIEsgPSAxID09PSBuICYmIChhLmluQ2xhc3MoYy50YXJnZXQsIFwiaGlnaGNoYXJ0cy10cmFja2VyXCIpICYmIGYucnVuVHJhY2tlckNsaWNrIHx8IGEucnVuQ2hhcnRDbGljayksXG4gICAgICAgICAgICBwID0ge307XG4gICAgICAgIDEgPCBuICYmIChhLmluaXRpYXRlZCA9ICEwKTtcbiAgICAgICAgZyAmJiBhLmluaXRpYXRlZCAmJiAhSyAmJiBjLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIFtdLm1hcC5jYWxsKGQsIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgcmV0dXJuIGEubm9ybWFsaXplKGIpO1xuICAgICAgICB9KTtcbiAgICAgICAgXCJ0b3VjaHN0YXJ0XCIgPT09IGMudHlwZSA/IChbXS5mb3JFYWNoLmNhbGwoZCwgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBlW2FdID0ge1xuICAgICAgICAgICAgY2hhcnRYOiBiLmNoYXJ0WCxcbiAgICAgICAgICAgIGNoYXJ0WTogYi5jaGFydFlcbiAgICAgICAgICB9O1xuICAgICAgICB9KSwgaC54ID0gW2VbMF0uY2hhcnRYLCBlWzFdICYmIGVbMV0uY2hhcnRYXSwgaC55ID0gW2VbMF0uY2hhcnRZLCBlWzFdICYmIGVbMV0uY2hhcnRZXSwgZi5heGVzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBpZiAoYi56b29tRW5hYmxlZCkge1xuICAgICAgICAgICAgdmFyIGEgPSBmLmJvdW5kc1tiLmhvcml6ID8gXCJoXCIgOiBcInZcIl0sXG4gICAgICAgICAgICAgICAgYyA9IGIubWluUGl4ZWxQYWRkaW5nLFxuICAgICAgICAgICAgICAgIGUgPSBiLnRvUGl4ZWxzKE1hdGgubWluKHEoYi5vcHRpb25zLm1pbiwgYi5kYXRhTWluKSwgYi5kYXRhTWluKSksXG4gICAgICAgICAgICAgICAgZCA9IGIudG9QaXhlbHMoTWF0aC5tYXgocShiLm9wdGlvbnMubWF4LCBiLmRhdGFNYXgpLCBiLmRhdGFNYXgpKSxcbiAgICAgICAgICAgICAgICBsID0gTWF0aC5tYXgoZSwgZCk7XG4gICAgICAgICAgICBhLm1pbiA9IE1hdGgubWluKGIucG9zLCBNYXRoLm1pbihlLCBkKSAtIGMpO1xuICAgICAgICAgICAgYS5tYXggPSBNYXRoLm1heChiLnBvcyArIGIubGVuLCBsICsgYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgYS5yZXMgPSAhMCkgOiBhLmZvbGxvd1RvdWNoTW92ZSAmJiAxID09PSBuID8gdGhpcy5ydW5Qb2ludEFjdGlvbnMoYS5ub3JtYWxpemUoYykpIDogZS5sZW5ndGggJiYgKHQgfHwgKGEuc2VsZWN0aW9uTWFya2VyID0gdCA9IEcoe1xuICAgICAgICAgIGRlc3Ryb3k6IGssXG4gICAgICAgICAgdG91Y2g6ICEwXG4gICAgICAgIH0sIGYucGxvdEJveCkpLCBhLnBpbmNoVHJhbnNsYXRlKGUsIGQsIEgsIHQsIHAsIGgpLCBhLmhhc1BpbmNoZWQgPSBnLCBhLnNjYWxlR3JvdXBzKEgsIHApLCBhLnJlcyAmJiAoYS5yZXMgPSAhMSwgdGhpcy5yZXNldCghMSwgMCkpKTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLnBpbmNoVHJhbnNsYXRlID0gZnVuY3Rpb24gKGMsIGEsIGUsIGQsIGssIG4pIHtcbiAgICAgICAgdGhpcy56b29tSG9yICYmIHRoaXMucGluY2hUcmFuc2xhdGVEaXJlY3Rpb24oITAsIGMsIGEsIGUsIGQsIGssIG4pO1xuICAgICAgICB0aGlzLnpvb21WZXJ0ICYmIHRoaXMucGluY2hUcmFuc2xhdGVEaXJlY3Rpb24oITEsIGMsIGEsIGUsIGQsIGssIG4pO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUucGluY2hUcmFuc2xhdGVEaXJlY3Rpb24gPSBmdW5jdGlvbiAoYywgYSwgZSwgZCwgaywgbiwgaCwgcSkge1xuICAgICAgICB2YXIgZiA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBsID0gYyA/IFwieFwiIDogXCJ5XCIsXG4gICAgICAgICAgICB2ID0gYyA/IFwiWFwiIDogXCJZXCIsXG4gICAgICAgICAgICBwID0gXCJjaGFydFwiICsgdixcbiAgICAgICAgICAgIGIgPSBjID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIixcbiAgICAgICAgICAgIHcgPSBmW1wicGxvdFwiICsgKGMgPyBcIkxlZnRcIiA6IFwiVG9wXCIpXSxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICBCLFxuICAgICAgICAgICAgZyA9IHEgfHwgMSxcbiAgICAgICAgICAgIHogPSBmLmludmVydGVkLFxuICAgICAgICAgICAgdCA9IGYuYm91bmRzW2MgPyBcImhcIiA6IFwidlwiXSxcbiAgICAgICAgICAgIG0gPSAxID09PSBhLmxlbmd0aCxcbiAgICAgICAgICAgIEwgPSBhWzBdW3BdLFxuICAgICAgICAgICAgeSA9IGVbMF1bcF0sXG4gICAgICAgICAgICB1ID0gIW0gJiYgYVsxXVtwXSxcbiAgICAgICAgICAgIEYgPSAhbSAmJiBlWzFdW3BdO1xuXG4gICAgICAgIGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIEYgJiYgMjAgPCBNYXRoLmFicyhMIC0gdSkgJiYgKGcgPSBxIHx8IE1hdGguYWJzKHkgLSBGKSAvIE1hdGguYWJzKEwgLSB1KSk7XG4gICAgICAgICAgQiA9ICh3IC0geSkgLyBnICsgTDtcbiAgICAgICAgICB4ID0gZltcInBsb3RcIiArIChjID8gXCJXaWR0aFwiIDogXCJIZWlnaHRcIildIC8gZztcbiAgICAgICAgfTtcblxuICAgICAgICBlKCk7XG4gICAgICAgIGEgPSBCO1xuXG4gICAgICAgIGlmIChhIDwgdC5taW4pIHtcbiAgICAgICAgICBhID0gdC5taW47XG4gICAgICAgICAgdmFyIFYgPSAhMDtcbiAgICAgICAgfSBlbHNlIGEgKyB4ID4gdC5tYXggJiYgKGEgPSB0Lm1heCAtIHgsIFYgPSAhMCk7XG5cbiAgICAgICAgViA/ICh5IC09IC44ICogKHkgLSBoW2xdWzBdKSwgXCJudW1iZXJcIiA9PT0gdHlwZW9mIEYgJiYgKEYgLT0gLjggKiAoRiAtIGhbbF1bMV0pKSwgZSgpKSA6IGhbbF0gPSBbeSwgRl07XG4gICAgICAgIHogfHwgKG5bbF0gPSBCIC0gdywgbltiXSA9IHgpO1xuICAgICAgICBuID0geiA/IDEgLyBnIDogZztcbiAgICAgICAga1tiXSA9IHg7XG4gICAgICAgIGtbbF0gPSBhO1xuICAgICAgICBkW3ogPyBjID8gXCJzY2FsZVlcIiA6IFwic2NhbGVYXCIgOiBcInNjYWxlXCIgKyB2XSA9IGc7XG4gICAgICAgIGRbXCJ0cmFuc2xhdGVcIiArIHZdID0gbiAqIHcgKyAoeSAtIG4gKiBMKTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgdmFyIGYgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZSA9IGYuaG92ZXJTZXJpZXMsXG4gICAgICAgICAgICBkID0gZi5ob3ZlclBvaW50LFxuICAgICAgICAgICAgayA9IGYuaG92ZXJQb2ludHMsXG4gICAgICAgICAgICBuID0gZi50b29sdGlwLFxuICAgICAgICAgICAgaCA9IG4gJiYgbi5zaGFyZWQgPyBrIDogZDtcbiAgICAgICAgYyAmJiBoICYmIFAoaCkuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEuc2VyaWVzLmlzQ2FydGVzaWFuICYmIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBhLnBsb3RYICYmIChjID0gITEpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGMpIG4gJiYgaCAmJiBQKGgpLmxlbmd0aCAmJiAobi5yZWZyZXNoKGgpLCBuLnNoYXJlZCAmJiBrID8gay5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYS5zZXRTdGF0ZShhLnN0YXRlLCAhMCk7XG4gICAgICAgICAgYS5zZXJpZXMuaXNDYXJ0ZXNpYW4gJiYgKGEuc2VyaWVzLnhBeGlzLmNyb3NzaGFpciAmJiBhLnNlcmllcy54QXhpcy5kcmF3Q3Jvc3NoYWlyKG51bGwsIGEpLCBhLnNlcmllcy55QXhpcy5jcm9zc2hhaXIgJiYgYS5zZXJpZXMueUF4aXMuZHJhd0Nyb3NzaGFpcihudWxsLCBhKSk7XG4gICAgICAgIH0pIDogZCAmJiAoZC5zZXRTdGF0ZShkLnN0YXRlLCAhMCksIGYuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYS5jcm9zc2hhaXIgJiYgZC5zZXJpZXNbYS5jb2xsXSA9PT0gYSAmJiBhLmRyYXdDcm9zc2hhaXIobnVsbCwgZCk7XG4gICAgICAgIH0pKSk7ZWxzZSB7XG4gICAgICAgICAgaWYgKGQpIGQub25Nb3VzZU91dCgpO1xuICAgICAgICAgIGsgJiYgay5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBhLnNldFN0YXRlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGUpIGUub25Nb3VzZU91dCgpO1xuICAgICAgICAgIG4gJiYgbi5oaWRlKGEpO1xuICAgICAgICAgIHRoaXMudW5Eb2NNb3VzZU1vdmUgJiYgKHRoaXMudW5Eb2NNb3VzZU1vdmUgPSB0aGlzLnVuRG9jTW91c2VNb3ZlKCkpO1xuICAgICAgICAgIGYuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBhLmhpZGVDcm9zc2hhaXIoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmhvdmVyWCA9IGYuaG92ZXJQb2ludHMgPSBmLmhvdmVyUG9pbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5ydW5Qb2ludEFjdGlvbnMgPSBmdW5jdGlvbiAoZiwgYSkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBrID0gZS50b29sdGlwICYmIGUudG9vbHRpcC5vcHRpb25zLmVuYWJsZWQgPyBlLnRvb2x0aXAgOiB2b2lkIDAsXG4gICAgICAgICAgICBuID0gayA/IGsuc2hhcmVkIDogITEsXG4gICAgICAgICAgICBoID0gYSB8fCBlLmhvdmVyUG9pbnQsXG4gICAgICAgICAgICBnID0gaCAmJiBoLnNlcmllcyB8fCBlLmhvdmVyU2VyaWVzO1xuICAgICAgICBnID0gdGhpcy5nZXRIb3ZlckRhdGEoaCwgZywgZS5zZXJpZXMsICghZiB8fCBcInRvdWNobW92ZVwiICE9PSBmLnR5cGUpICYmICghIWEgfHwgZyAmJiBnLmRpcmVjdFRvdWNoICYmIHRoaXMuaXNEaXJlY3RUb3VjaCksIG4sIGYpO1xuICAgICAgICBoID0gZy5ob3ZlclBvaW50O1xuICAgICAgICB2YXIgdCA9IGcuaG92ZXJQb2ludHM7XG4gICAgICAgIGEgPSAoZyA9IGcuaG92ZXJTZXJpZXMpICYmIGcudG9vbHRpcE9wdGlvbnMuZm9sbG93UG9pbnRlcjtcbiAgICAgICAgbiA9IG4gJiYgZyAmJiAhZy5ub1NoYXJlZFRvb2x0aXA7XG5cbiAgICAgICAgaWYgKGggJiYgKGggIT09IGUuaG92ZXJQb2ludCB8fCBrICYmIGsuaXNIaWRkZW4pKSB7XG4gICAgICAgICAgKGUuaG92ZXJQb2ludHMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIC0xID09PSB0LmluZGV4T2YoYSkgJiYgYS5zZXRTdGF0ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChlLmhvdmVyU2VyaWVzICE9PSBnKSBnLm9uTW91c2VPdmVyKCk7XG4gICAgICAgICAgdGhpcy5hcHBseUluYWN0aXZlU3RhdGUodCk7XG4gICAgICAgICAgKHQgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGEuc2V0U3RhdGUoXCJob3ZlclwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlLmhvdmVyUG9pbnQgJiYgZS5ob3ZlclBvaW50LmZpcmVQb2ludEV2ZW50KFwibW91c2VPdXRcIik7XG4gICAgICAgICAgaWYgKCFoLnNlcmllcykgcmV0dXJuO1xuICAgICAgICAgIGguZmlyZVBvaW50RXZlbnQoXCJtb3VzZU92ZXJcIik7XG4gICAgICAgICAgZS5ob3ZlclBvaW50cyA9IHQ7XG4gICAgICAgICAgZS5ob3ZlclBvaW50ID0gaDtcbiAgICAgICAgICBrICYmIGsucmVmcmVzaChuID8gdCA6IGgsIGYpO1xuICAgICAgICB9IGVsc2UgYSAmJiBrICYmICFrLmlzSGlkZGVuICYmIChoID0gay5nZXRBbmNob3IoW3t9XSwgZiksIGsudXBkYXRlUG9zaXRpb24oe1xuICAgICAgICAgIHBsb3RYOiBoWzBdLFxuICAgICAgICAgIHBsb3RZOiBoWzFdXG4gICAgICAgIH0pKTtcblxuICAgICAgICB0aGlzLnVuRG9jTW91c2VNb3ZlIHx8ICh0aGlzLnVuRG9jTW91c2VNb3ZlID0gSShlLmNvbnRhaW5lci5vd25lckRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHZhciBmID0gY1tkLmhvdmVyQ2hhcnRJbmRleF07XG4gICAgICAgICAgaWYgKGYpIGYucG9pbnRlci5vbkRvY3VtZW50TW91c2VNb3ZlKGEpO1xuICAgICAgICB9KSk7XG4gICAgICAgIGUuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgdmFyIGMgPSBxKGEuY3Jvc3NoYWlyLnNuYXAsICEwKSxcbiAgICAgICAgICAgICAgZSA9IGMgPyBKKHQsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5zZXJpZXNbYS5jb2xsXSA9PT0gYTtcbiAgICAgICAgICB9KSA6IHZvaWQgMDtcbiAgICAgICAgICBlIHx8ICFjID8gYS5kcmF3Q3Jvc3NoYWlyKGYsIGUpIDogYS5oaWRlQ3Jvc3NoYWlyKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUuc2NhbGVHcm91cHMgPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICB2YXIgZiA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBlO1xuICAgICAgICBmLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgZSA9IGMgfHwgZC5nZXRQbG90Qm94KCk7XG4gICAgICAgICAgZC54QXhpcyAmJiBkLnhBeGlzLnpvb21FbmFibGVkICYmIGQuZ3JvdXAgJiYgKGQuZ3JvdXAuYXR0cihlKSwgZC5tYXJrZXJHcm91cCAmJiAoZC5tYXJrZXJHcm91cC5hdHRyKGUpLCBkLm1hcmtlckdyb3VwLmNsaXAoYSA/IGYuY2xpcFJlY3QgOiBudWxsKSksIGQuZGF0YUxhYmVsc0dyb3VwICYmIGQuZGF0YUxhYmVsc0dyb3VwLmF0dHIoZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgZi5jbGlwUmVjdC5hdHRyKGEgfHwgZi5jbGlwQm94KTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLnNldERPTUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLFxuICAgICAgICAgICAgYSA9IGMuY2hhcnQuY29udGFpbmVyLFxuICAgICAgICAgICAgZSA9IGEub3duZXJEb2N1bWVudDtcblxuICAgICAgICBhLm9ubW91c2Vkb3duID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBjLm9uQ29udGFpbmVyTW91c2VEb3duKGEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGEub25tb3VzZW1vdmUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGMub25Db250YWluZXJNb3VzZU1vdmUoYSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYS5vbmNsaWNrID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBjLm9uQ29udGFpbmVyQ2xpY2soYSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51bmJpbmRDb250YWluZXJNb3VzZUxlYXZlID0gSShhLCBcIm1vdXNlbGVhdmVcIiwgYy5vbkNvbnRhaW5lck1vdXNlTGVhdmUpO1xuICAgICAgICBkLnVuYmluZERvY3VtZW50TW91c2VVcCB8fCAoZC51bmJpbmREb2N1bWVudE1vdXNlVXAgPSBJKGUsIFwibW91c2V1cFwiLCBjLm9uRG9jdW1lbnRNb3VzZVVwKSk7XG4gICAgICAgIGQuaGFzVG91Y2ggJiYgKEkoYSwgXCJ0b3VjaHN0YXJ0XCIsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYy5vbkNvbnRhaW5lclRvdWNoU3RhcnQoYSk7XG4gICAgICAgIH0pLCBJKGEsIFwidG91Y2htb3ZlXCIsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYy5vbkNvbnRhaW5lclRvdWNoTW92ZShhKTtcbiAgICAgICAgfSksIGQudW5iaW5kRG9jdW1lbnRUb3VjaEVuZCB8fCAoZC51bmJpbmREb2N1bWVudFRvdWNoRW5kID0gSShlLCBcInRvdWNoZW5kXCIsIGMub25Eb2N1bWVudFRvdWNoRW5kKSkpO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUudG91Y2ggPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICB2YXIgZiA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBlO1xuICAgICAgICBpZiAoZi5pbmRleCAhPT0gZC5ob3ZlckNoYXJ0SW5kZXgpIHRoaXMub25Db250YWluZXJNb3VzZUxlYXZlKHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiAhMFxuICAgICAgICB9KTtcbiAgICAgICAgZC5ob3ZlckNoYXJ0SW5kZXggPSBmLmluZGV4O1xuICAgICAgICBpZiAoMSA9PT0gYy50b3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChjID0gdGhpcy5ub3JtYWxpemUoYyksIChlID0gZi5pc0luc2lkZVBsb3QoYy5jaGFydFggLSBmLnBsb3RMZWZ0LCBjLmNoYXJ0WSAtIGYucGxvdFRvcCkpICYmICFmLm9wZW5NZW51KSB7XG4gICAgICAgICAgICBhICYmIHRoaXMucnVuUG9pbnRBY3Rpb25zKGMpO1xuXG4gICAgICAgICAgICBpZiAoXCJ0b3VjaG1vdmVcIiA9PT0gYy50eXBlKSB7XG4gICAgICAgICAgICAgIGEgPSB0aGlzLnBpbmNoRG93bjtcbiAgICAgICAgICAgICAgdmFyIGsgPSBhWzBdID8gNCA8PSBNYXRoLnNxcnQoTWF0aC5wb3coYVswXS5jaGFydFggLSBjLmNoYXJ0WCwgMikgKyBNYXRoLnBvdyhhWzBdLmNoYXJ0WSAtIGMuY2hhcnRZLCAyKSkgOiAhMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcShrLCAhMCkgJiYgdGhpcy5waW5jaChjKTtcbiAgICAgICAgICB9IGVsc2UgYSAmJiB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH0gZWxzZSAyID09PSBjLnRvdWNoZXMubGVuZ3RoICYmIHRoaXMucGluY2goYyk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS56b29tT3B0aW9uID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZiA9IGEub3B0aW9ucy5jaGFydCxcbiAgICAgICAgICAgIGUgPSBmLnpvb21UeXBlIHx8IFwiXCI7XG4gICAgICAgIGEgPSBhLmludmVydGVkO1xuICAgICAgICAvdG91Y2gvLnRlc3QoYy50eXBlKSAmJiAoZSA9IHEoZi5waW5jaFR5cGUsIGUpKTtcbiAgICAgICAgdGhpcy56b29tWCA9IGMgPSAveC8udGVzdChlKTtcbiAgICAgICAgdGhpcy56b29tWSA9IGUgPSAveS8udGVzdChlKTtcbiAgICAgICAgdGhpcy56b29tSG9yID0gYyAmJiAhYSB8fCBlICYmIGE7XG4gICAgICAgIHRoaXMuem9vbVZlcnQgPSBlICYmICFhIHx8IGMgJiYgYTtcbiAgICAgICAgdGhpcy5oYXNab29tID0gYyB8fCBlO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG47XG4gICAgfSgpO1xuXG4gICAgZC5Qb2ludGVyID0gZztcbiAgICByZXR1cm4gZC5Qb2ludGVyO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL01TUG9pbnRlci5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9Qb2ludGVyLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcsIHIpIHtcbiAgICBmdW5jdGlvbiB1KCkge1xuICAgICAgdmFyIGQgPSBbXTtcblxuICAgICAgZC5pdGVtID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbZF07XG4gICAgICB9O1xuXG4gICAgICBHKGgsIGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIGQucHVzaCh7XG4gICAgICAgICAgcGFnZVg6IGgucGFnZVgsXG4gICAgICAgICAgcGFnZVk6IGgucGFnZVksXG4gICAgICAgICAgdGFyZ2V0OiBoLnRhcmdldFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSShoLCBnLCBlLCBjKSB7XG4gICAgICBcInRvdWNoXCIgIT09IGgucG9pbnRlclR5cGUgJiYgaC5wb2ludGVyVHlwZSAhPT0gaC5NU1BPSU5URVJfVFlQRV9UT1VDSCB8fCAheVtkLmhvdmVyQ2hhcnRJbmRleF0gfHwgKGMoaCksIGMgPSB5W2QuaG92ZXJDaGFydEluZGV4XS5wb2ludGVyLCBjW2ddKHtcbiAgICAgICAgdHlwZTogZSxcbiAgICAgICAgdGFyZ2V0OiBoLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBELFxuICAgICAgICB0b3VjaGVzOiB1KClcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICB2YXIgTSA9IHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGQgPSBmdW5jdGlvbiAoaCwgZSkge1xuICAgICAgICBkID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICAgICAgICBfX3Byb3RvX186IFtdXG4gICAgICAgIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoYywgZSkge1xuICAgICAgICAgIGMuX19wcm90b19fID0gZTtcbiAgICAgICAgfSB8fCBmdW5jdGlvbiAoYywgZSkge1xuICAgICAgICAgIGZvciAodmFyIGQgaW4gZSkgZS5oYXNPd25Qcm9wZXJ0eShkKSAmJiAoY1tkXSA9IGVbZF0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBkKGgsIGUpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChoLCBlKSB7XG4gICAgICAgIGZ1bmN0aW9uIGMoKSB7XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGg7XG4gICAgICAgIH1cblxuICAgICAgICBkKGgsIGUpO1xuICAgICAgICBoLnByb3RvdHlwZSA9IG51bGwgPT09IGUgPyBPYmplY3QuY3JlYXRlKGUpIDogKGMucHJvdG90eXBlID0gZS5wcm90b3R5cGUsIG5ldyBjKCkpO1xuICAgICAgfTtcbiAgICB9KCksXG4gICAgICAgIEUgPSByLmFkZEV2ZW50LFxuICAgICAgICBBID0gci5jc3MsXG4gICAgICAgIEcgPSByLm9iamVjdEVhY2gsXG4gICAgICAgIEogPSByLnJlbW92ZUV2ZW50LFxuICAgICAgICB5ID0gZC5jaGFydHMsXG4gICAgICAgIHQgPSBkLmRvYyxcbiAgICAgICAgRCA9IGQubm9vcCxcbiAgICAgICAgaCA9IHt9LFxuICAgICAgICBOID0gISFkLndpbi5Qb2ludGVyRXZlbnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgIGZ1bmN0aW9uIGcoKSB7XG4gICAgICAgIHJldHVybiBudWxsICE9PSBkICYmIGQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgfVxuXG4gICAgICBNKGcsIGQpO1xuXG4gICAgICBnLnByb3RvdHlwZS5iYXRjaE1TRXZlbnRzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZSh0aGlzLmNoYXJ0LmNvbnRhaW5lciwgTiA/IFwicG9pbnRlcmRvd25cIiA6IFwiTVNQb2ludGVyRG93blwiLCB0aGlzLm9uQ29udGFpbmVyUG9pbnRlckRvd24pO1xuICAgICAgICBlKHRoaXMuY2hhcnQuY29udGFpbmVyLCBOID8gXCJwb2ludGVybW92ZVwiIDogXCJNU1BvaW50ZXJNb3ZlXCIsIHRoaXMub25Db250YWluZXJQb2ludGVyTW92ZSk7XG4gICAgICAgIGUodCwgTiA/IFwicG9pbnRlcnVwXCIgOiBcIk1TUG9pbnRlclVwXCIsIHRoaXMub25Eb2N1bWVudFBvaW50ZXJVcCk7XG4gICAgICB9O1xuXG4gICAgICBnLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmJhdGNoTVNFdmVudHMoSik7XG4gICAgICAgIGQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICAgIH07XG5cbiAgICAgIGcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZSwgYykge1xuICAgICAgICBkLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZSwgYyk7XG4gICAgICAgIHRoaXMuaGFzWm9vbSAmJiBBKGUuY29udGFpbmVyLCB7XG4gICAgICAgICAgXCItbXMtdG91Y2gtYWN0aW9uXCI6IFwibm9uZVwiLFxuICAgICAgICAgIFwidG91Y2gtYWN0aW9uXCI6IFwibm9uZVwiXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZy5wcm90b3R5cGUub25Db250YWluZXJQb2ludGVyRG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIEkoZSwgXCJvbkNvbnRhaW5lclRvdWNoU3RhcnRcIiwgXCJ0b3VjaHN0YXJ0XCIsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgaFtjLnBvaW50ZXJJZF0gPSB7XG4gICAgICAgICAgICBwYWdlWDogYy5wYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZOiBjLnBhZ2VZLFxuICAgICAgICAgICAgdGFyZ2V0OiBjLmN1cnJlbnRUYXJnZXRcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGcucHJvdG90eXBlLm9uQ29udGFpbmVyUG9pbnRlck1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBJKGUsIFwib25Db250YWluZXJUb3VjaE1vdmVcIiwgXCJ0b3VjaG1vdmVcIiwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBoW2MucG9pbnRlcklkXSA9IHtcbiAgICAgICAgICAgIHBhZ2VYOiBjLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGMucGFnZVlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGhbYy5wb2ludGVySWRdLnRhcmdldCB8fCAoaFtjLnBvaW50ZXJJZF0udGFyZ2V0ID0gYy5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBnLnByb3RvdHlwZS5vbkRvY3VtZW50UG9pbnRlclVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgSShlLCBcIm9uRG9jdW1lbnRUb3VjaEVuZFwiLCBcInRvdWNoZW5kXCIsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgZGVsZXRlIGhbYy5wb2ludGVySWRdO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGcucHJvdG90eXBlLnNldERPTUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZC5wcm90b3R5cGUuc2V0RE9NRXZlbnRzLmNhbGwodGhpcyk7XG4gICAgICAgICh0aGlzLmhhc1pvb20gfHwgdGhpcy5mb2xsb3dUb3VjaE1vdmUpICYmIHRoaXMuYmF0Y2hNU0V2ZW50cyhFKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBnO1xuICAgIH0oZyk7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvTGVnZW5kLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgdmFyIHIgPSBnLmFkZEV2ZW50LFxuICAgICAgICB1ID0gZy5jc3MsXG4gICAgICAgIEkgPSBnLmRlZmluZWQsXG4gICAgICAgIE0gPSBnLmRpc2NhcmRFbGVtZW50LFxuICAgICAgICBFID0gZy5maW5kLFxuICAgICAgICBBID0gZy5maXJlRXZlbnQsXG4gICAgICAgIEcgPSBnLmZvcm1hdCxcbiAgICAgICAgSiA9IGcuaXNOdW1iZXIsXG4gICAgICAgIHkgPSBnLm1lcmdlLFxuICAgICAgICB0ID0gZy5waWNrLFxuICAgICAgICBEID0gZy5yZWxhdGl2ZUxlbmd0aCxcbiAgICAgICAgaCA9IGcuc2V0QW5pbWF0aW9uLFxuICAgICAgICBOID0gZy5zdGFibGVTb3J0LFxuICAgICAgICBxID0gZy5zeW5jVGltZW91dDtcbiAgICBnID0gZy53cmFwO1xuXG4gICAgdmFyIFAgPSBkLmlzRmlyZWZveCxcbiAgICAgICAgZSA9IGQubWFyZ2luTmFtZXMsXG4gICAgICAgIGMgPSBkLndpbixcbiAgICAgICAgayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIGMoYywgYSkge1xuICAgICAgICB0aGlzLmFsbEl0ZW1zID0gW107XG4gICAgICAgIHRoaXMuY29udGVudEdyb3VwID0gdGhpcy5ib3ggPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuZGlzcGxheSA9ICExO1xuICAgICAgICB0aGlzLmdyb3VwID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9mZnNldFdpZHRoID0gdGhpcy5tYXhMZWdlbmRXaWR0aCA9IHRoaXMubWF4SXRlbVdpZHRoID0gdGhpcy5sZWdlbmRXaWR0aCA9IHRoaXMubGVnZW5kSGVpZ2h0ID0gdGhpcy5sYXN0TGluZUhlaWdodCA9IHRoaXMubGFzdEl0ZW1ZID0gdGhpcy5pdGVtWSA9IHRoaXMuaXRlbVggPSB0aGlzLml0ZW1NYXJnaW5Ub3AgPSB0aGlzLml0ZW1NYXJnaW5Cb3R0b20gPSB0aGlzLml0ZW1IZWlnaHQgPSB0aGlzLmluaXRpYWxJdGVtWSA9IDA7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLnBhZGRpbmcgPSAwO1xuICAgICAgICB0aGlzLnBhZ2VzID0gW107XG4gICAgICAgIHRoaXMucHJveGltYXRlID0gITE7XG4gICAgICAgIHRoaXMuc2Nyb2xsR3JvdXAgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMud2lkdGhPcHRpb24gPSB0aGlzLnRvdGFsSXRlbVdpZHRoID0gdGhpcy50aXRsZUhlaWdodCA9IHRoaXMuc3ltYm9sV2lkdGggPSB0aGlzLnN5bWJvbEhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuY2hhcnQgPSBjO1xuICAgICAgICB0aGlzLmluaXQoYywgYSk7XG4gICAgICB9XG5cbiAgICAgIGMucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICB0aGlzLmNoYXJ0ID0gYztcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKGEpO1xuICAgICAgICBhLmVuYWJsZWQgJiYgKHRoaXMucmVuZGVyKCksIHIodGhpcy5jaGFydCwgXCJlbmRSZXNpemVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMubGVnZW5kLnBvc2l0aW9uQ2hlY2tib3hlcygpO1xuICAgICAgICB9KSwgdGhpcy5wcm94aW1hdGUgPyB0aGlzLnVuY2hhcnRyZW5kZXIgPSByKHRoaXMuY2hhcnQsIFwicmVuZGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLmxlZ2VuZC5wcm94aW1hdGVQb3NpdGlvbnMoKTtcbiAgICAgICAgICB0aGlzLmxlZ2VuZC5wb3NpdGlvbkl0ZW1zKCk7XG4gICAgICAgIH0pIDogdGhpcy51bmNoYXJ0cmVuZGVyICYmIHRoaXMudW5jaGFydHJlbmRlcigpKTtcbiAgICAgIH07XG5cbiAgICAgIGMucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgYSA9IHQoYy5wYWRkaW5nLCA4KTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gYztcbiAgICAgICAgdGhpcy5jaGFydC5zdHlsZWRNb2RlIHx8ICh0aGlzLml0ZW1TdHlsZSA9IGMuaXRlbVN0eWxlLCB0aGlzLml0ZW1IaWRkZW5TdHlsZSA9IHkodGhpcy5pdGVtU3R5bGUsIGMuaXRlbUhpZGRlblN0eWxlKSk7XG4gICAgICAgIHRoaXMuaXRlbU1hcmdpblRvcCA9IGMuaXRlbU1hcmdpblRvcCB8fCAwO1xuICAgICAgICB0aGlzLml0ZW1NYXJnaW5Cb3R0b20gPSBjLml0ZW1NYXJnaW5Cb3R0b20gfHwgMDtcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gYTtcbiAgICAgICAgdGhpcy5pbml0aWFsSXRlbVkgPSBhIC0gNTtcbiAgICAgICAgdGhpcy5zeW1ib2xXaWR0aCA9IHQoYy5zeW1ib2xXaWR0aCwgMTYpO1xuICAgICAgICB0aGlzLnBhZ2VzID0gW107XG4gICAgICAgIHRoaXMucHJveGltYXRlID0gXCJwcm94aW1hdGVcIiA9PT0gYy5sYXlvdXQgJiYgIXRoaXMuY2hhcnQuaW52ZXJ0ZWQ7XG4gICAgICAgIHRoaXMuYmFzZWxpbmUgPSB2b2lkIDA7XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICB2YXIgZiA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyh5KCEwLCB0aGlzLm9wdGlvbnMsIGMpKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIGYuaXNEaXJ0eUxlZ2VuZCA9IGYuaXNEaXJ0eUJveCA9ICEwO1xuICAgICAgICB0KGEsICEwKSAmJiBmLnJlZHJhdygpO1xuICAgICAgICBBKHRoaXMsIFwiYWZ0ZXJVcGRhdGVcIik7XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZS5jb2xvcml6ZUl0ZW0gPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICBjLmxlZ2VuZEdyb3VwW2EgPyBcInJlbW92ZUNsYXNzXCIgOiBcImFkZENsYXNzXCJdKFwiaGlnaGNoYXJ0cy1sZWdlbmQtaXRlbS1oaWRkZW5cIik7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNoYXJ0LnN0eWxlZE1vZGUpIHtcbiAgICAgICAgICB2YXIgZiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgZSA9IGMubGVnZW5kSXRlbSxcbiAgICAgICAgICAgICAgZCA9IGMubGVnZW5kTGluZSxcbiAgICAgICAgICAgICAgayA9IGMubGVnZW5kU3ltYm9sLFxuICAgICAgICAgICAgICBoID0gdGhpcy5pdGVtSGlkZGVuU3R5bGUuY29sb3I7XG4gICAgICAgICAgZiA9IGEgPyBmLml0ZW1TdHlsZS5jb2xvciA6IGg7XG4gICAgICAgICAgdmFyIG4gPSBhID8gYy5jb2xvciB8fCBoIDogaCxcbiAgICAgICAgICAgICAgZyA9IGMub3B0aW9ucyAmJiBjLm9wdGlvbnMubWFya2VyLFxuICAgICAgICAgICAgICBxID0ge1xuICAgICAgICAgICAgZmlsbDogblxuICAgICAgICAgIH07XG4gICAgICAgICAgZSAmJiBlLmNzcyh7XG4gICAgICAgICAgICBmaWxsOiBmLFxuICAgICAgICAgICAgY29sb3I6IGZcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkICYmIGQuYXR0cih7XG4gICAgICAgICAgICBzdHJva2U6IG5cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBrICYmIChnICYmIGsuaXNNYXJrZXIgJiYgKHEgPSBjLnBvaW50QXR0cmlicygpLCBhIHx8IChxLnN0cm9rZSA9IHEuZmlsbCA9IGgpKSwgay5hdHRyKHEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEEodGhpcywgXCJhZnRlckNvbG9yaXplSXRlbVwiLCB7XG4gICAgICAgICAgaXRlbTogYyxcbiAgICAgICAgICB2aXNpYmxlOiBhXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgYy5wcm90b3R5cGUucG9zaXRpb25JdGVtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hbGxJdGVtcy5mb3JFYWNoKHRoaXMucG9zaXRpb25JdGVtLCB0aGlzKTtcbiAgICAgICAgdGhpcy5jaGFydC5pc1Jlc2l6aW5nIHx8IHRoaXMucG9zaXRpb25DaGVja2JveGVzKCk7XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZS5wb3NpdGlvbkl0ZW0gPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgYSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGYgPSBhLnN5bWJvbFBhZGRpbmc7XG4gICAgICAgIGEgPSAhYS5ydGw7XG4gICAgICAgIHZhciBlID0gYy5fbGVnZW5kSXRlbVBvcyxcbiAgICAgICAgICAgIGQgPSBlWzBdO1xuICAgICAgICBlID0gZVsxXTtcbiAgICAgICAgdmFyIGsgPSBjLmNoZWNrYm94O1xuICAgICAgICBpZiAoKGMgPSBjLmxlZ2VuZEdyb3VwKSAmJiBjLmVsZW1lbnQpIGNbSShjLnRyYW5zbGF0ZVkpID8gXCJhbmltYXRlXCIgOiBcImF0dHJcIl0oe1xuICAgICAgICAgIHRyYW5zbGF0ZVg6IGEgPyBkIDogdGhpcy5sZWdlbmRXaWR0aCAtIGQgLSAyICogZiAtIDQsXG4gICAgICAgICAgdHJhbnNsYXRlWTogZVxuICAgICAgICB9KTtcbiAgICAgICAgayAmJiAoay54ID0gZCwgay55ID0gZSk7XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZS5kZXN0cm95SXRlbSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBhID0gYy5jaGVja2JveDtcbiAgICAgICAgW1wibGVnZW5kSXRlbVwiLCBcImxlZ2VuZExpbmVcIiwgXCJsZWdlbmRTeW1ib2xcIiwgXCJsZWdlbmRHcm91cFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgY1thXSAmJiAoY1thXSA9IGNbYV0uZGVzdHJveSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGEgJiYgTShjLmNoZWNrYm94KTtcbiAgICAgIH07XG5cbiAgICAgIGMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGMoYSkge1xuICAgICAgICAgIHRoaXNbYV0gJiYgKHRoaXNbYV0gPSB0aGlzW2FdLmRlc3Ryb3koKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdldEFsbEl0ZW1zKCkuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIFtcImxlZ2VuZEl0ZW1cIiwgXCJsZWdlbmRHcm91cFwiXS5mb3JFYWNoKGMsIGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgXCJjbGlwUmVjdCB1cCBkb3duIHBhZ2VyIG5hdiBib3ggdGl0bGUgZ3JvdXBcIi5zcGxpdChcIiBcIikuZm9yRWFjaChjLCB0aGlzKTtcbiAgICAgICAgdGhpcy5kaXNwbGF5ID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIGMucHJvdG90eXBlLnBvc2l0aW9uQ2hlY2tib3hlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAuYWxpZ25BdHRyLFxuICAgICAgICAgICAgYSA9IHRoaXMuY2xpcEhlaWdodCB8fCB0aGlzLmxlZ2VuZEhlaWdodCxcbiAgICAgICAgICAgIGUgPSB0aGlzLnRpdGxlSGVpZ2h0O1xuXG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgdmFyIGQgPSBjLnRyYW5zbGF0ZVk7XG4gICAgICAgICAgdGhpcy5hbGxJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICB2YXIgayA9IGYuY2hlY2tib3g7XG5cbiAgICAgICAgICAgIGlmIChrKSB7XG4gICAgICAgICAgICAgIHZhciBsID0gZCArIGUgKyBrLnkgKyAodGhpcy5zY3JvbGxPZmZzZXQgfHwgMCkgKyAzO1xuICAgICAgICAgICAgICB1KGssIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBjLnRyYW5zbGF0ZVggKyBmLmNoZWNrYm94T2Zmc2V0ICsgay54IC0gMjAgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgdG9wOiBsICsgXCJweFwiLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IHRoaXMucHJveGltYXRlIHx8IGwgPiBkIC0gNiAmJiBsIDwgZCArIGEgLSA2ID8gXCJcIiA6IFwibm9uZVwiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZS5yZW5kZXJUaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBhID0gdGhpcy5wYWRkaW5nLFxuICAgICAgICAgICAgZSA9IGMudGl0bGUsXG4gICAgICAgICAgICBkID0gMDtcbiAgICAgICAgZS50ZXh0ICYmICh0aGlzLnRpdGxlIHx8ICh0aGlzLnRpdGxlID0gdGhpcy5jaGFydC5yZW5kZXJlci5sYWJlbChlLnRleHQsIGEgLSAzLCBhIC0gNCwgbnVsbCwgbnVsbCwgbnVsbCwgYy51c2VIVE1MLCBudWxsLCBcImxlZ2VuZC10aXRsZVwiKS5hdHRyKHtcbiAgICAgICAgICB6SW5kZXg6IDFcbiAgICAgICAgfSksIHRoaXMuY2hhcnQuc3R5bGVkTW9kZSB8fCB0aGlzLnRpdGxlLmNzcyhlLnN0eWxlKSwgdGhpcy50aXRsZS5hZGQodGhpcy5ncm91cCkpLCBlLndpZHRoIHx8IHRoaXMudGl0bGUuY3NzKHtcbiAgICAgICAgICB3aWR0aDogdGhpcy5tYXhMZWdlbmRXaWR0aCArIFwicHhcIlxuICAgICAgICB9KSwgYyA9IHRoaXMudGl0bGUuZ2V0QkJveCgpLCBkID0gYy5oZWlnaHQsIHRoaXMub2Zmc2V0V2lkdGggPSBjLndpZHRoLCB0aGlzLmNvbnRlbnRHcm91cC5hdHRyKHtcbiAgICAgICAgICB0cmFuc2xhdGVZOiBkXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy50aXRsZUhlaWdodCA9IGQ7XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGMubGVnZW5kSXRlbS5hdHRyKHtcbiAgICAgICAgICB0ZXh0OiBhLmxhYmVsRm9ybWF0ID8gRyhhLmxhYmVsRm9ybWF0LCBjLCB0aGlzLmNoYXJ0KSA6IGEubGFiZWxGb3JtYXR0ZXIuY2FsbChjKVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGMucHJvdG90eXBlLnJlbmRlckl0ZW0gPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBlID0gYS5yZW5kZXJlcixcbiAgICAgICAgICAgIGYgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBkID0gdGhpcy5zeW1ib2xXaWR0aCxcbiAgICAgICAgICAgIGsgPSBmLnN5bWJvbFBhZGRpbmcsXG4gICAgICAgICAgICBoID0gdGhpcy5pdGVtU3R5bGUsXG4gICAgICAgICAgICBuID0gdGhpcy5pdGVtSGlkZGVuU3R5bGUsXG4gICAgICAgICAgICBnID0gXCJob3Jpem9udGFsXCIgPT09IGYubGF5b3V0ID8gdChmLml0ZW1EaXN0YW5jZSwgMjApIDogMCxcbiAgICAgICAgICAgIHEgPSAhZi5ydGwsXG4gICAgICAgICAgICBLID0gYy5sZWdlbmRJdGVtLFxuICAgICAgICAgICAgcCA9ICFjLnNlcmllcyxcbiAgICAgICAgICAgIGIgPSAhcCAmJiBjLnNlcmllcy5kcmF3TGVnZW5kU3ltYm9sID8gYy5zZXJpZXMgOiBjLFxuICAgICAgICAgICAgQyA9IGIub3B0aW9ucztcbiAgICAgICAgQyA9IHRoaXMuY3JlYXRlQ2hlY2tib3hGb3JJdGVtICYmIEMgJiYgQy5zaG93Q2hlY2tib3g7XG4gICAgICAgIGcgPSBkICsgayArIGcgKyAoQyA/IDIwIDogMCk7XG4gICAgICAgIHZhciB4ID0gZi51c2VIVE1MLFxuICAgICAgICAgICAgUiA9IGMub3B0aW9ucy5jbGFzc05hbWU7XG4gICAgICAgIEsgfHwgKGMubGVnZW5kR3JvdXAgPSBlLmcoXCJsZWdlbmQtaXRlbVwiKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtXCIgKyBiLnR5cGUgKyBcIi1zZXJpZXMgaGlnaGNoYXJ0cy1jb2xvci1cIiArIGMuY29sb3JJbmRleCArIChSID8gXCIgXCIgKyBSIDogXCJcIikgKyAocCA/IFwiIGhpZ2hjaGFydHMtc2VyaWVzLVwiICsgYy5pbmRleCA6IFwiXCIpKS5hdHRyKHtcbiAgICAgICAgICB6SW5kZXg6IDFcbiAgICAgICAgfSkuYWRkKHRoaXMuc2Nyb2xsR3JvdXApLCBjLmxlZ2VuZEl0ZW0gPSBLID0gZS50ZXh0KFwiXCIsIHEgPyBkICsgayA6IC1rLCB0aGlzLmJhc2VsaW5lIHx8IDAsIHgpLCBhLnN0eWxlZE1vZGUgfHwgSy5jc3MoeShjLnZpc2libGUgPyBoIDogbikpLCBLLmF0dHIoe1xuICAgICAgICAgIGFsaWduOiBxID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIsXG4gICAgICAgICAgekluZGV4OiAyXG4gICAgICAgIH0pLmFkZChjLmxlZ2VuZEdyb3VwKSwgdGhpcy5iYXNlbGluZSB8fCAodGhpcy5mb250TWV0cmljcyA9IGUuZm9udE1ldHJpY3MoYS5zdHlsZWRNb2RlID8gMTIgOiBoLmZvbnRTaXplLCBLKSwgdGhpcy5iYXNlbGluZSA9IHRoaXMuZm9udE1ldHJpY3MuZiArIDMgKyB0aGlzLml0ZW1NYXJnaW5Ub3AsIEsuYXR0cihcInlcIiwgdGhpcy5iYXNlbGluZSkpLCB0aGlzLnN5bWJvbEhlaWdodCA9IGYuc3ltYm9sSGVpZ2h0IHx8IHRoaXMuZm9udE1ldHJpY3MuZiwgYi5kcmF3TGVnZW5kU3ltYm9sKHRoaXMsIGMpLCB0aGlzLnNldEl0ZW1FdmVudHMgJiYgdGhpcy5zZXRJdGVtRXZlbnRzKGMsIEssIHgpKTtcbiAgICAgICAgQyAmJiAhYy5jaGVja2JveCAmJiB0aGlzLmNyZWF0ZUNoZWNrYm94Rm9ySXRlbSAmJiB0aGlzLmNyZWF0ZUNoZWNrYm94Rm9ySXRlbShjKTtcbiAgICAgICAgdGhpcy5jb2xvcml6ZUl0ZW0oYywgYy52aXNpYmxlKTtcbiAgICAgICAgIWEuc3R5bGVkTW9kZSAmJiBoLndpZHRoIHx8IEsuY3NzKHtcbiAgICAgICAgICB3aWR0aDogKGYuaXRlbVdpZHRoIHx8IHRoaXMud2lkdGhPcHRpb24gfHwgYS5zcGFjaW5nQm94LndpZHRoKSAtIGdcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0VGV4dChjKTtcbiAgICAgICAgYSA9IEsuZ2V0QkJveCgpO1xuICAgICAgICBjLml0ZW1XaWR0aCA9IGMuY2hlY2tib3hPZmZzZXQgPSBmLml0ZW1XaWR0aCB8fCBjLmxlZ2VuZEl0ZW1XaWR0aCB8fCBhLndpZHRoICsgZztcbiAgICAgICAgdGhpcy5tYXhJdGVtV2lkdGggPSBNYXRoLm1heCh0aGlzLm1heEl0ZW1XaWR0aCwgYy5pdGVtV2lkdGgpO1xuICAgICAgICB0aGlzLnRvdGFsSXRlbVdpZHRoICs9IGMuaXRlbVdpZHRoO1xuICAgICAgICB0aGlzLml0ZW1IZWlnaHQgPSBjLml0ZW1IZWlnaHQgPSBNYXRoLnJvdW5kKGMubGVnZW5kSXRlbUhlaWdodCB8fCBhLmhlaWdodCB8fCB0aGlzLnN5bWJvbEhlaWdodCk7XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZS5sYXlvdXRJdGVtID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBlID0gdGhpcy5wYWRkaW5nLFxuICAgICAgICAgICAgZiA9IFwiaG9yaXpvbnRhbFwiID09PSBhLmxheW91dCxcbiAgICAgICAgICAgIGQgPSBjLml0ZW1IZWlnaHQsXG4gICAgICAgICAgICBrID0gdGhpcy5pdGVtTWFyZ2luQm90dG9tLFxuICAgICAgICAgICAgaCA9IHRoaXMuaXRlbU1hcmdpblRvcCxcbiAgICAgICAgICAgIG4gPSBmID8gdChhLml0ZW1EaXN0YW5jZSwgMjApIDogMCxcbiAgICAgICAgICAgIGcgPSB0aGlzLm1heExlZ2VuZFdpZHRoO1xuICAgICAgICBhID0gYS5hbGlnbkNvbHVtbnMgJiYgdGhpcy50b3RhbEl0ZW1XaWR0aCA+IGcgPyB0aGlzLm1heEl0ZW1XaWR0aCA6IGMuaXRlbVdpZHRoO1xuICAgICAgICBmICYmIHRoaXMuaXRlbVggLSBlICsgYSA+IGcgJiYgKHRoaXMuaXRlbVggPSBlLCB0aGlzLmxhc3RMaW5lSGVpZ2h0ICYmICh0aGlzLml0ZW1ZICs9IGggKyB0aGlzLmxhc3RMaW5lSGVpZ2h0ICsgayksIHRoaXMubGFzdExpbmVIZWlnaHQgPSAwKTtcbiAgICAgICAgdGhpcy5sYXN0SXRlbVkgPSBoICsgdGhpcy5pdGVtWSArIGs7XG4gICAgICAgIHRoaXMubGFzdExpbmVIZWlnaHQgPSBNYXRoLm1heChkLCB0aGlzLmxhc3RMaW5lSGVpZ2h0KTtcbiAgICAgICAgYy5fbGVnZW5kSXRlbVBvcyA9IFt0aGlzLml0ZW1YLCB0aGlzLml0ZW1ZXTtcbiAgICAgICAgZiA/IHRoaXMuaXRlbVggKz0gYSA6ICh0aGlzLml0ZW1ZICs9IGggKyBkICsgaywgdGhpcy5sYXN0TGluZUhlaWdodCA9IGQpO1xuICAgICAgICB0aGlzLm9mZnNldFdpZHRoID0gdGhpcy53aWR0aE9wdGlvbiB8fCBNYXRoLm1heCgoZiA/IHRoaXMuaXRlbVggLSBlIC0gKGMuY2hlY2tib3ggPyAwIDogbikgOiBhKSArIGUsIHRoaXMub2Zmc2V0V2lkdGgpO1xuICAgICAgfTtcblxuICAgICAgYy5wcm90b3R5cGUuZ2V0QWxsSXRlbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjID0gW107XG4gICAgICAgIHRoaXMuY2hhcnQuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICB2YXIgZSA9IGEgJiYgYS5vcHRpb25zO1xuICAgICAgICAgIGEgJiYgdChlLnNob3dJbkxlZ2VuZCwgSShlLmxpbmtlZFRvKSA/ICExIDogdm9pZCAwLCAhMCkgJiYgKGMgPSBjLmNvbmNhdChhLmxlZ2VuZEl0ZW1zIHx8IChcInBvaW50XCIgPT09IGUubGVnZW5kVHlwZSA/IGEuZGF0YSA6IGEpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBBKHRoaXMsIFwiYWZ0ZXJHZXRBbGxJdGVtc1wiLCB7XG4gICAgICAgICAgYWxsSXRlbXM6IGNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfTtcblxuICAgICAgYy5wcm90b3R5cGUuZ2V0QWxpZ25tZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgcmV0dXJuIHRoaXMucHJveGltYXRlID8gYy5hbGlnbi5jaGFyQXQoMCkgKyBcInR2XCIgOiBjLmZsb2F0aW5nID8gXCJcIiA6IGMuYWxpZ24uY2hhckF0KDApICsgYy52ZXJ0aWNhbEFsaWduLmNoYXJBdCgwKSArIGMubGF5b3V0LmNoYXJBdCgwKTtcbiAgICAgIH07XG5cbiAgICAgIGMucHJvdG90eXBlLmFkanVzdE1hcmdpbnMgPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICB2YXIgZiA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBkID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgayA9IHRoaXMuZ2V0QWxpZ25tZW50KCk7XG4gICAgICAgIGsgJiYgWy8obHRofGN0fHJ0aCkvLCAvKHJ0dnxybXxyYnYpLywgLyhyYmh8Y2J8bGJoKS8sIC8obGJ2fGxtfGx0dikvXS5mb3JFYWNoKGZ1bmN0aW9uIChsLCBoKSB7XG4gICAgICAgICAgbC50ZXN0KGspICYmICFJKGNbaF0pICYmIChmW2VbaF1dID0gTWF0aC5tYXgoZltlW2hdXSwgZi5sZWdlbmRbKGggKyAxKSAlIDIgPyBcImxlZ2VuZEhlaWdodFwiIDogXCJsZWdlbmRXaWR0aFwiXSArIFsxLCAtMSwgLTEsIDFdW2hdICogZFtoICUgMiA/IFwieFwiIDogXCJ5XCJdICsgdChkLm1hcmdpbiwgMTIpICsgYVtoXSArIChmLnRpdGxlT2Zmc2V0W2hdIHx8IDApKSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgYy5wcm90b3R5cGUucHJveGltYXRlUG9zaXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYyA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBhID0gW10sXG4gICAgICAgICAgICBlID0gXCJsZWZ0XCIgPT09IHRoaXMub3B0aW9ucy5hbGlnbjtcbiAgICAgICAgdGhpcy5hbGxJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgdmFyIGQgPSBlO1xuXG4gICAgICAgICAgaWYgKGYueUF4aXMgJiYgZi5wb2ludHMpIHtcbiAgICAgICAgICAgIGYueEF4aXMub3B0aW9ucy5yZXZlcnNlZCAmJiAoZCA9ICFkKTtcbiAgICAgICAgICAgIHZhciBrID0gRShkID8gZi5wb2ludHMgOiBmLnBvaW50cy5zbGljZSgwKS5yZXZlcnNlKCksIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgIHJldHVybiBKKGEucGxvdFkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkID0gdGhpcy5pdGVtTWFyZ2luVG9wICsgZi5sZWdlbmRJdGVtLmdldEJCb3goKS5oZWlnaHQgKyB0aGlzLml0ZW1NYXJnaW5Cb3R0b207XG4gICAgICAgICAgICB2YXIgbCA9IGYueUF4aXMudG9wIC0gYy5wbG90VG9wO1xuICAgICAgICAgICAgZi52aXNpYmxlID8gKGsgPSBrID8gay5wbG90WSA6IGYueUF4aXMuaGVpZ2h0LCBrICs9IGwgLSAuMyAqIGQpIDogayA9IGwgKyBmLnlBeGlzLmhlaWdodDtcbiAgICAgICAgICAgIGEucHVzaCh7XG4gICAgICAgICAgICAgIHRhcmdldDogayxcbiAgICAgICAgICAgICAgc2l6ZTogZCxcbiAgICAgICAgICAgICAgaXRlbTogZlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgZC5kaXN0cmlidXRlKGEsIGMucGxvdEhlaWdodCk7XG4gICAgICAgIGEuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEuaXRlbS5fbGVnZW5kSXRlbVBvc1sxXSA9IGMucGxvdFRvcCAtIGMuc3BhY2luZ1swXSArIGEucG9zO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGMucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgYSA9IGMucmVuZGVyZXIsXG4gICAgICAgICAgICBlID0gdGhpcy5ncm91cCxcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBrID0gdGhpcy5ib3gsXG4gICAgICAgICAgICBoID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgbiA9IHRoaXMucGFkZGluZztcbiAgICAgICAgdGhpcy5pdGVtWCA9IG47XG4gICAgICAgIHRoaXMuaXRlbVkgPSB0aGlzLmluaXRpYWxJdGVtWTtcbiAgICAgICAgdGhpcy5sYXN0SXRlbVkgPSB0aGlzLm9mZnNldFdpZHRoID0gMDtcbiAgICAgICAgdGhpcy53aWR0aE9wdGlvbiA9IEQoaC53aWR0aCwgYy5zcGFjaW5nQm94LndpZHRoIC0gbik7XG4gICAgICAgIHZhciBnID0gYy5zcGFjaW5nQm94LndpZHRoIC0gMiAqIG4gLSBoLng7XG4gICAgICAgIC0xIDwgW1wicm1cIiwgXCJsbVwiXS5pbmRleE9mKHRoaXMuZ2V0QWxpZ25tZW50KCkuc3Vic3RyaW5nKDAsIDIpKSAmJiAoZyAvPSAyKTtcbiAgICAgICAgdGhpcy5tYXhMZWdlbmRXaWR0aCA9IHRoaXMud2lkdGhPcHRpb24gfHwgZztcbiAgICAgICAgZSB8fCAodGhpcy5ncm91cCA9IGUgPSBhLmcoXCJsZWdlbmRcIikuYXR0cih7XG4gICAgICAgICAgekluZGV4OiA3XG4gICAgICAgIH0pLmFkZCgpLCB0aGlzLmNvbnRlbnRHcm91cCA9IGEuZygpLmF0dHIoe1xuICAgICAgICAgIHpJbmRleDogMVxuICAgICAgICB9KS5hZGQoZSksIHRoaXMuc2Nyb2xsR3JvdXAgPSBhLmcoKS5hZGQodGhpcy5jb250ZW50R3JvdXApKTtcbiAgICAgICAgdGhpcy5yZW5kZXJUaXRsZSgpO1xuICAgICAgICBnID0gdGhpcy5nZXRBbGxJdGVtcygpO1xuICAgICAgICBOKGcsIGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgICAgcmV0dXJuIChhLm9wdGlvbnMgJiYgYS5vcHRpb25zLmxlZ2VuZEluZGV4IHx8IDApIC0gKGMub3B0aW9ucyAmJiBjLm9wdGlvbnMubGVnZW5kSW5kZXggfHwgMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBoLnJldmVyc2VkICYmIGcucmV2ZXJzZSgpO1xuICAgICAgICB0aGlzLmFsbEl0ZW1zID0gZztcbiAgICAgICAgdGhpcy5kaXNwbGF5ID0gZCA9ICEhZy5sZW5ndGg7XG4gICAgICAgIHRoaXMuaXRlbUhlaWdodCA9IHRoaXMudG90YWxJdGVtV2lkdGggPSB0aGlzLm1heEl0ZW1XaWR0aCA9IHRoaXMubGFzdExpbmVIZWlnaHQgPSAwO1xuICAgICAgICBnLmZvckVhY2godGhpcy5yZW5kZXJJdGVtLCB0aGlzKTtcbiAgICAgICAgZy5mb3JFYWNoKHRoaXMubGF5b3V0SXRlbSwgdGhpcyk7XG4gICAgICAgIGcgPSAodGhpcy53aWR0aE9wdGlvbiB8fCB0aGlzLm9mZnNldFdpZHRoKSArIG47XG4gICAgICAgIHZhciBxID0gdGhpcy5sYXN0SXRlbVkgKyB0aGlzLmxhc3RMaW5lSGVpZ2h0ICsgdGhpcy50aXRsZUhlaWdodDtcbiAgICAgICAgcSA9IHRoaXMuaGFuZGxlT3ZlcmZsb3cocSk7XG4gICAgICAgIHEgKz0gbjtcbiAgICAgICAgayB8fCAodGhpcy5ib3ggPSBrID0gYS5yZWN0KCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWxlZ2VuZC1ib3hcIikuYXR0cih7XG4gICAgICAgICAgcjogaC5ib3JkZXJSYWRpdXNcbiAgICAgICAgfSkuYWRkKGUpLCBrLmlzTmV3ID0gITApO1xuICAgICAgICBjLnN0eWxlZE1vZGUgfHwgay5hdHRyKHtcbiAgICAgICAgICBzdHJva2U6IGguYm9yZGVyQ29sb3IsXG4gICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogaC5ib3JkZXJXaWR0aCB8fCAwLFxuICAgICAgICAgIGZpbGw6IGguYmFja2dyb3VuZENvbG9yIHx8IFwibm9uZVwiXG4gICAgICAgIH0pLnNoYWRvdyhoLnNoYWRvdyk7XG4gICAgICAgIDAgPCBnICYmIDAgPCBxICYmIChrW2suaXNOZXcgPyBcImF0dHJcIiA6IFwiYW5pbWF0ZVwiXShrLmNyaXNwLmNhbGwoe30sIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IGcsXG4gICAgICAgICAgaGVpZ2h0OiBxXG4gICAgICAgIH0sIGsuc3Ryb2tlV2lkdGgoKSkpLCBrLmlzTmV3ID0gITEpO1xuICAgICAgICBrW2QgPyBcInNob3dcIiA6IFwiaGlkZVwiXSgpO1xuICAgICAgICBjLnN0eWxlZE1vZGUgJiYgXCJub25lXCIgPT09IGUuZ2V0U3R5bGUoXCJkaXNwbGF5XCIpICYmIChnID0gcSA9IDApO1xuICAgICAgICB0aGlzLmxlZ2VuZFdpZHRoID0gZztcbiAgICAgICAgdGhpcy5sZWdlbmRIZWlnaHQgPSBxO1xuICAgICAgICBkICYmIChhID0gYy5zcGFjaW5nQm94LCBrID0gYS55LCAvKGx0aHxjdHxydGgpLy50ZXN0KHRoaXMuZ2V0QWxpZ25tZW50KCkpICYmIDAgPCBjLnRpdGxlT2Zmc2V0WzBdID8gayArPSBjLnRpdGxlT2Zmc2V0WzBdIDogLyhsYmh8Y2J8cmJoKS8udGVzdCh0aGlzLmdldEFsaWdubWVudCgpKSAmJiAwIDwgYy50aXRsZU9mZnNldFsyXSAmJiAoayAtPSBjLnRpdGxlT2Zmc2V0WzJdKSwgayAhPT0gYS55ICYmIChhID0geShhLCB7XG4gICAgICAgICAgeToga1xuICAgICAgICB9KSksIGUuYWxpZ24oeShoLCB7XG4gICAgICAgICAgd2lkdGg6IGcsXG4gICAgICAgICAgaGVpZ2h0OiBxLFxuICAgICAgICAgIHZlcnRpY2FsQWxpZ246IHRoaXMucHJveGltYXRlID8gXCJ0b3BcIiA6IGgudmVydGljYWxBbGlnblxuICAgICAgICB9KSwgITAsIGEpKTtcbiAgICAgICAgdGhpcy5wcm94aW1hdGUgfHwgdGhpcy5wb3NpdGlvbkl0ZW1zKCk7XG4gICAgICAgIEEodGhpcywgXCJhZnRlclJlbmRlclwiKTtcbiAgICAgIH07XG5cbiAgICAgIGMucHJvdG90eXBlLmhhbmRsZU92ZXJmbG93ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgZSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBmID0gZS5yZW5kZXJlcixcbiAgICAgICAgICAgIGQgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBrID0gZC55LFxuICAgICAgICAgICAgaCA9IHRoaXMucGFkZGluZztcbiAgICAgICAgayA9IGUuc3BhY2luZ0JveC5oZWlnaHQgKyAoXCJ0b3BcIiA9PT0gZC52ZXJ0aWNhbEFsaWduID8gLWsgOiBrKSAtIGg7XG5cbiAgICAgICAgdmFyIG4gPSBkLm1heEhlaWdodCxcbiAgICAgICAgICAgIGcsXG4gICAgICAgICAgICBxID0gdGhpcy5jbGlwUmVjdCxcbiAgICAgICAgICAgIHkgPSBkLm5hdmlnYXRpb24sXG4gICAgICAgICAgICBwID0gdCh5LmFuaW1hdGlvbiwgITApLFxuICAgICAgICAgICAgYiA9IHkuYXJyb3dTaXplIHx8IDEyLFxuICAgICAgICAgICAgQyA9IHRoaXMubmF2LFxuICAgICAgICAgICAgeCA9IHRoaXMucGFnZXMsXG4gICAgICAgICAgICBSLFxuICAgICAgICAgICAgTyA9IHRoaXMuYWxsSXRlbXMsXG4gICAgICAgICAgICB1ID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgYiA/IHEuYXR0cih7XG4gICAgICAgICAgICBoZWlnaHQ6IGJcbiAgICAgICAgICB9KSA6IHEgJiYgKGEuY2xpcFJlY3QgPSBxLmRlc3Ryb3koKSwgYS5jb250ZW50R3JvdXAuY2xpcCgpKTtcbiAgICAgICAgICBhLmNvbnRlbnRHcm91cC5kaXYgJiYgKGEuY29udGVudEdyb3VwLmRpdi5zdHlsZS5jbGlwID0gYiA/IFwicmVjdChcIiArIGggKyBcInB4LDk5OTlweCxcIiArIChoICsgYikgKyBcInB4LDApXCIgOiBcImF1dG9cIik7XG4gICAgICAgIH0sXG4gICAgICAgICAgICBEID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBhW2NdID0gZi5jaXJjbGUoMCwgMCwgMS4zICogYikudHJhbnNsYXRlKGIgLyAyLCBiIC8gMikuYWRkKEMpO1xuICAgICAgICAgIGUuc3R5bGVkTW9kZSB8fCBhW2NdLmF0dHIoXCJmaWxsXCIsIFwicmdiYSgwLDAsMCwwLjAwMDEpXCIpO1xuICAgICAgICAgIHJldHVybiBhW2NdO1xuICAgICAgICB9O1xuXG4gICAgICAgIFwiaG9yaXpvbnRhbFwiICE9PSBkLmxheW91dCB8fCBcIm1pZGRsZVwiID09PSBkLnZlcnRpY2FsQWxpZ24gfHwgZC5mbG9hdGluZyB8fCAoayAvPSAyKTtcbiAgICAgICAgbiAmJiAoayA9IE1hdGgubWluKGssIG4pKTtcbiAgICAgICAgeC5sZW5ndGggPSAwO1xuICAgICAgICBjID4gayAmJiAhMSAhPT0geS5lbmFibGVkID8gKHRoaXMuY2xpcEhlaWdodCA9IGcgPSBNYXRoLm1heChrIC0gMjAgLSB0aGlzLnRpdGxlSGVpZ2h0IC0gaCwgMCksIHRoaXMuY3VycmVudFBhZ2UgPSB0KHRoaXMuY3VycmVudFBhZ2UsIDEpLCB0aGlzLmZ1bGxIZWlnaHQgPSBjLCBPLmZvckVhY2goZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICB2YXIgYyA9IGIuX2xlZ2VuZEl0ZW1Qb3NbMV0sXG4gICAgICAgICAgICAgIGUgPSBNYXRoLnJvdW5kKGIubGVnZW5kSXRlbS5nZXRCQm94KCkuaGVpZ2h0KSxcbiAgICAgICAgICAgICAgZiA9IHgubGVuZ3RoO1xuICAgICAgICAgIGlmICghZiB8fCBjIC0geFtmIC0gMV0gPiBnICYmIChSIHx8IGMpICE9PSB4W2YgLSAxXSkgeC5wdXNoKFIgfHwgYyksIGYrKztcbiAgICAgICAgICBiLnBhZ2VJeCA9IGYgLSAxO1xuICAgICAgICAgIFIgJiYgKE9bYSAtIDFdLnBhZ2VJeCA9IGYgLSAxKTtcbiAgICAgICAgICBhID09PSBPLmxlbmd0aCAtIDEgJiYgYyArIGUgLSB4W2YgLSAxXSA+IGcgJiYgYyAhPT0gUiAmJiAoeC5wdXNoKGMpLCBiLnBhZ2VJeCA9IGYpO1xuICAgICAgICAgIGMgIT09IFIgJiYgKFIgPSBjKTtcbiAgICAgICAgfSksIHEgfHwgKHEgPSBhLmNsaXBSZWN0ID0gZi5jbGlwUmVjdCgwLCBoLCA5OTk5LCAwKSwgYS5jb250ZW50R3JvdXAuY2xpcChxKSksIHUoZyksIEMgfHwgKHRoaXMubmF2ID0gQyA9IGYuZygpLmF0dHIoe1xuICAgICAgICAgIHpJbmRleDogMVxuICAgICAgICB9KS5hZGQodGhpcy5ncm91cCksIHRoaXMudXAgPSBmLnN5bWJvbChcInRyaWFuZ2xlXCIsIDAsIDAsIGIsIGIpLmFkZChDKSwgRChcInVwVHJhY2tlclwiKS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhLnNjcm9sbCgtMSwgcCk7XG4gICAgICAgIH0pLCB0aGlzLnBhZ2VyID0gZi50ZXh0KFwiXCIsIDE1LCAxMCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWxlZ2VuZC1uYXZpZ2F0aW9uXCIpLCBlLnN0eWxlZE1vZGUgfHwgdGhpcy5wYWdlci5jc3MoeS5zdHlsZSksIHRoaXMucGFnZXIuYWRkKEMpLCB0aGlzLmRvd24gPSBmLnN5bWJvbChcInRyaWFuZ2xlLWRvd25cIiwgMCwgMCwgYiwgYikuYWRkKEMpLCBEKFwiZG93blRyYWNrZXJcIikub24oXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYS5zY3JvbGwoMSwgcCk7XG4gICAgICAgIH0pKSwgYS5zY3JvbGwoMCksIGMgPSBrKSA6IEMgJiYgKHUoKSwgdGhpcy5uYXYgPSBDLmRlc3Ryb3koKSwgdGhpcy5zY3JvbGxHcm91cC5hdHRyKHtcbiAgICAgICAgICB0cmFuc2xhdGVZOiAxXG4gICAgICAgIH0pLCB0aGlzLmNsaXBIZWlnaHQgPSAwKTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZS5zY3JvbGwgPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgICBmID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGsgPSB0aGlzLnBhZ2VzLFxuICAgICAgICAgICAgbiA9IGsubGVuZ3RoLFxuICAgICAgICAgICAgZyA9IHRoaXMuY3VycmVudFBhZ2UgKyBjO1xuICAgICAgICBjID0gdGhpcy5jbGlwSGVpZ2h0O1xuICAgICAgICB2YXIgeSA9IHRoaXMub3B0aW9ucy5uYXZpZ2F0aW9uLFxuICAgICAgICAgICAgdSA9IHRoaXMucGFnZXIsXG4gICAgICAgICAgICBIID0gdGhpcy5wYWRkaW5nO1xuICAgICAgICBnID4gbiAmJiAoZyA9IG4pO1xuICAgICAgICAwIDwgZyAmJiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGEgJiYgaChhLCBmKSwgdGhpcy5uYXYuYXR0cih7XG4gICAgICAgICAgdHJhbnNsYXRlWDogSCxcbiAgICAgICAgICB0cmFuc2xhdGVZOiBjICsgdGhpcy5wYWRkaW5nICsgNyArIHRoaXMudGl0bGVIZWlnaHQsXG4gICAgICAgICAgdmlzaWJpbGl0eTogXCJ2aXNpYmxlXCJcbiAgICAgICAgfSksIFt0aGlzLnVwLCB0aGlzLnVwVHJhY2tlcl0uZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEuYXR0cih7XG4gICAgICAgICAgICBcImNsYXNzXCI6IDEgPT09IGcgPyBcImhpZ2hjaGFydHMtbGVnZW5kLW5hdi1pbmFjdGl2ZVwiIDogXCJoaWdoY2hhcnRzLWxlZ2VuZC1uYXYtYWN0aXZlXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksIHUuYXR0cih7XG4gICAgICAgICAgdGV4dDogZyArIFwiL1wiICsgblxuICAgICAgICB9KSwgW3RoaXMuZG93biwgdGhpcy5kb3duVHJhY2tlcl0uZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEuYXR0cih7XG4gICAgICAgICAgICB4OiAxOCArIHRoaXMucGFnZXIuZ2V0QkJveCgpLndpZHRoLFxuICAgICAgICAgICAgXCJjbGFzc1wiOiBnID09PSBuID8gXCJoaWdoY2hhcnRzLWxlZ2VuZC1uYXYtaW5hY3RpdmVcIiA6IFwiaGlnaGNoYXJ0cy1sZWdlbmQtbmF2LWFjdGl2ZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRoaXMpLCBmLnN0eWxlZE1vZGUgfHwgKHRoaXMudXAuYXR0cih7XG4gICAgICAgICAgZmlsbDogMSA9PT0gZyA/IHkuaW5hY3RpdmVDb2xvciA6IHkuYWN0aXZlQ29sb3JcbiAgICAgICAgfSksIHRoaXMudXBUcmFja2VyLmNzcyh7XG4gICAgICAgICAgY3Vyc29yOiAxID09PSBnID8gXCJkZWZhdWx0XCIgOiBcInBvaW50ZXJcIlxuICAgICAgICB9KSwgdGhpcy5kb3duLmF0dHIoe1xuICAgICAgICAgIGZpbGw6IGcgPT09IG4gPyB5LmluYWN0aXZlQ29sb3IgOiB5LmFjdGl2ZUNvbG9yXG4gICAgICAgIH0pLCB0aGlzLmRvd25UcmFja2VyLmNzcyh7XG4gICAgICAgICAgY3Vyc29yOiBnID09PSBuID8gXCJkZWZhdWx0XCIgOiBcInBvaW50ZXJcIlxuICAgICAgICB9KSksIHRoaXMuc2Nyb2xsT2Zmc2V0ID0gLWtbZyAtIDFdICsgdGhpcy5pbml0aWFsSXRlbVksIHRoaXMuc2Nyb2xsR3JvdXAuYW5pbWF0ZSh7XG4gICAgICAgICAgdHJhbnNsYXRlWTogdGhpcy5zY3JvbGxPZmZzZXRcbiAgICAgICAgfSksIHRoaXMuY3VycmVudFBhZ2UgPSBnLCB0aGlzLnBvc2l0aW9uQ2hlY2tib3hlcygpLCBhID0gZC5hbmltT2JqZWN0KHQoYSwgZi5yZW5kZXJlci5nbG9iYWxBbmltYXRpb24sICEwKSksIHEoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIEEoZSwgXCJhZnRlclNjcm9sbFwiLCB7XG4gICAgICAgICAgICBjdXJyZW50UGFnZTogZ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBhLmR1cmF0aW9uIHx8IDApKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBjO1xuICAgIH0oKTtcblxuICAgICgvVHJpZGVudFxcLzdcXC4wLy50ZXN0KGMubmF2aWdhdG9yICYmIGMubmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgUCkgJiYgZyhrLnByb3RvdHlwZSwgXCJwb3NpdGlvbkl0ZW1cIiwgZnVuY3Rpb24gKGMsIGUpIHtcbiAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICBmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBlLl9sZWdlbmRJdGVtUG9zICYmIGMuY2FsbChhLCBlKTtcbiAgICAgIH07XG5cbiAgICAgIGYoKTtcbiAgICAgIGEuYnViYmxlTGVnZW5kIHx8IHNldFRpbWVvdXQoZik7XG4gICAgfSk7XG4gICAgZC5MZWdlbmQgPSBrO1xuICAgIHJldHVybiBkLkxlZ2VuZDtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9DaGFydC5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9MZWdlbmQuanNcIl0sIHJbXCJwYXJ0cy9NU1BvaW50ZXIuanNcIl0sIHJbXCJwYXJ0cy9Qb2ludGVyLmpzXCJdLCByW1wicGFydHMvVGltZS5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnLCByLCB1LCBJLCBNKSB7XG4gICAgdmFyIEUgPSBNLmFkZEV2ZW50LFxuICAgICAgICBBID0gTS5hbmltYXRlLFxuICAgICAgICBHID0gTS5hbmltT2JqZWN0LFxuICAgICAgICBKID0gTS5hdHRyLFxuICAgICAgICB5ID0gTS5jcmVhdGVFbGVtZW50LFxuICAgICAgICB0ID0gTS5jc3MsXG4gICAgICAgIEQgPSBNLmRlZmluZWQsXG4gICAgICAgIGggPSBNLmRpc2NhcmRFbGVtZW50LFxuICAgICAgICBOID0gTS5lcmFzZSxcbiAgICAgICAgcSA9IE0uZXJyb3IsXG4gICAgICAgIFAgPSBNLmV4dGVuZCxcbiAgICAgICAgZSA9IE0uZmluZCxcbiAgICAgICAgYyA9IE0uZmlyZUV2ZW50LFxuICAgICAgICBrID0gTS5nZXRTdHlsZSxcbiAgICAgICAgbiA9IE0uaXNBcnJheSxcbiAgICAgICAgZiA9IE0uaXNGdW5jdGlvbixcbiAgICAgICAgYSA9IE0uaXNOdW1iZXIsXG4gICAgICAgIGwgPSBNLmlzT2JqZWN0LFxuICAgICAgICB2ID0gTS5pc1N0cmluZyxcbiAgICAgICAgeiA9IE0ubWVyZ2UsXG4gICAgICAgIHcgPSBNLm51bWJlckZvcm1hdCxcbiAgICAgICAgQiA9IE0ub2JqZWN0RWFjaCxcbiAgICAgICAgTCA9IE0ucGljayxcbiAgICAgICAgUSA9IE0ucEludCxcbiAgICAgICAgSCA9IE0ucmVsYXRpdmVMZW5ndGgsXG4gICAgICAgIEsgPSBNLnJlbW92ZUV2ZW50LFxuICAgICAgICBwID0gTS5zZXRBbmltYXRpb24sXG4gICAgICAgIGIgPSBNLnNwbGF0LFxuICAgICAgICBDID0gTS5zeW5jVGltZW91dCxcbiAgICAgICAgeCA9IE0udW5pcXVlS2V5LFxuICAgICAgICBSID0gZC5kb2MsXG4gICAgICAgIE8gPSBkLkF4aXMsXG4gICAgICAgIFggPSBkLmRlZmF1bHRPcHRpb25zLFxuICAgICAgICBVID0gZC5jaGFydHMsXG4gICAgICAgIG0gPSBkLm1hcmdpbk5hbWVzLFxuICAgICAgICBUID0gZC5zZXJpZXNUeXBlcyxcbiAgICAgICAgWiA9IGQud2luLFxuICAgICAgICBjYSA9IGQuQ2hhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmdldEFyZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgZC5jaGFydCA9IGZ1bmN0aW9uIChiLCBhLCBjKSB7XG4gICAgICByZXR1cm4gbmV3IGNhKGIsIGEsIGMpO1xuICAgIH07XG5cbiAgICBQKGNhLnByb3RvdHlwZSwge1xuICAgICAgY2FsbGJhY2tzOiBbXSxcbiAgICAgIGdldEFyZ3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh2KGJbMF0pIHx8IGJbMF0ubm9kZU5hbWUpIHRoaXMucmVuZGVyVG8gPSBiLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuaW5pdChiWzBdLCBiWzFdKTtcbiAgICAgIH0sXG4gICAgICBpbml0OiBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICB2YXIgZSxcbiAgICAgICAgICAgIGsgPSBiLnNlcmllcyxcbiAgICAgICAgICAgIGggPSBiLnBsb3RPcHRpb25zIHx8IHt9O1xuICAgICAgICBjKHRoaXMsIFwiaW5pdFwiLCB7XG4gICAgICAgICAgYXJnczogYXJndW1lbnRzXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBiLnNlcmllcyA9IG51bGw7XG4gICAgICAgICAgZSA9IHooWCwgYik7XG4gICAgICAgICAgQihlLnBsb3RPcHRpb25zLCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgICAgbChiKSAmJiAoYi50b29sdGlwID0gaFthXSAmJiB6KGhbYV0udG9vbHRpcCkgfHwgdm9pZCAwKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlLnRvb2x0aXAudXNlck9wdGlvbnMgPSBiLmNoYXJ0ICYmIGIuY2hhcnQuZm9yRXhwb3J0ICYmIGIudG9vbHRpcC51c2VyT3B0aW9ucyB8fCBiLnRvb2x0aXA7XG4gICAgICAgICAgZS5zZXJpZXMgPSBiLnNlcmllcyA9IGs7XG4gICAgICAgICAgdGhpcy51c2VyT3B0aW9ucyA9IGI7XG4gICAgICAgICAgdmFyIG0gPSBlLmNoYXJ0LFxuICAgICAgICAgICAgICBuID0gbS5ldmVudHM7XG4gICAgICAgICAgdGhpcy5tYXJnaW4gPSBbXTtcbiAgICAgICAgICB0aGlzLnNwYWNpbmcgPSBbXTtcbiAgICAgICAgICB0aGlzLmJvdW5kcyA9IHtcbiAgICAgICAgICAgIGg6IHt9LFxuICAgICAgICAgICAgdjoge31cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMubGFiZWxDb2xsZWN0b3JzID0gW107XG4gICAgICAgICAgdGhpcy5jYWxsYmFjayA9IGE7XG4gICAgICAgICAgdGhpcy5pc1Jlc2l6aW5nID0gMDtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBlO1xuICAgICAgICAgIHRoaXMuYXhlcyA9IFtdO1xuICAgICAgICAgIHRoaXMuc2VyaWVzID0gW107XG4gICAgICAgICAgdGhpcy50aW1lID0gYi50aW1lICYmIE9iamVjdC5rZXlzKGIudGltZSkubGVuZ3RoID8gbmV3IEkoYi50aW1lKSA6IGQudGltZTtcbiAgICAgICAgICB0aGlzLm51bWJlckZvcm1hdHRlciA9IG0ubnVtYmVyRm9ybWF0dGVyIHx8IHc7XG4gICAgICAgICAgdGhpcy5zdHlsZWRNb2RlID0gbS5zdHlsZWRNb2RlO1xuICAgICAgICAgIHRoaXMuaGFzQ2FydGVzaWFuU2VyaWVzID0gbS5zaG93QXhlcztcbiAgICAgICAgICB2YXIgcCA9IHRoaXM7XG4gICAgICAgICAgcC5pbmRleCA9IFUubGVuZ3RoO1xuICAgICAgICAgIFUucHVzaChwKTtcbiAgICAgICAgICBkLmNoYXJ0Q291bnQrKztcbiAgICAgICAgICBuICYmIEIobiwgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICAgIGYoYikgJiYgRShwLCBhLCBiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwLnhBeGlzID0gW107XG4gICAgICAgICAgcC55QXhpcyA9IFtdO1xuICAgICAgICAgIHAucG9pbnRDb3VudCA9IHAuY29sb3JDb3VudGVyID0gcC5zeW1ib2xDb3VudGVyID0gMDtcbiAgICAgICAgICBjKHAsIFwiYWZ0ZXJJbml0XCIpO1xuICAgICAgICAgIHAuZmlyc3RSZW5kZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgaW5pdFNlcmllczogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9wdGlvbnMuY2hhcnQ7XG4gICAgICAgIGEgPSBiLnR5cGUgfHwgYS50eXBlIHx8IGEuZGVmYXVsdFNlcmllc1R5cGU7XG4gICAgICAgIHZhciBjID0gVFthXTtcbiAgICAgICAgYyB8fCBxKDE3LCAhMCwgdGhpcywge1xuICAgICAgICAgIG1pc3NpbmdNb2R1bGVGb3I6IGFcbiAgICAgICAgfSk7XG4gICAgICAgIGEgPSBuZXcgYygpO1xuICAgICAgICBhLmluaXQodGhpcywgYik7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSxcbiAgICAgIHNldFNlcmllc0RhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5nZXRTZXJpZXNPcmRlckJ5TGlua3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYi5wb2ludHMgfHwgYi5kYXRhIHx8ICFiLmVuYWJsZWREYXRhU29ydGluZyB8fCBiLnNldERhdGEoYi5vcHRpb25zLmRhdGEsICExKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZ2V0U2VyaWVzT3JkZXJCeUxpbmtzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcmllcy5jb25jYXQoKS5zb3J0KGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgcmV0dXJuIGIubGlua2VkU2VyaWVzLmxlbmd0aCB8fCBhLmxpbmtlZFNlcmllcy5sZW5ndGggPyBhLmxpbmtlZFNlcmllcy5sZW5ndGggLSBiLmxpbmtlZFNlcmllcy5sZW5ndGggOiAwO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvcmRlclNlcmllczogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLnNlcmllcztcblxuICAgICAgICBmb3IgKGIgPSBiIHx8IDA7IGIgPCBhLmxlbmd0aDsgYisrKSBhW2JdICYmIChhW2JdLmluZGV4ID0gYiwgYVtiXS5uYW1lID0gYVtiXS5nZXROYW1lKCkpO1xuICAgICAgfSxcbiAgICAgIGlzSW5zaWRlUGxvdDogZnVuY3Rpb24gKGIsIGEsIGUpIHtcbiAgICAgICAgdmFyIGYgPSBlID8gYSA6IGI7XG4gICAgICAgIGIgPSBlID8gYiA6IGE7XG4gICAgICAgIGYgPSB7XG4gICAgICAgICAgeDogZixcbiAgICAgICAgICB5OiBiLFxuICAgICAgICAgIGlzSW5zaWRlUGxvdDogMCA8PSBmICYmIGYgPD0gdGhpcy5wbG90V2lkdGggJiYgMCA8PSBiICYmIGIgPD0gdGhpcy5wbG90SGVpZ2h0XG4gICAgICAgIH07XG4gICAgICAgIGModGhpcywgXCJhZnRlcklzSW5zaWRlUGxvdFwiLCBmKTtcbiAgICAgICAgcmV0dXJuIGYuaXNJbnNpZGVQbG90O1xuICAgICAgfSxcbiAgICAgIHJlZHJhdzogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgYyh0aGlzLCBcImJlZm9yZVJlZHJhd1wiKTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmF4ZXMsXG4gICAgICAgICAgICBlID0gdGhpcy5zZXJpZXMsXG4gICAgICAgICAgICBmID0gdGhpcy5wb2ludGVyLFxuICAgICAgICAgICAgZCA9IHRoaXMubGVnZW5kLFxuICAgICAgICAgICAgayA9IHRoaXMudXNlck9wdGlvbnMubGVnZW5kLFxuICAgICAgICAgICAgbCA9IHRoaXMuaXNEaXJ0eUxlZ2VuZCxcbiAgICAgICAgICAgIGggPSB0aGlzLmhhc0NhcnRlc2lhblNlcmllcyxcbiAgICAgICAgICAgIG0gPSB0aGlzLmlzRGlydHlCb3gsXG4gICAgICAgICAgICBuID0gdGhpcy5yZW5kZXJlcixcbiAgICAgICAgICAgIHggPSBuLmlzSGlkZGVuKCksXG4gICAgICAgICAgICBnID0gW107XG4gICAgICAgIHRoaXMuc2V0UmVzcG9uc2l2ZSAmJiB0aGlzLnNldFJlc3BvbnNpdmUoITEpO1xuICAgICAgICBwKHRoaXMuaGFzUmVuZGVyZWQgPyBiIDogITEsIHRoaXMpO1xuICAgICAgICB4ICYmIHRoaXMudGVtcG9yYXJ5RGlzcGxheSgpO1xuICAgICAgICB0aGlzLmxheU91dFRpdGxlcygpO1xuXG4gICAgICAgIGZvciAoYiA9IGUubGVuZ3RoOyBiLS07KSB7XG4gICAgICAgICAgdmFyIHcgPSBlW2JdO1xuXG4gICAgICAgICAgaWYgKHcub3B0aW9ucy5zdGFja2luZykge1xuICAgICAgICAgICAgdmFyIEMgPSAhMDtcblxuICAgICAgICAgICAgaWYgKHcuaXNEaXJ0eSkge1xuICAgICAgICAgICAgICB2YXIgdiA9ICEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodikgZm9yIChiID0gZS5sZW5ndGg7IGItLTspIHcgPSBlW2JdLCB3Lm9wdGlvbnMuc3RhY2tpbmcgJiYgKHcuaXNEaXJ0eSA9ICEwKTtcbiAgICAgICAgZS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYi5pc0RpcnR5ICYmIChcInBvaW50XCIgPT09IGIub3B0aW9ucy5sZWdlbmRUeXBlID8gKGIudXBkYXRlVG90YWxzICYmIGIudXBkYXRlVG90YWxzKCksIGwgPSAhMCkgOiBrICYmIChrLmxhYmVsRm9ybWF0dGVyIHx8IGsubGFiZWxGb3JtYXQpICYmIChsID0gITApKTtcbiAgICAgICAgICBiLmlzRGlydHlEYXRhICYmIGMoYiwgXCJ1cGRhdGVkRGF0YVwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGwgJiYgZCAmJiBkLm9wdGlvbnMuZW5hYmxlZCAmJiAoZC5yZW5kZXIoKSwgdGhpcy5pc0RpcnR5TGVnZW5kID0gITEpO1xuICAgICAgICBDICYmIHRoaXMuZ2V0U3RhY2tzKCk7XG4gICAgICAgIGggJiYgYS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYi51cGRhdGVOYW1lcygpO1xuICAgICAgICAgIGIuc2V0U2NhbGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ2V0TWFyZ2lucygpO1xuICAgICAgICBoICYmIChhLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBiLmlzRGlydHkgJiYgKG0gPSAhMCk7XG4gICAgICAgIH0pLCBhLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICB2YXIgYSA9IGIubWluICsgXCIsXCIgKyBiLm1heDtcbiAgICAgICAgICBiLmV4dEtleSAhPT0gYSAmJiAoYi5leHRLZXkgPSBhLCBnLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYyhiLCBcImFmdGVyU2V0RXh0cmVtZXNcIiwgUChiLmV2ZW50QXJncywgYi5nZXRFeHRyZW1lcygpKSk7XG4gICAgICAgICAgICBkZWxldGUgYi5ldmVudEFyZ3M7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIChtIHx8IEMpICYmIGIucmVkcmF3KCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgbSAmJiB0aGlzLmRyYXdDaGFydEJveCgpO1xuICAgICAgICBjKHRoaXMsIFwicHJlZHJhd1wiKTtcbiAgICAgICAgZS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgKG0gfHwgYi5pc0RpcnR5KSAmJiBiLnZpc2libGUgJiYgYi5yZWRyYXcoKTtcbiAgICAgICAgICBiLmlzRGlydHlEYXRhID0gITE7XG4gICAgICAgIH0pO1xuICAgICAgICBmICYmIGYucmVzZXQoITApO1xuICAgICAgICBuLmRyYXcoKTtcbiAgICAgICAgYyh0aGlzLCBcInJlZHJhd1wiKTtcbiAgICAgICAgYyh0aGlzLCBcInJlbmRlclwiKTtcbiAgICAgICAgeCAmJiB0aGlzLnRlbXBvcmFyeURpc3BsYXkoITApO1xuICAgICAgICBnLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBiLmNhbGwoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoYikge1xuICAgICAgICBmdW5jdGlvbiBhKGEpIHtcbiAgICAgICAgICByZXR1cm4gYS5pZCA9PT0gYiB8fCBhLm9wdGlvbnMgJiYgYS5vcHRpb25zLmlkID09PSBiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSB0aGlzLnNlcmllcyxcbiAgICAgICAgICAgIGY7XG4gICAgICAgIHZhciBkID0gZSh0aGlzLmF4ZXMsIGEpIHx8IGUodGhpcy5zZXJpZXMsIGEpO1xuXG4gICAgICAgIGZvciAoZiA9IDA7ICFkICYmIGYgPCBjLmxlbmd0aDsgZisrKSBkID0gZShjW2ZdLnBvaW50cyB8fCBbXSwgYSk7XG5cbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9LFxuICAgICAgZ2V0QXhlczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICBlID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgZiA9IGUueEF4aXMgPSBiKGUueEF4aXMgfHwge30pO1xuICAgICAgICBlID0gZS55QXhpcyA9IGIoZS55QXhpcyB8fCB7fSk7XG4gICAgICAgIGModGhpcywgXCJnZXRBeGVzXCIpO1xuICAgICAgICBmLmZvckVhY2goZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBiLmluZGV4ID0gYTtcbiAgICAgICAgICBiLmlzWCA9ICEwO1xuICAgICAgICB9KTtcbiAgICAgICAgZS5mb3JFYWNoKGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgYi5pbmRleCA9IGE7XG4gICAgICAgIH0pO1xuICAgICAgICBmLmNvbmNhdChlKS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgbmV3IE8oYSwgYik7XG4gICAgICAgIH0pO1xuICAgICAgICBjKHRoaXMsIFwiYWZ0ZXJHZXRBeGVzXCIpO1xuICAgICAgfSxcbiAgICAgIGdldFNlbGVjdGVkUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gW107XG4gICAgICAgIHRoaXMuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBiID0gYi5jb25jYXQoYS5nZXRQb2ludHNDb2xsZWN0aW9uKCkuZmlsdGVyKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICByZXR1cm4gTChiLnNlbGVjdGVkU3RhZ2luZywgYi5zZWxlY3RlZCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9LFxuICAgICAgZ2V0U2VsZWN0ZWRTZXJpZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWVzLmZpbHRlcihmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHJldHVybiBiLnNlbGVjdGVkO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzZXRUaXRsZTogZnVuY3Rpb24gKGIsIGEsIGMpIHtcbiAgICAgICAgdGhpcy5hcHBseURlc2NyaXB0aW9uKFwidGl0bGVcIiwgYik7XG4gICAgICAgIHRoaXMuYXBwbHlEZXNjcmlwdGlvbihcInN1YnRpdGxlXCIsIGEpO1xuICAgICAgICB0aGlzLmFwcGx5RGVzY3JpcHRpb24oXCJjYXB0aW9uXCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMubGF5T3V0VGl0bGVzKGMpO1xuICAgICAgfSxcbiAgICAgIGFwcGx5RGVzY3JpcHRpb246IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIHZhciBjID0gdGhpcyxcbiAgICAgICAgICAgIGUgPSBcInRpdGxlXCIgPT09IGIgPyB7XG4gICAgICAgICAgY29sb3I6IFwiIzMzMzMzM1wiLFxuICAgICAgICAgIGZvbnRTaXplOiB0aGlzLm9wdGlvbnMuaXNTdG9jayA/IFwiMTZweFwiIDogXCIxOHB4XCJcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBjb2xvcjogXCIjNjY2NjY2XCJcbiAgICAgICAgfTtcbiAgICAgICAgZSA9IHRoaXMub3B0aW9uc1tiXSA9IHooIXRoaXMuc3R5bGVkTW9kZSAmJiB7XG4gICAgICAgICAgc3R5bGU6IGVcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zW2JdLCBhKTtcbiAgICAgICAgdmFyIGYgPSB0aGlzW2JdO1xuICAgICAgICBmICYmIGEgJiYgKHRoaXNbYl0gPSBmID0gZi5kZXN0cm95KCkpO1xuICAgICAgICBlICYmICFmICYmIChmID0gdGhpcy5yZW5kZXJlci50ZXh0KGUudGV4dCwgMCwgMCwgZS51c2VIVE1MKS5hdHRyKHtcbiAgICAgICAgICBhbGlnbjogZS5hbGlnbixcbiAgICAgICAgICBcImNsYXNzXCI6IFwiaGlnaGNoYXJ0cy1cIiArIGIsXG4gICAgICAgICAgekluZGV4OiBlLnpJbmRleCB8fCA0XG4gICAgICAgIH0pLmFkZCgpLCBmLnVwZGF0ZSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgY1t7XG4gICAgICAgICAgICB0aXRsZTogXCJzZXRUaXRsZVwiLFxuICAgICAgICAgICAgc3VidGl0bGU6IFwic2V0U3VidGl0bGVcIixcbiAgICAgICAgICAgIGNhcHRpb246IFwic2V0Q2FwdGlvblwiXG4gICAgICAgICAgfVtiXV0oYSk7XG4gICAgICAgIH0sIHRoaXMuc3R5bGVkTW9kZSB8fCBmLmNzcyhlLnN0eWxlKSwgdGhpc1tiXSA9IGYpO1xuICAgICAgfSxcbiAgICAgIGxheU91dFRpdGxlczogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSBbMCwgMCwgMF0sXG4gICAgICAgICAgICBlID0gdGhpcy5yZW5kZXJlcixcbiAgICAgICAgICAgIGYgPSB0aGlzLnNwYWNpbmdCb3g7XG4gICAgICAgIFtcInRpdGxlXCIsIFwic3VidGl0bGVcIiwgXCJjYXB0aW9uXCJdLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICB2YXIgYyA9IHRoaXNbYl0sXG4gICAgICAgICAgICAgIGQgPSB0aGlzLm9wdGlvbnNbYl0sXG4gICAgICAgICAgICAgIGsgPSBkLnZlcnRpY2FsQWxpZ24gfHwgXCJ0b3BcIjtcbiAgICAgICAgICBiID0gXCJ0aXRsZVwiID09PSBiID8gLTMgOiBcInRvcFwiID09PSBrID8gYVswXSArIDIgOiAwO1xuXG4gICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdHlsZWRNb2RlKSB2YXIgbCA9IGQuc3R5bGUuZm9udFNpemU7XG4gICAgICAgICAgICBsID0gZS5mb250TWV0cmljcyhsLCBjKS5iO1xuICAgICAgICAgICAgYy5jc3Moe1xuICAgICAgICAgICAgICB3aWR0aDogKGQud2lkdGggfHwgZi53aWR0aCArIChkLndpZHRoQWRqdXN0IHx8IDApKSArIFwicHhcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaCA9IE1hdGgucm91bmQoYy5nZXRCQm94KGQudXNlSFRNTCkuaGVpZ2h0KTtcbiAgICAgICAgICAgIGMuYWxpZ24oUCh7XG4gICAgICAgICAgICAgIHk6IFwiYm90dG9tXCIgPT09IGsgPyBsIDogYiArIGwsXG4gICAgICAgICAgICAgIGhlaWdodDogaFxuICAgICAgICAgICAgfSwgZCksICExLCBcInNwYWNpbmdCb3hcIik7XG4gICAgICAgICAgICBkLmZsb2F0aW5nIHx8IChcInRvcFwiID09PSBrID8gYVswXSA9IE1hdGguY2VpbChhWzBdICsgaCkgOiBcImJvdHRvbVwiID09PSBrICYmIChhWzJdID0gTWF0aC5jZWlsKGFbMl0gKyBoKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGFbMF0gJiYgXCJ0b3BcIiA9PT0gKHRoaXMub3B0aW9ucy50aXRsZS52ZXJ0aWNhbEFsaWduIHx8IFwidG9wXCIpICYmIChhWzBdICs9IHRoaXMub3B0aW9ucy50aXRsZS5tYXJnaW4pO1xuICAgICAgICBhWzJdICYmIFwiYm90dG9tXCIgPT09IHRoaXMub3B0aW9ucy5jYXB0aW9uLnZlcnRpY2FsQWxpZ24gJiYgKGFbMl0gKz0gdGhpcy5vcHRpb25zLmNhcHRpb24ubWFyZ2luKTtcbiAgICAgICAgdmFyIGQgPSAhdGhpcy50aXRsZU9mZnNldCB8fCB0aGlzLnRpdGxlT2Zmc2V0LmpvaW4oXCIsXCIpICE9PSBhLmpvaW4oXCIsXCIpO1xuICAgICAgICB0aGlzLnRpdGxlT2Zmc2V0ID0gYTtcbiAgICAgICAgYyh0aGlzLCBcImFmdGVyTGF5T3V0VGl0bGVzXCIpO1xuICAgICAgICAhdGhpcy5pc0RpcnR5Qm94ICYmIGQgJiYgKHRoaXMuaXNEaXJ0eUJveCA9IHRoaXMuaXNEaXJ0eUxlZ2VuZCA9IGQsIHRoaXMuaGFzUmVuZGVyZWQgJiYgTChiLCAhMCkgJiYgdGhpcy5pc0RpcnR5Qm94ICYmIHRoaXMucmVkcmF3KCkpO1xuICAgICAgfSxcbiAgICAgIGdldENoYXJ0U2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMub3B0aW9ucy5jaGFydCxcbiAgICAgICAgICAgIGEgPSBiLndpZHRoO1xuICAgICAgICBiID0gYi5oZWlnaHQ7XG4gICAgICAgIHZhciBjID0gdGhpcy5yZW5kZXJUbztcbiAgICAgICAgRChhKSB8fCAodGhpcy5jb250YWluZXJXaWR0aCA9IGsoYywgXCJ3aWR0aFwiKSk7XG4gICAgICAgIEQoYikgfHwgKHRoaXMuY29udGFpbmVySGVpZ2h0ID0gayhjLCBcImhlaWdodFwiKSk7XG4gICAgICAgIHRoaXMuY2hhcnRXaWR0aCA9IE1hdGgubWF4KDAsIGEgfHwgdGhpcy5jb250YWluZXJXaWR0aCB8fCA2MDApO1xuICAgICAgICB0aGlzLmNoYXJ0SGVpZ2h0ID0gTWF0aC5tYXgoMCwgSChiLCB0aGlzLmNoYXJ0V2lkdGgpIHx8ICgxIDwgdGhpcy5jb250YWluZXJIZWlnaHQgPyB0aGlzLmNvbnRhaW5lckhlaWdodCA6IDQwMCkpO1xuICAgICAgfSxcbiAgICAgIHRlbXBvcmFyeURpc3BsYXk6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5yZW5kZXJUbztcbiAgICAgICAgaWYgKGIpIGZvciAoOyBhICYmIGEuc3R5bGU7KSBhLmhjT3JpZ1N0eWxlICYmICh0KGEsIGEuaGNPcmlnU3R5bGUpLCBkZWxldGUgYS5oY09yaWdTdHlsZSksIGEuaGNPcmlnRGV0YWNoZWQgJiYgKFIuYm9keS5yZW1vdmVDaGlsZChhKSwgYS5oY09yaWdEZXRhY2hlZCA9ICExKSwgYSA9IGEucGFyZW50Tm9kZTtlbHNlIGZvciAoOyBhICYmIGEuc3R5bGU7KSB7XG4gICAgICAgICAgUi5ib2R5LmNvbnRhaW5zKGEpIHx8IGEucGFyZW50Tm9kZSB8fCAoYS5oY09yaWdEZXRhY2hlZCA9ICEwLCBSLmJvZHkuYXBwZW5kQ2hpbGQoYSkpO1xuICAgICAgICAgIGlmIChcIm5vbmVcIiA9PT0gayhhLCBcImRpc3BsYXlcIiwgITEpIHx8IGEuaGNPcmljRGV0YWNoZWQpIGEuaGNPcmlnU3R5bGUgPSB7XG4gICAgICAgICAgICBkaXNwbGF5OiBhLnN0eWxlLmRpc3BsYXksXG4gICAgICAgICAgICBoZWlnaHQ6IGEuc3R5bGUuaGVpZ2h0LFxuICAgICAgICAgICAgb3ZlcmZsb3c6IGEuc3R5bGUub3ZlcmZsb3dcbiAgICAgICAgICB9LCBiID0ge1xuICAgICAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCJcbiAgICAgICAgICB9LCBhICE9PSB0aGlzLnJlbmRlclRvICYmIChiLmhlaWdodCA9IDApLCB0KGEsIGIpLCBhLm9mZnNldFdpZHRoIHx8IGEuc3R5bGUuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIiwgXCJpbXBvcnRhbnRcIik7XG4gICAgICAgICAgYSA9IGEucGFyZW50Tm9kZTtcbiAgICAgICAgICBpZiAoYSA9PT0gUi5ib2R5KSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldENsYXNzTmFtZTogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gXCJoaWdoY2hhcnRzLWNvbnRhaW5lciBcIiArIChiIHx8IFwiXCIpO1xuICAgICAgfSxcbiAgICAgIGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGUgPSBiLmNoYXJ0O1xuICAgICAgICB2YXIgZiA9IHRoaXMucmVuZGVyVG87XG4gICAgICAgIHZhciBrID0geCgpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGg7XG4gICAgICAgIGYgfHwgKHRoaXMucmVuZGVyVG8gPSBmID0gZS5yZW5kZXJUbyk7XG4gICAgICAgIHYoZikgJiYgKHRoaXMucmVuZGVyVG8gPSBmID0gUi5nZXRFbGVtZW50QnlJZChmKSk7XG4gICAgICAgIGYgfHwgcSgxMywgITAsIHRoaXMpO1xuICAgICAgICB2YXIgbSA9IFEoSihmLCBcImRhdGEtaGlnaGNoYXJ0cy1jaGFydFwiKSk7XG4gICAgICAgIGEobSkgJiYgVVttXSAmJiBVW21dLmhhc1JlbmRlcmVkICYmIFVbbV0uZGVzdHJveSgpO1xuICAgICAgICBKKGYsIFwiZGF0YS1oaWdoY2hhcnRzLWNoYXJ0XCIsIHRoaXMuaW5kZXgpO1xuICAgICAgICBmLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIGUuc2tpcENsb25lIHx8IGYub2Zmc2V0V2lkdGggfHwgdGhpcy50ZW1wb3JhcnlEaXNwbGF5KCk7XG4gICAgICAgIHRoaXMuZ2V0Q2hhcnRTaXplKCk7XG4gICAgICAgIG0gPSB0aGlzLmNoYXJ0V2lkdGg7XG4gICAgICAgIHZhciBuID0gdGhpcy5jaGFydEhlaWdodDtcbiAgICAgICAgdChmLCB7XG4gICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3R5bGVkTW9kZSB8fCAobCA9IFAoe1xuICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgd2lkdGg6IG0gKyBcInB4XCIsXG4gICAgICAgICAgaGVpZ2h0OiBuICsgXCJweFwiLFxuICAgICAgICAgIHRleHRBbGlnbjogXCJsZWZ0XCIsXG4gICAgICAgICAgbGluZUhlaWdodDogXCJub3JtYWxcIixcbiAgICAgICAgICB6SW5kZXg6IDAsXG4gICAgICAgICAgXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIjogXCJyZ2JhKDAsMCwwLDApXCJcbiAgICAgICAgfSwgZS5zdHlsZSkpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGYgPSB5KFwiZGl2XCIsIHtcbiAgICAgICAgICBpZDoga1xuICAgICAgICB9LCBsLCBmKTtcbiAgICAgICAgdGhpcy5fY3Vyc29yID0gZi5zdHlsZS5jdXJzb3I7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgKGRbZS5yZW5kZXJlcl0gfHwgZC5SZW5kZXJlcikoZiwgbSwgbiwgbnVsbCwgZS5mb3JFeHBvcnQsIGIuZXhwb3J0aW5nICYmIGIuZXhwb3J0aW5nLmFsbG93SFRNTCwgdGhpcy5zdHlsZWRNb2RlKTtcbiAgICAgICAgcCh2b2lkIDAsIHRoaXMpO1xuICAgICAgICB0aGlzLnNldENsYXNzTmFtZShlLmNsYXNzTmFtZSk7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlZE1vZGUpIGZvciAoaCBpbiBiLmRlZnMpIHRoaXMucmVuZGVyZXIuZGVmaW5pdGlvbihiLmRlZnNbaF0pO2Vsc2UgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlLnN0eWxlKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5jaGFydEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgYyh0aGlzLCBcImFmdGVyR2V0Q29udGFpbmVyXCIpO1xuICAgICAgfSxcbiAgICAgIGdldE1hcmdpbnM6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5zcGFjaW5nLFxuICAgICAgICAgICAgZSA9IHRoaXMubWFyZ2luLFxuICAgICAgICAgICAgZiA9IHRoaXMudGl0bGVPZmZzZXQ7XG4gICAgICAgIHRoaXMucmVzZXRNYXJnaW5zKCk7XG4gICAgICAgIGZbMF0gJiYgIUQoZVswXSkgJiYgKHRoaXMucGxvdFRvcCA9IE1hdGgubWF4KHRoaXMucGxvdFRvcCwgZlswXSArIGFbMF0pKTtcbiAgICAgICAgZlsyXSAmJiAhRChlWzJdKSAmJiAodGhpcy5tYXJnaW5Cb3R0b20gPSBNYXRoLm1heCh0aGlzLm1hcmdpbkJvdHRvbSwgZlsyXSArIGFbMl0pKTtcbiAgICAgICAgdGhpcy5sZWdlbmQgJiYgdGhpcy5sZWdlbmQuZGlzcGxheSAmJiB0aGlzLmxlZ2VuZC5hZGp1c3RNYXJnaW5zKGUsIGEpO1xuICAgICAgICBjKHRoaXMsIFwiZ2V0TWFyZ2luc1wiKTtcbiAgICAgICAgYiB8fCB0aGlzLmdldEF4aXNNYXJnaW5zKCk7XG4gICAgICB9LFxuICAgICAgZ2V0QXhpc01hcmdpbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICAgICAgYSA9IGIuYXhpc09mZnNldCA9IFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgIGMgPSBiLmNvbG9yQXhpcyxcbiAgICAgICAgICAgIGUgPSBiLm1hcmdpbixcbiAgICAgICAgICAgIGYgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGIuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgYi52aXNpYmxlICYmIGIuZ2V0T2Zmc2V0KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYi5oYXNDYXJ0ZXNpYW5TZXJpZXMgPyBmKGIuYXhlcykgOiBjICYmIGMubGVuZ3RoICYmIGYoYyk7XG4gICAgICAgIG0uZm9yRWFjaChmdW5jdGlvbiAoYywgZikge1xuICAgICAgICAgIEQoZVtmXSkgfHwgKGJbY10gKz0gYVtmXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBiLnNldENoYXJ0U2l6ZSgpO1xuICAgICAgfSxcbiAgICAgIHJlZmxvdzogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgYyA9IGEub3B0aW9ucy5jaGFydCxcbiAgICAgICAgICAgIGUgPSBhLnJlbmRlclRvLFxuICAgICAgICAgICAgZiA9IEQoYy53aWR0aCkgJiYgRChjLmhlaWdodCksXG4gICAgICAgICAgICBkID0gYy53aWR0aCB8fCBrKGUsIFwid2lkdGhcIik7XG4gICAgICAgIGMgPSBjLmhlaWdodCB8fCBrKGUsIFwiaGVpZ2h0XCIpO1xuICAgICAgICBlID0gYiA/IGIudGFyZ2V0IDogWjtcblxuICAgICAgICBpZiAoIWYgJiYgIWEuaXNQcmludGluZyAmJiBkICYmIGMgJiYgKGUgPT09IFogfHwgZSA9PT0gUikpIHtcbiAgICAgICAgICBpZiAoZCAhPT0gYS5jb250YWluZXJXaWR0aCB8fCBjICE9PSBhLmNvbnRhaW5lckhlaWdodCkgTS5jbGVhclRpbWVvdXQoYS5yZWZsb3dUaW1lb3V0KSwgYS5yZWZsb3dUaW1lb3V0ID0gQyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhLmNvbnRhaW5lciAmJiBhLnNldFNpemUodm9pZCAwLCB2b2lkIDAsICExKTtcbiAgICAgICAgICB9LCBiID8gMTAwIDogMCk7XG4gICAgICAgICAgYS5jb250YWluZXJXaWR0aCA9IGQ7XG4gICAgICAgICAgYS5jb250YWluZXJIZWlnaHQgPSBjO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0UmVmbG93OiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgICExID09PSBiIHx8IHRoaXMudW5iaW5kUmVmbG93ID8gITEgPT09IGIgJiYgdGhpcy51bmJpbmRSZWZsb3cgJiYgKHRoaXMudW5iaW5kUmVmbG93ID0gdGhpcy51bmJpbmRSZWZsb3coKSkgOiAodGhpcy51bmJpbmRSZWZsb3cgPSBFKFosIFwicmVzaXplXCIsIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYS5vcHRpb25zICYmIGEucmVmbG93KGIpO1xuICAgICAgICB9KSwgRSh0aGlzLCBcImRlc3Ryb3lcIiwgdGhpcy51bmJpbmRSZWZsb3cpKTtcbiAgICAgIH0sXG4gICAgICBzZXRTaXplOiBmdW5jdGlvbiAoYiwgYSwgZSkge1xuICAgICAgICB2YXIgZiA9IHRoaXMsXG4gICAgICAgICAgICBkID0gZi5yZW5kZXJlcjtcbiAgICAgICAgZi5pc1Jlc2l6aW5nICs9IDE7XG4gICAgICAgIHAoZSwgZik7XG4gICAgICAgIGUgPSBkLmdsb2JhbEFuaW1hdGlvbjtcbiAgICAgICAgZi5vbGRDaGFydEhlaWdodCA9IGYuY2hhcnRIZWlnaHQ7XG4gICAgICAgIGYub2xkQ2hhcnRXaWR0aCA9IGYuY2hhcnRXaWR0aDtcbiAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGIgJiYgKGYub3B0aW9ucy5jaGFydC53aWR0aCA9IGIpO1xuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYSAmJiAoZi5vcHRpb25zLmNoYXJ0LmhlaWdodCA9IGEpO1xuICAgICAgICBmLmdldENoYXJ0U2l6ZSgpO1xuICAgICAgICBmLnN0eWxlZE1vZGUgfHwgKGUgPyBBIDogdCkoZi5jb250YWluZXIsIHtcbiAgICAgICAgICB3aWR0aDogZi5jaGFydFdpZHRoICsgXCJweFwiLFxuICAgICAgICAgIGhlaWdodDogZi5jaGFydEhlaWdodCArIFwicHhcIlxuICAgICAgICB9LCBlKTtcbiAgICAgICAgZi5zZXRDaGFydFNpemUoITApO1xuICAgICAgICBkLnNldFNpemUoZi5jaGFydFdpZHRoLCBmLmNoYXJ0SGVpZ2h0LCBlKTtcbiAgICAgICAgZi5heGVzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBiLmlzRGlydHkgPSAhMDtcbiAgICAgICAgICBiLnNldFNjYWxlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBmLmlzRGlydHlMZWdlbmQgPSAhMDtcbiAgICAgICAgZi5pc0RpcnR5Qm94ID0gITA7XG4gICAgICAgIGYubGF5T3V0VGl0bGVzKCk7XG4gICAgICAgIGYuZ2V0TWFyZ2lucygpO1xuICAgICAgICBmLnJlZHJhdyhlKTtcbiAgICAgICAgZi5vbGRDaGFydEhlaWdodCA9IG51bGw7XG4gICAgICAgIGMoZiwgXCJyZXNpemVcIik7XG4gICAgICAgIEMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGYgJiYgYyhmLCBcImVuZFJlc2l6ZVwiLCBudWxsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAtLWYuaXNSZXNpemluZztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgRyhlKS5kdXJhdGlvbiB8fCAwKTtcbiAgICAgIH0sXG4gICAgICBzZXRDaGFydFNpemU6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5pbnZlcnRlZCxcbiAgICAgICAgICAgIGUgPSB0aGlzLnJlbmRlcmVyLFxuICAgICAgICAgICAgZiA9IHRoaXMuY2hhcnRXaWR0aCxcbiAgICAgICAgICAgIGQgPSB0aGlzLmNoYXJ0SGVpZ2h0LFxuICAgICAgICAgICAgayA9IHRoaXMub3B0aW9ucy5jaGFydCxcbiAgICAgICAgICAgIGwgPSB0aGlzLnNwYWNpbmcsXG4gICAgICAgICAgICBoID0gdGhpcy5jbGlwT2Zmc2V0LFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIG4sXG4gICAgICAgICAgICBwLFxuICAgICAgICAgICAgeDtcbiAgICAgICAgdGhpcy5wbG90TGVmdCA9IG0gPSBNYXRoLnJvdW5kKHRoaXMucGxvdExlZnQpO1xuICAgICAgICB0aGlzLnBsb3RUb3AgPSBuID0gTWF0aC5yb3VuZCh0aGlzLnBsb3RUb3ApO1xuICAgICAgICB0aGlzLnBsb3RXaWR0aCA9IHAgPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKGYgLSBtIC0gdGhpcy5tYXJnaW5SaWdodCkpO1xuICAgICAgICB0aGlzLnBsb3RIZWlnaHQgPSB4ID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZChkIC0gbiAtIHRoaXMubWFyZ2luQm90dG9tKSk7XG4gICAgICAgIHRoaXMucGxvdFNpemVYID0gYSA/IHggOiBwO1xuICAgICAgICB0aGlzLnBsb3RTaXplWSA9IGEgPyBwIDogeDtcbiAgICAgICAgdGhpcy5wbG90Qm9yZGVyV2lkdGggPSBrLnBsb3RCb3JkZXJXaWR0aCB8fCAwO1xuICAgICAgICB0aGlzLnNwYWNpbmdCb3ggPSBlLnNwYWNpbmdCb3ggPSB7XG4gICAgICAgICAgeDogbFszXSxcbiAgICAgICAgICB5OiBsWzBdLFxuICAgICAgICAgIHdpZHRoOiBmIC0gbFszXSAtIGxbMV0sXG4gICAgICAgICAgaGVpZ2h0OiBkIC0gbFswXSAtIGxbMl1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wbG90Qm94ID0gZS5wbG90Qm94ID0ge1xuICAgICAgICAgIHg6IG0sXG4gICAgICAgICAgeTogbixcbiAgICAgICAgICB3aWR0aDogcCxcbiAgICAgICAgICBoZWlnaHQ6IHhcbiAgICAgICAgfTtcbiAgICAgICAgZiA9IDIgKiBNYXRoLmZsb29yKHRoaXMucGxvdEJvcmRlcldpZHRoIC8gMik7XG4gICAgICAgIGEgPSBNYXRoLmNlaWwoTWF0aC5tYXgoZiwgaFszXSkgLyAyKTtcbiAgICAgICAgZSA9IE1hdGguY2VpbChNYXRoLm1heChmLCBoWzBdKSAvIDIpO1xuICAgICAgICB0aGlzLmNsaXBCb3ggPSB7XG4gICAgICAgICAgeDogYSxcbiAgICAgICAgICB5OiBlLFxuICAgICAgICAgIHdpZHRoOiBNYXRoLmZsb29yKHRoaXMucGxvdFNpemVYIC0gTWF0aC5tYXgoZiwgaFsxXSkgLyAyIC0gYSksXG4gICAgICAgICAgaGVpZ2h0OiBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHRoaXMucGxvdFNpemVZIC0gTWF0aC5tYXgoZiwgaFsyXSkgLyAyIC0gZSkpXG4gICAgICAgIH07XG4gICAgICAgIGIgfHwgdGhpcy5heGVzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBiLnNldEF4aXNTaXplKCk7XG4gICAgICAgICAgYi5zZXRBeGlzVHJhbnNsYXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGModGhpcywgXCJhZnRlclNldENoYXJ0U2l6ZVwiLCB7XG4gICAgICAgICAgc2tpcEF4ZXM6IGJcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcmVzZXRNYXJnaW5zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGModGhpcywgXCJyZXNldE1hcmdpbnNcIik7XG4gICAgICAgIHZhciBiID0gdGhpcyxcbiAgICAgICAgICAgIGEgPSBiLm9wdGlvbnMuY2hhcnQ7XG4gICAgICAgIFtcIm1hcmdpblwiLCBcInNwYWNpbmdcIl0uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHZhciBlID0gYVtjXSxcbiAgICAgICAgICAgICAgZiA9IGwoZSkgPyBlIDogW2UsIGUsIGUsIGVdO1xuICAgICAgICAgIFtcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChlLCBkKSB7XG4gICAgICAgICAgICBiW2NdW2RdID0gTChhW2MgKyBlXSwgZltkXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBtLmZvckVhY2goZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgICBiW2FdID0gTChiLm1hcmdpbltjXSwgYi5zcGFjaW5nW2NdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGIuYXhpc09mZnNldCA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgYi5jbGlwT2Zmc2V0ID0gWzAsIDAsIDAsIDBdO1xuICAgICAgfSxcbiAgICAgIGRyYXdDaGFydEJveDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMub3B0aW9ucy5jaGFydCxcbiAgICAgICAgICAgIGEgPSB0aGlzLnJlbmRlcmVyLFxuICAgICAgICAgICAgZSA9IHRoaXMuY2hhcnRXaWR0aCxcbiAgICAgICAgICAgIGYgPSB0aGlzLmNoYXJ0SGVpZ2h0LFxuICAgICAgICAgICAgZCA9IHRoaXMuY2hhcnRCYWNrZ3JvdW5kLFxuICAgICAgICAgICAgayA9IHRoaXMucGxvdEJhY2tncm91bmQsXG4gICAgICAgICAgICBsID0gdGhpcy5wbG90Qm9yZGVyLFxuICAgICAgICAgICAgaCA9IHRoaXMuc3R5bGVkTW9kZSxcbiAgICAgICAgICAgIG0gPSB0aGlzLnBsb3RCR0ltYWdlLFxuICAgICAgICAgICAgbiA9IGIuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgcCA9IGIucGxvdEJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIHggPSBiLnBsb3RCYWNrZ3JvdW5kSW1hZ2UsXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgdyA9IHRoaXMucGxvdExlZnQsXG4gICAgICAgICAgICBDID0gdGhpcy5wbG90VG9wLFxuICAgICAgICAgICAgdiA9IHRoaXMucGxvdFdpZHRoLFxuICAgICAgICAgICAgcSA9IHRoaXMucGxvdEhlaWdodCxcbiAgICAgICAgICAgIHQgPSB0aGlzLnBsb3RCb3gsXG4gICAgICAgICAgICBCID0gdGhpcy5jbGlwUmVjdCxcbiAgICAgICAgICAgIHogPSB0aGlzLmNsaXBCb3gsXG4gICAgICAgICAgICBPID0gXCJhbmltYXRlXCI7XG4gICAgICAgIGQgfHwgKHRoaXMuY2hhcnRCYWNrZ3JvdW5kID0gZCA9IGEucmVjdCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1iYWNrZ3JvdW5kXCIpLmFkZCgpLCBPID0gXCJhdHRyXCIpO1xuICAgICAgICBpZiAoaCkgdmFyIHkgPSBnID0gZC5zdHJva2VXaWR0aCgpO2Vsc2Uge1xuICAgICAgICAgIHkgPSBiLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgICAgICAgZyA9IHkgKyAoYi5zaGFkb3cgPyA4IDogMCk7XG4gICAgICAgICAgbiA9IHtcbiAgICAgICAgICAgIGZpbGw6IG4gfHwgXCJub25lXCJcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICh5IHx8IGRbXCJzdHJva2Utd2lkdGhcIl0pIG4uc3Ryb2tlID0gYi5ib3JkZXJDb2xvciwgbltcInN0cm9rZS13aWR0aFwiXSA9IHk7XG4gICAgICAgICAgZC5hdHRyKG4pLnNoYWRvdyhiLnNoYWRvdyk7XG4gICAgICAgIH1cbiAgICAgICAgZFtPXSh7XG4gICAgICAgICAgeDogZyAvIDIsXG4gICAgICAgICAgeTogZyAvIDIsXG4gICAgICAgICAgd2lkdGg6IGUgLSBnIC0geSAlIDIsXG4gICAgICAgICAgaGVpZ2h0OiBmIC0gZyAtIHkgJSAyLFxuICAgICAgICAgIHI6IGIuYm9yZGVyUmFkaXVzXG4gICAgICAgIH0pO1xuICAgICAgICBPID0gXCJhbmltYXRlXCI7XG4gICAgICAgIGsgfHwgKE8gPSBcImF0dHJcIiwgdGhpcy5wbG90QmFja2dyb3VuZCA9IGsgPSBhLnJlY3QoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtcGxvdC1iYWNrZ3JvdW5kXCIpLmFkZCgpKTtcbiAgICAgICAga1tPXSh0KTtcbiAgICAgICAgaCB8fCAoay5hdHRyKHtcbiAgICAgICAgICBmaWxsOiBwIHx8IFwibm9uZVwiXG4gICAgICAgIH0pLnNoYWRvdyhiLnBsb3RTaGFkb3cpLCB4ICYmIChtID8gKHggIT09IG0uYXR0cihcImhyZWZcIikgJiYgbS5hdHRyKFwiaHJlZlwiLCB4KSwgbS5hbmltYXRlKHQpKSA6IHRoaXMucGxvdEJHSW1hZ2UgPSBhLmltYWdlKHgsIHcsIEMsIHYsIHEpLmFkZCgpKSk7XG4gICAgICAgIEIgPyBCLmFuaW1hdGUoe1xuICAgICAgICAgIHdpZHRoOiB6LndpZHRoLFxuICAgICAgICAgIGhlaWdodDogei5oZWlnaHRcbiAgICAgICAgfSkgOiB0aGlzLmNsaXBSZWN0ID0gYS5jbGlwUmVjdCh6KTtcbiAgICAgICAgTyA9IFwiYW5pbWF0ZVwiO1xuICAgICAgICBsIHx8IChPID0gXCJhdHRyXCIsIHRoaXMucGxvdEJvcmRlciA9IGwgPSBhLnJlY3QoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtcGxvdC1ib3JkZXJcIikuYXR0cih7XG4gICAgICAgICAgekluZGV4OiAxXG4gICAgICAgIH0pLmFkZCgpKTtcbiAgICAgICAgaCB8fCBsLmF0dHIoe1xuICAgICAgICAgIHN0cm9rZTogYi5wbG90Qm9yZGVyQ29sb3IsXG4gICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogYi5wbG90Qm9yZGVyV2lkdGggfHwgMCxcbiAgICAgICAgICBmaWxsOiBcIm5vbmVcIlxuICAgICAgICB9KTtcbiAgICAgICAgbFtPXShsLmNyaXNwKHtcbiAgICAgICAgICB4OiB3LFxuICAgICAgICAgIHk6IEMsXG4gICAgICAgICAgd2lkdGg6IHYsXG4gICAgICAgICAgaGVpZ2h0OiBxXG4gICAgICAgIH0sIC1sLnN0cm9rZVdpZHRoKCkpKTtcbiAgICAgICAgdGhpcy5pc0RpcnR5Qm94ID0gITE7XG4gICAgICAgIGModGhpcywgXCJhZnRlckRyYXdDaGFydEJveFwiKTtcbiAgICAgIH0sXG4gICAgICBwcm9wRnJvbVNlcmllczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgICAgICBhID0gYi5vcHRpb25zLmNoYXJ0LFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIGUgPSBiLm9wdGlvbnMuc2VyaWVzLFxuICAgICAgICAgICAgZixcbiAgICAgICAgICAgIGQ7XG4gICAgICAgIFtcImludmVydGVkXCIsIFwiYW5ndWxhclwiLCBcInBvbGFyXCJdLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICBjID0gVFthLnR5cGUgfHwgYS5kZWZhdWx0U2VyaWVzVHlwZV07XG4gICAgICAgICAgZCA9IGFba10gfHwgYyAmJiBjLnByb3RvdHlwZVtrXTtcblxuICAgICAgICAgIGZvciAoZiA9IGUgJiYgZS5sZW5ndGg7ICFkICYmIGYtLTspIChjID0gVFtlW2ZdLnR5cGVdKSAmJiBjLnByb3RvdHlwZVtrXSAmJiAoZCA9ICEwKTtcblxuICAgICAgICAgIGJba10gPSBkO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBsaW5rU2VyaWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcyxcbiAgICAgICAgICAgIGEgPSBiLnNlcmllcztcbiAgICAgICAgYS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYi5saW5rZWRTZXJpZXMubGVuZ3RoID0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIGEuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHZhciBjID0gYS5vcHRpb25zLmxpbmtlZFRvO1xuICAgICAgICAgIHYoYykgJiYgKGMgPSBcIjpwcmV2aW91c1wiID09PSBjID8gYi5zZXJpZXNbYS5pbmRleCAtIDFdIDogYi5nZXQoYykpICYmIGMubGlua2VkUGFyZW50ICE9PSBhICYmIChjLmxpbmtlZFNlcmllcy5wdXNoKGEpLCBhLmxpbmtlZFBhcmVudCA9IGMsIGMuZW5hYmxlZERhdGFTb3J0aW5nICYmIGEuc2V0RGF0YVNvcnRpbmdPcHRpb25zKCksIGEudmlzaWJsZSA9IEwoYS5vcHRpb25zLnZpc2libGUsIGMub3B0aW9ucy52aXNpYmxlLCBhLnZpc2libGUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGModGhpcywgXCJhZnRlckxpbmtTZXJpZXNcIik7XG4gICAgICB9LFxuICAgICAgcmVuZGVyU2VyaWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBiLnRyYW5zbGF0ZSgpO1xuICAgICAgICAgIGIucmVuZGVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHJlbmRlckxhYmVsczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgICAgICBhID0gYi5vcHRpb25zLmxhYmVscztcbiAgICAgICAgYS5pdGVtcyAmJiBhLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICB2YXIgZSA9IFAoYS5zdHlsZSwgYy5zdHlsZSksXG4gICAgICAgICAgICAgIGYgPSBRKGUubGVmdCkgKyBiLnBsb3RMZWZ0LFxuICAgICAgICAgICAgICBkID0gUShlLnRvcCkgKyBiLnBsb3RUb3AgKyAxMjtcbiAgICAgICAgICBkZWxldGUgZS5sZWZ0O1xuICAgICAgICAgIGRlbGV0ZSBlLnRvcDtcbiAgICAgICAgICBiLnJlbmRlcmVyLnRleHQoYy5odG1sLCBmLCBkKS5hdHRyKHtcbiAgICAgICAgICAgIHpJbmRleDogMlxuICAgICAgICAgIH0pLmNzcyhlKS5hZGQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5heGVzLFxuICAgICAgICAgICAgYSA9IHRoaXMuY29sb3JBeGlzLFxuICAgICAgICAgICAgYyA9IHRoaXMucmVuZGVyZXIsXG4gICAgICAgICAgICBlID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgZiA9IDAsXG4gICAgICAgICAgICBkID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBiLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIGIudmlzaWJsZSAmJiBiLnJlbmRlcigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0VGl0bGUoKTtcbiAgICAgICAgdGhpcy5sZWdlbmQgPSBuZXcgZyh0aGlzLCBlLmxlZ2VuZCk7XG4gICAgICAgIHRoaXMuZ2V0U3RhY2tzICYmIHRoaXMuZ2V0U3RhY2tzKCk7XG4gICAgICAgIHRoaXMuZ2V0TWFyZ2lucyghMCk7XG4gICAgICAgIHRoaXMuc2V0Q2hhcnRTaXplKCk7XG4gICAgICAgIGUgPSB0aGlzLnBsb3RXaWR0aDtcbiAgICAgICAgYi5zb21lKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgaWYgKGIuaG9yaXogJiYgYi52aXNpYmxlICYmIGIub3B0aW9ucy5sYWJlbHMuZW5hYmxlZCAmJiBiLnNlcmllcy5sZW5ndGgpIHJldHVybiBmID0gMjEsICEwO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGsgPSB0aGlzLnBsb3RIZWlnaHQgPSBNYXRoLm1heCh0aGlzLnBsb3RIZWlnaHQgLSBmLCAwKTtcbiAgICAgICAgYi5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYi5zZXRTY2FsZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nZXRBeGlzTWFyZ2lucygpO1xuICAgICAgICB2YXIgbCA9IDEuMSA8IGUgLyB0aGlzLnBsb3RXaWR0aDtcbiAgICAgICAgdmFyIGggPSAxLjA1IDwgayAvIHRoaXMucGxvdEhlaWdodDtcbiAgICAgICAgaWYgKGwgfHwgaCkgYi5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgKGIuaG9yaXogJiYgbCB8fCAhYi5ob3JpeiAmJiBoKSAmJiBiLnNldFRpY2tJbnRlcnZhbCghMCk7XG4gICAgICAgIH0pLCB0aGlzLmdldE1hcmdpbnMoKTtcbiAgICAgICAgdGhpcy5kcmF3Q2hhcnRCb3goKTtcbiAgICAgICAgdGhpcy5oYXNDYXJ0ZXNpYW5TZXJpZXMgPyBkKGIpIDogYSAmJiBhLmxlbmd0aCAmJiBkKGEpO1xuICAgICAgICB0aGlzLnNlcmllc0dyb3VwIHx8ICh0aGlzLnNlcmllc0dyb3VwID0gYy5nKFwic2VyaWVzLWdyb3VwXCIpLmF0dHIoe1xuICAgICAgICAgIHpJbmRleDogM1xuICAgICAgICB9KS5hZGQoKSk7XG4gICAgICAgIHRoaXMucmVuZGVyU2VyaWVzKCk7XG4gICAgICAgIHRoaXMucmVuZGVyTGFiZWxzKCk7XG4gICAgICAgIHRoaXMuYWRkQ3JlZGl0cygpO1xuICAgICAgICB0aGlzLnNldFJlc3BvbnNpdmUgJiYgdGhpcy5zZXRSZXNwb25zaXZlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQ29udGFpbmVyU2NhbGluZygpO1xuICAgICAgICB0aGlzLmhhc1JlbmRlcmVkID0gITA7XG4gICAgICB9LFxuICAgICAgYWRkQ3JlZGl0czogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICBiID0geighMCwgdGhpcy5vcHRpb25zLmNyZWRpdHMsIGIpO1xuICAgICAgICBiLmVuYWJsZWQgJiYgIXRoaXMuY3JlZGl0cyAmJiAodGhpcy5jcmVkaXRzID0gdGhpcy5yZW5kZXJlci50ZXh0KGIudGV4dCArICh0aGlzLm1hcENyZWRpdHMgfHwgXCJcIiksIDAsIDApLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1jcmVkaXRzXCIpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGIuaHJlZiAmJiAoWi5sb2NhdGlvbi5ocmVmID0gYi5ocmVmKTtcbiAgICAgICAgfSkuYXR0cih7XG4gICAgICAgICAgYWxpZ246IGIucG9zaXRpb24uYWxpZ24sXG4gICAgICAgICAgekluZGV4OiA4XG4gICAgICAgIH0pLCBhLnN0eWxlZE1vZGUgfHwgdGhpcy5jcmVkaXRzLmNzcyhiLnN0eWxlKSwgdGhpcy5jcmVkaXRzLmFkZCgpLmFsaWduKGIucG9zaXRpb24pLCB0aGlzLmNyZWRpdHMudXBkYXRlID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBhLmNyZWRpdHMgPSBhLmNyZWRpdHMuZGVzdHJveSgpO1xuICAgICAgICAgIGEuYWRkQ3JlZGl0cyhiKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlQ29udGFpbmVyU2NhbGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMuY29udGFpbmVyO1xuXG4gICAgICAgIGlmIChiLm9mZnNldFdpZHRoICYmIGIub2Zmc2V0SGVpZ2h0ICYmIGIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG4gICAgICAgICAgdmFyIGEgPSBiLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICBjID0gYS53aWR0aCAvIGIub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgYiA9IGEuaGVpZ2h0IC8gYi5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgMSAhPT0gYyB8fCAxICE9PSBiID8gdGhpcy5jb250YWluZXJTY2FsaW5nID0ge1xuICAgICAgICAgICAgc2NhbGVYOiBjLFxuICAgICAgICAgICAgc2NhbGVZOiBiXG4gICAgICAgICAgfSA6IGRlbGV0ZSB0aGlzLmNvbnRhaW5lclNjYWxpbmc7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcyxcbiAgICAgICAgICAgIGEgPSBiLmF4ZXMsXG4gICAgICAgICAgICBlID0gYi5zZXJpZXMsXG4gICAgICAgICAgICBmID0gYi5jb250YWluZXIsXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgbCA9IGYgJiYgZi5wYXJlbnROb2RlO1xuICAgICAgICBjKGIsIFwiZGVzdHJveVwiKTtcbiAgICAgICAgYi5yZW5kZXJlci5mb3JFeHBvcnQgPyBOKFUsIGIpIDogVVtiLmluZGV4XSA9IHZvaWQgMDtcbiAgICAgICAgZC5jaGFydENvdW50LS07XG4gICAgICAgIGIucmVuZGVyVG8ucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1oaWdoY2hhcnRzLWNoYXJ0XCIpO1xuICAgICAgICBLKGIpO1xuXG4gICAgICAgIGZvciAoayA9IGEubGVuZ3RoOyBrLS07KSBhW2tdID0gYVtrXS5kZXN0cm95KCk7XG5cbiAgICAgICAgdGhpcy5zY3JvbGxlciAmJiB0aGlzLnNjcm9sbGVyLmRlc3Ryb3kgJiYgdGhpcy5zY3JvbGxlci5kZXN0cm95KCk7XG5cbiAgICAgICAgZm9yIChrID0gZS5sZW5ndGg7IGstLTspIGVba10gPSBlW2tdLmRlc3Ryb3koKTtcblxuICAgICAgICBcInRpdGxlIHN1YnRpdGxlIGNoYXJ0QmFja2dyb3VuZCBwbG90QmFja2dyb3VuZCBwbG90QkdJbWFnZSBwbG90Qm9yZGVyIHNlcmllc0dyb3VwIGNsaXBSZWN0IGNyZWRpdHMgcG9pbnRlciByYW5nZVNlbGVjdG9yIGxlZ2VuZCByZXNldFpvb21CdXR0b24gdG9vbHRpcCByZW5kZXJlclwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgdmFyIGMgPSBiW2FdO1xuICAgICAgICAgIGMgJiYgYy5kZXN0cm95ICYmIChiW2FdID0gYy5kZXN0cm95KCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgZiAmJiAoZi5pbm5lckhUTUwgPSBcIlwiLCBLKGYpLCBsICYmIGgoZikpO1xuICAgICAgICBCKGIsIGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgICAgZGVsZXRlIGJbY107XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZpcnN0UmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcyxcbiAgICAgICAgICAgIGEgPSBiLm9wdGlvbnM7XG5cbiAgICAgICAgaWYgKCFiLmlzUmVhZHlUb1JlbmRlciB8fCBiLmlzUmVhZHlUb1JlbmRlcigpKSB7XG4gICAgICAgICAgYi5nZXRDb250YWluZXIoKTtcbiAgICAgICAgICBiLnJlc2V0TWFyZ2lucygpO1xuICAgICAgICAgIGIuc2V0Q2hhcnRTaXplKCk7XG4gICAgICAgICAgYi5wcm9wRnJvbVNlcmllcygpO1xuICAgICAgICAgIGIuZ2V0QXhlcygpO1xuICAgICAgICAgIChuKGEuc2VyaWVzKSA/IGEuc2VyaWVzIDogW10pLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGIuaW5pdFNlcmllcyhhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBiLmxpbmtTZXJpZXMoKTtcbiAgICAgICAgICBiLnNldFNlcmllc0RhdGEoKTtcbiAgICAgICAgICBjKGIsIFwiYmVmb3JlUmVuZGVyXCIpO1xuICAgICAgICAgIHUgJiYgKGIucG9pbnRlciA9IGQuaGFzVG91Y2ggfHwgIVouUG9pbnRlckV2ZW50ICYmICFaLk1TUG9pbnRlckV2ZW50ID8gbmV3IHUoYiwgYSkgOiBuZXcgcihiLCBhKSk7XG4gICAgICAgICAgYi5yZW5kZXIoKTtcbiAgICAgICAgICBpZiAoIWIucmVuZGVyZXIuaW1nQ291bnQgJiYgIWIuaGFzTG9hZGVkKSBiLm9ubG9hZCgpO1xuICAgICAgICAgIGIudGVtcG9yYXJ5RGlzcGxheSghMCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbmxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MuY29uY2F0KFt0aGlzLmNhbGxiYWNrXSkuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGIgJiYgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHRoaXMuaW5kZXggJiYgYi5hcHBseSh0aGlzLCBbdGhpc10pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgYyh0aGlzLCBcImxvYWRcIik7XG4gICAgICAgIGModGhpcywgXCJyZW5kZXJcIik7XG4gICAgICAgIEQodGhpcy5pbmRleCkgJiYgdGhpcy5zZXRSZWZsb3codGhpcy5vcHRpb25zLmNoYXJ0LnJlZmxvdyk7XG4gICAgICAgIHRoaXMuaGFzTG9hZGVkID0gITA7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvU2Nyb2xsYWJsZVBsb3RBcmVhLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgdmFyIHIgPSBnLmFkZEV2ZW50LFxuICAgICAgICB1ID0gZy5jcmVhdGVFbGVtZW50LFxuICAgICAgICBJID0gZy5waWNrLFxuICAgICAgICBNID0gZy5zdG9wO1xuICAgIGcgPSBkLkNoYXJ0O1xuICAgIFwiXCI7XG4gICAgcihnLCBcImFmdGVyU2V0Q2hhcnRTaXplXCIsIGZ1bmN0aW9uIChnKSB7XG4gICAgICB2YXIgdSA9IHRoaXMub3B0aW9ucy5jaGFydC5zY3JvbGxhYmxlUGxvdEFyZWEsXG4gICAgICAgICAgciA9IHUgJiYgdS5taW5XaWR0aDtcbiAgICAgIHUgPSB1ICYmIHUubWluSGVpZ2h0O1xuXG4gICAgICBpZiAoIXRoaXMucmVuZGVyZXIuZm9yRXhwb3J0KSB7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1ggPSByID0gTWF0aC5tYXgoMCwgciAtIHRoaXMuY2hhcnRXaWR0aCkpIHtcbiAgICAgICAgICAgIHRoaXMucGxvdFdpZHRoICs9IHI7XG4gICAgICAgICAgICB0aGlzLmludmVydGVkID8gKHRoaXMuY2xpcEJveC5oZWlnaHQgKz0gciwgdGhpcy5wbG90Qm94LmhlaWdodCArPSByKSA6ICh0aGlzLmNsaXBCb3gud2lkdGggKz0gciwgdGhpcy5wbG90Qm94LndpZHRoICs9IHIpO1xuICAgICAgICAgICAgdmFyIEUgPSB7XG4gICAgICAgICAgICAgIDE6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB1ICYmICh0aGlzLnNjcm9sbGFibGVQaXhlbHNZID0gciA9IE1hdGgubWF4KDAsIHUgLSB0aGlzLmNoYXJ0SGVpZ2h0KSkgJiYgKHRoaXMucGxvdEhlaWdodCArPSByLCB0aGlzLmludmVydGVkID8gKHRoaXMuY2xpcEJveC53aWR0aCArPSByLCB0aGlzLnBsb3RCb3gud2lkdGggKz0gcikgOiAodGhpcy5jbGlwQm94LmhlaWdodCArPSByLCB0aGlzLnBsb3RCb3guaGVpZ2h0ICs9IHIpLCBFID0ge1xuICAgICAgICAgIDI6IHtcbiAgICAgICAgICAgIG5hbWU6IFwiYm90dG9tXCIsXG4gICAgICAgICAgICB2YWx1ZTogclxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgRSAmJiAhZy5za2lwQXhlcyAmJiB0aGlzLmF4ZXMuZm9yRWFjaChmdW5jdGlvbiAoZykge1xuICAgICAgICAgIEVbZy5zaWRlXSA/IGcuZ2V0UGxvdExpbmVQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHQgPSBFW2cuc2lkZV0ubmFtZSxcbiAgICAgICAgICAgICAgICB5ID0gdGhpc1t0XTtcbiAgICAgICAgICAgIHRoaXNbdF0gPSB5IC0gRVtnLnNpZGVdLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGggPSBkLkF4aXMucHJvdG90eXBlLmdldFBsb3RMaW5lUGF0aC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpc1t0XSA9IHk7XG4gICAgICAgICAgICByZXR1cm4gaDtcbiAgICAgICAgICB9IDogKGcuc2V0QXhpc1NpemUoKSwgZy5zZXRBeGlzVHJhbnNsYXRpb24oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHIoZywgXCJyZW5kZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zY3JvbGxhYmxlUGl4ZWxzWCB8fCB0aGlzLnNjcm9sbGFibGVQaXhlbHNZID8gKHRoaXMuc2V0VXBTY3JvbGxpbmcgJiYgdGhpcy5zZXRVcFNjcm9sbGluZygpLCB0aGlzLmFwcGx5Rml4ZWQoKSkgOiB0aGlzLmZpeGVkRGl2ICYmIHRoaXMuYXBwbHlGaXhlZCgpO1xuICAgIH0pO1xuXG4gICAgZy5wcm90b3R5cGUuc2V0VXBTY3JvbGxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgZyA9IHtcbiAgICAgICAgV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmc6IFwidG91Y2hcIixcbiAgICAgICAgb3ZlcmZsb3dYOiBcImhpZGRlblwiLFxuICAgICAgICBvdmVyZmxvd1k6IFwiaGlkZGVuXCJcbiAgICAgIH07XG4gICAgICB0aGlzLnNjcm9sbGFibGVQaXhlbHNYICYmIChnLm92ZXJmbG93WCA9IFwiYXV0b1wiKTtcbiAgICAgIHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1kgJiYgKGcub3ZlcmZsb3dZID0gXCJhdXRvXCIpO1xuICAgICAgdGhpcy5zY3JvbGxpbmdDb250YWluZXIgPSB1KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImhpZ2hjaGFydHMtc2Nyb2xsaW5nXCJcbiAgICAgIH0sIGcsIHRoaXMucmVuZGVyVG8pO1xuICAgICAgcih0aGlzLnNjcm9sbGluZ0NvbnRhaW5lciwgXCJzY3JvbGxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBkLnBvaW50ZXIgJiYgZGVsZXRlIGQucG9pbnRlci5jaGFydFBvc2l0aW9uO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmlubmVyQ29udGFpbmVyID0gdShcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJoaWdoY2hhcnRzLWlubmVyLWNvbnRhaW5lclwiXG4gICAgICB9LCBudWxsLCB0aGlzLnNjcm9sbGluZ0NvbnRhaW5lcik7XG4gICAgICB0aGlzLmlubmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgIHRoaXMuc2V0VXBTY3JvbGxpbmcgPSBudWxsO1xuICAgIH07XG5cbiAgICBnLnByb3RvdHlwZS5tb3ZlRml4ZWRFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkID0gdGhpcy5jb250YWluZXIsXG4gICAgICAgICAgZyA9IHRoaXMuZml4ZWRSZW5kZXJlcixcbiAgICAgICAgICB1ID0gXCIuaGlnaGNoYXJ0cy1jb250ZXh0YnV0dG9uIC5oaWdoY2hhcnRzLWNyZWRpdHMgLmhpZ2hjaGFydHMtbGVnZW5kIC5oaWdoY2hhcnRzLWxlZ2VuZC1jaGVja2JveCAuaGlnaGNoYXJ0cy1uYXZpZ2F0b3Itc2VyaWVzIC5oaWdoY2hhcnRzLW5hdmlnYXRvci14YXhpcyAuaGlnaGNoYXJ0cy1uYXZpZ2F0b3IteWF4aXMgLmhpZ2hjaGFydHMtbmF2aWdhdG9yIC5oaWdoY2hhcnRzLXJlc2V0LXpvb20gLmhpZ2hjaGFydHMtc2Nyb2xsYmFyIC5oaWdoY2hhcnRzLXN1YnRpdGxlIC5oaWdoY2hhcnRzLXRpdGxlXCIuc3BsaXQoXCIgXCIpLFxuICAgICAgICAgIHI7XG4gICAgICB0aGlzLnNjcm9sbGFibGVQaXhlbHNYICYmICF0aGlzLmludmVydGVkID8gciA9IFwiLmhpZ2hjaGFydHMteWF4aXNcIiA6IHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1ggJiYgdGhpcy5pbnZlcnRlZCA/IHIgPSBcIi5oaWdoY2hhcnRzLXhheGlzXCIgOiB0aGlzLnNjcm9sbGFibGVQaXhlbHNZICYmICF0aGlzLmludmVydGVkID8gciA9IFwiLmhpZ2hjaGFydHMteGF4aXNcIiA6IHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1kgJiYgdGhpcy5pbnZlcnRlZCAmJiAociA9IFwiLmhpZ2hjaGFydHMteWF4aXNcIik7XG4gICAgICB1LnB1c2gociwgciArIFwiLWxhYmVsc1wiKTtcbiAgICAgIHUuZm9yRWFjaChmdW5jdGlvbiAoeSkge1xuICAgICAgICBbXS5mb3JFYWNoLmNhbGwoZC5xdWVyeVNlbGVjdG9yQWxsKHkpLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIChkLm5hbWVzcGFjZVVSSSA9PT0gZy5TVkdfTlMgPyBnLmJveCA6IGcuYm94LnBhcmVudE5vZGUpLmFwcGVuZENoaWxkKGQpO1xuICAgICAgICAgIGQuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBnLnByb3RvdHlwZS5hcHBseUZpeGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGcsXG4gICAgICAgICAgQSA9ICF0aGlzLmZpeGVkRGl2LFxuICAgICAgICAgIEcgPSB0aGlzLm9wdGlvbnMuY2hhcnQuc2Nyb2xsYWJsZVBsb3RBcmVhO1xuICAgICAgQSA/ICh0aGlzLmZpeGVkRGl2ID0gdShcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJoaWdoY2hhcnRzLWZpeGVkXCJcbiAgICAgIH0sIHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgICAgICB6SW5kZXg6IDJcbiAgICAgIH0sIG51bGwsICEwKSwgdGhpcy5yZW5kZXJUby5pbnNlcnRCZWZvcmUodGhpcy5maXhlZERpdiwgdGhpcy5yZW5kZXJUby5maXJzdENoaWxkKSwgdGhpcy5yZW5kZXJUby5zdHlsZS5vdmVyZmxvdyA9IFwidmlzaWJsZVwiLCB0aGlzLmZpeGVkUmVuZGVyZXIgPSBnID0gbmV3IGQuUmVuZGVyZXIodGhpcy5maXhlZERpdiwgdGhpcy5jaGFydFdpZHRoLCB0aGlzLmNoYXJ0SGVpZ2h0KSwgdGhpcy5zY3JvbGxhYmxlTWFzayA9IGcucGF0aCgpLmF0dHIoe1xuICAgICAgICBmaWxsOiB0aGlzLm9wdGlvbnMuY2hhcnQuYmFja2dyb3VuZENvbG9yIHx8IFwiI2ZmZlwiLFxuICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiBJKEcub3BhY2l0eSwgLjg1KSxcbiAgICAgICAgekluZGV4OiAtMVxuICAgICAgfSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXNjcm9sbGFibGUtbWFza1wiKS5hZGQoKSwgdGhpcy5tb3ZlRml4ZWRFbGVtZW50cygpLCByKHRoaXMsIFwiYWZ0ZXJTaG93UmVzZXRab29tXCIsIHRoaXMubW92ZUZpeGVkRWxlbWVudHMpLCByKHRoaXMsIFwiYWZ0ZXJMYXlPdXRUaXRsZXNcIiwgdGhpcy5tb3ZlRml4ZWRFbGVtZW50cykpIDogdGhpcy5maXhlZFJlbmRlcmVyLnNldFNpemUodGhpcy5jaGFydFdpZHRoLCB0aGlzLmNoYXJ0SGVpZ2h0KTtcbiAgICAgIGcgPSB0aGlzLmNoYXJ0V2lkdGggKyAodGhpcy5zY3JvbGxhYmxlUGl4ZWxzWCB8fCAwKTtcbiAgICAgIHZhciBKID0gdGhpcy5jaGFydEhlaWdodCArICh0aGlzLnNjcm9sbGFibGVQaXhlbHNZIHx8IDApO1xuICAgICAgTSh0aGlzLmNvbnRhaW5lcik7XG4gICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS53aWR0aCA9IGcgKyBcInB4XCI7XG4gICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBKICsgXCJweFwiO1xuICAgICAgdGhpcy5yZW5kZXJlci5ib3hXcmFwcGVyLmF0dHIoe1xuICAgICAgICB3aWR0aDogZyxcbiAgICAgICAgaGVpZ2h0OiBKLFxuICAgICAgICB2aWV3Qm94OiBbMCwgMCwgZywgSl0uam9pbihcIiBcIilcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jaGFydEJhY2tncm91bmQuYXR0cih7XG4gICAgICAgIHdpZHRoOiBnLFxuICAgICAgICBoZWlnaHQ6IEpcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zY3JvbGxhYmxlUGl4ZWxzWSAmJiAodGhpcy5zY3JvbGxpbmdDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gdGhpcy5jaGFydEhlaWdodCArIFwicHhcIik7XG4gICAgICBBICYmIChHLnNjcm9sbFBvc2l0aW9uWCAmJiAodGhpcy5zY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1ggKiBHLnNjcm9sbFBvc2l0aW9uWCksIEcuc2Nyb2xsUG9zaXRpb25ZICYmICh0aGlzLnNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbGFibGVQaXhlbHNZICogRy5zY3JvbGxQb3NpdGlvblkpKTtcbiAgICAgIEogPSB0aGlzLmF4aXNPZmZzZXQ7XG4gICAgICBBID0gdGhpcy5wbG90VG9wIC0gSlswXSAtIDE7XG4gICAgICBHID0gdGhpcy5wbG90TGVmdCAtIEpbM10gLSAxO1xuICAgICAgZyA9IHRoaXMucGxvdFRvcCArIHRoaXMucGxvdEhlaWdodCArIEpbMl0gKyAxO1xuICAgICAgSiA9IHRoaXMucGxvdExlZnQgKyB0aGlzLnBsb3RXaWR0aCArIEpbMV0gKyAxO1xuICAgICAgdmFyIHkgPSB0aGlzLnBsb3RMZWZ0ICsgdGhpcy5wbG90V2lkdGggLSAodGhpcy5zY3JvbGxhYmxlUGl4ZWxzWCB8fCAwKSxcbiAgICAgICAgICB0ID0gdGhpcy5wbG90VG9wICsgdGhpcy5wbG90SGVpZ2h0IC0gKHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1kgfHwgMCk7XG4gICAgICBBID0gdGhpcy5zY3JvbGxhYmxlUGl4ZWxzWCA/IFtcIk1cIiwgMCwgQSwgXCJMXCIsIHRoaXMucGxvdExlZnQgLSAxLCBBLCBcIkxcIiwgdGhpcy5wbG90TGVmdCAtIDEsIGcsIFwiTFwiLCAwLCBnLCBcIlpcIiwgXCJNXCIsIHksIEEsIFwiTFwiLCB0aGlzLmNoYXJ0V2lkdGgsIEEsIFwiTFwiLCB0aGlzLmNoYXJ0V2lkdGgsIGcsIFwiTFwiLCB5LCBnLCBcIlpcIl0gOiB0aGlzLnNjcm9sbGFibGVQaXhlbHNZID8gW1wiTVwiLCBHLCAwLCBcIkxcIiwgRywgdGhpcy5wbG90VG9wIC0gMSwgXCJMXCIsIEosIHRoaXMucGxvdFRvcCAtIDEsIFwiTFwiLCBKLCAwLCBcIlpcIiwgXCJNXCIsIEcsIHQsIFwiTFwiLCBHLCB0aGlzLmNoYXJ0SGVpZ2h0LCBcIkxcIiwgSiwgdGhpcy5jaGFydEhlaWdodCwgXCJMXCIsIEosIHQsIFwiWlwiXSA6IFtcIk1cIiwgMCwgMF07XG4gICAgICBcImFkanVzdEhlaWdodFwiICE9PSB0aGlzLnJlZHJhd1RyaWdnZXIgJiYgdGhpcy5zY3JvbGxhYmxlTWFzay5hdHRyKHtcbiAgICAgICAgZDogQVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSk7XG4gIFMociwgXCJtaXhpbnMvbGVnZW5kLXN5bWJvbC5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZykge1xuICAgIHZhciByID0gZy5tZXJnZSxcbiAgICAgICAgdSA9IGcucGljaztcbiAgICBkLkxlZ2VuZFN5bWJvbE1peGluID0ge1xuICAgICAgZHJhd1JlY3RhbmdsZTogZnVuY3Rpb24gKGQsIGcpIHtcbiAgICAgICAgdmFyIHIgPSBkLnN5bWJvbEhlaWdodCxcbiAgICAgICAgICAgIEEgPSBkLm9wdGlvbnMuc3F1YXJlU3ltYm9sO1xuICAgICAgICBnLmxlZ2VuZFN5bWJvbCA9IHRoaXMuY2hhcnQucmVuZGVyZXIucmVjdChBID8gKGQuc3ltYm9sV2lkdGggLSByKSAvIDIgOiAwLCBkLmJhc2VsaW5lIC0gciArIDEsIEEgPyByIDogZC5zeW1ib2xXaWR0aCwgciwgdShkLm9wdGlvbnMuc3ltYm9sUmFkaXVzLCByIC8gMikpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1wb2ludFwiKS5hdHRyKHtcbiAgICAgICAgICB6SW5kZXg6IDNcbiAgICAgICAgfSkuYWRkKGcubGVnZW5kR3JvdXApO1xuICAgICAgfSxcbiAgICAgIGRyYXdMaW5lTWFya2VyOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgZyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIEUgPSBnLm1hcmtlcixcbiAgICAgICAgICAgIEEgPSBkLnN5bWJvbFdpZHRoLFxuICAgICAgICAgICAgRyA9IGQuc3ltYm9sSGVpZ2h0LFxuICAgICAgICAgICAgSiA9IEcgLyAyLFxuICAgICAgICAgICAgeSA9IHRoaXMuY2hhcnQucmVuZGVyZXIsXG4gICAgICAgICAgICB0ID0gdGhpcy5sZWdlbmRHcm91cDtcbiAgICAgICAgZCA9IGQuYmFzZWxpbmUgLSBNYXRoLnJvdW5kKC4zICogZC5mb250TWV0cmljcy5iKTtcbiAgICAgICAgdmFyIEQgPSB7fTtcbiAgICAgICAgdGhpcy5jaGFydC5zdHlsZWRNb2RlIHx8IChEID0ge1xuICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IGcubGluZVdpZHRoIHx8IDBcbiAgICAgICAgfSwgZy5kYXNoU3R5bGUgJiYgKEQuZGFzaHN0eWxlID0gZy5kYXNoU3R5bGUpKTtcbiAgICAgICAgdGhpcy5sZWdlbmRMaW5lID0geS5wYXRoKFtcIk1cIiwgMCwgZCwgXCJMXCIsIEEsIGRdKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtZ3JhcGhcIikuYXR0cihEKS5hZGQodCk7XG4gICAgICAgIEUgJiYgITEgIT09IEUuZW5hYmxlZCAmJiBBICYmIChnID0gTWF0aC5taW4odShFLnJhZGl1cywgSiksIEopLCAwID09PSB0aGlzLnN5bWJvbC5pbmRleE9mKFwidXJsXCIpICYmIChFID0gcihFLCB7XG4gICAgICAgICAgd2lkdGg6IEcsXG4gICAgICAgICAgaGVpZ2h0OiBHXG4gICAgICAgIH0pLCBnID0gMCksIHRoaXMubGVnZW5kU3ltYm9sID0gRSA9IHkuc3ltYm9sKHRoaXMuc3ltYm9sLCBBIC8gMiAtIGcsIGQgLSBnLCAyICogZywgMiAqIGcsIEUpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1wb2ludFwiKS5hZGQodCksIEUuaXNNYXJrZXIgPSAhMCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gZC5MZWdlbmRTeW1ib2xNaXhpbjtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9Qb2ludC5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZykge1xuICAgIFwiXCI7XG5cbiAgICB2YXIgciA9IGcuYW5pbU9iamVjdCxcbiAgICAgICAgdSA9IGcuZGVmaW5lZCxcbiAgICAgICAgSSA9IGcuZXJhc2UsXG4gICAgICAgIE0gPSBnLmV4dGVuZCxcbiAgICAgICAgRSA9IGcuZm9ybWF0LFxuICAgICAgICBBID0gZy5nZXROZXN0ZWRQcm9wZXJ0eSxcbiAgICAgICAgRyA9IGcuaXNBcnJheSxcbiAgICAgICAgSiA9IGcuaXNOdW1iZXIsXG4gICAgICAgIHkgPSBnLmlzT2JqZWN0LFxuICAgICAgICB0ID0gZy5zeW5jVGltZW91dCxcbiAgICAgICAgRCA9IGcucGljayxcbiAgICAgICAgaCA9IGcucmVtb3ZlRXZlbnQsXG4gICAgICAgIE4gPSBnLnVuaXF1ZUtleSxcbiAgICAgICAgcSA9IGQuZmlyZUV2ZW50O1xuXG4gICAgZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIGQoKSB7XG4gICAgICAgIHRoaXMuY29sb3JJbmRleCA9IHRoaXMuY2F0ZWdvcnkgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuZm9ybWF0UHJlZml4ID0gXCJwb2ludFwiO1xuICAgICAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmlzTnVsbCA9ICExO1xuICAgICAgICB0aGlzLnBlcmNlbnRhZ2UgPSB0aGlzLm9wdGlvbnMgPSB0aGlzLm5hbWUgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSAhMTtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRoaXMuc2VyaWVzID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnZpc2libGUgPSAhMDtcbiAgICAgICAgdGhpcy54ID0gdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICBkLnByb3RvdHlwZS5hbmltYXRlQmVmb3JlRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgICAgYyA9IHtcbiAgICAgICAgICB4OiBlLnN0YXJ0WFBvcyxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgaCA9IGUuZ2V0R3JhcGhpY2FsUHJvcHMoKTtcbiAgICAgICAgaC5zaW5ndWxhci5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgZCA9IFwiZGF0YUxhYmVsXCIgPT09IGY7XG4gICAgICAgICAgZVtmXSA9IGVbZl0uYW5pbWF0ZShkID8ge1xuICAgICAgICAgICAgeDogZVtmXS5zdGFydFhQb3MsXG4gICAgICAgICAgICB5OiBlW2ZdLnN0YXJ0WVBvcyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9IDogYyk7XG4gICAgICAgIH0pO1xuICAgICAgICBoLnBsdXJhbC5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgZVtjXS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBhLmVsZW1lbnQgJiYgYS5hbmltYXRlKE0oe1xuICAgICAgICAgICAgICB4OiBlLnN0YXJ0WFBvc1xuICAgICAgICAgICAgfSwgYS5zdGFydFlQb3MgPyB7XG4gICAgICAgICAgICAgIHg6IGEuc3RhcnRYUG9zLFxuICAgICAgICAgICAgICB5OiBhLnN0YXJ0WVBvc1xuICAgICAgICAgICAgfSA6IHt9KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUuYXBwbHlPcHRpb25zID0gZnVuY3Rpb24gKGUsIGMpIHtcbiAgICAgICAgdmFyIGsgPSB0aGlzLnNlcmllcyxcbiAgICAgICAgICAgIGggPSBrLm9wdGlvbnMucG9pbnRWYWxLZXkgfHwgay5wb2ludFZhbEtleTtcbiAgICAgICAgZSA9IGQucHJvdG90eXBlLm9wdGlvbnNUb09iamVjdC5jYWxsKHRoaXMsIGUpO1xuICAgICAgICBNKHRoaXMsIGUpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgPyBNKHRoaXMub3B0aW9ucywgZSkgOiBlO1xuICAgICAgICBlLmdyb3VwICYmIGRlbGV0ZSB0aGlzLmdyb3VwO1xuICAgICAgICBlLmRhdGFMYWJlbHMgJiYgZGVsZXRlIHRoaXMuZGF0YUxhYmVscztcbiAgICAgICAgaCAmJiAodGhpcy55ID0gZC5wcm90b3R5cGUuZ2V0TmVzdGVkUHJvcGVydHkuY2FsbCh0aGlzLCBoKSk7XG4gICAgICAgIHRoaXMuZm9ybWF0UHJlZml4ID0gKHRoaXMuaXNOdWxsID0gRCh0aGlzLmlzVmFsaWQgJiYgIXRoaXMuaXNWYWxpZCgpLCBudWxsID09PSB0aGlzLnggfHwgIUoodGhpcy55KSkpID8gXCJudWxsXCIgOiBcInBvaW50XCI7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgJiYgKHRoaXMuc3RhdGUgPSBcInNlbGVjdFwiKTtcbiAgICAgICAgXCJuYW1lXCIgaW4gdGhpcyAmJiBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgYyAmJiBrLnhBeGlzICYmIGsueEF4aXMuaGFzTmFtZXMgJiYgKHRoaXMueCA9IGsueEF4aXMubmFtZVRvWCh0aGlzKSk7XG4gICAgICAgIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiB0aGlzLnggJiYgayAmJiAodGhpcy54ID0gXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGMgPyBrLmF1dG9JbmNyZW1lbnQodGhpcykgOiBjKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICAgIGlmIChjLmdyYXBoaWMgfHwgYy5kYXRhTGFiZWwgfHwgYy5kYXRhTGFiZWxzKSBoKGMpLCBjLmRlc3Ryb3lFbGVtZW50cygpO1xuXG4gICAgICAgICAgZm9yIChsIGluIGMpIGNbbF0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSB0aGlzLFxuICAgICAgICAgICAgZCA9IGMuc2VyaWVzLFxuICAgICAgICAgICAgbiA9IGQuY2hhcnQ7XG4gICAgICAgIGQgPSBkLm9wdGlvbnMuZGF0YVNvcnRpbmc7XG4gICAgICAgIHZhciBmID0gbi5ob3ZlclBvaW50cyxcbiAgICAgICAgICAgIGEgPSByKGMuc2VyaWVzLmNoYXJ0LnJlbmRlcmVyLmdsb2JhbEFuaW1hdGlvbiksXG4gICAgICAgICAgICBsO1xuICAgICAgICBjLmxlZ2VuZEl0ZW0gJiYgbi5sZWdlbmQuZGVzdHJveUl0ZW0oYyk7XG4gICAgICAgIGYgJiYgKGMuc2V0U3RhdGUoKSwgSShmLCBjKSwgZi5sZW5ndGggfHwgKG4uaG92ZXJQb2ludHMgPSBudWxsKSk7XG4gICAgICAgIGlmIChjID09PSBuLmhvdmVyUG9pbnQpIGMub25Nb3VzZU91dCgpO1xuICAgICAgICBkICYmIGQuZW5hYmxlZCA/ICh0aGlzLmFuaW1hdGVCZWZvcmVEZXN0cm95KCksIHQoZSwgYS5kdXJhdGlvbikpIDogZSgpO1xuICAgICAgICBuLnBvaW50Q291bnQtLTtcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLmRlc3Ryb3lFbGVtZW50cyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBjID0gdGhpcztcbiAgICAgICAgZSA9IGMuZ2V0R3JhcGhpY2FsUHJvcHMoZSk7XG4gICAgICAgIGUuc2luZ3VsYXIuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGNbZV0gPSBjW2VdLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGUucGx1cmFsLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBjW2VdLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGMuZWxlbWVudCAmJiBjLmRlc3Ryb3koKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWxldGUgY1tlXTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS5maXJlUG9pbnRFdmVudCA9IGZ1bmN0aW9uIChlLCBjLCBkKSB7XG4gICAgICAgIHZhciBrID0gdGhpcyxcbiAgICAgICAgICAgIGYgPSB0aGlzLnNlcmllcy5vcHRpb25zO1xuICAgICAgICAoZi5wb2ludC5ldmVudHNbZV0gfHwgay5vcHRpb25zICYmIGsub3B0aW9ucy5ldmVudHMgJiYgay5vcHRpb25zLmV2ZW50c1tlXSkgJiYgay5pbXBvcnRFdmVudHMoKTtcbiAgICAgICAgXCJjbGlja1wiID09PSBlICYmIGYuYWxsb3dQb2ludFNlbGVjdCAmJiAoZCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgay5zZWxlY3QgJiYgay5zZWxlY3QobnVsbCwgYS5jdHJsS2V5IHx8IGEubWV0YUtleSB8fCBhLnNoaWZ0S2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHEoaywgZSwgYywgZCk7XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS5nZXRDbGFzc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcImhpZ2hjaGFydHMtcG9pbnRcIiArICh0aGlzLnNlbGVjdGVkID8gXCIgaGlnaGNoYXJ0cy1wb2ludC1zZWxlY3RcIiA6IFwiXCIpICsgKHRoaXMubmVnYXRpdmUgPyBcIiBoaWdoY2hhcnRzLW5lZ2F0aXZlXCIgOiBcIlwiKSArICh0aGlzLmlzTnVsbCA/IFwiIGhpZ2hjaGFydHMtbnVsbC1wb2ludFwiIDogXCJcIikgKyAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHRoaXMuY29sb3JJbmRleCA/IFwiIGhpZ2hjaGFydHMtY29sb3ItXCIgKyB0aGlzLmNvbG9ySW5kZXggOiBcIlwiKSArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lID8gXCIgXCIgKyB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIDogXCJcIikgKyAodGhpcy56b25lICYmIHRoaXMuem9uZS5jbGFzc05hbWUgPyBcIiBcIiArIHRoaXMuem9uZS5jbGFzc05hbWUucmVwbGFjZShcImhpZ2hjaGFydHMtbmVnYXRpdmVcIiwgXCJcIikgOiBcIlwiKTtcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLmdldEdyYXBoaWNhbFByb3BzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLFxuICAgICAgICAgICAgZCA9IFtdLFxuICAgICAgICAgICAgaCxcbiAgICAgICAgICAgIGYgPSB7XG4gICAgICAgICAgc2luZ3VsYXI6IFtdLFxuICAgICAgICAgIHBsdXJhbDogW11cbiAgICAgICAgfTtcbiAgICAgICAgZSA9IGUgfHwge1xuICAgICAgICAgIGdyYXBoaWM6IDEsXG4gICAgICAgICAgZGF0YUxhYmVsOiAxXG4gICAgICAgIH07XG4gICAgICAgIGUuZ3JhcGhpYyAmJiBkLnB1c2goXCJncmFwaGljXCIsIFwic2hhZG93R3JvdXBcIik7XG4gICAgICAgIGUuZGF0YUxhYmVsICYmIGQucHVzaChcImRhdGFMYWJlbFwiLCBcImRhdGFMYWJlbFVwcGVyXCIsIFwiY29ubmVjdG9yXCIpO1xuXG4gICAgICAgIGZvciAoaCA9IGQubGVuZ3RoOyBoLS07KSB7XG4gICAgICAgICAgdmFyIGEgPSBkW2hdO1xuICAgICAgICAgIGNbYV0gJiYgZi5zaW5ndWxhci5wdXNoKGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgW1wiZGF0YUxhYmVsXCIsIFwiY29ubmVjdG9yXCJdLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICB2YXIgZCA9IGEgKyBcInNcIjtcbiAgICAgICAgICBlW2FdICYmIGNbZF0gJiYgZi5wbHVyYWwucHVzaChkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUuZ2V0TGFiZWxDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogdGhpcy5jYXRlZ29yeSxcbiAgICAgICAgICB5OiB0aGlzLnksXG4gICAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgICAgY29sb3JJbmRleDogdGhpcy5jb2xvckluZGV4LFxuICAgICAgICAgIGtleTogdGhpcy5uYW1lIHx8IHRoaXMuY2F0ZWdvcnksXG4gICAgICAgICAgc2VyaWVzOiB0aGlzLnNlcmllcyxcbiAgICAgICAgICBwb2ludDogdGhpcyxcbiAgICAgICAgICBwZXJjZW50YWdlOiB0aGlzLnBlcmNlbnRhZ2UsXG4gICAgICAgICAgdG90YWw6IHRoaXMudG90YWwgfHwgdGhpcy5zdGFja1RvdGFsXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS5nZXROZXN0ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlKSByZXR1cm4gMCA9PT0gZS5pbmRleE9mKFwiY3VzdG9tLlwiKSA/IEEoZSwgdGhpcy5vcHRpb25zKSA6IHRoaXNbZV07XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS5nZXRab25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuc2VyaWVzLFxuICAgICAgICAgICAgYyA9IGUuem9uZXM7XG4gICAgICAgIGUgPSBlLnpvbmVBeGlzIHx8IFwieVwiO1xuICAgICAgICB2YXIgZCA9IDAsXG4gICAgICAgICAgICBoO1xuXG4gICAgICAgIGZvciAoaCA9IGNbZF07IHRoaXNbZV0gPj0gaC52YWx1ZTspIGggPSBjWysrZF07XG5cbiAgICAgICAgdGhpcy5ub25ab25lZENvbG9yIHx8ICh0aGlzLm5vblpvbmVkQ29sb3IgPSB0aGlzLmNvbG9yKTtcbiAgICAgICAgdGhpcy5jb2xvciA9IGggJiYgaC5jb2xvciAmJiAhdGhpcy5vcHRpb25zLmNvbG9yID8gaC5jb2xvciA6IHRoaXMubm9uWm9uZWRDb2xvcjtcbiAgICAgICAgcmV0dXJuIGg7XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS5oYXNOZXdTaGFwZVR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5ncmFwaGljICYmICh0aGlzLmdyYXBoaWMuc3ltYm9sTmFtZSB8fCB0aGlzLmdyYXBoaWMuZWxlbWVudC5ub2RlTmFtZSkpICE9PSB0aGlzLnNoYXBlVHlwZTtcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZSwgYywgZCkge1xuICAgICAgICB0aGlzLnNlcmllcyA9IGU7XG4gICAgICAgIHRoaXMuYXBwbHlPcHRpb25zKGMsIGQpO1xuICAgICAgICB0aGlzLmlkID0gdSh0aGlzLmlkKSA/IHRoaXMuaWQgOiBOKCk7XG4gICAgICAgIHRoaXMucmVzb2x2ZUNvbG9yKCk7XG4gICAgICAgIGUuY2hhcnQucG9pbnRDb3VudCsrO1xuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJJbml0XCIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLm9wdGlvbnNUb09iamVjdCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBjID0ge30sXG4gICAgICAgICAgICBrID0gdGhpcy5zZXJpZXMsXG4gICAgICAgICAgICBoID0gay5vcHRpb25zLmtleXMsXG4gICAgICAgICAgICBmID0gaCB8fCBrLnBvaW50QXJyYXlNYXAgfHwgW1wieVwiXSxcbiAgICAgICAgICAgIGEgPSBmLmxlbmd0aCxcbiAgICAgICAgICAgIGwgPSAwLFxuICAgICAgICAgICAgZyA9IDA7XG4gICAgICAgIGlmIChKKGUpIHx8IG51bGwgPT09IGUpIGNbZlswXV0gPSBlO2Vsc2UgaWYgKEcoZSkpIGZvciAoIWggJiYgZS5sZW5ndGggPiBhICYmIChrID0gdHlwZW9mIGVbMF0sIFwic3RyaW5nXCIgPT09IGsgPyBjLm5hbWUgPSBlWzBdIDogXCJudW1iZXJcIiA9PT0gayAmJiAoYy54ID0gZVswXSksIGwrKyk7IGcgPCBhOykgaCAmJiBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgZVtsXSB8fCAoMCA8IGZbZ10uaW5kZXhPZihcIi5cIikgPyBkLnByb3RvdHlwZS5zZXROZXN0ZWRQcm9wZXJ0eShjLCBlW2xdLCBmW2ddKSA6IGNbZltnXV0gPSBlW2xdKSwgbCsrLCBnKys7ZWxzZSBcIm9iamVjdFwiID09PSB0eXBlb2YgZSAmJiAoYyA9IGUsIGUuZGF0YUxhYmVscyAmJiAoay5faGFzUG9pbnRMYWJlbHMgPSAhMCksIGUubWFya2VyICYmIChrLl9oYXNQb2ludE1hcmtlcnMgPSAhMCkpO1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLnJlc29sdmVDb2xvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLnNlcmllcztcbiAgICAgICAgdmFyIGMgPSBlLmNoYXJ0Lm9wdGlvbnMuY2hhcnQuY29sb3JDb3VudDtcbiAgICAgICAgdmFyIGQgPSBlLmNoYXJ0LnN0eWxlZE1vZGU7XG4gICAgICAgIGQgfHwgdGhpcy5vcHRpb25zLmNvbG9yIHx8ICh0aGlzLmNvbG9yID0gZS5jb2xvcik7XG4gICAgICAgIGUub3B0aW9ucy5jb2xvckJ5UG9pbnQgPyAoZCB8fCAoYyA9IGUub3B0aW9ucy5jb2xvcnMgfHwgZS5jaGFydC5vcHRpb25zLmNvbG9ycywgdGhpcy5jb2xvciA9IHRoaXMuY29sb3IgfHwgY1tlLmNvbG9yQ291bnRlcl0sIGMgPSBjLmxlbmd0aCksIGQgPSBlLmNvbG9yQ291bnRlciwgZS5jb2xvckNvdW50ZXIrKywgZS5jb2xvckNvdW50ZXIgPT09IGMgJiYgKGUuY29sb3JDb3VudGVyID0gMCkpIDogZCA9IGUuY29sb3JJbmRleDtcbiAgICAgICAgdGhpcy5jb2xvckluZGV4ID0gRCh0aGlzLmNvbG9ySW5kZXgsIGQpO1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUuc2V0TmVzdGVkUHJvcGVydHkgPSBmdW5jdGlvbiAoZSwgYywgZCkge1xuICAgICAgICBkLnNwbGl0KFwiLlwiKS5yZWR1Y2UoZnVuY3Rpb24gKGUsIGYsIGEsIGQpIHtcbiAgICAgICAgICBlW2ZdID0gZC5sZW5ndGggLSAxID09PSBhID8gYyA6IHkoZVtmXSwgITApID8gZVtmXSA6IHt9O1xuICAgICAgICAgIHJldHVybiBlW2ZdO1xuICAgICAgICB9LCBlKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS50b29sdGlwRm9ybWF0dGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLnNlcmllcyxcbiAgICAgICAgICAgIGQgPSBjLnRvb2x0aXBPcHRpb25zLFxuICAgICAgICAgICAgaCA9IEQoZC52YWx1ZURlY2ltYWxzLCBcIlwiKSxcbiAgICAgICAgICAgIGYgPSBkLnZhbHVlUHJlZml4IHx8IFwiXCIsXG4gICAgICAgICAgICBhID0gZC52YWx1ZVN1ZmZpeCB8fCBcIlwiO1xuICAgICAgICBjLmNoYXJ0LnN0eWxlZE1vZGUgJiYgKGUgPSBjLmNoYXJ0LnRvb2x0aXAuc3R5bGVkTW9kZUZvcm1hdChlKSk7XG4gICAgICAgIChjLnBvaW50QXJyYXlNYXAgfHwgW1wieVwiXSkuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGMgPSBcIntwb2ludC5cIiArIGM7XG4gICAgICAgICAgaWYgKGYgfHwgYSkgZSA9IGUucmVwbGFjZShSZWdFeHAoYyArIFwifVwiLCBcImdcIiksIGYgKyBjICsgXCJ9XCIgKyBhKTtcbiAgICAgICAgICBlID0gZS5yZXBsYWNlKFJlZ0V4cChjICsgXCJ9XCIsIFwiZ1wiKSwgYyArIFwiOiwuXCIgKyBoICsgXCJmfVwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBFKGUsIHtcbiAgICAgICAgICBwb2ludDogdGhpcyxcbiAgICAgICAgICBzZXJpZXM6IHRoaXMuc2VyaWVzXG4gICAgICAgIH0sIGMuY2hhcnQpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGQ7XG4gICAgfSgpO1xuXG4gICAgZC5Qb2ludCA9IGc7XG4gICAgcmV0dXJuIGQuUG9pbnQ7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvU2VyaWVzLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcIm1peGlucy9sZWdlbmQtc3ltYm9sLmpzXCJdLCByW1wicGFydHMvUG9pbnQuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZywgciwgdSkge1xuICAgIFwiXCI7XG5cbiAgICB2YXIgSSA9IHUuYWRkRXZlbnQsXG4gICAgICAgIE0gPSB1LmFuaW1PYmplY3QsXG4gICAgICAgIEUgPSB1LmFycmF5TWF4LFxuICAgICAgICBBID0gdS5hcnJheU1pbixcbiAgICAgICAgRyA9IHUuY2xhbXAsXG4gICAgICAgIEogPSB1LmNvcnJlY3RGbG9hdCxcbiAgICAgICAgeSA9IHUuZGVmaW5lZCxcbiAgICAgICAgdCA9IHUuZXJhc2UsXG4gICAgICAgIEQgPSB1LmVycm9yLFxuICAgICAgICBoID0gdS5leHRlbmQsXG4gICAgICAgIE4gPSB1LmZpbmQsXG4gICAgICAgIHEgPSB1LmZpcmVFdmVudCxcbiAgICAgICAgUCA9IHUuZ2V0TmVzdGVkUHJvcGVydHksXG4gICAgICAgIGUgPSB1LmlzQXJyYXksXG4gICAgICAgIGMgPSB1LmlzRnVuY3Rpb24sXG4gICAgICAgIGsgPSB1LmlzTnVtYmVyLFxuICAgICAgICBuID0gdS5pc1N0cmluZyxcbiAgICAgICAgZiA9IHUubWVyZ2UsXG4gICAgICAgIGEgPSB1Lm9iamVjdEVhY2gsXG4gICAgICAgIGwgPSB1LnBpY2ssXG4gICAgICAgIHYgPSB1LnJlbW92ZUV2ZW50LFxuICAgICAgICB6ID0gdS5zZXJpZXNUeXBlLFxuICAgICAgICB3ID0gdS5zcGxhdCxcbiAgICAgICAgQiA9IHUuc3luY1RpbWVvdXQsXG4gICAgICAgIEwgPSBkLmRlZmF1bHRPcHRpb25zLFxuICAgICAgICBRID0gZC5kZWZhdWx0UGxvdE9wdGlvbnMsXG4gICAgICAgIEggPSBkLnNlcmllc1R5cGVzLFxuICAgICAgICBLID0gZC5TVkdFbGVtZW50LFxuICAgICAgICBwID0gZC53aW47XG4gICAgZC5TZXJpZXMgPSB6KFwibGluZVwiLCBudWxsLCB7XG4gICAgICBsaW5lV2lkdGg6IDIsXG4gICAgICBhbGxvd1BvaW50U2VsZWN0OiAhMSxcbiAgICAgIHNob3dDaGVja2JveDogITEsXG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgZHVyYXRpb246IDFFM1xuICAgICAgfSxcbiAgICAgIGV2ZW50czoge30sXG4gICAgICBtYXJrZXI6IHtcbiAgICAgICAgZW5hYmxlZFRocmVzaG9sZDogMixcbiAgICAgICAgbGluZUNvbG9yOiBcIiNmZmZmZmZcIixcbiAgICAgICAgbGluZVdpZHRoOiAwLFxuICAgICAgICByYWRpdXM6IDQsXG4gICAgICAgIHN0YXRlczoge1xuICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgYW5pbWF0aW9uOiAhMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgICAgICBkdXJhdGlvbjogNTBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmFibGVkOiAhMCxcbiAgICAgICAgICAgIHJhZGl1c1BsdXM6IDIsXG4gICAgICAgICAgICBsaW5lV2lkdGhQbHVzOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgIGZpbGxDb2xvcjogXCIjY2NjY2NjXCIsXG4gICAgICAgICAgICBsaW5lQ29sb3I6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgICAgbGluZVdpZHRoOiAyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcG9pbnQ6IHtcbiAgICAgICAgZXZlbnRzOiB7fVxuICAgICAgfSxcbiAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgYWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBiID0gdGhpcy5zZXJpZXMuY2hhcnQubnVtYmVyRm9ybWF0dGVyO1xuICAgICAgICAgIHJldHVybiBcIm51bWJlclwiICE9PSB0eXBlb2YgdGhpcy55ID8gXCJcIiA6IGIodGhpcy55LCAtMSk7XG4gICAgICAgIH0sXG4gICAgICAgIHBhZGRpbmc6IDUsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZm9udFNpemU6IFwiMTFweFwiLFxuICAgICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiLFxuICAgICAgICAgIGNvbG9yOiBcImNvbnRyYXN0XCIsXG4gICAgICAgICAgdGV4dE91dGxpbmU6IFwiMXB4IGNvbnRyYXN0XCJcbiAgICAgICAgfSxcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJib3R0b21cIixcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSxcbiAgICAgIGNyb3BUaHJlc2hvbGQ6IDMwMCxcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICBwb2ludFJhbmdlOiAwLFxuICAgICAgc29mdFRocmVzaG9sZDogITAsXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgYW5pbWF0aW9uOiAhMFxuICAgICAgICB9LFxuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgICAgZHVyYXRpb246IDUwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBsaW5lV2lkdGhQbHVzOiAxLFxuICAgICAgICAgIG1hcmtlcjoge30sXG4gICAgICAgICAgaGFsbzoge1xuICAgICAgICAgICAgc2l6ZTogMTAsXG4gICAgICAgICAgICBvcGFjaXR5OiAuMjVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGluYWN0aXZlOiB7XG4gICAgICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAgICBkdXJhdGlvbjogNTBcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9wYWNpdHk6IC4yXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzdGlja3lUcmFja2luZzogITAsXG4gICAgICB0dXJib1RocmVzaG9sZDogMUUzLFxuICAgICAgZmluZE5lYXJlc3RQb2ludEJ5OiBcInhcIlxuICAgIH0sIHtcbiAgICAgIGF4aXNUeXBlczogW1wieEF4aXNcIiwgXCJ5QXhpc1wiXSxcbiAgICAgIGNvbGw6IFwic2VyaWVzXCIsXG4gICAgICBjb2xvckNvdW50ZXI6IDAsXG4gICAgICBjcm9wU2hvdWxkZXI6IDEsXG4gICAgICBkaXJlY3RUb3VjaDogITEsXG4gICAgICBldmVudHNUb1VuYmluZDogW10sXG4gICAgICBpc0NhcnRlc2lhbjogITAsXG4gICAgICBwYXJhbGxlbEFycmF5czogW1wieFwiLCBcInlcIl0sXG4gICAgICBwb2ludENsYXNzOiByLFxuICAgICAgcmVxdWlyZVNvcnRpbmc6ICEwLFxuICAgICAgc29ydGVkOiAhMCxcbiAgICAgIGluaXQ6IGZ1bmN0aW9uIChiLCBlKSB7XG4gICAgICAgIHEodGhpcywgXCJpbml0XCIsIHtcbiAgICAgICAgICBvcHRpb25zOiBlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZiA9IHRoaXMsXG4gICAgICAgICAgICBkID0gYi5zZXJpZXMsXG4gICAgICAgICAgICBrO1xuICAgICAgICB0aGlzLmV2ZW50T3B0aW9ucyA9IHRoaXMuZXZlbnRPcHRpb25zIHx8IHt9O1xuICAgICAgICBmLmNoYXJ0ID0gYjtcbiAgICAgICAgZi5vcHRpb25zID0gZSA9IGYuc2V0T3B0aW9ucyhlKTtcbiAgICAgICAgZi5saW5rZWRTZXJpZXMgPSBbXTtcbiAgICAgICAgZi5iaW5kQXhlcygpO1xuICAgICAgICBoKGYsIHtcbiAgICAgICAgICBuYW1lOiBlLm5hbWUsXG4gICAgICAgICAgc3RhdGU6IFwiXCIsXG4gICAgICAgICAgdmlzaWJsZTogITEgIT09IGUudmlzaWJsZSxcbiAgICAgICAgICBzZWxlY3RlZDogITAgPT09IGUuc2VsZWN0ZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwID0gZS5ldmVudHM7XG4gICAgICAgIGEocCwgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBjKGIpICYmIGYuZXZlbnRPcHRpb25zW2FdICE9PSBiICYmIChjKGYuZXZlbnRPcHRpb25zW2FdKSAmJiB2KGYsIGEsIGYuZXZlbnRPcHRpb25zW2FdKSwgZi5ldmVudE9wdGlvbnNbYV0gPSBiLCBJKGYsIGEsIGIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwICYmIHAuY2xpY2sgfHwgZS5wb2ludCAmJiBlLnBvaW50LmV2ZW50cyAmJiBlLnBvaW50LmV2ZW50cy5jbGljayB8fCBlLmFsbG93UG9pbnRTZWxlY3QpIGIucnVuVHJhY2tlckNsaWNrID0gITA7XG4gICAgICAgIGYuZ2V0Q29sb3IoKTtcbiAgICAgICAgZi5nZXRTeW1ib2woKTtcbiAgICAgICAgZi5wYXJhbGxlbEFycmF5cy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgZltiICsgXCJEYXRhXCJdIHx8IChmW2IgKyBcIkRhdGFcIl0gPSBbXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmLmlzQ2FydGVzaWFuICYmIChiLmhhc0NhcnRlc2lhblNlcmllcyA9ICEwKTtcbiAgICAgICAgZC5sZW5ndGggJiYgKGsgPSBkW2QubGVuZ3RoIC0gMV0pO1xuICAgICAgICBmLl9pID0gbChrICYmIGsuX2ksIC0xKSArIDE7XG4gICAgICAgIGIub3JkZXJTZXJpZXModGhpcy5pbnNlcnQoZCkpO1xuICAgICAgICBlLmRhdGFTb3J0aW5nICYmIGUuZGF0YVNvcnRpbmcuZW5hYmxlZCA/IGYuc2V0RGF0YVNvcnRpbmdPcHRpb25zKCkgOiBmLnBvaW50cyB8fCBmLmRhdGEgfHwgZi5zZXREYXRhKGUuZGF0YSwgITEpO1xuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJJbml0XCIpO1xuICAgICAgfSxcbiAgICAgIGlzOiBmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gSFtiXSAmJiB0aGlzIGluc3RhbmNlb2YgSFtiXTtcbiAgICAgIH0sXG4gICAgICBpbnNlcnQ6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5vcHRpb25zLmluZGV4LFxuICAgICAgICAgICAgYztcblxuICAgICAgICBpZiAoayhhKSkge1xuICAgICAgICAgIGZvciAoYyA9IGIubGVuZ3RoOyBjLS07KSBpZiAoYSA+PSBsKGJbY10ub3B0aW9ucy5pbmRleCwgYltjXS5faSkpIHtcbiAgICAgICAgICAgIGIuc3BsaWNlKGMgKyAxLCAwLCB0aGlzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC0xID09PSBjICYmIGIudW5zaGlmdCh0aGlzKTtcbiAgICAgICAgICBjICs9IDE7XG4gICAgICAgIH0gZWxzZSBiLnB1c2godGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGwoYywgYi5sZW5ndGggLSAxKTtcbiAgICAgIH0sXG4gICAgICBiaW5kQXhlczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgICAgICBhID0gYi5vcHRpb25zLFxuICAgICAgICAgICAgYyA9IGIuY2hhcnQsXG4gICAgICAgICAgICBlO1xuICAgICAgICBxKHRoaXMsIFwiYmluZEF4ZXNcIiwgbnVsbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIChiLmF4aXNUeXBlcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgY1tmXS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgIGUgPSBjLm9wdGlvbnM7XG4gICAgICAgICAgICAgIGlmIChhW2ZdID09PSBlLmluZGV4IHx8IFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBhW2ZdICYmIGFbZl0gPT09IGUuaWQgfHwgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGFbZl0gJiYgMCA9PT0gZS5pbmRleCkgYi5pbnNlcnQoYy5zZXJpZXMpLCBiW2ZdID0gYywgYy5pc0RpcnR5ID0gITA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJbZl0gfHwgYi5vcHRpb25hbEF4aXMgPT09IGYgfHwgRCgxOCwgITAsIGMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcSh0aGlzLCBcImFmdGVyQmluZEF4ZXNcIik7XG4gICAgICB9LFxuICAgICAgdXBkYXRlUGFyYWxsZWxBcnJheXM6IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIHZhciBjID0gYi5zZXJpZXMsXG4gICAgICAgICAgICBlID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgZiA9IGsoYSkgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBmID0gXCJ5XCIgPT09IGUgJiYgYy50b1lEYXRhID8gYy50b1lEYXRhKGIpIDogYltlXTtcbiAgICAgICAgICBjW2UgKyBcIkRhdGFcIl1bYV0gPSBmO1xuICAgICAgICB9IDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGVbYV0uYXBwbHkoY1tiICsgXCJEYXRhXCJdLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLCAyKSk7XG4gICAgICAgIH07XG4gICAgICAgIGMucGFyYWxsZWxBcnJheXMuZm9yRWFjaChmKTtcbiAgICAgIH0sXG4gICAgICBoYXNEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGUgJiYgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHRoaXMuZGF0YU1heCAmJiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgdGhpcy5kYXRhTWluIHx8IHRoaXMudmlzaWJsZSAmJiB0aGlzLnlEYXRhICYmIDAgPCB0aGlzLnlEYXRhLmxlbmd0aDtcbiAgICAgIH0sXG4gICAgICBhdXRvSW5jcmVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgYSA9IHRoaXMueEluY3JlbWVudCxcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBlID0gYi5wb2ludEludGVydmFsVW5pdCxcbiAgICAgICAgICAgIGYgPSB0aGlzLmNoYXJ0LnRpbWU7XG4gICAgICAgIGEgPSBsKGEsIGIucG9pbnRTdGFydCwgMCk7XG4gICAgICAgIHRoaXMucG9pbnRJbnRlcnZhbCA9IGMgPSBsKHRoaXMucG9pbnRJbnRlcnZhbCwgYi5wb2ludEludGVydmFsLCAxKTtcbiAgICAgICAgZSAmJiAoYiA9IG5ldyBmLkRhdGUoYSksIFwiZGF5XCIgPT09IGUgPyBmLnNldChcIkRhdGVcIiwgYiwgZi5nZXQoXCJEYXRlXCIsIGIpICsgYykgOiBcIm1vbnRoXCIgPT09IGUgPyBmLnNldChcIk1vbnRoXCIsIGIsIGYuZ2V0KFwiTW9udGhcIiwgYikgKyBjKSA6IFwieWVhclwiID09PSBlICYmIGYuc2V0KFwiRnVsbFllYXJcIiwgYiwgZi5nZXQoXCJGdWxsWWVhclwiLCBiKSArIGMpLCBjID0gYi5nZXRUaW1lKCkgLSBhKTtcbiAgICAgICAgdGhpcy54SW5jcmVtZW50ID0gYSArIGM7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSxcbiAgICAgIHNldERhdGFTb3J0aW5nT3B0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaCh0aGlzLCB7XG4gICAgICAgICAgcmVxdWlyZVNvcnRpbmc6ICExLFxuICAgICAgICAgIHNvcnRlZDogITEsXG4gICAgICAgICAgZW5hYmxlZERhdGFTb3J0aW5nOiAhMCxcbiAgICAgICAgICBhbGxvd0RHOiAhMVxuICAgICAgICB9KTtcbiAgICAgICAgeShiLnBvaW50UmFuZ2UpIHx8IChiLnBvaW50UmFuZ2UgPSAxKTtcbiAgICAgIH0sXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBjID0gYS5vcHRpb25zLFxuICAgICAgICAgICAgZSA9IGMucGxvdE9wdGlvbnMsXG4gICAgICAgICAgICBkID0gYS51c2VyT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgYiA9IGYoYik7XG4gICAgICAgIGEgPSBhLnN0eWxlZE1vZGU7XG4gICAgICAgIHZhciBrID0ge1xuICAgICAgICAgIHBsb3RPcHRpb25zOiBlLFxuICAgICAgICAgIHVzZXJPcHRpb25zOiBiXG4gICAgICAgIH07XG4gICAgICAgIHEodGhpcywgXCJzZXRPcHRpb25zXCIsIGspO1xuICAgICAgICB2YXIgaCA9IGsucGxvdE9wdGlvbnNbdGhpcy50eXBlXSxcbiAgICAgICAgICAgIG0gPSBkLnBsb3RPcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLnVzZXJPcHRpb25zID0gay51c2VyT3B0aW9ucztcbiAgICAgICAgZCA9IGYoaCwgZS5zZXJpZXMsIGQucGxvdE9wdGlvbnMgJiYgZC5wbG90T3B0aW9uc1t0aGlzLnR5cGVdLCBiKTtcbiAgICAgICAgdGhpcy50b29sdGlwT3B0aW9ucyA9IGYoTC50b29sdGlwLCBMLnBsb3RPcHRpb25zLnNlcmllcyAmJiBMLnBsb3RPcHRpb25zLnNlcmllcy50b29sdGlwLCBMLnBsb3RPcHRpb25zW3RoaXMudHlwZV0udG9vbHRpcCwgYy50b29sdGlwLnVzZXJPcHRpb25zLCBlLnNlcmllcyAmJiBlLnNlcmllcy50b29sdGlwLCBlW3RoaXMudHlwZV0udG9vbHRpcCwgYi50b29sdGlwKTtcbiAgICAgICAgdGhpcy5zdGlja3lUcmFja2luZyA9IGwoYi5zdGlja3lUcmFja2luZywgbVt0aGlzLnR5cGVdICYmIG1bdGhpcy50eXBlXS5zdGlja3lUcmFja2luZywgbS5zZXJpZXMgJiYgbS5zZXJpZXMuc3RpY2t5VHJhY2tpbmcsIHRoaXMudG9vbHRpcE9wdGlvbnMuc2hhcmVkICYmICF0aGlzLm5vU2hhcmVkVG9vbHRpcCA/ICEwIDogZC5zdGlja3lUcmFja2luZyk7XG4gICAgICAgIG51bGwgPT09IGgubWFya2VyICYmIGRlbGV0ZSBkLm1hcmtlcjtcbiAgICAgICAgdGhpcy56b25lQXhpcyA9IGQuem9uZUF4aXM7XG4gICAgICAgIGMgPSB0aGlzLnpvbmVzID0gKGQuem9uZXMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgICFkLm5lZ2F0aXZlQ29sb3IgJiYgIWQubmVnYXRpdmVGaWxsQ29sb3IgfHwgZC56b25lcyB8fCAoZSA9IHtcbiAgICAgICAgICB2YWx1ZTogZFt0aGlzLnpvbmVBeGlzICsgXCJUaHJlc2hvbGRcIl0gfHwgZC50aHJlc2hvbGQgfHwgMCxcbiAgICAgICAgICBjbGFzc05hbWU6IFwiaGlnaGNoYXJ0cy1uZWdhdGl2ZVwiXG4gICAgICAgIH0sIGEgfHwgKGUuY29sb3IgPSBkLm5lZ2F0aXZlQ29sb3IsIGUuZmlsbENvbG9yID0gZC5uZWdhdGl2ZUZpbGxDb2xvciksIGMucHVzaChlKSk7XG4gICAgICAgIGMubGVuZ3RoICYmIHkoY1tjLmxlbmd0aCAtIDFdLnZhbHVlKSAmJiBjLnB1c2goYSA/IHt9IDoge1xuICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICAgIGZpbGxDb2xvcjogdGhpcy5maWxsQ29sb3JcbiAgICAgICAgfSk7XG4gICAgICAgIHEodGhpcywgXCJhZnRlclNldE9wdGlvbnNcIiwge1xuICAgICAgICAgIG9wdGlvbnM6IGRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkO1xuICAgICAgfSxcbiAgICAgIGdldE5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGwodGhpcy5vcHRpb25zLm5hbWUsIFwiU2VyaWVzIFwiICsgKHRoaXMuaW5kZXggKyAxKSk7XG4gICAgICB9LFxuICAgICAgZ2V0Q3ljbGljOiBmdW5jdGlvbiAoYiwgYSwgYykge1xuICAgICAgICB2YXIgZSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBmID0gdGhpcy51c2VyT3B0aW9ucyxcbiAgICAgICAgICAgIGQgPSBiICsgXCJJbmRleFwiLFxuICAgICAgICAgICAgayA9IGIgKyBcIkNvdW50ZXJcIixcbiAgICAgICAgICAgIGggPSBjID8gYy5sZW5ndGggOiBsKGUub3B0aW9ucy5jaGFydFtiICsgXCJDb3VudFwiXSwgZVtiICsgXCJDb3VudFwiXSk7XG5cbiAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgdmFyIHAgPSBsKGZbZF0sIGZbXCJfXCIgKyBkXSk7XG4gICAgICAgICAgeShwKSB8fCAoZS5zZXJpZXMubGVuZ3RoIHx8IChlW2tdID0gMCksIGZbXCJfXCIgKyBkXSA9IHAgPSBlW2tdICUgaCwgZVtrXSArPSAxKTtcbiAgICAgICAgICBjICYmIChhID0gY1twXSk7XG4gICAgICAgIH1cblxuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgcCAmJiAodGhpc1tkXSA9IHApO1xuICAgICAgICB0aGlzW2JdID0gYTtcbiAgICAgIH0sXG4gICAgICBnZXRDb2xvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoYXJ0LnN0eWxlZE1vZGUgPyB0aGlzLmdldEN5Y2xpYyhcImNvbG9yXCIpIDogdGhpcy5vcHRpb25zLmNvbG9yQnlQb2ludCA/IHRoaXMub3B0aW9ucy5jb2xvciA9IG51bGwgOiB0aGlzLmdldEN5Y2xpYyhcImNvbG9yXCIsIHRoaXMub3B0aW9ucy5jb2xvciB8fCBRW3RoaXMudHlwZV0uY29sb3IsIHRoaXMuY2hhcnQub3B0aW9ucy5jb2xvcnMpO1xuICAgICAgfSxcbiAgICAgIGdldFBvaW50c0NvbGxlY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmhhc0dyb3VwZWREYXRhID8gdGhpcy5wb2ludHMgOiB0aGlzLmRhdGEpIHx8IFtdO1xuICAgICAgfSxcbiAgICAgIGdldFN5bWJvbDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdldEN5Y2xpYyhcInN5bWJvbFwiLCB0aGlzLm9wdGlvbnMubWFya2VyLnN5bWJvbCwgdGhpcy5jaGFydC5vcHRpb25zLnN5bWJvbHMpO1xuICAgICAgfSxcbiAgICAgIGZpbmRQb2ludEluZGV4OiBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICB2YXIgYyA9IGIuaWQsXG4gICAgICAgICAgICBlID0gYi54LFxuICAgICAgICAgICAgZiA9IHRoaXMucG9pbnRzLFxuICAgICAgICAgICAgZCxcbiAgICAgICAgICAgIGggPSB0aGlzLm9wdGlvbnMuZGF0YVNvcnRpbmc7XG4gICAgICAgIGlmIChjKSB2YXIgbCA9IHRoaXMuY2hhcnQuZ2V0KGMpO2Vsc2UgaWYgKHRoaXMubGlua2VkUGFyZW50IHx8IHRoaXMuZW5hYmxlZERhdGFTb3J0aW5nKSB7XG4gICAgICAgICAgdmFyIHAgPSBoICYmIGgubWF0Y2hCeU5hbWUgPyBcIm5hbWVcIiA6IFwiaW5kZXhcIjtcbiAgICAgICAgICBsID0gTihmLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuICFhLnRvdWNoZWQgJiYgYVtwXSA9PT0gYltwXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWwpIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsKSB7XG4gICAgICAgICAgdmFyIG4gPSBsICYmIGwuaW5kZXg7XG4gICAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIG4gJiYgKGQgPSAhMCk7XG4gICAgICAgIH1cblxuICAgICAgICBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgbiAmJiBrKGUpICYmIChuID0gdGhpcy54RGF0YS5pbmRleE9mKGUsIGEpKTtcbiAgICAgICAgLTEgIT09IG4gJiYgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIG4gJiYgdGhpcy5jcm9wcGVkICYmIChuID0gbiA+PSB0aGlzLmNyb3BTdGFydCA/IG4gLSB0aGlzLmNyb3BTdGFydCA6IG4pO1xuICAgICAgICAhZCAmJiBmW25dICYmIGZbbl0udG91Y2hlZCAmJiAobiA9IHZvaWQgMCk7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfSxcbiAgICAgIGRyYXdMZWdlbmRTeW1ib2w6IGcuZHJhd0xpbmVNYXJrZXIsXG4gICAgICB1cGRhdGVEYXRhOiBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICB2YXIgYyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGUgPSBjLmRhdGFTb3J0aW5nLFxuICAgICAgICAgICAgZiA9IHRoaXMucG9pbnRzLFxuICAgICAgICAgICAgZCA9IFtdLFxuICAgICAgICAgICAgaCxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBuLFxuICAgICAgICAgICAgcCA9IHRoaXMucmVxdWlyZVNvcnRpbmcsXG4gICAgICAgICAgICBnID0gYi5sZW5ndGggPT09IGYubGVuZ3RoLFxuICAgICAgICAgICAgdyA9ICEwO1xuICAgICAgICB0aGlzLnhJbmNyZW1lbnQgPSBudWxsO1xuICAgICAgICBiLmZvckVhY2goZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICB2YXIgbCA9IHkoYikgJiYgdGhpcy5wb2ludENsYXNzLnByb3RvdHlwZS5vcHRpb25zVG9PYmplY3QuY2FsbCh7XG4gICAgICAgICAgICBzZXJpZXM6IHRoaXNcbiAgICAgICAgICB9LCBiKSB8fCB7fTtcbiAgICAgICAgICB2YXIgbSA9IGwueDtcblxuICAgICAgICAgIGlmIChsLmlkIHx8IGsobSkpIHtcbiAgICAgICAgICAgIGlmIChtID0gdGhpcy5maW5kUG9pbnRJbmRleChsLCBuKSwgLTEgPT09IG0gfHwgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIG0gPyBkLnB1c2goYikgOiBmW21dICYmIGIgIT09IGMuZGF0YVttXSA/IChmW21dLnVwZGF0ZShiLCAhMSwgbnVsbCwgITEpLCBmW21dLnRvdWNoZWQgPSAhMCwgcCAmJiAobiA9IG0gKyAxKSkgOiBmW21dICYmIChmW21dLnRvdWNoZWQgPSAhMCksICFnIHx8IGEgIT09IG0gfHwgZSAmJiBlLmVuYWJsZWQgfHwgdGhpcy5oYXNEZXJpdmVkRGF0YSkgaCA9ICEwO1xuICAgICAgICAgIH0gZWxzZSBkLnB1c2goYik7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBpZiAoaCkgZm9yIChiID0gZi5sZW5ndGg7IGItLTspIChsID0gZltiXSkgJiYgIWwudG91Y2hlZCAmJiBsLnJlbW92ZSAmJiBsLnJlbW92ZSghMSwgYSk7ZWxzZSAhZyB8fCBlICYmIGUuZW5hYmxlZCA/IHcgPSAhMSA6IChiLmZvckVhY2goZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBmW2FdLnVwZGF0ZSAmJiBiICE9PSBmW2FdLnkgJiYgZlthXS51cGRhdGUoYiwgITEsIG51bGwsICExKTtcbiAgICAgICAgfSksIGQubGVuZ3RoID0gMCk7XG4gICAgICAgIGYuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGIgJiYgKGIudG91Y2hlZCA9ICExKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdykgcmV0dXJuICExO1xuICAgICAgICBkLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICB0aGlzLmFkZFBvaW50KGIsICExLCBudWxsLCBudWxsLCAhMSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBudWxsID09PSB0aGlzLnhJbmNyZW1lbnQgJiYgdGhpcy54RGF0YSAmJiB0aGlzLnhEYXRhLmxlbmd0aCAmJiAodGhpcy54SW5jcmVtZW50ID0gRSh0aGlzLnhEYXRhKSwgdGhpcy5hdXRvSW5jcmVtZW50KCkpO1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9LFxuICAgICAgc2V0RGF0YTogZnVuY3Rpb24gKGIsIGEsIGMsIGYpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgICAgaCA9IGQucG9pbnRzLFxuICAgICAgICAgICAgcCA9IGggJiYgaC5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgIG0sXG4gICAgICAgICAgICBnID0gZC5vcHRpb25zLFxuICAgICAgICAgICAgdyA9IGQuY2hhcnQsXG4gICAgICAgICAgICB4ID0gZy5kYXRhU29ydGluZyxcbiAgICAgICAgICAgIHEgPSBudWxsLFxuICAgICAgICAgICAgdiA9IGQueEF4aXM7XG4gICAgICAgIHEgPSBnLnR1cmJvVGhyZXNob2xkO1xuICAgICAgICB2YXIgQyA9IHRoaXMueERhdGEsXG4gICAgICAgICAgICB0ID0gdGhpcy55RGF0YSxcbiAgICAgICAgICAgIEIgPSAobSA9IGQucG9pbnRBcnJheU1hcCkgJiYgbS5sZW5ndGgsXG4gICAgICAgICAgICB6ID0gZy5rZXlzLFxuICAgICAgICAgICAgeSA9IDAsXG4gICAgICAgICAgICBMID0gMSxcbiAgICAgICAgICAgIHU7XG4gICAgICAgIGIgPSBiIHx8IFtdO1xuICAgICAgICBtID0gYi5sZW5ndGg7XG4gICAgICAgIGEgPSBsKGEsICEwKTtcbiAgICAgICAgeCAmJiB4LmVuYWJsZWQgJiYgKGIgPSB0aGlzLnNvcnREYXRhKGIpKTtcbiAgICAgICAgITEgIT09IGYgJiYgbSAmJiBwICYmICFkLmNyb3BwZWQgJiYgIWQuaGFzR3JvdXBlZERhdGEgJiYgZC52aXNpYmxlICYmICFkLmlzU2VyaWVzQm9vc3RpbmcgJiYgKHUgPSB0aGlzLnVwZGF0ZURhdGEoYiwgYykpO1xuXG4gICAgICAgIGlmICghdSkge1xuICAgICAgICAgIGQueEluY3JlbWVudCA9IG51bGw7XG4gICAgICAgICAgZC5jb2xvckNvdW50ZXIgPSAwO1xuICAgICAgICAgIHRoaXMucGFyYWxsZWxBcnJheXMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgZFtiICsgXCJEYXRhXCJdLmxlbmd0aCA9IDA7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHEgJiYgbSA+IHEpIHtcbiAgICAgICAgICAgIGlmIChxID0gZC5nZXRGaXJzdFZhbGlkUG9pbnQoYiksIGsocSkpIGZvciAoYyA9IDA7IGMgPCBtOyBjKyspIENbY10gPSB0aGlzLmF1dG9JbmNyZW1lbnQoKSwgdFtjXSA9IGJbY107ZWxzZSBpZiAoZShxKSkge1xuICAgICAgICAgICAgICBpZiAoQikgZm9yIChjID0gMDsgYyA8IG07IGMrKykgZiA9IGJbY10sIENbY10gPSBmWzBdLCB0W2NdID0gZi5zbGljZSgxLCBCICsgMSk7ZWxzZSBmb3IgKHogJiYgKHkgPSB6LmluZGV4T2YoXCJ4XCIpLCBMID0gei5pbmRleE9mKFwieVwiKSwgeSA9IDAgPD0geSA/IHkgOiAwLCBMID0gMCA8PSBMID8gTCA6IDEpLCBjID0gMDsgYyA8IG07IGMrKykgZiA9IGJbY10sIENbY10gPSBmW3ldLCB0W2NdID0gZltMXTtcbiAgICAgICAgICAgIH0gZWxzZSBEKDEyLCAhMSwgdyk7XG4gICAgICAgICAgfSBlbHNlIGZvciAoYyA9IDA7IGMgPCBtOyBjKyspIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBiW2NdICYmIChmID0ge1xuICAgICAgICAgICAgc2VyaWVzOiBkXG4gICAgICAgICAgfSwgZC5wb2ludENsYXNzLnByb3RvdHlwZS5hcHBseU9wdGlvbnMuYXBwbHkoZiwgW2JbY11dKSwgZC51cGRhdGVQYXJhbGxlbEFycmF5cyhmLCBjKSk7XG4gICAgICAgICAgdCAmJiBuKHRbMF0pICYmIEQoMTQsICEwLCB3KTtcbiAgICAgICAgICBkLmRhdGEgPSBbXTtcbiAgICAgICAgICBkLm9wdGlvbnMuZGF0YSA9IGQudXNlck9wdGlvbnMuZGF0YSA9IGI7XG5cbiAgICAgICAgICBmb3IgKGMgPSBwOyBjLS07KSBoW2NdICYmIGhbY10uZGVzdHJveSAmJiBoW2NdLmRlc3Ryb3koKTtcblxuICAgICAgICAgIHYgJiYgKHYubWluUmFuZ2UgPSB2LnVzZXJNaW5SYW5nZSk7XG4gICAgICAgICAgZC5pc0RpcnR5ID0gdy5pc0RpcnR5Qm94ID0gITA7XG4gICAgICAgICAgZC5pc0RpcnR5RGF0YSA9ICEhaDtcbiAgICAgICAgICBjID0gITE7XG4gICAgICAgIH1cblxuICAgICAgICBcInBvaW50XCIgPT09IGcubGVnZW5kVHlwZSAmJiAodGhpcy5wcm9jZXNzRGF0YSgpLCB0aGlzLmdlbmVyYXRlUG9pbnRzKCkpO1xuICAgICAgICBhICYmIHcucmVkcmF3KGMpO1xuICAgICAgfSxcbiAgICAgIHNvcnREYXRhOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICBjID0gYS5vcHRpb25zLmRhdGFTb3J0aW5nLnNvcnRLZXkgfHwgXCJ5XCIsXG4gICAgICAgICAgICBlID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICByZXR1cm4geShhKSAmJiBiLnBvaW50Q2xhc3MucHJvdG90eXBlLm9wdGlvbnNUb09iamVjdC5jYWxsKHtcbiAgICAgICAgICAgIHNlcmllczogYlxuICAgICAgICAgIH0sIGEpIHx8IHt9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGIuZm9yRWFjaChmdW5jdGlvbiAoYywgZikge1xuICAgICAgICAgIGJbZl0gPSBlKGEsIGMpO1xuICAgICAgICAgIGJbZl0uaW5kZXggPSBmO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgYi5jb25jYXQoKS5zb3J0KGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgYiA9IFAoYywgYik7XG4gICAgICAgICAgYSA9IFAoYywgYSk7XG4gICAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgYi54ID0gYTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGEubGlua2VkU2VyaWVzICYmIGEubGlua2VkU2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICB2YXIgYyA9IGEub3B0aW9ucyxcbiAgICAgICAgICAgICAgZiA9IGMuZGF0YTtcbiAgICAgICAgICBjLmRhdGFTb3J0aW5nICYmIGMuZGF0YVNvcnRpbmcuZW5hYmxlZCB8fCAhZiB8fCAoZi5mb3JFYWNoKGZ1bmN0aW9uIChjLCBkKSB7XG4gICAgICAgICAgICBmW2RdID0gZShhLCBjKTtcbiAgICAgICAgICAgIGJbZF0gJiYgKGZbZF0ueCA9IGJbZF0ueCwgZltkXS5pbmRleCA9IGQpO1xuICAgICAgICAgIH0pLCBhLnNldERhdGEoZiwgITEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSxcbiAgICAgIHByb2Nlc3NEYXRhOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXMueERhdGEsXG4gICAgICAgICAgICBjID0gdGhpcy55RGF0YSxcbiAgICAgICAgICAgIGUgPSBhLmxlbmd0aDtcbiAgICAgICAgdmFyIGYgPSAwO1xuICAgICAgICB2YXIgZCA9IHRoaXMueEF4aXMsXG4gICAgICAgICAgICBrID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgaCA9IGsuY3JvcFRocmVzaG9sZDtcbiAgICAgICAgdmFyIGwgPSB0aGlzLmdldEV4dHJlbWVzRnJvbUFsbCB8fCBrLmdldEV4dHJlbWVzRnJvbUFsbCxcbiAgICAgICAgICAgIHAgPSB0aGlzLmlzQ2FydGVzaWFuO1xuICAgICAgICBrID0gZCAmJiBkLnZhbDJsaW47XG4gICAgICAgIHZhciBuID0gZCAmJiBkLmlzTG9nLFxuICAgICAgICAgICAgZyA9IHRoaXMucmVxdWlyZVNvcnRpbmc7XG4gICAgICAgIGlmIChwICYmICF0aGlzLmlzRGlydHkgJiYgIWQuaXNEaXJ0eSAmJiAhdGhpcy55QXhpcy5pc0RpcnR5ICYmICFiKSByZXR1cm4gITE7XG5cbiAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICBiID0gZC5nZXRFeHRyZW1lcygpO1xuICAgICAgICAgIHZhciB3ID0gYi5taW47XG4gICAgICAgICAgdmFyIHEgPSBiLm1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwICYmIHRoaXMuc29ydGVkICYmICFsICYmICghaCB8fCBlID4gaCB8fCB0aGlzLmZvcmNlQ3JvcCkpIGlmIChhW2UgLSAxXSA8IHcgfHwgYVswXSA+IHEpIGEgPSBbXSwgYyA9IFtdO2Vsc2UgaWYgKHRoaXMueURhdGEgJiYgKGFbMF0gPCB3IHx8IGFbZSAtIDFdID4gcSkpIHtcbiAgICAgICAgICBmID0gdGhpcy5jcm9wRGF0YSh0aGlzLnhEYXRhLCB0aGlzLnlEYXRhLCB3LCBxKTtcbiAgICAgICAgICBhID0gZi54RGF0YTtcbiAgICAgICAgICBjID0gZi55RGF0YTtcbiAgICAgICAgICBmID0gZi5zdGFydDtcbiAgICAgICAgICB2YXIgdiA9ICEwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChoID0gYS5sZW5ndGggfHwgMTsgLS1oOykgaWYgKGUgPSBuID8gayhhW2hdKSAtIGsoYVtoIC0gMV0pIDogYVtoXSAtIGFbaCAtIDFdLCAwIDwgZSAmJiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHQgfHwgZSA8IHQpKSB2YXIgdCA9IGU7ZWxzZSAwID4gZSAmJiBnICYmIChEKDE1LCAhMSwgdGhpcy5jaGFydCksIGcgPSAhMSk7XG5cbiAgICAgICAgdGhpcy5jcm9wcGVkID0gdjtcbiAgICAgICAgdGhpcy5jcm9wU3RhcnQgPSBmO1xuICAgICAgICB0aGlzLnByb2Nlc3NlZFhEYXRhID0gYTtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWRZRGF0YSA9IGM7XG4gICAgICAgIHRoaXMuY2xvc2VzdFBvaW50UmFuZ2UgPSB0aGlzLmJhc2VQb2ludFJhbmdlID0gdDtcbiAgICAgIH0sXG4gICAgICBjcm9wRGF0YTogZnVuY3Rpb24gKGIsIGEsIGMsIGUsIGYpIHtcbiAgICAgICAgdmFyIGQgPSBiLmxlbmd0aCxcbiAgICAgICAgICAgIGsgPSAwLFxuICAgICAgICAgICAgaCA9IGQsXG4gICAgICAgICAgICBwO1xuICAgICAgICBmID0gbChmLCB0aGlzLmNyb3BTaG91bGRlcik7XG5cbiAgICAgICAgZm9yIChwID0gMDsgcCA8IGQ7IHArKykgaWYgKGJbcF0gPj0gYykge1xuICAgICAgICAgIGsgPSBNYXRoLm1heCgwLCBwIC0gZik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGMgPSBwOyBjIDwgZDsgYysrKSBpZiAoYltjXSA+IGUpIHtcbiAgICAgICAgICBoID0gYyArIGY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHhEYXRhOiBiLnNsaWNlKGssIGgpLFxuICAgICAgICAgIHlEYXRhOiBhLnNsaWNlKGssIGgpLFxuICAgICAgICAgIHN0YXJ0OiBrLFxuICAgICAgICAgIGVuZDogaFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgYSA9IGIuZGF0YSxcbiAgICAgICAgICAgIGMgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICBlLFxuICAgICAgICAgICAgZiA9IHRoaXMucHJvY2Vzc2VkWERhdGEsXG4gICAgICAgICAgICBkID0gdGhpcy5wcm9jZXNzZWRZRGF0YSxcbiAgICAgICAgICAgIGsgPSB0aGlzLnBvaW50Q2xhc3MsXG4gICAgICAgICAgICBsID0gZi5sZW5ndGgsXG4gICAgICAgICAgICBwID0gdGhpcy5jcm9wU3RhcnQgfHwgMCxcbiAgICAgICAgICAgIG4gPSB0aGlzLmhhc0dyb3VwZWREYXRhO1xuICAgICAgICBiID0gYi5rZXlzO1xuICAgICAgICB2YXIgZyA9IFtdLFxuICAgICAgICAgICAgdjtcbiAgICAgICAgYyB8fCBuIHx8IChjID0gW10sIGMubGVuZ3RoID0gYS5sZW5ndGgsIGMgPSB0aGlzLmRhdGEgPSBjKTtcbiAgICAgICAgYiAmJiBuICYmICh0aGlzLm9wdGlvbnMua2V5cyA9ICExKTtcblxuICAgICAgICBmb3IgKHYgPSAwOyB2IDwgbDsgdisrKSB7XG4gICAgICAgICAgdmFyIHQgPSBwICsgdjtcblxuICAgICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICB2YXIgQiA9IG5ldyBrKCkuaW5pdCh0aGlzLCBbZlt2XV0uY29uY2F0KHcoZFt2XSkpKTtcbiAgICAgICAgICAgIEIuZGF0YUdyb3VwID0gdGhpcy5ncm91cE1hcFt2XTtcbiAgICAgICAgICAgIEIuZGF0YUdyb3VwLm9wdGlvbnMgJiYgKEIub3B0aW9ucyA9IEIuZGF0YUdyb3VwLm9wdGlvbnMsIGgoQiwgQi5kYXRhR3JvdXAub3B0aW9ucyksIGRlbGV0ZSBCLmRhdGFMYWJlbHMpO1xuICAgICAgICAgIH0gZWxzZSAoQiA9IGNbdF0pIHx8IFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBhW3RdIHx8IChjW3RdID0gQiA9IG5ldyBrKCkuaW5pdCh0aGlzLCBhW3RdLCBmW3ZdKSk7XG5cbiAgICAgICAgICBCICYmIChCLmluZGV4ID0gdCwgZ1t2XSA9IEIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLmtleXMgPSBiO1xuICAgICAgICBpZiAoYyAmJiAobCAhPT0gKGUgPSBjLmxlbmd0aCkgfHwgbikpIGZvciAodiA9IDA7IHYgPCBlOyB2KyspIHYgIT09IHAgfHwgbiB8fCAodiArPSBsKSwgY1t2XSAmJiAoY1t2XS5kZXN0cm95RWxlbWVudHMoKSwgY1t2XS5wbG90WCA9IHZvaWQgMCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGM7XG4gICAgICAgIHRoaXMucG9pbnRzID0gZztcbiAgICAgICAgcSh0aGlzLCBcImFmdGVyR2VuZXJhdGVQb2ludHNcIik7XG4gICAgICB9LFxuICAgICAgZ2V0WEV4dHJlbWVzOiBmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1pbjogQShiKSxcbiAgICAgICAgICBtYXg6IEUoYilcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBnZXRFeHRyZW1lczogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLnhBeGlzLFxuICAgICAgICAgICAgYyA9IHRoaXMueUF4aXMsXG4gICAgICAgICAgICBmID0gdGhpcy5wcm9jZXNzZWRYRGF0YSB8fCB0aGlzLnhEYXRhLFxuICAgICAgICAgICAgZCA9IFtdLFxuICAgICAgICAgICAgaCA9IDAsXG4gICAgICAgICAgICBsID0gMDtcbiAgICAgICAgdmFyIG0gPSAwO1xuICAgICAgICB2YXIgcCA9IHRoaXMucmVxdWlyZVNvcnRpbmcgPyB0aGlzLmNyb3BTaG91bGRlciA6IDAsXG4gICAgICAgICAgICBuID0gYyA/IGMucG9zaXRpdmVWYWx1ZXNPbmx5IDogITEsXG4gICAgICAgICAgICBnO1xuICAgICAgICBiID0gYiB8fCB0aGlzLnN0YWNrZWRZRGF0YSB8fCB0aGlzLnByb2Nlc3NlZFlEYXRhIHx8IFtdO1xuICAgICAgICBjID0gYi5sZW5ndGg7XG4gICAgICAgIGEgJiYgKG0gPSBhLmdldEV4dHJlbWVzKCksIGwgPSBtLm1pbiwgbSA9IG0ubWF4KTtcblxuICAgICAgICBmb3IgKGcgPSAwOyBnIDwgYzsgZysrKSB7XG4gICAgICAgICAgdmFyIHcgPSBmW2ddO1xuICAgICAgICAgIHZhciB2ID0gYltnXTtcbiAgICAgICAgICB2YXIgdCA9IChrKHYpIHx8IGUodikpICYmICh2Lmxlbmd0aCB8fCAwIDwgdiB8fCAhbik7XG4gICAgICAgICAgdyA9IHRoaXMuZ2V0RXh0cmVtZXNGcm9tQWxsIHx8IHRoaXMub3B0aW9ucy5nZXRFeHRyZW1lc0Zyb21BbGwgfHwgdGhpcy5jcm9wcGVkIHx8ICFhIHx8IChmW2cgKyBwXSB8fCB3KSA+PSBsICYmIChmW2cgLSBwXSB8fCB3KSA8PSBtO1xuICAgICAgICAgIGlmICh0ICYmIHcpIGlmICh0ID0gdi5sZW5ndGgpIGZvciAoOyB0LS07KSBrKHZbdF0pICYmIChkW2grK10gPSB2W3RdKTtlbHNlIGRbaCsrXSA9IHY7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGFNaW4gPSBBKGQpO1xuICAgICAgICB0aGlzLmRhdGFNYXggPSBFKGQpO1xuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJHZXRFeHRyZW1lc1wiKTtcbiAgICAgIH0sXG4gICAgICBnZXRGaXJzdFZhbGlkUG9pbnQ6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIGZvciAodmFyIGEgPSBudWxsLCBjID0gYi5sZW5ndGgsIGUgPSAwOyBudWxsID09PSBhICYmIGUgPCBjOykgYSA9IGJbZV0sIGUrKztcblxuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWRYRGF0YSB8fCB0aGlzLnByb2Nlc3NEYXRhKCk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVQb2ludHMoKTtcbiAgICAgICAgdmFyIGIgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBhID0gYi5zdGFja2luZyxcbiAgICAgICAgICAgIGMgPSB0aGlzLnhBeGlzLFxuICAgICAgICAgICAgZiA9IGMuY2F0ZWdvcmllcyxcbiAgICAgICAgICAgIGQgPSB0aGlzLmVuYWJsZWREYXRhU29ydGluZyxcbiAgICAgICAgICAgIGggPSB0aGlzLnlBeGlzLFxuICAgICAgICAgICAgcCA9IHRoaXMucG9pbnRzLFxuICAgICAgICAgICAgbSA9IHAubGVuZ3RoLFxuICAgICAgICAgICAgbiA9ICEhdGhpcy5tb2RpZnlWYWx1ZSxcbiAgICAgICAgICAgIGcsXG4gICAgICAgICAgICB3ID0gdGhpcy5wb2ludFBsYWNlbWVudFRvWFZhbHVlKCksXG4gICAgICAgICAgICB2ID0gISF3LFxuICAgICAgICAgICAgdCA9IGIudGhyZXNob2xkLFxuICAgICAgICAgICAgQiA9IGIuc3RhcnRGcm9tVGhyZXNob2xkID8gdCA6IDAsXG4gICAgICAgICAgICB6LFxuICAgICAgICAgICAgTCA9IHRoaXMuem9uZUF4aXMgfHwgXCJ5XCIsXG4gICAgICAgICAgICB1ID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgICBmb3IgKGcgPSAwOyBnIDwgbTsgZysrKSB7XG4gICAgICAgICAgdmFyIEsgPSBwW2ddLFxuICAgICAgICAgICAgICByID0gSy54LFxuICAgICAgICAgICAgICBIID0gSy55LFxuICAgICAgICAgICAgICBEID0gSy5sb3csXG4gICAgICAgICAgICAgIEEgPSBhICYmIGguc3RhY2tzWyh0aGlzLm5lZ1N0YWNrcyAmJiBIIDwgKEIgPyAwIDogdCkgPyBcIi1cIiA6IFwiXCIpICsgdGhpcy5zdGFja0tleV07XG4gICAgICAgICAgaC5wb3NpdGl2ZVZhbHVlc09ubHkgJiYgbnVsbCAhPT0gSCAmJiAwID49IEggJiYgKEsuaXNOdWxsID0gITApO1xuICAgICAgICAgIEsucGxvdFggPSB6ID0gSihHKGMudHJhbnNsYXRlKHIsIDAsIDAsIDAsIDEsIHcsIFwiZmxhZ3NcIiA9PT0gdGhpcy50eXBlKSwgLTFFNSwgMUU1KSk7XG5cbiAgICAgICAgICBpZiAoYSAmJiB0aGlzLnZpc2libGUgJiYgQSAmJiBBW3JdKSB7XG4gICAgICAgICAgICB2YXIgTiA9IHRoaXMuZ2V0U3RhY2tJbmRpY2F0b3IoTiwgciwgdGhpcy5pbmRleCk7XG5cbiAgICAgICAgICAgIGlmICghSy5pc051bGwpIHtcbiAgICAgICAgICAgICAgdmFyIFEgPSBBW3JdO1xuICAgICAgICAgICAgICB2YXIgRSA9IFEucG9pbnRzW04ua2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlKEUpICYmIChEID0gRVswXSwgSCA9IEVbMV0sIEQgPT09IEIgJiYgTi5rZXkgPT09IEFbcl0uYmFzZSAmJiAoRCA9IGwoayh0KSAmJiB0LCBoLm1pbikpLCBoLnBvc2l0aXZlVmFsdWVzT25seSAmJiAwID49IEQgJiYgKEQgPSBudWxsKSwgSy50b3RhbCA9IEsuc3RhY2tUb3RhbCA9IFEudG90YWwsIEsucGVyY2VudGFnZSA9IFEudG90YWwgJiYgSy55IC8gUS50b3RhbCAqIDEwMCwgSy5zdGFja1kgPSBILCB0aGlzLmlycmVndWxhcldpZHRocyB8fCBRLnNldE9mZnNldCh0aGlzLnBvaW50WE9mZnNldCB8fCAwLCB0aGlzLmJhclcgfHwgMCkpO1xuICAgICAgICAgIEsueUJvdHRvbSA9IHkoRCkgPyBHKGgudHJhbnNsYXRlKEQsIDAsIDEsIDAsIDEpLCAtMUU1LCAxRTUpIDogbnVsbDtcbiAgICAgICAgICBuICYmIChIID0gdGhpcy5tb2RpZnlWYWx1ZShILCBLKSk7XG4gICAgICAgICAgSy5wbG90WSA9IFwibnVtYmVyXCIgPT09IHR5cGVvZiBIICYmIEluZmluaXR5ICE9PSBIID8gRyhoLnRyYW5zbGF0ZShILCAwLCAxLCAwLCAxKSwgLTFFNSwgMUU1KSA6IHZvaWQgMDtcbiAgICAgICAgICBLLmlzSW5zaWRlID0gdGhpcy5pc1BvaW50SW5zaWRlKEspO1xuICAgICAgICAgIEsuY2xpZW50WCA9IHYgPyBKKGMudHJhbnNsYXRlKHIsIDAsIDAsIDAsIDEsIHcpKSA6IHo7XG4gICAgICAgICAgSy5uZWdhdGl2ZSA9IEtbTF0gPCAoYltMICsgXCJUaHJlc2hvbGRcIl0gfHwgdCB8fCAwKTtcbiAgICAgICAgICBLLmNhdGVnb3J5ID0gZiAmJiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZltLLnhdID8gZltLLnhdIDogSy54O1xuXG4gICAgICAgICAgaWYgKCFLLmlzTnVsbCAmJiAhMSAhPT0gSy52aXNpYmxlKSB7XG4gICAgICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgUCAmJiAodSA9IE1hdGgubWluKHUsIE1hdGguYWJzKHogLSBQKSkpO1xuICAgICAgICAgICAgdmFyIFAgPSB6O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEsuem9uZSA9IHRoaXMuem9uZXMubGVuZ3RoICYmIEsuZ2V0Wm9uZSgpO1xuICAgICAgICAgICFLLmdyYXBoaWMgJiYgdGhpcy5ncm91cCAmJiBkICYmIChLLmlzTmV3ID0gITApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbG9zZXN0UG9pbnRSYW5nZVB4ID0gdTtcbiAgICAgICAgcSh0aGlzLCBcImFmdGVyVHJhbnNsYXRlXCIpO1xuICAgICAgfSxcbiAgICAgIGdldFZhbGlkUG9pbnRzOiBmdW5jdGlvbiAoYiwgYSwgYykge1xuICAgICAgICB2YXIgZSA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIHJldHVybiAoYiB8fCB0aGlzLnBvaW50cyB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgcmV0dXJuIGEgJiYgIWUuaXNJbnNpZGVQbG90KGIucGxvdFgsIGIucGxvdFksIGUuaW52ZXJ0ZWQpID8gITEgOiAhMSAhPT0gYi52aXNpYmxlICYmIChjIHx8ICFiLmlzTnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdldENsaXBCb3g6IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgZSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBmID0gZS5pbnZlcnRlZCxcbiAgICAgICAgICAgIGQgPSB0aGlzLnhBeGlzLFxuICAgICAgICAgICAgayA9IGQgJiYgdGhpcy55QXhpcztcbiAgICAgICAgYiAmJiAhMSA9PT0gYy5jbGlwICYmIGsgPyBiID0gZiA/IHtcbiAgICAgICAgICB5OiAtZS5jaGFydFdpZHRoICsgay5sZW4gKyBrLnBvcyxcbiAgICAgICAgICBoZWlnaHQ6IGUuY2hhcnRXaWR0aCxcbiAgICAgICAgICB3aWR0aDogZS5jaGFydEhlaWdodCxcbiAgICAgICAgICB4OiAtZS5jaGFydEhlaWdodCArIGQubGVuICsgZC5wb3NcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB5OiAtay5wb3MsXG4gICAgICAgICAgaGVpZ2h0OiBlLmNoYXJ0SGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiBlLmNoYXJ0V2lkdGgsXG4gICAgICAgICAgeDogLWQucG9zXG4gICAgICAgIH0gOiAoYiA9IHRoaXMuY2xpcEJveCB8fCBlLmNsaXBCb3gsIGEgJiYgKGIud2lkdGggPSBlLnBsb3RTaXplWCwgYi54ID0gMCkpO1xuICAgICAgICByZXR1cm4gYSA/IHtcbiAgICAgICAgICB3aWR0aDogYi53aWR0aCxcbiAgICAgICAgICB4OiBiLnhcbiAgICAgICAgfSA6IGI7XG4gICAgICB9LFxuICAgICAgc2V0Q2xpcDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgYyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGUgPSBhLnJlbmRlcmVyLFxuICAgICAgICAgICAgZiA9IGEuaW52ZXJ0ZWQsXG4gICAgICAgICAgICBkID0gdGhpcy5jbGlwQm94LFxuICAgICAgICAgICAgayA9IHRoaXMuZ2V0Q2xpcEJveChiKSxcbiAgICAgICAgICAgIGggPSB0aGlzLnNoYXJlZENsaXBLZXkgfHwgW1wiX3NoYXJlZENsaXBcIiwgYiAmJiBiLmR1cmF0aW9uLCBiICYmIGIuZWFzaW5nLCBrLmhlaWdodCwgYy54QXhpcywgYy55QXhpc10uam9pbigpLFxuICAgICAgICAgICAgbCA9IGFbaF0sXG4gICAgICAgICAgICBwID0gYVtoICsgXCJtXCJdO1xuICAgICAgICBiICYmIChrLndpZHRoID0gMCwgZiAmJiAoay54ID0gYS5wbG90SGVpZ2h0ICsgKCExICE9PSBjLmNsaXAgPyAwIDogYS5wbG90VG9wKSkpO1xuICAgICAgICBsID8gYS5oYXNMb2FkZWQgfHwgbC5hdHRyKGspIDogKGIgJiYgKGFbaCArIFwibVwiXSA9IHAgPSBlLmNsaXBSZWN0KGYgPyBhLnBsb3RTaXplWCArIDk5IDogLTk5LCBmID8gLWEucGxvdExlZnQgOiAtYS5wbG90VG9wLCA5OSwgZiA/IGEuY2hhcnRXaWR0aCA6IGEuY2hhcnRIZWlnaHQpKSwgYVtoXSA9IGwgPSBlLmNsaXBSZWN0KGspLCBsLmNvdW50ID0ge1xuICAgICAgICAgIGxlbmd0aDogMFxuICAgICAgICB9KTtcbiAgICAgICAgYiAmJiAhbC5jb3VudFt0aGlzLmluZGV4XSAmJiAobC5jb3VudFt0aGlzLmluZGV4XSA9ICEwLCBsLmNvdW50Lmxlbmd0aCArPSAxKTtcbiAgICAgICAgaWYgKCExICE9PSBjLmNsaXAgfHwgYikgdGhpcy5ncm91cC5jbGlwKGIgfHwgZCA/IGwgOiBhLmNsaXBSZWN0KSwgdGhpcy5tYXJrZXJHcm91cC5jbGlwKHApLCB0aGlzLnNoYXJlZENsaXBLZXkgPSBoO1xuICAgICAgICBiIHx8IChsLmNvdW50W3RoaXMuaW5kZXhdICYmIChkZWxldGUgbC5jb3VudFt0aGlzLmluZGV4XSwgLS1sLmNvdW50Lmxlbmd0aCksIDAgPT09IGwuY291bnQubGVuZ3RoICYmIGggJiYgYVtoXSAmJiAoZCB8fCAoYVtoXSA9IGFbaF0uZGVzdHJveSgpKSwgYVtoICsgXCJtXCJdICYmIChhW2ggKyBcIm1cIl0gPSBhW2ggKyBcIm1cIl0uZGVzdHJveSgpKSkpO1xuICAgICAgfSxcbiAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGMgPSBNKHRoaXMub3B0aW9ucy5hbmltYXRpb24pO1xuICAgICAgICBpZiAoIWEuaGFzUmVuZGVyZWQpIGlmIChiKSB0aGlzLnNldENsaXAoYyk7ZWxzZSB7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLnNoYXJlZENsaXBLZXk7XG4gICAgICAgICAgYiA9IGFbZV07XG4gICAgICAgICAgdmFyIGYgPSB0aGlzLmdldENsaXBCb3goYywgITApO1xuICAgICAgICAgIGIgJiYgYi5hbmltYXRlKGYsIGMpO1xuICAgICAgICAgIGFbZSArIFwibVwiXSAmJiBhW2UgKyBcIm1cIl0uYW5pbWF0ZSh7XG4gICAgICAgICAgICB3aWR0aDogZi53aWR0aCArIDk5LFxuICAgICAgICAgICAgeDogZi54IC0gKGEuaW52ZXJ0ZWQgPyAwIDogOTkpXG4gICAgICAgICAgfSwgYyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhZnRlckFuaW1hdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRDbGlwKCk7XG4gICAgICAgIHEodGhpcywgXCJhZnRlckFuaW1hdGVcIik7XG4gICAgICAgIHRoaXMuZmluaXNoZWRBbmltYXRpbmcgPSAhMDtcbiAgICAgIH0sXG4gICAgICBkcmF3UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5wb2ludHMsXG4gICAgICAgICAgICBhID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBlLFxuICAgICAgICAgICAgZiA9IHRoaXMub3B0aW9ucy5tYXJrZXIsXG4gICAgICAgICAgICBkID0gdGhpc1t0aGlzLnNwZWNpYWxHcm91cF0gfHwgdGhpcy5tYXJrZXJHcm91cCxcbiAgICAgICAgICAgIGsgPSB0aGlzLnhBeGlzLFxuICAgICAgICAgICAgaCA9IGwoZi5lbmFibGVkLCAhayB8fCBrLmlzUmFkaWFsID8gITAgOiBudWxsLCB0aGlzLmNsb3Nlc3RQb2ludFJhbmdlUHggPj0gZi5lbmFibGVkVGhyZXNob2xkICogZi5yYWRpdXMpO1xuICAgICAgICBpZiAoITEgIT09IGYuZW5hYmxlZCB8fCB0aGlzLl9oYXNQb2ludE1hcmtlcnMpIGZvciAoYyA9IDA7IGMgPCBiLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgdmFyIHAgPSBiW2NdO1xuICAgICAgICAgIHZhciBuID0gKGUgPSBwLmdyYXBoaWMpID8gXCJhbmltYXRlXCIgOiBcImF0dHJcIjtcbiAgICAgICAgICB2YXIgZyA9IHAubWFya2VyIHx8IHt9O1xuICAgICAgICAgIHZhciB3ID0gISFwLm1hcmtlcjtcblxuICAgICAgICAgIGlmICgoaCAmJiBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgZy5lbmFibGVkIHx8IGcuZW5hYmxlZCkgJiYgIXAuaXNOdWxsICYmICExICE9PSBwLnZpc2libGUpIHtcbiAgICAgICAgICAgIHZhciB2ID0gbChnLnN5bWJvbCwgdGhpcy5zeW1ib2wpO1xuICAgICAgICAgICAgdmFyIHEgPSB0aGlzLm1hcmtlckF0dHJpYnMocCwgcC5zZWxlY3RlZCAmJiBcInNlbGVjdFwiKTtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlZERhdGFTb3J0aW5nICYmIChwLnN0YXJ0WFBvcyA9IGsucmV2ZXJzZWQgPyAtcS53aWR0aCA6IGsud2lkdGgpO1xuICAgICAgICAgICAgdmFyIHQgPSAhMSAhPT0gcC5pc0luc2lkZTtcbiAgICAgICAgICAgIGUgPyBlW3QgPyBcInNob3dcIiA6IFwiaGlkZVwiXSh0KS5hbmltYXRlKHEpIDogdCAmJiAoMCA8IHEud2lkdGggfHwgcC5oYXNJbWFnZSkgJiYgKHAuZ3JhcGhpYyA9IGUgPSBhLnJlbmRlcmVyLnN5bWJvbCh2LCBxLngsIHEueSwgcS53aWR0aCwgcS5oZWlnaHQsIHcgPyBnIDogZikuYWRkKGQpLCB0aGlzLmVuYWJsZWREYXRhU29ydGluZyAmJiBhLmhhc1JlbmRlcmVkICYmIChlLmF0dHIoe1xuICAgICAgICAgICAgICB4OiBwLnN0YXJ0WFBvc1xuICAgICAgICAgICAgfSksIG4gPSBcImFuaW1hdGVcIikpO1xuICAgICAgICAgICAgZSAmJiBcImFuaW1hdGVcIiA9PT0gbiAmJiBlW3QgPyBcInNob3dcIiA6IFwiaGlkZVwiXSh0KS5hbmltYXRlKHEpO1xuICAgICAgICAgICAgaWYgKGUgJiYgIWEuc3R5bGVkTW9kZSkgZVtuXSh0aGlzLnBvaW50QXR0cmlicyhwLCBwLnNlbGVjdGVkICYmIFwic2VsZWN0XCIpKTtcbiAgICAgICAgICAgIGUgJiYgZS5hZGRDbGFzcyhwLmdldENsYXNzTmFtZSgpLCAhMCk7XG4gICAgICAgICAgfSBlbHNlIGUgJiYgKHAuZ3JhcGhpYyA9IGUuZGVzdHJveSgpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1hcmtlckF0dHJpYnM6IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5vcHRpb25zLm1hcmtlcixcbiAgICAgICAgICAgIGUgPSBiLm1hcmtlciB8fCB7fSxcbiAgICAgICAgICAgIGYgPSBlLnN5bWJvbCB8fCBjLnN5bWJvbCxcbiAgICAgICAgICAgIGQgPSBsKGUucmFkaXVzLCBjLnJhZGl1cyk7XG4gICAgICAgIGEgJiYgKGMgPSBjLnN0YXRlc1thXSwgYSA9IGUuc3RhdGVzICYmIGUuc3RhdGVzW2FdLCBkID0gbChhICYmIGEucmFkaXVzLCBjICYmIGMucmFkaXVzLCBkICsgKGMgJiYgYy5yYWRpdXNQbHVzIHx8IDApKSk7XG4gICAgICAgIGIuaGFzSW1hZ2UgPSBmICYmIDAgPT09IGYuaW5kZXhPZihcInVybFwiKTtcbiAgICAgICAgYi5oYXNJbWFnZSAmJiAoZCA9IDApO1xuICAgICAgICBiID0ge1xuICAgICAgICAgIHg6IE1hdGguZmxvb3IoYi5wbG90WCkgLSBkLFxuICAgICAgICAgIHk6IGIucGxvdFkgLSBkXG4gICAgICAgIH07XG4gICAgICAgIGQgJiYgKGIud2lkdGggPSBiLmhlaWdodCA9IDIgKiBkKTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9LFxuICAgICAgcG9pbnRBdHRyaWJzOiBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICB2YXIgYyA9IHRoaXMub3B0aW9ucy5tYXJrZXIsXG4gICAgICAgICAgICBlID0gYiAmJiBiLm9wdGlvbnMsXG4gICAgICAgICAgICBmID0gZSAmJiBlLm1hcmtlciB8fCB7fSxcbiAgICAgICAgICAgIGQgPSB0aGlzLmNvbG9yLFxuICAgICAgICAgICAgayA9IGUgJiYgZS5jb2xvcixcbiAgICAgICAgICAgIGggPSBiICYmIGIuY29sb3I7XG4gICAgICAgIGUgPSBsKGYubGluZVdpZHRoLCBjLmxpbmVXaWR0aCk7XG4gICAgICAgIHZhciBwID0gYiAmJiBiLnpvbmUgJiYgYi56b25lLmNvbG9yO1xuICAgICAgICBiID0gMTtcbiAgICAgICAgZCA9IGsgfHwgcCB8fCBoIHx8IGQ7XG4gICAgICAgIGsgPSBmLmZpbGxDb2xvciB8fCBjLmZpbGxDb2xvciB8fCBkO1xuICAgICAgICBkID0gZi5saW5lQ29sb3IgfHwgYy5saW5lQ29sb3IgfHwgZDtcbiAgICAgICAgYSA9IGEgfHwgXCJub3JtYWxcIjtcbiAgICAgICAgYyA9IGMuc3RhdGVzW2FdO1xuICAgICAgICBhID0gZi5zdGF0ZXMgJiYgZi5zdGF0ZXNbYV0gfHwge307XG4gICAgICAgIGUgPSBsKGEubGluZVdpZHRoLCBjLmxpbmVXaWR0aCwgZSArIGwoYS5saW5lV2lkdGhQbHVzLCBjLmxpbmVXaWR0aFBsdXMsIDApKTtcbiAgICAgICAgayA9IGEuZmlsbENvbG9yIHx8IGMuZmlsbENvbG9yIHx8IGs7XG4gICAgICAgIGQgPSBhLmxpbmVDb2xvciB8fCBjLmxpbmVDb2xvciB8fCBkO1xuICAgICAgICBiID0gbChhLm9wYWNpdHksIGMub3BhY2l0eSwgYik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3Ryb2tlOiBkLFxuICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IGUsXG4gICAgICAgICAgZmlsbDogayxcbiAgICAgICAgICBvcGFjaXR5OiBiXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLFxuICAgICAgICAgICAgZSA9IGMuY2hhcnQsXG4gICAgICAgICAgICBmID0gL0FwcGxlV2ViS2l0XFwvNTMzLy50ZXN0KHAubmF2aWdhdG9yLnVzZXJBZ2VudCksXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgayxcbiAgICAgICAgICAgIGggPSBjLmRhdGEgfHwgW10sXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgbjtcbiAgICAgICAgcShjLCBcImRlc3Ryb3lcIik7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRzKGIpO1xuICAgICAgICAoYy5heGlzVHlwZXMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAobiA9IGNbYl0pICYmIG4uc2VyaWVzICYmICh0KG4uc2VyaWVzLCBjKSwgbi5pc0RpcnR5ID0gbi5mb3JjZVJlZHJhdyA9ICEwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGMubGVnZW5kSXRlbSAmJiBjLmNoYXJ0LmxlZ2VuZC5kZXN0cm95SXRlbShjKTtcblxuICAgICAgICBmb3IgKGsgPSBoLmxlbmd0aDsgay0tOykgKGwgPSBoW2tdKSAmJiBsLmRlc3Ryb3kgJiYgbC5kZXN0cm95KCk7XG5cbiAgICAgICAgYy5wb2ludHMgPSBudWxsO1xuICAgICAgICB1LmNsZWFyVGltZW91dChjLmFuaW1hdGlvblRpbWVvdXQpO1xuICAgICAgICBhKGMsIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgYiBpbnN0YW5jZW9mIEsgJiYgIWIuc3Vydml2ZSAmJiAoZCA9IGYgJiYgXCJncm91cFwiID09PSBhID8gXCJoaWRlXCIgOiBcImRlc3Ryb3lcIiwgYltkXSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGUuaG92ZXJTZXJpZXMgPT09IGMgJiYgKGUuaG92ZXJTZXJpZXMgPSBudWxsKTtcbiAgICAgICAgdChlLnNlcmllcywgYyk7XG4gICAgICAgIGUub3JkZXJTZXJpZXMoKTtcbiAgICAgICAgYShjLCBmdW5jdGlvbiAoYSwgZSkge1xuICAgICAgICAgIGIgJiYgXCJoY0V2ZW50c1wiID09PSBlIHx8IGRlbGV0ZSBjW2VdO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZXRHcmFwaFBhdGg6IGZ1bmN0aW9uIChiLCBhLCBjKSB7XG4gICAgICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgICAgIGYgPSBlLm9wdGlvbnMsXG4gICAgICAgICAgICBkID0gZi5zdGVwLFxuICAgICAgICAgICAgayxcbiAgICAgICAgICAgIGggPSBbXSxcbiAgICAgICAgICAgIGwgPSBbXSxcbiAgICAgICAgICAgIHA7XG4gICAgICAgIGIgPSBiIHx8IGUucG9pbnRzO1xuICAgICAgICAoayA9IGIucmV2ZXJzZWQpICYmIGIucmV2ZXJzZSgpO1xuICAgICAgICAoZCA9IHtcbiAgICAgICAgICByaWdodDogMSxcbiAgICAgICAgICBjZW50ZXI6IDJcbiAgICAgICAgfVtkXSB8fCBkICYmIDMpICYmIGsgJiYgKGQgPSA0IC0gZCk7XG4gICAgICAgIGIgPSB0aGlzLmdldFZhbGlkUG9pbnRzKGIsICExLCAhKGYuY29ubmVjdE51bGxzICYmICFhICYmICFjKSk7XG4gICAgICAgIGIuZm9yRWFjaChmdW5jdGlvbiAoaywgbikge1xuICAgICAgICAgIHZhciBtID0gay5wbG90WCxcbiAgICAgICAgICAgICAgZyA9IGsucGxvdFksXG4gICAgICAgICAgICAgIHcgPSBiW24gLSAxXTtcbiAgICAgICAgICAoay5sZWZ0Q2xpZmYgfHwgdyAmJiB3LnJpZ2h0Q2xpZmYpICYmICFjICYmIChwID0gITApO1xuICAgICAgICAgIGsuaXNOdWxsICYmICF5KGEpICYmIDAgPCBuID8gcCA9ICFmLmNvbm5lY3ROdWxscyA6IGsuaXNOdWxsICYmICFhID8gcCA9ICEwIDogKDAgPT09IG4gfHwgcCA/IG4gPSBbXCJNXCIsIGsucGxvdFgsIGsucGxvdFldIDogZS5nZXRQb2ludFNwbGluZSA/IG4gPSBlLmdldFBvaW50U3BsaW5lKGIsIGssIG4pIDogZCA/IChuID0gMSA9PT0gZCA/IFtcIkxcIiwgdy5wbG90WCwgZ10gOiAyID09PSBkID8gW1wiTFwiLCAody5wbG90WCArIG0pIC8gMiwgdy5wbG90WSwgXCJMXCIsICh3LnBsb3RYICsgbSkgLyAyLCBnXSA6IFtcIkxcIiwgbSwgdy5wbG90WV0sIG4ucHVzaChcIkxcIiwgbSwgZykpIDogbiA9IFtcIkxcIiwgbSwgZ10sIGwucHVzaChrLngpLCBkICYmIChsLnB1c2goay54KSwgMiA9PT0gZCAmJiBsLnB1c2goay54KSksIGgucHVzaC5hcHBseShoLCBuKSwgcCA9ICExKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGgueE1hcCA9IGw7XG4gICAgICAgIHJldHVybiBlLmdyYXBoUGF0aCA9IGg7XG4gICAgICB9LFxuICAgICAgZHJhd0dyYXBoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcyxcbiAgICAgICAgICAgIGEgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBjID0gKHRoaXMuZ2FwcGVkUGF0aCB8fCB0aGlzLmdldEdyYXBoUGF0aCkuY2FsbCh0aGlzKSxcbiAgICAgICAgICAgIGUgPSB0aGlzLmNoYXJ0LnN0eWxlZE1vZGUsXG4gICAgICAgICAgICBmID0gW1tcImdyYXBoXCIsIFwiaGlnaGNoYXJ0cy1ncmFwaFwiXV07XG4gICAgICAgIGUgfHwgZlswXS5wdXNoKGEubGluZUNvbG9yIHx8IHRoaXMuY29sb3IgfHwgXCIjY2NjY2NjXCIsIGEuZGFzaFN0eWxlKTtcbiAgICAgICAgZiA9IGIuZ2V0Wm9uZXNHcmFwaHMoZik7XG4gICAgICAgIGYuZm9yRWFjaChmdW5jdGlvbiAoZiwgZCkge1xuICAgICAgICAgIHZhciBrID0gZlswXSxcbiAgICAgICAgICAgICAgaCA9IGJba10sXG4gICAgICAgICAgICAgIGwgPSBoID8gXCJhbmltYXRlXCIgOiBcImF0dHJcIjtcbiAgICAgICAgICBoID8gKGguZW5kWCA9IGIucHJldmVudEdyYXBoQW5pbWF0aW9uID8gbnVsbCA6IGMueE1hcCwgaC5hbmltYXRlKHtcbiAgICAgICAgICAgIGQ6IGNcbiAgICAgICAgICB9KSkgOiBjLmxlbmd0aCAmJiAoYltrXSA9IGggPSBiLmNoYXJ0LnJlbmRlcmVyLnBhdGgoYykuYWRkQ2xhc3MoZlsxXSkuYXR0cih7XG4gICAgICAgICAgICB6SW5kZXg6IDFcbiAgICAgICAgICB9KS5hZGQoYi5ncm91cCkpO1xuICAgICAgICAgIGggJiYgIWUgJiYgKGsgPSB7XG4gICAgICAgICAgICBzdHJva2U6IGZbMl0sXG4gICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBhLmxpbmVXaWR0aCxcbiAgICAgICAgICAgIGZpbGw6IGIuZmlsbEdyYXBoICYmIGIuY29sb3IgfHwgXCJub25lXCJcbiAgICAgICAgICB9LCBmWzNdID8gay5kYXNoc3R5bGUgPSBmWzNdIDogXCJzcXVhcmVcIiAhPT0gYS5saW5lY2FwICYmIChrW1wic3Ryb2tlLWxpbmVjYXBcIl0gPSBrW1wic3Ryb2tlLWxpbmVqb2luXCJdID0gXCJyb3VuZFwiKSwgaFtsXShrKS5zaGFkb3coMiA+IGQgJiYgYS5zaGFkb3cpKTtcbiAgICAgICAgICBoICYmIChoLnN0YXJ0WCA9IGMueE1hcCwgaC5pc0FyZWEgPSBjLmlzQXJlYSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdldFpvbmVzR3JhcGhzOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB0aGlzLnpvbmVzLmZvckVhY2goZnVuY3Rpb24gKGIsIGMpIHtcbiAgICAgICAgICBjID0gW1wiem9uZS1ncmFwaC1cIiArIGMsIFwiaGlnaGNoYXJ0cy1ncmFwaCBoaWdoY2hhcnRzLXpvbmUtZ3JhcGgtXCIgKyBjICsgXCIgXCIgKyAoYi5jbGFzc05hbWUgfHwgXCJcIildO1xuICAgICAgICAgIHRoaXMuY2hhcnQuc3R5bGVkTW9kZSB8fCBjLnB1c2goYi5jb2xvciB8fCB0aGlzLmNvbG9yLCBiLmRhc2hTdHlsZSB8fCB0aGlzLm9wdGlvbnMuZGFzaFN0eWxlKTtcbiAgICAgICAgICBhLnB1c2goYyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sXG4gICAgICBhcHBseVpvbmVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIGMgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZSA9IGMucmVuZGVyZXIsXG4gICAgICAgICAgICBmID0gdGhpcy56b25lcyxcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgaCA9IHRoaXMuY2xpcHMgfHwgW10sXG4gICAgICAgICAgICBwLFxuICAgICAgICAgICAgbiA9IHRoaXMuZ3JhcGgsXG4gICAgICAgICAgICBnID0gdGhpcy5hcmVhLFxuICAgICAgICAgICAgdyA9IE1hdGgubWF4KGMuY2hhcnRXaWR0aCwgYy5jaGFydEhlaWdodCksXG4gICAgICAgICAgICB2ID0gdGhpc1sodGhpcy56b25lQXhpcyB8fCBcInlcIikgKyBcIkF4aXNcIl0sXG4gICAgICAgICAgICBxID0gYy5pbnZlcnRlZCxcbiAgICAgICAgICAgIHQsXG4gICAgICAgICAgICBCLFxuICAgICAgICAgICAgeixcbiAgICAgICAgICAgIHkgPSAhMTtcblxuICAgICAgICBpZiAoZi5sZW5ndGggJiYgKG4gfHwgZykgJiYgdiAmJiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2Ygdi5taW4pIHtcbiAgICAgICAgICB2YXIgSyA9IHYucmV2ZXJzZWQ7XG4gICAgICAgICAgdmFyIEwgPSB2Lmhvcml6O1xuICAgICAgICAgIG4gJiYgIXRoaXMuc2hvd0xpbmUgJiYgbi5oaWRlKCk7XG4gICAgICAgICAgZyAmJiBnLmhpZGUoKTtcbiAgICAgICAgICB2YXIgdSA9IHYuZ2V0RXh0cmVtZXMoKTtcbiAgICAgICAgICBmLmZvckVhY2goZnVuY3Rpb24gKGIsIGYpIHtcbiAgICAgICAgICAgIGQgPSBLID8gTCA/IGMucGxvdFdpZHRoIDogMCA6IEwgPyAwIDogdi50b1BpeGVscyh1Lm1pbikgfHwgMDtcbiAgICAgICAgICAgIGQgPSBHKGwoaywgZCksIDAsIHcpO1xuICAgICAgICAgICAgayA9IEcoTWF0aC5yb3VuZCh2LnRvUGl4ZWxzKGwoYi52YWx1ZSwgdS5tYXgpLCAhMCkgfHwgMCksIDAsIHcpO1xuICAgICAgICAgICAgeSAmJiAoZCA9IGsgPSB2LnRvUGl4ZWxzKHUubWF4KSk7XG4gICAgICAgICAgICB0ID0gTWF0aC5hYnMoZCAtIGspO1xuICAgICAgICAgICAgQiA9IE1hdGgubWluKGQsIGspO1xuICAgICAgICAgICAgeiA9IE1hdGgubWF4KGQsIGspO1xuICAgICAgICAgICAgdi5pc1hBeGlzID8gKHAgPSB7XG4gICAgICAgICAgICAgIHg6IHEgPyB6IDogQixcbiAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgd2lkdGg6IHQsXG4gICAgICAgICAgICAgIGhlaWdodDogd1xuICAgICAgICAgICAgfSwgTCB8fCAocC54ID0gYy5wbG90SGVpZ2h0IC0gcC54KSkgOiAocCA9IHtcbiAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgeTogcSA/IHogOiBCLFxuICAgICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgICAgaGVpZ2h0OiB0XG4gICAgICAgICAgICB9LCBMICYmIChwLnkgPSBjLnBsb3RXaWR0aCAtIHAueSkpO1xuICAgICAgICAgICAgcSAmJiBlLmlzVk1MICYmIChwID0gdi5pc1hBeGlzID8ge1xuICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICB5OiBLID8gQiA6IHosXG4gICAgICAgICAgICAgIGhlaWdodDogcC53aWR0aCxcbiAgICAgICAgICAgICAgd2lkdGg6IGMuY2hhcnRXaWR0aFxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgeDogcC55IC0gYy5wbG90TGVmdCAtIGMuc3BhY2luZ0JveC54LFxuICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICB3aWR0aDogcC5oZWlnaHQsXG4gICAgICAgICAgICAgIGhlaWdodDogYy5jaGFydEhlaWdodFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoW2ZdID8gaFtmXS5hbmltYXRlKHApIDogaFtmXSA9IGUuY2xpcFJlY3QocCk7XG4gICAgICAgICAgICBuICYmIGFbXCJ6b25lLWdyYXBoLVwiICsgZl0uY2xpcChoW2ZdKTtcbiAgICAgICAgICAgIGcgJiYgYVtcInpvbmUtYXJlYS1cIiArIGZdLmNsaXAoaFtmXSk7XG4gICAgICAgICAgICB5ID0gYi52YWx1ZSA+IHUubWF4O1xuICAgICAgICAgICAgYS5yZXNldFpvbmVzICYmIDAgPT09IGsgJiYgKGsgPSB2b2lkIDApO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuY2xpcHMgPSBoO1xuICAgICAgICB9IGVsc2UgYS52aXNpYmxlICYmIChuICYmIG4uc2hvdyghMCksIGcgJiYgZy5zaG93KCEwKSk7XG4gICAgICB9LFxuICAgICAgaW52ZXJ0R3JvdXBzOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICBmdW5jdGlvbiBiKCkge1xuICAgICAgICAgIFtcImdyb3VwXCIsIFwibWFya2VyR3JvdXBcIl0uZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgY1tiXSAmJiAoZS5yZW5kZXJlci5pc1ZNTCAmJiBjW2JdLmF0dHIoe1xuICAgICAgICAgICAgICB3aWR0aDogYy55QXhpcy5sZW4sXG4gICAgICAgICAgICAgIGhlaWdodDogYy54QXhpcy5sZW5cbiAgICAgICAgICAgIH0pLCBjW2JdLndpZHRoID0gYy55QXhpcy5sZW4sIGNbYl0uaGVpZ2h0ID0gYy54QXhpcy5sZW4sIGNbYl0uaW52ZXJ0KGMuaXNSYWRpYWxTZXJpZXMgPyAhMSA6IGEpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0gdGhpcyxcbiAgICAgICAgICAgIGUgPSBjLmNoYXJ0O1xuICAgICAgICBjLnhBeGlzICYmIChjLmV2ZW50c1RvVW5iaW5kLnB1c2goSShlLCBcInJlc2l6ZVwiLCBiKSksIGIoKSwgYy5pbnZlcnRHcm91cHMgPSBiKTtcbiAgICAgIH0sXG4gICAgICBwbG90R3JvdXA6IGZ1bmN0aW9uIChhLCBjLCBlLCBmLCBkKSB7XG4gICAgICAgIHZhciBiID0gdGhpc1thXSxcbiAgICAgICAgICAgIGsgPSAhYjtcbiAgICAgICAgayAmJiAodGhpc1thXSA9IGIgPSB0aGlzLmNoYXJ0LnJlbmRlcmVyLmcoKS5hdHRyKHtcbiAgICAgICAgICB6SW5kZXg6IGYgfHwgLjFcbiAgICAgICAgfSkuYWRkKGQpKTtcbiAgICAgICAgYi5hZGRDbGFzcyhcImhpZ2hjaGFydHMtXCIgKyBjICsgXCIgaGlnaGNoYXJ0cy1zZXJpZXMtXCIgKyB0aGlzLmluZGV4ICsgXCIgaGlnaGNoYXJ0cy1cIiArIHRoaXMudHlwZSArIFwiLXNlcmllcyBcIiArICh5KHRoaXMuY29sb3JJbmRleCkgPyBcImhpZ2hjaGFydHMtY29sb3ItXCIgKyB0aGlzLmNvbG9ySW5kZXggKyBcIiBcIiA6IFwiXCIpICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgfHwgXCJcIikgKyAoYi5oYXNDbGFzcyhcImhpZ2hjaGFydHMtdHJhY2tlclwiKSA/IFwiIGhpZ2hjaGFydHMtdHJhY2tlclwiIDogXCJcIiksICEwKTtcbiAgICAgICAgYi5hdHRyKHtcbiAgICAgICAgICB2aXNpYmlsaXR5OiBlXG4gICAgICAgIH0pW2sgPyBcImF0dHJcIiA6IFwiYW5pbWF0ZVwiXSh0aGlzLmdldFBsb3RCb3goKSk7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSxcbiAgICAgIGdldFBsb3RCb3g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgYyA9IHRoaXMueEF4aXMsXG4gICAgICAgICAgICBlID0gdGhpcy55QXhpcztcbiAgICAgICAgYS5pbnZlcnRlZCAmJiAoYyA9IGUsIGUgPSB0aGlzLnhBeGlzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmFuc2xhdGVYOiBjID8gYy5sZWZ0IDogYS5wbG90TGVmdCxcbiAgICAgICAgICB0cmFuc2xhdGVZOiBlID8gZS50b3AgOiBhLnBsb3RUb3AsXG4gICAgICAgICAgc2NhbGVYOiAxLFxuICAgICAgICAgIHNjYWxlWTogMVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUV2ZW50czogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgYSA/IHRoaXMuZXZlbnRzVG9VbmJpbmQubGVuZ3RoICYmICh0aGlzLmV2ZW50c1RvVW5iaW5kLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhKCk7XG4gICAgICAgIH0pLCB0aGlzLmV2ZW50c1RvVW5iaW5kLmxlbmd0aCA9IDApIDogdih0aGlzKTtcbiAgICAgIH0sXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgYyA9IGEuY2hhcnQsXG4gICAgICAgICAgICBlID0gYS5vcHRpb25zLFxuICAgICAgICAgICAgZiA9ICFhLmZpbmlzaGVkQW5pbWF0aW5nICYmIGMucmVuZGVyZXIuaXNTVkcgJiYgTShlLmFuaW1hdGlvbikuZHVyYXRpb24sXG4gICAgICAgICAgICBkID0gYS52aXNpYmxlID8gXCJpbmhlcml0XCIgOiBcImhpZGRlblwiLFxuICAgICAgICAgICAgayA9IGUuekluZGV4LFxuICAgICAgICAgICAgaCA9IGEuaGFzUmVuZGVyZWQsXG4gICAgICAgICAgICBsID0gYy5zZXJpZXNHcm91cCxcbiAgICAgICAgICAgIHAgPSBjLmludmVydGVkO1xuICAgICAgICBxKHRoaXMsIFwicmVuZGVyXCIpO1xuICAgICAgICB2YXIgbiA9IGEucGxvdEdyb3VwKFwiZ3JvdXBcIiwgXCJzZXJpZXNcIiwgZCwgaywgbCk7XG4gICAgICAgIGEubWFya2VyR3JvdXAgPSBhLnBsb3RHcm91cChcIm1hcmtlckdyb3VwXCIsIFwibWFya2Vyc1wiLCBkLCBrLCBsKTtcbiAgICAgICAgZiAmJiBhLmFuaW1hdGUgJiYgYS5hbmltYXRlKCEwKTtcbiAgICAgICAgbi5pbnZlcnRlZCA9IGEuaXNDYXJ0ZXNpYW4gfHwgYS5pbnZlcnRhYmxlID8gcCA6ICExO1xuICAgICAgICBhLmRyYXdHcmFwaCAmJiAoYS5kcmF3R3JhcGgoKSwgYS5hcHBseVpvbmVzKCkpO1xuICAgICAgICBhLnZpc2libGUgJiYgYS5kcmF3UG9pbnRzKCk7XG4gICAgICAgIGEuZHJhd0RhdGFMYWJlbHMgJiYgYS5kcmF3RGF0YUxhYmVscygpO1xuICAgICAgICBhLnJlZHJhd1BvaW50cyAmJiBhLnJlZHJhd1BvaW50cygpO1xuICAgICAgICBhLmRyYXdUcmFja2VyICYmICExICE9PSBhLm9wdGlvbnMuZW5hYmxlTW91c2VUcmFja2luZyAmJiBhLmRyYXdUcmFja2VyKCk7XG4gICAgICAgIGEuaW52ZXJ0R3JvdXBzKHApO1xuICAgICAgICAhMSA9PT0gZS5jbGlwIHx8IGEuc2hhcmVkQ2xpcEtleSB8fCBoIHx8IG4uY2xpcChjLmNsaXBSZWN0KTtcbiAgICAgICAgZiAmJiBhLmFuaW1hdGUgJiYgYS5hbmltYXRlKCk7XG4gICAgICAgIGggfHwgKGEuYW5pbWF0aW9uVGltZW91dCA9IEIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGEuYWZ0ZXJBbmltYXRlKCk7XG4gICAgICAgIH0sIGYgfHwgMCkpO1xuICAgICAgICBhLmlzRGlydHkgPSAhMTtcbiAgICAgICAgYS5oYXNSZW5kZXJlZCA9ICEwO1xuICAgICAgICBxKGEsIFwiYWZ0ZXJSZW5kZXJcIik7XG4gICAgICB9LFxuICAgICAgcmVkcmF3OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGMgPSB0aGlzLmlzRGlydHkgfHwgdGhpcy5pc0RpcnR5RGF0YSxcbiAgICAgICAgICAgIGUgPSB0aGlzLmdyb3VwLFxuICAgICAgICAgICAgZiA9IHRoaXMueEF4aXMsXG4gICAgICAgICAgICBkID0gdGhpcy55QXhpcztcbiAgICAgICAgZSAmJiAoYS5pbnZlcnRlZCAmJiBlLmF0dHIoe1xuICAgICAgICAgIHdpZHRoOiBhLnBsb3RXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGEucGxvdEhlaWdodFxuICAgICAgICB9KSwgZS5hbmltYXRlKHtcbiAgICAgICAgICB0cmFuc2xhdGVYOiBsKGYgJiYgZi5sZWZ0LCBhLnBsb3RMZWZ0KSxcbiAgICAgICAgICB0cmFuc2xhdGVZOiBsKGQgJiYgZC50b3AsIGEucGxvdFRvcClcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZSgpO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICBjICYmIGRlbGV0ZSB0aGlzLmtkVHJlZTtcbiAgICAgIH0sXG4gICAgICBrZEF4aXNBcnJheTogW1wiY2xpZW50WFwiLCBcInBsb3RZXCJdLFxuICAgICAgc2VhcmNoUG9pbnQ6IGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy54QXhpcyxcbiAgICAgICAgICAgIGUgPSB0aGlzLnlBeGlzLFxuICAgICAgICAgICAgZiA9IHRoaXMuY2hhcnQuaW52ZXJ0ZWQ7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaEtEVHJlZSh7XG4gICAgICAgICAgY2xpZW50WDogZiA/IGIubGVuIC0gYS5jaGFydFkgKyBiLnBvcyA6IGEuY2hhcnRYIC0gYi5wb3MsXG4gICAgICAgICAgcGxvdFk6IGYgPyBlLmxlbiAtIGEuY2hhcnRYICsgZS5wb3MgOiBhLmNoYXJ0WSAtIGUucG9zXG4gICAgICAgIH0sIGMsIGEpO1xuICAgICAgfSxcbiAgICAgIGJ1aWxkS0RUcmVlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICBmdW5jdGlvbiBiKGEsIGUsIGYpIHtcbiAgICAgICAgICB2YXIgZDtcblxuICAgICAgICAgIGlmIChkID0gYSAmJiBhLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGsgPSBjLmtkQXhpc0FycmF5W2UgJSBmXTtcbiAgICAgICAgICAgIGEuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICByZXR1cm4gYVtrXSAtIGJba107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGQgPSBNYXRoLmZsb29yKGQgLyAyKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHBvaW50OiBhW2RdLFxuICAgICAgICAgICAgICBsZWZ0OiBiKGEuc2xpY2UoMCwgZCksIGUgKyAxLCBmKSxcbiAgICAgICAgICAgICAgcmlnaHQ6IGIoYS5zbGljZShkICsgMSksIGUgKyAxLCBmKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJ1aWxkaW5nS2RUcmVlID0gITA7XG4gICAgICAgIHZhciBjID0gdGhpcyxcbiAgICAgICAgICAgIGUgPSAtMSA8IGMub3B0aW9ucy5maW5kTmVhcmVzdFBvaW50QnkuaW5kZXhPZihcInlcIikgPyAyIDogMTtcbiAgICAgICAgZGVsZXRlIGMua2RUcmVlO1xuICAgICAgICBCKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjLmtkVHJlZSA9IGIoYy5nZXRWYWxpZFBvaW50cyhudWxsLCAhYy5kaXJlY3RUb3VjaCksIGUsIGUpO1xuICAgICAgICAgIGMuYnVpbGRpbmdLZFRyZWUgPSAhMTtcbiAgICAgICAgfSwgYy5vcHRpb25zLmtkTm93IHx8IGEgJiYgXCJ0b3VjaHN0YXJ0XCIgPT09IGEudHlwZSA/IDAgOiAxKTtcbiAgICAgIH0sXG4gICAgICBzZWFyY2hLRFRyZWU6IGZ1bmN0aW9uIChhLCBjLCBlKSB7XG4gICAgICAgIGZ1bmN0aW9uIGIoYSwgYywgZSwgbCkge1xuICAgICAgICAgIHZhciBwID0gYy5wb2ludCxcbiAgICAgICAgICAgICAgbiA9IGYua2RBeGlzQXJyYXlbZSAlIGxdLFxuICAgICAgICAgICAgICBnID0gcDtcbiAgICAgICAgICB2YXIgbSA9IHkoYVtkXSkgJiYgeShwW2RdKSA/IE1hdGgucG93KGFbZF0gLSBwW2RdLCAyKSA6IG51bGw7XG4gICAgICAgICAgdmFyIHcgPSB5KGFba10pICYmIHkocFtrXSkgPyBNYXRoLnBvdyhhW2tdIC0gcFtrXSwgMikgOiBudWxsO1xuICAgICAgICAgIHcgPSAobSB8fCAwKSArICh3IHx8IDApO1xuICAgICAgICAgIHAuZGlzdCA9IHkodykgPyBNYXRoLnNxcnQodykgOiBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgIHAuZGlzdFggPSB5KG0pID8gTWF0aC5zcXJ0KG0pIDogTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICBuID0gYVtuXSAtIHBbbl07XG4gICAgICAgICAgdyA9IDAgPiBuID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XG4gICAgICAgICAgbSA9IDAgPiBuID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XG4gICAgICAgICAgY1t3XSAmJiAodyA9IGIoYSwgY1t3XSwgZSArIDEsIGwpLCBnID0gd1toXSA8IGdbaF0gPyB3IDogcCk7XG4gICAgICAgICAgY1ttXSAmJiBNYXRoLnNxcnQobiAqIG4pIDwgZ1toXSAmJiAoYSA9IGIoYSwgY1ttXSwgZSArIDEsIGwpLCBnID0gYVtoXSA8IGdbaF0gPyBhIDogZyk7XG4gICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZiA9IHRoaXMsXG4gICAgICAgICAgICBkID0gdGhpcy5rZEF4aXNBcnJheVswXSxcbiAgICAgICAgICAgIGsgPSB0aGlzLmtkQXhpc0FycmF5WzFdLFxuICAgICAgICAgICAgaCA9IGMgPyBcImRpc3RYXCIgOiBcImRpc3RcIjtcbiAgICAgICAgYyA9IC0xIDwgZi5vcHRpb25zLmZpbmROZWFyZXN0UG9pbnRCeS5pbmRleE9mKFwieVwiKSA/IDIgOiAxO1xuICAgICAgICB0aGlzLmtkVHJlZSB8fCB0aGlzLmJ1aWxkaW5nS2RUcmVlIHx8IHRoaXMuYnVpbGRLRFRyZWUoZSk7XG4gICAgICAgIGlmICh0aGlzLmtkVHJlZSkgcmV0dXJuIGIoYSwgdGhpcy5rZFRyZWUsIGMsIGMpO1xuICAgICAgfSxcbiAgICAgIHBvaW50UGxhY2VtZW50VG9YVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBjID0gYS5wb2ludFJhbmdlLFxuICAgICAgICAgICAgZSA9IHRoaXMueEF4aXM7XG4gICAgICAgIGEgPSBhLnBvaW50UGxhY2VtZW50O1xuICAgICAgICBcImJldHdlZW5cIiA9PT0gYSAmJiAoYSA9IGUucmV2ZXJzZWQgPyAtLjUgOiAuNSk7XG4gICAgICAgIHJldHVybiBrKGEpID8gYSAqIGwoYywgZS5wb2ludFJhbmdlKSA6IDA7XG4gICAgICB9LFxuICAgICAgaXNQb2ludEluc2lkZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBhLnBsb3RZICYmIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBhLnBsb3RYICYmIDAgPD0gYS5wbG90WSAmJiBhLnBsb3RZIDw9IHRoaXMueUF4aXMubGVuICYmIDAgPD0gYS5wbG90WCAmJiBhLnBsb3RYIDw9IHRoaXMueEF4aXMubGVuO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFwiXCI7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvU3RhY2tpbmcuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcpIHtcbiAgICB2YXIgciA9IGcuY29ycmVjdEZsb2F0LFxuICAgICAgICB1ID0gZy5kZWZpbmVkLFxuICAgICAgICBJID0gZy5kZXN0cm95T2JqZWN0UHJvcGVydGllcyxcbiAgICAgICAgTSA9IGcuZm9ybWF0LFxuICAgICAgICBFID0gZy5vYmplY3RFYWNoLFxuICAgICAgICBBID0gZy5waWNrO1xuICAgIGcgPSBkLkF4aXM7XG4gICAgdmFyIEcgPSBkLkNoYXJ0LFxuICAgICAgICBKID0gZC5TZXJpZXM7XG5cbiAgICBkLlN0YWNrSXRlbSA9IGZ1bmN0aW9uIChkLCBnLCB1LCBoLCByKSB7XG4gICAgICB2YXIgcSA9IGQuY2hhcnQuaW52ZXJ0ZWQ7XG4gICAgICB0aGlzLmF4aXMgPSBkO1xuICAgICAgdGhpcy5pc05lZ2F0aXZlID0gdTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IGcgPSBnIHx8IHt9O1xuICAgICAgdGhpcy54ID0gaDtcbiAgICAgIHRoaXMudG90YWwgPSBudWxsO1xuICAgICAgdGhpcy5wb2ludHMgPSB7fTtcbiAgICAgIHRoaXMuc3RhY2sgPSByO1xuICAgICAgdGhpcy5yaWdodENsaWZmID0gdGhpcy5sZWZ0Q2xpZmYgPSAwO1xuICAgICAgdGhpcy5hbGlnbk9wdGlvbnMgPSB7XG4gICAgICAgIGFsaWduOiBnLmFsaWduIHx8IChxID8gdSA/IFwibGVmdFwiIDogXCJyaWdodFwiIDogXCJjZW50ZXJcIiksXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IGcudmVydGljYWxBbGlnbiB8fCAocSA/IFwibWlkZGxlXCIgOiB1ID8gXCJib3R0b21cIiA6IFwidG9wXCIpLFxuICAgICAgICB5OiBnLnksXG4gICAgICAgIHg6IGcueFxuICAgICAgfTtcbiAgICAgIHRoaXMudGV4dEFsaWduID0gZy50ZXh0QWxpZ24gfHwgKHEgPyB1ID8gXCJyaWdodFwiIDogXCJsZWZ0XCIgOiBcImNlbnRlclwiKTtcbiAgICB9O1xuXG4gICAgZC5TdGFja0l0ZW0ucHJvdG90eXBlID0ge1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBJKHRoaXMsIHRoaXMuYXhpcyk7XG4gICAgICB9LFxuICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgZyA9IHRoaXMuYXhpcy5jaGFydCxcbiAgICAgICAgICAgIHkgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBoID0geS5mb3JtYXQ7XG4gICAgICAgIGggPSBoID8gTShoLCB0aGlzLCBnKSA6IHkuZm9ybWF0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubGFiZWwgPyB0aGlzLmxhYmVsLmF0dHIoe1xuICAgICAgICAgIHRleHQ6IGgsXG4gICAgICAgICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIlxuICAgICAgICB9KSA6ICh0aGlzLmxhYmVsID0gZy5yZW5kZXJlci5sYWJlbChoLCBudWxsLCBudWxsLCB5LnNoYXBlLCBudWxsLCBudWxsLCB5LnVzZUhUTUwsICExLCBcInN0YWNrLWxhYmVsc1wiKSwgaCA9IHtcbiAgICAgICAgICB0ZXh0OiBoLFxuICAgICAgICAgIHJvdGF0aW9uOiB5LnJvdGF0aW9uLFxuICAgICAgICAgIHBhZGRpbmc6IEEoeS5wYWRkaW5nLCA1KSxcbiAgICAgICAgICB2aXNpYmlsaXR5OiBcImhpZGRlblwiXG4gICAgICAgIH0sIHRoaXMubGFiZWwuYXR0cihoKSwgZy5zdHlsZWRNb2RlIHx8IHRoaXMubGFiZWwuY3NzKHkuc3R5bGUpLCB0aGlzLmxhYmVsLmFkZGVkIHx8IHRoaXMubGFiZWwuYWRkKGQpKTtcbiAgICAgICAgdGhpcy5sYWJlbC5sYWJlbHJhbmsgPSBnLnBsb3RIZWlnaHQ7XG4gICAgICB9LFxuICAgICAgc2V0T2Zmc2V0OiBmdW5jdGlvbiAoZCwgZywgciwgaCwgTikge1xuICAgICAgICB2YXIgcSA9IHRoaXMuYXhpcyxcbiAgICAgICAgICAgIHQgPSBxLmNoYXJ0O1xuICAgICAgICBoID0gcS50cmFuc2xhdGUocS51c2VQZXJjZW50YWdlID8gMTAwIDogaCA/IGggOiB0aGlzLnRvdGFsLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgciA9IHEudHJhbnNsYXRlKHIgPyByIDogMCk7XG4gICAgICAgIHIgPSB1KGgpICYmIE1hdGguYWJzKGggLSByKTtcbiAgICAgICAgZCA9IEEoTiwgdC54QXhpc1swXS50cmFuc2xhdGUodGhpcy54KSkgKyBkO1xuICAgICAgICBxID0gdShoKSAmJiB0aGlzLmdldFN0YWNrQm94KHQsIHRoaXMsIGQsIGgsIGcsIHIsIHEpO1xuICAgICAgICBnID0gdGhpcy5sYWJlbDtcbiAgICAgICAgciA9IHRoaXMuaXNOZWdhdGl2ZTtcbiAgICAgICAgZCA9IFwianVzdGlmeVwiID09PSBBKHRoaXMub3B0aW9ucy5vdmVyZmxvdywgXCJqdXN0aWZ5XCIpO1xuICAgICAgICB2YXIgZSA9IHRoaXMudGV4dEFsaWduO1xuICAgICAgICBnICYmIHEgJiYgKE4gPSBnLmdldEJCb3goKSwgaCA9IGcucGFkZGluZywgZSA9IFwibGVmdFwiID09PSBlID8gdC5pbnZlcnRlZCA/IC1oIDogaCA6IFwicmlnaHRcIiA9PT0gZSA/IE4ud2lkdGggOiB0LmludmVydGVkICYmIFwiY2VudGVyXCIgPT09IGUgPyBOLndpZHRoIC8gMiA6IHQuaW52ZXJ0ZWQgPyByID8gTi53aWR0aCArIGggOiAtaCA6IE4ud2lkdGggLyAyLCByID0gdC5pbnZlcnRlZCA/IE4uaGVpZ2h0IC8gMiA6IHIgPyAtaCA6IE4uaGVpZ2h0LCB0aGlzLmFsaWduT3B0aW9ucy54ID0gQSh0aGlzLm9wdGlvbnMueCwgMCksIHRoaXMuYWxpZ25PcHRpb25zLnkgPSBBKHRoaXMub3B0aW9ucy55LCAwKSwgcS54IC09IGUsIHEueSAtPSByLCBnLmFsaWduKHRoaXMuYWxpZ25PcHRpb25zLCBudWxsLCBxKSwgdC5pc0luc2lkZVBsb3QoZy5hbGlnbkF0dHIueCArIGUgLSB0aGlzLmFsaWduT3B0aW9ucy54LCBnLmFsaWduQXR0ci55ICsgciAtIHRoaXMuYWxpZ25PcHRpb25zLnkpID8gZy5zaG93KCkgOiAoZy5hbGlnbkF0dHIueSA9IC05OTk5LCBkID0gITEpLCBkICYmIEoucHJvdG90eXBlLmp1c3RpZnlEYXRhTGFiZWwuY2FsbCh0aGlzLmF4aXMsIGcsIHRoaXMuYWxpZ25PcHRpb25zLCBnLmFsaWduQXR0ciwgTiwgcSksIGcuYXR0cih7XG4gICAgICAgICAgeDogZy5hbGlnbkF0dHIueCxcbiAgICAgICAgICB5OiBnLmFsaWduQXR0ci55XG4gICAgICAgIH0pLCBBKCFkICYmIHRoaXMub3B0aW9ucy5jcm9wLCAhMCkgJiYgKCh0ID0gdC5pc0luc2lkZVBsb3QoZy54IC0gaCArIGcud2lkdGgsIGcueSkgJiYgdC5pc0luc2lkZVBsb3QoZy54ICsgaCwgZy55KSkgfHwgZy5oaWRlKCkpKTtcbiAgICAgIH0sXG4gICAgICBnZXRTdGFja0JveDogZnVuY3Rpb24gKGQsIGcsIHIsIGgsIHUsIHEsIEEpIHtcbiAgICAgICAgdmFyIGUgPSBnLmF4aXMucmV2ZXJzZWQsXG4gICAgICAgICAgICBjID0gZC5pbnZlcnRlZDtcbiAgICAgICAgZCA9IEEuaGVpZ2h0ICsgQS5wb3MgLSAoYyA/IGQucGxvdExlZnQgOiBkLnBsb3RUb3ApO1xuICAgICAgICBnID0gZy5pc05lZ2F0aXZlICYmICFlIHx8ICFnLmlzTmVnYXRpdmUgJiYgZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBjID8gZyA/IGggOiBoIC0gcSA6IHIsXG4gICAgICAgICAgeTogYyA/IGQgLSByIC0gdSA6IGcgPyBkIC0gaCAtIHEgOiBkIC0gaCxcbiAgICAgICAgICB3aWR0aDogYyA/IHEgOiB1LFxuICAgICAgICAgIGhlaWdodDogYyA/IHUgOiBxXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIEcucHJvdG90eXBlLmdldFN0YWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICBnID0gZC5pbnZlcnRlZDtcbiAgICAgIGQueUF4aXMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICBkLnN0YWNrcyAmJiBkLmhhc1Zpc2libGVTZXJpZXMgJiYgKGQub2xkU3RhY2tzID0gZC5zdGFja3MpO1xuICAgICAgfSk7XG4gICAgICBkLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBoID0gdC54QXhpcyAmJiB0LnhBeGlzLm9wdGlvbnMgfHwge307XG4gICAgICAgICF0Lm9wdGlvbnMuc3RhY2tpbmcgfHwgITAgIT09IHQudmlzaWJsZSAmJiAhMSAhPT0gZC5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcyB8fCAodC5zdGFja0tleSA9IFt0LnR5cGUsIEEodC5vcHRpb25zLnN0YWNrLCBcIlwiKSwgZyA/IGgudG9wIDogaC5sZWZ0LCBnID8gaC5oZWlnaHQgOiBoLndpZHRoXS5qb2luKCkpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGcucHJvdG90eXBlLmJ1aWxkU3RhY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGcgPSB0aGlzLnNlcmllcyxcbiAgICAgICAgICB0ID0gQSh0aGlzLm9wdGlvbnMucmV2ZXJzZWRTdGFja3MsICEwKSxcbiAgICAgICAgICByID0gZy5sZW5ndGgsXG4gICAgICAgICAgaDtcblxuICAgICAgaWYgKCF0aGlzLmlzWEF4aXMpIHtcbiAgICAgICAgdGhpcy51c2VQZXJjZW50YWdlID0gITE7XG5cbiAgICAgICAgZm9yIChoID0gcjsgaC0tOykge1xuICAgICAgICAgIHZhciB1ID0gZ1t0ID8gaCA6IHIgLSBoIC0gMV07XG4gICAgICAgICAgdS5zZXRTdGFja2VkUG9pbnRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGggPSAwOyBoIDwgcjsgaCsrKSBnW2hdLm1vZGlmeVN0YWNrcygpO1xuXG4gICAgICAgIGQuZmlyZUV2ZW50KHRoaXMsIFwiYWZ0ZXJCdWlsZFN0YWNrc1wiKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZy5wcm90b3R5cGUucmVuZGVyU3RhY2tUb3RhbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZCA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgZyA9IGQucmVuZGVyZXIsXG4gICAgICAgICAgciA9IHRoaXMuc3RhY2tzLFxuICAgICAgICAgIGggPSB0aGlzLnN0YWNrVG90YWxHcm91cDtcbiAgICAgIGggfHwgKHRoaXMuc3RhY2tUb3RhbEdyb3VwID0gaCA9IGcuZyhcInN0YWNrLWxhYmVsc1wiKS5hdHRyKHtcbiAgICAgICAgdmlzaWJpbGl0eTogXCJ2aXNpYmxlXCIsXG4gICAgICAgIHpJbmRleDogNlxuICAgICAgfSkuYWRkKCkpO1xuICAgICAgaC50cmFuc2xhdGUoZC5wbG90TGVmdCwgZC5wbG90VG9wKTtcbiAgICAgIEUociwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgRShkLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGQucmVuZGVyKGgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBnLnByb3RvdHlwZS5yZXNldFN0YWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICBnID0gZC5zdGFja3M7XG4gICAgICBkLmlzWEF4aXMgfHwgRShnLCBmdW5jdGlvbiAoZykge1xuICAgICAgICBFKGcsIGZ1bmN0aW9uIChoLCB0KSB7XG4gICAgICAgICAgaC50b3VjaGVkIDwgZC5zdGFja3NUb3VjaGVkID8gKGguZGVzdHJveSgpLCBkZWxldGUgZ1t0XSkgOiAoaC50b3RhbCA9IG51bGwsIGguY3VtdWxhdGl2ZSA9IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBnLnByb3RvdHlwZS5jbGVhblN0YWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5pc1hBeGlzKSB7XG4gICAgICAgIGlmICh0aGlzLm9sZFN0YWNrcykgdmFyIGQgPSB0aGlzLnN0YWNrcyA9IHRoaXMub2xkU3RhY2tzO1xuICAgICAgICBFKGQsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgRShkLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgZC5jdW11bGF0aXZlID0gZC50b3RhbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEoucHJvdG90eXBlLnNldFN0YWNrZWRQb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWNraW5nICYmICghMCA9PT0gdGhpcy52aXNpYmxlIHx8ICExID09PSB0aGlzLmNoYXJ0Lm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzKSkge1xuICAgICAgICB2YXIgZyA9IHRoaXMucHJvY2Vzc2VkWERhdGEsXG4gICAgICAgICAgICB0ID0gdGhpcy5wcm9jZXNzZWRZRGF0YSxcbiAgICAgICAgICAgIEQgPSBbXSxcbiAgICAgICAgICAgIGggPSB0Lmxlbmd0aCxcbiAgICAgICAgICAgIE4gPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBxID0gTi50aHJlc2hvbGQsXG4gICAgICAgICAgICBHID0gQShOLnN0YXJ0RnJvbVRocmVzaG9sZCAmJiBxLCAwKSxcbiAgICAgICAgICAgIGUgPSBOLnN0YWNrO1xuICAgICAgICBOID0gTi5zdGFja2luZztcbiAgICAgICAgdmFyIGMgPSB0aGlzLnN0YWNrS2V5LFxuICAgICAgICAgICAgayA9IFwiLVwiICsgYyxcbiAgICAgICAgICAgIG4gPSB0aGlzLm5lZ1N0YWNrcyxcbiAgICAgICAgICAgIGYgPSB0aGlzLnlBeGlzLFxuICAgICAgICAgICAgYSA9IGYuc3RhY2tzLFxuICAgICAgICAgICAgbCA9IGYub2xkU3RhY2tzLFxuICAgICAgICAgICAgdixcbiAgICAgICAgICAgIHo7XG4gICAgICAgIGYuc3RhY2tzVG91Y2hlZCArPSAxO1xuXG4gICAgICAgIGZvciAoeiA9IDA7IHogPCBoOyB6KyspIHtcbiAgICAgICAgICB2YXIgdyA9IGdbel07XG4gICAgICAgICAgdmFyIEIgPSB0W3pdO1xuICAgICAgICAgIHZhciBMID0gdGhpcy5nZXRTdGFja0luZGljYXRvcihMLCB3LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICB2YXIgUSA9IEwua2V5O1xuICAgICAgICAgIHZhciBIID0gKHYgPSBuICYmIEIgPCAoRyA/IDAgOiBxKSkgPyBrIDogYztcbiAgICAgICAgICBhW0hdIHx8IChhW0hdID0ge30pO1xuICAgICAgICAgIGFbSF1bd10gfHwgKGxbSF0gJiYgbFtIXVt3XSA/IChhW0hdW3ddID0gbFtIXVt3XSwgYVtIXVt3XS50b3RhbCA9IG51bGwpIDogYVtIXVt3XSA9IG5ldyBkLlN0YWNrSXRlbShmLCBmLm9wdGlvbnMuc3RhY2tMYWJlbHMsIHYsIHcsIGUpKTtcbiAgICAgICAgICBIID0gYVtIXVt3XTtcbiAgICAgICAgICBudWxsICE9PSBCID8gKEgucG9pbnRzW1FdID0gSC5wb2ludHNbdGhpcy5pbmRleF0gPSBbQShILmN1bXVsYXRpdmUsIEcpXSwgdShILmN1bXVsYXRpdmUpIHx8IChILmJhc2UgPSBRKSwgSC50b3VjaGVkID0gZi5zdGFja3NUb3VjaGVkLCAwIDwgTC5pbmRleCAmJiAhMSA9PT0gdGhpcy5zaW5nbGVTdGFja3MgJiYgKEgucG9pbnRzW1FdWzBdID0gSC5wb2ludHNbdGhpcy5pbmRleCArIFwiLFwiICsgdyArIFwiLDBcIl1bMF0pKSA6IEgucG9pbnRzW1FdID0gSC5wb2ludHNbdGhpcy5pbmRleF0gPSBudWxsO1xuICAgICAgICAgIFwicGVyY2VudFwiID09PSBOID8gKHYgPSB2ID8gYyA6IGssIG4gJiYgYVt2XSAmJiBhW3ZdW3ddID8gKHYgPSBhW3ZdW3ddLCBILnRvdGFsID0gdi50b3RhbCA9IE1hdGgubWF4KHYudG90YWwsIEgudG90YWwpICsgTWF0aC5hYnMoQikgfHwgMCkgOiBILnRvdGFsID0gcihILnRvdGFsICsgKE1hdGguYWJzKEIpIHx8IDApKSkgOiBILnRvdGFsID0gcihILnRvdGFsICsgKEIgfHwgMCkpO1xuICAgICAgICAgIEguY3VtdWxhdGl2ZSA9IEEoSC5jdW11bGF0aXZlLCBHKSArIChCIHx8IDApO1xuICAgICAgICAgIG51bGwgIT09IEIgJiYgKEgucG9pbnRzW1FdLnB1c2goSC5jdW11bGF0aXZlKSwgRFt6XSA9IEguY3VtdWxhdGl2ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBcInBlcmNlbnRcIiA9PT0gTiAmJiAoZi51c2VQZXJjZW50YWdlID0gITApO1xuICAgICAgICB0aGlzLnN0YWNrZWRZRGF0YSA9IEQ7XG4gICAgICAgIGYub2xkU3RhY2tzID0ge307XG4gICAgICB9XG4gICAgfTtcblxuICAgIEoucHJvdG90eXBlLm1vZGlmeVN0YWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICBnID0gZC5zdGFja0tleSxcbiAgICAgICAgICByID0gZC55QXhpcy5zdGFja3MsXG4gICAgICAgICAgaCA9IGQucHJvY2Vzc2VkWERhdGEsXG4gICAgICAgICAgdSxcbiAgICAgICAgICBxID0gZC5vcHRpb25zLnN0YWNraW5nO1xuICAgICAgZFtxICsgXCJTdGFja2VyXCJdICYmIFtnLCBcIi1cIiArIGddLmZvckVhY2goZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IGgubGVuZ3RoLCBjLCBrOyBlLS07KSBpZiAoYyA9IGhbZV0sIHUgPSBkLmdldFN0YWNrSW5kaWNhdG9yKHUsIGMsIGQuaW5kZXgsIGcpLCBrID0gKGMgPSByW2ddICYmIHJbZ11bY10pICYmIGMucG9pbnRzW3Uua2V5XSkgZFtxICsgXCJTdGFja2VyXCJdKGssIGMsIGUpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIEoucHJvdG90eXBlLnBlcmNlbnRTdGFja2VyID0gZnVuY3Rpb24gKGQsIGcsIHUpIHtcbiAgICAgIGcgPSBnLnRvdGFsID8gMTAwIC8gZy50b3RhbCA6IDA7XG4gICAgICBkWzBdID0gcihkWzBdICogZyk7XG4gICAgICBkWzFdID0gcihkWzFdICogZyk7XG4gICAgICB0aGlzLnN0YWNrZWRZRGF0YVt1XSA9IGRbMV07XG4gICAgfTtcblxuICAgIEoucHJvdG90eXBlLmdldFN0YWNrSW5kaWNhdG9yID0gZnVuY3Rpb24gKGQsIGcsIHIsIGgpIHtcbiAgICAgICF1KGQpIHx8IGQueCAhPT0gZyB8fCBoICYmIGQua2V5ICE9PSBoID8gZCA9IHtcbiAgICAgICAgeDogZyxcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIGtleTogaFxuICAgICAgfSA6IGQuaW5kZXgrKztcbiAgICAgIGQua2V5ID0gW3IsIGcsIGQuaW5kZXhdLmpvaW4oKTtcbiAgICAgIHJldHVybiBkO1xuICAgIH07XG4gIH0pO1xuICBTKHIsIFwicGFydHMvRHluYW1pY3MuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvUG9pbnQuanNcIl0sIHJbXCJwYXJ0cy9UaW1lLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcsIHIsIHUpIHtcbiAgICB2YXIgSSA9IHUuYWRkRXZlbnQsXG4gICAgICAgIE0gPSB1LmFuaW1hdGUsXG4gICAgICAgIEUgPSB1LmNyZWF0ZUVsZW1lbnQsXG4gICAgICAgIEEgPSB1LmNzcyxcbiAgICAgICAgRyA9IHUuZGVmaW5lZCxcbiAgICAgICAgSiA9IHUuZXJhc2UsXG4gICAgICAgIHkgPSB1LmVycm9yLFxuICAgICAgICB0ID0gdS5leHRlbmQsXG4gICAgICAgIEQgPSB1LmZpcmVFdmVudCxcbiAgICAgICAgaCA9IHUuaXNBcnJheSxcbiAgICAgICAgTiA9IHUuaXNOdW1iZXIsXG4gICAgICAgIHEgPSB1LmlzT2JqZWN0LFxuICAgICAgICBQID0gdS5pc1N0cmluZyxcbiAgICAgICAgZSA9IHUubWVyZ2UsXG4gICAgICAgIGMgPSB1Lm9iamVjdEVhY2gsXG4gICAgICAgIGsgPSB1LnBpY2ssXG4gICAgICAgIG4gPSB1LnJlbGF0aXZlTGVuZ3RoLFxuICAgICAgICBmID0gdS5zZXRBbmltYXRpb24sXG4gICAgICAgIGEgPSB1LnNwbGF0LFxuICAgICAgICBsID0gZC5BeGlzO1xuICAgIHUgPSBkLkNoYXJ0O1xuICAgIHZhciB2ID0gZC5TZXJpZXMsXG4gICAgICAgIHogPSBkLnNlcmllc1R5cGVzO1xuXG4gICAgZC5jbGVhblJlY3Vyc2l2ZWx5ID0gZnVuY3Rpb24gKGEsIGUpIHtcbiAgICAgIHZhciBmID0ge307XG4gICAgICBjKGEsIGZ1bmN0aW9uIChjLCBrKSB7XG4gICAgICAgIGlmIChxKGFba10sICEwKSAmJiAhYS5ub2RlVHlwZSAmJiBlW2tdKSBjID0gZC5jbGVhblJlY3Vyc2l2ZWx5KGFba10sIGVba10pLCBPYmplY3Qua2V5cyhjKS5sZW5ndGggJiYgKGZba10gPSBjKTtlbHNlIGlmIChxKGFba10pIHx8IGFba10gIT09IGVba10pIGZba10gPSBhW2tdO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZjtcbiAgICB9O1xuXG4gICAgdCh1LnByb3RvdHlwZSwge1xuICAgICAgYWRkU2VyaWVzOiBmdW5jdGlvbiAoYSwgYywgZSkge1xuICAgICAgICB2YXIgZixcbiAgICAgICAgICAgIGQgPSB0aGlzO1xuICAgICAgICBhICYmIChjID0gayhjLCAhMCksIEQoZCwgXCJhZGRTZXJpZXNcIiwge1xuICAgICAgICAgIG9wdGlvbnM6IGFcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGYgPSBkLmluaXRTZXJpZXMoYSk7XG4gICAgICAgICAgZC5pc0RpcnR5TGVnZW5kID0gITA7XG4gICAgICAgICAgZC5saW5rU2VyaWVzKCk7XG4gICAgICAgICAgZi5lbmFibGVkRGF0YVNvcnRpbmcgJiYgZi5zZXREYXRhKGEuZGF0YSwgITEpO1xuICAgICAgICAgIEQoZCwgXCJhZnRlckFkZFNlcmllc1wiLCB7XG4gICAgICAgICAgICBzZXJpZXM6IGZcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjICYmIGQucmVkcmF3KGUpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfSxcbiAgICAgIGFkZEF4aXM6IGZ1bmN0aW9uIChhLCBjLCBlLCBmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUF4aXMoYyA/IFwieEF4aXNcIiA6IFwieUF4aXNcIiwge1xuICAgICAgICAgIGF4aXM6IGEsXG4gICAgICAgICAgcmVkcmF3OiBlLFxuICAgICAgICAgIGFuaW1hdGlvbjogZlxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBhZGRDb2xvckF4aXM6IGZ1bmN0aW9uIChhLCBjLCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUF4aXMoXCJjb2xvckF4aXNcIiwge1xuICAgICAgICAgIGF4aXM6IGEsXG4gICAgICAgICAgcmVkcmF3OiBjLFxuICAgICAgICAgIGFuaW1hdGlvbjogZVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVBeGlzOiBmdW5jdGlvbiAoYywgZikge1xuICAgICAgICB2YXIgaCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGcgPSBcImNvbG9yQXhpc1wiID09PSBjLFxuICAgICAgICAgICAgbiA9IGYucmVkcmF3LFxuICAgICAgICAgICAgdyA9IGYuYW5pbWF0aW9uO1xuICAgICAgICBmID0gZShmLmF4aXMsIHtcbiAgICAgICAgICBpbmRleDogdGhpc1tjXS5sZW5ndGgsXG4gICAgICAgICAgaXNYOiBcInhBeGlzXCIgPT09IGNcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwID0gZyA/IG5ldyBkLkNvbG9yQXhpcyh0aGlzLCBmKSA6IG5ldyBsKHRoaXMsIGYpO1xuICAgICAgICBoW2NdID0gYShoW2NdIHx8IHt9KTtcbiAgICAgICAgaFtjXS5wdXNoKGYpO1xuICAgICAgICBnICYmICh0aGlzLmlzRGlydHlMZWdlbmQgPSAhMCwgdGhpcy5heGVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhLnNlcmllcyA9IFtdO1xuICAgICAgICB9KSwgdGhpcy5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEuYmluZEF4ZXMoKTtcbiAgICAgICAgICBhLmlzRGlydHlEYXRhID0gITA7XG4gICAgICAgIH0pKTtcbiAgICAgICAgayhuLCAhMCkgJiYgdGhpcy5yZWRyYXcodyk7XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfSxcbiAgICAgIHNob3dMb2FkaW5nOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYyA9IHRoaXMsXG4gICAgICAgICAgICBlID0gYy5vcHRpb25zLFxuICAgICAgICAgICAgZiA9IGMubG9hZGluZ0RpdixcbiAgICAgICAgICAgIGQgPSBlLmxvYWRpbmcsXG4gICAgICAgICAgICBoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGYgJiYgQShmLCB7XG4gICAgICAgICAgICBsZWZ0OiBjLnBsb3RMZWZ0ICsgXCJweFwiLFxuICAgICAgICAgICAgdG9wOiBjLnBsb3RUb3AgKyBcInB4XCIsXG4gICAgICAgICAgICB3aWR0aDogYy5wbG90V2lkdGggKyBcInB4XCIsXG4gICAgICAgICAgICBoZWlnaHQ6IGMucGxvdEhlaWdodCArIFwicHhcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYgfHwgKGMubG9hZGluZ0RpdiA9IGYgPSBFKFwiZGl2XCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiaGlnaGNoYXJ0cy1sb2FkaW5nIGhpZ2hjaGFydHMtbG9hZGluZy1oaWRkZW5cIlxuICAgICAgICB9LCBudWxsLCBjLmNvbnRhaW5lciksIGMubG9hZGluZ1NwYW4gPSBFKFwic3BhblwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImhpZ2hjaGFydHMtbG9hZGluZy1pbm5lclwiXG4gICAgICAgIH0sIG51bGwsIGYpLCBJKGMsIFwicmVkcmF3XCIsIGgpKTtcbiAgICAgICAgZi5jbGFzc05hbWUgPSBcImhpZ2hjaGFydHMtbG9hZGluZ1wiO1xuICAgICAgICBjLmxvYWRpbmdTcGFuLmlubmVySFRNTCA9IGsoYSwgZS5sYW5nLmxvYWRpbmcsIFwiXCIpO1xuICAgICAgICBjLnN0eWxlZE1vZGUgfHwgKEEoZiwgdChkLnN0eWxlLCB7XG4gICAgICAgICAgekluZGV4OiAxMFxuICAgICAgICB9KSksIEEoYy5sb2FkaW5nU3BhbiwgZC5sYWJlbFN0eWxlKSwgYy5sb2FkaW5nU2hvd24gfHwgKEEoZiwge1xuICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgZGlzcGxheTogXCJcIlxuICAgICAgICB9KSwgTShmLCB7XG4gICAgICAgICAgb3BhY2l0eTogZC5zdHlsZS5vcGFjaXR5IHx8IC41XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogZC5zaG93RHVyYXRpb24gfHwgMFxuICAgICAgICB9KSkpO1xuICAgICAgICBjLmxvYWRpbmdTaG93biA9ICEwO1xuICAgICAgICBoKCk7XG4gICAgICB9LFxuICAgICAgaGlkZUxvYWRpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBjID0gdGhpcy5sb2FkaW5nRGl2O1xuICAgICAgICBjICYmIChjLmNsYXNzTmFtZSA9IFwiaGlnaGNoYXJ0cy1sb2FkaW5nIGhpZ2hjaGFydHMtbG9hZGluZy1oaWRkZW5cIiwgdGhpcy5zdHlsZWRNb2RlIHx8IE0oYywge1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiBhLmxvYWRpbmcuaGlkZUR1cmF0aW9uIHx8IDEwMCxcbiAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgQShjLCB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5sb2FkaW5nU2hvd24gPSAhMTtcbiAgICAgIH0sXG4gICAgICBwcm9wc1JlcXVpcmVEaXJ0eUJveDogXCJiYWNrZ3JvdW5kQ29sb3IgYm9yZGVyQ29sb3IgYm9yZGVyV2lkdGggYm9yZGVyUmFkaXVzIHBsb3RCYWNrZ3JvdW5kQ29sb3IgcGxvdEJhY2tncm91bmRJbWFnZSBwbG90Qm9yZGVyQ29sb3IgcGxvdEJvcmRlcldpZHRoIHBsb3RTaGFkb3cgc2hhZG93XCIuc3BsaXQoXCIgXCIpLFxuICAgICAgcHJvcHNSZXF1aXJlUmVmbG93OiBcIm1hcmdpbiBtYXJnaW5Ub3AgbWFyZ2luUmlnaHQgbWFyZ2luQm90dG9tIG1hcmdpbkxlZnQgc3BhY2luZyBzcGFjaW5nVG9wIHNwYWNpbmdSaWdodCBzcGFjaW5nQm90dG9tIHNwYWNpbmdMZWZ0XCIuc3BsaXQoXCIgXCIpLFxuICAgICAgcHJvcHNSZXF1aXJlVXBkYXRlU2VyaWVzOiBcImNoYXJ0LmludmVydGVkIGNoYXJ0LnBvbGFyIGNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcyBjaGFydC50eXBlIGNvbG9ycyBwbG90T3B0aW9ucyB0aW1lIHRvb2x0aXBcIi5zcGxpdChcIiBcIiksXG4gICAgICBjb2xsZWN0aW9uc1dpdGhVcGRhdGU6IFtcInhBeGlzXCIsIFwieUF4aXNcIiwgXCJ6QXhpc1wiLCBcInNlcmllc1wiXSxcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGYsIGgsIGwsIGcpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLFxuICAgICAgICAgICAgdyA9IHtcbiAgICAgICAgICBjcmVkaXRzOiBcImFkZENyZWRpdHNcIixcbiAgICAgICAgICB0aXRsZTogXCJzZXRUaXRsZVwiLFxuICAgICAgICAgIHN1YnRpdGxlOiBcInNldFN1YnRpdGxlXCIsXG4gICAgICAgICAgY2FwdGlvbjogXCJzZXRDYXB0aW9uXCJcbiAgICAgICAgfSxcbiAgICAgICAgICAgIHAsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgcSxcbiAgICAgICAgICAgIHQgPSBmLmlzUmVzcG9uc2l2ZU9wdGlvbnMsXG4gICAgICAgICAgICB6ID0gW107XG4gICAgICAgIEQodiwgXCJ1cGRhdGVcIiwge1xuICAgICAgICAgIG9wdGlvbnM6IGZcbiAgICAgICAgfSk7XG4gICAgICAgIHQgfHwgdi5zZXRSZXNwb25zaXZlKCExLCAhMCk7XG4gICAgICAgIGYgPSBkLmNsZWFuUmVjdXJzaXZlbHkoZiwgdi5vcHRpb25zKTtcbiAgICAgICAgZSghMCwgdi51c2VyT3B0aW9ucywgZik7XG5cbiAgICAgICAgaWYgKHAgPSBmLmNoYXJ0KSB7XG4gICAgICAgICAgZSghMCwgdi5vcHRpb25zLmNoYXJ0LCBwKTtcbiAgICAgICAgICBcImNsYXNzTmFtZVwiIGluIHAgJiYgdi5zZXRDbGFzc05hbWUocC5jbGFzc05hbWUpO1xuICAgICAgICAgIFwicmVmbG93XCIgaW4gcCAmJiB2LnNldFJlZmxvdyhwLnJlZmxvdyk7XG5cbiAgICAgICAgICBpZiAoXCJpbnZlcnRlZFwiIGluIHAgfHwgXCJwb2xhclwiIGluIHAgfHwgXCJ0eXBlXCIgaW4gcCkge1xuICAgICAgICAgICAgdi5wcm9wRnJvbVNlcmllcygpO1xuICAgICAgICAgICAgdmFyIEIgPSAhMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBcImFsaWduVGlja3NcIiBpbiBwICYmIChCID0gITApO1xuICAgICAgICAgIGMocCwgZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgICAgIC0xICE9PSB2LnByb3BzUmVxdWlyZVVwZGF0ZVNlcmllcy5pbmRleE9mKFwiY2hhcnQuXCIgKyBjKSAmJiAoYiA9ICEwKTtcbiAgICAgICAgICAgIC0xICE9PSB2LnByb3BzUmVxdWlyZURpcnR5Qm94LmluZGV4T2YoYykgJiYgKHYuaXNEaXJ0eUJveCA9ICEwKTtcbiAgICAgICAgICAgIHQgfHwgLTEgPT09IHYucHJvcHNSZXF1aXJlUmVmbG93LmluZGV4T2YoYykgfHwgKHEgPSAhMCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgIXYuc3R5bGVkTW9kZSAmJiBcInN0eWxlXCIgaW4gcCAmJiB2LnJlbmRlcmVyLnNldFN0eWxlKHAuc3R5bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgIXYuc3R5bGVkTW9kZSAmJiBmLmNvbG9ycyAmJiAodGhpcy5vcHRpb25zLmNvbG9ycyA9IGYuY29sb3JzKTtcbiAgICAgICAgZi5wbG90T3B0aW9ucyAmJiBlKCEwLCB0aGlzLm9wdGlvbnMucGxvdE9wdGlvbnMsIGYucGxvdE9wdGlvbnMpO1xuICAgICAgICBmLnRpbWUgJiYgdGhpcy50aW1lID09PSBkLnRpbWUgJiYgKHRoaXMudGltZSA9IG5ldyByKGYudGltZSkpO1xuICAgICAgICBjKGYsIGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgICAgaWYgKHZbY10gJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdltjXS51cGRhdGUpIHZbY10udXBkYXRlKGEsICExKTtlbHNlIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2W3dbY11dKSB2W3dbY11dKGEpO1xuICAgICAgICAgIFwiY2hhcnRcIiAhPT0gYyAmJiAtMSAhPT0gdi5wcm9wc1JlcXVpcmVVcGRhdGVTZXJpZXMuaW5kZXhPZihjKSAmJiAoYiA9ICEwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbnNXaXRoVXBkYXRlLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBpZiAoZltiXSkge1xuICAgICAgICAgICAgaWYgKFwic2VyaWVzXCIgPT09IGIpIHtcbiAgICAgICAgICAgICAgdmFyIGMgPSBbXTtcbiAgICAgICAgICAgICAgdltiXS5mb3JFYWNoKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgYS5vcHRpb25zLmlzSW50ZXJuYWwgfHwgYy5wdXNoKGsoYS5vcHRpb25zLmluZGV4LCBiKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhKGZbYl0pLmZvckVhY2goZnVuY3Rpb24gKGEsIGUpIHtcbiAgICAgICAgICAgICAgKGUgPSBHKGEuaWQpICYmIHYuZ2V0KGEuaWQpIHx8IHZbYl1bYyA/IGNbZV0gOiBlXSkgJiYgZS5jb2xsID09PSBiICYmIChlLnVwZGF0ZShhLCAhMSksIGwgJiYgKGUudG91Y2hlZCA9ICEwKSk7XG4gICAgICAgICAgICAgICFlICYmIGwgJiYgdi5jb2xsZWN0aW9uc1dpdGhJbml0W2JdICYmICh2LmNvbGxlY3Rpb25zV2l0aEluaXRbYl1bMF0uYXBwbHkodiwgW2FdLmNvbmNhdCh2LmNvbGxlY3Rpb25zV2l0aEluaXRbYl1bMV0gfHwgW10pLmNvbmNhdChbITFdKSkudG91Y2hlZCA9ICEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbCAmJiB2W2JdLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgYS50b3VjaGVkIHx8IGEub3B0aW9ucy5pc0ludGVybmFsID8gZGVsZXRlIGEudG91Y2hlZCA6IHoucHVzaChhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHouZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEucmVtb3ZlICYmIGEucmVtb3ZlKCExKTtcbiAgICAgICAgfSk7XG4gICAgICAgIEIgJiYgdi5heGVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhLnVwZGF0ZSh7fSwgITEpO1xuICAgICAgICB9KTtcbiAgICAgICAgYiAmJiB2LmdldFNlcmllc09yZGVyQnlMaW5rcygpLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhLmNoYXJ0ICYmIGEudXBkYXRlKHt9LCAhMSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBmLmxvYWRpbmcgJiYgZSghMCwgdi5vcHRpb25zLmxvYWRpbmcsIGYubG9hZGluZyk7XG4gICAgICAgIEIgPSBwICYmIHAud2lkdGg7XG4gICAgICAgIHAgPSBwICYmIHAuaGVpZ2h0O1xuICAgICAgICBQKHApICYmIChwID0gbihwLCBCIHx8IHYuY2hhcnRXaWR0aCkpO1xuICAgICAgICBxIHx8IE4oQikgJiYgQiAhPT0gdi5jaGFydFdpZHRoIHx8IE4ocCkgJiYgcCAhPT0gdi5jaGFydEhlaWdodCA/IHYuc2V0U2l6ZShCLCBwLCBnKSA6IGsoaCwgITApICYmIHYucmVkcmF3KGcpO1xuICAgICAgICBEKHYsIFwiYWZ0ZXJVcGRhdGVcIiwge1xuICAgICAgICAgIG9wdGlvbnM6IGYsXG4gICAgICAgICAgcmVkcmF3OiBoLFxuICAgICAgICAgIGFuaW1hdGlvbjogZ1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzZXRTdWJ0aXRsZTogZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgdGhpcy5hcHBseURlc2NyaXB0aW9uKFwic3VidGl0bGVcIiwgYSk7XG4gICAgICAgIHRoaXMubGF5T3V0VGl0bGVzKGMpO1xuICAgICAgfSxcbiAgICAgIHNldENhcHRpb246IGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgIHRoaXMuYXBwbHlEZXNjcmlwdGlvbihcImNhcHRpb25cIiwgYSk7XG4gICAgICAgIHRoaXMubGF5T3V0VGl0bGVzKGMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHUucHJvdG90eXBlLmNvbGxlY3Rpb25zV2l0aEluaXQgPSB7XG4gICAgICB4QXhpczogW3UucHJvdG90eXBlLmFkZEF4aXMsIFshMF1dLFxuICAgICAgeUF4aXM6IFt1LnByb3RvdHlwZS5hZGRBeGlzLCBbITFdXSxcbiAgICAgIHNlcmllczogW3UucHJvdG90eXBlLmFkZFNlcmllc11cbiAgICB9O1xuICAgIHQoZy5wcm90b3R5cGUsIHtcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGEsIGMsIGUsIGYpIHtcbiAgICAgICAgZnVuY3Rpb24gZCgpIHtcbiAgICAgICAgICBoLmFwcGx5T3B0aW9ucyhhKTtcbiAgICAgICAgICB2YXIgZiA9IGIgJiYgaC5oYXNEdW1teUdyYXBoaWM7XG4gICAgICAgICAgZiA9IG51bGwgPT09IGgueSA/ICFmIDogZjtcbiAgICAgICAgICBiICYmIGYgJiYgKGguZ3JhcGhpYyA9IGIuZGVzdHJveSgpLCBkZWxldGUgaC5oYXNEdW1teUdyYXBoaWMpO1xuICAgICAgICAgIHEoYSwgITApICYmIChiICYmIGIuZWxlbWVudCAmJiBhICYmIGEubWFya2VyICYmIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBhLm1hcmtlci5zeW1ib2wgJiYgKGguZ3JhcGhpYyA9IGIuZGVzdHJveSgpKSwgYSAmJiBhLmRhdGFMYWJlbHMgJiYgaC5kYXRhTGFiZWwgJiYgKGguZGF0YUxhYmVsID0gaC5kYXRhTGFiZWwuZGVzdHJveSgpKSwgaC5jb25uZWN0b3IgJiYgKGguY29ubmVjdG9yID0gaC5jb25uZWN0b3IuZGVzdHJveSgpKSk7XG4gICAgICAgICAgZyA9IGguaW5kZXg7XG4gICAgICAgICAgbC51cGRhdGVQYXJhbGxlbEFycmF5cyhoLCBnKTtcbiAgICAgICAgICB2LmRhdGFbZ10gPSBxKHYuZGF0YVtnXSwgITApIHx8IHEoYSwgITApID8gaC5vcHRpb25zIDogayhhLCB2LmRhdGFbZ10pO1xuICAgICAgICAgIGwuaXNEaXJ0eSA9IGwuaXNEaXJ0eURhdGEgPSAhMDtcbiAgICAgICAgICAhbC5maXhlZEJveCAmJiBsLmhhc0NhcnRlc2lhblNlcmllcyAmJiAobi5pc0RpcnR5Qm94ID0gITApO1xuICAgICAgICAgIFwicG9pbnRcIiA9PT0gdi5sZWdlbmRUeXBlICYmIChuLmlzRGlydHlMZWdlbmQgPSAhMCk7XG4gICAgICAgICAgYyAmJiBuLnJlZHJhdyhlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoID0gdGhpcyxcbiAgICAgICAgICAgIGwgPSBoLnNlcmllcyxcbiAgICAgICAgICAgIGIgPSBoLmdyYXBoaWMsXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgbiA9IGwuY2hhcnQsXG4gICAgICAgICAgICB2ID0gbC5vcHRpb25zO1xuICAgICAgICBjID0gayhjLCAhMCk7XG4gICAgICAgICExID09PSBmID8gZCgpIDogaC5maXJlUG9pbnRFdmVudChcInVwZGF0ZVwiLCB7XG4gICAgICAgICAgb3B0aW9uczogYVxuICAgICAgICB9LCBkKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgIHRoaXMuc2VyaWVzLnJlbW92ZVBvaW50KHRoaXMuc2VyaWVzLmRhdGEuaW5kZXhPZih0aGlzKSwgYSwgYyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdCh2LnByb3RvdHlwZSwge1xuICAgICAgYWRkUG9pbnQ6IGZ1bmN0aW9uIChhLCBjLCBlLCBmLCBkKSB7XG4gICAgICAgIHZhciBoID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgbCA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGIgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZyA9IHRoaXMueEF4aXM7XG4gICAgICAgIGcgPSBnICYmIGcuaGFzTmFtZXMgJiYgZy5uYW1lcztcbiAgICAgICAgdmFyIG4gPSBoLmRhdGEsXG4gICAgICAgICAgICB2ID0gdGhpcy54RGF0YSxcbiAgICAgICAgICAgIHE7XG4gICAgICAgIGMgPSBrKGMsICEwKTtcbiAgICAgICAgdmFyIHcgPSB7XG4gICAgICAgICAgc2VyaWVzOiB0aGlzXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucG9pbnRDbGFzcy5wcm90b3R5cGUuYXBwbHlPcHRpb25zLmFwcGx5KHcsIFthXSk7XG4gICAgICAgIHZhciB0ID0gdy54O1xuICAgICAgICB2YXIgbSA9IHYubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5yZXF1aXJlU29ydGluZyAmJiB0IDwgdlttIC0gMV0pIGZvciAocSA9ICEwOyBtICYmIHZbbSAtIDFdID4gdDspIG0tLTtcbiAgICAgICAgdGhpcy51cGRhdGVQYXJhbGxlbEFycmF5cyh3LCBcInNwbGljZVwiLCBtLCAwLCAwKTtcbiAgICAgICAgdGhpcy51cGRhdGVQYXJhbGxlbEFycmF5cyh3LCBtKTtcbiAgICAgICAgZyAmJiB3Lm5hbWUgJiYgKGdbdF0gPSB3Lm5hbWUpO1xuICAgICAgICBuLnNwbGljZShtLCAwLCBhKTtcbiAgICAgICAgcSAmJiAodGhpcy5kYXRhLnNwbGljZShtLCAwLCBudWxsKSwgdGhpcy5wcm9jZXNzRGF0YSgpKTtcbiAgICAgICAgXCJwb2ludFwiID09PSBoLmxlZ2VuZFR5cGUgJiYgdGhpcy5nZW5lcmF0ZVBvaW50cygpO1xuICAgICAgICBlICYmIChsWzBdICYmIGxbMF0ucmVtb3ZlID8gbFswXS5yZW1vdmUoITEpIDogKGwuc2hpZnQoKSwgdGhpcy51cGRhdGVQYXJhbGxlbEFycmF5cyh3LCBcInNoaWZ0XCIpLCBuLnNoaWZ0KCkpKTtcbiAgICAgICAgITEgIT09IGQgJiYgRCh0aGlzLCBcImFkZFBvaW50XCIsIHtcbiAgICAgICAgICBwb2ludDogd1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pc0RpcnR5RGF0YSA9IHRoaXMuaXNEaXJ0eSA9ICEwO1xuICAgICAgICBjICYmIGIucmVkcmF3KGYpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZVBvaW50OiBmdW5jdGlvbiAoYSwgYywgZSkge1xuICAgICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgICBoID0gZC5kYXRhLFxuICAgICAgICAgICAgbCA9IGhbYV0sXG4gICAgICAgICAgICBnID0gZC5wb2ludHMsXG4gICAgICAgICAgICBiID0gZC5jaGFydCxcbiAgICAgICAgICAgIG4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZyAmJiBnLmxlbmd0aCA9PT0gaC5sZW5ndGggJiYgZy5zcGxpY2UoYSwgMSk7XG4gICAgICAgICAgaC5zcGxpY2UoYSwgMSk7XG4gICAgICAgICAgZC5vcHRpb25zLmRhdGEuc3BsaWNlKGEsIDEpO1xuICAgICAgICAgIGQudXBkYXRlUGFyYWxsZWxBcnJheXMobCB8fCB7XG4gICAgICAgICAgICBzZXJpZXM6IGRcbiAgICAgICAgICB9LCBcInNwbGljZVwiLCBhLCAxKTtcbiAgICAgICAgICBsICYmIGwuZGVzdHJveSgpO1xuICAgICAgICAgIGQuaXNEaXJ0eSA9ICEwO1xuICAgICAgICAgIGQuaXNEaXJ0eURhdGEgPSAhMDtcbiAgICAgICAgICBjICYmIGIucmVkcmF3KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZihlLCBiKTtcbiAgICAgICAgYyA9IGsoYywgITApO1xuICAgICAgICBsID8gbC5maXJlUG9pbnRFdmVudChcInJlbW92ZVwiLCBudWxsLCBuKSA6IG4oKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIChhLCBjLCBlLCBmKSB7XG4gICAgICAgIGZ1bmN0aW9uIGQoKSB7XG4gICAgICAgICAgaC5kZXN0cm95KGYpO1xuICAgICAgICAgIGgucmVtb3ZlID0gbnVsbDtcbiAgICAgICAgICBsLmlzRGlydHlMZWdlbmQgPSBsLmlzRGlydHlCb3ggPSAhMDtcbiAgICAgICAgICBsLmxpbmtTZXJpZXMoKTtcbiAgICAgICAgICBrKGEsICEwKSAmJiBsLnJlZHJhdyhjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoID0gdGhpcyxcbiAgICAgICAgICAgIGwgPSBoLmNoYXJ0O1xuICAgICAgICAhMSAhPT0gZSA/IEQoaCwgXCJyZW1vdmVcIiwgbnVsbCwgZCkgOiBkKCk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICBhID0gZC5jbGVhblJlY3Vyc2l2ZWx5KGEsIHRoaXMudXNlck9wdGlvbnMpO1xuICAgICAgICBEKHRoaXMsIFwidXBkYXRlXCIsIHtcbiAgICAgICAgICBvcHRpb25zOiBhXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZiA9IHRoaXMsXG4gICAgICAgICAgICBoID0gZi5jaGFydCxcbiAgICAgICAgICAgIGwgPSBmLnVzZXJPcHRpb25zLFxuICAgICAgICAgICAgZyA9IGYuaW5pdGlhbFR5cGUgfHwgZi50eXBlLFxuICAgICAgICAgICAgbiA9IGEudHlwZSB8fCBsLnR5cGUgfHwgaC5vcHRpb25zLmNoYXJ0LnR5cGUsXG4gICAgICAgICAgICBiID0gISh0aGlzLmhhc0Rlcml2ZWREYXRhIHx8IGEuZGF0YUdyb3VwaW5nIHx8IG4gJiYgbiAhPT0gdGhpcy50eXBlIHx8IFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBhLnBvaW50U3RhcnQgfHwgYS5wb2ludEludGVydmFsIHx8IGEucG9pbnRJbnRlcnZhbFVuaXQgfHwgYS5rZXlzKSxcbiAgICAgICAgICAgIHYgPSB6W2ddLnByb3RvdHlwZSxcbiAgICAgICAgICAgIHEsXG4gICAgICAgICAgICB3ID0gW1wiZ3JvdXBcIiwgXCJtYXJrZXJHcm91cFwiLCBcImRhdGFMYWJlbHNHcm91cFwiLCBcInRyYW5zZm9ybUdyb3VwXCJdLFxuICAgICAgICAgICAgciA9IFtcImV2ZW50T3B0aW9uc1wiLCBcIm5hdmlnYXRvclNlcmllc1wiLCBcImJhc2VTZXJpZXNcIl0sXG4gICAgICAgICAgICBCID0gZi5maW5pc2hlZEFuaW1hdGluZyAmJiB7XG4gICAgICAgICAgYW5pbWF0aW9uOiAhMVxuICAgICAgICB9LFxuICAgICAgICAgICAgdSA9IHt9O1xuICAgICAgICBiICYmIChyLnB1c2goXCJkYXRhXCIsIFwiaXNEaXJ0eURhdGFcIiwgXCJwb2ludHNcIiwgXCJwcm9jZXNzZWRYRGF0YVwiLCBcInByb2Nlc3NlZFlEYXRhXCIsIFwieEluY3JlbWVudFwiLCBcIl9oYXNQb2ludE1hcmtlcnNcIiwgXCJfaGFzUG9pbnRMYWJlbHNcIiwgXCJtYXBNYXBcIiwgXCJtYXBEYXRhXCIsIFwibWluWVwiLCBcIm1heFlcIiwgXCJtaW5YXCIsIFwibWF4WFwiKSwgITEgIT09IGEudmlzaWJsZSAmJiByLnB1c2goXCJhcmVhXCIsIFwiZ3JhcGhcIiksIGYucGFyYWxsZWxBcnJheXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHIucHVzaChhICsgXCJEYXRhXCIpO1xuICAgICAgICB9KSwgYS5kYXRhICYmIChhLmRhdGFTb3J0aW5nICYmIHQoZi5vcHRpb25zLmRhdGFTb3J0aW5nLCBhLmRhdGFTb3J0aW5nKSwgdGhpcy5zZXREYXRhKGEuZGF0YSwgITEpKSk7XG4gICAgICAgIGEgPSBlKGwsIEIsIHtcbiAgICAgICAgICBpbmRleDogXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGwuaW5kZXggPyBmLmluZGV4IDogbC5pbmRleCxcbiAgICAgICAgICBwb2ludFN0YXJ0OiBrKGwucG9pbnRTdGFydCwgZi54RGF0YVswXSlcbiAgICAgICAgfSwgIWIgJiYge1xuICAgICAgICAgIGRhdGE6IGYub3B0aW9ucy5kYXRhXG4gICAgICAgIH0sIGEpO1xuICAgICAgICBiICYmIGEuZGF0YSAmJiAoYS5kYXRhID0gZi5vcHRpb25zLmRhdGEpO1xuICAgICAgICByID0gdy5jb25jYXQocik7XG4gICAgICAgIHIuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHJbYV0gPSBmW2FdO1xuICAgICAgICAgIGRlbGV0ZSBmW2FdO1xuICAgICAgICB9KTtcbiAgICAgICAgZi5yZW1vdmUoITEsIG51bGwsICExLCAhMCk7XG5cbiAgICAgICAgZm9yIChxIGluIHYpIGZbcV0gPSB2b2lkIDA7XG5cbiAgICAgICAgeltuIHx8IGddID8gdChmLCB6W24gfHwgZ10ucHJvdG90eXBlKSA6IHkoMTcsICEwLCBoLCB7XG4gICAgICAgICAgbWlzc2luZ01vZHVsZUZvcjogbiB8fCBnXG4gICAgICAgIH0pO1xuICAgICAgICByLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBmW2FdID0gclthXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGYuaW5pdChoLCBhKTtcblxuICAgICAgICBpZiAoYiAmJiB0aGlzLnBvaW50cykge1xuICAgICAgICAgIHZhciBtID0gZi5vcHRpb25zO1xuICAgICAgICAgICExID09PSBtLnZpc2libGUgPyAodS5ncmFwaGljID0gMSwgdS5kYXRhTGFiZWwgPSAxKSA6IGYuX2hhc1BvaW50TGFiZWxzIHx8IChuID0gbS5tYXJrZXIsIHYgPSBtLmRhdGFMYWJlbHMsIG4gJiYgKCExID09PSBuLmVuYWJsZWQgfHwgXCJzeW1ib2xcIiBpbiBuKSAmJiAodS5ncmFwaGljID0gMSksIHYgJiYgITEgPT09IHYuZW5hYmxlZCAmJiAodS5kYXRhTGFiZWwgPSAxKSk7XG4gICAgICAgICAgdGhpcy5wb2ludHMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYSAmJiBhLnNlcmllcyAmJiAoYS5yZXNvbHZlQ29sb3IoKSwgT2JqZWN0LmtleXModSkubGVuZ3RoICYmIGEuZGVzdHJveUVsZW1lbnRzKHUpLCAhMSA9PT0gbS5zaG93SW5MZWdlbmQgJiYgYS5sZWdlbmRJdGVtICYmIGgubGVnZW5kLmRlc3Ryb3lJdGVtKGEpKTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGEuekluZGV4ICE9PSBsLnpJbmRleCAmJiB3LmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBmW2JdICYmIGZbYl0uYXR0cih7XG4gICAgICAgICAgICB6SW5kZXg6IGEuekluZGV4XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmLmluaXRpYWxUeXBlID0gZztcbiAgICAgICAgaC5saW5rU2VyaWVzKCk7XG4gICAgICAgIEQodGhpcywgXCJhZnRlclVwZGF0ZVwiKTtcbiAgICAgICAgayhjLCAhMCkgJiYgaC5yZWRyYXcoYiA/IHZvaWQgMCA6ICExKTtcbiAgICAgIH0sXG4gICAgICBzZXROYW1lOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLm9wdGlvbnMubmFtZSA9IHRoaXMudXNlck9wdGlvbnMubmFtZSA9IGE7XG4gICAgICAgIHRoaXMuY2hhcnQuaXNEaXJ0eUxlZ2VuZCA9ICEwO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHQobC5wcm90b3R5cGUsIHtcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGEsIGYpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgaCA9IGEgJiYgYS5ldmVudHMgfHwge307XG4gICAgICAgIGEgPSBlKHRoaXMudXNlck9wdGlvbnMsIGEpO1xuICAgICAgICBkLm9wdGlvbnNbdGhpcy5jb2xsXS5pbmRleE9mICYmIChkLm9wdGlvbnNbdGhpcy5jb2xsXVtkLm9wdGlvbnNbdGhpcy5jb2xsXS5pbmRleE9mKHRoaXMudXNlck9wdGlvbnMpXSA9IGEpO1xuICAgICAgICBjKGQub3B0aW9uc1t0aGlzLmNvbGxdLmV2ZW50cywgZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgICBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgaFtjXSAmJiAoaFtjXSA9IHZvaWQgMCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koITApO1xuICAgICAgICB0aGlzLmluaXQoZCwgdChhLCB7XG4gICAgICAgICAgZXZlbnRzOiBoXG4gICAgICAgIH0pKTtcbiAgICAgICAgZC5pc0RpcnR5Qm94ID0gITA7XG4gICAgICAgIGsoZiwgITApICYmIGQucmVkcmF3KCk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICBmb3IgKHZhciBjID0gdGhpcy5jaGFydCwgZSA9IHRoaXMuY29sbCwgZiA9IHRoaXMuc2VyaWVzLCBkID0gZi5sZW5ndGg7IGQtLTspIGZbZF0gJiYgZltkXS5yZW1vdmUoITEpO1xuXG4gICAgICAgIEooYy5heGVzLCB0aGlzKTtcbiAgICAgICAgSihjW2VdLCB0aGlzKTtcbiAgICAgICAgaChjLm9wdGlvbnNbZV0pID8gYy5vcHRpb25zW2VdLnNwbGljZSh0aGlzLm9wdGlvbnMuaW5kZXgsIDEpIDogZGVsZXRlIGMub3B0aW9uc1tlXTtcbiAgICAgICAgY1tlXS5mb3JFYWNoKGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgICAgYS5vcHRpb25zLmluZGV4ID0gYS51c2VyT3B0aW9ucy5pbmRleCA9IGM7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgYy5pc0RpcnR5Qm94ID0gITA7XG4gICAgICAgIGsoYSwgITApICYmIGMucmVkcmF3KCk7XG4gICAgICB9LFxuICAgICAgc2V0VGl0bGU6IGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICB0aXRsZTogYVxuICAgICAgICB9LCBjKTtcbiAgICAgIH0sXG4gICAgICBzZXRDYXRlZ29yaWVzOiBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgY2F0ZWdvcmllczogYVxuICAgICAgICB9LCBjKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9BcmVhU2VyaWVzLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL0NvbG9yLmpzXCJdLCByW1wibWl4aW5zL2xlZ2VuZC1zeW1ib2wuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZywgciwgdSkge1xuICAgIHZhciBJID0gZy5wYXJzZSxcbiAgICAgICAgTSA9IHUub2JqZWN0RWFjaCxcbiAgICAgICAgRSA9IHUucGljaztcbiAgICBnID0gdS5zZXJpZXNUeXBlO1xuICAgIHZhciBBID0gZC5TZXJpZXM7XG4gICAgZyhcImFyZWFcIiwgXCJsaW5lXCIsIHtcbiAgICAgIHNvZnRUaHJlc2hvbGQ6ICExLFxuICAgICAgdGhyZXNob2xkOiAwXG4gICAgfSwge1xuICAgICAgc2luZ2xlU3RhY2tzOiAhMSxcbiAgICAgIGdldFN0YWNrUG9pbnRzOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgZyA9IFtdLFxuICAgICAgICAgICAgciA9IFtdLFxuICAgICAgICAgICAgdCA9IHRoaXMueEF4aXMsXG4gICAgICAgICAgICB1ID0gdGhpcy55QXhpcyxcbiAgICAgICAgICAgIGggPSB1LnN0YWNrc1t0aGlzLnN0YWNrS2V5XSxcbiAgICAgICAgICAgIEEgPSB7fSxcbiAgICAgICAgICAgIHEgPSB0aGlzLmluZGV4LFxuICAgICAgICAgICAgRyA9IHUuc2VyaWVzLFxuICAgICAgICAgICAgZSA9IEcubGVuZ3RoLFxuICAgICAgICAgICAgYyA9IEUodS5vcHRpb25zLnJldmVyc2VkU3RhY2tzLCAhMCkgPyAxIDogLTEsXG4gICAgICAgICAgICBrO1xuICAgICAgICBkID0gZCB8fCB0aGlzLnBvaW50cztcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWNraW5nKSB7XG4gICAgICAgICAgZm9yIChrID0gMDsgayA8IGQubGVuZ3RoOyBrKyspIGRba10ubGVmdE51bGwgPSBkW2tdLnJpZ2h0TnVsbCA9IHZvaWQgMCwgQVtkW2tdLnhdID0gZFtrXTtcblxuICAgICAgICAgIE0oaCwgZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgICAgIG51bGwgIT09IGMudG90YWwgJiYgci5wdXNoKGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHIuc29ydChmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICAgICAgcmV0dXJuIGMgLSBhO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBuID0gRy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiBjLnZpc2libGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgci5mb3JFYWNoKGZ1bmN0aW9uIChmLCBhKSB7XG4gICAgICAgICAgICB2YXIgZCA9IDAsXG4gICAgICAgICAgICAgICAgdixcbiAgICAgICAgICAgICAgICB6O1xuICAgICAgICAgICAgaWYgKEFbZl0gJiYgIUFbZl0uaXNOdWxsKSBnLnB1c2goQVtmXSksIFstMSwgMV0uZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICB2YXIgbCA9IDEgPT09IGQgPyBcInJpZ2h0TnVsbFwiIDogXCJsZWZ0TnVsbFwiLFxuICAgICAgICAgICAgICAgICAgZyA9IDAsXG4gICAgICAgICAgICAgICAgICB3ID0gaFtyW2EgKyBkXV07XG4gICAgICAgICAgICAgIGlmICh3KSBmb3IgKGsgPSBxOyAwIDw9IGsgJiYgayA8IGU7KSB2ID0gdy5wb2ludHNba10sIHYgfHwgKGsgPT09IHEgPyBBW2ZdW2xdID0gITAgOiBuW2tdICYmICh6ID0gaFtmXS5wb2ludHNba10pICYmIChnIC09IHpbMV0gLSB6WzBdKSksIGsgKz0gYztcbiAgICAgICAgICAgICAgQVtmXVsxID09PSBkID8gXCJyaWdodENsaWZmXCIgOiBcImxlZnRDbGlmZlwiXSA9IGc7XG4gICAgICAgICAgICB9KTtlbHNlIHtcbiAgICAgICAgICAgICAgZm9yIChrID0gcTsgMCA8PSBrICYmIGsgPCBlOykge1xuICAgICAgICAgICAgICAgIGlmICh2ID0gaFtmXS5wb2ludHNba10pIHtcbiAgICAgICAgICAgICAgICAgIGQgPSB2WzFdO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgayArPSBjO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZCA9IHUudHJhbnNsYXRlKGQsIDAsIDEsIDAsIDEpO1xuICAgICAgICAgICAgICBnLnB1c2goe1xuICAgICAgICAgICAgICAgIGlzTnVsbDogITAsXG4gICAgICAgICAgICAgICAgcGxvdFg6IHQudHJhbnNsYXRlKGYsIDAsIDAsIDAsIDEpLFxuICAgICAgICAgICAgICAgIHg6IGYsXG4gICAgICAgICAgICAgICAgcGxvdFk6IGQsXG4gICAgICAgICAgICAgICAgeUJvdHRvbTogZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnO1xuICAgICAgfSxcbiAgICAgIGdldEdyYXBoUGF0aDogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIGcgPSBBLnByb3RvdHlwZS5nZXRHcmFwaFBhdGgsXG4gICAgICAgICAgICByID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgdCA9IHIuc3RhY2tpbmcsXG4gICAgICAgICAgICB1ID0gdGhpcy55QXhpcyxcbiAgICAgICAgICAgIGgsXG4gICAgICAgICAgICBOID0gW10sXG4gICAgICAgICAgICBxID0gW10sXG4gICAgICAgICAgICBHID0gdGhpcy5pbmRleCxcbiAgICAgICAgICAgIGUgPSB1LnN0YWNrc1t0aGlzLnN0YWNrS2V5XSxcbiAgICAgICAgICAgIGMgPSByLnRocmVzaG9sZCxcbiAgICAgICAgICAgIGsgPSBNYXRoLnJvdW5kKHUuZ2V0VGhyZXNob2xkKHIudGhyZXNob2xkKSk7XG4gICAgICAgIHIgPSBFKHIuY29ubmVjdE51bGxzLCBcInBlcmNlbnRcIiA9PT0gdCk7XG5cbiAgICAgICAgdmFyIG4gPSBmdW5jdGlvbiAoZiwgaCwgbCkge1xuICAgICAgICAgIHZhciBnID0gZFtmXTtcbiAgICAgICAgICBmID0gdCAmJiBlW2cueF0ucG9pbnRzW0ddO1xuICAgICAgICAgIHZhciBuID0gZ1tsICsgXCJOdWxsXCJdIHx8IDA7XG4gICAgICAgICAgbCA9IGdbbCArIFwiQ2xpZmZcIl0gfHwgMDtcbiAgICAgICAgICBnID0gITA7XG5cbiAgICAgICAgICBpZiAobCB8fCBuKSB7XG4gICAgICAgICAgICB2YXIgdiA9IChuID8gZlswXSA6IGZbMV0pICsgbDtcbiAgICAgICAgICAgIHZhciB3ID0gZlswXSArIGw7XG4gICAgICAgICAgICBnID0gISFuO1xuICAgICAgICAgIH0gZWxzZSAhdCAmJiBkW2hdICYmIGRbaF0uaXNOdWxsICYmICh2ID0gdyA9IGMpO1xuXG4gICAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHYgJiYgKHEucHVzaCh7XG4gICAgICAgICAgICBwbG90WDogYSxcbiAgICAgICAgICAgIHBsb3RZOiBudWxsID09PSB2ID8gayA6IHUuZ2V0VGhyZXNob2xkKHYpLFxuICAgICAgICAgICAgaXNOdWxsOiBnLFxuICAgICAgICAgICAgaXNDbGlmZjogITBcbiAgICAgICAgICB9KSwgTi5wdXNoKHtcbiAgICAgICAgICAgIHBsb3RYOiBhLFxuICAgICAgICAgICAgcGxvdFk6IG51bGwgPT09IHcgPyBrIDogdS5nZXRUaHJlc2hvbGQodyksXG4gICAgICAgICAgICBkb0N1cnZlOiAhMVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcblxuICAgICAgICBkID0gZCB8fCB0aGlzLnBvaW50cztcbiAgICAgICAgdCAmJiAoZCA9IHRoaXMuZ2V0U3RhY2tQb2ludHMoZCkpO1xuXG4gICAgICAgIGZvciAoaCA9IDA7IGggPCBkLmxlbmd0aDsgaCsrKSB7XG4gICAgICAgICAgdCB8fCAoZFtoXS5sZWZ0Q2xpZmYgPSBkW2hdLnJpZ2h0Q2xpZmYgPSBkW2hdLmxlZnROdWxsID0gZFtoXS5yaWdodE51bGwgPSB2b2lkIDApO1xuICAgICAgICAgIHZhciBmID0gZFtoXS5pc051bGw7XG4gICAgICAgICAgdmFyIGEgPSBFKGRbaF0ucmVjdFBsb3RYLCBkW2hdLnBsb3RYKTtcbiAgICAgICAgICB2YXIgbCA9IEUoZFtoXS55Qm90dG9tLCBrKTtcbiAgICAgICAgICBpZiAoIWYgfHwgcikgciB8fCBuKGgsIGggLSAxLCBcImxlZnRcIiksIGYgJiYgIXQgJiYgciB8fCAocS5wdXNoKGRbaF0pLCBOLnB1c2goe1xuICAgICAgICAgICAgeDogaCxcbiAgICAgICAgICAgIHBsb3RYOiBhLFxuICAgICAgICAgICAgcGxvdFk6IGxcbiAgICAgICAgICB9KSksIHIgfHwgbihoLCBoICsgMSwgXCJyaWdodFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGggPSBnLmNhbGwodGhpcywgcSwgITAsICEwKTtcbiAgICAgICAgTi5yZXZlcnNlZCA9ICEwO1xuICAgICAgICBmID0gZy5jYWxsKHRoaXMsIE4sICEwLCAhMCk7XG4gICAgICAgIGYubGVuZ3RoICYmIChmWzBdID0gXCJMXCIpO1xuICAgICAgICBmID0gaC5jb25jYXQoZik7XG4gICAgICAgIGcgPSBnLmNhbGwodGhpcywgcSwgITEsIHIpO1xuICAgICAgICBmLnhNYXAgPSBoLnhNYXA7XG4gICAgICAgIHRoaXMuYXJlYVBhdGggPSBmO1xuICAgICAgICByZXR1cm4gZztcbiAgICAgIH0sXG4gICAgICBkcmF3R3JhcGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hcmVhUGF0aCA9IFtdO1xuICAgICAgICBBLnByb3RvdHlwZS5kcmF3R3JhcGguYXBwbHkodGhpcyk7XG4gICAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICAgIGcgPSB0aGlzLmFyZWFQYXRoLFxuICAgICAgICAgICAgciA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIHQgPSBbW1wiYXJlYVwiLCBcImhpZ2hjaGFydHMtYXJlYVwiLCB0aGlzLmNvbG9yLCByLmZpbGxDb2xvcl1dO1xuICAgICAgICB0aGlzLnpvbmVzLmZvckVhY2goZnVuY3Rpb24gKGcsIGgpIHtcbiAgICAgICAgICB0LnB1c2goW1wiem9uZS1hcmVhLVwiICsgaCwgXCJoaWdoY2hhcnRzLWFyZWEgaGlnaGNoYXJ0cy16b25lLWFyZWEtXCIgKyBoICsgXCIgXCIgKyBnLmNsYXNzTmFtZSwgZy5jb2xvciB8fCBkLmNvbG9yLCBnLmZpbGxDb2xvciB8fCByLmZpbGxDb2xvcl0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdC5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGggPSB0WzBdLFxuICAgICAgICAgICAgICB1ID0gZFtoXSxcbiAgICAgICAgICAgICAgcSA9IHUgPyBcImFuaW1hdGVcIiA6IFwiYXR0clwiLFxuICAgICAgICAgICAgICB5ID0ge307XG4gICAgICAgICAgdSA/ICh1LmVuZFggPSBkLnByZXZlbnRHcmFwaEFuaW1hdGlvbiA/IG51bGwgOiBnLnhNYXAsIHUuYW5pbWF0ZSh7XG4gICAgICAgICAgICBkOiBnXG4gICAgICAgICAgfSkpIDogKHkuekluZGV4ID0gMCwgdSA9IGRbaF0gPSBkLmNoYXJ0LnJlbmRlcmVyLnBhdGgoZykuYWRkQ2xhc3ModFsxXSkuYWRkKGQuZ3JvdXApLCB1LmlzQXJlYSA9ICEwKTtcbiAgICAgICAgICBkLmNoYXJ0LnN0eWxlZE1vZGUgfHwgKHkuZmlsbCA9IEUodFszXSwgSSh0WzJdKS5zZXRPcGFjaXR5KEUoci5maWxsT3BhY2l0eSwgLjc1KSkuZ2V0KCkpKTtcbiAgICAgICAgICB1W3FdKHkpO1xuICAgICAgICAgIHUuc3RhcnRYID0gZy54TWFwO1xuICAgICAgICAgIHUuc2hpZnRVbml0ID0gci5zdGVwID8gMiA6IDE7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGRyYXdMZWdlbmRTeW1ib2w6IHIuZHJhd1JlY3RhbmdsZVxuICAgIH0pO1xuICAgIFwiXCI7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvU3BsaW5lU2VyaWVzLmpzXCIsIFtyW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQpIHtcbiAgICB2YXIgZyA9IGQucGljaztcbiAgICBkID0gZC5zZXJpZXNUeXBlO1xuICAgIGQoXCJzcGxpbmVcIiwgXCJsaW5lXCIsIHt9LCB7XG4gICAgICBnZXRQb2ludFNwbGluZTogZnVuY3Rpb24gKGQsIHIsIEkpIHtcbiAgICAgICAgdmFyIHUgPSByLnBsb3RYLFxuICAgICAgICAgICAgRSA9IHIucGxvdFksXG4gICAgICAgICAgICBBID0gZFtJIC0gMV07XG4gICAgICAgIEkgPSBkW0kgKyAxXTtcblxuICAgICAgICBpZiAoQSAmJiAhQS5pc051bGwgJiYgITEgIT09IEEuZG9DdXJ2ZSAmJiAhci5pc0NsaWZmICYmIEkgJiYgIUkuaXNOdWxsICYmICExICE9PSBJLmRvQ3VydmUgJiYgIXIuaXNDbGlmZikge1xuICAgICAgICAgIGQgPSBBLnBsb3RZO1xuICAgICAgICAgIHZhciBHID0gSS5wbG90WDtcbiAgICAgICAgICBJID0gSS5wbG90WTtcbiAgICAgICAgICB2YXIgSiA9IDA7XG4gICAgICAgICAgdmFyIHkgPSAoMS41ICogdSArIEEucGxvdFgpIC8gMi41O1xuICAgICAgICAgIHZhciB0ID0gKDEuNSAqIEUgKyBkKSAvIDIuNTtcbiAgICAgICAgICBHID0gKDEuNSAqIHUgKyBHKSAvIDIuNTtcbiAgICAgICAgICB2YXIgRCA9ICgxLjUgKiBFICsgSSkgLyAyLjU7XG4gICAgICAgICAgRyAhPT0geSAmJiAoSiA9IChEIC0gdCkgKiAoRyAtIHUpIC8gKEcgLSB5KSArIEUgLSBEKTtcbiAgICAgICAgICB0ICs9IEo7XG4gICAgICAgICAgRCArPSBKO1xuICAgICAgICAgIHQgPiBkICYmIHQgPiBFID8gKHQgPSBNYXRoLm1heChkLCBFKSwgRCA9IDIgKiBFIC0gdCkgOiB0IDwgZCAmJiB0IDwgRSAmJiAodCA9IE1hdGgubWluKGQsIEUpLCBEID0gMiAqIEUgLSB0KTtcbiAgICAgICAgICBEID4gSSAmJiBEID4gRSA/IChEID0gTWF0aC5tYXgoSSwgRSksIHQgPSAyICogRSAtIEQpIDogRCA8IEkgJiYgRCA8IEUgJiYgKEQgPSBNYXRoLm1pbihJLCBFKSwgdCA9IDIgKiBFIC0gRCk7XG4gICAgICAgICAgci5yaWdodENvbnRYID0gRztcbiAgICAgICAgICByLnJpZ2h0Q29udFkgPSBEO1xuICAgICAgICB9XG5cbiAgICAgICAgciA9IFtcIkNcIiwgZyhBLnJpZ2h0Q29udFgsIEEucGxvdFgpLCBnKEEucmlnaHRDb250WSwgQS5wbG90WSksIGcoeSwgdSksIGcodCwgRSksIHUsIEVdO1xuICAgICAgICBBLnJpZ2h0Q29udFggPSBBLnJpZ2h0Q29udFkgPSBudWxsO1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcIlwiO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL0FyZWFTcGxpbmVTZXJpZXMuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wibWl4aW5zL2xlZ2VuZC1zeW1ib2wuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZywgcikge1xuICAgIHIgPSByLnNlcmllc1R5cGU7XG4gICAgdmFyIHUgPSBkLnNlcmllc1R5cGVzLmFyZWEucHJvdG90eXBlO1xuICAgIHIoXCJhcmVhc3BsaW5lXCIsIFwic3BsaW5lXCIsIGQuZGVmYXVsdFBsb3RPcHRpb25zLmFyZWEsIHtcbiAgICAgIGdldFN0YWNrUG9pbnRzOiB1LmdldFN0YWNrUG9pbnRzLFxuICAgICAgZ2V0R3JhcGhQYXRoOiB1LmdldEdyYXBoUGF0aCxcbiAgICAgIGRyYXdHcmFwaDogdS5kcmF3R3JhcGgsXG4gICAgICBkcmF3TGVnZW5kU3ltYm9sOiBnLmRyYXdSZWN0YW5nbGVcbiAgICB9KTtcbiAgICBcIlwiO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL0NvbHVtblNlcmllcy5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9Db2xvci5qc1wiXSwgcltcIm1peGlucy9sZWdlbmQtc3ltYm9sLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcsIHIsIHUpIHtcbiAgICBcIlwiO1xuXG4gICAgdmFyIEkgPSBnLnBhcnNlLFxuICAgICAgICBNID0gdS5hbmltT2JqZWN0LFxuICAgICAgICBFID0gdS5jbGFtcCxcbiAgICAgICAgQSA9IHUuZGVmaW5lZCxcbiAgICAgICAgRyA9IHUuZXh0ZW5kLFxuICAgICAgICBKID0gdS5pc051bWJlcixcbiAgICAgICAgeSA9IHUubWVyZ2UsXG4gICAgICAgIHQgPSB1LnBpY2s7XG4gICAgZyA9IHUuc2VyaWVzVHlwZTtcbiAgICB2YXIgRCA9IGQuU2VyaWVzO1xuICAgIGcoXCJjb2x1bW5cIiwgXCJsaW5lXCIsIHtcbiAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgIGNyaXNwOiAhMCxcbiAgICAgIGdyb3VwUGFkZGluZzogLjIsXG4gICAgICBtYXJrZXI6IG51bGwsXG4gICAgICBwb2ludFBhZGRpbmc6IC4xLFxuICAgICAgbWluUG9pbnRMZW5ndGg6IDAsXG4gICAgICBjcm9wVGhyZXNob2xkOiA1MCxcbiAgICAgIHBvaW50UmFuZ2U6IG51bGwsXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICBoYWxvOiAhMSxcbiAgICAgICAgICBicmlnaHRuZXNzOiAuMVxuICAgICAgICB9LFxuICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICBjb2xvcjogXCIjY2NjY2NjXCIsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzAwMDAwMFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgIGFsaWduOiBudWxsLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBudWxsLFxuICAgICAgICB5OiBudWxsXG4gICAgICB9LFxuICAgICAgc29mdFRocmVzaG9sZDogITEsXG4gICAgICBzdGFydEZyb21UaHJlc2hvbGQ6ICEwLFxuICAgICAgc3RpY2t5VHJhY2tpbmc6ICExLFxuICAgICAgdG9vbHRpcDoge1xuICAgICAgICBkaXN0YW5jZTogNlxuICAgICAgfSxcbiAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgIGJvcmRlckNvbG9yOiBcIiNmZmZmZmZcIlxuICAgIH0sIHtcbiAgICAgIGNyb3BTaG91bGRlcjogMCxcbiAgICAgIGRpcmVjdFRvdWNoOiAhMCxcbiAgICAgIHRyYWNrZXJHcm91cHM6IFtcImdyb3VwXCIsIFwiZGF0YUxhYmVsc0dyb3VwXCJdLFxuICAgICAgbmVnU3RhY2tzOiAhMCxcbiAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgRC5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgICBnID0gZC5jaGFydDtcbiAgICAgICAgZy5oYXNSZW5kZXJlZCAmJiBnLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgaC50eXBlID09PSBkLnR5cGUgJiYgKGguaXNEaXJ0eSA9ICEwKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZ2V0Q29sdW1uTWV0cmljczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgICBnID0gZC5vcHRpb25zLFxuICAgICAgICAgICAgcSA9IGQueEF4aXMsXG4gICAgICAgICAgICByID0gZC55QXhpcyxcbiAgICAgICAgICAgIGUgPSBxLm9wdGlvbnMucmV2ZXJzZWRTdGFja3M7XG4gICAgICAgIGUgPSBxLnJldmVyc2VkICYmICFlIHx8ICFxLnJldmVyc2VkICYmIGU7XG4gICAgICAgIHZhciBjLFxuICAgICAgICAgICAgayA9IHt9LFxuICAgICAgICAgICAgbiA9IDA7XG4gICAgICAgICExID09PSBnLmdyb3VwaW5nID8gbiA9IDEgOiBkLmNoYXJ0LnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgdmFyIGUgPSBhLnlBeGlzLFxuICAgICAgICAgICAgICBmID0gYS5vcHRpb25zO1xuXG4gICAgICAgICAgaWYgKGEudHlwZSA9PT0gZC50eXBlICYmIChhLnZpc2libGUgfHwgIWQuY2hhcnQub3B0aW9ucy5jaGFydC5pZ25vcmVIaWRkZW5TZXJpZXMpICYmIHIubGVuID09PSBlLmxlbiAmJiByLnBvcyA9PT0gZS5wb3MpIHtcbiAgICAgICAgICAgIGlmIChmLnN0YWNraW5nKSB7XG4gICAgICAgICAgICAgIGMgPSBhLnN0YWNrS2V5O1xuICAgICAgICAgICAgICBcInVuZGVmaW5lZFwiID09PSB0eXBlb2Yga1tjXSAmJiAoa1tjXSA9IG4rKyk7XG4gICAgICAgICAgICAgIHZhciBoID0ga1tjXTtcbiAgICAgICAgICAgIH0gZWxzZSAhMSAhPT0gZi5ncm91cGluZyAmJiAoaCA9IG4rKyk7XG5cbiAgICAgICAgICAgIGEuY29sdW1uSW5kZXggPSBoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBmID0gTWF0aC5taW4oTWF0aC5hYnMocS50cmFuc0EpICogKHEub3JkaW5hbFNsb3BlIHx8IGcucG9pbnRSYW5nZSB8fCBxLmNsb3Nlc3RQb2ludFJhbmdlIHx8IHEudGlja0ludGVydmFsIHx8IDEpLCBxLmxlbiksXG4gICAgICAgICAgICBhID0gZiAqIGcuZ3JvdXBQYWRkaW5nLFxuICAgICAgICAgICAgbCA9IChmIC0gMiAqIGEpIC8gKG4gfHwgMSk7XG4gICAgICAgIGcgPSBNYXRoLm1pbihnLm1heFBvaW50V2lkdGggfHwgcS5sZW4sIHQoZy5wb2ludFdpZHRoLCBsICogKDEgLSAyICogZy5wb2ludFBhZGRpbmcpKSk7XG4gICAgICAgIGQuY29sdW1uTWV0cmljcyA9IHtcbiAgICAgICAgICB3aWR0aDogZyxcbiAgICAgICAgICBvZmZzZXQ6IChsIC0gZykgLyAyICsgKGEgKyAoKGQuY29sdW1uSW5kZXggfHwgMCkgKyAoZSA/IDEgOiAwKSkgKiBsIC0gZiAvIDIpICogKGUgPyAtMSA6IDEpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBkLmNvbHVtbk1ldHJpY3M7XG4gICAgICB9LFxuICAgICAgY3Jpc3BDb2w6IGZ1bmN0aW9uIChkLCBnLCBxLCB0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGMgPSB0aGlzLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgayA9IC0oYyAlIDIgPyAuNSA6IDApO1xuICAgICAgICBjID0gYyAlIDIgPyAuNSA6IDE7XG4gICAgICAgIGUuaW52ZXJ0ZWQgJiYgZS5yZW5kZXJlci5pc1ZNTCAmJiAoYyArPSAxKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmNyaXNwICYmIChxID0gTWF0aC5yb3VuZChkICsgcSkgKyBrLCBkID0gTWF0aC5yb3VuZChkKSArIGssIHEgLT0gZCk7XG4gICAgICAgIHQgPSBNYXRoLnJvdW5kKGcgKyB0KSArIGM7XG4gICAgICAgIGsgPSAuNSA+PSBNYXRoLmFicyhnKSAmJiAuNSA8IHQ7XG4gICAgICAgIGcgPSBNYXRoLnJvdW5kKGcpICsgYztcbiAgICAgICAgdCAtPSBnO1xuICAgICAgICBrICYmIHQgJiYgKC0tZywgdCArPSAxKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBkLFxuICAgICAgICAgIHk6IGcsXG4gICAgICAgICAgd2lkdGg6IHEsXG4gICAgICAgICAgaGVpZ2h0OiB0XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICAgIGcgPSBkLmNoYXJ0LFxuICAgICAgICAgICAgcSA9IGQub3B0aW9ucyxcbiAgICAgICAgICAgIHIgPSBkLmRlbnNlID0gMiA+IGQuY2xvc2VzdFBvaW50UmFuZ2UgKiBkLnhBeGlzLnRyYW5zQTtcbiAgICAgICAgciA9IGQuYm9yZGVyV2lkdGggPSB0KHEuYm9yZGVyV2lkdGgsIHIgPyAwIDogMSk7XG4gICAgICAgIHZhciBlID0gZC54QXhpcyxcbiAgICAgICAgICAgIGMgPSBkLnlBeGlzLFxuICAgICAgICAgICAgayA9IHEudGhyZXNob2xkLFxuICAgICAgICAgICAgbiA9IGQudHJhbnNsYXRlZFRocmVzaG9sZCA9IGMuZ2V0VGhyZXNob2xkKGspLFxuICAgICAgICAgICAgZiA9IHQocS5taW5Qb2ludExlbmd0aCwgNSksXG4gICAgICAgICAgICBhID0gZC5nZXRDb2x1bW5NZXRyaWNzKCksXG4gICAgICAgICAgICBsID0gYS53aWR0aCxcbiAgICAgICAgICAgIHYgPSBkLmJhclcgPSBNYXRoLm1heChsLCAxICsgMiAqIHIpLFxuICAgICAgICAgICAgeiA9IGQucG9pbnRYT2Zmc2V0ID0gYS5vZmZzZXQsXG4gICAgICAgICAgICB3ID0gZC5kYXRhTWluLFxuICAgICAgICAgICAgdSA9IGQuZGF0YU1heDtcbiAgICAgICAgZy5pbnZlcnRlZCAmJiAobiAtPSAuNSk7XG4gICAgICAgIHEucG9pbnRQYWRkaW5nICYmICh2ID0gTWF0aC5jZWlsKHYpKTtcbiAgICAgICAgRC5wcm90b3R5cGUudHJhbnNsYXRlLmFwcGx5KGQpO1xuICAgICAgICBkLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgdmFyIGggPSB0KGEueUJvdHRvbSwgbiksXG4gICAgICAgICAgICAgIHEgPSA5OTkgKyBNYXRoLmFicyhoKSxcbiAgICAgICAgICAgICAgciA9IGwsXG4gICAgICAgICAgICAgIHAgPSBhLnBsb3RYO1xuICAgICAgICAgIHEgPSBFKGEucGxvdFksIC1xLCBjLmxlbiArIHEpO1xuICAgICAgICAgIHZhciBiID0gYS5wbG90WCArIHosXG4gICAgICAgICAgICAgIEIgPSB2LFxuICAgICAgICAgICAgICB4ID0gTWF0aC5taW4ocSwgaCksXG4gICAgICAgICAgICAgIHkgPSBNYXRoLm1heChxLCBoKSAtIHg7XG5cbiAgICAgICAgICBpZiAoZiAmJiBNYXRoLmFicyh5KSA8IGYpIHtcbiAgICAgICAgICAgIHkgPSBmO1xuICAgICAgICAgICAgdmFyIEwgPSAhYy5yZXZlcnNlZCAmJiAhYS5uZWdhdGl2ZSB8fCBjLnJldmVyc2VkICYmIGEubmVnYXRpdmU7XG4gICAgICAgICAgICBhLnkgPT09IGsgJiYgZC5kYXRhTWF4IDw9IGsgJiYgYy5taW4gPCBrICYmIHcgIT09IHUgJiYgKEwgPSAhTCk7XG4gICAgICAgICAgICB4ID0gTWF0aC5hYnMoeCAtIG4pID4gZiA/IGggLSBmIDogbiAtIChMID8gZiA6IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEEoYS5vcHRpb25zLnBvaW50V2lkdGgpICYmIChyID0gQiA9IE1hdGguY2VpbChhLm9wdGlvbnMucG9pbnRXaWR0aCksIGIgLT0gTWF0aC5yb3VuZCgociAtIGwpIC8gMikpO1xuICAgICAgICAgIGEuYmFyWCA9IGI7XG4gICAgICAgICAgYS5wb2ludFdpZHRoID0gcjtcbiAgICAgICAgICBhLnRvb2x0aXBQb3MgPSBnLmludmVydGVkID8gW2MubGVuICsgYy5wb3MgLSBnLnBsb3RMZWZ0IC0gcSwgZS5sZW4gKyBlLnBvcyAtIGcucGxvdFRvcCAtIChwIHx8IDApIC0geiAtIEIgLyAyLCB5XSA6IFtiICsgQiAvIDIsIHEgKyBjLnBvcyAtIGcucGxvdFRvcCwgeV07XG4gICAgICAgICAgYS5zaGFwZVR5cGUgPSBkLnBvaW50Q2xhc3MucHJvdG90eXBlLnNoYXBlVHlwZSB8fCBcInJlY3RcIjtcbiAgICAgICAgICBhLnNoYXBlQXJncyA9IGQuY3Jpc3BDb2wuYXBwbHkoZCwgYS5pc051bGwgPyBbYiwgbiwgQiwgMF0gOiBbYiwgeCwgQiwgeV0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZXRTeW1ib2w6IGQubm9vcCxcbiAgICAgIGRyYXdMZWdlbmRTeW1ib2w6IHIuZHJhd1JlY3RhbmdsZSxcbiAgICAgIGRyYXdHcmFwaDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdyb3VwW3RoaXMuZGVuc2UgPyBcImFkZENsYXNzXCIgOiBcInJlbW92ZUNsYXNzXCJdKFwiaGlnaGNoYXJ0cy1kZW5zZS1kYXRhXCIpO1xuICAgICAgfSxcbiAgICAgIHBvaW50QXR0cmliczogZnVuY3Rpb24gKGQsIGcpIHtcbiAgICAgICAgdmFyIGggPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICByID0gdGhpcy5wb2ludEF0dHJUb09wdGlvbnMgfHwge307XG4gICAgICAgIHZhciBlID0gci5zdHJva2UgfHwgXCJib3JkZXJDb2xvclwiO1xuICAgICAgICB2YXIgYyA9IHJbXCJzdHJva2Utd2lkdGhcIl0gfHwgXCJib3JkZXJXaWR0aFwiLFxuICAgICAgICAgICAgayA9IGQgJiYgZC5jb2xvciB8fCB0aGlzLmNvbG9yLFxuICAgICAgICAgICAgbiA9IGQgJiYgZFtlXSB8fCBoW2VdIHx8IHRoaXMuY29sb3IgfHwgayxcbiAgICAgICAgICAgIGYgPSBkICYmIGRbY10gfHwgaFtjXSB8fCB0aGlzW2NdIHx8IDA7XG4gICAgICAgIHIgPSBkICYmIGQub3B0aW9ucy5kYXNoU3R5bGUgfHwgaC5kYXNoU3R5bGU7XG4gICAgICAgIHZhciBhID0gdChkICYmIGQub3BhY2l0eSwgaC5vcGFjaXR5LCAxKTtcblxuICAgICAgICBpZiAoZCAmJiB0aGlzLnpvbmVzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBsID0gZC5nZXRab25lKCk7XG4gICAgICAgICAgayA9IGQub3B0aW9ucy5jb2xvciB8fCBsICYmIChsLmNvbG9yIHx8IGQubm9uWm9uZWRDb2xvcikgfHwgdGhpcy5jb2xvcjtcbiAgICAgICAgICBsICYmIChuID0gbC5ib3JkZXJDb2xvciB8fCBuLCByID0gbC5kYXNoU3R5bGUgfHwgciwgZiA9IGwuYm9yZGVyV2lkdGggfHwgZik7XG4gICAgICAgIH1cblxuICAgICAgICBnICYmIGQgJiYgKGQgPSB5KGguc3RhdGVzW2ddLCBkLm9wdGlvbnMuc3RhdGVzICYmIGQub3B0aW9ucy5zdGF0ZXNbZ10gfHwge30pLCBnID0gZC5icmlnaHRuZXNzLCBrID0gZC5jb2xvciB8fCBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZyAmJiBJKGspLmJyaWdodGVuKGQuYnJpZ2h0bmVzcykuZ2V0KCkgfHwgaywgbiA9IGRbZV0gfHwgbiwgZiA9IGRbY10gfHwgZiwgciA9IGQuZGFzaFN0eWxlIHx8IHIsIGEgPSB0KGQub3BhY2l0eSwgYSkpO1xuICAgICAgICBlID0ge1xuICAgICAgICAgIGZpbGw6IGssXG4gICAgICAgICAgc3Ryb2tlOiBuLFxuICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IGYsXG4gICAgICAgICAgb3BhY2l0eTogYVxuICAgICAgICB9O1xuICAgICAgICByICYmIChlLmRhc2hzdHlsZSA9IHIpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0sXG4gICAgICBkcmF3UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICAgIGcgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgcSA9IGQub3B0aW9ucyxcbiAgICAgICAgICAgIHQgPSBnLnJlbmRlcmVyLFxuICAgICAgICAgICAgZSA9IHEuYW5pbWF0aW9uTGltaXQgfHwgMjUwLFxuICAgICAgICAgICAgYztcbiAgICAgICAgZC5wb2ludHMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgIHZhciBoID0gay5ncmFwaGljLFxuICAgICAgICAgICAgICBmID0gISFoLFxuICAgICAgICAgICAgICBhID0gaCAmJiBnLnBvaW50Q291bnQgPCBlID8gXCJhbmltYXRlXCIgOiBcImF0dHJcIjtcblxuICAgICAgICAgIGlmIChKKGsucGxvdFkpICYmIG51bGwgIT09IGsueSkge1xuICAgICAgICAgICAgYyA9IGsuc2hhcGVBcmdzO1xuICAgICAgICAgICAgaCAmJiBrLmhhc05ld1NoYXBlVHlwZSgpICYmIChoID0gaC5kZXN0cm95KCkpO1xuICAgICAgICAgICAgZC5lbmFibGVkRGF0YVNvcnRpbmcgJiYgKGsuc3RhcnRYUG9zID0gZC54QXhpcy5yZXZlcnNlZCA/IC0oYyA/IGMud2lkdGggOiAwKSA6IGQueEF4aXMud2lkdGgpO1xuICAgICAgICAgICAgaCB8fCAoay5ncmFwaGljID0gaCA9IHRbay5zaGFwZVR5cGVdKGMpLmFkZChrLmdyb3VwIHx8IGQuZ3JvdXApKSAmJiBkLmVuYWJsZWREYXRhU29ydGluZyAmJiBnLmhhc1JlbmRlcmVkICYmIGcucG9pbnRDb3VudCA8IGUgJiYgKGguYXR0cih7XG4gICAgICAgICAgICAgIHg6IGsuc3RhcnRYUG9zXG4gICAgICAgICAgICB9KSwgZiA9ICEwLCBhID0gXCJhbmltYXRlXCIpO1xuICAgICAgICAgICAgaWYgKGggJiYgZikgaFthXSh5KGMpKTtcbiAgICAgICAgICAgIGlmIChxLmJvcmRlclJhZGl1cykgaFthXSh7XG4gICAgICAgICAgICAgIHI6IHEuYm9yZGVyUmFkaXVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGcuc3R5bGVkTW9kZSB8fCBoW2FdKGQucG9pbnRBdHRyaWJzKGssIGsuc2VsZWN0ZWQgJiYgXCJzZWxlY3RcIikpLnNoYWRvdyghMSAhPT0gay5hbGxvd1NoYWRvdyAmJiBxLnNoYWRvdywgbnVsbCwgcS5zdGFja2luZyAmJiAhcS5ib3JkZXJSYWRpdXMpO1xuICAgICAgICAgICAgaC5hZGRDbGFzcyhrLmdldENsYXNzTmFtZSgpLCAhMCk7XG4gICAgICAgICAgfSBlbHNlIGggJiYgKGsuZ3JhcGhpYyA9IGguZGVzdHJveSgpKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgYW5pbWF0ZTogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIGggPSB0aGlzLFxuICAgICAgICAgICAgZyA9IHRoaXMueUF4aXMsXG4gICAgICAgICAgICB0ID0gaC5vcHRpb25zLFxuICAgICAgICAgICAgZSA9IHRoaXMuY2hhcnQuaW52ZXJ0ZWQsXG4gICAgICAgICAgICBjID0ge30sXG4gICAgICAgICAgICBrID0gZSA/IFwidHJhbnNsYXRlWFwiIDogXCJ0cmFuc2xhdGVZXCI7XG4gICAgICAgIGlmIChkKSBjLnNjYWxlWSA9IC4wMDEsIGQgPSBFKGcudG9QaXhlbHModC50aHJlc2hvbGQpLCBnLnBvcywgZy5wb3MgKyBnLmxlbiksIGUgPyBjLnRyYW5zbGF0ZVggPSBkIC0gZy5sZW4gOiBjLnRyYW5zbGF0ZVkgPSBkLCBoLmNsaXBCb3ggJiYgaC5zZXRDbGlwKCksIGguZ3JvdXAuYXR0cihjKTtlbHNlIHtcbiAgICAgICAgICB2YXIgbiA9IGguZ3JvdXAuYXR0cihrKTtcbiAgICAgICAgICBoLmdyb3VwLmFuaW1hdGUoe1xuICAgICAgICAgICAgc2NhbGVZOiAxXG4gICAgICAgICAgfSwgRyhNKGgub3B0aW9ucy5hbmltYXRpb24pLCB7XG4gICAgICAgICAgICBzdGVwOiBmdW5jdGlvbiAoZSwgYSkge1xuICAgICAgICAgICAgICBoLmdyb3VwICYmIChjW2tdID0gbiArIGEucG9zICogKGcucG9zIC0gbiksIGguZ3JvdXAuYXR0cihjKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICAgIGcgPSBkLmNoYXJ0O1xuICAgICAgICBnLmhhc1JlbmRlcmVkICYmIGcuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICBoLnR5cGUgPT09IGQudHlwZSAmJiAoaC5pc0RpcnR5ID0gITApO1xuICAgICAgICB9KTtcbiAgICAgICAgRC5wcm90b3R5cGUucmVtb3ZlLmFwcGx5KGQsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXCJcIjtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9CYXJTZXJpZXMuanNcIiwgW3JbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCkge1xuICAgIGQgPSBkLnNlcmllc1R5cGU7XG4gICAgZChcImJhclwiLCBcImNvbHVtblwiLCBudWxsLCB7XG4gICAgICBpbnZlcnRlZDogITBcbiAgICB9KTtcbiAgICBcIlwiO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL1NjYXR0ZXJTZXJpZXMuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcpIHtcbiAgICB2YXIgciA9IGcuYWRkRXZlbnQ7XG4gICAgZyA9IGcuc2VyaWVzVHlwZTtcbiAgICB2YXIgdSA9IGQuU2VyaWVzO1xuICAgIGcoXCJzY2F0dGVyXCIsIFwibGluZVwiLCB7XG4gICAgICBsaW5lV2lkdGg6IDAsXG4gICAgICBmaW5kTmVhcmVzdFBvaW50Qnk6IFwieHlcIixcbiAgICAgIGppdHRlcjoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LFxuICAgICAgbWFya2VyOiB7XG4gICAgICAgIGVuYWJsZWQ6ICEwXG4gICAgICB9LFxuICAgICAgdG9vbHRpcDoge1xuICAgICAgICBoZWFkZXJGb3JtYXQ6ICc8c3BhbiBzdHlsZT1cImNvbG9yOntwb2ludC5jb2xvcn1cIj5cXHUyNWNmPC9zcGFuPiA8c3BhbiBzdHlsZT1cImZvbnQtc2l6ZTogMTBweFwiPiB7c2VyaWVzLm5hbWV9PC9zcGFuPjxici8+JyxcbiAgICAgICAgcG9pbnRGb3JtYXQ6IFwieDogPGI+e3BvaW50Lnh9PC9iPjxici8+eTogPGI+e3BvaW50Lnl9PC9iPjxici8+XCJcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzb3J0ZWQ6ICExLFxuICAgICAgcmVxdWlyZVNvcnRpbmc6ICExLFxuICAgICAgbm9TaGFyZWRUb29sdGlwOiAhMCxcbiAgICAgIHRyYWNrZXJHcm91cHM6IFtcImdyb3VwXCIsIFwibWFya2VyR3JvdXBcIiwgXCJkYXRhTGFiZWxzR3JvdXBcIl0sXG4gICAgICB0YWtlT3JkaW5hbFBvc2l0aW9uOiAhMSxcbiAgICAgIGRyYXdHcmFwaDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMubGluZVdpZHRoICYmIHUucHJvdG90eXBlLmRyYXdHcmFwaC5jYWxsKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGFwcGx5Sml0dGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICAgIGcgPSB0aGlzLm9wdGlvbnMuaml0dGVyLFxuICAgICAgICAgICAgciA9IHRoaXMucG9pbnRzLmxlbmd0aDtcbiAgICAgICAgZyAmJiB0aGlzLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uICh1LCBFKSB7XG4gICAgICAgICAgW1wieFwiLCBcInlcIl0uZm9yRWFjaChmdW5jdGlvbiAoQSwgeSkge1xuICAgICAgICAgICAgdmFyIHQgPSBcInBsb3RcIiArIEEudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKGdbQV0gJiYgIXUuaXNOdWxsKSB7XG4gICAgICAgICAgICAgIHZhciBEID0gZFtBICsgXCJBeGlzXCJdO1xuICAgICAgICAgICAgICB2YXIgaCA9IGdbQV0gKiBELnRyYW5zQTtcblxuICAgICAgICAgICAgICBpZiAoRCAmJiAhRC5pc0xvZykge1xuICAgICAgICAgICAgICAgIHZhciBHID0gTWF0aC5tYXgoMCwgdVt0XSAtIGgpO1xuICAgICAgICAgICAgICAgIEQgPSBNYXRoLm1pbihELmxlbiwgdVt0XSArIGgpO1xuICAgICAgICAgICAgICAgIHkgPSAxRTQgKiBNYXRoLnNpbihFICsgeSAqIHIpO1xuICAgICAgICAgICAgICAgIHVbdF0gPSBHICsgKEQgLSBHKSAqICh5IC0gTWF0aC5mbG9vcih5KSk7XG4gICAgICAgICAgICAgICAgXCJ4XCIgPT09IEEgJiYgKHUuY2xpZW50WCA9IHUucGxvdFgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHIodSwgXCJhZnRlclRyYW5zbGF0ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmFwcGx5Sml0dGVyICYmIHRoaXMuYXBwbHlKaXR0ZXIoKTtcbiAgICB9KTtcbiAgICBcIlwiO1xuICB9KTtcbiAgUyhyLCBcIm1peGlucy9jZW50ZXJlZC1zZXJpZXMuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcpIHtcbiAgICB2YXIgciA9IGcuaXNOdW1iZXIsXG4gICAgICAgIHUgPSBnLnBpY2ssXG4gICAgICAgIEkgPSBnLnJlbGF0aXZlTGVuZ3RoLFxuICAgICAgICBNID0gZC5kZWcycmFkO1xuICAgIGQuQ2VudGVyZWRTZXJpZXNNaXhpbiA9IHtcbiAgICAgIGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGcgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgciA9IDIgKiAoZC5zbGljZWRPZmZzZXQgfHwgMCksXG4gICAgICAgICAgICBKID0gZy5wbG90V2lkdGggLSAyICogcixcbiAgICAgICAgICAgIHkgPSBnLnBsb3RIZWlnaHQgLSAyICogcixcbiAgICAgICAgICAgIHQgPSBkLmNlbnRlcixcbiAgICAgICAgICAgIEQgPSBNYXRoLm1pbihKLCB5KSxcbiAgICAgICAgICAgIGggPSBkLnNpemUsXG4gICAgICAgICAgICBOID0gZC5pbm5lclNpemUgfHwgMDtcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGggJiYgKGggPSBwYXJzZUZsb2F0KGgpKTtcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIE4gJiYgKE4gPSBwYXJzZUZsb2F0KE4pKTtcbiAgICAgICAgZCA9IFt1KHRbMF0sIFwiNTAlXCIpLCB1KHRbMV0sIFwiNTAlXCIpLCB1KGggJiYgMCA+IGggPyB2b2lkIDAgOiBkLnNpemUsIFwiMTAwJVwiKSwgdShOICYmIDAgPiBOID8gdm9pZCAwIDogZC5pbm5lclNpemUgfHwgMCwgXCIwJVwiKV07XG4gICAgICAgIGcuYW5ndWxhciAmJiAoZFszXSA9IDApO1xuXG4gICAgICAgIGZvciAodCA9IDA7IDQgPiB0OyArK3QpIGggPSBkW3RdLCBnID0gMiA+IHQgfHwgMiA9PT0gdCAmJiAvJSQvLnRlc3QoaCksIGRbdF0gPSBJKGgsIFtKLCB5LCBELCBkWzJdXVt0XSkgKyAoZyA/IHIgOiAwKTtcblxuICAgICAgICBkWzNdID4gZFsyXSAmJiAoZFszXSA9IGRbMl0pO1xuICAgICAgICByZXR1cm4gZDtcbiAgICAgIH0sXG4gICAgICBnZXRTdGFydEFuZEVuZFJhZGlhbnM6IGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgICAgIGQgPSByKGQpID8gZCA6IDA7XG4gICAgICAgIGcgPSByKGcpICYmIGcgPiBkICYmIDM2MCA+IGcgLSBkID8gZyA6IGQgKyAzNjA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhcnQ6IE0gKiAoZCArIC05MCksXG4gICAgICAgICAgZW5kOiBNICogKGcgKyAtOTApXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9QaWVTZXJpZXMuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wibWl4aW5zL2xlZ2VuZC1zeW1ib2wuanNcIl0sIHJbXCJwYXJ0cy9Qb2ludC5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnLCByLCB1KSB7XG4gICAgdmFyIEkgPSB1LmFkZEV2ZW50LFxuICAgICAgICBNID0gdS5jbGFtcCxcbiAgICAgICAgRSA9IHUuZGVmaW5lZCxcbiAgICAgICAgQSA9IHUuZmlyZUV2ZW50LFxuICAgICAgICBHID0gdS5pc051bWJlcixcbiAgICAgICAgSiA9IHUubWVyZ2UsXG4gICAgICAgIHkgPSB1LnBpY2ssXG4gICAgICAgIHQgPSB1LnJlbGF0aXZlTGVuZ3RoLFxuICAgICAgICBEID0gdS5zZXJpZXNUeXBlLFxuICAgICAgICBoID0gdS5zZXRBbmltYXRpb247XG4gICAgdSA9IGQuQ2VudGVyZWRTZXJpZXNNaXhpbjtcbiAgICB2YXIgTiA9IHUuZ2V0U3RhcnRBbmRFbmRSYWRpYW5zLFxuICAgICAgICBxID0gZC5ub29wLFxuICAgICAgICBQID0gZC5TZXJpZXM7XG4gICAgRChcInBpZVwiLCBcImxpbmVcIiwge1xuICAgICAgY2VudGVyOiBbbnVsbCwgbnVsbF0sXG4gICAgICBjbGlwOiAhMSxcbiAgICAgIGNvbG9yQnlQb2ludDogITAsXG4gICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgIGFsbG93T3ZlcmxhcDogITAsXG4gICAgICAgIGNvbm5lY3RvclBhZGRpbmc6IDUsXG4gICAgICAgIGNvbm5lY3RvclNoYXBlOiBcImZpeGVkT2Zmc2V0XCIsXG4gICAgICAgIGNyb29rRGlzdGFuY2U6IFwiNzAlXCIsXG4gICAgICAgIGRpc3RhbmNlOiAzMCxcbiAgICAgICAgZW5hYmxlZDogITAsXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBvaW50LmlzTnVsbCA/IHZvaWQgMCA6IHRoaXMucG9pbnQubmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc29mdENvbm5lY3RvcjogITAsXG4gICAgICAgIHg6IDBcbiAgICAgIH0sXG4gICAgICBmaWxsQ29sb3I6IHZvaWQgMCxcbiAgICAgIGlnbm9yZUhpZGRlblBvaW50OiAhMCxcbiAgICAgIGluYWN0aXZlT3RoZXJQb2ludHM6ICEwLFxuICAgICAgbGVnZW5kVHlwZTogXCJwb2ludFwiLFxuICAgICAgbWFya2VyOiBudWxsLFxuICAgICAgc2l6ZTogbnVsbCxcbiAgICAgIHNob3dJbkxlZ2VuZDogITEsXG4gICAgICBzbGljZWRPZmZzZXQ6IDEwLFxuICAgICAgc3RpY2t5VHJhY2tpbmc6ICExLFxuICAgICAgdG9vbHRpcDoge1xuICAgICAgICBmb2xsb3dQb2ludGVyOiAhMFxuICAgICAgfSxcbiAgICAgIGJvcmRlckNvbG9yOiBcIiNmZmZmZmZcIixcbiAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgbGluZVdpZHRoOiB2b2lkIDAsXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICBicmlnaHRuZXNzOiAuMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgaXNDYXJ0ZXNpYW46ICExLFxuICAgICAgcmVxdWlyZVNvcnRpbmc6ICExLFxuICAgICAgZGlyZWN0VG91Y2g6ICEwLFxuICAgICAgbm9TaGFyZWRUb29sdGlwOiAhMCxcbiAgICAgIHRyYWNrZXJHcm91cHM6IFtcImdyb3VwXCIsIFwiZGF0YUxhYmVsc0dyb3VwXCJdLFxuICAgICAgYXhpc1R5cGVzOiBbXSxcbiAgICAgIHBvaW50QXR0cmliczogZC5zZXJpZXNUeXBlcy5jb2x1bW4ucHJvdG90eXBlLnBvaW50QXR0cmlicyxcbiAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBjID0gdGhpcyxcbiAgICAgICAgICAgIGQgPSBjLnBvaW50cyxcbiAgICAgICAgICAgIGcgPSBjLnN0YXJ0QW5nbGVSYWQ7XG4gICAgICAgIGUgfHwgZC5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIGEgPSBlLmdyYXBoaWMsXG4gICAgICAgICAgICAgIGYgPSBlLnNoYXBlQXJncztcbiAgICAgICAgICBhICYmIGYgJiYgKGEuYXR0cih7XG4gICAgICAgICAgICByOiB5KGUuc3RhcnRSLCBjLmNlbnRlciAmJiBjLmNlbnRlclszXSAvIDIpLFxuICAgICAgICAgICAgc3RhcnQ6IGcsXG4gICAgICAgICAgICBlbmQ6IGdcbiAgICAgICAgICB9KSwgYS5hbmltYXRlKHtcbiAgICAgICAgICAgIHI6IGYucixcbiAgICAgICAgICAgIHN0YXJ0OiBmLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBmLmVuZFxuICAgICAgICAgIH0sIGMub3B0aW9ucy5hbmltYXRpb24pKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgaGFzRGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnByb2Nlc3NlZFhEYXRhLmxlbmd0aDtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVUb3RhbHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUsXG4gICAgICAgICAgICBjID0gMCxcbiAgICAgICAgICAgIGQgPSB0aGlzLnBvaW50cyxcbiAgICAgICAgICAgIGcgPSBkLmxlbmd0aCxcbiAgICAgICAgICAgIGYgPSB0aGlzLm9wdGlvbnMuaWdub3JlSGlkZGVuUG9pbnQ7XG5cbiAgICAgICAgZm9yIChlID0gMDsgZSA8IGc7IGUrKykge1xuICAgICAgICAgIHZhciBhID0gZFtlXTtcbiAgICAgICAgICBjICs9IGYgJiYgIWEudmlzaWJsZSA/IDAgOiBhLmlzTnVsbCA/IDAgOiBhLnk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRvdGFsID0gYztcblxuICAgICAgICBmb3IgKGUgPSAwOyBlIDwgZzsgZSsrKSBhID0gZFtlXSwgYS5wZXJjZW50YWdlID0gMCA8IGMgJiYgKGEudmlzaWJsZSB8fCAhZikgPyBhLnkgLyBjICogMTAwIDogMCwgYS50b3RhbCA9IGM7XG4gICAgICB9LFxuICAgICAgZ2VuZXJhdGVQb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgUC5wcm90b3R5cGUuZ2VuZXJhdGVQb2ludHMuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVUb3RhbHMoKTtcbiAgICAgIH0sXG4gICAgICBnZXRYOiBmdW5jdGlvbiAoZSwgYywgZCkge1xuICAgICAgICB2YXIgayA9IHRoaXMuY2VudGVyLFxuICAgICAgICAgICAgZiA9IHRoaXMucmFkaWkgPyB0aGlzLnJhZGlpW2QuaW5kZXhdIDoga1syXSAvIDI7XG4gICAgICAgIGUgPSBNYXRoLmFzaW4oTSgoZSAtIGtbMV0pIC8gKGYgKyBkLmxhYmVsRGlzdGFuY2UpLCAtMSwgMSkpO1xuICAgICAgICByZXR1cm4ga1swXSArIChjID8gLTEgOiAxKSAqIE1hdGguY29zKGUpICogKGYgKyBkLmxhYmVsRGlzdGFuY2UpICsgKDAgPCBkLmxhYmVsRGlzdGFuY2UgPyAoYyA/IC0xIDogMSkgKiB0aGlzLm9wdGlvbnMuZGF0YUxhYmVscy5wYWRkaW5nIDogMCk7XG4gICAgICB9LFxuICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLmdlbmVyYXRlUG9pbnRzKCk7XG4gICAgICAgIHZhciBjID0gMCxcbiAgICAgICAgICAgIGQgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBnID0gZC5zbGljZWRPZmZzZXQsXG4gICAgICAgICAgICBmID0gZyArIChkLmJvcmRlcldpZHRoIHx8IDApLFxuICAgICAgICAgICAgYSA9IE4oZC5zdGFydEFuZ2xlLCBkLmVuZEFuZ2xlKSxcbiAgICAgICAgICAgIGggPSB0aGlzLnN0YXJ0QW5nbGVSYWQgPSBhLnN0YXJ0O1xuICAgICAgICBhID0gKHRoaXMuZW5kQW5nbGVSYWQgPSBhLmVuZCkgLSBoO1xuICAgICAgICB2YXIgdiA9IHRoaXMucG9pbnRzLFxuICAgICAgICAgICAgcSA9IGQuZGF0YUxhYmVscy5kaXN0YW5jZTtcbiAgICAgICAgZCA9IGQuaWdub3JlSGlkZGVuUG9pbnQ7XG4gICAgICAgIHZhciB3LFxuICAgICAgICAgICAgciA9IHYubGVuZ3RoO1xuICAgICAgICBlIHx8ICh0aGlzLmNlbnRlciA9IGUgPSB0aGlzLmdldENlbnRlcigpKTtcblxuICAgICAgICBmb3IgKHcgPSAwOyB3IDwgcjsgdysrKSB7XG4gICAgICAgICAgdmFyIHUgPSB2W3ddO1xuICAgICAgICAgIHZhciBEID0gaCArIGMgKiBhO1xuICAgICAgICAgIGlmICghZCB8fCB1LnZpc2libGUpIGMgKz0gdS5wZXJjZW50YWdlIC8gMTAwO1xuICAgICAgICAgIHZhciBIID0gaCArIGMgKiBhO1xuICAgICAgICAgIHUuc2hhcGVUeXBlID0gXCJhcmNcIjtcbiAgICAgICAgICB1LnNoYXBlQXJncyA9IHtcbiAgICAgICAgICAgIHg6IGVbMF0sXG4gICAgICAgICAgICB5OiBlWzFdLFxuICAgICAgICAgICAgcjogZVsyXSAvIDIsXG4gICAgICAgICAgICBpbm5lclI6IGVbM10gLyAyLFxuICAgICAgICAgICAgc3RhcnQ6IE1hdGgucm91bmQoMUUzICogRCkgLyAxRTMsXG4gICAgICAgICAgICBlbmQ6IE1hdGgucm91bmQoMUUzICogSCkgLyAxRTNcbiAgICAgICAgICB9O1xuICAgICAgICAgIHUubGFiZWxEaXN0YW5jZSA9IHkodS5vcHRpb25zLmRhdGFMYWJlbHMgJiYgdS5vcHRpb25zLmRhdGFMYWJlbHMuZGlzdGFuY2UsIHEpO1xuICAgICAgICAgIHUubGFiZWxEaXN0YW5jZSA9IHQodS5sYWJlbERpc3RhbmNlLCB1LnNoYXBlQXJncy5yKTtcbiAgICAgICAgICB0aGlzLm1heExhYmVsRGlzdGFuY2UgPSBNYXRoLm1heCh0aGlzLm1heExhYmVsRGlzdGFuY2UgfHwgMCwgdS5sYWJlbERpc3RhbmNlKTtcbiAgICAgICAgICBIID0gKEggKyBEKSAvIDI7XG4gICAgICAgICAgSCA+IDEuNSAqIE1hdGguUEkgPyBIIC09IDIgKiBNYXRoLlBJIDogSCA8IC1NYXRoLlBJIC8gMiAmJiAoSCArPSAyICogTWF0aC5QSSk7XG4gICAgICAgICAgdS5zbGljZWRUcmFuc2xhdGlvbiA9IHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZVg6IE1hdGgucm91bmQoTWF0aC5jb3MoSCkgKiBnKSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6IE1hdGgucm91bmQoTWF0aC5zaW4oSCkgKiBnKVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIEsgPSBNYXRoLmNvcyhIKSAqIGVbMl0gLyAyO1xuICAgICAgICAgIHZhciBwID0gTWF0aC5zaW4oSCkgKiBlWzJdIC8gMjtcbiAgICAgICAgICB1LnRvb2x0aXBQb3MgPSBbZVswXSArIC43ICogSywgZVsxXSArIC43ICogcF07XG4gICAgICAgICAgdS5oYWxmID0gSCA8IC1NYXRoLlBJIC8gMiB8fCBIID4gTWF0aC5QSSAvIDIgPyAxIDogMDtcbiAgICAgICAgICB1LmFuZ2xlID0gSDtcbiAgICAgICAgICBEID0gTWF0aC5taW4oZiwgdS5sYWJlbERpc3RhbmNlIC8gNSk7XG4gICAgICAgICAgdS5sYWJlbFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgbmF0dXJhbDoge1xuICAgICAgICAgICAgICB4OiBlWzBdICsgSyArIE1hdGguY29zKEgpICogdS5sYWJlbERpc3RhbmNlLFxuICAgICAgICAgICAgICB5OiBlWzFdICsgcCArIE1hdGguc2luKEgpICogdS5sYWJlbERpc3RhbmNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmaW5hbFwiOiB7fSxcbiAgICAgICAgICAgIGFsaWdubWVudDogMCA+IHUubGFiZWxEaXN0YW5jZSA/IFwiY2VudGVyXCIgOiB1LmhhbGYgPyBcInJpZ2h0XCIgOiBcImxlZnRcIixcbiAgICAgICAgICAgIGNvbm5lY3RvclBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgIGJyZWFrQXQ6IHtcbiAgICAgICAgICAgICAgICB4OiBlWzBdICsgSyArIE1hdGguY29zKEgpICogRCxcbiAgICAgICAgICAgICAgICB5OiBlWzFdICsgcCArIE1hdGguc2luKEgpICogRFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0b3VjaGluZ1NsaWNlQXQ6IHtcbiAgICAgICAgICAgICAgICB4OiBlWzBdICsgSyxcbiAgICAgICAgICAgICAgICB5OiBlWzFdICsgcFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIEEodGhpcywgXCJhZnRlclRyYW5zbGF0ZVwiKTtcbiAgICAgIH0sXG4gICAgICBkcmF3RW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgaWYgKDAgPT09IHRoaXMudG90YWwpIHtcbiAgICAgICAgICB2YXIgYyA9IHRoaXMuY2VudGVyWzBdO1xuICAgICAgICAgIHZhciBkID0gdGhpcy5jZW50ZXJbMV07XG4gICAgICAgICAgdGhpcy5ncmFwaCB8fCAodGhpcy5ncmFwaCA9IHRoaXMuY2hhcnQucmVuZGVyZXIuY2lyY2xlKGMsIGQsIDApLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1ncmFwaFwiKS5hZGQodGhpcy5ncm91cCkpO1xuICAgICAgICAgIHRoaXMuZ3JhcGguYW5pbWF0ZSh7XG4gICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgY3g6IGMsXG4gICAgICAgICAgICBjeTogZCxcbiAgICAgICAgICAgIHI6IHRoaXMuY2VudGVyWzJdIC8gMixcbiAgICAgICAgICAgIGZpbGw6IGUuZmlsbENvbG9yIHx8IFwibm9uZVwiLFxuICAgICAgICAgICAgc3Ryb2tlOiBlLmNvbG9yIHx8IFwiI2NjY2NjY1wiXG4gICAgICAgICAgfSwgdGhpcy5vcHRpb25zLmFuaW1hdGlvbik7XG4gICAgICAgIH0gZWxzZSB0aGlzLmdyYXBoICYmICh0aGlzLmdyYXBoID0gdGhpcy5ncmFwaC5kZXN0cm95KCkpO1xuICAgICAgfSxcbiAgICAgIHJlZHJhd1BvaW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgICBjID0gZS5jaGFydCxcbiAgICAgICAgICAgIGQgPSBjLnJlbmRlcmVyLFxuICAgICAgICAgICAgZyxcbiAgICAgICAgICAgIGYsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgaCxcbiAgICAgICAgICAgIHYgPSBlLm9wdGlvbnMuc2hhZG93O1xuICAgICAgICB0aGlzLmRyYXdFbXB0eSgpO1xuICAgICAgICAhdiB8fCBlLnNoYWRvd0dyb3VwIHx8IGMuc3R5bGVkTW9kZSB8fCAoZS5zaGFkb3dHcm91cCA9IGQuZyhcInNoYWRvd1wiKS5hdHRyKHtcbiAgICAgICAgICB6SW5kZXg6IC0xXG4gICAgICAgIH0pLmFkZChlLmdyb3VwKSk7XG4gICAgICAgIGUucG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICB2YXIgbCA9IHt9O1xuICAgICAgICAgIGYgPSBrLmdyYXBoaWM7XG5cbiAgICAgICAgICBpZiAoIWsuaXNOdWxsICYmIGYpIHtcbiAgICAgICAgICAgIGggPSBrLnNoYXBlQXJncztcbiAgICAgICAgICAgIGcgPSBrLmdldFRyYW5zbGF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAoIWMuc3R5bGVkTW9kZSkge1xuICAgICAgICAgICAgICB2YXIgbiA9IGsuc2hhZG93R3JvdXA7XG4gICAgICAgICAgICAgIHYgJiYgIW4gJiYgKG4gPSBrLnNoYWRvd0dyb3VwID0gZC5nKFwic2hhZG93XCIpLmFkZChlLnNoYWRvd0dyb3VwKSk7XG4gICAgICAgICAgICAgIG4gJiYgbi5hdHRyKGcpO1xuICAgICAgICAgICAgICBhID0gZS5wb2ludEF0dHJpYnMoaywgay5zZWxlY3RlZCAmJiBcInNlbGVjdFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgay5kZWxheWVkUmVuZGVyaW5nID8gKGYuc2V0UmFkaWFsUmVmZXJlbmNlKGUuY2VudGVyKS5hdHRyKGgpLmF0dHIoZyksIGMuc3R5bGVkTW9kZSB8fCBmLmF0dHIoYSkuYXR0cih7XG4gICAgICAgICAgICAgIFwic3Ryb2tlLWxpbmVqb2luXCI6IFwicm91bmRcIlxuICAgICAgICAgICAgfSkuc2hhZG93KHYsIG4pLCBrLmRlbGF5ZWRSZW5kZXJpbmcgPSAhMSkgOiAoZi5zZXRSYWRpYWxSZWZlcmVuY2UoZS5jZW50ZXIpLCBjLnN0eWxlZE1vZGUgfHwgSighMCwgbCwgYSksIEooITAsIGwsIGgsIGcpLCBmLmFuaW1hdGUobCkpO1xuICAgICAgICAgICAgZi5hdHRyKHtcbiAgICAgICAgICAgICAgdmlzaWJpbGl0eTogay52aXNpYmxlID8gXCJpbmhlcml0XCIgOiBcImhpZGRlblwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGYuYWRkQ2xhc3Moay5nZXRDbGFzc05hbWUoKSk7XG4gICAgICAgICAgfSBlbHNlIGYgJiYgKGsuZ3JhcGhpYyA9IGYuZGVzdHJveSgpKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZHJhd1BvaW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuY2hhcnQucmVuZGVyZXI7XG4gICAgICAgIHRoaXMucG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBjLmdyYXBoaWMgJiYgYy5oYXNOZXdTaGFwZVR5cGUoKSAmJiAoYy5ncmFwaGljID0gYy5ncmFwaGljLmRlc3Ryb3koKSk7XG4gICAgICAgICAgYy5ncmFwaGljIHx8IChjLmdyYXBoaWMgPSBlW2Muc2hhcGVUeXBlXShjLnNoYXBlQXJncykuYWRkKGMuc2VyaWVzLmdyb3VwKSwgYy5kZWxheWVkUmVuZGVyaW5nID0gITApO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzZWFyY2hQb2ludDogcSxcbiAgICAgIHNvcnRCeUFuZ2xlOiBmdW5jdGlvbiAoZSwgYykge1xuICAgICAgICBlLnNvcnQoZnVuY3Rpb24gKGUsIGQpIHtcbiAgICAgICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGUuYW5nbGUgJiYgKGQuYW5nbGUgLSBlLmFuZ2xlKSAqIGM7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGRyYXdMZWdlbmRTeW1ib2w6IGcuZHJhd1JlY3RhbmdsZSxcbiAgICAgIGdldENlbnRlcjogdS5nZXRDZW50ZXIsXG4gICAgICBnZXRTeW1ib2w6IHEsXG4gICAgICBkcmF3R3JhcGg6IG51bGxcbiAgICB9LCB7XG4gICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHIucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICBlLm5hbWUgPSB5KGUubmFtZSwgXCJTbGljZVwiKTtcblxuICAgICAgICB2YXIgYyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgZS5zbGljZShcInNlbGVjdFwiID09PSBjLnR5cGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIEkoZSwgXCJzZWxlY3RcIiwgYyk7XG4gICAgICAgIEkoZSwgXCJ1bnNlbGVjdFwiLCBjKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9LFxuICAgICAgaXNWYWxpZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRyh0aGlzLnkpICYmIDAgPD0gdGhpcy55O1xuICAgICAgfSxcbiAgICAgIHNldFZpc2libGU6IGZ1bmN0aW9uIChlLCBjKSB7XG4gICAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICAgIGcgPSBkLnNlcmllcyxcbiAgICAgICAgICAgIGYgPSBnLmNoYXJ0LFxuICAgICAgICAgICAgYSA9IGcub3B0aW9ucy5pZ25vcmVIaWRkZW5Qb2ludDtcbiAgICAgICAgYyA9IHkoYywgYSk7XG4gICAgICAgIGUgIT09IGQudmlzaWJsZSAmJiAoZC52aXNpYmxlID0gZC5vcHRpb25zLnZpc2libGUgPSBlID0gXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGUgPyAhZC52aXNpYmxlIDogZSwgZy5vcHRpb25zLmRhdGFbZy5kYXRhLmluZGV4T2YoZCldID0gZC5vcHRpb25zLCBbXCJncmFwaGljXCIsIFwiZGF0YUxhYmVsXCIsIFwiY29ubmVjdG9yXCIsIFwic2hhZG93R3JvdXBcIl0uZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGlmIChkW2FdKSBkW2FdW2UgPyBcInNob3dcIiA6IFwiaGlkZVwiXSghMCk7XG4gICAgICAgIH0pLCBkLmxlZ2VuZEl0ZW0gJiYgZi5sZWdlbmQuY29sb3JpemVJdGVtKGQsIGUpLCBlIHx8IFwiaG92ZXJcIiAhPT0gZC5zdGF0ZSB8fCBkLnNldFN0YXRlKFwiXCIpLCBhICYmIChnLmlzRGlydHkgPSAhMCksIGMgJiYgZi5yZWRyYXcoKSk7XG4gICAgICB9LFxuICAgICAgc2xpY2U6IGZ1bmN0aW9uIChlLCBjLCBkKSB7XG4gICAgICAgIHZhciBnID0gdGhpcy5zZXJpZXM7XG4gICAgICAgIGgoZCwgZy5jaGFydCk7XG4gICAgICAgIHkoYywgITApO1xuICAgICAgICB0aGlzLnNsaWNlZCA9IHRoaXMub3B0aW9ucy5zbGljZWQgPSBFKGUpID8gZSA6ICF0aGlzLnNsaWNlZDtcbiAgICAgICAgZy5vcHRpb25zLmRhdGFbZy5kYXRhLmluZGV4T2YodGhpcyldID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB0aGlzLmdyYXBoaWMuYW5pbWF0ZSh0aGlzLmdldFRyYW5zbGF0ZSgpKTtcbiAgICAgICAgdGhpcy5zaGFkb3dHcm91cCAmJiB0aGlzLnNoYWRvd0dyb3VwLmFuaW1hdGUodGhpcy5nZXRUcmFuc2xhdGUoKSk7XG4gICAgICB9LFxuICAgICAgZ2V0VHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNsaWNlZCA/IHRoaXMuc2xpY2VkVHJhbnNsYXRpb24gOiB7XG4gICAgICAgICAgdHJhbnNsYXRlWDogMCxcbiAgICAgICAgICB0cmFuc2xhdGVZOiAwXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgaGFsb1BhdGg6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5zaGFwZUFyZ3M7XG4gICAgICAgIHJldHVybiB0aGlzLnNsaWNlZCB8fCAhdGhpcy52aXNpYmxlID8gW10gOiB0aGlzLnNlcmllcy5jaGFydC5yZW5kZXJlci5zeW1ib2xzLmFyYyhjLngsIGMueSwgYy5yICsgZSwgYy5yICsgZSwge1xuICAgICAgICAgIGlubmVyUjogYy5yIC0gMSxcbiAgICAgICAgICBzdGFydDogYy5zdGFydCxcbiAgICAgICAgICBlbmQ6IGMuZW5kXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGNvbm5lY3RvclNoYXBlczoge1xuICAgICAgICBmaXhlZE9mZnNldDogZnVuY3Rpb24gKGUsIGMsIGQpIHtcbiAgICAgICAgICB2YXIgZyA9IGMuYnJlYWtBdDtcbiAgICAgICAgICBjID0gYy50b3VjaGluZ1NsaWNlQXQ7XG4gICAgICAgICAgcmV0dXJuIFtcIk1cIiwgZS54LCBlLnldLmNvbmNhdChkLnNvZnRDb25uZWN0b3IgPyBbXCJDXCIsIGUueCArIChcImxlZnRcIiA9PT0gZS5hbGlnbm1lbnQgPyAtNSA6IDUpLCBlLnksIDIgKiBnLnggLSBjLngsIDIgKiBnLnkgLSBjLnksIGcueCwgZy55XSA6IFtcIkxcIiwgZy54LCBnLnldKS5jb25jYXQoW1wiTFwiLCBjLngsIGMueV0pO1xuICAgICAgICB9LFxuICAgICAgICBzdHJhaWdodDogZnVuY3Rpb24gKGUsIGMpIHtcbiAgICAgICAgICBjID0gYy50b3VjaGluZ1NsaWNlQXQ7XG4gICAgICAgICAgcmV0dXJuIFtcIk1cIiwgZS54LCBlLnksIFwiTFwiLCBjLngsIGMueV07XG4gICAgICAgIH0sXG4gICAgICAgIGNyb29rZWRMaW5lOiBmdW5jdGlvbiAoZSwgYywgZCkge1xuICAgICAgICAgIGMgPSBjLnRvdWNoaW5nU2xpY2VBdDtcbiAgICAgICAgICB2YXIgZyA9IHRoaXMuc2VyaWVzLFxuICAgICAgICAgICAgICBmID0gZy5jZW50ZXJbMF0sXG4gICAgICAgICAgICAgIGEgPSBnLmNoYXJ0LnBsb3RXaWR0aCxcbiAgICAgICAgICAgICAgayA9IGcuY2hhcnQucGxvdExlZnQ7XG4gICAgICAgICAgZyA9IGUuYWxpZ25tZW50O1xuICAgICAgICAgIHZhciBoID0gdGhpcy5zaGFwZUFyZ3MucjtcbiAgICAgICAgICBkID0gdChkLmNyb29rRGlzdGFuY2UsIDEpO1xuICAgICAgICAgIGQgPSBcImxlZnRcIiA9PT0gZyA/IGYgKyBoICsgKGEgKyBrIC0gZiAtIGgpICogKDEgLSBkKSA6IGsgKyAoZiAtIGgpICogZDtcbiAgICAgICAgICBmID0gW1wiTFwiLCBkLCBlLnldO1xuICAgICAgICAgIGlmIChcImxlZnRcIiA9PT0gZyA/IGQgPiBlLnggfHwgZCA8IGMueCA6IGQgPCBlLnggfHwgZCA+IGMueCkgZiA9IFtdO1xuICAgICAgICAgIHJldHVybiBbXCJNXCIsIGUueCwgZS55XS5jb25jYXQoZikuY29uY2F0KFtcIkxcIiwgYy54LCBjLnldKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldENvbm5lY3RvclBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmxhYmVsUG9zaXRpb24sXG4gICAgICAgICAgICBjID0gdGhpcy5zZXJpZXMub3B0aW9ucy5kYXRhTGFiZWxzLFxuICAgICAgICAgICAgZCA9IGMuY29ubmVjdG9yU2hhcGUsXG4gICAgICAgICAgICBnID0gdGhpcy5jb25uZWN0b3JTaGFwZXM7XG4gICAgICAgIGdbZF0gJiYgKGQgPSBnW2RdKTtcbiAgICAgICAgcmV0dXJuIGQuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgeDogZS5maW5hbC54LFxuICAgICAgICAgIHk6IGUuZmluYWwueSxcbiAgICAgICAgICBhbGlnbm1lbnQ6IGUuYWxpZ25tZW50XG4gICAgICAgIH0sIGUuY29ubmVjdG9yUG9zaXRpb24sIGMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFwiXCI7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvRGF0YUxhYmVscy5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZykge1xuICAgIHZhciByID0gZy5hbmltT2JqZWN0LFxuICAgICAgICB1ID0gZy5hcnJheU1heCxcbiAgICAgICAgSSA9IGcuY2xhbXAsXG4gICAgICAgIE0gPSBnLmRlZmluZWQsXG4gICAgICAgIEUgPSBnLmV4dGVuZCxcbiAgICAgICAgQSA9IGcuZm9ybWF0LFxuICAgICAgICBHID0gZy5pc0FycmF5LFxuICAgICAgICBKID0gZy5tZXJnZSxcbiAgICAgICAgeSA9IGcub2JqZWN0RWFjaCxcbiAgICAgICAgdCA9IGcucGljayxcbiAgICAgICAgRCA9IGcucmVsYXRpdmVMZW5ndGgsXG4gICAgICAgIGggPSBnLnNwbGF0LFxuICAgICAgICBOID0gZy5zdGFibGVTb3J0O1xuICAgIGcgPSBkLm5vb3A7XG4gICAgdmFyIHEgPSBkLlNlcmllcyxcbiAgICAgICAgUCA9IGQuc2VyaWVzVHlwZXM7XG5cbiAgICBkLmRpc3RyaWJ1dGUgPSBmdW5jdGlvbiAoZSwgYywgZykge1xuICAgICAgZnVuY3Rpb24gaChhLCBjKSB7XG4gICAgICAgIHJldHVybiBhLnRhcmdldCAtIGMudGFyZ2V0O1xuICAgICAgfVxuXG4gICAgICB2YXIgZixcbiAgICAgICAgICBhID0gITAsXG4gICAgICAgICAgayA9IGUsXG4gICAgICAgICAgdiA9IFtdO1xuICAgICAgdmFyIHEgPSAwO1xuICAgICAgdmFyIHcgPSBrLnJlZHVjZWRMZW4gfHwgYztcblxuICAgICAgZm9yIChmID0gZS5sZW5ndGg7IGYtLTspIHEgKz0gZVtmXS5zaXplO1xuXG4gICAgICBpZiAocSA+IHcpIHtcbiAgICAgICAgTihlLCBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICAgIHJldHVybiAoYy5yYW5rIHx8IDApIC0gKGEucmFuayB8fCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yIChxID0gZiA9IDA7IHEgPD0gdzspIHEgKz0gZVtmXS5zaXplLCBmKys7XG5cbiAgICAgICAgdiA9IGUuc3BsaWNlKGYgLSAxLCBlLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIE4oZSwgaCk7XG5cbiAgICAgIGZvciAoZSA9IGUubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2l6ZTogYS5zaXplLFxuICAgICAgICAgIHRhcmdldHM6IFthLnRhcmdldF0sXG4gICAgICAgICAgYWxpZ246IHQoYS5hbGlnbiwgLjUpXG4gICAgICAgIH07XG4gICAgICB9KTsgYTspIHtcbiAgICAgICAgZm9yIChmID0gZS5sZW5ndGg7IGYtLTspIGEgPSBlW2ZdLCBxID0gKE1hdGgubWluLmFwcGx5KDAsIGEudGFyZ2V0cykgKyBNYXRoLm1heC5hcHBseSgwLCBhLnRhcmdldHMpKSAvIDIsIGEucG9zID0gSShxIC0gYS5zaXplICogYS5hbGlnbiwgMCwgYyAtIGEuc2l6ZSk7XG5cbiAgICAgICAgZiA9IGUubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoYSA9ICExOyBmLS07KSAwIDwgZiAmJiBlW2YgLSAxXS5wb3MgKyBlW2YgLSAxXS5zaXplID4gZVtmXS5wb3MgJiYgKGVbZiAtIDFdLnNpemUgKz0gZVtmXS5zaXplLCBlW2YgLSAxXS50YXJnZXRzID0gZVtmIC0gMV0udGFyZ2V0cy5jb25jYXQoZVtmXS50YXJnZXRzKSwgZVtmIC0gMV0uYWxpZ24gPSAuNSwgZVtmIC0gMV0ucG9zICsgZVtmIC0gMV0uc2l6ZSA+IGMgJiYgKGVbZiAtIDFdLnBvcyA9IGMgLSBlW2YgLSAxXS5zaXplKSwgZS5zcGxpY2UoZiwgMSksIGEgPSAhMCk7XG4gICAgICB9XG5cbiAgICAgIGsucHVzaC5hcHBseShrLCB2KTtcbiAgICAgIGYgPSAwO1xuICAgICAgZS5zb21lKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBlID0gMDtcbiAgICAgICAgaWYgKGEudGFyZ2V0cy5zb21lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBrW2ZdLnBvcyA9IGEucG9zICsgZTtcbiAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGcgJiYgTWF0aC5hYnMoa1tmXS5wb3MgLSBrW2ZdLnRhcmdldCkgPiBnKSByZXR1cm4gay5zbGljZSgwLCBmICsgMSkuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZGVsZXRlIGEucG9zO1xuICAgICAgICAgIH0pLCBrLnJlZHVjZWRMZW4gPSAoay5yZWR1Y2VkTGVuIHx8IGMpIC0gLjEgKiBjLCBrLnJlZHVjZWRMZW4gPiAuMSAqIGMgJiYgZC5kaXN0cmlidXRlKGssIGMsIGcpLCAhMDtcbiAgICAgICAgICBlICs9IGtbZl0uc2l6ZTtcbiAgICAgICAgICBmKys7XG4gICAgICAgIH0pKSByZXR1cm4gITA7XG4gICAgICB9KTtcbiAgICAgIE4oaywgaCk7XG4gICAgfTtcblxuICAgIHEucHJvdG90eXBlLmRyYXdEYXRhTGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gZShhLCBjKSB7XG4gICAgICAgIHZhciBiID0gYy5maWx0ZXI7XG4gICAgICAgIHJldHVybiBiID8gKGMgPSBiLm9wZXJhdG9yLCBhID0gYVtiLnByb3BlcnR5XSwgYiA9IGIudmFsdWUsIFwiPlwiID09PSBjICYmIGEgPiBiIHx8IFwiPFwiID09PSBjICYmIGEgPCBiIHx8IFwiPj1cIiA9PT0gYyAmJiBhID49IGIgfHwgXCI8PVwiID09PSBjICYmIGEgPD0gYiB8fCBcIj09XCIgPT09IGMgJiYgYSA9PSBiIHx8IFwiPT09XCIgPT09IGMgJiYgYSA9PT0gYiA/ICEwIDogITEpIDogITA7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGMoYSwgYykge1xuICAgICAgICB2YXIgYiA9IFtdLFxuICAgICAgICAgICAgZTtcbiAgICAgICAgaWYgKEcoYSkgJiYgIUcoYykpIGIgPSBhLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHJldHVybiBKKGEsIGMpO1xuICAgICAgICB9KTtlbHNlIGlmIChHKGMpICYmICFHKGEpKSBiID0gYy5tYXAoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICByZXR1cm4gSihhLCBiKTtcbiAgICAgICAgfSk7ZWxzZSBpZiAoRyhhKSB8fCBHKGMpKSBmb3IgKGUgPSBNYXRoLm1heChhLmxlbmd0aCwgYy5sZW5ndGgpOyBlLS07KSBiW2VdID0gSihhW2VdLCBjW2VdKTtlbHNlIGIgPSBKKGEsIGMpO1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH1cblxuICAgICAgdmFyIGcgPSB0aGlzLFxuICAgICAgICAgIG4gPSBnLmNoYXJ0LFxuICAgICAgICAgIGYgPSBnLm9wdGlvbnMsXG4gICAgICAgICAgYSA9IGYuZGF0YUxhYmVscyxcbiAgICAgICAgICBsID0gZy5wb2ludHMsXG4gICAgICAgICAgdixcbiAgICAgICAgICBxID0gZy5oYXNSZW5kZXJlZCB8fCAwLFxuICAgICAgICAgIHcgPSByKGYuYW5pbWF0aW9uKS5kdXJhdGlvbixcbiAgICAgICAgICB1ID0gTWF0aC5taW4odywgMjAwKSxcbiAgICAgICAgICBMID0gIW4ucmVuZGVyZXIuZm9yRXhwb3J0ICYmIHQoYS5kZWZlciwgMCA8IHUpLFxuICAgICAgICAgIEQgPSBuLnJlbmRlcmVyO1xuICAgICAgYSA9IGMoYyhuLm9wdGlvbnMucGxvdE9wdGlvbnMgJiYgbi5vcHRpb25zLnBsb3RPcHRpb25zLnNlcmllcyAmJiBuLm9wdGlvbnMucGxvdE9wdGlvbnMuc2VyaWVzLmRhdGFMYWJlbHMsIG4ub3B0aW9ucy5wbG90T3B0aW9ucyAmJiBuLm9wdGlvbnMucGxvdE9wdGlvbnNbZy50eXBlXSAmJiBuLm9wdGlvbnMucGxvdE9wdGlvbnNbZy50eXBlXS5kYXRhTGFiZWxzKSwgYSk7XG4gICAgICBkLmZpcmVFdmVudCh0aGlzLCBcImRyYXdEYXRhTGFiZWxzXCIpO1xuXG4gICAgICBpZiAoRyhhKSB8fCBhLmVuYWJsZWQgfHwgZy5faGFzUG9pbnRMYWJlbHMpIHtcbiAgICAgICAgdmFyIEggPSBnLnBsb3RHcm91cChcImRhdGFMYWJlbHNHcm91cFwiLCBcImRhdGEtbGFiZWxzXCIsIEwgJiYgIXEgPyBcImhpZGRlblwiIDogXCJpbmhlcml0XCIsIGEuekluZGV4IHx8IDYpO1xuICAgICAgICBMICYmIChILmF0dHIoe1xuICAgICAgICAgIG9wYWNpdHk6ICtxXG4gICAgICAgIH0pLCBxIHx8IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhID0gZy5kYXRhTGFiZWxzR3JvdXA7XG4gICAgICAgICAgYSAmJiAoZy52aXNpYmxlICYmIEguc2hvdyghMCksIGFbZi5hbmltYXRpb24gPyBcImFuaW1hdGVcIiA6IFwiYXR0clwiXSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgZHVyYXRpb246IHVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sIHcgLSB1KSk7XG4gICAgICAgIGwuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHYgPSBoKGMoYSwgZC5kbE9wdGlvbnMgfHwgZC5vcHRpb25zICYmIGQub3B0aW9ucy5kYXRhTGFiZWxzKSk7XG4gICAgICAgICAgdi5mb3JFYWNoKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGEuZW5hYmxlZCAmJiAoIWQuaXNOdWxsIHx8IGQuZGF0YUxhYmVsT25OdWxsKSAmJiBlKGQsIGEpLFxuICAgICAgICAgICAgICAgIGggPSBkLmRhdGFMYWJlbHMgPyBkLmRhdGFMYWJlbHNbYl0gOiBkLmRhdGFMYWJlbCxcbiAgICAgICAgICAgICAgICBrID0gZC5jb25uZWN0b3JzID8gZC5jb25uZWN0b3JzW2JdIDogZC5jb25uZWN0b3IsXG4gICAgICAgICAgICAgICAgbCA9IHQoYS5kaXN0YW5jZSwgZC5sYWJlbERpc3RhbmNlKSxcbiAgICAgICAgICAgICAgICBwID0gIWg7XG5cbiAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgIHZhciB2ID0gZC5nZXRMYWJlbENvbmZpZygpO1xuICAgICAgICAgICAgICB2YXIgbSA9IHQoYVtkLmZvcm1hdFByZWZpeCArIFwiRm9ybWF0XCJdLCBhLmZvcm1hdCk7XG4gICAgICAgICAgICAgIHYgPSBNKG0pID8gQShtLCB2LCBuKSA6IChhW2QuZm9ybWF0UHJlZml4ICsgXCJGb3JtYXR0ZXJcIl0gfHwgYS5mb3JtYXR0ZXIpLmNhbGwodiwgYSk7XG4gICAgICAgICAgICAgIG0gPSBhLnN0eWxlO1xuICAgICAgICAgICAgICB2YXIgcSA9IGEucm90YXRpb247XG4gICAgICAgICAgICAgIG4uc3R5bGVkTW9kZSB8fCAobS5jb2xvciA9IHQoYS5jb2xvciwgbS5jb2xvciwgZy5jb2xvciwgXCIjMDAwMDAwXCIpLCBcImNvbnRyYXN0XCIgPT09IG0uY29sb3IgPyAoZC5jb250cmFzdENvbG9yID0gRC5nZXRDb250cmFzdChkLmNvbG9yIHx8IGcuY29sb3IpLCBtLmNvbG9yID0gIU0obCkgJiYgYS5pbnNpZGUgfHwgMCA+IGwgfHwgZi5zdGFja2luZyA/IGQuY29udHJhc3RDb2xvciA6IFwiIzAwMDAwMFwiKSA6IGRlbGV0ZSBkLmNvbnRyYXN0Q29sb3IsIGYuY3Vyc29yICYmIChtLmN1cnNvciA9IGYuY3Vyc29yKSk7XG4gICAgICAgICAgICAgIHZhciB3ID0ge1xuICAgICAgICAgICAgICAgIHI6IGEuYm9yZGVyUmFkaXVzIHx8IDAsXG4gICAgICAgICAgICAgICAgcm90YXRpb246IHEsXG4gICAgICAgICAgICAgICAgcGFkZGluZzogYS5wYWRkaW5nLFxuICAgICAgICAgICAgICAgIHpJbmRleDogMVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBuLnN0eWxlZE1vZGUgfHwgKHcuZmlsbCA9IGEuYmFja2dyb3VuZENvbG9yLCB3LnN0cm9rZSA9IGEuYm9yZGVyQ29sb3IsIHdbXCJzdHJva2Utd2lkdGhcIl0gPSBhLmJvcmRlcldpZHRoKTtcbiAgICAgICAgICAgICAgeSh3LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBhICYmIGRlbGV0ZSB3W2JdO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgIWggfHwgYyAmJiBNKHYpID8gYyAmJiBNKHYpICYmIChoID8gdy50ZXh0ID0gdiA6IChkLmRhdGFMYWJlbHMgPSBkLmRhdGFMYWJlbHMgfHwgW10sIGggPSBkLmRhdGFMYWJlbHNbYl0gPSBxID8gRC50ZXh0KHYsIDAsIC05OTk5LCBhLnVzZUhUTUwpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1kYXRhLWxhYmVsXCIpIDogRC5sYWJlbCh2LCAwLCAtOTk5OSwgYS5zaGFwZSwgbnVsbCwgbnVsbCwgYS51c2VIVE1MLCBudWxsLCBcImRhdGEtbGFiZWxcIiksIGIgfHwgKGQuZGF0YUxhYmVsID0gaCksIGguYWRkQ2xhc3MoXCIgaGlnaGNoYXJ0cy1kYXRhLWxhYmVsLWNvbG9yLVwiICsgZC5jb2xvckluZGV4ICsgXCIgXCIgKyAoYS5jbGFzc05hbWUgfHwgXCJcIikgKyAoYS51c2VIVE1MID8gXCIgaGlnaGNoYXJ0cy10cmFja2VyXCIgOiBcIlwiKSkpLCBoLm9wdGlvbnMgPSBhLCBoLmF0dHIodyksIG4uc3R5bGVkTW9kZSB8fCBoLmNzcyhtKS5zaGFkb3coYS5zaGFkb3cpLCBoLmFkZGVkIHx8IGguYWRkKEgpLCBhLnRleHRQYXRoICYmICFhLnVzZUhUTUwgJiYgKGguc2V0VGV4dFBhdGgoZC5nZXREYXRhTGFiZWxQYXRoICYmIGQuZ2V0RGF0YUxhYmVsUGF0aChoKSB8fCBkLmdyYXBoaWMsIGEudGV4dFBhdGgpLCBkLmRhdGFMYWJlbFBhdGggJiYgIWEudGV4dFBhdGguZW5hYmxlZCAmJiAoZC5kYXRhTGFiZWxQYXRoID0gZC5kYXRhTGFiZWxQYXRoLmRlc3Ryb3koKSkpLCBnLmFsaWduRGF0YUxhYmVsKGQsIGgsIGEsIG51bGwsIHApKSA6IChkLmRhdGFMYWJlbCA9IGQuZGF0YUxhYmVsICYmIGQuZGF0YUxhYmVsLmRlc3Ryb3koKSwgZC5kYXRhTGFiZWxzICYmICgxID09PSBkLmRhdGFMYWJlbHMubGVuZ3RoID8gZGVsZXRlIGQuZGF0YUxhYmVscyA6IGRlbGV0ZSBkLmRhdGFMYWJlbHNbYl0pLCBiIHx8IGRlbGV0ZSBkLmRhdGFMYWJlbCwgayAmJiAoZC5jb25uZWN0b3IgPSBkLmNvbm5lY3Rvci5kZXN0cm95KCksIGQuY29ubmVjdG9ycyAmJiAoMSA9PT0gZC5jb25uZWN0b3JzLmxlbmd0aCA/IGRlbGV0ZSBkLmNvbm5lY3RvcnMgOiBkZWxldGUgZC5jb25uZWN0b3JzW2JdKSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZC5maXJlRXZlbnQodGhpcywgXCJhZnRlckRyYXdEYXRhTGFiZWxzXCIpO1xuICAgIH07XG5cbiAgICBxLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbCA9IGZ1bmN0aW9uIChkLCBjLCBnLCBoLCBmKSB7XG4gICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgZSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgayA9IHRoaXMuaXNDYXJ0ZXNpYW4gJiYgZS5pbnZlcnRlZCxcbiAgICAgICAgICBuID0gdGhpcy5lbmFibGVkRGF0YVNvcnRpbmcsXG4gICAgICAgICAgcSA9IHQoZC5kbEJveCAmJiBkLmRsQm94LmNlbnRlclgsIGQucGxvdFgsIC05OTk5KSxcbiAgICAgICAgICByID0gdChkLnBsb3RZLCAtOTk5OSksXG4gICAgICAgICAgdSA9IGMuZ2V0QkJveCgpLFxuICAgICAgICAgIHkgPSBnLnJvdGF0aW9uLFxuICAgICAgICAgIEEgPSBnLmFsaWduLFxuICAgICAgICAgIEsgPSBlLmlzSW5zaWRlUGxvdChxLCBNYXRoLnJvdW5kKHIpLCBrKSxcbiAgICAgICAgICBwID0gXCJqdXN0aWZ5XCIgPT09IHQoZy5vdmVyZmxvdywgbiA/IFwibm9uZVwiIDogXCJqdXN0aWZ5XCIpLFxuICAgICAgICAgIGIgPSB0aGlzLnZpc2libGUgJiYgITEgIT09IGQudmlzaWJsZSAmJiAoZC5zZXJpZXMuZm9yY2VETCB8fCBuICYmICFwIHx8IEsgfHwgZy5pbnNpZGUgJiYgaCAmJiBlLmlzSW5zaWRlUGxvdChxLCBrID8gaC54ICsgMSA6IGgueSArIGguaGVpZ2h0IC0gMSwgaykpO1xuXG4gICAgICB2YXIgQyA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIG4gJiYgYS54QXhpcyAmJiAhcCAmJiBhLnNldERhdGFMYWJlbFN0YXJ0UG9zKGQsIGMsIGYsIEssIGIpO1xuICAgICAgfTtcblxuICAgICAgaWYgKGIpIHtcbiAgICAgICAgdmFyIHggPSBlLnJlbmRlcmVyLmZvbnRNZXRyaWNzKGUuc3R5bGVkTW9kZSA/IHZvaWQgMCA6IGcuc3R5bGUuZm9udFNpemUsIGMpLmI7XG4gICAgICAgIGggPSBFKHtcbiAgICAgICAgICB4OiBrID8gdGhpcy55QXhpcy5sZW4gLSByIDogcSxcbiAgICAgICAgICB5OiBNYXRoLnJvdW5kKGsgPyB0aGlzLnhBeGlzLmxlbiAtIHEgOiByKSxcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfSwgaCk7XG4gICAgICAgIEUoZywge1xuICAgICAgICAgIHdpZHRoOiB1LndpZHRoLFxuICAgICAgICAgIGhlaWdodDogdS5oZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIHkgPyAocCA9ICExLCBxID0gZS5yZW5kZXJlci5yb3RDb3JyKHgsIHkpLCBxID0ge1xuICAgICAgICAgIHg6IGgueCArIGcueCArIGgud2lkdGggLyAyICsgcS54LFxuICAgICAgICAgIHk6IGgueSArIGcueSArIHtcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIG1pZGRsZTogLjUsXG4gICAgICAgICAgICBib3R0b206IDFcbiAgICAgICAgICB9W2cudmVydGljYWxBbGlnbl0gKiBoLmhlaWdodFxuICAgICAgICB9LCBDKHEpLCBjW2YgPyBcImF0dHJcIiA6IFwiYW5pbWF0ZVwiXShxKS5hdHRyKHtcbiAgICAgICAgICBhbGlnbjogQVxuICAgICAgICB9KSwgQyA9ICh5ICsgNzIwKSAlIDM2MCwgQyA9IDE4MCA8IEMgJiYgMzYwID4gQywgXCJsZWZ0XCIgPT09IEEgPyBxLnkgLT0gQyA/IHUuaGVpZ2h0IDogMCA6IFwiY2VudGVyXCIgPT09IEEgPyAocS54IC09IHUud2lkdGggLyAyLCBxLnkgLT0gdS5oZWlnaHQgLyAyKSA6IFwicmlnaHRcIiA9PT0gQSAmJiAocS54IC09IHUud2lkdGgsIHEueSAtPSBDID8gMCA6IHUuaGVpZ2h0KSwgYy5wbGFjZWQgPSAhMCwgYy5hbGlnbkF0dHIgPSBxKSA6IChDKGgpLCBjLmFsaWduKGcsIG51bGwsIGgpLCBxID0gYy5hbGlnbkF0dHIpO1xuICAgICAgICBwICYmIDAgPD0gaC5oZWlnaHQgPyB0aGlzLmp1c3RpZnlEYXRhTGFiZWwoYywgZywgcSwgdSwgaCwgZikgOiB0KGcuY3JvcCwgITApICYmIChiID0gZS5pc0luc2lkZVBsb3QocS54LCBxLnkpICYmIGUuaXNJbnNpZGVQbG90KHEueCArIHUud2lkdGgsIHEueSArIHUuaGVpZ2h0KSk7XG4gICAgICAgIGlmIChnLnNoYXBlICYmICF5KSBjW2YgPyBcImF0dHJcIiA6IFwiYW5pbWF0ZVwiXSh7XG4gICAgICAgICAgYW5jaG9yWDogayA/IGUucGxvdFdpZHRoIC0gZC5wbG90WSA6IGQucGxvdFgsXG4gICAgICAgICAgYW5jaG9yWTogayA/IGUucGxvdEhlaWdodCAtIGQucGxvdFggOiBkLnBsb3RZXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmICYmIG4gJiYgKGMucGxhY2VkID0gITEpO1xuICAgICAgYiB8fCBuICYmICFwIHx8IChjLmhpZGUoITApLCBjLnBsYWNlZCA9ICExKTtcbiAgICB9O1xuXG4gICAgcS5wcm90b3R5cGUuc2V0RGF0YUxhYmVsU3RhcnRQb3MgPSBmdW5jdGlvbiAoZCwgYywgZywgaCwgZikge1xuICAgICAgdmFyIGEgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgIGUgPSBhLmludmVydGVkLFxuICAgICAgICAgIGsgPSB0aGlzLnhBeGlzLFxuICAgICAgICAgIG4gPSBrLnJldmVyc2VkLFxuICAgICAgICAgIHEgPSBlID8gYy5oZWlnaHQgLyAyIDogYy53aWR0aCAvIDI7XG4gICAgICBkID0gKGQgPSBkLnBvaW50V2lkdGgpID8gZCAvIDIgOiAwO1xuICAgICAgayA9IGUgPyBmLnggOiBuID8gLXEgLSBkIDogay53aWR0aCAtIHEgKyBkO1xuICAgICAgZiA9IGUgPyBuID8gdGhpcy55QXhpcy5oZWlnaHQgLSBxICsgZCA6IC1xIC0gZCA6IGYueTtcbiAgICAgIGMuc3RhcnRYUG9zID0gaztcbiAgICAgIGMuc3RhcnRZUG9zID0gZjtcbiAgICAgIGggPyBcImhpZGRlblwiID09PSBjLnZpc2liaWxpdHkgJiYgKGMuc2hvdygpLCBjLmF0dHIoe1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9KS5hbmltYXRlKHtcbiAgICAgICAgb3BhY2l0eTogMVxuICAgICAgfSkpIDogYy5hdHRyKHtcbiAgICAgICAgb3BhY2l0eTogMVxuICAgICAgfSkuYW5pbWF0ZSh7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0sIHZvaWQgMCwgYy5oaWRlKTtcbiAgICAgIGEuaGFzUmVuZGVyZWQgJiYgKGcgJiYgYy5hdHRyKHtcbiAgICAgICAgeDogYy5zdGFydFhQb3MsXG4gICAgICAgIHk6IGMuc3RhcnRZUG9zXG4gICAgICB9KSwgYy5wbGFjZWQgPSAhMCk7XG4gICAgfTtcblxuICAgIHEucHJvdG90eXBlLmp1c3RpZnlEYXRhTGFiZWwgPSBmdW5jdGlvbiAoZCwgYywgZywgaCwgZiwgYSkge1xuICAgICAgdmFyIGUgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgIGsgPSBjLmFsaWduLFxuICAgICAgICAgIG4gPSBjLnZlcnRpY2FsQWxpZ24sXG4gICAgICAgICAgcSA9IGQuYm94ID8gMCA6IGQucGFkZGluZyB8fCAwO1xuICAgICAgdmFyIHIgPSBnLnggKyBxO1xuXG4gICAgICBpZiAoMCA+IHIpIHtcbiAgICAgICAgXCJyaWdodFwiID09PSBrID8gKGMuYWxpZ24gPSBcImxlZnRcIiwgYy5pbnNpZGUgPSAhMCkgOiBjLnggPSAtcjtcbiAgICAgICAgdmFyIHQgPSAhMDtcbiAgICAgIH1cblxuICAgICAgciA9IGcueCArIGgud2lkdGggLSBxO1xuICAgICAgciA+IGUucGxvdFdpZHRoICYmIChcImxlZnRcIiA9PT0gayA/IChjLmFsaWduID0gXCJyaWdodFwiLCBjLmluc2lkZSA9ICEwKSA6IGMueCA9IGUucGxvdFdpZHRoIC0gciwgdCA9ICEwKTtcbiAgICAgIHIgPSBnLnkgKyBxO1xuICAgICAgMCA+IHIgJiYgKFwiYm90dG9tXCIgPT09IG4gPyAoYy52ZXJ0aWNhbEFsaWduID0gXCJ0b3BcIiwgYy5pbnNpZGUgPSAhMCkgOiBjLnkgPSAtciwgdCA9ICEwKTtcbiAgICAgIHIgPSBnLnkgKyBoLmhlaWdodCAtIHE7XG4gICAgICByID4gZS5wbG90SGVpZ2h0ICYmIChcInRvcFwiID09PSBuID8gKGMudmVydGljYWxBbGlnbiA9IFwiYm90dG9tXCIsIGMuaW5zaWRlID0gITApIDogYy55ID0gZS5wbG90SGVpZ2h0IC0gciwgdCA9ICEwKTtcbiAgICAgIHQgJiYgKGQucGxhY2VkID0gIWEsIGQuYWxpZ24oYywgbnVsbCwgZikpO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcblxuICAgIFAucGllICYmIChQLnBpZS5wcm90b3R5cGUuZGF0YUxhYmVsUG9zaXRpb25lcnMgPSB7XG4gICAgICByYWRpYWxEaXN0cmlidXRpb25ZOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC50b3AgKyBkLmRpc3RyaWJ1dGVCb3gucG9zO1xuICAgICAgfSxcbiAgICAgIHJhZGlhbERpc3RyaWJ1dGlvblg6IGZ1bmN0aW9uIChkLCBjLCBnLCBoKSB7XG4gICAgICAgIHJldHVybiBkLmdldFgoZyA8IGMudG9wICsgMiB8fCBnID4gYy5ib3R0b20gLSAyID8gaCA6IGcsIGMuaGFsZiwgYyk7XG4gICAgICB9LFxuICAgICAganVzdGlmeTogZnVuY3Rpb24gKGQsIGMsIGcpIHtcbiAgICAgICAgcmV0dXJuIGdbMF0gKyAoZC5oYWxmID8gLTEgOiAxKSAqIChjICsgZC5sYWJlbERpc3RhbmNlKTtcbiAgICAgIH0sXG4gICAgICBhbGlnblRvUGxvdEVkZ2VzOiBmdW5jdGlvbiAoZCwgYywgZywgaCkge1xuICAgICAgICBkID0gZC5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgIHJldHVybiBjID8gZCArIGggOiBnIC0gZCAtIGg7XG4gICAgICB9LFxuICAgICAgYWxpZ25Ub0Nvbm5lY3RvcnM6IGZ1bmN0aW9uIChkLCBjLCBnLCBoKSB7XG4gICAgICAgIHZhciBlID0gMCxcbiAgICAgICAgICAgIGE7XG4gICAgICAgIGQuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGEgPSBjLmRhdGFMYWJlbC5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgICAgYSA+IGUgJiYgKGUgPSBhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjID8gZSArIGggOiBnIC0gZSAtIGg7XG4gICAgICB9XG4gICAgfSwgUC5waWUucHJvdG90eXBlLmRyYXdEYXRhTGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgIGMgPSBlLmRhdGEsXG4gICAgICAgICAgZyxcbiAgICAgICAgICBoID0gZS5jaGFydCxcbiAgICAgICAgICBmID0gZS5vcHRpb25zLmRhdGFMYWJlbHMgfHwge30sXG4gICAgICAgICAgYSA9IGYuY29ubmVjdG9yUGFkZGluZyxcbiAgICAgICAgICBsLFxuICAgICAgICAgIHYgPSBoLnBsb3RXaWR0aCxcbiAgICAgICAgICByID0gaC5wbG90SGVpZ2h0LFxuICAgICAgICAgIHcgPSBoLnBsb3RMZWZ0LFxuICAgICAgICAgIHkgPSBNYXRoLnJvdW5kKGguY2hhcnRXaWR0aCAvIDMpLFxuICAgICAgICAgIEEsXG4gICAgICAgICAgRCA9IGUuY2VudGVyLFxuICAgICAgICAgIEggPSBEWzJdIC8gMixcbiAgICAgICAgICBLID0gRFsxXSxcbiAgICAgICAgICBwLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgQyxcbiAgICAgICAgICB4LFxuICAgICAgICAgIEcgPSBbW10sIFtdXSxcbiAgICAgICAgICBFLFxuICAgICAgICAgIE4sXG4gICAgICAgICAgSSxcbiAgICAgICAgICBtLFxuICAgICAgICAgIFAgPSBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgUyA9IGUuZGF0YUxhYmVsUG9zaXRpb25lcnMsXG4gICAgICAgICAgVztcbiAgICAgIGUudmlzaWJsZSAmJiAoZi5lbmFibGVkIHx8IGUuX2hhc1BvaW50TGFiZWxzKSAmJiAoYy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGEuZGF0YUxhYmVsICYmIGEudmlzaWJsZSAmJiBhLmRhdGFMYWJlbC5zaG9ydGVuZWQgJiYgKGEuZGF0YUxhYmVsLmF0dHIoe1xuICAgICAgICAgIHdpZHRoOiBcImF1dG9cIlxuICAgICAgICB9KS5jc3Moe1xuICAgICAgICAgIHdpZHRoOiBcImF1dG9cIixcbiAgICAgICAgICB0ZXh0T3ZlcmZsb3c6IFwiY2xpcFwiXG4gICAgICAgIH0pLCBhLmRhdGFMYWJlbC5zaG9ydGVuZWQgPSAhMSk7XG4gICAgICB9KSwgcS5wcm90b3R5cGUuZHJhd0RhdGFMYWJlbHMuYXBwbHkoZSksIGMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICBhLmRhdGFMYWJlbCAmJiAoYS52aXNpYmxlID8gKEdbYS5oYWxmXS5wdXNoKGEpLCBhLmRhdGFMYWJlbC5fcG9zID0gbnVsbCwgIU0oZi5zdHlsZS53aWR0aCkgJiYgIU0oYS5vcHRpb25zLmRhdGFMYWJlbHMgJiYgYS5vcHRpb25zLmRhdGFMYWJlbHMuc3R5bGUgJiYgYS5vcHRpb25zLmRhdGFMYWJlbHMuc3R5bGUud2lkdGgpICYmIGEuZGF0YUxhYmVsLmdldEJCb3goKS53aWR0aCA+IHkgJiYgKGEuZGF0YUxhYmVsLmNzcyh7XG4gICAgICAgICAgd2lkdGg6IC43ICogeVxuICAgICAgICB9KSwgYS5kYXRhTGFiZWwuc2hvcnRlbmVkID0gITApKSA6IChhLmRhdGFMYWJlbCA9IGEuZGF0YUxhYmVsLmRlc3Ryb3koKSwgYS5kYXRhTGFiZWxzICYmIDEgPT09IGEuZGF0YUxhYmVscy5sZW5ndGggJiYgZGVsZXRlIGEuZGF0YUxhYmVscykpO1xuICAgICAgfSksIEcuZm9yRWFjaChmdW5jdGlvbiAoYywgaykge1xuICAgICAgICB2YXIgbCA9IGMubGVuZ3RoLFxuICAgICAgICAgICAgbiA9IFtdLFxuICAgICAgICAgICAgcTtcblxuICAgICAgICBpZiAobCkge1xuICAgICAgICAgIGUuc29ydEJ5QW5nbGUoYywgayAtIC41KTtcblxuICAgICAgICAgIGlmICgwIDwgZS5tYXhMYWJlbERpc3RhbmNlKSB7XG4gICAgICAgICAgICB2YXIgdSA9IE1hdGgubWF4KDAsIEsgLSBIIC0gZS5tYXhMYWJlbERpc3RhbmNlKTtcbiAgICAgICAgICAgIHZhciB6ID0gTWF0aC5taW4oSyArIEggKyBlLm1heExhYmVsRGlzdGFuY2UsIGgucGxvdEhlaWdodCk7XG4gICAgICAgICAgICBjLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgMCA8IGEubGFiZWxEaXN0YW5jZSAmJiBhLmRhdGFMYWJlbCAmJiAoYS50b3AgPSBNYXRoLm1heCgwLCBLIC0gSCAtIGEubGFiZWxEaXN0YW5jZSksIGEuYm90dG9tID0gTWF0aC5taW4oSyArIEggKyBhLmxhYmVsRGlzdGFuY2UsIGgucGxvdEhlaWdodCksIHEgPSBhLmRhdGFMYWJlbC5nZXRCQm94KCkuaGVpZ2h0IHx8IDIxLCBhLmRpc3RyaWJ1dGVCb3ggPSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBhLmxhYmVsUG9zaXRpb24ubmF0dXJhbC55IC0gYS50b3AgKyBxIC8gMixcbiAgICAgICAgICAgICAgICBzaXplOiBxLFxuICAgICAgICAgICAgICAgIHJhbms6IGEueVxuICAgICAgICAgICAgICB9LCBuLnB1c2goYS5kaXN0cmlidXRlQm94KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHUgPSB6ICsgcSAtIHU7XG4gICAgICAgICAgICBkLmRpc3RyaWJ1dGUobiwgdSwgdSAvIDUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAobSA9IDA7IG0gPCBsOyBtKyspIHtcbiAgICAgICAgICAgIGcgPSBjW21dO1xuICAgICAgICAgICAgQyA9IGcubGFiZWxQb3NpdGlvbjtcbiAgICAgICAgICAgIHAgPSBnLmRhdGFMYWJlbDtcbiAgICAgICAgICAgIEkgPSAhMSA9PT0gZy52aXNpYmxlID8gXCJoaWRkZW5cIiA6IFwiaW5oZXJpdFwiO1xuICAgICAgICAgICAgTiA9IHUgPSBDLm5hdHVyYWwueTtcbiAgICAgICAgICAgIG4gJiYgTShnLmRpc3RyaWJ1dGVCb3gpICYmIChcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgZy5kaXN0cmlidXRlQm94LnBvcyA/IEkgPSBcImhpZGRlblwiIDogKHggPSBnLmRpc3RyaWJ1dGVCb3guc2l6ZSwgTiA9IFMucmFkaWFsRGlzdHJpYnV0aW9uWShnKSkpO1xuICAgICAgICAgICAgZGVsZXRlIGcucG9zaXRpb25JbmRleDtcbiAgICAgICAgICAgIGlmIChmLmp1c3RpZnkpIEUgPSBTLmp1c3RpZnkoZywgSCwgRCk7ZWxzZSBzd2l0Y2ggKGYuYWxpZ25Ubykge1xuICAgICAgICAgICAgICBjYXNlIFwiY29ubmVjdG9yc1wiOlxuICAgICAgICAgICAgICAgIEUgPSBTLmFsaWduVG9Db25uZWN0b3JzKGMsIGssIHYsIHcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJwbG90RWRnZXNcIjpcbiAgICAgICAgICAgICAgICBFID0gUy5hbGlnblRvUGxvdEVkZ2VzKHAsIGssIHYsIHcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgRSA9IFMucmFkaWFsRGlzdHJpYnV0aW9uWChlLCBnLCBOLCB1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAuX2F0dHIgPSB7XG4gICAgICAgICAgICAgIHZpc2liaWxpdHk6IEksXG4gICAgICAgICAgICAgIGFsaWduOiBDLmFsaWdubWVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFcgPSBnLm9wdGlvbnMuZGF0YUxhYmVscyB8fCB7fTtcbiAgICAgICAgICAgIHAuX3BvcyA9IHtcbiAgICAgICAgICAgICAgeDogRSArIHQoVy54LCBmLngpICsgKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBhLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAtYVxuICAgICAgICAgICAgICB9W0MuYWxpZ25tZW50XSB8fCAwKSxcbiAgICAgICAgICAgICAgeTogTiArIHQoVy55LCBmLnkpIC0gMTBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBDLmZpbmFsLnggPSBFO1xuICAgICAgICAgICAgQy5maW5hbC55ID0gTjtcbiAgICAgICAgICAgIHQoZi5jcm9wLCAhMCkgJiYgKGIgPSBwLmdldEJCb3goKS53aWR0aCwgdSA9IG51bGwsIEUgLSBiIDwgYSAmJiAxID09PSBrID8gKHUgPSBNYXRoLnJvdW5kKGIgLSBFICsgYSksIFBbM10gPSBNYXRoLm1heCh1LCBQWzNdKSkgOiBFICsgYiA+IHYgLSBhICYmIDAgPT09IGsgJiYgKHUgPSBNYXRoLnJvdW5kKEUgKyBiIC0gdiArIGEpLCBQWzFdID0gTWF0aC5tYXgodSwgUFsxXSkpLCAwID4gTiAtIHggLyAyID8gUFswXSA9IE1hdGgubWF4KE1hdGgucm91bmQoLU4gKyB4IC8gMiksIFBbMF0pIDogTiArIHggLyAyID4gciAmJiAoUFsyXSA9IE1hdGgubWF4KE1hdGgucm91bmQoTiArIHggLyAyIC0gciksIFBbMl0pKSwgcC5zaWRlT3ZlcmZsb3cgPSB1KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLCAwID09PSB1KFApIHx8IHRoaXMudmVyaWZ5RGF0YUxhYmVsT3ZlcmZsb3coUCkpICYmICh0aGlzLnBsYWNlRGF0YUxhYmVscygpLCB0aGlzLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIFcgPSBKKGYsIGEub3B0aW9ucy5kYXRhTGFiZWxzKTtcblxuICAgICAgICBpZiAobCA9IHQoVy5jb25uZWN0b3JXaWR0aCwgMSkpIHtcbiAgICAgICAgICB2YXIgYjtcbiAgICAgICAgICBBID0gYS5jb25uZWN0b3I7XG5cbiAgICAgICAgICBpZiAoKHAgPSBhLmRhdGFMYWJlbCkgJiYgcC5fcG9zICYmIGEudmlzaWJsZSAmJiAwIDwgYS5sYWJlbERpc3RhbmNlKSB7XG4gICAgICAgICAgICBJID0gcC5fYXR0ci52aXNpYmlsaXR5O1xuICAgICAgICAgICAgaWYgKGIgPSAhQSkgYS5jb25uZWN0b3IgPSBBID0gaC5yZW5kZXJlci5wYXRoKCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWRhdGEtbGFiZWwtY29ubmVjdG9yICBoaWdoY2hhcnRzLWNvbG9yLVwiICsgYS5jb2xvckluZGV4ICsgKGEuY2xhc3NOYW1lID8gXCIgXCIgKyBhLmNsYXNzTmFtZSA6IFwiXCIpKS5hZGQoZS5kYXRhTGFiZWxzR3JvdXApLCBoLnN0eWxlZE1vZGUgfHwgQS5hdHRyKHtcbiAgICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogbCxcbiAgICAgICAgICAgICAgc3Ryb2tlOiBXLmNvbm5lY3RvckNvbG9yIHx8IGEuY29sb3IgfHwgXCIjNjY2NjY2XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgQVtiID8gXCJhdHRyXCIgOiBcImFuaW1hdGVcIl0oe1xuICAgICAgICAgICAgICBkOiBhLmdldENvbm5lY3RvclBhdGgoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBBLmF0dHIoXCJ2aXNpYmlsaXR5XCIsIEkpO1xuICAgICAgICAgIH0gZWxzZSBBICYmIChhLmNvbm5lY3RvciA9IEEuZGVzdHJveSgpKTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH0sIFAucGllLnByb3RvdHlwZS5wbGFjZURhdGFMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBjID0gZC5kYXRhTGFiZWwsXG4gICAgICAgICAgICBlO1xuICAgICAgICBjICYmIGQudmlzaWJsZSAmJiAoKGUgPSBjLl9wb3MpID8gKGMuc2lkZU92ZXJmbG93ICYmIChjLl9hdHRyLndpZHRoID0gTWF0aC5tYXgoYy5nZXRCQm94KCkud2lkdGggLSBjLnNpZGVPdmVyZmxvdywgMCksIGMuY3NzKHtcbiAgICAgICAgICB3aWR0aDogYy5fYXR0ci53aWR0aCArIFwicHhcIixcbiAgICAgICAgICB0ZXh0T3ZlcmZsb3c6ICh0aGlzLm9wdGlvbnMuZGF0YUxhYmVscy5zdHlsZSB8fCB7fSkudGV4dE92ZXJmbG93IHx8IFwiZWxsaXBzaXNcIlxuICAgICAgICB9KSwgYy5zaG9ydGVuZWQgPSAhMCksIGMuYXR0cihjLl9hdHRyKSwgY1tjLm1vdmVkID8gXCJhbmltYXRlXCIgOiBcImF0dHJcIl0oZSksIGMubW92ZWQgPSAhMCkgOiBjICYmIGMuYXR0cih7XG4gICAgICAgICAgeTogLTk5OTlcbiAgICAgICAgfSkpO1xuICAgICAgICBkZWxldGUgZC5kaXN0cmlidXRlQm94O1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSwgUC5waWUucHJvdG90eXBlLmFsaWduRGF0YUxhYmVsID0gZywgUC5waWUucHJvdG90eXBlLnZlcmlmeURhdGFMYWJlbE92ZXJmbG93ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciBjID0gdGhpcy5jZW50ZXIsXG4gICAgICAgICAgZSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBnID0gZS5jZW50ZXIsXG4gICAgICAgICAgZiA9IGUubWluU2l6ZSB8fCA4MCxcbiAgICAgICAgICBhID0gbnVsbCAhPT0gZS5zaXplO1xuXG4gICAgICBpZiAoIWEpIHtcbiAgICAgICAgaWYgKG51bGwgIT09IGdbMF0pIHZhciBoID0gTWF0aC5tYXgoY1syXSAtIE1hdGgubWF4KGRbMV0sIGRbM10pLCBmKTtlbHNlIGggPSBNYXRoLm1heChjWzJdIC0gZFsxXSAtIGRbM10sIGYpLCBjWzBdICs9IChkWzNdIC0gZFsxXSkgLyAyO1xuICAgICAgICBudWxsICE9PSBnWzFdID8gaCA9IEkoaCwgZiwgY1syXSAtIE1hdGgubWF4KGRbMF0sIGRbMl0pKSA6IChoID0gSShoLCBmLCBjWzJdIC0gZFswXSAtIGRbMl0pLCBjWzFdICs9IChkWzBdIC0gZFsyXSkgLyAyKTtcbiAgICAgICAgaCA8IGNbMl0gPyAoY1syXSA9IGgsIGNbM10gPSBNYXRoLm1pbihEKGUuaW5uZXJTaXplIHx8IDAsIGgpLCBoKSwgdGhpcy50cmFuc2xhdGUoYyksIHRoaXMuZHJhd0RhdGFMYWJlbHMgJiYgdGhpcy5kcmF3RGF0YUxhYmVscygpKSA6IGEgPSAhMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGE7XG4gICAgfSk7XG4gICAgUC5jb2x1bW4gJiYgKFAuY29sdW1uLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbCA9IGZ1bmN0aW9uIChkLCBjLCBnLCBoLCBmKSB7XG4gICAgICB2YXIgYSA9IHRoaXMuY2hhcnQuaW52ZXJ0ZWQsXG4gICAgICAgICAgZSA9IGQuc2VyaWVzLFxuICAgICAgICAgIGsgPSBkLmRsQm94IHx8IGQuc2hhcGVBcmdzLFxuICAgICAgICAgIG4gPSB0KGQuYmVsb3csIGQucGxvdFkgPiB0KHRoaXMudHJhbnNsYXRlZFRocmVzaG9sZCwgZS55QXhpcy5sZW4pKSxcbiAgICAgICAgICByID0gdChnLmluc2lkZSwgISF0aGlzLm9wdGlvbnMuc3RhY2tpbmcpO1xuICAgICAgayAmJiAoaCA9IEooayksIDAgPiBoLnkgJiYgKGguaGVpZ2h0ICs9IGgueSwgaC55ID0gMCksIGsgPSBoLnkgKyBoLmhlaWdodCAtIGUueUF4aXMubGVuLCAwIDwgayAmJiBrIDwgaC5oZWlnaHQgJiYgKGguaGVpZ2h0IC09IGspLCBhICYmIChoID0ge1xuICAgICAgICB4OiBlLnlBeGlzLmxlbiAtIGgueSAtIGguaGVpZ2h0LFxuICAgICAgICB5OiBlLnhBeGlzLmxlbiAtIGgueCAtIGgud2lkdGgsXG4gICAgICAgIHdpZHRoOiBoLmhlaWdodCxcbiAgICAgICAgaGVpZ2h0OiBoLndpZHRoXG4gICAgICB9KSwgciB8fCAoYSA/IChoLnggKz0gbiA/IDAgOiBoLndpZHRoLCBoLndpZHRoID0gMCkgOiAoaC55ICs9IG4gPyBoLmhlaWdodCA6IDAsIGguaGVpZ2h0ID0gMCkpKTtcbiAgICAgIGcuYWxpZ24gPSB0KGcuYWxpZ24sICFhIHx8IHIgPyBcImNlbnRlclwiIDogbiA/IFwicmlnaHRcIiA6IFwibGVmdFwiKTtcbiAgICAgIGcudmVydGljYWxBbGlnbiA9IHQoZy52ZXJ0aWNhbEFsaWduLCBhIHx8IHIgPyBcIm1pZGRsZVwiIDogbiA/IFwidG9wXCIgOiBcImJvdHRvbVwiKTtcbiAgICAgIHEucHJvdG90eXBlLmFsaWduRGF0YUxhYmVsLmNhbGwodGhpcywgZCwgYywgZywgaCwgZik7XG4gICAgICBnLmluc2lkZSAmJiBkLmNvbnRyYXN0Q29sb3IgJiYgYy5jc3Moe1xuICAgICAgICBjb2xvcjogZC5jb250cmFzdENvbG9yXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIFMociwgXCJtb2R1bGVzL292ZXJsYXBwaW5nLWRhdGFsYWJlbHMuc3JjLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgdmFyIHIgPSBnLmFkZEV2ZW50LFxuICAgICAgICB1ID0gZy5maXJlRXZlbnQsXG4gICAgICAgIEkgPSBnLmlzQXJyYXksXG4gICAgICAgIE0gPSBnLm9iamVjdEVhY2gsXG4gICAgICAgIEUgPSBnLnBpY2s7XG4gICAgZCA9IGQuQ2hhcnQ7XG4gICAgcihkLCBcInJlbmRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZCA9IFtdO1xuICAgICAgKHRoaXMubGFiZWxDb2xsZWN0b3JzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIGQgPSBkLmNvbmNhdChnKCkpO1xuICAgICAgfSk7XG4gICAgICAodGhpcy55QXhpcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoZykge1xuICAgICAgICBnLm9wdGlvbnMuc3RhY2tMYWJlbHMgJiYgIWcub3B0aW9ucy5zdGFja0xhYmVscy5hbGxvd092ZXJsYXAgJiYgTShnLnN0YWNrcywgZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgICBNKGcsIGZ1bmN0aW9uIChnKSB7XG4gICAgICAgICAgICBkLnB1c2goZy5sYWJlbCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAodGhpcy5zZXJpZXMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgdmFyIHIgPSBnLm9wdGlvbnMuZGF0YUxhYmVscztcbiAgICAgICAgZy52aXNpYmxlICYmICghMSAhPT0gci5lbmFibGVkIHx8IGcuX2hhc1BvaW50TGFiZWxzKSAmJiAoZy5ub2RlcyB8fCBnLnBvaW50cykuZm9yRWFjaChmdW5jdGlvbiAoZykge1xuICAgICAgICAgIGcudmlzaWJsZSAmJiAoSShnLmRhdGFMYWJlbHMpID8gZy5kYXRhTGFiZWxzIDogZy5kYXRhTGFiZWwgPyBbZy5kYXRhTGFiZWxdIDogW10pLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHZhciB0ID0gci5vcHRpb25zO1xuICAgICAgICAgICAgci5sYWJlbHJhbmsgPSBFKHQubGFiZWxyYW5rLCBnLmxhYmVscmFuaywgZy5zaGFwZUFyZ3MgJiYgZy5zaGFwZUFyZ3MuaGVpZ2h0KTtcbiAgICAgICAgICAgIHQuYWxsb3dPdmVybGFwIHx8IGQucHVzaChyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGlkZU92ZXJsYXBwaW5nTGFiZWxzKGQpO1xuICAgIH0pO1xuXG4gICAgZC5wcm90b3R5cGUuaGlkZU92ZXJsYXBwaW5nTGFiZWxzID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciBnID0gdGhpcyxcbiAgICAgICAgICByID0gZC5sZW5ndGgsXG4gICAgICAgICAgeSA9IGcucmVuZGVyZXIsXG4gICAgICAgICAgdCxcbiAgICAgICAgICBBLFxuICAgICAgICAgIGgsXG4gICAgICAgICAgRSA9ICExO1xuXG4gICAgICB2YXIgcSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBkID0gYy5ib3ggPyAwIDogYy5wYWRkaW5nIHx8IDA7XG4gICAgICAgIHZhciBlID0gMDtcblxuICAgICAgICBpZiAoYyAmJiAoIWMuYWxpZ25BdHRyIHx8IGMucGxhY2VkKSkge1xuICAgICAgICAgIHZhciBmID0gYy5hbGlnbkF0dHIgfHwge1xuICAgICAgICAgICAgeDogYy5hdHRyKFwieFwiKSxcbiAgICAgICAgICAgIHk6IGMuYXR0cihcInlcIilcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBhID0gYy5wYXJlbnRHcm91cDtcbiAgICAgICAgICBjLndpZHRoIHx8IChlID0gYy5nZXRCQm94KCksIGMud2lkdGggPSBlLndpZHRoLCBjLmhlaWdodCA9IGUuaGVpZ2h0LCBlID0geS5mb250TWV0cmljcyhudWxsLCBjLmVsZW1lbnQpLmgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBmLnggKyAoYS50cmFuc2xhdGVYIHx8IDApICsgZCxcbiAgICAgICAgICAgIHk6IGYueSArIChhLnRyYW5zbGF0ZVkgfHwgMCkgKyBkIC0gZSxcbiAgICAgICAgICAgIHdpZHRoOiBjLndpZHRoIC0gMiAqIGQsXG4gICAgICAgICAgICBoZWlnaHQ6IGMuaGVpZ2h0IC0gMiAqIGRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKEEgPSAwOyBBIDwgcjsgQSsrKSBpZiAodCA9IGRbQV0pIHQub2xkT3BhY2l0eSA9IHQub3BhY2l0eSwgdC5uZXdPcGFjaXR5ID0gMSwgdC5hYnNvbHV0ZUJveCA9IHEodCk7XG5cbiAgICAgIGQuc29ydChmdW5jdGlvbiAoYywgZCkge1xuICAgICAgICByZXR1cm4gKGQubGFiZWxyYW5rIHx8IDApIC0gKGMubGFiZWxyYW5rIHx8IDApO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAoQSA9IDA7IEEgPCByOyBBKyspIHtcbiAgICAgICAgdmFyIEkgPSAocSA9IGRbQV0pICYmIHEuYWJzb2x1dGVCb3g7XG5cbiAgICAgICAgZm9yICh0ID0gQSArIDE7IHQgPCByOyArK3QpIHtcbiAgICAgICAgICB2YXIgZSA9IChoID0gZFt0XSkgJiYgaC5hYnNvbHV0ZUJveDtcbiAgICAgICAgICAhSSB8fCAhZSB8fCBxID09PSBoIHx8IDAgPT09IHEubmV3T3BhY2l0eSB8fCAwID09PSBoLm5ld09wYWNpdHkgfHwgZS54ID4gSS54ICsgSS53aWR0aCB8fCBlLnggKyBlLndpZHRoIDwgSS54IHx8IGUueSA+IEkueSArIEkuaGVpZ2h0IHx8IGUueSArIGUuaGVpZ2h0IDwgSS55IHx8ICgocS5sYWJlbHJhbmsgPCBoLmxhYmVscmFuayA/IHEgOiBoKS5uZXdPcGFjaXR5ID0gMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZC5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBkO1xuXG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgdmFyIGUgPSBjLm5ld09wYWNpdHk7XG4gICAgICAgICAgYy5vbGRPcGFjaXR5ICE9PSBlICYmIChjLmFsaWduQXR0ciAmJiBjLnBsYWNlZCA/IChlID8gYy5zaG93KCEwKSA6IGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjLmhpZGUoITApO1xuICAgICAgICAgICAgYy5wbGFjZWQgPSAhMTtcbiAgICAgICAgICB9LCBFID0gITAsIGMuYWxpZ25BdHRyLm9wYWNpdHkgPSBlLCBjW2MuaXNPbGQgPyBcImFuaW1hdGVcIiA6IFwiYXR0clwiXShjLmFsaWduQXR0ciwgbnVsbCwgZCksIHUoZywgXCJhZnRlckhpZGVPdmVybGFwcGluZ0xhYmVsXCIpKSA6IGMuYXR0cih7XG4gICAgICAgICAgICBvcGFjaXR5OiBlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGMuaXNPbGQgPSAhMDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBFICYmIHUoZywgXCJhZnRlckhpZGVBbGxPdmVybGFwcGluZ0xhYmVsc1wiKTtcbiAgICB9O1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL0ludGVyYWN0aW9uLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL0xlZ2VuZC5qc1wiXSwgcltcInBhcnRzL1BvaW50LmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcsIHIsIHUpIHtcbiAgICB2YXIgSSA9IHUuYWRkRXZlbnQsXG4gICAgICAgIE0gPSB1LmNyZWF0ZUVsZW1lbnQsXG4gICAgICAgIEUgPSB1LmNzcyxcbiAgICAgICAgQSA9IHUuZGVmaW5lZCxcbiAgICAgICAgRyA9IHUuZXh0ZW5kLFxuICAgICAgICBKID0gdS5maXJlRXZlbnQsXG4gICAgICAgIHkgPSB1LmlzQXJyYXksXG4gICAgICAgIHQgPSB1LmlzRnVuY3Rpb24sXG4gICAgICAgIEQgPSB1LmlzT2JqZWN0LFxuICAgICAgICBoID0gdS5tZXJnZSxcbiAgICAgICAgTiA9IHUub2JqZWN0RWFjaCxcbiAgICAgICAgcSA9IHUucGljaztcbiAgICB1ID0gZC5DaGFydDtcbiAgICB2YXIgUCA9IGQuZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgIGUgPSBkLmRlZmF1bHRQbG90T3B0aW9ucyxcbiAgICAgICAgYyA9IGQuaGFzVG91Y2gsXG4gICAgICAgIGsgPSBkLlNlcmllcyxcbiAgICAgICAgbiA9IGQuc2VyaWVzVHlwZXMsXG4gICAgICAgIGYgPSBkLnN2ZztcbiAgICBkID0gZC5UcmFja2VyTWl4aW4gPSB7XG4gICAgICBkcmF3VHJhY2tlclBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIGQgPSBhLmNoYXJ0LFxuICAgICAgICAgICAgZSA9IGQucG9pbnRlcixcbiAgICAgICAgICAgIGYgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHZhciBjID0gZS5nZXRQb2ludEZyb21FdmVudChhKTtcbiAgICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYyAmJiAoZS5pc0RpcmVjdFRvdWNoID0gITAsIGMub25Nb3VzZU92ZXIoYSkpO1xuICAgICAgICB9LFxuICAgICAgICAgICAgZztcblxuICAgICAgICBhLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgZyA9IHkoYS5kYXRhTGFiZWxzKSA/IGEuZGF0YUxhYmVscyA6IGEuZGF0YUxhYmVsID8gW2EuZGF0YUxhYmVsXSA6IFtdO1xuICAgICAgICAgIGEuZ3JhcGhpYyAmJiAoYS5ncmFwaGljLmVsZW1lbnQucG9pbnQgPSBhKTtcbiAgICAgICAgICBnLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGMuZGl2ID8gYy5kaXYucG9pbnQgPSBhIDogYy5lbGVtZW50LnBvaW50ID0gYTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGEuX2hhc1RyYWNraW5nIHx8IChhLnRyYWNrZXJHcm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZykge1xuICAgICAgICAgIGlmIChhW2ddKSB7XG4gICAgICAgICAgICBhW2ddLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy10cmFja2VyXCIpLm9uKFwibW91c2VvdmVyXCIsIGYpLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgZS5vblRyYWNrZXJNb3VzZU91dChhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGMpIGFbZ10ub24oXCJ0b3VjaHN0YXJ0XCIsIGYpO1xuICAgICAgICAgICAgIWQuc3R5bGVkTW9kZSAmJiBhLm9wdGlvbnMuY3Vyc29yICYmIGFbZ10uY3NzKEUpLmNzcyh7XG4gICAgICAgICAgICAgIGN1cnNvcjogYS5vcHRpb25zLmN1cnNvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgYS5faGFzVHJhY2tpbmcgPSAhMCk7XG4gICAgICAgIEoodGhpcywgXCJhZnRlckRyYXdUcmFja2VyXCIpO1xuICAgICAgfSxcbiAgICAgIGRyYXdUcmFja2VyR3JhcGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgZCA9IGEub3B0aW9ucyxcbiAgICAgICAgICAgIGUgPSBkLnRyYWNrQnlBcmVhLFxuICAgICAgICAgICAgZyA9IFtdLmNvbmNhdChlID8gYS5hcmVhUGF0aCA6IGEuZ3JhcGhQYXRoKSxcbiAgICAgICAgICAgIGggPSBnLmxlbmd0aCxcbiAgICAgICAgICAgIGsgPSBhLmNoYXJ0LFxuICAgICAgICAgICAgbiA9IGsucG9pbnRlcixcbiAgICAgICAgICAgIHEgPSBrLnJlbmRlcmVyLFxuICAgICAgICAgICAgciA9IGsub3B0aW9ucy50b29sdGlwLnNuYXAsXG4gICAgICAgICAgICB0ID0gYS50cmFja2VyLFxuICAgICAgICAgICAgcCxcbiAgICAgICAgICAgIGIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGsuaG92ZXJTZXJpZXMgIT09IGEpIGEub25Nb3VzZU92ZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIHUgPSBcInJnYmEoMTkyLDE5MiwxOTIsXCIgKyAoZiA/IC4wMDAxIDogLjAwMikgKyBcIilcIjtcblxuICAgICAgICBpZiAoaCAmJiAhZSkgZm9yIChwID0gaCArIDE7IHAtLTspIFwiTVwiID09PSBnW3BdICYmIGcuc3BsaWNlKHAgKyAxLCAwLCBnW3AgKyAxXSAtIHIsIGdbcCArIDJdLCBcIkxcIiksIChwICYmIFwiTVwiID09PSBnW3BdIHx8IHAgPT09IGgpICYmIGcuc3BsaWNlKHAsIDAsIFwiTFwiLCBnW3AgLSAyXSArIHIsIGdbcCAtIDFdKTtcbiAgICAgICAgdCA/IHQuYXR0cih7XG4gICAgICAgICAgZDogZ1xuICAgICAgICB9KSA6IGEuZ3JhcGggJiYgKGEudHJhY2tlciA9IHEucGF0aChnKS5hdHRyKHtcbiAgICAgICAgICB2aXNpYmlsaXR5OiBhLnZpc2libGUgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgekluZGV4OiAyXG4gICAgICAgIH0pLmFkZENsYXNzKGUgPyBcImhpZ2hjaGFydHMtdHJhY2tlci1hcmVhXCIgOiBcImhpZ2hjaGFydHMtdHJhY2tlci1saW5lXCIpLmFkZChhLmdyb3VwKSwgay5zdHlsZWRNb2RlIHx8IGEudHJhY2tlci5hdHRyKHtcbiAgICAgICAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInJvdW5kXCIsXG4gICAgICAgICAgc3Ryb2tlOiB1LFxuICAgICAgICAgIGZpbGw6IGUgPyB1IDogXCJub25lXCIsXG4gICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogYS5ncmFwaC5zdHJva2VXaWR0aCgpICsgKGUgPyAwIDogMiAqIHIpXG4gICAgICAgIH0pLCBbYS50cmFja2VyLCBhLm1hcmtlckdyb3VwXS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtdHJhY2tlclwiKS5vbihcIm1vdXNlb3ZlclwiLCBiKS5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBuLm9uVHJhY2tlck1vdXNlT3V0KGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGQuY3Vyc29yICYmICFrLnN0eWxlZE1vZGUgJiYgYS5jc3Moe1xuICAgICAgICAgICAgY3Vyc29yOiBkLmN1cnNvclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChjKSBhLm9uKFwidG91Y2hzdGFydFwiLCBiKTtcbiAgICAgICAgfSkpO1xuICAgICAgICBKKHRoaXMsIFwiYWZ0ZXJEcmF3VHJhY2tlclwiKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG4uY29sdW1uICYmIChuLmNvbHVtbi5wcm90b3R5cGUuZHJhd1RyYWNrZXIgPSBkLmRyYXdUcmFja2VyUG9pbnQpO1xuICAgIG4ucGllICYmIChuLnBpZS5wcm90b3R5cGUuZHJhd1RyYWNrZXIgPSBkLmRyYXdUcmFja2VyUG9pbnQpO1xuICAgIG4uc2NhdHRlciAmJiAobi5zY2F0dGVyLnByb3RvdHlwZS5kcmF3VHJhY2tlciA9IGQuZHJhd1RyYWNrZXJQb2ludCk7XG4gICAgRyhnLnByb3RvdHlwZSwge1xuICAgICAgc2V0SXRlbUV2ZW50czogZnVuY3Rpb24gKGEsIGMsIGQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgICAgZiA9IGUuY2hhcnQucmVuZGVyZXIuYm94V3JhcHBlcixcbiAgICAgICAgICAgIGcgPSBhIGluc3RhbmNlb2YgcixcbiAgICAgICAgICAgIGsgPSBcImhpZ2hjaGFydHMtbGVnZW5kLVwiICsgKGcgPyBcInBvaW50XCIgOiBcInNlcmllc1wiKSArIFwiLWFjdGl2ZVwiLFxuICAgICAgICAgICAgbCA9IGUuY2hhcnQuc3R5bGVkTW9kZTtcbiAgICAgICAgKGQgPyBbYywgYS5sZWdlbmRTeW1ib2xdIDogW2EubGVnZW5kR3JvdXBdKS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgaWYgKGQpIGQub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYS52aXNpYmxlICYmIGUuYWxsSXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICBhICE9PSBjICYmIGMuc2V0U3RhdGUoXCJpbmFjdGl2ZVwiLCAhZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGEuc2V0U3RhdGUoXCJob3ZlclwiKTtcbiAgICAgICAgICAgIGEudmlzaWJsZSAmJiBmLmFkZENsYXNzKGspO1xuICAgICAgICAgICAgbCB8fCBjLmNzcyhlLm9wdGlvbnMuaXRlbUhvdmVyU3R5bGUpO1xuICAgICAgICAgIH0pLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZS5jaGFydC5zdHlsZWRNb2RlIHx8IGMuY3NzKGgoYS52aXNpYmxlID8gZS5pdGVtU3R5bGUgOiBlLml0ZW1IaWRkZW5TdHlsZSkpO1xuICAgICAgICAgICAgZS5hbGxJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgIGEgIT09IGMgJiYgYy5zZXRTdGF0ZShcIlwiLCAhZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGYucmVtb3ZlQ2xhc3Moayk7XG4gICAgICAgICAgICBhLnNldFN0YXRlKCk7XG4gICAgICAgICAgfSkub24oXCJjbGlja1wiLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgdmFyIGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGEuc2V0VmlzaWJsZSAmJiBhLnNldFZpc2libGUoKTtcbiAgICAgICAgICAgICAgZS5hbGxJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAgICAgYSAhPT0gYiAmJiBiLnNldFN0YXRlKGEudmlzaWJsZSA/IFwiaW5hY3RpdmVcIiA6IFwiXCIsICFnKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmLnJlbW92ZUNsYXNzKGspO1xuICAgICAgICAgICAgYyA9IHtcbiAgICAgICAgICAgICAgYnJvd3NlckV2ZW50OiBjXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYS5maXJlUG9pbnRFdmVudCA/IGEuZmlyZVBvaW50RXZlbnQoXCJsZWdlbmRJdGVtQ2xpY2tcIiwgYywgZCkgOiBKKGEsIFwibGVnZW5kSXRlbUNsaWNrXCIsIGMsIGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVDaGVja2JveEZvckl0ZW06IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGEuY2hlY2tib3ggPSBNKFwiaW5wdXRcIiwge1xuICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICBjbGFzc05hbWU6IFwiaGlnaGNoYXJ0cy1sZWdlbmQtY2hlY2tib3hcIixcbiAgICAgICAgICBjaGVja2VkOiBhLnNlbGVjdGVkLFxuICAgICAgICAgIGRlZmF1bHRDaGVja2VkOiBhLnNlbGVjdGVkXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5pdGVtQ2hlY2tib3hTdHlsZSwgdGhpcy5jaGFydC5jb250YWluZXIpO1xuICAgICAgICBJKGEuY2hlY2tib3gsIFwiY2xpY2tcIiwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBKKGEuc2VyaWVzIHx8IGEsIFwiY2hlY2tib3hDbGlja1wiLCB7XG4gICAgICAgICAgICBjaGVja2VkOiBjLnRhcmdldC5jaGVja2VkLFxuICAgICAgICAgICAgaXRlbTogYVxuICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGEuc2VsZWN0KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIEcodS5wcm90b3R5cGUsIHtcbiAgICAgIHNob3dSZXNldFpvb206IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gYSgpIHtcbiAgICAgICAgICBjLnpvb21PdXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0gdGhpcyxcbiAgICAgICAgICAgIGQgPSBQLmxhbmcsXG4gICAgICAgICAgICBlID0gYy5vcHRpb25zLmNoYXJ0LnJlc2V0Wm9vbUJ1dHRvbixcbiAgICAgICAgICAgIGYgPSBlLnRoZW1lLFxuICAgICAgICAgICAgZyA9IGYuc3RhdGVzLFxuICAgICAgICAgICAgaCA9IFwiY2hhcnRcIiA9PT0gZS5yZWxhdGl2ZVRvIHx8IFwic3BhY2VCb3hcIiA9PT0gZS5yZWxhdGl2ZVRvID8gbnVsbCA6IFwicGxvdEJveFwiO1xuICAgICAgICBKKHRoaXMsIFwiYmVmb3JlU2hvd1Jlc2V0Wm9vbVwiLCBudWxsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYy5yZXNldFpvb21CdXR0b24gPSBjLnJlbmRlcmVyLmJ1dHRvbihkLnJlc2V0Wm9vbSwgbnVsbCwgbnVsbCwgYSwgZiwgZyAmJiBnLmhvdmVyKS5hdHRyKHtcbiAgICAgICAgICAgIGFsaWduOiBlLnBvc2l0aW9uLmFsaWduLFxuICAgICAgICAgICAgdGl0bGU6IGQucmVzZXRab29tVGl0bGVcbiAgICAgICAgICB9KS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtcmVzZXQtem9vbVwiKS5hZGQoKS5hbGlnbihlLnBvc2l0aW9uLCAhMSwgaCk7XG4gICAgICAgIH0pO1xuICAgICAgICBKKHRoaXMsIFwiYWZ0ZXJTaG93UmVzZXRab29tXCIpO1xuICAgICAgfSxcbiAgICAgIHpvb21PdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgSih0aGlzLCBcInNlbGVjdGlvblwiLCB7XG4gICAgICAgICAgcmVzZXRTZWxlY3Rpb246ICEwXG4gICAgICAgIH0sIHRoaXMuem9vbSk7XG4gICAgICB9LFxuICAgICAgem9vbTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLFxuICAgICAgICAgICAgZCxcbiAgICAgICAgICAgIGUgPSBjLnBvaW50ZXIsXG4gICAgICAgICAgICBmID0gITEsXG4gICAgICAgICAgICBnID0gYy5pbnZlcnRlZCA/IGUubW91c2VEb3duWCA6IGUubW91c2VEb3duWTtcbiAgICAgICAgIWEgfHwgYS5yZXNldFNlbGVjdGlvbiA/IChjLmF4ZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGQgPSBhLnpvb20oKTtcbiAgICAgICAgfSksIGUuaW5pdGlhdGVkID0gITEpIDogYS54QXhpcy5jb25jYXQoYS55QXhpcykuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHZhciBoID0gYS5heGlzLFxuICAgICAgICAgICAgICBrID0gYy5pbnZlcnRlZCA/IGgubGVmdCA6IGgudG9wLFxuICAgICAgICAgICAgICBsID0gYy5pbnZlcnRlZCA/IGsgKyBoLndpZHRoIDogayArIGguaGVpZ2h0LFxuICAgICAgICAgICAgICBiID0gaC5pc1hBeGlzLFxuICAgICAgICAgICAgICBuID0gITE7XG4gICAgICAgICAgaWYgKCFiICYmIGcgPj0gayAmJiBnIDw9IGwgfHwgYiB8fCAhQShnKSkgbiA9ICEwO1xuICAgICAgICAgIGVbYiA/IFwiem9vbVhcIiA6IFwiem9vbVlcIl0gJiYgbiAmJiAoZCA9IGguem9vbShhLm1pbiwgYS5tYXgpLCBoLmRpc3BsYXlCdG4gJiYgKGYgPSAhMCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGggPSBjLnJlc2V0Wm9vbUJ1dHRvbjtcbiAgICAgICAgZiAmJiAhaCA/IGMuc2hvd1Jlc2V0Wm9vbSgpIDogIWYgJiYgRChoKSAmJiAoYy5yZXNldFpvb21CdXR0b24gPSBoLmRlc3Ryb3koKSk7XG4gICAgICAgIGQgJiYgYy5yZWRyYXcocShjLm9wdGlvbnMuY2hhcnQuYW5pbWF0aW9uLCBhICYmIGEuYW5pbWF0aW9uLCAxMDAgPiBjLnBvaW50Q291bnQpKTtcbiAgICAgIH0sXG4gICAgICBwYW46IGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICAgIGUgPSBkLmhvdmVyUG9pbnRzLFxuICAgICAgICAgICAgZiA9IGQub3B0aW9ucy5jaGFydCxcbiAgICAgICAgICAgIGc7XG4gICAgICAgIGMgPSBcIm9iamVjdFwiID09PSB0eXBlb2YgYyA/IGMgOiB7XG4gICAgICAgICAgZW5hYmxlZDogYyxcbiAgICAgICAgICB0eXBlOiBcInhcIlxuICAgICAgICB9O1xuICAgICAgICBmICYmIGYucGFubmluZyAmJiAoZi5wYW5uaW5nID0gYyk7XG4gICAgICAgIHZhciBoID0gYy50eXBlO1xuICAgICAgICBKKHRoaXMsIFwicGFuXCIsIHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBhXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlICYmIGUuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYS5zZXRTdGF0ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBjID0gWzFdO1xuICAgICAgICAgIFwieHlcIiA9PT0gaCA/IGMgPSBbMSwgMF0gOiBcInlcIiA9PT0gaCAmJiAoYyA9IFswXSk7XG4gICAgICAgICAgYy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICB2YXIgZSA9IGRbYyA/IFwieEF4aXNcIiA6IFwieUF4aXNcIl1bMF0sXG4gICAgICAgICAgICAgICAgZiA9IGUub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBiID0gZS5ob3JpeixcbiAgICAgICAgICAgICAgICBoID0gYVtiID8gXCJjaGFydFhcIiA6IFwiY2hhcnRZXCJdO1xuICAgICAgICAgICAgYiA9IGIgPyBcIm1vdXNlRG93blhcIiA6IFwibW91c2VEb3duWVwiO1xuICAgICAgICAgICAgdmFyIGsgPSBkW2JdLFxuICAgICAgICAgICAgICAgIGwgPSAoZS5wb2ludFJhbmdlIHx8IDApIC8gMixcbiAgICAgICAgICAgICAgICBuID0gZS5yZXZlcnNlZCAmJiAhZC5pbnZlcnRlZCB8fCAhZS5yZXZlcnNlZCAmJiBkLmludmVydGVkID8gLTEgOiAxLFxuICAgICAgICAgICAgICAgIHEgPSBlLmdldEV4dHJlbWVzKCksXG4gICAgICAgICAgICAgICAgdiA9IGUudG9WYWx1ZShrIC0gaCwgITApICsgbCAqIG47XG4gICAgICAgICAgICBuID0gZS50b1ZhbHVlKGsgKyBlLmxlbiAtIGgsICEwKSAtIGwgKiBuO1xuICAgICAgICAgICAgdmFyIG0gPSBuIDwgdjtcbiAgICAgICAgICAgIGsgPSBtID8gbiA6IHY7XG4gICAgICAgICAgICB2ID0gbSA/IHYgOiBuO1xuICAgICAgICAgICAgbiA9IE1hdGgubWluKHEuZGF0YU1pbiwgbCA/IHEubWluIDogZS50b1ZhbHVlKGUudG9QaXhlbHMocS5taW4pIC0gZS5taW5QaXhlbFBhZGRpbmcpKTtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1heChxLmRhdGFNYXgsIGwgPyBxLm1heCA6IGUudG9WYWx1ZShlLnRvUGl4ZWxzKHEubWF4KSArIGUubWluUGl4ZWxQYWRkaW5nKSk7XG5cbiAgICAgICAgICAgIGlmICghZi5vcmRpbmFsKSB7XG4gICAgICAgICAgICAgIGMgJiYgKGYgPSBuIC0gaywgMCA8IGYgJiYgKHYgKz0gZiwgayA9IG4pLCBmID0gdiAtIGwsIDAgPCBmICYmICh2ID0gbCwgayAtPSBmKSk7XG4gICAgICAgICAgICAgIGlmIChlLnNlcmllcy5sZW5ndGggJiYgayAhPT0gcS5taW4gJiYgdiAhPT0gcS5tYXggJiYgYyB8fCBlLnBhbm5pbmdTdGF0ZSAmJiBrID49IGUucGFubmluZ1N0YXRlLnN0YXJ0TWluICYmIHYgPD0gZS5wYW5uaW5nU3RhdGUuc3RhcnRNYXgpIGUuc2V0RXh0cmVtZXMoaywgdiwgITEsICExLCB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlcjogXCJwYW5cIlxuICAgICAgICAgICAgICB9KSwgZyA9ICEwO1xuICAgICAgICAgICAgICBkW2JdID0gaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBnICYmIGQucmVkcmF3KCExKTtcbiAgICAgICAgICBFKGQuY29udGFpbmVyLCB7XG4gICAgICAgICAgICBjdXJzb3I6IFwibW92ZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIEcoci5wcm90b3R5cGUsIHtcbiAgICAgIHNlbGVjdDogZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgICAgZSA9IGQuc2VyaWVzLFxuICAgICAgICAgICAgZiA9IGUuY2hhcnQ7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRTdGFnaW5nID0gYSA9IHEoYSwgIWQuc2VsZWN0ZWQpO1xuICAgICAgICBkLmZpcmVQb2ludEV2ZW50KGEgPyBcInNlbGVjdFwiIDogXCJ1bnNlbGVjdFwiLCB7XG4gICAgICAgICAgYWNjdW11bGF0ZTogY1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZC5zZWxlY3RlZCA9IGQub3B0aW9ucy5zZWxlY3RlZCA9IGE7XG4gICAgICAgICAgZS5vcHRpb25zLmRhdGFbZS5kYXRhLmluZGV4T2YoZCldID0gZC5vcHRpb25zO1xuICAgICAgICAgIGQuc2V0U3RhdGUoYSAmJiBcInNlbGVjdFwiKTtcbiAgICAgICAgICBjIHx8IGYuZ2V0U2VsZWN0ZWRQb2ludHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGEuc2VyaWVzO1xuICAgICAgICAgICAgYS5zZWxlY3RlZCAmJiBhICE9PSBkICYmIChhLnNlbGVjdGVkID0gYS5vcHRpb25zLnNlbGVjdGVkID0gITEsIGMub3B0aW9ucy5kYXRhW2MuZGF0YS5pbmRleE9mKGEpXSA9IGEub3B0aW9ucywgYS5zZXRTdGF0ZShmLmhvdmVyUG9pbnRzICYmIGMub3B0aW9ucy5pbmFjdGl2ZU90aGVyUG9pbnRzID8gXCJpbmFjdGl2ZVwiIDogXCJcIiksIGEuZmlyZVBvaW50RXZlbnQoXCJ1bnNlbGVjdFwiKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgdGhpcy5zZWxlY3RlZFN0YWdpbmc7XG4gICAgICB9LFxuICAgICAgb25Nb3VzZU92ZXI6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5zZXJpZXMuY2hhcnQsXG4gICAgICAgICAgICBkID0gYy5wb2ludGVyO1xuICAgICAgICBhID0gYSA/IGQubm9ybWFsaXplKGEpIDogZC5nZXRDaGFydENvb3JkaW5hdGVzRnJvbVBvaW50KHRoaXMsIGMuaW52ZXJ0ZWQpO1xuICAgICAgICBkLnJ1blBvaW50QWN0aW9ucyhhLCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICBvbk1vdXNlT3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5zZXJpZXMuY2hhcnQ7XG4gICAgICAgIHRoaXMuZmlyZVBvaW50RXZlbnQoXCJtb3VzZU91dFwiKTtcbiAgICAgICAgdGhpcy5zZXJpZXMub3B0aW9ucy5pbmFjdGl2ZU90aGVyUG9pbnRzIHx8IChhLmhvdmVyUG9pbnRzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYS5zZXRTdGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgYS5ob3ZlclBvaW50cyA9IGEuaG92ZXJQb2ludCA9IG51bGw7XG4gICAgICB9LFxuICAgICAgaW1wb3J0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNJbXBvcnRlZEV2ZW50cykge1xuICAgICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgICAgYyA9IGgoYS5zZXJpZXMub3B0aW9ucy5wb2ludCwgYS5vcHRpb25zKS5ldmVudHM7XG4gICAgICAgICAgYS5ldmVudHMgPSBjO1xuICAgICAgICAgIE4oYywgZnVuY3Rpb24gKGMsIGQpIHtcbiAgICAgICAgICAgIHQoYykgJiYgSShhLCBkLCBjKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmhhc0ltcG9ydGVkRXZlbnRzID0gITA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXRTdGF0ZTogZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLnNlcmllcyxcbiAgICAgICAgICAgIGYgPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgZyA9IGQub3B0aW9ucy5zdGF0ZXNbYSB8fCBcIm5vcm1hbFwiXSB8fCB7fSxcbiAgICAgICAgICAgIGggPSBlW2QudHlwZV0ubWFya2VyICYmIGQub3B0aW9ucy5tYXJrZXIsXG4gICAgICAgICAgICBrID0gaCAmJiAhMSA9PT0gaC5lbmFibGVkLFxuICAgICAgICAgICAgbCA9IGggJiYgaC5zdGF0ZXMgJiYgaC5zdGF0ZXNbYSB8fCBcIm5vcm1hbFwiXSB8fCB7fSxcbiAgICAgICAgICAgIG4gPSAhMSA9PT0gbC5lbmFibGVkLFxuICAgICAgICAgICAgciA9IGQuc3RhdGVNYXJrZXJHcmFwaGljLFxuICAgICAgICAgICAgcCA9IHRoaXMubWFya2VyIHx8IHt9LFxuICAgICAgICAgICAgYiA9IGQuY2hhcnQsXG4gICAgICAgICAgICB0ID0gZC5oYWxvLFxuICAgICAgICAgICAgdSxcbiAgICAgICAgICAgIHkgPSBoICYmIGQubWFya2VyQXR0cmlicztcbiAgICAgICAgYSA9IGEgfHwgXCJcIjtcblxuICAgICAgICBpZiAoIShhID09PSB0aGlzLnN0YXRlICYmICFjIHx8IHRoaXMuc2VsZWN0ZWQgJiYgXCJzZWxlY3RcIiAhPT0gYSB8fCAhMSA9PT0gZy5lbmFibGVkIHx8IGEgJiYgKG4gfHwgayAmJiAhMSA9PT0gbC5lbmFibGVkKSB8fCBhICYmIHAuc3RhdGVzICYmIHAuc3RhdGVzW2FdICYmICExID09PSBwLnN0YXRlc1thXS5lbmFibGVkKSkge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBhO1xuICAgICAgICAgIHkgJiYgKHUgPSBkLm1hcmtlckF0dHJpYnModGhpcywgYSkpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZ3JhcGhpYykge1xuICAgICAgICAgICAgZiAmJiB0aGlzLmdyYXBoaWMucmVtb3ZlQ2xhc3MoXCJoaWdoY2hhcnRzLXBvaW50LVwiICsgZik7XG4gICAgICAgICAgICBhICYmIHRoaXMuZ3JhcGhpYy5hZGRDbGFzcyhcImhpZ2hjaGFydHMtcG9pbnQtXCIgKyBhKTtcblxuICAgICAgICAgICAgaWYgKCFiLnN0eWxlZE1vZGUpIHtcbiAgICAgICAgICAgICAgdmFyIEEgPSBkLnBvaW50QXR0cmlicyh0aGlzLCBhKTtcbiAgICAgICAgICAgICAgdmFyIEQgPSBxKGIub3B0aW9ucy5jaGFydC5hbmltYXRpb24sIGcuYW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgZC5vcHRpb25zLmluYWN0aXZlT3RoZXJQb2ludHMgJiYgKCh0aGlzLmRhdGFMYWJlbHMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICBhICYmIGEuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgICBvcGFjaXR5OiBBLm9wYWNpdHlcbiAgICAgICAgICAgICAgICB9LCBEKTtcbiAgICAgICAgICAgICAgfSksIHRoaXMuY29ubmVjdG9yICYmIHRoaXMuY29ubmVjdG9yLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IEEub3BhY2l0eVxuICAgICAgICAgICAgICB9LCBEKSk7XG4gICAgICAgICAgICAgIHRoaXMuZ3JhcGhpYy5hbmltYXRlKEEsIEQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1ICYmIHRoaXMuZ3JhcGhpYy5hbmltYXRlKHUsIHEoYi5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbiwgbC5hbmltYXRpb24sIGguYW5pbWF0aW9uKSk7XG4gICAgICAgICAgICByICYmIHIuaGlkZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYSAmJiBsKSB7XG4gICAgICAgICAgICAgIGYgPSBwLnN5bWJvbCB8fCBkLnN5bWJvbDtcbiAgICAgICAgICAgICAgciAmJiByLmN1cnJlbnRTeW1ib2wgIT09IGYgJiYgKHIgPSByLmRlc3Ryb3koKSk7XG4gICAgICAgICAgICAgIGlmICh1KSBpZiAocikgcltjID8gXCJhbmltYXRlXCIgOiBcImF0dHJcIl0oe1xuICAgICAgICAgICAgICAgIHg6IHUueCxcbiAgICAgICAgICAgICAgICB5OiB1LnlcbiAgICAgICAgICAgICAgfSk7ZWxzZSBmICYmIChkLnN0YXRlTWFya2VyR3JhcGhpYyA9IHIgPSBiLnJlbmRlcmVyLnN5bWJvbChmLCB1LngsIHUueSwgdS53aWR0aCwgdS5oZWlnaHQpLmFkZChkLm1hcmtlckdyb3VwKSwgci5jdXJyZW50U3ltYm9sID0gZik7XG4gICAgICAgICAgICAgICFiLnN0eWxlZE1vZGUgJiYgciAmJiByLmF0dHIoZC5wb2ludEF0dHJpYnModGhpcywgYSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByICYmIChyW2EgJiYgdGhpcy5pc0luc2lkZSA/IFwic2hvd1wiIDogXCJoaWRlXCJdKCksIHIuZWxlbWVudC5wb2ludCA9IHRoaXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGEgPSBnLmhhbG87XG4gICAgICAgICAgZyA9IChyID0gdGhpcy5ncmFwaGljIHx8IHIpICYmIHIudmlzaWJpbGl0eSB8fCBcImluaGVyaXRcIjtcbiAgICAgICAgICBhICYmIGEuc2l6ZSAmJiByICYmIFwiaGlkZGVuXCIgIT09IGcgJiYgIXRoaXMuaXNDbHVzdGVyID8gKHQgfHwgKGQuaGFsbyA9IHQgPSBiLnJlbmRlcmVyLnBhdGgoKS5hZGQoci5wYXJlbnRHcm91cCkpLCB0LnNob3coKVtjID8gXCJhbmltYXRlXCIgOiBcImF0dHJcIl0oe1xuICAgICAgICAgICAgZDogdGhpcy5oYWxvUGF0aChhLnNpemUpXG4gICAgICAgICAgfSksIHQuYXR0cih7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiaGlnaGNoYXJ0cy1oYWxvIGhpZ2hjaGFydHMtY29sb3ItXCIgKyBxKHRoaXMuY29sb3JJbmRleCwgZC5jb2xvckluZGV4KSArICh0aGlzLmNsYXNzTmFtZSA/IFwiIFwiICsgdGhpcy5jbGFzc05hbWUgOiBcIlwiKSxcbiAgICAgICAgICAgIHZpc2liaWxpdHk6IGcsXG4gICAgICAgICAgICB6SW5kZXg6IC0xXG4gICAgICAgICAgfSksIHQucG9pbnQgPSB0aGlzLCBiLnN0eWxlZE1vZGUgfHwgdC5hdHRyKEcoe1xuICAgICAgICAgICAgZmlsbDogdGhpcy5jb2xvciB8fCBkLmNvbG9yLFxuICAgICAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjogYS5vcGFjaXR5XG4gICAgICAgICAgfSwgYS5hdHRyaWJ1dGVzKSkpIDogdCAmJiB0LnBvaW50ICYmIHQucG9pbnQuaGFsb1BhdGggJiYgdC5hbmltYXRlKHtcbiAgICAgICAgICAgIGQ6IHQucG9pbnQuaGFsb1BhdGgoMClcbiAgICAgICAgICB9LCBudWxsLCB0LmhpZGUpO1xuICAgICAgICAgIEoodGhpcywgXCJhZnRlclNldFN0YXRlXCIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGFsb1BhdGg6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcmllcy5jaGFydC5yZW5kZXJlci5zeW1ib2xzLmNpcmNsZShNYXRoLmZsb29yKHRoaXMucGxvdFgpIC0gYSwgdGhpcy5wbG90WSAtIGEsIDIgKiBhLCAyICogYSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgRyhrLnByb3RvdHlwZSwge1xuICAgICAgb25Nb3VzZU92ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgYyA9IGEuaG92ZXJTZXJpZXM7XG4gICAgICAgIGlmIChjICYmIGMgIT09IHRoaXMpIGMub25Nb3VzZU91dCgpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuZXZlbnRzLm1vdXNlT3ZlciAmJiBKKHRoaXMsIFwibW91c2VPdmVyXCIpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwiaG92ZXJcIik7XG4gICAgICAgIGEuaG92ZXJTZXJpZXMgPSB0aGlzO1xuICAgICAgfSxcbiAgICAgIG9uTW91c2VPdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBjID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGQgPSBjLnRvb2x0aXAsXG4gICAgICAgICAgICBlID0gYy5ob3ZlclBvaW50O1xuICAgICAgICBjLmhvdmVyU2VyaWVzID0gbnVsbDtcbiAgICAgICAgaWYgKGUpIGUub25Nb3VzZU91dCgpO1xuICAgICAgICB0aGlzICYmIGEuZXZlbnRzLm1vdXNlT3V0ICYmIEoodGhpcywgXCJtb3VzZU91dFwiKTtcbiAgICAgICAgIWQgfHwgdGhpcy5zdGlja3lUcmFja2luZyB8fCBkLnNoYXJlZCAmJiAhdGhpcy5ub1NoYXJlZFRvb2x0aXAgfHwgZC5oaWRlKCk7XG4gICAgICAgIGMuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhLnNldFN0YXRlKFwiXCIsICEwKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc2V0U3RhdGU6IGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICAgIGUgPSBkLm9wdGlvbnMsXG4gICAgICAgICAgICBmID0gZC5ncmFwaCxcbiAgICAgICAgICAgIGcgPSBlLmluYWN0aXZlT3RoZXJQb2ludHMsXG4gICAgICAgICAgICBoID0gZS5zdGF0ZXMsXG4gICAgICAgICAgICBrID0gZS5saW5lV2lkdGgsXG4gICAgICAgICAgICBsID0gZS5vcGFjaXR5LFxuICAgICAgICAgICAgbiA9IHEoaFthIHx8IFwibm9ybWFsXCJdICYmIGhbYSB8fCBcIm5vcm1hbFwiXS5hbmltYXRpb24sIGQuY2hhcnQub3B0aW9ucy5jaGFydC5hbmltYXRpb24pO1xuICAgICAgICBlID0gMDtcbiAgICAgICAgYSA9IGEgfHwgXCJcIjtcblxuICAgICAgICBpZiAoZC5zdGF0ZSAhPT0gYSAmJiAoW2QuZ3JvdXAsIGQubWFya2VyR3JvdXAsIGQuZGF0YUxhYmVsc0dyb3VwXS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgYyAmJiAoZC5zdGF0ZSAmJiBjLnJlbW92ZUNsYXNzKFwiaGlnaGNoYXJ0cy1zZXJpZXMtXCIgKyBkLnN0YXRlKSwgYSAmJiBjLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1zZXJpZXMtXCIgKyBhKSk7XG4gICAgICAgIH0pLCBkLnN0YXRlID0gYSwgIWQuY2hhcnQuc3R5bGVkTW9kZSkpIHtcbiAgICAgICAgICBpZiAoaFthXSAmJiAhMSA9PT0gaFthXS5lbmFibGVkKSByZXR1cm47XG4gICAgICAgICAgYSAmJiAoayA9IGhbYV0ubGluZVdpZHRoIHx8IGsgKyAoaFthXS5saW5lV2lkdGhQbHVzIHx8IDApLCBsID0gcShoW2FdLm9wYWNpdHksIGwpKTtcbiAgICAgICAgICBpZiAoZiAmJiAhZi5kYXNoc3R5bGUpIGZvciAoaCA9IHtcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IGtcbiAgICAgICAgICB9LCBmLmFuaW1hdGUoaCwgbik7IGRbXCJ6b25lLWdyYXBoLVwiICsgZV07KSBkW1wiem9uZS1ncmFwaC1cIiArIGVdLmF0dHIoaCksIGUgKz0gMTtcbiAgICAgICAgICBnIHx8IFtkLmdyb3VwLCBkLm1hcmtlckdyb3VwLCBkLmRhdGFMYWJlbHNHcm91cCwgZC5sYWJlbEJ5U2VyaWVzXS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBhICYmIGEuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IGxcbiAgICAgICAgICAgIH0sIG4pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYyAmJiBnICYmIGQucG9pbnRzICYmIGQuc2V0QWxsUG9pbnRzVG9TdGF0ZShhKTtcbiAgICAgIH0sXG4gICAgICBzZXRBbGxQb2ludHNUb1N0YXRlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB0aGlzLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgYy5zZXRTdGF0ZSAmJiBjLnNldFN0YXRlKGEpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzZXRWaXNpYmxlOiBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgICBlID0gZC5jaGFydCxcbiAgICAgICAgICAgIGYgPSBkLmxlZ2VuZEl0ZW0sXG4gICAgICAgICAgICBnID0gZS5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcyxcbiAgICAgICAgICAgIGggPSBkLnZpc2libGU7XG4gICAgICAgIHZhciBrID0gKGQudmlzaWJsZSA9IGEgPSBkLm9wdGlvbnMudmlzaWJsZSA9IGQudXNlck9wdGlvbnMudmlzaWJsZSA9IFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBhID8gIWggOiBhKSA/IFwic2hvd1wiIDogXCJoaWRlXCI7XG4gICAgICAgIFtcImdyb3VwXCIsIFwiZGF0YUxhYmVsc0dyb3VwXCIsIFwibWFya2VyR3JvdXBcIiwgXCJ0cmFja2VyXCIsIFwidHRcIl0uZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGlmIChkW2FdKSBkW2FdW2tdKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZS5ob3ZlclNlcmllcyA9PT0gZCB8fCAoZS5ob3ZlclBvaW50ICYmIGUuaG92ZXJQb2ludC5zZXJpZXMpID09PSBkKSBkLm9uTW91c2VPdXQoKTtcbiAgICAgICAgZiAmJiBlLmxlZ2VuZC5jb2xvcml6ZUl0ZW0oZCwgYSk7XG4gICAgICAgIGQuaXNEaXJ0eSA9ICEwO1xuICAgICAgICBkLm9wdGlvbnMuc3RhY2tpbmcgJiYgZS5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEub3B0aW9ucy5zdGFja2luZyAmJiBhLnZpc2libGUgJiYgKGEuaXNEaXJ0eSA9ICEwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGQubGlua2VkU2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBjLnNldFZpc2libGUoYSwgITEpO1xuICAgICAgICB9KTtcbiAgICAgICAgZyAmJiAoZS5pc0RpcnR5Qm94ID0gITApO1xuICAgICAgICBKKGQsIGspO1xuICAgICAgICAhMSAhPT0gYyAmJiBlLnJlZHJhdygpO1xuICAgICAgfSxcbiAgICAgIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRWaXNpYmxlKCEwKTtcbiAgICAgIH0sXG4gICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0VmlzaWJsZSghMSk7XG4gICAgICB9LFxuICAgICAgc2VsZWN0OiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gYSA9IHRoaXMub3B0aW9ucy5zZWxlY3RlZCA9IFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBhID8gIXRoaXMuc2VsZWN0ZWQgOiBhO1xuICAgICAgICB0aGlzLmNoZWNrYm94ICYmICh0aGlzLmNoZWNrYm94LmNoZWNrZWQgPSBhKTtcbiAgICAgICAgSih0aGlzLCBhID8gXCJzZWxlY3RcIiA6IFwidW5zZWxlY3RcIik7XG4gICAgICB9LFxuICAgICAgZHJhd1RyYWNrZXI6IGQuZHJhd1RyYWNrZXJHcmFwaFxuICAgIH0pO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL1Jlc3BvbnNpdmUuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcpIHtcbiAgICB2YXIgciA9IGcuZmluZCxcbiAgICAgICAgdSA9IGcuaXNBcnJheSxcbiAgICAgICAgSSA9IGcuaXNPYmplY3QsXG4gICAgICAgIE0gPSBnLm1lcmdlLFxuICAgICAgICBFID0gZy5vYmplY3RFYWNoLFxuICAgICAgICBBID0gZy5waWNrLFxuICAgICAgICBHID0gZy5zcGxhdCxcbiAgICAgICAgSiA9IGcudW5pcXVlS2V5O1xuICAgIGQgPSBkLkNoYXJ0O1xuXG4gICAgZC5wcm90b3R5cGUuc2V0UmVzcG9uc2l2ZSA9IGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgICB2YXIgdCA9IHRoaXMub3B0aW9ucy5yZXNwb25zaXZlLFxuICAgICAgICAgIGggPSBbXSxcbiAgICAgICAgICB1ID0gdGhpcy5jdXJyZW50UmVzcG9uc2l2ZTtcbiAgICAgICFnICYmIHQgJiYgdC5ydWxlcyAmJiB0LnJ1bGVzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGQuX2lkICYmIChkLl9pZCA9IEooKSk7XG4gICAgICAgIHRoaXMubWF0Y2hSZXNwb25zaXZlUnVsZShkLCBoKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgZyA9IE0uYXBwbHkoMCwgaC5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHIodC5ydWxlcywgZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgICByZXR1cm4gZy5faWQgPT09IGQ7XG4gICAgICAgIH0pLmNoYXJ0T3B0aW9ucztcbiAgICAgIH0pKTtcbiAgICAgIGcuaXNSZXNwb25zaXZlT3B0aW9ucyA9ICEwO1xuICAgICAgaCA9IGgudG9TdHJpbmcoKSB8fCB2b2lkIDA7XG4gICAgICBoICE9PSAodSAmJiB1LnJ1bGVJZHMpICYmICh1ICYmIHRoaXMudXBkYXRlKHUudW5kb09wdGlvbnMsIGQsICEwKSwgaCA/ICh1ID0gdGhpcy5jdXJyZW50T3B0aW9ucyhnKSwgdS5pc1Jlc3BvbnNpdmVPcHRpb25zID0gITAsIHRoaXMuY3VycmVudFJlc3BvbnNpdmUgPSB7XG4gICAgICAgIHJ1bGVJZHM6IGgsXG4gICAgICAgIG1lcmdlZE9wdGlvbnM6IGcsXG4gICAgICAgIHVuZG9PcHRpb25zOiB1XG4gICAgICB9LCB0aGlzLnVwZGF0ZShnLCBkLCAhMCkpIDogdGhpcy5jdXJyZW50UmVzcG9uc2l2ZSA9IHZvaWQgMCk7XG4gICAgfTtcblxuICAgIGQucHJvdG90eXBlLm1hdGNoUmVzcG9uc2l2ZVJ1bGUgPSBmdW5jdGlvbiAoZCwgZykge1xuICAgICAgdmFyIHIgPSBkLmNvbmRpdGlvbjtcbiAgICAgIChyLmNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhcnRXaWR0aCA8PSBBKHIubWF4V2lkdGgsIE51bWJlci5NQVhfVkFMVUUpICYmIHRoaXMuY2hhcnRIZWlnaHQgPD0gQShyLm1heEhlaWdodCwgTnVtYmVyLk1BWF9WQUxVRSkgJiYgdGhpcy5jaGFydFdpZHRoID49IEEoci5taW5XaWR0aCwgMCkgJiYgdGhpcy5jaGFydEhlaWdodCA+PSBBKHIubWluSGVpZ2h0LCAwKTtcbiAgICAgIH0pLmNhbGwodGhpcykgJiYgZy5wdXNoKGQuX2lkKTtcbiAgICB9O1xuXG4gICAgZC5wcm90b3R5cGUuY3VycmVudE9wdGlvbnMgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgZnVuY3Rpb24gZyhkLCBoLCB0LCBlKSB7XG4gICAgICAgIHZhciBjO1xuICAgICAgICBFKGQsIGZ1bmN0aW9uIChkLCBuKSB7XG4gICAgICAgICAgaWYgKCFlICYmIC0xIDwgci5jb2xsZWN0aW9uc1dpdGhVcGRhdGUuaW5kZXhPZihuKSkgZm9yIChkID0gRyhkKSwgdFtuXSA9IFtdLCBjID0gMDsgYyA8IGQubGVuZ3RoOyBjKyspIGhbbl1bY10gJiYgKHRbbl1bY10gPSB7fSwgZyhkW2NdLCBoW25dW2NdLCB0W25dW2NdLCBlICsgMSkpO2Vsc2UgSShkKSA/ICh0W25dID0gdShkKSA/IFtdIDoge30sIGcoZCwgaFtuXSB8fCB7fSwgdFtuXSwgZSArIDEpKSA6IHRbbl0gPSBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgaFtuXSA/IG51bGwgOiBoW25dO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHIgPSB0aGlzLFxuICAgICAgICAgIGggPSB7fTtcbiAgICAgIGcoZCwgdGhpcy5vcHRpb25zLCBoLCAwKTtcbiAgICAgIHJldHVybiBoO1xuICAgIH07XG4gIH0pO1xuICBTKHIsIFwibWFzdGVycy9oaWdoY2hhcnRzLnNyYy5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl1dLCBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkO1xuICB9KTtcbiAgcltcIm1hc3RlcnMvaGlnaGNoYXJ0cy5zcmMuanNcIl0uX21vZHVsZXMgPSByO1xuICByZXR1cm4gcltcIm1hc3RlcnMvaGlnaGNoYXJ0cy5zcmMuanNcIl07XG59KTsiLCIvKlxuIEhpZ2hjaGFydHMgSlMgdjguMC40ICgyMDIwLTAzLTEwKVxuXG4gRXhwb3J0aW5nIG1vZHVsZVxuXG4gKGMpIDIwMTAtMjAxOSBUb3JzdGVpbiBIb25zaVxuXG4gTGljZW5zZTogd3d3LmhpZ2hjaGFydHMuY29tL2xpY2Vuc2VcbiovXG4oZnVuY3Rpb24gKGUpIHtcbiAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cyA/IChlW1wiZGVmYXVsdFwiXSA9IGUsIG1vZHVsZS5leHBvcnRzID0gZSkgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShcImhpZ2hjaGFydHMvbW9kdWxlcy9leHBvcnRpbmdcIiwgW1wiaGlnaGNoYXJ0c1wiXSwgZnVuY3Rpb24gKG0pIHtcbiAgICBlKG0pO1xuICAgIGUuSGlnaGNoYXJ0cyA9IG07XG4gICAgcmV0dXJuIGU7XG4gIH0pIDogZShcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgSGlnaGNoYXJ0cyA/IEhpZ2hjaGFydHMgOiB2b2lkIDApO1xufSkoZnVuY3Rpb24gKGUpIHtcbiAgZnVuY3Rpb24gbShmLCBnLCBlLCBuKSB7XG4gICAgZi5oYXNPd25Qcm9wZXJ0eShnKSB8fCAoZltnXSA9IG4uYXBwbHkobnVsbCwgZSkpO1xuICB9XG5cbiAgZSA9IGUgPyBlLl9tb2R1bGVzIDoge307XG4gIG0oZSwgXCJtb2R1bGVzL2Z1bGwtc2NyZWVuLnNyYy5qc1wiLCBbZVtcInBhcnRzL0dsb2JhbHMuanNcIl1dLCBmdW5jdGlvbiAoZikge1xuICAgIHZhciBnID0gZi5hZGRFdmVudCxcbiAgICAgICAgZSA9IGYuQ2hhcnQsXG4gICAgICAgIG4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBnKGgpIHtcbiAgICAgICAgdGhpcy5jaGFydCA9IGg7XG4gICAgICAgIHRoaXMuaXNPcGVuID0gITE7XG4gICAgICAgIGguY29udGFpbmVyLnBhcmVudE5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ICYmIChoID0gaC5jb250YWluZXIucGFyZW50Tm9kZSwgdGhpcy5icm93c2VyUHJvcHMgfHwgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGgucmVxdWVzdEZ1bGxzY3JlZW4gPyB0aGlzLmJyb3dzZXJQcm9wcyA9IHtcbiAgICAgICAgICBmdWxsc2NyZWVuQ2hhbmdlOiBcImZ1bGxzY3JlZW5jaGFuZ2VcIixcbiAgICAgICAgICByZXF1ZXN0RnVsbHNjcmVlbjogXCJyZXF1ZXN0RnVsbHNjcmVlblwiLFxuICAgICAgICAgIGV4aXRGdWxsc2NyZWVuOiBcImV4aXRGdWxsc2NyZWVuXCJcbiAgICAgICAgfSA6IGgubW96UmVxdWVzdEZ1bGxTY3JlZW4gPyB0aGlzLmJyb3dzZXJQcm9wcyA9IHtcbiAgICAgICAgICBmdWxsc2NyZWVuQ2hhbmdlOiBcIm1vemZ1bGxzY3JlZW5jaGFuZ2VcIixcbiAgICAgICAgICByZXF1ZXN0RnVsbHNjcmVlbjogXCJtb3pSZXF1ZXN0RnVsbFNjcmVlblwiLFxuICAgICAgICAgIGV4aXRGdWxsc2NyZWVuOiBcIm1vekNhbmNlbEZ1bGxTY3JlZW5cIlxuICAgICAgICB9IDogaC53ZWJraXRSZXF1ZXN0RnVsbFNjcmVlbiA/IHRoaXMuYnJvd3NlclByb3BzID0ge1xuICAgICAgICAgIGZ1bGxzY3JlZW5DaGFuZ2U6IFwid2Via2l0ZnVsbHNjcmVlbmNoYW5nZVwiLFxuICAgICAgICAgIHJlcXVlc3RGdWxsc2NyZWVuOiBcIndlYmtpdFJlcXVlc3RGdWxsU2NyZWVuXCIsXG4gICAgICAgICAgZXhpdEZ1bGxzY3JlZW46IFwid2Via2l0RXhpdEZ1bGxzY3JlZW5cIlxuICAgICAgICB9IDogaC5tc1JlcXVlc3RGdWxsc2NyZWVuICYmICh0aGlzLmJyb3dzZXJQcm9wcyA9IHtcbiAgICAgICAgICBmdWxsc2NyZWVuQ2hhbmdlOiBcIk1TRnVsbHNjcmVlbkNoYW5nZVwiLFxuICAgICAgICAgIHJlcXVlc3RGdWxsc2NyZWVuOiBcIm1zUmVxdWVzdEZ1bGxzY3JlZW5cIixcbiAgICAgICAgICBleGl0RnVsbHNjcmVlbjogXCJtc0V4aXRGdWxsc2NyZWVuXCJcbiAgICAgICAgfSkpKTtcbiAgICAgIH1cblxuICAgICAgZy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoID0gdGhpcy5jaGFydDtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuICYmIHRoaXMuYnJvd3NlclByb3BzICYmIGguY29udGFpbmVyLm93bmVyRG9jdW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudCkgaC5jb250YWluZXIub3duZXJEb2N1bWVudFt0aGlzLmJyb3dzZXJQcm9wcy5leGl0RnVsbHNjcmVlbl0oKTtcbiAgICAgICAgdGhpcy51bmJpbmRGdWxsc2NyZWVuRXZlbnQgJiYgdGhpcy51bmJpbmRGdWxsc2NyZWVuRXZlbnQoKTtcbiAgICAgICAgdGhpcy5pc09wZW4gPSAhMTtcbiAgICAgICAgdGhpcy5zZXRCdXR0b25UZXh0KCk7XG4gICAgICB9O1xuXG4gICAgICBnLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaCA9IHRoaXMsXG4gICAgICAgICAgICBnID0gaC5jaGFydDtcblxuICAgICAgICBpZiAoaC5icm93c2VyUHJvcHMpIHtcbiAgICAgICAgICBoLnVuYmluZEZ1bGxzY3JlZW5FdmVudCA9IGYuYWRkRXZlbnQoZy5jb250YWluZXIub3duZXJEb2N1bWVudCwgaC5icm93c2VyUHJvcHMuZnVsbHNjcmVlbkNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaC5pc09wZW4gPyAoaC5pc09wZW4gPSAhMSwgaC5jbG9zZSgpKSA6IChoLmlzT3BlbiA9ICEwLCBoLnNldEJ1dHRvblRleHQoKSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoZy5jb250YWluZXIucGFyZW50Tm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gZy5jb250YWluZXIucGFyZW50Tm9kZVtoLmJyb3dzZXJQcm9wcy5yZXF1ZXN0RnVsbHNjcmVlbl0oKTtcbiAgICAgICAgICAgIGlmIChlKSBlW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBhbGVydChcIkZ1bGwgc2NyZWVuIGlzIG5vdCBzdXBwb3J0ZWQgaW5zaWRlIGEgZnJhbWUuXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZi5hZGRFdmVudChnLCBcImRlc3Ryb3lcIiwgaC51bmJpbmRGdWxsc2NyZWVuRXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBnLnByb3RvdHlwZS5zZXRCdXR0b25UZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaCxcbiAgICAgICAgICAgIGcgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZiA9IGcuZXhwb3J0RGl2RWxlbWVudHMsXG4gICAgICAgICAgICBlID0gZy5vcHRpb25zLmV4cG9ydGluZyxcbiAgICAgICAgICAgIG4gPSBudWxsID09PSAoaCA9IG51bGwgPT09IGUgfHwgdm9pZCAwID09PSBlID8gdm9pZCAwIDogZS5idXR0b25zKSB8fCB2b2lkIDAgPT09IGggPyB2b2lkIDAgOiBoLmNvbnRleHRCdXR0b24ubWVudUl0ZW1zO1xuICAgICAgICBoID0gZy5vcHRpb25zLmxhbmc7XG4gICAgICAgIChudWxsID09PSBlIHx8IHZvaWQgMCA9PT0gZSA/IDAgOiBlLm1lbnVJdGVtRGVmaW5pdGlvbnMpICYmIChudWxsID09PSBoIHx8IHZvaWQgMCA9PT0gaCA/IDAgOiBoLmV4aXRGdWxsc2NyZWVuKSAmJiBoLnZpZXdGdWxsc2NyZWVuICYmIG4gJiYgZiAmJiBmLmxlbmd0aCAmJiAoZltuLmluZGV4T2YoXCJ2aWV3RnVsbHNjcmVlblwiKV0uaW5uZXJIVE1MID0gdGhpcy5pc09wZW4gPyBoLmV4aXRGdWxsc2NyZWVuIDogZS5tZW51SXRlbURlZmluaXRpb25zLnZpZXdGdWxsc2NyZWVuLnRleHQgfHwgaC52aWV3RnVsbHNjcmVlbik7XG4gICAgICB9O1xuXG4gICAgICBnLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNPcGVuID8gdGhpcy5jbG9zZSgpIDogdGhpcy5vcGVuKCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZztcbiAgICB9KCk7XG5cbiAgICBmLkZ1bGxzY3JlZW4gPSBuO1xuICAgIGcoZSwgXCJiZWZvcmVSZW5kZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5mdWxsc2NyZWVuID0gbmV3IGYuRnVsbHNjcmVlbih0aGlzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZi5GdWxsc2NyZWVuO1xuICB9KTtcbiAgbShlLCBcIm1peGlucy9uYXZpZ2F0aW9uLmpzXCIsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXRVcGRhdGU6IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIGYubmF2aWdhdGlvbiB8fCAoZi5uYXZpZ2F0aW9uID0ge1xuICAgICAgICAgIHVwZGF0ZXM6IFtdLFxuICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGcsIGYpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGUudXBkYXRlLmNhbGwoZS5jb250ZXh0LCBnLCBmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgYWRkVXBkYXRlOiBmdW5jdGlvbiAoZiwgZykge1xuICAgICAgICBnLm5hdmlnYXRpb24gfHwgdGhpcy5pbml0VXBkYXRlKGcpO1xuICAgICAgICBnLm5hdmlnYXRpb24udXBkYXRlcy5wdXNoKHtcbiAgICAgICAgICB1cGRhdGU6IGYsXG4gICAgICAgICAgY29udGV4dDogZ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgbShlLCBcIm1vZHVsZXMvZXhwb3J0aW5nLnNyYy5qc1wiLCBbZVtcInBhcnRzL0dsb2JhbHMuanNcIl0sIGVbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl0sIGVbXCJtaXhpbnMvbmF2aWdhdGlvbi5qc1wiXV0sIGZ1bmN0aW9uIChmLCBnLCBlKSB7XG4gICAgdmFyIG4gPSBnLmFkZEV2ZW50LFxuICAgICAgICB1ID0gZy5jc3MsXG4gICAgICAgIGggPSBnLmNyZWF0ZUVsZW1lbnQsXG4gICAgICAgIG0gPSBnLmRpc2NhcmRFbGVtZW50LFxuICAgICAgICB4ID0gZy5leHRlbmQsXG4gICAgICAgIEkgPSBnLmZpbmQsXG4gICAgICAgIEIgPSBnLmZpcmVFdmVudCxcbiAgICAgICAgSiA9IGcuaXNPYmplY3QsXG4gICAgICAgIHAgPSBnLm1lcmdlLFxuICAgICAgICBFID0gZy5vYmplY3RFYWNoLFxuICAgICAgICBxID0gZy5waWNrLFxuICAgICAgICBLID0gZy5yZW1vdmVFdmVudCxcbiAgICAgICAgTCA9IGcudW5pcXVlS2V5LFxuICAgICAgICB3ID0gZi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgeSA9IGYuZG9jLFxuICAgICAgICBDID0gZi5DaGFydCxcbiAgICAgICAgTSA9IGYuaXNUb3VjaERldmljZSxcbiAgICAgICAgeiA9IGYud2luLFxuICAgICAgICBHID0gei5uYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgICBGID0gZi5TVkdSZW5kZXJlcixcbiAgICAgICAgSCA9IGYuUmVuZGVyZXIucHJvdG90eXBlLnN5bWJvbHMsXG4gICAgICAgIE4gPSAvRWRnZVxcL3xUcmlkZW50XFwvfE1TSUUgLy50ZXN0KEcpLFxuICAgICAgICBPID0gL2ZpcmVmb3gvaS50ZXN0KEcpO1xuICAgIHgody5sYW5nLCB7XG4gICAgICB2aWV3RnVsbHNjcmVlbjogXCJWaWV3IGluIGZ1bGwgc2NyZWVuXCIsXG4gICAgICBleGl0RnVsbHNjcmVlbjogXCJFeGl0IGZyb20gZnVsbCBzY3JlZW5cIixcbiAgICAgIHByaW50Q2hhcnQ6IFwiUHJpbnQgY2hhcnRcIixcbiAgICAgIGRvd25sb2FkUE5HOiBcIkRvd25sb2FkIFBORyBpbWFnZVwiLFxuICAgICAgZG93bmxvYWRKUEVHOiBcIkRvd25sb2FkIEpQRUcgaW1hZ2VcIixcbiAgICAgIGRvd25sb2FkUERGOiBcIkRvd25sb2FkIFBERiBkb2N1bWVudFwiLFxuICAgICAgZG93bmxvYWRTVkc6IFwiRG93bmxvYWQgU1ZHIHZlY3RvciBpbWFnZVwiLFxuICAgICAgY29udGV4dEJ1dHRvblRpdGxlOiBcIkNoYXJ0IGNvbnRleHQgbWVudVwiXG4gICAgfSk7XG4gICAgdy5uYXZpZ2F0aW9uIHx8ICh3Lm5hdmlnYXRpb24gPSB7fSk7XG4gICAgcCghMCwgdy5uYXZpZ2F0aW9uLCB7XG4gICAgICBidXR0b25PcHRpb25zOiB7XG4gICAgICAgIHRoZW1lOiB7fSxcbiAgICAgICAgc3ltYm9sU2l6ZTogMTQsXG4gICAgICAgIHN5bWJvbFg6IDEyLjUsXG4gICAgICAgIHN5bWJvbFk6IDEwLjUsXG4gICAgICAgIGFsaWduOiBcInJpZ2h0XCIsXG4gICAgICAgIGJ1dHRvblNwYWNpbmc6IDMsXG4gICAgICAgIGhlaWdodDogMjIsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwidG9wXCIsXG4gICAgICAgIHdpZHRoOiAyNFxuICAgICAgfVxuICAgIH0pO1xuICAgIHAoITAsIHcubmF2aWdhdGlvbiwge1xuICAgICAgbWVudVN0eWxlOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzk5OTk5OVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNmZmZmZmZcIixcbiAgICAgICAgcGFkZGluZzogXCI1cHggMFwiXG4gICAgICB9LFxuICAgICAgbWVudUl0ZW1TdHlsZToge1xuICAgICAgICBwYWRkaW5nOiBcIjAuNWVtIDFlbVwiLFxuICAgICAgICBjb2xvcjogXCIjMzMzMzMzXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwibm9uZVwiLFxuICAgICAgICBmb250U2l6ZTogTSA/IFwiMTRweFwiIDogXCIxMXB4XCIsXG4gICAgICAgIHRyYW5zaXRpb246IFwiYmFja2dyb3VuZCAyNTBtcywgY29sb3IgMjUwbXNcIlxuICAgICAgfSxcbiAgICAgIG1lbnVJdGVtSG92ZXJTdHlsZToge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiMzMzVjYWRcIixcbiAgICAgICAgY29sb3I6IFwiI2ZmZmZmZlwiXG4gICAgICB9LFxuICAgICAgYnV0dG9uT3B0aW9uczoge1xuICAgICAgICBzeW1ib2xGaWxsOiBcIiM2NjY2NjZcIixcbiAgICAgICAgc3ltYm9sU3Ryb2tlOiBcIiM2NjY2NjZcIixcbiAgICAgICAgc3ltYm9sU3Ryb2tlV2lkdGg6IDMsXG4gICAgICAgIHRoZW1lOiB7XG4gICAgICAgICAgcGFkZGluZzogNVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdy5leHBvcnRpbmcgPSB7XG4gICAgICB0eXBlOiBcImltYWdlL3BuZ1wiLFxuICAgICAgdXJsOiBcImh0dHBzOi8vZXhwb3J0LmhpZ2hjaGFydHMuY29tL1wiLFxuICAgICAgcHJpbnRNYXhXaWR0aDogNzgwLFxuICAgICAgc2NhbGU6IDIsXG4gICAgICBidXR0b25zOiB7XG4gICAgICAgIGNvbnRleHRCdXR0b246IHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiaGlnaGNoYXJ0cy1jb250ZXh0YnV0dG9uXCIsXG4gICAgICAgICAgbWVudUNsYXNzTmFtZTogXCJoaWdoY2hhcnRzLWNvbnRleHRtZW51XCIsXG4gICAgICAgICAgc3ltYm9sOiBcIm1lbnVcIixcbiAgICAgICAgICB0aXRsZUtleTogXCJjb250ZXh0QnV0dG9uVGl0bGVcIixcbiAgICAgICAgICBtZW51SXRlbXM6IFwidmlld0Z1bGxzY3JlZW4gcHJpbnRDaGFydCBzZXBhcmF0b3IgZG93bmxvYWRQTkcgZG93bmxvYWRKUEVHIGRvd25sb2FkUERGIGRvd25sb2FkU1ZHXCIuc3BsaXQoXCIgXCIpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZW51SXRlbURlZmluaXRpb25zOiB7XG4gICAgICAgIHZpZXdGdWxsc2NyZWVuOiB7XG4gICAgICAgICAgdGV4dEtleTogXCJ2aWV3RnVsbHNjcmVlblwiLFxuICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZnVsbHNjcmVlbi50b2dnbGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByaW50Q2hhcnQ6IHtcbiAgICAgICAgICB0ZXh0S2V5OiBcInByaW50Q2hhcnRcIixcbiAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnByaW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXBhcmF0b3I6IHtcbiAgICAgICAgICBzZXBhcmF0b3I6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGRvd25sb2FkUE5HOiB7XG4gICAgICAgICAgdGV4dEtleTogXCJkb3dubG9hZFBOR1wiLFxuICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwb3J0Q2hhcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRvd25sb2FkSlBFRzoge1xuICAgICAgICAgIHRleHRLZXk6IFwiZG93bmxvYWRKUEVHXCIsXG4gICAgICAgICAgb25jbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5leHBvcnRDaGFydCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2UvanBlZ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRvd25sb2FkUERGOiB7XG4gICAgICAgICAgdGV4dEtleTogXCJkb3dubG9hZFBERlwiLFxuICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwb3J0Q2hhcnQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL3BkZlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRvd25sb2FkU1ZHOiB7XG4gICAgICAgICAgdGV4dEtleTogXCJkb3dubG9hZFNWR1wiLFxuICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwb3J0Q2hhcnQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImltYWdlL3N2Zyt4bWxcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGYucG9zdCA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICB2YXIgZCA9IGgoXCJmb3JtXCIsIHAoe1xuICAgICAgICBtZXRob2Q6IFwicG9zdFwiLFxuICAgICAgICBhY3Rpb246IGEsXG4gICAgICAgIGVuY3R5cGU6IFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiXG4gICAgICB9LCBjKSwge1xuICAgICAgICBkaXNwbGF5OiBcIm5vbmVcIlxuICAgICAgfSwgeS5ib2R5KTtcbiAgICAgIEUoYiwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgaChcImlucHV0XCIsIHtcbiAgICAgICAgICB0eXBlOiBcImhpZGRlblwiLFxuICAgICAgICAgIG5hbWU6IGIsXG4gICAgICAgICAgdmFsdWU6IGFcbiAgICAgICAgfSwgbnVsbCwgZCk7XG4gICAgICB9KTtcbiAgICAgIGQuc3VibWl0KCk7XG4gICAgICBtKGQpO1xuICAgIH07XG5cbiAgICBmLmlzU2FmYXJpICYmIGYud2luLm1hdGNoTWVkaWEoXCJwcmludFwiKS5hZGRMaXN0ZW5lcihmdW5jdGlvbiAoYSkge1xuICAgICAgZi5wcmludGluZ0NoYXJ0ICYmIChhLm1hdGNoZXMgPyBmLnByaW50aW5nQ2hhcnQuYmVmb3JlUHJpbnQoKSA6IGYucHJpbnRpbmdDaGFydC5hZnRlclByaW50KCkpO1xuICAgIH0pO1xuICAgIHgoQy5wcm90b3R5cGUsIHtcbiAgICAgIHNhbml0aXplU1ZHOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgYyA9IGEuaW5kZXhPZihcIjwvc3ZnPlwiKSArIDYsXG4gICAgICAgICAgICBkID0gYS5zdWJzdHIoYyk7XG4gICAgICAgIGEgPSBhLnN1YnN0cigwLCBjKTtcbiAgICAgICAgYiAmJiBiLmV4cG9ydGluZyAmJiBiLmV4cG9ydGluZy5hbGxvd0hUTUwgJiYgZCAmJiAoZCA9ICc8Zm9yZWlnbk9iamVjdCB4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCInICsgYi5jaGFydC53aWR0aCArICdcIiBoZWlnaHQ9XCInICsgYi5jaGFydC5oZWlnaHQgKyAnXCI+PGJvZHkgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI+JyArIGQgKyBcIjwvYm9keT48L2ZvcmVpZ25PYmplY3Q+XCIsIGEgPSBhLnJlcGxhY2UoXCI8L3N2Zz5cIiwgZCArIFwiPC9zdmc+XCIpKTtcbiAgICAgICAgYSA9IGEucmVwbGFjZSgvekluZGV4PVwiW15cIl0rXCIvZywgXCJcIikucmVwbGFjZSgvc3ltYm9sTmFtZT1cIlteXCJdK1wiL2csIFwiXCIpLnJlcGxhY2UoL2pRdWVyeVswLTldKz1cIlteXCJdK1wiL2csIFwiXCIpLnJlcGxhY2UoL3VybFxcKChcInwmcXVvdDspKC4qPykoXCJ8JnF1b3Q7KTs/XFwpL2csIFwidXJsKCQyKVwiKS5yZXBsYWNlKC91cmxcXChbXiNdKyMvZywgXCJ1cmwoI1wiKS5yZXBsYWNlKC88c3ZnIC8sICc8c3ZnIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiICcpLnJlcGxhY2UoLyAofE5TWzAtOV0rOilocmVmPS9nLCBcIiB4bGluazpocmVmPVwiKS5yZXBsYWNlKC9cXG4vLCBcIiBcIikucmVwbGFjZSgvKGZpbGx8c3Ryb2tlKT1cInJnYmFcXCgoWyAwLTldKyxbIDAtOV0rLFsgMC05XSspLChbIDAtOVxcLl0rKVxcKVwiL2csICckMT1cInJnYigkMilcIiAkMS1vcGFjaXR5PVwiJDNcIicpLnJlcGxhY2UoLyZuYnNwOy9nLCBcIlxcdTAwYTBcIikucmVwbGFjZSgvJnNoeTsvZywgXCJcXHUwMGFkXCIpO1xuICAgICAgICB0aGlzLmllU2FuaXRpemVTVkcgJiYgKGEgPSB0aGlzLmllU2FuaXRpemVTVkcoYSkpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sXG4gICAgICBnZXRDaGFydEhUTUw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdHlsZWRNb2RlICYmIHRoaXMuaW5saW5lU3R5bGVzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgICB9LFxuICAgICAgZ2V0U1ZHOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYixcbiAgICAgICAgICAgIGMgPSBwKHRoaXMub3B0aW9ucywgYSk7XG4gICAgICAgIGMucGxvdE9wdGlvbnMgPSBwKHRoaXMudXNlck9wdGlvbnMucGxvdE9wdGlvbnMsIGEgJiYgYS5wbG90T3B0aW9ucyk7XG4gICAgICAgIGMudGltZSA9IHAodGhpcy51c2VyT3B0aW9ucy50aW1lLCBhICYmIGEudGltZSk7XG4gICAgICAgIHZhciBkID0gaChcImRpdlwiLCBudWxsLCB7XG4gICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICB0b3A6IFwiLTk5OTllbVwiLFxuICAgICAgICAgIHdpZHRoOiB0aGlzLmNoYXJ0V2lkdGggKyBcInB4XCIsXG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLmNoYXJ0SGVpZ2h0ICsgXCJweFwiXG4gICAgICAgIH0sIHkuYm9keSk7XG4gICAgICAgIHZhciBnID0gdGhpcy5yZW5kZXJUby5zdHlsZS53aWR0aDtcbiAgICAgICAgdmFyIGUgPSB0aGlzLnJlbmRlclRvLnN0eWxlLmhlaWdodDtcbiAgICAgICAgZyA9IGMuZXhwb3J0aW5nLnNvdXJjZVdpZHRoIHx8IGMuY2hhcnQud2lkdGggfHwgL3B4JC8udGVzdChnKSAmJiBwYXJzZUludChnLCAxMCkgfHwgKGMuaXNHYW50dCA/IDgwMCA6IDYwMCk7XG4gICAgICAgIGUgPSBjLmV4cG9ydGluZy5zb3VyY2VIZWlnaHQgfHwgYy5jaGFydC5oZWlnaHQgfHwgL3B4JC8udGVzdChlKSAmJiBwYXJzZUludChlLCAxMCkgfHwgNDAwO1xuICAgICAgICB4KGMuY2hhcnQsIHtcbiAgICAgICAgICBhbmltYXRpb246ICExLFxuICAgICAgICAgIHJlbmRlclRvOiBkLFxuICAgICAgICAgIGZvckV4cG9ydDogITAsXG4gICAgICAgICAgcmVuZGVyZXI6IFwiU1ZHUmVuZGVyZXJcIixcbiAgICAgICAgICB3aWR0aDogZyxcbiAgICAgICAgICBoZWlnaHQ6IGVcbiAgICAgICAgfSk7XG4gICAgICAgIGMuZXhwb3J0aW5nLmVuYWJsZWQgPSAhMTtcbiAgICAgICAgZGVsZXRlIGMuZGF0YTtcbiAgICAgICAgYy5zZXJpZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGIgPSBwKGEudXNlck9wdGlvbnMsIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbjogITEsXG4gICAgICAgICAgICBlbmFibGVNb3VzZVRyYWNraW5nOiAhMSxcbiAgICAgICAgICAgIHNob3dDaGVja2JveDogITEsXG4gICAgICAgICAgICB2aXNpYmxlOiBhLnZpc2libGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBiLmlzSW50ZXJuYWwgfHwgYy5zZXJpZXMucHVzaChiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYS51c2VyT3B0aW9ucy5pbnRlcm5hbEtleSB8fCAoYS51c2VyT3B0aW9ucy5pbnRlcm5hbEtleSA9IEwoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgciA9IG5ldyBmLkNoYXJ0KGMsIHRoaXMuY2FsbGJhY2spO1xuICAgICAgICBhICYmIFtcInhBeGlzXCIsIFwieUF4aXNcIiwgXCJzZXJpZXNcIl0uZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHZhciBkID0ge307XG4gICAgICAgICAgYVtiXSAmJiAoZFtiXSA9IGFbYl0sIHIudXBkYXRlKGQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgdmFyIGIgPSBJKHIuYXhlcywgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLm9wdGlvbnMuaW50ZXJuYWxLZXkgPT09IGEudXNlck9wdGlvbnMuaW50ZXJuYWxLZXk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGQgPSBhLmdldEV4dHJlbWVzKCksXG4gICAgICAgICAgICAgIGMgPSBkLnVzZXJNaW47XG4gICAgICAgICAgZCA9IGQudXNlck1heDtcbiAgICAgICAgICBiICYmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYyAmJiBjICE9PSBiLm1pbiB8fCBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZCAmJiBkICE9PSBiLm1heCkgJiYgYi5zZXRFeHRyZW1lcyhjLCBkLCAhMCwgITEpO1xuICAgICAgICB9KTtcbiAgICAgICAgZyA9IHIuZ2V0Q2hhcnRIVE1MKCk7XG4gICAgICAgIEIodGhpcywgXCJnZXRTVkdcIiwge1xuICAgICAgICAgIGNoYXJ0Q29weTogclxuICAgICAgICB9KTtcbiAgICAgICAgZyA9IHRoaXMuc2FuaXRpemVTVkcoZywgYyk7XG4gICAgICAgIGMgPSBudWxsO1xuICAgICAgICByLmRlc3Ryb3koKTtcbiAgICAgICAgbShkKTtcbiAgICAgICAgcmV0dXJuIGc7XG4gICAgICB9LFxuICAgICAgZ2V0U1ZHRm9yRXhwb3J0OiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgYyA9IHRoaXMub3B0aW9ucy5leHBvcnRpbmc7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNWRyhwKHtcbiAgICAgICAgICBjaGFydDoge1xuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LCBjLmNoYXJ0T3B0aW9ucywgYiwge1xuICAgICAgICAgIGV4cG9ydGluZzoge1xuICAgICAgICAgICAgc291cmNlV2lkdGg6IGEgJiYgYS5zb3VyY2VXaWR0aCB8fCBjLnNvdXJjZVdpZHRoLFxuICAgICAgICAgICAgc291cmNlSGVpZ2h0OiBhICYmIGEuc291cmNlSGVpZ2h0IHx8IGMuc291cmNlSGVpZ2h0XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgICAgZ2V0RmlsZW5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLnVzZXJPcHRpb25zLnRpdGxlICYmIHRoaXMudXNlck9wdGlvbnMudGl0bGUudGV4dCxcbiAgICAgICAgICAgIGIgPSB0aGlzLm9wdGlvbnMuZXhwb3J0aW5nLmZpbGVuYW1lO1xuICAgICAgICBpZiAoYikgcmV0dXJuIGIucmVwbGFjZSgvXFwvL2csIFwiLVwiKTtcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGEgJiYgKGIgPSBhLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvPFxcLz9bXj5dKyg+fCQpL2csIFwiXCIpLnJlcGxhY2UoL1tcXHNfXSsvZywgXCItXCIpLnJlcGxhY2UoL1teYS16MC05XFwtXS9nLCBcIlwiKS5yZXBsYWNlKC9eW1xcLV0rL2csIFwiXCIpLnJlcGxhY2UoL1tcXC1dKy9nLCBcIi1cIikuc3Vic3RyKDAsIDI0KS5yZXBsYWNlKC9bXFwtXSskL2csIFwiXCIpKTtcbiAgICAgICAgaWYgKCFiIHx8IDUgPiBiLmxlbmd0aCkgYiA9IFwiY2hhcnRcIjtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9LFxuICAgICAgZXhwb3J0Q2hhcnQ6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGIgPSB0aGlzLmdldFNWR0ZvckV4cG9ydChhLCBiKTtcbiAgICAgICAgYSA9IHAodGhpcy5vcHRpb25zLmV4cG9ydGluZywgYSk7XG4gICAgICAgIGYucG9zdChhLnVybCwge1xuICAgICAgICAgIGZpbGVuYW1lOiBhLmZpbGVuYW1lID8gYS5maWxlbmFtZS5yZXBsYWNlKC9cXC8vZywgXCItXCIpIDogdGhpcy5nZXRGaWxlbmFtZSgpLFxuICAgICAgICAgIHR5cGU6IGEudHlwZSxcbiAgICAgICAgICB3aWR0aDogYS53aWR0aCB8fCAwLFxuICAgICAgICAgIHNjYWxlOiBhLnNjYWxlLFxuICAgICAgICAgIHN2ZzogYlxuICAgICAgICB9LCBhLmZvcm1BdHRyaWJ1dGVzKTtcbiAgICAgIH0sXG4gICAgICBtb3ZlQ29udGFpbmVyczogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgKHRoaXMuZml4ZWREaXYgPyBbdGhpcy5maXhlZERpdiwgdGhpcy5zY3JvbGxpbmdDb250YWluZXJdIDogW3RoaXMuY29udGFpbmVyXSkuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGEuYXBwZW5kQ2hpbGQoYik7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGJlZm9yZVByaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0geS5ib2R5LFxuICAgICAgICAgICAgYiA9IHRoaXMub3B0aW9ucy5leHBvcnRpbmcucHJpbnRNYXhXaWR0aCxcbiAgICAgICAgICAgIGMgPSB7XG4gICAgICAgICAgY2hpbGROb2RlczogYS5jaGlsZE5vZGVzLFxuICAgICAgICAgIG9yaWdEaXNwbGF5OiBbXSxcbiAgICAgICAgICByZXNldFBhcmFtczogdm9pZCAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNQcmludGluZyA9ICEwO1xuICAgICAgICB0aGlzLnBvaW50ZXIucmVzZXQobnVsbCwgMCk7XG4gICAgICAgIEIodGhpcywgXCJiZWZvcmVQcmludFwiKTtcbiAgICAgICAgYiAmJiB0aGlzLmNoYXJ0V2lkdGggPiBiICYmIChjLnJlc2V0UGFyYW1zID0gW3RoaXMub3B0aW9ucy5jaGFydC53aWR0aCwgdm9pZCAwLCAhMV0sIHRoaXMuc2V0U2l6ZShiLCB2b2lkIDAsICExKSk7XG4gICAgICAgIFtdLmZvckVhY2guY2FsbChjLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgMSA9PT0gYS5ub2RlVHlwZSAmJiAoYy5vcmlnRGlzcGxheVtiXSA9IGEuc3R5bGUuZGlzcGxheSwgYS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb3ZlQ29udGFpbmVycyhhKTtcbiAgICAgICAgdGhpcy5wcmludFJldmVyc2VJbmZvID0gYztcbiAgICAgIH0sXG4gICAgICBhZnRlclByaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByaW50UmV2ZXJzZUluZm8pIHtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMucHJpbnRSZXZlcnNlSW5mby5jaGlsZE5vZGVzLFxuICAgICAgICAgICAgICBiID0gdGhpcy5wcmludFJldmVyc2VJbmZvLm9yaWdEaXNwbGF5LFxuICAgICAgICAgICAgICBjID0gdGhpcy5wcmludFJldmVyc2VJbmZvLnJlc2V0UGFyYW1zO1xuICAgICAgICAgIHRoaXMubW92ZUNvbnRhaW5lcnModGhpcy5yZW5kZXJUbyk7XG4gICAgICAgICAgW10uZm9yRWFjaC5jYWxsKGEsIGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgICAgICAxID09PSBhLm5vZGVUeXBlICYmIChhLnN0eWxlLmRpc3BsYXkgPSBiW2NdIHx8IFwiXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuaXNQcmludGluZyA9ICExO1xuICAgICAgICAgIGMgJiYgdGhpcy5zZXRTaXplLmFwcGx5KHRoaXMsIGMpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnByaW50UmV2ZXJzZUluZm87XG4gICAgICAgICAgZGVsZXRlIGYucHJpbnRpbmdDaGFydDtcbiAgICAgICAgICBCKHRoaXMsIFwiYWZ0ZXJQcmludFwiKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgYS5pc1ByaW50aW5nIHx8IChmLnByaW50aW5nQ2hhcnQgPSBhLCBmLmlzU2FmYXJpIHx8IGEuYmVmb3JlUHJpbnQoKSwgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgei5mb2N1cygpO1xuICAgICAgICAgIHoucHJpbnQoKTtcbiAgICAgICAgICBmLmlzU2FmYXJpIHx8IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYS5hZnRlclByaW50KCk7XG4gICAgICAgICAgfSwgMUUzKTtcbiAgICAgICAgfSwgMSkpO1xuICAgICAgfSxcbiAgICAgIGNvbnRleHRNZW51OiBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZiwgcikge1xuICAgICAgICB2YXIgayA9IHRoaXMsXG4gICAgICAgICAgICBEID0gay5vcHRpb25zLm5hdmlnYXRpb24sXG4gICAgICAgICAgICBwID0gay5jaGFydFdpZHRoLFxuICAgICAgICAgICAgQSA9IGsuY2hhcnRIZWlnaHQsXG4gICAgICAgICAgICB0ID0gXCJjYWNoZS1cIiArIGEsXG4gICAgICAgICAgICBsID0ga1t0XSxcbiAgICAgICAgICAgIHYgPSBNYXRoLm1heChlLCBmKTtcblxuICAgICAgICBpZiAoIWwpIHtcbiAgICAgICAgICBrLmV4cG9ydENvbnRleHRNZW51ID0ga1t0XSA9IGwgPSBoKFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogYVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB6SW5kZXg6IDFFMyxcbiAgICAgICAgICAgIHBhZGRpbmc6IHYgKyBcInB4XCIsXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcImF1dG9cIlxuICAgICAgICAgIH0sIGsuZml4ZWREaXYgfHwgay5jb250YWluZXIpO1xuICAgICAgICAgIHZhciBtID0gaChcInVsXCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJoaWdoY2hhcnRzLW1lbnVcIlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGxpc3RTdHlsZTogXCJub25lXCIsXG4gICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICBwYWRkaW5nOiAwXG4gICAgICAgICAgfSwgbCk7XG4gICAgICAgICAgay5zdHlsZWRNb2RlIHx8IHUobSwgeCh7XG4gICAgICAgICAgICBNb3pCb3hTaGFkb3c6IFwiM3B4IDNweCAxMHB4ICM4ODhcIixcbiAgICAgICAgICAgIFdlYmtpdEJveFNoYWRvdzogXCIzcHggM3B4IDEwcHggIzg4OFwiLFxuICAgICAgICAgICAgYm94U2hhZG93OiBcIjNweCAzcHggMTBweCAjODg4XCJcbiAgICAgICAgICB9LCBELm1lbnVTdHlsZSkpO1xuXG4gICAgICAgICAgbC5oaWRlTWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHUobCwge1xuICAgICAgICAgICAgICBkaXNwbGF5OiBcIm5vbmVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByICYmIHIuc2V0U3RhdGUoMCk7XG4gICAgICAgICAgICBrLm9wZW5NZW51ID0gITE7XG4gICAgICAgICAgICB1KGsucmVuZGVyVG8sIHtcbiAgICAgICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZy5jbGVhclRpbWVvdXQobC5oaWRlVGltZXIpO1xuICAgICAgICAgICAgQihrLCBcImV4cG9ydE1lbnVIaWRkZW5cIik7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGsuZXhwb3J0RXZlbnRzLnB1c2gobihsLCBcIm1vdXNlbGVhdmVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbC5oaWRlVGltZXIgPSB6LnNldFRpbWVvdXQobC5oaWRlTWVudSwgNTAwKTtcbiAgICAgICAgICB9KSwgbihsLCBcIm1vdXNlZW50ZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZy5jbGVhclRpbWVvdXQobC5oaWRlVGltZXIpO1xuICAgICAgICAgIH0pLCBuKHksIFwibW91c2V1cFwiLCBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgay5wb2ludGVyLmluQ2xhc3MoYi50YXJnZXQsIGEpIHx8IGwuaGlkZU1lbnUoKTtcbiAgICAgICAgICB9KSwgbihsLCBcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGsub3Blbk1lbnUgJiYgbC5oaWRlTWVudSgpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBiLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBhICYmIChhID0gay5vcHRpb25zLmV4cG9ydGluZy5tZW51SXRlbURlZmluaXRpb25zW2FdKTtcblxuICAgICAgICAgICAgaWYgKEooYSwgITApKSB7XG4gICAgICAgICAgICAgIGlmIChhLnNlcGFyYXRvcikgdmFyIGIgPSBoKFwiaHJcIiwgbnVsbCwgbnVsbCwgbSk7ZWxzZSBiID0gaChcImxpXCIsIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiaGlnaGNoYXJ0cy1tZW51LWl0ZW1cIixcbiAgICAgICAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgICAgICAgYiAmJiBiLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgbC5oaWRlTWVudSgpO1xuICAgICAgICAgICAgICAgICAgYS5vbmNsaWNrICYmIGEub25jbGljay5hcHBseShrLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5uZXJIVE1MOiBhLnRleHQgfHwgay5vcHRpb25zLmxhbmdbYS50ZXh0S2V5XVxuICAgICAgICAgICAgICB9LCBudWxsLCBtKSwgay5zdHlsZWRNb2RlIHx8IChiLm9ubW91c2VvdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHUodGhpcywgRC5tZW51SXRlbUhvdmVyU3R5bGUpO1xuICAgICAgICAgICAgICB9LCBiLm9ubW91c2VvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdSh0aGlzLCBELm1lbnVJdGVtU3R5bGUpO1xuICAgICAgICAgICAgICB9LCB1KGIsIHgoe1xuICAgICAgICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICAgICAgICAgICAgfSwgRC5tZW51SXRlbVN0eWxlKSkpO1xuICAgICAgICAgICAgICBrLmV4cG9ydERpdkVsZW1lbnRzLnB1c2goYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgay5leHBvcnREaXZFbGVtZW50cy5wdXNoKG0sIGwpO1xuICAgICAgICAgIGsuZXhwb3J0TWVudVdpZHRoID0gbC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICBrLmV4cG9ydE1lbnVIZWlnaHQgPSBsLm9mZnNldEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGIgPSB7XG4gICAgICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgICAgIH07XG4gICAgICAgIGMgKyBrLmV4cG9ydE1lbnVXaWR0aCA+IHAgPyBiLnJpZ2h0ID0gcCAtIGMgLSBlIC0gdiArIFwicHhcIiA6IGIubGVmdCA9IGMgLSB2ICsgXCJweFwiO1xuICAgICAgICBkICsgZiArIGsuZXhwb3J0TWVudUhlaWdodCA+IEEgJiYgXCJ0b3BcIiAhPT0gci5hbGlnbk9wdGlvbnMudmVydGljYWxBbGlnbiA/IGIuYm90dG9tID0gQSAtIGQgLSB2ICsgXCJweFwiIDogYi50b3AgPSBkICsgZiAtIHYgKyBcInB4XCI7XG4gICAgICAgIHUobCwgYik7XG4gICAgICAgIHUoay5yZW5kZXJUbywge1xuICAgICAgICAgIG92ZXJmbG93OiBcIlwiXG4gICAgICAgIH0pO1xuICAgICAgICBrLm9wZW5NZW51ID0gITA7XG4gICAgICAgIEIoaywgXCJleHBvcnRNZW51U2hvd25cIik7XG4gICAgICB9LFxuICAgICAgYWRkQnV0dG9uOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgICAgICBjID0gYi5yZW5kZXJlcixcbiAgICAgICAgICAgIGQgPSBwKGIub3B0aW9ucy5uYXZpZ2F0aW9uLmJ1dHRvbk9wdGlvbnMsIGEpLFxuICAgICAgICAgICAgZyA9IGQub25jbGljayxcbiAgICAgICAgICAgIGUgPSBkLm1lbnVJdGVtcyxcbiAgICAgICAgICAgIGYgPSBkLnN5bWJvbFNpemUgfHwgMTI7XG4gICAgICAgIGIuYnRuQ291bnQgfHwgKGIuYnRuQ291bnQgPSAwKTtcbiAgICAgICAgYi5leHBvcnREaXZFbGVtZW50cyB8fCAoYi5leHBvcnREaXZFbGVtZW50cyA9IFtdLCBiLmV4cG9ydFNWR0VsZW1lbnRzID0gW10pO1xuXG4gICAgICAgIGlmICghMSAhPT0gZC5lbmFibGVkKSB7XG4gICAgICAgICAgdmFyIGsgPSBkLnRoZW1lLFxuICAgICAgICAgICAgICBoID0gay5zdGF0ZXMsXG4gICAgICAgICAgICAgIG0gPSBoICYmIGguaG92ZXI7XG4gICAgICAgICAgaCA9IGggJiYgaC5zZWxlY3Q7XG4gICAgICAgICAgdmFyIEE7XG4gICAgICAgICAgYi5zdHlsZWRNb2RlIHx8IChrLmZpbGwgPSBxKGsuZmlsbCwgXCIjZmZmZmZmXCIpLCBrLnN0cm9rZSA9IHEoay5zdHJva2UsIFwibm9uZVwiKSk7XG4gICAgICAgICAgZGVsZXRlIGsuc3RhdGVzO1xuICAgICAgICAgIGcgPyBBID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGEgJiYgYS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGcuY2FsbChiLCBhKTtcbiAgICAgICAgICB9IDogZSAmJiAoQSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBhICYmIGEuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBiLmNvbnRleHRNZW51KHQubWVudUNsYXNzTmFtZSwgZSwgdC50cmFuc2xhdGVYLCB0LnRyYW5zbGF0ZVksIHQud2lkdGgsIHQuaGVpZ2h0LCB0KTtcbiAgICAgICAgICAgIHQuc2V0U3RhdGUoMik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZC50ZXh0ICYmIGQuc3ltYm9sID8gay5wYWRkaW5nTGVmdCA9IHEoay5wYWRkaW5nTGVmdCwgMjUpIDogZC50ZXh0IHx8IHgoaywge1xuICAgICAgICAgICAgd2lkdGg6IGQud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGQuaGVpZ2h0LFxuICAgICAgICAgICAgcGFkZGluZzogMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGIuc3R5bGVkTW9kZSB8fCAoa1tcInN0cm9rZS1saW5lY2FwXCJdID0gXCJyb3VuZFwiLCBrLmZpbGwgPSBxKGsuZmlsbCwgXCIjZmZmZmZmXCIpLCBrLnN0cm9rZSA9IHEoay5zdHJva2UsIFwibm9uZVwiKSk7XG4gICAgICAgICAgdmFyIHQgPSBjLmJ1dHRvbihkLnRleHQsIDAsIDAsIEEsIGssIG0sIGgpLmFkZENsYXNzKGEuY2xhc3NOYW1lKS5hdHRyKHtcbiAgICAgICAgICAgIHRpdGxlOiBxKGIub3B0aW9ucy5sYW5nW2QuX3RpdGxlS2V5IHx8IGQudGl0bGVLZXldLCBcIlwiKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHQubWVudUNsYXNzTmFtZSA9IGEubWVudUNsYXNzTmFtZSB8fCBcImhpZ2hjaGFydHMtbWVudS1cIiArIGIuYnRuQ291bnQrKztcblxuICAgICAgICAgIGlmIChkLnN5bWJvbCkge1xuICAgICAgICAgICAgdmFyIGwgPSBjLnN5bWJvbChkLnN5bWJvbCwgZC5zeW1ib2xYIC0gZiAvIDIsIGQuc3ltYm9sWSAtIGYgLyAyLCBmLCBmLCB7XG4gICAgICAgICAgICAgIHdpZHRoOiBmLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGZcbiAgICAgICAgICAgIH0pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1idXR0b24tc3ltYm9sXCIpLmF0dHIoe1xuICAgICAgICAgICAgICB6SW5kZXg6IDFcbiAgICAgICAgICAgIH0pLmFkZCh0KTtcbiAgICAgICAgICAgIGIuc3R5bGVkTW9kZSB8fCBsLmF0dHIoe1xuICAgICAgICAgICAgICBzdHJva2U6IGQuc3ltYm9sU3Ryb2tlLFxuICAgICAgICAgICAgICBmaWxsOiBkLnN5bWJvbEZpbGwsXG4gICAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IGQuc3ltYm9sU3Ryb2tlV2lkdGggfHwgMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdC5hZGQoYi5leHBvcnRpbmdHcm91cCkuYWxpZ24oeChkLCB7XG4gICAgICAgICAgICB3aWR0aDogdC53aWR0aCxcbiAgICAgICAgICAgIHg6IHEoZC54LCBiLmJ1dHRvbk9mZnNldClcbiAgICAgICAgICB9KSwgITAsIFwic3BhY2luZ0JveFwiKTtcbiAgICAgICAgICBiLmJ1dHRvbk9mZnNldCArPSAodC53aWR0aCArIGQuYnV0dG9uU3BhY2luZykgKiAoXCJyaWdodFwiID09PSBkLmFsaWduID8gLTEgOiAxKTtcbiAgICAgICAgICBiLmV4cG9ydFNWR0VsZW1lbnRzLnB1c2godCwgbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXN0cm95RXhwb3J0OiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYiA9IGEgPyBhLnRhcmdldCA6IHRoaXM7XG4gICAgICAgIGEgPSBiLmV4cG9ydFNWR0VsZW1lbnRzO1xuICAgICAgICB2YXIgYyA9IGIuZXhwb3J0RGl2RWxlbWVudHMsXG4gICAgICAgICAgICBkID0gYi5leHBvcnRFdmVudHMsXG4gICAgICAgICAgICBmO1xuICAgICAgICBhICYmIChhLmZvckVhY2goZnVuY3Rpb24gKGEsIGQpIHtcbiAgICAgICAgICBhICYmIChhLm9uY2xpY2sgPSBhLm9udG91Y2hzdGFydCA9IG51bGwsIGYgPSBcImNhY2hlLVwiICsgYS5tZW51Q2xhc3NOYW1lLCBiW2ZdICYmIGRlbGV0ZSBiW2ZdLCBiLmV4cG9ydFNWR0VsZW1lbnRzW2RdID0gYS5kZXN0cm95KCkpO1xuICAgICAgICB9KSwgYS5sZW5ndGggPSAwKTtcbiAgICAgICAgYi5leHBvcnRpbmdHcm91cCAmJiAoYi5leHBvcnRpbmdHcm91cC5kZXN0cm95KCksIGRlbGV0ZSBiLmV4cG9ydGluZ0dyb3VwKTtcbiAgICAgICAgYyAmJiAoYy5mb3JFYWNoKGZ1bmN0aW9uIChhLCBkKSB7XG4gICAgICAgICAgZy5jbGVhclRpbWVvdXQoYS5oaWRlVGltZXIpO1xuICAgICAgICAgIEsoYSwgXCJtb3VzZWxlYXZlXCIpO1xuICAgICAgICAgIGIuZXhwb3J0RGl2RWxlbWVudHNbZF0gPSBhLm9ubW91c2VvdXQgPSBhLm9ubW91c2VvdmVyID0gYS5vbnRvdWNoc3RhcnQgPSBhLm9uY2xpY2sgPSBudWxsO1xuICAgICAgICAgIG0oYSk7XG4gICAgICAgIH0pLCBjLmxlbmd0aCA9IDApO1xuICAgICAgICBkICYmIChkLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhKCk7XG4gICAgICAgIH0pLCBkLmxlbmd0aCA9IDApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIEYucHJvdG90eXBlLmlubGluZVRvQXR0cmlidXRlcyA9IFwiZmlsbCBzdHJva2Ugc3Ryb2tlTGluZWNhcCBzdHJva2VMaW5lam9pbiBzdHJva2VXaWR0aCB0ZXh0QW5jaG9yIHggeVwiLnNwbGl0KFwiIFwiKTtcbiAgICBGLnByb3RvdHlwZS5pbmxpbmVCbGFja2xpc3QgPSBbLy0vLCAvXihjbGlwUGF0aHxjc3NUZXh0fGR8aGVpZ2h0fHdpZHRoKSQvLCAvXmZvbnQkLywgL1tsTF1vZ2ljYWwoV2lkdGh8SGVpZ2h0KSQvLCAvcGVyc3BlY3RpdmUvLCAvVGFwSGlnaGxpZ2h0Q29sb3IvLCAvXnRyYW5zaXRpb24vLCAvXmxlbmd0aCQvXTtcbiAgICBGLnByb3RvdHlwZS51bnN0eWxlZEVsZW1lbnRzID0gW1wiY2xpcFBhdGhcIiwgXCJkZWZzXCIsIFwiZGVzY1wiXTtcblxuICAgIEMucHJvdG90eXBlLmlubGluZVN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIGEoYSkge1xuICAgICAgICByZXR1cm4gYS5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIFwiLVwiICsgYi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYihjKSB7XG4gICAgICAgIGZ1bmN0aW9uIGsoYiwgZSkge1xuICAgICAgICAgIHYgPSB1ID0gITE7XG5cbiAgICAgICAgICBpZiAoZykge1xuICAgICAgICAgICAgZm9yIChxID0gZy5sZW5ndGg7IHEtLSAmJiAhdTspIHUgPSBnW3FdLnRlc3QoZSk7XG5cbiAgICAgICAgICAgIHYgPSAhdTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBcInRyYW5zZm9ybVwiID09PSBlICYmIFwibm9uZVwiID09PSBiICYmICh2ID0gITApO1xuXG4gICAgICAgICAgZm9yIChxID0gZi5sZW5ndGg7IHEtLSAmJiAhdjspIHYgPSBmW3FdLnRlc3QoZSkgfHwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYjtcblxuICAgICAgICAgIHYgfHwgeFtlXSA9PT0gYiAmJiBcInN2Z1wiICE9PSBjLm5vZGVOYW1lIHx8IGhbYy5ub2RlTmFtZV1bZV0gPT09IGIgfHwgKC0xICE9PSBkLmluZGV4T2YoZSkgPyBjLnNldEF0dHJpYnV0ZShhKGUpLCBiKSA6IGwgKz0gYShlKSArIFwiOlwiICsgYiArIFwiO1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsID0gXCJcIixcbiAgICAgICAgICAgIHYsXG4gICAgICAgICAgICB1LFxuICAgICAgICAgICAgcTtcblxuICAgICAgICBpZiAoMSA9PT0gYy5ub2RlVHlwZSAmJiAtMSA9PT0gZS5pbmRleE9mKGMubm9kZU5hbWUpKSB7XG4gICAgICAgICAgdmFyIHIgPSB6LmdldENvbXB1dGVkU3R5bGUoYywgbnVsbCk7XG4gICAgICAgICAgdmFyIHggPSBcInN2Z1wiID09PSBjLm5vZGVOYW1lID8ge30gOiB6LmdldENvbXB1dGVkU3R5bGUoYy5wYXJlbnROb2RlLCBudWxsKTtcblxuICAgICAgICAgIGlmICghaFtjLm5vZGVOYW1lXSkge1xuICAgICAgICAgICAgbSA9IG4uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzdmdcIilbMF07XG4gICAgICAgICAgICB2YXIgdyA9IG4uY3JlYXRlRWxlbWVudE5TKGMubmFtZXNwYWNlVVJJLCBjLm5vZGVOYW1lKTtcbiAgICAgICAgICAgIG0uYXBwZW5kQ2hpbGQodyk7XG4gICAgICAgICAgICBoW2Mubm9kZU5hbWVdID0gcCh6LmdldENvbXB1dGVkU3R5bGUodywgbnVsbCkpO1xuICAgICAgICAgICAgXCJ0ZXh0XCIgPT09IGMubm9kZU5hbWUgJiYgZGVsZXRlIGgudGV4dC5maWxsO1xuICAgICAgICAgICAgbS5yZW1vdmVDaGlsZCh3KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoTyB8fCBOKSBmb3IgKHZhciB5IGluIHIpIGsoclt5XSwgeSk7ZWxzZSBFKHIsIGspO1xuICAgICAgICAgIGwgJiYgKHIgPSBjLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpLCBjLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIChyID8gciArIFwiO1wiIDogXCJcIikgKyBsKSk7XG4gICAgICAgICAgXCJzdmdcIiA9PT0gYy5ub2RlTmFtZSAmJiBjLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBcIjFweFwiKTtcbiAgICAgICAgICBcInRleHRcIiAhPT0gYy5ub2RlTmFtZSAmJiBbXS5mb3JFYWNoLmNhbGwoYy5jaGlsZHJlbiB8fCBjLmNoaWxkTm9kZXMsIGIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjID0gdGhpcy5yZW5kZXJlcixcbiAgICAgICAgICBkID0gYy5pbmxpbmVUb0F0dHJpYnV0ZXMsXG4gICAgICAgICAgZiA9IGMuaW5saW5lQmxhY2tsaXN0LFxuICAgICAgICAgIGcgPSBjLmlubGluZVdoaXRlbGlzdCxcbiAgICAgICAgICBlID0gYy51bnN0eWxlZEVsZW1lbnRzLFxuICAgICAgICAgIGggPSB7fSxcbiAgICAgICAgICBtO1xuICAgICAgYyA9IHkuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgIHUoYywge1xuICAgICAgICB3aWR0aDogXCIxcHhcIixcbiAgICAgICAgaGVpZ2h0OiBcIjFweFwiLFxuICAgICAgICB2aXNpYmlsaXR5OiBcImhpZGRlblwiXG4gICAgICB9KTtcbiAgICAgIHkuYm9keS5hcHBlbmRDaGlsZChjKTtcbiAgICAgIHZhciBuID0gYy5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICAgICAgbi5vcGVuKCk7XG4gICAgICBuLndyaXRlKCc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48L3N2Zz4nKTtcbiAgICAgIG4uY2xvc2UoKTtcbiAgICAgIGIodGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcInN2Z1wiKSk7XG4gICAgICBtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobSk7XG4gICAgfTtcblxuICAgIEgubWVudSA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gW1wiTVwiLCBhLCBiICsgMi41LCBcIkxcIiwgYSArIGMsIGIgKyAyLjUsIFwiTVwiLCBhLCBiICsgZCAvIDIgKyAuNSwgXCJMXCIsIGEgKyBjLCBiICsgZCAvIDIgKyAuNSwgXCJNXCIsIGEsIGIgKyBkIC0gMS41LCBcIkxcIiwgYSArIGMsIGIgKyBkIC0gMS41XTtcbiAgICB9O1xuXG4gICAgSC5tZW51YmFsbCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgICBhID0gW107XG4gICAgICBkID0gZCAvIDMgLSAyO1xuICAgICAgcmV0dXJuIGEgPSBhLmNvbmNhdCh0aGlzLmNpcmNsZShjIC0gZCwgYiwgZCwgZCksIHRoaXMuY2lyY2xlKGMgLSBkLCBiICsgZCArIDQsIGQsIGQpLCB0aGlzLmNpcmNsZShjIC0gZCwgYiArIDIgKiAoZCArIDQpLCBkLCBkKSk7XG4gICAgfTtcblxuICAgIEMucHJvdG90eXBlLnJlbmRlckV4cG9ydGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICBiID0gYS5vcHRpb25zLmV4cG9ydGluZyxcbiAgICAgICAgICBjID0gYi5idXR0b25zLFxuICAgICAgICAgIGQgPSBhLmlzRGlydHlFeHBvcnRpbmcgfHwgIWEuZXhwb3J0U1ZHRWxlbWVudHM7XG4gICAgICBhLmJ1dHRvbk9mZnNldCA9IDA7XG4gICAgICBhLmlzRGlydHlFeHBvcnRpbmcgJiYgYS5kZXN0cm95RXhwb3J0KCk7XG4gICAgICBkICYmICExICE9PSBiLmVuYWJsZWQgJiYgKGEuZXhwb3J0RXZlbnRzID0gW10sIGEuZXhwb3J0aW5nR3JvdXAgPSBhLmV4cG9ydGluZ0dyb3VwIHx8IGEucmVuZGVyZXIuZyhcImV4cG9ydGluZy1ncm91cFwiKS5hdHRyKHtcbiAgICAgICAgekluZGV4OiAzXG4gICAgICB9KS5hZGQoKSwgRShjLCBmdW5jdGlvbiAoYikge1xuICAgICAgICBhLmFkZEJ1dHRvbihiKTtcbiAgICAgIH0pLCBhLmlzRGlydHlFeHBvcnRpbmcgPSAhMSk7XG4gICAgICBuKGEsIFwiZGVzdHJveVwiLCBhLmRlc3Ryb3lFeHBvcnQpO1xuICAgIH07XG5cbiAgICBuKEMsIFwiaW5pdFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICBhLmV4cG9ydGluZyA9IHtcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoYiwgYykge1xuICAgICAgICAgIGEuaXNEaXJ0eUV4cG9ydGluZyA9ICEwO1xuICAgICAgICAgIHAoITAsIGEub3B0aW9ucy5leHBvcnRpbmcsIGIpO1xuICAgICAgICAgIHEoYywgITApICYmIGEucmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBlLmFkZFVwZGF0ZShmdW5jdGlvbiAoYiwgYykge1xuICAgICAgICBhLmlzRGlydHlFeHBvcnRpbmcgPSAhMDtcbiAgICAgICAgcCghMCwgYS5vcHRpb25zLm5hdmlnYXRpb24sIGIpO1xuICAgICAgICBxKGMsICEwKSAmJiBhLnJlZHJhdygpO1xuICAgICAgfSwgYSk7XG4gICAgfSk7XG4gICAgQy5wcm90b3R5cGUuY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKGEpIHtcbiAgICAgIGEucmVuZGVyRXhwb3J0aW5nKCk7XG4gICAgICBuKGEsIFwicmVkcmF3XCIsIGEucmVuZGVyRXhwb3J0aW5nKTtcbiAgICB9KTtcbiAgfSk7XG4gIG0oZSwgXCJtYXN0ZXJzL21vZHVsZXMvZXhwb3J0aW5nLnNyYy5qc1wiLCBbXSwgZnVuY3Rpb24gKCkge30pO1xufSk7IiwidmFyIGc7IC8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5cbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufSgpO1xuXG50cnkge1xuICAvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcbiAgZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcbiAgLy8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59IC8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBnOyIsImltcG9ydCBcIi4vc3R5bGVzL2luZGV4LnNjc3NcIjtcclxuaW1wb3J0IHsgY2FyZFNlYXJjaGVyIH0gZnJvbSAnLi9zY3JpcHRzL2NhcmRfc2VhcmNoZXInO1xyXG5pbXBvcnQgY2FyZEdlbmVyYXRvciBmcm9tICcuL3NjcmlwdHMvY2FyZF9nZW5lcmF0b3InO1xyXG5cclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IHtcclxuICBjb25zdCBib2FyZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgY29uc3Qgc2VhcmNoQmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIik7XHJcbiAgY29uc3QgaW5wdXRGaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcclxuICBjb25zdCBzdWJtaXRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xyXG4gIGNvbnN0IHNlYXJjaEljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcclxuICBjb25zdCB0aXRsZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImgxXCIpO1xyXG4gIGNvbnN0IHRpdGxlSW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcclxuICBjb25zdCBuYXZDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBjb25zdCBnaXRMaW5rSW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlcIik7XHJcbiAgY29uc3QgbGlua2VkaW5MaW5rSW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlcIik7XHJcbiAgY29uc3QgZ2l0TGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xyXG4gIGNvbnN0IGxpbmtlZGluTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xyXG5cclxuICBnaXRMaW5rLmFwcGVuZChnaXRMaW5rSW1nKTtcclxuICBnaXRMaW5rLmNsYXNzTGlzdC5hZGQoJ25hdi1saW5rJyk7XHJcbiAgZ2l0TGluay5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIFwiaHR0cHM6Ly9naXRodWIuY29tL05vcnRvbi1EZXNpZ24vY2FyZEF1Z3VyeVwiKTtcclxuICBnaXRMaW5rLnNldEF0dHJpYnV0ZShcInRhcmdldFwiLCBcIl9ibGFua1wiKTtcclxuXHJcbiAgbGlua2VkaW5MaW5rLmFwcGVuZChsaW5rZWRpbkxpbmtJbWcpO1xyXG4gIGxpbmtlZGluTGluay5jbGFzc0xpc3QuYWRkKCduYXYtbGluaycpO1xyXG4gIGxpbmtlZGluTGluay5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIFwiaHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL21pY2hhZWwtbm9ydG9uLTViNTU1OTE5OS9cIik7XHJcbiAgbGlua2VkaW5MaW5rLnNldEF0dHJpYnV0ZShcInRhcmdldFwiLCBcIl9ibGFua1wiKTtcclxuXHJcbiAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFwiY2VudGVyXCIpO1xyXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kKGJvYXJkKTtcclxuXHJcbiAgYm9hcmQuY2xhc3NMaXN0LmFkZChcImJvYXJkXCIsIFwiY2VudGVyXCIpO1xyXG4gIGJvYXJkLnNldEF0dHJpYnV0ZSgnaWQnLCBcIm1haW4tYm9hcmRcIilcclxuICBib2FyZC5hcHBlbmQodGl0bGVDb250YWluZXIpXHJcbiAgYm9hcmQuYXBwZW5kKHNlYXJjaEJhcik7XHJcbiAgYm9hcmQuYXBwZW5kKG5hdkNvbnRhaW5lcik7XHJcblxyXG4gIHRpdGxlQ29udGFpbmVyLmFwcGVuZCh0aXRsZUltZyk7XHJcbiAgdGl0bGVDb250YWluZXIuYXBwZW5kKHRpdGxlKTtcclxuICB0aXRsZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGl0bGUtY29udGFpbmVyXCIpXHJcblxyXG4gIG5hdkNvbnRhaW5lci5hcHBlbmQoZ2l0TGluayk7XHJcbiAgbmF2Q29udGFpbmVyLmFwcGVuZChsaW5rZWRpbkxpbmspO1xyXG4gIG5hdkNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCduYXYnKTtcclxuXHJcbiAgdGl0bGVJbWcuc2V0QXR0cmlidXRlKFwic3JjXCIsIFwiLi9zcmMvaW1hZ2VzL2ZpbmFsLW93bDIucG5nXCIpXHJcblxyXG4gIHRpdGxlLmlubmVySFRNTCA9IFwiQ2FyZCBBdWd1cnlcIjtcclxuXHJcbiAgc2VhcmNoSWNvbi5jbGFzc0xpc3QuYWRkKFwiZmFcIik7XHJcbiAgc2VhcmNoSWNvbi5jbGFzc0xpc3QuYWRkKFwiZmEtc2VhcmNoXCIpO1xyXG5cclxuICBsaW5rZWRpbkxpbmtJbWcuY2xhc3NMaXN0LmFkZCgnZmEnKTtcclxuICBsaW5rZWRpbkxpbmtJbWcuY2xhc3NMaXN0LmFkZCgnZmEtbGlua2VkaW4nKTtcclxuXHJcbiAgZ2l0TGlua0ltZy5jbGFzc0xpc3QuYWRkKCdmYScpO1xyXG4gIGdpdExpbmtJbWcuY2xhc3NMaXN0LmFkZCgnZmEtZ2l0aHViJyk7XHJcblxyXG4gIHN1Ym1pdEJ1dHRvbi5hcHBlbmQoc2VhcmNoSWNvbik7XHJcbiAgc3VibWl0QnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3NlYXJjaC1idXR0b24nKTtcclxuXHJcbiAgaW5wdXRGaWVsZC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNlYXJjaGJhclwiKTtcclxuICBpbnB1dEZpZWxkLnNldEF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIsIFwiU2VhcmNoIGZvciBhIGNhcmQuLi5cIik7XHJcbiAgaW5wdXRGaWVsZC5jbGFzc0xpc3QuYWRkKFwic2VhcmNoYmFyXCIpO1xyXG5cclxuICBzZWFyY2hCYXIuY2xhc3NMaXN0LmFkZChcInNlYXJjaGJhci1jb250YWluZXJcIik7XHJcbiAgc2VhcmNoQmFyLmFwcGVuZChpbnB1dEZpZWxkKTtcclxuICBzZWFyY2hCYXIuYXBwZW5kKHN1Ym1pdEJ1dHRvbik7XHJcblxyXG5cclxuXHJcbiAgc3VibWl0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICBcclxuICAgIGNhcmRTZWFyY2hlcigpXHJcbiAgICAgIC50aGVuKGNhcmQgPT4gXHJcbiAgICAgICAge2JvYXJkLnJlbW92ZUNoaWxkKG5hdkNvbnRhaW5lcilcclxuICAgICAgICBjYXJkR2VuZXJhdG9yKGNhcmQpXHJcbiAgICAgIH0pXHJcbiAgICAgIC50aGVuKCgpID0+IGJvYXJkLmFwcGVuZChuYXZDb250YWluZXIpKVxyXG4gIH0pXHJcbiAgLy8gcGFzcyB0aGUgcmV0dXJuIHZhbHVlIHRvIGEgZnVuY3Rpb24gdGhhdCBhbWVuZHMgdGhlIGFsbCBjb21wb25lbnRzXHJcbn0pOyIsImltcG9ydCB7IHNldEZldGNoZXIgfSBmcm9tICcuL3NldF9mZXRjaGVyJ1xyXG5pbXBvcnQgeyB0eXBlVG90YWxzIH0gZnJvbSAnLi9zZXRfc3RhdHNfdXRpbCc7XHJcbmltcG9ydCAnYmFiZWwtcG9seWZpbGwnO1xyXG5jb25zdCBIaWdoY2hhcnRzID0gcmVxdWlyZSgnaGlnaGNoYXJ0cycpOyBcclxucmVxdWlyZSgnaGlnaGNoYXJ0cy9tb2R1bGVzL2V4cG9ydGluZycpKEhpZ2hjaGFydHMpO1xyXG4vLyBDcmVhdGUgdGhlIGNoYXJ0XHJcbi8vIEhpZ2hjaGFydHMuY2hhcnQoJ2NvbnRhaW5lcicsIHsgLypIaWdoY2hhcnRzIG9wdGlvbnMqLyB9KTtcclxuXHJcbmNvbnN0IGNhcmRHZW5lcmF0b3IgPSBhc3luYyAoY2FyZEluZm8pID0+IHtcclxuICBjb25zdCBib2FyZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWFpbi1ib2FyZFwiKTtcclxuICBjb25zdCBwcmV2Q29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYXJkLWNvbnRhaW5lclwiKTtcclxuICBjb25zdCBjYXJkQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICBjb25zdCBzZXRTdGF0Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgY29uc3QgaW1nTGluayA9IGNhcmRJbmZvLmltYWdlX3VyaXMubm9ybWFsO1xyXG4gIGNvbnN0IHNldEJhckNoYXJ0UGxhY2Vob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBjb25zdCBzZXRQaWVDaGFydFBsYWNlaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgY29uc3QgcGllTG9hZGluZ0ljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcclxuICBjb25zdCBiYXJMb2FkaW5nSWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpXCIpO1xyXG5cclxuICBpZiAocHJldkNvbnRhaW5lcikgYm9hcmQucmVtb3ZlQ2hpbGQocHJldkNvbnRhaW5lcik7XHJcbiAgXHJcbiAgcGllTG9hZGluZ0ljb24uY2xhc3NMaXN0LmFkZChcImZhXCIpO1xyXG4gIHBpZUxvYWRpbmdJY29uLmNsYXNzTGlzdC5hZGQoXCJmYS1zcGlubmVyXCIpO1xyXG5cclxuICBiYXJMb2FkaW5nSWNvbi5jbGFzc0xpc3QuYWRkKFwiZmFcIik7XHJcbiAgYmFyTG9hZGluZ0ljb24uY2xhc3NMaXN0LmFkZChcImZhLXNwaW5uZXJcIik7XHJcblxyXG4gIHNldFN0YXRDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnc2V0LXN0YXRzLWNvbnRhaW5lcicpO1xyXG4gIHNldEJhckNoYXJ0UGxhY2Vob2xkZXIuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJzZXQtYmFyLXBoXCIpOyAvLyA8LS0tIFRBUkdFVCBUTyBSRVBMQUNFIFRIRSBCQVJDSEFSVFxyXG4gIHNldFBpZUNoYXJ0UGxhY2Vob2xkZXIuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJzZXQtcGllLXBoXCIpOyAvLyA8LS0tIFRBUkdFVCBUTyBSRVBMQUNFIFRIRSBQSUVDSEFSVFxyXG5cclxuICBzZXRCYXJDaGFydFBsYWNlaG9sZGVyLmFwcGVuZChiYXJMb2FkaW5nSWNvbik7XHJcbiAgc2V0UGllQ2hhcnRQbGFjZWhvbGRlci5hcHBlbmQocGllTG9hZGluZ0ljb24pO1xyXG5cclxuICBib2FyZC5hcHBlbmQoY2FyZENvbnRhaW5lcik7XHJcblxyXG4gIHNldFN0YXRDb250YWluZXIuYXBwZW5kKHNldEJhckNoYXJ0UGxhY2Vob2xkZXIpO1xyXG4gIHNldFN0YXRDb250YWluZXIuYXBwZW5kKHNldFBpZUNoYXJ0UGxhY2Vob2xkZXIpO1xyXG5cclxuICBjYXJkQ29udGFpbmVyLmFwcGVuZChpbWdDcmVhdG9yKGltZ0xpbmspKTtcclxuICBjYXJkQ29udGFpbmVyLmFwcGVuZChzdGF0QmxvY2tDcmVhdG9yKGNhcmRJbmZvKSk7XHJcbiAgY2FyZENvbnRhaW5lci5hcHBlbmQoc2V0U3RhdENvbnRhaW5lcik7XHJcbiAgY2FyZENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcImNhcmQtY29udGFpbmVyXCIpO1xyXG4gIGNhcmRDb250YWluZXIuY2xhc3NMaXN0LmFkZChcImNhcmQtY29udGFpbmVyXCIpO1xyXG5cclxuICBzZXRGZXRjaGVyKGNhcmRJbmZvKVxyXG4gICAgLnRoZW4oY2FyZFNldCA9PiBzZXRTdGF0c0NyZWF0b3IoY2FyZEluZm8sIGNhcmRTZXQpKVxyXG59XHJcblxyXG5jb25zdCBpbWdDcmVhdG9yID0gaW1nTGluayA9PiB7XHJcbiAgY29uc3QgaW1nQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICBpbWdDb250YWluZXIuY2xhc3NMaXN0LmFkZChcImltYWdlLWNvbnRhaW5lclwiKTtcclxuICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xyXG4gIGltZy5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgaW1nTGluayk7XHJcbiAgaW1nQ29udGFpbmVyLmFwcGVuZChpbWcpO1xyXG5cclxuICByZXR1cm4gaW1nQ29udGFpbmVyO1xyXG59XHJcblxyXG5jb25zdCBzdGF0QmxvY2tDcmVhdG9yID0gKGNhcmRJbmZvKSA9PiB7XHJcbiAgY29uc3QgeyBcclxuICAgIG5hbWUsIFxyXG4gICAgbWFuYV9jb3N0LCBcclxuICAgIHJhcml0eSwgXHJcbiAgICBvcmFjbGVfdGV4dCwgXHJcbiAgICBzZXRfbmFtZSwgXHJcbiAgICB0eXBlX2xpbmUsICBcclxuICB9ID0gY2FyZEluZm87XHJcblxyXG4gIGNvbnN0IHN0YXRCbG9ja0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiKTtcclxuICBzdGF0QmxvY2tDb250YWluZXIuY2xhc3NMaXN0LmFkZChcInN0YXQtYmxvY2stY29udGFpbmVyXCIpO1xyXG5cclxuICBjb25zdCBjYXJkVGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIilcclxuICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoMlwiKVxyXG4gIGNvbnN0IGNhcmRDb3N0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICBjYXJkQ29zdC5pbm5lckhUTUwgPSBtYW5hX2Nvc3Q7XHJcbiAgdGl0bGUuaW5uZXJIVE1MID0gbmFtZTtcclxuICBjYXJkVGl0bGUuYXBwZW5kKHRpdGxlKVxyXG4gIGNhcmRUaXRsZS5hcHBlbmQoY2FyZENvc3QpO1xyXG4gIGNhcmRUaXRsZS5jbGFzc0xpc3QuYWRkKFwiY2FyZC10aXRsZS1jb250YWluZXJcIik7XHJcbiAgc3RhdEJsb2NrQ29udGFpbmVyLmFwcGVuZChjYXJkVGl0bGUpO1xyXG5cclxuXHJcbiAgLy8gU0VUIFRIRSBMSVNUIFZBTFVFUyBGT1IgVEhFIENBUkRcclxuICBjb25zdCBociA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoclwiKTtcclxuICBzdGF0QmxvY2tDb250YWluZXIuYXBwZW5kKGhyKTtcclxuXHJcbiAgY29uc3QgY2FyZFR5cGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIik7XHJcbiAgY2FyZFR5cGUuaW5uZXJIVE1MID0gdHlwZV9saW5lO1xyXG4gIHN0YXRCbG9ja0NvbnRhaW5lci5hcHBlbmQoY2FyZFR5cGUpO1xyXG5cclxuICBjb25zdCBjYXJkU2V0TmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcclxuICBjYXJkU2V0TmFtZS5pbm5lckhUTUwgPSBzZXRfbmFtZTtcclxuICBzdGF0QmxvY2tDb250YWluZXIuYXBwZW5kKGNhcmRTZXROYW1lKTtcclxuXHJcbiAgY29uc3QgY2FyZFJhcml0eSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcclxuICBjYXJkUmFyaXR5LmlubmVySFRNTCA9IGNhcGl0YWxpemUocmFyaXR5KTtcclxuICBzdGF0QmxvY2tDb250YWluZXIuYXBwZW5kKGNhcmRSYXJpdHkpO1xyXG5cclxuICBjb25zdCBjYXJkT3JhY2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpO1xyXG4gIGNhcmRPcmFjbGUuaW5uZXJIVE1MID0gb3JhY2xlX3RleHQ7XHJcbiAgc3RhdEJsb2NrQ29udGFpbmVyLmFwcGVuZChjYXJkT3JhY2xlKTtcclxuXHJcbiAgcmV0dXJuIHN0YXRCbG9ja0NvbnRhaW5lcjtcclxufVxyXG5cclxuY29uc3Qgc2V0U3RhdHNDcmVhdG9yID0gKGNhcmRJbmZvLCBjYXJkU2V0KSA9PiB7XHJcbiAgY29uc29sZS5sb2coY2FyZFNldCk7XHJcbiAgdHlwZVRvdGFscyhjYXJkU2V0KS50aGVuKHRvdGFsQnJlYWtkb3duID0+IHtcclxuICAgIGNvbnNvbGUubG9nKHRvdGFsQnJlYWtkb3duKTtcclxuICAgIGNvbnN0IHR5cGVDaGFydCA9IEhpZ2hjaGFydHMuY2hhcnQoXCJzZXQtcGllLXBoXCIsIHtcclxuICAgICAgY2hhcnQ6IHtcclxuICAgICAgICBwbG90QmFja2dyb3VuZENvbG9yOiBudWxsLFxyXG4gICAgICAgIHBsb3RCb3JkZXJXaWR0aDogbnVsbCxcclxuICAgICAgICBwbG90U2hhZG93OiBmYWxzZSxcclxuICAgICAgICB0eXBlOiAncGllJ1xyXG4gICAgICB9LFxyXG4gICAgICB0aXRsZToge1xyXG4gICAgICAgIHRleHQ6IGBDYXJkIFR5cGVzICgke2NhcmRJbmZvLnNldF9uYW1lfSlgLFxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICBcImZvbnQtZmFtaWx5XCI6IFwiJHRpdGxlLWZvbnRcIixcclxuICAgICAgICAgIFwiZm9udC1zaXplXCI6IFwiMXJlbVwiXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICB0b29sdGlwOiB7XHJcbiAgICAgICAgcG9pbnRGb3JtYXQ6ICd7c2VyaWVzLm5hbWV9OiB7cG9pbnQucGVyY2VudGFnZTouMWZ9JScsXHJcbiAgICAgICAgZm9vdGVyRm9ybWF0OiAnXFxuICh7cG9pbnQueX0pJ1xyXG4gICAgICB9LFxyXG4gICAgICBhY2Nlc3NpYmlsaXR5OiB7XHJcbiAgICAgICAgcG9pbnQ6IHtcclxuICAgICAgICAgIHZhbHVlU3VmZml4OiAnJSdcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHBsb3RPcHRpb25zOiB7XHJcbiAgICAgICAgcGllOiB7XHJcbiAgICAgICAgICBhbGxvd1BvaW50U2VsZWN0OiB0cnVlLFxyXG4gICAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXHJcbiAgICAgICAgICBkYXRhTGFiZWxzOiB7XHJcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIGZvcm1hdDogJ3twb2ludC5uYW1lfScsXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgZm9udFdlaWdodDogNDAwLFxyXG4gICAgICAgICAgICAgIGZvbnRGYW1pbHk6IFwiJGJvZHktZm9udFwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHNlcmllczogW3tcclxuICAgICAgICBuYW1lOiAnVHlwZXMnLFxyXG4gICAgICAgIGNvbG9yQnlQb2ludDogdHJ1ZSxcclxuICAgICAgICBkYXRhOiBPYmplY3QuZW50cmllcyh0b3RhbEJyZWFrZG93bi50eXBlcykuc29ydCgoYSxiKSA9PiBhWzFdIC0gYlsxXSkucmV2ZXJzZSgpLm1hcChwYWlyID0+IHtcclxuICAgICAgICAgIHJldHVybiB7bmFtZTogcGFpclswXSwgeTogcGFpclsxXX1cclxuICAgICAgICB9KVxyXG4gICAgICB9XVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdmFsdWVDaGFydCA9IEhpZ2hjaGFydHMuY2hhcnQoXCJzZXQtYmFyLXBoXCIsIHtcclxuICAgICAgY2hhcnQ6IHtcclxuICAgICAgICB0eXBlOiAnY29sdW1uJ1xyXG4gICAgfSxcclxuICAgIHRpdGxlOiB7XHJcbiAgICAgICAgdGV4dDogYE1vc3QgVmFsdWVkICgke2NhcmRJbmZvLnNldF9uYW1lfSlgLFxyXG4gICAgICAgIHN0eWxlOiB7IFxyXG4gICAgICAgICAgXCJmb250LWZhbWlseVwiOiBcIiR0aXRsZS1mb250XCIsXHJcbiAgICAgICAgICBcImZvbnQtc2l6ZVwiOiBcIjFyZW1cIlxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB4QXhpczoge1xyXG4gICAgICAgIGNhdGVnb3JpZXM6IHRvdGFsQnJlYWtkb3duLm5vblByb21vVG9wVGVuLm1hcChjYXJkID0+IGNhcmQubmFtZSksXHJcbiAgICAgICAgY3Jvc3NoYWlyOiB0cnVlLFxyXG4gICAgICAgIGxhYmVsczogeyBlbmFibGVkOiBmYWxzZSB9XHJcbiAgICB9LFxyXG4gICAgeUF4aXM6IHtcclxuICAgICAgICBtaW46IDAsXHJcbiAgICAgICAgdGl0bGU6IHtcclxuICAgICAgICAgICAgdGV4dDogJ1VTRCcsXHJcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBvcHBvc2l0ZTogdHJ1ZVxyXG4gICAgfSxcclxuICAgIHRvb2x0aXA6IHtcclxuICAgICAgICBoZWFkZXJGb3JtYXQ6ICc8c3BhbiBzdHlsZT1cImZvbnQtc2l6ZToxMHB4XCI+e3BvaW50LmtleX08L3NwYW4+PHRhYmxlPicsXHJcbiAgICAgICAgcG9pbnRGb3JtYXQ6ICc8dHI+PHRkIHN0eWxlPVwiY29sb3I6e3Nlcmllcy5jb2xvcn07cGFkZGluZzowXCI+e3Nlcmllcy5uYW1lfTogPC90ZD4nICtcclxuICAgICAgICAgICAgJzx0ZCBzdHlsZT1cInBhZGRpbmc6MFwiPjxiPiR7cG9pbnQueTouMWZ9PC9iPjwvdGQ+PC90cj4nLFxyXG4gICAgICAgIGZvb3RlckZvcm1hdDogJzwvdGFibGU+JyxcclxuICAgICAgICBzaGFyZWQ6IHRydWUsXHJcbiAgICAgICAgdXNlSFRNTDogdHJ1ZVxyXG4gICAgfSxcclxuICAgIHBsb3RPcHRpb25zOiB7XHJcbiAgICAgICAgY29sdW1uOiB7XHJcbiAgICAgICAgICAgIHBvaW50UGFkZGluZzogMC4yLFxyXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogMFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBzZXJpZXM6IFt7XHJcbiAgICAgICAgbmFtZTogJ1ZhbHVlJyxcclxuICAgICAgICBjb2xvckJ5UG9pbnQ6IHRydWUsXHJcbiAgICAgICAgZGF0YTogdG90YWxCcmVha2Rvd24ubm9uUHJvbW9Ub3BUZW4ubWFwKGNhcmQgPT4gcGFyc2VGbG9hdChjYXJkLnByaWNlcy51c2QpKSxcclxuICAgICAgICBzaG93SW5MZWdlbmQ6IGZhbHNlXHJcbiAgICB9XVxyXG4gICAgfSk7XHJcbiAgfSlcclxufVxyXG5cclxuY29uc3QgY2FwaXRhbGl6ZSA9IHN0ciA9PntcclxuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjYXJkR2VuZXJhdG9yOyIsImV4cG9ydCBsZXQgY2FyZDtcclxuaW1wb3J0ICdiYWJlbC1wb2x5ZmlsbCc7XHJcblxyXG5leHBvcnQgY29uc3QgY2FyZFNlYXJjaGVyID0gYXN5bmMgKGUpID0+IHtcclxuICAvLyBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgY29uc3QgaW5wdXRTdHIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlYXJjaGJhclwiKS52YWx1ZTtcclxuICBjb25zdCB1cmwgPSAnaHR0cHM6Ly9hcGkuc2NyeWZhbGwuY29tL2NhcmRzL25hbWVkP2Z1enp5PSc7XHJcbiAgY29uc3Qgc2VhcmNoVXJsID0gdXJsICsgdmFsaWRTZWFyY2hJbnB1dChpbnB1dFN0cik7XHJcblxyXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goc2VhcmNoVXJsKTtcclxuICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gIGNhcmQgPSBhd2FpdCBqc29uO1xyXG5cclxuICByZXR1cm4gY2FyZDtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHZhbGlkU2VhcmNoSW5wdXQgPSBzZWFyY2hJbnB1dCA9PiAoIHNlYXJjaElucHV0LnNwbGl0KCcgJykuam9pbihcIi1cIikgKVxyXG4iLCJpbXBvcnQgJ2JhYmVsLXBvbHlmaWxsJztcclxuXHJcbmV4cG9ydCBjb25zdCBzZXRGZXRjaGVyID0gYXN5bmMgKGNhcmRJbmZvKSA9PiB7XHJcbiAgICBjb25zdCBzZWFyY2hVcmwgPSBgaHR0cHM6Ly9hcGkuc2NyeWZhbGwuY29tL2NhcmRzL3NlYXJjaD9vcmRlcj11c2QmcT1lJTNBJHtjYXJkSW5mby5zZXR9JnVuaXF1ZT1wcmludHNgO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChzZWFyY2hVcmwpO1xyXG4gICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICBpZiAoanNvbi5oYXNfbW9yZSl7XHJcbiAgICAgIGNvbnN0IG5leHRVcmwgPSBqc29uLm5leHRfcGFnZTtcclxuICAgICAgY29uc3QgbmV4dFJlc3BvbnNlID0gYXdhaXQgZmV0Y2gobmV4dFVybCk7XHJcbiAgICAgIGNvbnN0IG5leHRKc29uID0gYXdhaXQgbmV4dFJlc3BvbnNlLmpzb24oKTtcclxuICBcclxuICAgICAgaWYgKG5leHRKc29uLmhhc19tb3JlKXtcclxuICAgICAgICBjb25zdCBmaW5hbFVybCA9IG5leHRKc29uLm5leHRfcGFnZTtcclxuICAgICAgICBjb25zdCBmaW5hbFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZmluYWxVcmwpO1xyXG4gICAgICAgIGNvbnN0IGZpbmFsSnNvbiA9IGF3YWl0IGZpbmFsUmVzcG9uc2UuanNvbigpXHJcblxyXG4gICAgICAgIHJldHVybiBzZXRNZXJnZShbanNvbiwgbmV4dEpzb24sIGZpbmFsSnNvbl0pXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIHJldHVybiBzZXRNZXJnZShbanNvbiwgbmV4dEpzb25dKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgIHJldHVybiBhd2FpdCBqc29uO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3Qgc2V0TWVyZ2UgPSBhc3luYyAoYXJyT2ZTZXRzKSA9PiB7XHJcbiAgbGV0IGJhc2VTZXQgPSBhcnJPZlNldHNbMF07XHJcblxyXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJyT2ZTZXRzLmxlbmd0aDsgaSsrKXtcclxuICAgIGNvbnN0IG1lcmdpbmdTZXQgPSBhcnJPZlNldHNbaV07XHJcbiAgICBiYXNlU2V0LmRhdGEgPSBiYXNlU2V0LmRhdGEuY29uY2F0KG1lcmdpbmdTZXQuZGF0YSlcclxuICB9XHJcblxyXG4gIHJldHVybiBiYXNlU2V0O1xyXG59XHJcblxyXG5cclxuIiwiaW1wb3J0ICdiYWJlbC1wb2x5ZmlsbCc7XG5cbmV4cG9ydCBjb25zdCB0eXBlVG90YWxzID0gYXN5bmMgc2V0ID0+IHtcbiAgICAvLyByZXR1cm4gb2JqIHdpdGggYWxsIHR5cGVzIGFzIGtleXMgZXhjZXB0IGJhc2ljIGxhbmRzXG4gICAgY29uc3QgTVRHQ0FSRFRZUEVTID0gWydBcnRpZmFjdCcsICdDcmVhdHVyZScsICdFbmNoYW50bWVudCcsICdJbnN0YW50JywgJ0xhbmQnLCAnUGxhbmVzd2Fsa2VyJywgJ1NvcmNlcnknLCAnVHJpYmFsJ107XG4gICAgY29uc3QgY2FyZHMgPSBzZXQuZGF0YTtcbiAgICBjb25zdCBzdGF0cyA9IHsgXG4gICAgICAgIG5vbkJhc2ljc1RvdGFsOiAwLCBcbiAgICAgICAgdG90YWxTZXRWYWx1ZTogMCxcbiAgICAgICAgbm9uUHJvbW9Ub3BUZW46IFtdLFxuICAgICAgICB0b3RhbFNldFZhbHVlQXZlcmFnZTogMCxcbiAgICAgICAgdHlwZXM6IHt9LFxuICAgICAgICBzdWJUeXBlczoge31cbiAgICB9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYXJkcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IGNhcmQgPSBjYXJkc1tpXTtcbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkVHlwZXM7XG4gICAgICAgIC8vIFJFTU9WRSBQUk9NTyBDQVJEUyBGUk9NIFRIRSBQT09MIEJFQ0FVU0UgVEhFWSdSRSBEVVBFU1xuICAgICAgICBpZiAoY2FyZC5wcm9tbyl7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRDYXJkVHlwZXMgPSB0eXBlTGluZVBhcnNlcihjYXJkLnR5cGVfbGluZSk7IC8vIDwtLSBcblxuICAgICAgICBpZiAoY3VycmVudENhcmRUeXBlcy5pbmNsdWRlcygnQmFzaWMnKSl7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNhcmRWYWx1ZSA9ICh0eXBlb2YgY2FyZC5wcmljZXMudXNkID09PSBcInVuZGVmaW5lZFwiIHx8IGNhcmQucHJpY2VzLnVzZCA9PT0gbnVsbCkgPyAwIDogcGFyc2VGbG9hdChjYXJkLnByaWNlcy51c2QpXG4gICAgICAgICAgICBjdXJyZW50Q2FyZFR5cGVzLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKE1UR0NBUkRUWVBFUy5pbmNsdWRlcyh0eXBlKSAmJiB0eXBlb2Ygc3RhdHMudHlwZXNbdHlwZV0gPT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMudHlwZXNbdHlwZV0gPSAxXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNVEdDQVJEVFlQRVMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMudHlwZXNbdHlwZV0gKz0gMVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIU1UR0NBUkRUWVBFUy5pbmNsdWRlcyh0eXBlKSAmJiB0eXBlb2Ygc3RhdHMuc3ViVHlwZXNbdHlwZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLnN1YlR5cGVzW3R5cGVdID0gMVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLnN1YlR5cGVzW3R5cGVdICs9IDFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0YXRzLm5vbkJhc2ljc1RvdGFsICs9IDE7XG4gICAgICAgICAgICBzdGF0cy50b3RhbFNldFZhbHVlICs9IGNhcmRWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKHN0YXRzLm5vblByb21vVG9wVGVuLmxlbmd0aCA8IDEwKXtcbiAgICAgICAgICAgICAgICBzdGF0cy5ub25Qcm9tb1RvcFRlbi5wdXNoKGNhcmQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0cy5ub25Qcm9tb1RvcFRlblZhbHVlQXZlcmFnZSA9IGNhcmRBdmVyYWdlcihzdGF0cy5ub25Qcm9tb1RvcFRlbik7XG4gICAgc3RhdHMudG90YWxTZXRWYWx1ZUF2ZXJhZ2UgPSBzdGF0cy50b3RhbFNldFZhbHVlIC8gc3RhdHMubm9uQmFzaWNzVG90YWw7XG5cbiAgICByZXR1cm4gc3RhdHNcbn1cblxuY29uc3QgY2FyZEF2ZXJhZ2VyID0gY2FyZEFyciA9PiB7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBjYXJkQXJyLmZvckVhY2goY2FyZCA9PiB0b3RhbCArPSBwYXJzZUZsb2F0KGNhcmQucHJpY2VzLnVzZCkpXG4gICAgcmV0dXJuIHRvdGFsIC8gY2FyZEFyci5sZW5ndGg7XG59XG5cbmNvbnN0IHR5cGVMaW5lUGFyc2VyID0gdHlwZUxpbmVTdHIgPT4ge1xuICAgIGNvbnN0IHR5cGVBcnIgPSB0eXBlTGluZVN0ci5zcGxpdCgnICcpXG4gICAgcmV0dXJuIHR5cGVBcnIuZmlsdGVyKHR5cGUgPT4gdHlwZS5sZW5ndGggPiAyKVxufVxuXG5jb25zdCBoaWdoY2hhcnRzRGlnZXN0ID0gKHN0YXRzKSA9PiB7XG4gICAgLy9jaGVjayBoaWdoY2hhcnRzIGZvciBmb3JtYXR0aW5nLi4uXG59XG5cbi8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgdmFyIG15Q2hhcnQgPSBIaWdoY2hhcnRzLmNoYXJ0KCdjb250YWluZXInLCB7XG4vLyAgICAgICAgIGNoYXJ0OiB7XG4vLyAgICAgICAgICAgICB0eXBlOiAnYmFyJ1xuLy8gICAgICAgICB9LFxuLy8gICAgICAgICB0aXRsZToge1xuLy8gICAgICAgICAgICAgdGV4dDogJ1RvcCBUZW4gaW4ge1NFVCBOQU1FfSdcbi8vICAgICAgICAgfSxcbi8vICAgICAgICAgeEF4aXM6IHtcbi8vICAgICAgICAgICAgIGNhdGVnb3JpZXM6IFsnQXBwbGVzJywgJ0JhbmFuYXMnLCAnT3JhbmdlcyddXG4vLyAgICAgICAgIH0sXG4vLyAgICAgICAgIHlBeGlzOiB7XG4vLyAgICAgICAgICAgICB0aXRsZToge1xuLy8gICAgICAgICAgICAgICAgIHRleHQ6ICdVU0QnXG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH0sXG4vLyAgICAgICAgIHNlcmllczogW3tcbi8vICAgICAgICAgICAgIG5hbWU6ICdKYW5lJyxcbi8vICAgICAgICAgICAgIGRhdGE6IFsxLCAwLCA0XVxuLy8gICAgICAgICB9LCB7XG4vLyAgICAgICAgICAgICBuYW1lOiAnSm9obicsXG4vLyAgICAgICAgICAgICBkYXRhOiBbNSwgNywgM11cbi8vICAgICAgICAgfV1cbi8vICAgICB9KTtcbi8vIH0pOyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=
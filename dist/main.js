/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-polyfill/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/babel-polyfill/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

__webpack_require__(/*! core-js/shim */ "./node_modules/core-js/shim.js");

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/babel-polyfill/node_modules/regenerator-runtime/runtime.js");

__webpack_require__(/*! core-js/fn/regexp/escape */ "./node_modules/core-js/fn/regexp/escape.js");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}

global._babelPolyfill = true;
var DEFINE_PROPERTY = "defineProperty";

function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);
"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/regenerator-runtime/runtime.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/regenerator-runtime/runtime.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */
!function (global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;

  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    } // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.


    return;
  } // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.


  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  runtime.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  runtime.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function () {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function (record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
}( // Among the various tricks for obtaining a reference to the global
// object, this seems to be the most reliable technique that does not
// use indirect eval (which violates Content Security Policy).
typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/core-js/fn/regexp/escape.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/fn/regexp/escape.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/core.regexp.escape */ "./node_modules/core-js/modules/core.regexp.escape.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").RegExp.escape;

/***/ }),

/***/ "./node_modules/core-js/modules/_a-function.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_a-function.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_a-number-value.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_a-number-value.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_add-to-unscopables.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_add-to-unscopables.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('unscopables');

var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(ArrayProto, UNSCOPABLES, {});

module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_advance-string-index.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_advance-string-index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(true); // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex


module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_an-instance.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_an-instance.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
    throw TypeError(name + ': incorrect invocation!');
  }

  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_an-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_an-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-copy-within.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-copy-within.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)


var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = [].copyWithin || function copyWithin(target
/* = 0 */
, start
/* = 0, end = @length */
) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;

  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }

  while (count-- > 0) {
    if (from in O) O[to] = O[from];else delete O[to];
    to += inc;
    from += inc;
  }

  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-fill.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_array-fill.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = function fill(value
/* , start = 0, end = @length */
) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

  while (endPos > index) O[index++] = value;

  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-from-iterable.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-from-iterable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-includes.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_array-includes.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-methods.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_array-methods.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var asc = __webpack_require__(/*! ./_array-species-create */ "./node_modules/core-js/modules/_array-species-create.js");

module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;

    for (; length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);

      if (TYPE) {
        if (IS_MAP) result[index] = res; // map
        else if (res) switch (TYPE) {
            case 3:
              return true;
            // some

            case 5:
              return val;
            // find

            case 6:
              return index;
            // findIndex

            case 2:
              result.push(val);
            // filter
          } else if (IS_EVERY) return false; // every
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-reduce.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_array-reduce.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }

    index += i;

    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }

  for (; isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }

  return memo;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-species-constructor.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-species-constructor.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (original) {
  var C;

  if (isArray(original)) {
    C = original.constructor; // cross-realm fallback

    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;

    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }

  return C === undefined ? Array : C;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-species-create.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-species-create.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ "./node_modules/core-js/modules/_array-species-constructor.js");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_bind.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_bind.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/core-js/modules/_invoke.js");

var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']'; // eslint-disable-next-line no-new-func


    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  }

  return factories[len](F, args);
};

module.exports = Function.bind || function bind(that
/* , ...args */
) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);

  var bound = function ()
  /* args... */
  {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };

  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_classof.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_classof.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag'); // ES3 wrong here


var ARG = cof(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) {
    /* empty */
  }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
  : ARG ? cof(O) // ES3 arguments fallback
  : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_cof.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_cof.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_collection-strong.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_collection-strong.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

var $iterDefine = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/modules/_iter-define.js");

var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/modules/_iter-step.js");

var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var fastKey = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").fastKey;

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index]; // frozen object case

  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type

      that._i = create(null); // index

      that._f = undefined; // first entry

      that._l = undefined; // last entry

      that[SIZE] = 0; // size

      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }

        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);

        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        }

        return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn
      /* , that = undefined */
      ) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;

        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this); // revert to the last existing entry

          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index; // change existing entry

    if (entry) {
      entry.v = value; // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true),
        // <- index
        k: key,
        // <- key
        v: value,
        // <- value
        p: prev = that._l,
        // <- previous entry
        n: undefined,
        // <- next entry
        r: false // <- removed

      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++; // add to index

      if (index !== 'F') that._i[index] = entry;
    }

    return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target

      this._k = kind; // kind

      this._l = undefined; // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l; // revert to the last existing entry

      while (entry && entry.r) entry = entry.p; // get next entry


      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      } // return step by kind


      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

    setSpecies(NAME);
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_collection-to-json.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_collection-to-json.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

var from = __webpack_require__(/*! ./_array-from-iterable */ "./node_modules/core-js/modules/_array-from-iterable.js");

module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_collection-weak.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_collection-weak.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

var getWeak = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").getWeak;

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js");

var $has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0; // fallback for uncaught frozen keys

var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function () {
  this.a = [];
};

var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};
module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type

      that._i = id++; // collection id

      that._l = undefined; // leak store for uncaught frozen objects

      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

/***/ }),

/***/ "./node_modules/core-js/modules/_collection.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_collection.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/core-js/modules/_inherit-if-required.js");

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};

  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY, KEY == 'delete' ? function (a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'has' ? function has(a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'get' ? function get(a) {
      return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'add' ? function add(a) {
      fn.call(this, a === 0 ? 0 : a);
      return this;
    } : function set(a, b) {
      fn.call(this, a === 0 ? 0 : a, b);
      return this;
    });
  };

  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C(); // early implementations not supports chaining

    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false

    var THROWS_ON_PRIMITIVES = fails(function () {
      instance.has(1);
    }); // most early implementations doesn't supports iterables, most modern - not close it correctly

    var ACCEPT_ITERABLES = $iterDetect(function (iter) {
      new C(iter);
    }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same

    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;

      while (index--) $instance[ADDER](index, index);

      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);
  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);
  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
  return C;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_core.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_core.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = {
  version: '2.6.11'
};
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/core-js/modules/_create-property.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_create-property.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_ctx.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_ctx.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_date-to-iso-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_date-to-iso-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
}; // PhantomJS / old WebKit has a broken implementations


module.exports = fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
}) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

/***/ }),

/***/ "./node_modules/core-js/modules/_date-to-primitive.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_date-to-primitive.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_defined.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_defined.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_descriptors.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_descriptors.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/core-js/modules/_dom-create.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_dom-create.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document; // typeof document.createElement is 'object' in old IE


var is = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),

/***/ "./node_modules/core-js/modules/_enum-bug-keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_enum-bug-keys.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

/***/ }),

/***/ "./node_modules/core-js/modules/_enum-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_enum-keys.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");

module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;

  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;

    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  }

  return result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_export.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_export.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;

  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

    out = (own ? target : source)[key]; // bind timers to global for call from export context

    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global

    if (target) redefine(target, key, out, type & $export.U); // export

    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};

global.core = core; // type bitmap

$export.F = 1; // forced

$export.G = 2; // global

$export.S = 4; // static

$export.P = 8; // proto

$export.B = 16; // bind

$export.W = 32; // wrap

$export.U = 64; // safe

$export.R = 128; // real proto method for `library`

module.exports = $export;

/***/ }),

/***/ "./node_modules/core-js/modules/_fails-is-regexp.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_fails-is-regexp.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match');

module.exports = function (KEY) {
  var re = /./;

  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) {
      /* empty */
    }
  }

  return true;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_fails.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_fails.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_fix-re-wks.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_fix-re-wks.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./es6.regexp.exec */ "./node_modules/core-js/modules/es6.regexp.exec.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");

var SPECIES = wks('species');
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;

  re.exec = function () {
    var result = [];
    result.groups = {
      a: '7'
    };
    return result;
  };

  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;

  re.exec = function () {
    return originalExec.apply(this, arguments);
  };

  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
}();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};

    O[SYMBOL] = function () {
      return 7;
    };

    return ''[KEY](O) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    re.exec = function () {
      execCalled = true;
      return null;
    };

    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};

      re.constructor[SPECIES] = function () {
        return re;
      };
    }

    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return {
            done: true,
            value: nativeRegExpMethod.call(regexp, str, arg2)
          };
        }

        return {
          done: true,
          value: nativeMethod.call(str, regexp, arg2)
        };
      }

      return {
        done: false
      };
    });
    var strfn = fns[0];
    var rxfn = fns[1];
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {
      return rxfn.call(string, this, arg);
    } // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {
      return rxfn.call(string, this);
    });
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_flags.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_flags.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 21.2.5.3 get RegExp.prototype.flags

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_flatten-into-array.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_flatten-into-array.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray

var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var IS_CONCAT_SPREADABLE = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
      spreadable = false;

      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }

    sourceIndex++;
  }

  return targetIndex;
}

module.exports = flattenIntoArray;

/***/ }),

/***/ "./node_modules/core-js/modules/_for-of.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_for-of.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/modules/_iter-call.js");

var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");

var BREAK = {};
var RETURN = {};

var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () {
    return iterable;
  } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator

  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};

exports.BREAK = BREAK;
exports.RETURN = RETURN;

/***/ }),

/***/ "./node_modules/core-js/modules/_function-to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_function-to-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('native-function-to-string', Function.toString);

/***/ }),

/***/ "./node_modules/core-js/modules/_global.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/core-js/modules/_has.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_has.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_hide.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_hide.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_html.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_html.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document;

module.exports = document && document.documentElement;

/***/ }),

/***/ "./node_modules/core-js/modules/_ie8-dom-define.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_ie8-dom-define.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js")('div'), 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/core-js/modules/_inherit-if-required.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_inherit-if-required.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var setPrototypeOf = __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/modules/_set-proto.js").set;

module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;

  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  }

  return that;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_invoke.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_invoke.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;

  switch (args.length) {
    case 0:
      return un ? fn() : fn.call(that);

    case 1:
      return un ? fn(args[0]) : fn.call(that, args[0]);

    case 2:
      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);

    case 3:
      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);

    case 4:
      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
  }

  return fn.apply(that, args);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iobject.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_iobject.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js"); // eslint-disable-next-line no-prototype-builtins


module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-array-iter.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_is-array-iter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');

var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-array.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_is-array.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-integer.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-integer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var floor = Math.floor;

module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-regexp.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-regexp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

var MATCH = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match');

module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-call.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-call.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-create.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-create.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

__webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator'), function () {
  return this;
});

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, {
    next: descriptor(1, next)
  });
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-define.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-define.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/modules/_iter-create.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');

var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () {
  return this;
};

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);

  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];

    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };

      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }

    return function entries() {
      return new Constructor(this, kind);
    };
  };

  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype; // Fix native

  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));

    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  } // fix Array#{values, @@iterator}.name in V8 / FF


  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;

    $default = function values() {
      return $native.call(this);
    };
  } // Define iterator


  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  } // Plug for library


  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;

  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }

  return methods;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-detect.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-detect.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');

var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();

  riter['return'] = function () {
    SAFE_CLOSING = true;
  }; // eslint-disable-next-line no-throw-literal


  Array.from(riter, function () {
    throw 2;
  });
} catch (e) {
  /* empty */
}

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;

  try {
    var arr = [7];
    var iter = arr[ITERATOR]();

    iter.next = function () {
      return {
        done: safe = true
      };
    };

    arr[ITERATOR] = function () {
      return iter;
    };

    exec(arr);
  } catch (e) {
    /* empty */
  }

  return safe;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-step.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-step.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return {
    value: value,
    done: !!done
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iterators.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iterators.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),

/***/ "./node_modules/core-js/modules/_library.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_library.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = false;

/***/ }),

/***/ "./node_modules/core-js/modules/_math-expm1.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_math-expm1.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = !$expm1 // Old FF bug
|| $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 // Tor Browser bug
|| $expm1(-2e-17) != -2e-17 ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

/***/ }),

/***/ "./node_modules/core-js/modules/_math-fround.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_math-fround.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(/*! ./_math-sign */ "./node_modules/core-js/modules/_math-sign.js");

var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs); // eslint-disable-next-line no-self-compare

  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_math-log1p.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_math-log1p.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_math-scale.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_math-scale.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (arguments.length === 0 // eslint-disable-next-line no-self-compare
  || x != x // eslint-disable-next-line no-self-compare
  || inLow != inLow // eslint-disable-next-line no-self-compare
  || inHigh != inHigh // eslint-disable-next-line no-self-compare
  || outLow != outLow // eslint-disable-next-line no-self-compare
  || outHigh != outHigh) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_math-sign.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_math-sign.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_meta.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_meta.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js")('meta');

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var setDesc = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var FREEZE = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});

var setMeta = function (it) {
  setDesc(it, META, {
    value: {
      i: 'O' + ++id,
      // object ID
      w: {} // weak collections IDs

    }
  });
};

var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F'; // not necessary to add metadata

    if (!create) return 'E'; // add missing metadata

    setMeta(it); // return object ID
  }

  return it[META].i;
};

var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true; // not necessary to add metadata

    if (!create) return false; // add missing metadata

    setMeta(it); // return hash weak collections IDs
  }

  return it[META].w;
}; // add metadata on freeze-family methods calling


var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};

var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

/***/ }),

/***/ "./node_modules/core-js/modules/_metadata.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_metadata.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Map = __webpack_require__(/*! ./es6.map */ "./node_modules/core-js/modules/es6.map.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('metadata');

var store = shared.store || (shared.store = new (__webpack_require__(/*! ./es6.weak-map */ "./node_modules/core-js/modules/es6.weak-map.js"))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);

  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }

  var keyMetadata = targetMetadata.get(targetKey);

  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  }

  return keyMetadata;
};

var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};

var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};

var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};

var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) {
    keys.push(key);
  });
  return keys;
};

var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};

var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

/***/ }),

/***/ "./node_modules/core-js/modules/_microtask.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_microtask.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var macrotask = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js").set;

var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();

    while (head) {
      fn = head.fn;
      head = head.next;

      try {
        fn();
      } catch (e) {
        if (head) notify();else last = undefined;
        throw e;
      }
    }

    last = undefined;
    if (parent) parent.enter();
  }; // Node.js


  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    }; // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339

  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, {
      characterData: true
    }); // eslint-disable-line no-new

    notify = function () {
      node.data = toggle = !toggle;
    }; // environments with maybe non-completely correct, but existent Promise

  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);

    notify = function () {
      promise.then(flush);
    }; // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout

  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = {
      fn: fn,
      next: undefined
    };
    if (last) last.next = task;

    if (!head) {
      head = task;
      notify();
    }

    last = task;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_new-promise-capability.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/_new-promise-capability.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 25.4.1.5 NewPromiseCapability(C)

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-assign.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-assign.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 19.1.2.1 Object.assign(target, source, ...)

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");

var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

module.exports = !$assign || __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  var A = {};
  var B = {}; // eslint-disable-next-line no-undef

  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;

  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  }

  return T;
} : $assign;

/***/ }),

/***/ "./node_modules/core-js/modules/_object-create.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-create.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/modules/_object-dps.js");

var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js");

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

var Empty = function () {
  /* empty */
};

var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js")('iframe');

  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';

  __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js").appendChild(iframe);

  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);

  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;

  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];

  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO] = O;
  } else result = createDict();

  return Properties === undefined ? result : dPs(result, Properties);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-dp.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/modules/_ie8-dom-define.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var dP = Object.defineProperty;
exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-dps.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dps.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;

  while (length > i) dP.f(O, P = keys[i++], Properties[P]);

  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-forced-pam.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_object-forced-pam.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Forced replacement prototype accessors methods

module.exports = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js") || !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  var K = Math.random(); // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call

  __defineSetter__.call(null, K, function () {
    /* empty */
  });

  delete __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js")[K];
});

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopd.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopd.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/modules/_ie8-dom-define.js");

var gOPD = Object.getOwnPropertyDescriptor;
exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) {
    /* empty */
  }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopn-ext.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopn-ext.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

var toString = {}.toString;
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopn.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopn.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/modules/_object-keys-internal.js");

var hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gops.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gops.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gpo.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gpo.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];

  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }

  return O instanceof Object ? ObjectProto : null;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys-internal.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys-internal.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(false);

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key); // Don't enum bug & hidden keys


  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }

  return result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/modules/_object-keys-internal.js");

var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-pie.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-pie.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),

/***/ "./node_modules/core-js/modules/_object-sap.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-sap.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () {
    fn(1);
  }), 'Object', exp);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-to-array.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-to-array.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var isEnum = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js").f;

module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;

    while (length > i) {
      key = keys[i++];

      if (!DESCRIPTORS || isEnum.call(O, key)) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }

    return result;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_own-keys.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_own-keys.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var Reflect = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Reflect;

module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_parse-float.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_parse-float.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").parseFloat;

var $trim = __webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js").trim;

module.exports = 1 / $parseFloat(__webpack_require__(/*! ./_string-ws */ "./node_modules/core-js/modules/_string-ws.js") + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

/***/ }),

/***/ "./node_modules/core-js/modules/_parse-int.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_parse-int.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").parseInt;

var $trim = __webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js").trim;

var ws = __webpack_require__(/*! ./_string-ws */ "./node_modules/core-js/modules/_string-ws.js");

var hex = /^[-+]?0[xX]/;
module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
} : $parseInt;

/***/ }),

/***/ "./node_modules/core-js/modules/_perform.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_perform.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return {
      e: false,
      v: exec()
    };
  } catch (e) {
    return {
      e: true,
      v: e
    };
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_promise-resolve.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_promise-resolve.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/modules/_new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_property-desc.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_property-desc.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_redefine-all.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_redefine-all.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);

  return target;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_redefine.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_redefine.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var SRC = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js")('src');

var $toString = __webpack_require__(/*! ./_function-to-string */ "./node_modules/core-js/modules/_function-to-string.js");

var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

/***/ }),

/***/ "./node_modules/core-js/modules/_regexp-exec-abstract.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_regexp-exec-abstract.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec

module.exports = function (R, S) {
  var exec = R.exec;

  if (typeof exec === 'function') {
    var result = exec.call(R, S);

    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }

    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }

  return builtinExec.call(R, S);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_regexp-exec.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_regexp-exec.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpFlags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");

var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.

var nativeReplace = String.prototype.replace;
var patchedExec = nativeExec;
var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
}(); // nonparticipating capturing group, copied from es5-shim's String#split patch.


var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }

    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }

    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;

/***/ }),

/***/ "./node_modules/core-js/modules/_replacer.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_replacer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_same-value.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_same-value.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-collection-from.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_set-collection-from.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-setmap-offrom/

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, {
    from: function from(source
    /* , mapFn, thisArg */
    ) {
      var mapFn = arguments[1];
      var mapping, A, n, cb;
      aFunction(this);
      mapping = mapFn !== undefined;
      if (mapping) aFunction(mapFn);
      if (source == undefined) return new this();
      A = [];

      if (mapping) {
        n = 0;
        cb = ctx(mapFn, arguments[2], 2);
        forOf(source, false, function (nextItem) {
          A.push(cb(nextItem, n++));
        });
      } else {
        forOf(source, false, A.push, A);
      }

      return new this(A);
    }
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-collection-of.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_set-collection-of.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-setmap-offrom/

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, {
    of: function of() {
      var length = arguments.length;
      var A = new Array(length);

      while (length--) A[length] = arguments[length];

      return new this(A);
    }
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-proto.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_set-proto.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.

/* eslint-disable no-proto */
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};

module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
    try {
      set = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js")(Function.call, __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f(Object.prototype, '__proto__').set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }

    return function setPrototypeOf(O, proto) {
      check(O, proto);
      if (buggy) O.__proto__ = proto;else set(O, proto);
      return O;
    };
  }({}, false) : undefined),
  check: check
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-species.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_set-species.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () {
      return this;
    }
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-to-string-tag.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_set-to-string-tag.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
    configurable: true,
    value: tag
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_shared-key.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_shared-key.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('keys');

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_shared.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_shared.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js") ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});

/***/ }),

/***/ "./node_modules/core-js/modules/_species-constructor.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_species-constructor.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_strict-method.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_strict-method.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () {
      /* empty */
    }, 1) : method.call(null);
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-at.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-at.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js"); // true  -> String#at
// false -> String#codePointAt


module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-context.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_string-context.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-html.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_string-html.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value)

var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};

module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-pad.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-pad.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var repeat = __webpack_require__(/*! ./_string-repeat */ "./node_modules/core-js/modules/_string-repeat.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-repeat.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_string-repeat.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");

  for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;

  return res;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-trim.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_string-trim.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var spaces = __webpack_require__(/*! ./_string-ws */ "./node_modules/core-js/modules/_string-ws.js");

var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
}; // 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim


var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

/***/ }),

/***/ "./node_modules/core-js/modules/_string-ws.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-ws.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ }),

/***/ "./node_modules/core-js/modules/_task.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_task.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/core-js/modules/_invoke.js");

var html = __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js");

var cel = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function () {
  var id = +this; // eslint-disable-next-line no-prototype-builtins

  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var listener = function (event) {
  run.call(event.data);
}; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;

    while (arguments.length > i) args.push(arguments[i++]);

    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };

    defer(counter);
    return counter;
  };

  clearTask = function clearImmediate(id) {
    delete queue[id];
  }; // Node.js 0.8-


  if (__webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js")(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    }; // Sphere (JS game engine) Dispatch API

  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    }; // Browsers with MessageChannel, includes WebWorkers

  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };

    global.addEventListener('message', listener, false); // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    }; // Rest old browsers

  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}

module.exports = {
  set: setTask,
  clear: clearTask
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-absolute-index.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_to-absolute-index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var max = Math.max;
var min = Math.min;

module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-index.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_to-index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-integer.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-integer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;

module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-iobject.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-iobject.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function (it) {
  return IObject(defined(it));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-length.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-length.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var min = Math.min;

module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function (it) {
  return Object(defined(it));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-primitive.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_to-primitive.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js"); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),

/***/ "./node_modules/core-js/modules/_typed-array.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_typed-array.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js")) {
  var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

  var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

  var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

  var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

  var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");

  var $buffer = __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js");

  var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

  var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

  var propertyDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

  var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

  var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

  var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

  var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

  var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/core-js/modules/_to-index.js");

  var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

  var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

  var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

  var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

  var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

  var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");

  var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

  var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

  var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

  var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");

  var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

  var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

  var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js");

  var createArrayIncludes = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js");

  var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

  var ArrayIterators = __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");

  var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

  var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js");

  var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js");

  var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js");

  var arrayCopyWithin = __webpack_require__(/*! ./_array-copy-within */ "./node_modules/core-js/modules/_array-copy-within.js");

  var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

  var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';
  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });
  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });
  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    }

    return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);

    while (length > index) result[index] = list[index++];

    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, {
      get: function () {
        return this._d[internal];
      }
    });
  };

  var $from = function from(source
  /* , mapfn, thisArg */
  ) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;

    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      }

      O = values;
    }

    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);

    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }

    return result;
  };

  var $of = function of()
  /* ...items */
  {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);

    while (length > index) result[index] = arguments[index++];

    return result;
  }; // iOS Safari 6.x fails here


  var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
    arrayToLocaleString.call(new Uint8Array(1));
  });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start
    /* , end */
    ) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn
    /* , thisArg */
    ) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value
    /* , start, end */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn
    /* , thisArg */
    ) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate
    /* , thisArg */
    ) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate
    /* , thisArg */
    ) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn
    /* , thisArg */
    ) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement
    /* , fromIndex */
    ) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement
    /* , fromIndex */
    ) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) {
      // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement
    /* , fromIndex */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn
    /* , thisArg */
    ) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn
    /* , initialValue */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn
    /* , initialValue */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;

      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      }

      return that;
    },
    some: function some(callbackfn
    /* , thisArg */
    ) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike
  /* , offset */
  ) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);

    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target) && target[TYPED_ARRAY] && typeof key != 'symbol' && key in target && String(+key) == String(key);
  };

  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
  };

  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') // TODO: add validation descriptor w/o calling accessors
    && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
      target[key] = desc.value;
      return target;
    }

    return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () {
    arrayToString.call({});
  })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () {
      /* noop */
    },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () {
      return this[TYPED_ARRAY];
    }
  }); // eslint-disable-next-line max-statements

  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];

    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };

    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };

    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;

        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;

          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }

          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }

        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });

        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new

      new TypedArray(null); // eslint-disable-line no-new

      new TypedArray(1.5); // eslint-disable-line no-new

      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass; // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645

        if (!isObject(data)) return new Base(toIndex(data));

        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
        }

        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }

    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () {
          return NAME;
        }
      });
    }

    O[NAME] = TypedArray;
    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });
    $export($export.S + $export.F * fails(function () {
      Base.of.call(TypedArray, 1);
    }), NAME, {
      from: $from,
      of: $of
    });
    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
    $export($export.P, NAME, proto);
    setSpecies(NAME);
    $export($export.P + $export.F * FORCED_SET, NAME, {
      set: $set
    });
    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, {
      slice: $slice
    });
    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, {
      toLocaleString: $toLocaleString
    });
    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () {
  /* empty */
};

/***/ }),

/***/ "./node_modules/core-js/modules/_typed-buffer.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_typed-buffer.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/core-js/modules/_to-index.js");

var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError; // eslint-disable-next-line no-shadow-restricted-names

var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET; // IEEE754 conversions based on https://github.com/feross/ieee754

function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value); // eslint-disable-next-line no-self-compare

  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);

    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);

  buffer[--i] |= s * 128;
  return buffer;
}

function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;

  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}

function packI8(it) {
  return [it & 0xff];
}

function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}

function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}

function packF64(it) {
  return packIEEE754(it, 52, 8);
}

function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, {
    get: function () {
      return this[internal];
    }
  });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}

function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);

  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset
    /* , littleEndian */
    ) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset
    /* , littleEndian */
    ) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new

    new $ArrayBuffer(1.5); // eslint-disable-line no-new

    new $ArrayBuffer(NaN); // eslint-disable-line no-new

    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };

    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];

    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }

    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  } // iOS Safari 7.x bug


  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

/***/ }),

/***/ "./node_modules/core-js/modules/_typed.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_typed.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;
var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

/***/ }),

/***/ "./node_modules/core-js/modules/_uid.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_uid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();

module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_user-agent.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_user-agent.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var navigator = global.navigator;
module.exports = navigator && navigator.userAgent || '';

/***/ }),

/***/ "./node_modules/core-js/modules/_validate-collection.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_validate-collection.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_wks-define.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_wks-define.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/modules/_wks-ext.js");

var defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, {
    value: wksExt.f(name)
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_wks-ext.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_wks-ext.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

/***/ }),

/***/ "./node_modules/core-js/modules/_wks.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_wks.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('wks');

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

var Symbol = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Symbol;

var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),

/***/ "./node_modules/core-js/modules/core.get-iterator-method.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/core.get-iterator-method.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

module.exports = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

/***/ }),

/***/ "./node_modules/core-js/modules/core.regexp.escape.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/core.regexp.escape.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/benjamingr/RexExp.escape
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $re = __webpack_require__(/*! ./_replacer */ "./node_modules/core-js/modules/_replacer.js")(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', {
  escape: function escape(it) {
    return $re(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.copy-within.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.copy-within.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', {
  copyWithin: __webpack_require__(/*! ./_array-copy-within */ "./node_modules/core-js/modules/_array-copy-within.js")
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('copyWithin');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.every.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.every.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $every = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(4);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn
  /* , thisArg */
  ) {
    return $every(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.fill.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.fill.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', {
  fill: __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js")
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('fill');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.filter.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.filter.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $filter = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(2);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn
  /* , thisArg */
  ) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.find-index.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.find-index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $find = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(6);

var KEY = 'findIndex';
var forced = true; // Shouldn't skip holes

if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")(KEY);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.find.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.find.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $find = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(5);

var KEY = 'find';
var forced = true; // Shouldn't skip holes

if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")(KEY);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.for-each.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.for-each.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $forEach = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(0);

var STRICT = __webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn
  /* , thisArg */
  ) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.from.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.from.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/modules/_iter-call.js");

var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/modules/_create-property.js");

var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");

$export($export.S + $export.F * !__webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  Array.from(iter);
}), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike
  /* , mapfn = undefined, thisArg = undefined */
  ) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);

      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }

    result.length = index;
    return result;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.index-of.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.index-of.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $indexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(false);

var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement
  /* , fromIndex = 0 */
  ) {
    return NEGATIVE_ZERO // convert -0 to +0
    ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.is-array.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.is-array.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Array', {
  isArray: __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js");

var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/modules/_iter-step.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js"); // 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()


module.exports = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target

  this._i = 0; // next index

  this._k = kind; // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;

  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }

  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

Iterators.Arguments = Iterators.Array;
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.join.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.join.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.13 Array.prototype.join(separator)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var arrayJoin = [].join; // fallback for not array-like strings

$export($export.P + $export.F * (__webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js") != Object || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.last-index-of.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.last-index-of.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement
  /* , fromIndex = @[*-1] */
  ) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;

    for (; index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;

    return -1;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.map.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.map.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $map = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(1);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn
  /* , thisArg */
  ) {
    return $map(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.of.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.of.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/modules/_create-property.js"); // WebKit Array.of isn't generic


$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  function F() {
    /* empty */
  }

  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of()
  /* ...args */
  {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);

    while (aLen > index) createProperty(result, index, arguments[index++]);

    result.length = aLen;
    return result;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.reduce-right.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.reduce-right.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $reduce = __webpack_require__(/*! ./_array-reduce */ "./node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.reduce.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.reduce.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $reduce = __webpack_require__(/*! ./_array-reduce */ "./node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.slice.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.slice.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var html = __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js");

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var arraySlice = [].slice; // fallback for not array-like ES3 strings and DOM objects

$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;

    for (; i < size; i++) cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];

    return cloned;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.some.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.some.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $some = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(3);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn
  /* , thisArg */
  ) {
    return $some(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.sort.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.sort.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var $sort = [].sort;
var test = [1, 2, 3];
$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null); // Old WebKit
}) || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.species.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.species.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")('Array');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.now.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.now.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Date', {
  now: function () {
    return new Date().getTime();
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-iso-string.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-iso-string.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toISOString = __webpack_require__(/*! ./_date-to-iso-string */ "./node_modules/core-js/modules/_date-to-iso-string.js"); // PhantomJS / old WebKit has a broken implementations


$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-json.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-json.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
    toISOString: function () {
      return 1;
    }
  }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-primitive.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-primitive.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toPrimitive');

var proto = Date.prototype;
if (!(TO_PRIMITIVE in proto)) __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(proto, TO_PRIMITIVE, __webpack_require__(/*! ./_date-to-primitive */ "./node_modules/core-js/modules/_date-to-primitive.js"));

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-string.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;

if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this); // eslint-disable-next-line no-self-compare

    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.bind.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.function.bind.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'Function', {
  bind: __webpack_require__(/*! ./_bind */ "./node_modules/core-js/modules/_bind.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.has-instance.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.function.has-instance.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var HAS_INSTANCE = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('hasInstance');

var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype[@@hasInstance](V)

if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f(FunctionProto, HAS_INSTANCE, {
  value: function (O) {
    if (typeof this != 'function' || !isObject(O)) return false;
    if (!isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:

    while (O = getPrototypeOf(O)) if (this.prototype === O) return true;

    return false;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.name.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.function.name.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name'; // 19.2.4.2 name

NAME in FProto || __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.map.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/es6.map.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(/*! ./_collection-strong */ "./node_modules/core-js/modules/_collection-strong.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var MAP = 'Map'; // 23.1 Map Objects

module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(MAP, function (get) {
  return function Map() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.acosh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.acosh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var log1p = __webpack_require__(/*! ./_math-log1p */ "./node_modules/core-js/modules/_math-log1p.js");

var sqrt = Math.sqrt;
var $acosh = Math.acosh;
$export($export.S + $export.F * !($acosh // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
&& Math.floor($acosh(Number.MAX_VALUE)) == 710 // Tor Browser bug: Math.acosh(Infinity) -> NaN
&& $acosh(Infinity) == Infinity), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.asinh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.asinh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
} // Tor Browser bug: Math.asinh(0) -> -0


$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {
  asinh: asinh
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.atanh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.atanh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $atanh = Math.atanh; // Tor Browser bug: Math.atanh(-0) -> 0

$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.cbrt.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.cbrt.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var sign = __webpack_require__(/*! ./_math-sign */ "./node_modules/core-js/modules/_math-sign.js");

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.clz32.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.clz32.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.cosh.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.cosh.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var exp = Math.exp;
$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.expm1.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.expm1.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/core-js/modules/_math-expm1.js");

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {
  expm1: $expm1
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.fround.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.fround.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  fround: __webpack_require__(/*! ./_math-fround */ "./node_modules/core-js/modules/_math-fround.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.hypot.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.hypot.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var abs = Math.abs;
$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) {
    // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;

    while (i < aLen) {
      arg = abs(arguments[i++]);

      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }

    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.imul.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.imul.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $imul = Math.imul; // some WebKit versions fails with big numbers, some has wrong arity

$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.log10.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.log10.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.log1p.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.log1p.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log1p: __webpack_require__(/*! ./_math-log1p */ "./node_modules/core-js/modules/_math-log1p.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.log2.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.log2.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.sign.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.sign.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  sign: __webpack_require__(/*! ./_math-sign */ "./node_modules/core-js/modules/_math-sign.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.sinh.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.sinh.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/core-js/modules/_math-expm1.js");

var exp = Math.exp; // V8 near Chromium 38 has a problem with very small numbers

$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.tanh.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.tanh.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/core-js/modules/_math-expm1.js");

var exp = Math.exp;
$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.trunc.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.trunc.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.constructor.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.constructor.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/core-js/modules/_inherit-if-required.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f;

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var $trim = __webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js").trim;

var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype; // Opera ~12 has broken Object#toString

var BROKEN_COF = cof(__webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js")(proto)) == NUMBER;
var TRIM = ('trim' in String.prototype); // 7.1.3 ToNumber(argument)

var toNumber = function (argument) {
  var it = toPrimitive(argument, false);

  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;

    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        // fast equal /^0b[01]+$/i

        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        // fast equal /^0o[0-7]+$/i

        default:
          return +it;
      }

      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i); // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols

        if (code < 48 || code > maxCode) return NaN;
      }

      return parseInt(digits, radix);
    }
  }

  return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number // check on 1..constructor(foo) case
    && (BROKEN_COF ? fails(function () {
      proto.valueOf.call(that);
    }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };

  for (var keys = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? gOPN(Base) : ( // ES3:
  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES6 (in case, if modules with ES6 Number statics required before):
  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }

  $Number.prototype = proto;
  proto.constructor = $Number;

  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(global, NUMBER, $Number);
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.epsilon.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.epsilon.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  EPSILON: Math.pow(2, -52)
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-finite.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-finite.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var _isFinite = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-integer.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-integer.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  isInteger: __webpack_require__(/*! ./_is-integer */ "./node_modules/core-js/modules/_is-integer.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-nan.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-nan.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-safe-integer.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-safe-integer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var isInteger = __webpack_require__(/*! ./_is-integer */ "./node_modules/core-js/modules/_is-integer.js");

var abs = Math.abs;
$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.max-safe-integer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.max-safe-integer.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  MAX_SAFE_INTEGER: 0x1fffffffffffff
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.min-safe-integer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.min-safe-integer.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  MIN_SAFE_INTEGER: -0x1fffffffffffff
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.parse-float.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.parse-float.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $parseFloat = __webpack_require__(/*! ./_parse-float */ "./node_modules/core-js/modules/_parse-float.js"); // 20.1.2.12 Number.parseFloat(string)


$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {
  parseFloat: $parseFloat
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.parse-int.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.parse-int.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $parseInt = __webpack_require__(/*! ./_parse-int */ "./node_modules/core-js/modules/_parse-int.js"); // 20.1.2.13 Number.parseInt(string, radix)


$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {
  parseInt: $parseInt
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.to-fixed.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.to-fixed.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var aNumberValue = __webpack_require__(/*! ./_a-number-value */ "./node_modules/core-js/modules/_a-number-value.js");

var repeat = __webpack_require__(/*! ./_string-repeat */ "./node_modules/core-js/modules/_string-repeat.js");

var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;

  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};

var divide = function (n) {
  var i = 6;
  var c = 0;

  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = c % n * 1e7;
  }
};

var numToString = function () {
  var i = 6;
  var s = '';

  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  }

  return s;
};

var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function (x) {
  var n = 0;
  var x2 = x;

  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }

  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  }

  return n;
};

$export($export.P + $export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR); // eslint-disable-next-line no-self-compare

    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);

    if (x < 0) {
      s = '-';
      x = -x;
    }

    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;

      if (e > 0) {
        multiply(0, z);
        j = f;

        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }

        multiply(pow(10, j, 1), 0);
        j = e - 1;

        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }

        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }

    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    }

    return m;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.to-precision.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.to-precision.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var aNumberValue = __webpack_require__(/*! ./_a-number-value */ "./node_modules/core-js/modules/_a-number-value.js");

var $toPrecision = 1.0.toPrecision;
$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.assign.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.assign.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S + $export.F, 'Object', {
  assign: __webpack_require__(/*! ./_object-assign */ "./node_modules/core-js/modules/_object-assign.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.create.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.create.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js"); // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])


$export($export.S, 'Object', {
  create: __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.define-properties.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.define-properties.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js"); // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)


$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js"), 'Object', {
  defineProperties: __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/modules/_object-dps.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.define-property.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.define-property.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js"); // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)


$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js"), 'Object', {
  defineProperty: __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.freeze.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.freeze.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.get-own-property-descriptor.js":
/*!********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.get-own-property-descriptor.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var $getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.get-own-property-names.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.get-own-property-names.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('getOwnPropertyNames', function () {
  return __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/core-js/modules/_object-gopn-ext.js").f;
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.get-prototype-of.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.get-prototype-of.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var $getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is-extensible.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is-extensible.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is-frozen.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is-frozen.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is-sealed.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is-sealed.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Object', {
  is: __webpack_require__(/*! ./_same-value */ "./node_modules/core-js/modules/_same-value.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.keys.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.prevent-extensions.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.prevent-extensions.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.seal.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.seal.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.set-prototype-of.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.set-prototype-of.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Object', {
  setPrototypeOf: __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/modules/_set-proto.js").set
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.to-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 19.1.3.6 Object.prototype.toString()

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

var test = {};
test[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag')] = 'z';

if (test + '' != '[object z]') {
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.parse-float.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.parse-float.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $parseFloat = __webpack_require__(/*! ./_parse-float */ "./node_modules/core-js/modules/_parse-float.js"); // 18.2.4 parseFloat(string)


$export($export.G + $export.F * (parseFloat != $parseFloat), {
  parseFloat: $parseFloat
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.parse-int.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.parse-int.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $parseInt = __webpack_require__(/*! ./_parse-int */ "./node_modules/core-js/modules/_parse-int.js"); // 18.2.5 parseInt(string, radix)


$export($export.G + $export.F * (parseInt != $parseInt), {
  parseInt: $parseInt
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.promise.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/es6.promise.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

var task = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js").set;

var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/core-js/modules/_microtask.js")();

var newPromiseCapabilityModule = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/modules/_new-promise-capability.js");

var perform = __webpack_require__(/*! ./_perform */ "./node_modules/core-js/modules/_perform.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js");

var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/core-js/modules/_promise-resolve.js");

var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';

var empty = function () {
  /* empty */
};

var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);

    var FakePromise = (promise.constructor = {})[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species')] = function (exec) {
      exec(empty, empty);
    }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test


    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // we can't detect it synchronously, so just check versions
    && v8.indexOf('6.6') !== 0 && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) {
    /* empty */
  }
}(); // helpers

var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;

    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;

      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }

          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value); // may throw

            if (domain) {
              domain.exit();
              exited = true;
            }
          }

          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };

    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach


    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};

var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;

    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({
            promise: promise,
            reason: value
          });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    }

    promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};

var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};

var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;

    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({
        promise: promise,
        reason: promise._v
      });
    }
  });
};

var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};

var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");

    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = {
          _w: promise,
          _d: false
        }; // wrap

        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({
      _w: promise,
      _d: false
    }, e); // wrap
  }
}; // constructor polyfill


if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);

    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  }; // eslint-disable-next-line no-unused-vars


  Internal = function Promise(executor) {
    this._c = []; // <- awaiting reactions

    this._a = undefined; // <- checked in isUnhandled reactions

    this._s = 0; // <- state

    this._d = false; // <- done

    this._v = undefined; // <- value

    this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled

    this._n = false; // <- notify
  };

  Internal.prototype = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;

      this._c.push(reaction);

      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });

  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };

  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Promise: $Promise
});

__webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js")($Promise, PROMISE);

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")(PROMISE);

Wrapper = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js")[PROMISE]; // statics

$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.apply.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.apply.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var rApply = (__webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Reflect || {}).apply;
var fApply = Function.apply; // MS Edge argumentsList argument is optional

$export($export.S + $export.F * !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  rApply(function () {
    /* empty */
  });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.construct.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.construct.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var bind = __webpack_require__(/*! ./_bind */ "./node_modules/core-js/modules/_bind.js");

var rConstruct = (__webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Reflect || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it

var NEW_TARGET_BUG = fails(function () {
  function F() {
    /* empty */
  }

  return !(rConstruct(function () {
    /* empty */
  }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () {
    /* empty */
  });
});
$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args
  /* , newTarget */
  ) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);

    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0:
          return new Target();

        case 1:
          return new Target(args[0]);

        case 2:
          return new Target(args[0], args[1]);

        case 3:
          return new Target(args[0], args[1], args[2]);

        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      } // w/o altered newTarget, lot of arguments case


      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    } // with altered newTarget, not support built-in constructors


    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.define-property.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.define-property.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js"); // MS Edge has broken Reflect.defineProperty - throwing instead of returning false


$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, {
    value: 1
  }), 1, {
    value: 2
  });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);

    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.delete-property.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.delete-property.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f;

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.enumerate.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.enumerate.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 26.1.5 Reflect.enumerate(target)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target

  this._i = 0; // next index

  var keys = this._k = []; // keys

  var key;

  for (key in iterated) keys.push(key);
};

__webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/modules/_iter-create.js")(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;

  do {
    if (that._i >= keys.length) return {
      value: undefined,
      done: true
    };
  } while (!((key = keys[that._i++]) in that._t));

  return {
    value: key,
    done: false
  };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.get-prototype-of.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.get-prototype-of.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var getProto = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.get.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.get.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

function get(target, propertyKey
/* , receiver */
) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', {
  get: get
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.has.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.has.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.is-extensible.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.is-extensible.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var $isExtensible = Object.isExtensible;
$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.own-keys.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.own-keys.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', {
  ownKeys: __webpack_require__(/*! ./_own-keys */ "./node_modules/core-js/modules/_own-keys.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.prevent-extensions.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.prevent-extensions.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var $preventExtensions = Object.preventExtensions;
$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);

    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.set-prototype-of.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.set-prototype-of.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var setProto = __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/modules/_set-proto.js");

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);

    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.set.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.set.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

function set(target, propertyKey, V
/* , receiver */
) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;

  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }

    ownDesc = createDesc(0);
  }

  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;

    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));

    return true;
  }

  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', {
  set: set
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.constructor.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.constructor.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/core-js/modules/_inherit-if-required.js");

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");

var $flags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");

var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g; // "new" creates a new object, old webkit buggy here

var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && (!CORRECT_NEW || __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  re2[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match')] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp);
  };

  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () {
        return Base[key];
      },
      set: function (it) {
        Base[key] = it;
      }
    });
  };

  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);

  proto.constructor = $RegExp;
  $RegExp.prototype = proto;

  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(global, 'RegExp', $RegExp);
}

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")('RegExp');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.exec.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.exec.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");

__webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js")({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.flags.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.flags.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && /./g.flags != 'g') __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.match.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.match.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js"); // @@match logic


__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [// `String.prototype.match` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.match
  function match(regexp) {
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, // `RegExp.prototype[@@match]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
  function (regexp) {
    var res = maybeCallNative($match, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    if (!rx.global) return regExpExec(rx, S);
    var fullUnicode = rx.unicode;
    rx.lastIndex = 0;
    var A = [];
    var n = 0;
    var result;

    while ((result = regExpExec(rx, S)) !== null) {
      var matchStr = String(result[0]);
      A[n] = matchStr;
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      n++;
    }

    return n === 0 ? null : A;
  }];
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.replace.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.replace.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");

var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
}; // @@replace logic


__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [// `String.prototype.replace` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.replace
  function replace(searchValue, replaceValue) {
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
  }, // `RegExp.prototype[@@replace]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
  function (regexp, replaceValue) {
    var res = maybeCallNative($replace, regexp, this, replaceValue);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var functionalReplace = typeof replaceValue === 'function';
    if (!functionalReplace) replaceValue = String(replaceValue);
    var global = rx.global;

    if (global) {
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
    }

    var results = [];

    while (true) {
      var result = regExpExec(rx, S);
      if (result === null) break;
      results.push(result);
      if (!global) break;
      var matchStr = String(result[0]);
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
    }

    var accumulatedResult = '';
    var nextSourcePosition = 0;

    for (var i = 0; i < results.length; i++) {
      result = results[i];
      var matched = String(result[0]);
      var position = max(min(toInteger(result.index), S.length), 0);
      var captures = []; // NOTE: This is equivalent to
      //   captures = result.slice(1).map(maybeToString)
      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

      for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));

      var namedCaptures = result.groups;

      if (functionalReplace) {
        var replacerArgs = [matched].concat(captures, position, S);
        if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
        var replacement = String(replaceValue.apply(undefined, replacerArgs));
      } else {
        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
      }

      if (position >= nextSourcePosition) {
        accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
        nextSourcePosition = position + matched.length;
      }
    }

    return accumulatedResult + S.slice(nextSourcePosition);
  }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }

    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;

      switch (ch.charAt(0)) {
        case '$':
          return '$';

        case '&':
          return matched;

        case '`':
          return str.slice(0, position);

        case "'":
          return str.slice(tailPos);

        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;

        default:
          // \d\d?
          var n = +ch;
          if (n === 0) return match;

          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }

          capture = captures[n - 1];
      }

      return capture === undefined ? '' : capture;
    });
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.search.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.search.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var sameValue = __webpack_require__(/*! ./_same-value */ "./node_modules/core-js/modules/_same-value.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js"); // @@search logic


__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [// `String.prototype.search` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.search
  function search(regexp) {
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, // `RegExp.prototype[@@search]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
  function (regexp) {
    var res = maybeCallNative($search, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var previousLastIndex = rx.lastIndex;
    if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
    var result = regExpExec(rx, S);
    if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
    return result === null ? -1 : result.index;
  }];
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.split.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.split.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var callRegExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");

var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff; // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError

var SUPPORTS_Y = !fails(function () {
  RegExp(MAX_UINT32, 'y');
}); // @@split logic

__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;

  if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return []; // If `separator` is not a regex, use native split

      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0; // Make `global` and avoid `lastIndex` issues by working with a copy

      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;

      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];

        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }

        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }

      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));

      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    }; // Chakra, V8

  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [// `String.prototype.split` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.split
  function split(separator, limit) {
    var O = defined(this);
    var splitter = separator == undefined ? undefined : separator[SPLIT];
    return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
  }, // `RegExp.prototype[@@split]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
  //
  // NOTE: This cannot be properly polyfilled in engines that don't support
  // the 'y' flag.
  function (regexp, limit) {
    var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var C = speciesConstructor(rx, RegExp);
    var unicodeMatching = rx.unicode;
    var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g'); // ^(? + rx + ) is needed, in combination with some S slicing, to
    // simulate the 'y' flag.

    var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
    var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
    if (lim === 0) return [];
    if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
    var p = 0;
    var q = 0;
    var A = [];

    while (q < S.length) {
      splitter.lastIndex = SUPPORTS_Y ? q : 0;
      var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
      var e;

      if (z === null || (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
        q = advanceStringIndex(S, q, unicodeMatching);
      } else {
        A.push(S.slice(p, q));
        if (A.length === lim) return A;

        for (var i = 1; i <= z.length - 1; i++) {
          A.push(z[i]);
          if (A.length === lim) return A;
        }

        q = p = e;
      }
    }

    A.push(S.slice(p));
    return A;
  }];
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.to-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./es6.regexp.flags */ "./node_modules/core-js/modules/es6.regexp.flags.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var $flags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(RegExp.prototype, TO_STRING, fn, true);
}; // 21.2.5.14 RegExp.prototype.toString()


if (__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return $toString.call({
    source: 'a',
    flags: 'b'
  }) != '/a/b';
})) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  }); // FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.set.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/es6.set.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(/*! ./_collection-strong */ "./node_modules/core-js/modules/_collection-strong.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var SET = 'Set'; // 23.2 Set Objects

module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(SET, function (get) {
  return function Set() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.anchor.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.anchor.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.2 String.prototype.anchor(name)

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.big.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.big.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.3 String.prototype.big()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.blink.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.blink.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.4 String.prototype.blink()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.bold.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.bold.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.5 String.prototype.bold()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.code-point-at.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.code-point-at.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(false);

$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.ends-with.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.ends-with.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var context = __webpack_require__(/*! ./_string-context */ "./node_modules/core-js/modules/_string-context.js");

var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/core-js/modules/_fails-is-regexp.js")(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString
  /* , endPosition = @length */
  ) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.fixed.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.fixed.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.6 String.prototype.fixed()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.fontcolor.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.fontcolor.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.7 String.prototype.fontcolor(color)

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.fontsize.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.fontsize.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.8 String.prototype.fontsize(size)

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.from-code-point.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.from-code-point.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem

$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) {
    // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;

    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
    }

    return res.join('');
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.includes.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.includes.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var context = __webpack_require__(/*! ./_string-context */ "./node_modules/core-js/modules/_string-context.js");

var INCLUDES = 'includes';
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/core-js/modules/_fails-is-regexp.js")(INCLUDES), 'String', {
  includes: function includes(searchString
  /* , position = 0 */
  ) {
    return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.italics.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.italics.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.9 String.prototype.italics()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.iterator.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(true); // 21.1.3.27 String.prototype[@@iterator]()


__webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target

  this._i = 0; // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return {
    value: undefined,
    done: true
  };
  point = $at(O, index);
  this._i += point.length;
  return {
    value: point,
    done: false
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.link.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.link.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.10 String.prototype.link(url)

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.raw.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.raw.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;

    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    }

    return res.join('');
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.repeat.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.repeat.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(/*! ./_string-repeat */ "./node_modules/core-js/modules/_string-repeat.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.small.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.small.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.11 String.prototype.small()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.starts-with.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.starts-with.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var context = __webpack_require__(/*! ./_string-context */ "./node_modules/core-js/modules/_string-context.js");

var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/core-js/modules/_fails-is-regexp.js")(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString
  /* , position = 0 */
  ) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.strike.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.strike.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.12 String.prototype.strike()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.sub.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.sub.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.13 String.prototype.sub()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.sup.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.sup.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.14 String.prototype.sup()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.trim.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.trim.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 21.1.3.25 String.prototype.trim()

__webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js")('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.symbol.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es6.symbol.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // ECMAScript 6 symbols shim

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var META = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").KEY;

var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/modules/_wks-ext.js");

var wksDefine = __webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/modules/_wks-define.js");

var enumKeys = __webpack_require__(/*! ./_enum-keys */ "./node_modules/core-js/modules/_enum-keys.js");

var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

var _create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

var gOPNExt = __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/core-js/modules/_object-gopn-ext.js");

var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var $GOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");

var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;

var _stringify = $JSON && $JSON.stringify;

var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () {
      return dP(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);

  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);

  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, {
        enumerable: createDesc(0, false)
      });
    }

    return setSymbolDesc(it, key, D);
  }

  return dP(it, key, D);
};

var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;

  while (l > i) $defineProperty(it, key = keys[i++], P[key]);

  return it;
};

var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};

var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};

var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  }

  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  }

  return result;
}; // 19.4.1.1 Symbol([description])


if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);

    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };

    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: $set
    });
    return wrap(tag);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });
  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js").f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Symbol: $Symbol
});

for (var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');

    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () {
    setter = true;
  },
  useSimple: function () {
    setter = false;
  }
});
$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
}); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443

var FAILS_ON_PRIMITIVES = $fails(function () {
  $GOPS.f(1);
});
$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
}); // 24.3.2 JSON.stringify(value [, replacer [, space]])

$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol(); // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols

  return _stringify([S]) != '[null]' || _stringify({
    a: S
  }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;

    while (arguments.length > i) args.push(arguments[i++]);

    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
}); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)

$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag]

setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag]

setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag]

setToStringTag(global.JSON, 'JSON', true);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.array-buffer.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.array-buffer.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");

var buffer = __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var ArrayBuffer = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").ArrayBuffer;

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';
$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {
  ArrayBuffer: $ArrayBuffer
});
$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});
$export($export.P + $export.U + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix

    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;

    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    }

    return result;
  }
});

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")(ARRAY_BUFFER);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.data-view.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.data-view.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.G + $export.W + $export.F * !__webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js").ABV, {
  DataView: __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js").DataView
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.float32-array.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.float32-array.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.float64-array.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.float64-array.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.int16-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.int16-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.int32-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.int32-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.int8-array.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.int8-array.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint16-array.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint16-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint32-array.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint32-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint8-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint8-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint8-clamped-array.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint8-clamped-array.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.weak-map.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.weak-map.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var each = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(0);

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js");

var assign = __webpack_require__(/*! ./_object-assign */ "./node_modules/core-js/modules/_object-assign.js");

var weak = __webpack_require__(/*! ./_collection-weak */ "./node_modules/core-js/modules/_collection-weak.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var NATIVE_WEAK_MAP = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
}; // 23.3 WeakMap Objects

var $WeakMap = module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(WEAK_MAP, wrapper, methods, weak, true, true); // IE11 WeakMap frozen keys fix


if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();

        var result = this._f[key](a, b);

        return key == 'set' ? this : result; // store all the rest on native weakmap
      }

      return method.call(this, a, b);
    });
  });
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.weak-set.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.weak-set.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var weak = __webpack_require__(/*! ./_collection-weak */ "./node_modules/core-js/modules/_collection-weak.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var WEAK_SET = 'WeakSet'; // 23.4 WeakSet Objects

__webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(WEAK_SET, function (get) {
  return function WeakSet() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

/***/ }),

/***/ "./node_modules/core-js/modules/es7.array.flat-map.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.array.flat-map.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var flattenIntoArray = __webpack_require__(/*! ./_flatten-into-array */ "./node_modules/core-js/modules/_flatten-into-array.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var arraySpeciesCreate = __webpack_require__(/*! ./_array-species-create */ "./node_modules/core-js/modules/_array-species-create.js");

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn
  /* , thisArg */
  ) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('flatMap');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.array.flatten.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.array.flatten.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var flattenIntoArray = __webpack_require__(/*! ./_flatten-into-array */ "./node_modules/core-js/modules/_flatten-into-array.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var arraySpeciesCreate = __webpack_require__(/*! ./_array-species-create */ "./node_modules/core-js/modules/_array-species-create.js");

$export($export.P, 'Array', {
  flatten: function flatten()
  /* depthArg = 1 */
  {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('flatten');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.array.includes.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.array.includes.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/Array.prototype.includes

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $includes = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(true);

$export($export.P, 'Array', {
  includes: function includes(el
  /* , fromIndex = 0 */
  ) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('includes');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.asap.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/es7.asap.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/core-js/modules/_microtask.js")();

var process = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").process;

var isNode = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js")(process) == 'process';
$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.error.is-error.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.error.is-error.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/ljharb/proposal-is-error
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.global.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es7.global.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.G, {
  global: __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.map.from.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es7.map.from.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/core-js/modules/_set-collection-from.js")('Map');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.map.of.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es7.map.of.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/core-js/modules/_set-collection-of.js")('Map');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.map.to-json.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.map.to-json.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P + $export.R, 'Map', {
  toJSON: __webpack_require__(/*! ./_collection-to-json */ "./node_modules/core-js/modules/_collection-to-json.js")('Map')
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.clamp.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.clamp.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.deg-per-rad.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.deg-per-rad.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  DEG_PER_RAD: Math.PI / 180
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.degrees.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.degrees.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var RAD_PER_DEG = 180 / Math.PI;
$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.fscale.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.fscale.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var scale = __webpack_require__(/*! ./_math-scale */ "./node_modules/core-js/modules/_math-scale.js");

var fround = __webpack_require__(/*! ./_math-fround */ "./node_modules/core-js/modules/_math-fround.js");

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.iaddh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.iaddh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.imulh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.imulh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.isubh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.isubh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.rad-per-deg.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.rad-per-deg.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  RAD_PER_DEG: 180 / Math.PI
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.radians.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.radians.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var DEG_PER_RAD = Math.PI / 180;
$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.scale.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.scale.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  scale: __webpack_require__(/*! ./_math-scale */ "./node_modules/core-js/modules/_math-scale.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.signbit.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.signbit.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// http://jfbastien.github.io/papers/Math.signbit.html
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  signbit: function signbit(x) {
    // eslint-disable-next-line no-self-compare
    return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.umulh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.umulh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.define-getter.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.define-getter.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js"); // B.2.2.2 Object.prototype.__defineGetter__(P, getter)


__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "./node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, {
      get: aFunction(getter),
      enumerable: true,
      configurable: true
    });
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.define-setter.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.define-setter.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js"); // B.2.2.3 Object.prototype.__defineSetter__(P, setter)


__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "./node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, {
      set: aFunction(setter),
      enumerable: true,
      configurable: true
    });
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.entries.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.entries.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $entries = __webpack_require__(/*! ./_object-to-array */ "./node_modules/core-js/modules/_object-to-array.js")(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var ownKeys = __webpack_require__(/*! ./_own-keys */ "./node_modules/core-js/modules/_own-keys.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/modules/_create-property.js");

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;

    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }

    return result;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.lookup-getter.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.lookup-getter.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f; // B.2.2.4 Object.prototype.__lookupGetter__(P)


__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "./node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;

    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.lookup-setter.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.lookup-setter.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f; // B.2.2.5 Object.prototype.__lookupSetter__(P)


__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "./node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;

    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.values.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.values.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $values = __webpack_require__(/*! ./_object-to-array */ "./node_modules/core-js/modules/_object-to-array.js")(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.observable.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.observable.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/zenparsing/es-observable

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/core-js/modules/_microtask.js")();

var OBSERVABLE = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('observable');

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;

  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);

  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;

    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () {
        subscription.unsubscribe();
      };else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  }

  if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() {
    closeSubscription(this);
  }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;

    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;

      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;

    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    }

    cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;

    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;

      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      }

      cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});
redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);

    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }

    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          }

          observer.complete();
        }
      });
      return function () {
        done = true;
      };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];

    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          }

          observer.complete();
        }
      });
      return function () {
        done = true;
      };
    });
  }
});
hide($Observable.prototype, OBSERVABLE, function () {
  return this;
});
$export($export.G, {
  Observable: $Observable
});

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")('Observable');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.promise.finally.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.promise.finally.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/core-js/modules/_promise-resolve.js");

$export($export.P + $export.R, 'Promise', {
  'finally': function (onFinally) {
    var C = speciesConstructor(this, core.Promise || global.Promise);
    var isFunction = typeof onFinally == 'function';
    return this.then(isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () {
        return x;
      });
    } : onFinally, isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () {
        throw e;
      });
    } : onFinally);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.promise.try.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.promise.try.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-promise-try

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/modules/_new-promise-capability.js");

var perform = __webpack_require__(/*! ./_perform */ "./node_modules/core-js/modules/_perform.js");

$export($export.S, 'Promise', {
  'try': function (callbackfn) {
    var promiseCapability = newPromiseCapability.f(this);
    var result = perform(callbackfn);
    (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
    return promiseCapability.promise;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.define-metadata.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.define-metadata.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;
metadata.exp({
  defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
    ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.delete-metadata.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.delete-metadata.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;
metadata.exp({
  deleteMetadata: function deleteMetadata(metadataKey, target
  /* , targetKey */
  ) {
    var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
    var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
    if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
    if (metadataMap.size) return true;
    var targetMetadata = store.get(target);
    targetMetadata['delete'](targetKey);
    return !!targetMetadata.size || store['delete'](target);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.get-metadata-keys.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.get-metadata-keys.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(/*! ./es6.set */ "./node_modules/core-js/modules/es6.set.js");

var from = __webpack_require__(/*! ./_array-from-iterable */ "./node_modules/core-js/modules/_array-from-iterable.js");

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({
  getMetadataKeys: function getMetadataKeys(target
  /* , targetKey */
  ) {
    return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.get-metadata.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.get-metadata.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({
  getMetadata: function getMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;
metadata.exp({
  getOwnMetadataKeys: function getOwnMetadataKeys(target
  /* , targetKey */
  ) {
    return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.get-own-metadata.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.get-own-metadata.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;
metadata.exp({
  getOwnMetadata: function getOwnMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryGetOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.has-metadata.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.has-metadata.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({
  hasMetadata: function hasMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.has-own-metadata.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.has-own-metadata.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;
metadata.exp({
  hasOwnMetadata: function hasOwnMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryHasOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.metadata.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.metadata.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;
$metadata.exp({
  metadata: function metadata(metadataKey, metadataValue) {
    return function decorator(target, targetKey) {
      ordinaryDefineOwnMetadata(metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey(targetKey));
    };
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.set.from.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es7.set.from.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/core-js/modules/_set-collection-from.js")('Set');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.set.of.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es7.set.of.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/core-js/modules/_set-collection-of.js")('Set');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.set.to-json.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.set.to-json.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P + $export.R, 'Set', {
  toJSON: __webpack_require__(/*! ./_collection-to-json */ "./node_modules/core-js/modules/_collection-to-json.js")('Set')
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.at.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.at.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/mathiasbynens/String.prototype.at

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.match-all.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.match-all.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/String.prototype.matchAll/

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");

var getFlags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");

var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

__webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/modules/_iter-create.js")($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);

  return {
    value: match,
    done: match === null
  };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.pad-end.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.pad-end.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $pad = __webpack_require__(/*! ./_string-pad */ "./node_modules/core-js/modules/_string-pad.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js"); // https://github.com/zloirock/core-js/issues/280


var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padEnd: function padEnd(maxLength
  /* , fillString = ' ' */
  ) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.pad-start.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.pad-start.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $pad = __webpack_require__(/*! ./_string-pad */ "./node_modules/core-js/modules/_string-pad.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js"); // https://github.com/zloirock/core-js/issues/280


var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength
  /* , fillString = ' ' */
  ) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.trim-left.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.trim-left.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/sebmarkbage/ecmascript-string-left-right-trim

__webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js")('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.trim-right.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.trim-right.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/sebmarkbage/ecmascript-string-left-right-trim

__webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js")('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.symbol.async-iterator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.symbol.async-iterator.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/modules/_wks-define.js")('asyncIterator');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.symbol.observable.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.symbol.observable.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/modules/_wks-define.js")('observable');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.system.global.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.system.global.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'System', {
  global: __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.weak-map.from.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.weak-map.from.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/core-js/modules/_set-collection-from.js")('WeakMap');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.weak-map.of.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.weak-map.of.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/core-js/modules/_set-collection-of.js")('WeakMap');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.weak-set.from.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.weak-set.from.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/core-js/modules/_set-collection-from.js")('WeakSet');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.weak-set.of.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.weak-set.of.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/core-js/modules/_set-collection-of.js")('WeakSet');

/***/ }),

/***/ "./node_modules/core-js/modules/web.dom.iterable.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom.iterable.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;
var DOMIterables = {
  CSSRuleList: true,
  // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true,
  // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true,
  // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;

  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

/***/ }),

/***/ "./node_modules/core-js/modules/web.immediate.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/web.immediate.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $task = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js");

$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

/***/ }),

/***/ "./node_modules/core-js/modules/web.timers.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/web.timers.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js");

var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check

var wrap = function (set) {
  return function (fn, time
  /* , ...args */
  ) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};

$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

/***/ }),

/***/ "./node_modules/core-js/shim.js":
/*!**************************************!*\
  !*** ./node_modules/core-js/shim.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./modules/es6.symbol */ "./node_modules/core-js/modules/es6.symbol.js");

__webpack_require__(/*! ./modules/es6.object.create */ "./node_modules/core-js/modules/es6.object.create.js");

__webpack_require__(/*! ./modules/es6.object.define-property */ "./node_modules/core-js/modules/es6.object.define-property.js");

__webpack_require__(/*! ./modules/es6.object.define-properties */ "./node_modules/core-js/modules/es6.object.define-properties.js");

__webpack_require__(/*! ./modules/es6.object.get-own-property-descriptor */ "./node_modules/core-js/modules/es6.object.get-own-property-descriptor.js");

__webpack_require__(/*! ./modules/es6.object.get-prototype-of */ "./node_modules/core-js/modules/es6.object.get-prototype-of.js");

__webpack_require__(/*! ./modules/es6.object.keys */ "./node_modules/core-js/modules/es6.object.keys.js");

__webpack_require__(/*! ./modules/es6.object.get-own-property-names */ "./node_modules/core-js/modules/es6.object.get-own-property-names.js");

__webpack_require__(/*! ./modules/es6.object.freeze */ "./node_modules/core-js/modules/es6.object.freeze.js");

__webpack_require__(/*! ./modules/es6.object.seal */ "./node_modules/core-js/modules/es6.object.seal.js");

__webpack_require__(/*! ./modules/es6.object.prevent-extensions */ "./node_modules/core-js/modules/es6.object.prevent-extensions.js");

__webpack_require__(/*! ./modules/es6.object.is-frozen */ "./node_modules/core-js/modules/es6.object.is-frozen.js");

__webpack_require__(/*! ./modules/es6.object.is-sealed */ "./node_modules/core-js/modules/es6.object.is-sealed.js");

__webpack_require__(/*! ./modules/es6.object.is-extensible */ "./node_modules/core-js/modules/es6.object.is-extensible.js");

__webpack_require__(/*! ./modules/es6.object.assign */ "./node_modules/core-js/modules/es6.object.assign.js");

__webpack_require__(/*! ./modules/es6.object.is */ "./node_modules/core-js/modules/es6.object.is.js");

__webpack_require__(/*! ./modules/es6.object.set-prototype-of */ "./node_modules/core-js/modules/es6.object.set-prototype-of.js");

__webpack_require__(/*! ./modules/es6.object.to-string */ "./node_modules/core-js/modules/es6.object.to-string.js");

__webpack_require__(/*! ./modules/es6.function.bind */ "./node_modules/core-js/modules/es6.function.bind.js");

__webpack_require__(/*! ./modules/es6.function.name */ "./node_modules/core-js/modules/es6.function.name.js");

__webpack_require__(/*! ./modules/es6.function.has-instance */ "./node_modules/core-js/modules/es6.function.has-instance.js");

__webpack_require__(/*! ./modules/es6.parse-int */ "./node_modules/core-js/modules/es6.parse-int.js");

__webpack_require__(/*! ./modules/es6.parse-float */ "./node_modules/core-js/modules/es6.parse-float.js");

__webpack_require__(/*! ./modules/es6.number.constructor */ "./node_modules/core-js/modules/es6.number.constructor.js");

__webpack_require__(/*! ./modules/es6.number.to-fixed */ "./node_modules/core-js/modules/es6.number.to-fixed.js");

__webpack_require__(/*! ./modules/es6.number.to-precision */ "./node_modules/core-js/modules/es6.number.to-precision.js");

__webpack_require__(/*! ./modules/es6.number.epsilon */ "./node_modules/core-js/modules/es6.number.epsilon.js");

__webpack_require__(/*! ./modules/es6.number.is-finite */ "./node_modules/core-js/modules/es6.number.is-finite.js");

__webpack_require__(/*! ./modules/es6.number.is-integer */ "./node_modules/core-js/modules/es6.number.is-integer.js");

__webpack_require__(/*! ./modules/es6.number.is-nan */ "./node_modules/core-js/modules/es6.number.is-nan.js");

__webpack_require__(/*! ./modules/es6.number.is-safe-integer */ "./node_modules/core-js/modules/es6.number.is-safe-integer.js");

__webpack_require__(/*! ./modules/es6.number.max-safe-integer */ "./node_modules/core-js/modules/es6.number.max-safe-integer.js");

__webpack_require__(/*! ./modules/es6.number.min-safe-integer */ "./node_modules/core-js/modules/es6.number.min-safe-integer.js");

__webpack_require__(/*! ./modules/es6.number.parse-float */ "./node_modules/core-js/modules/es6.number.parse-float.js");

__webpack_require__(/*! ./modules/es6.number.parse-int */ "./node_modules/core-js/modules/es6.number.parse-int.js");

__webpack_require__(/*! ./modules/es6.math.acosh */ "./node_modules/core-js/modules/es6.math.acosh.js");

__webpack_require__(/*! ./modules/es6.math.asinh */ "./node_modules/core-js/modules/es6.math.asinh.js");

__webpack_require__(/*! ./modules/es6.math.atanh */ "./node_modules/core-js/modules/es6.math.atanh.js");

__webpack_require__(/*! ./modules/es6.math.cbrt */ "./node_modules/core-js/modules/es6.math.cbrt.js");

__webpack_require__(/*! ./modules/es6.math.clz32 */ "./node_modules/core-js/modules/es6.math.clz32.js");

__webpack_require__(/*! ./modules/es6.math.cosh */ "./node_modules/core-js/modules/es6.math.cosh.js");

__webpack_require__(/*! ./modules/es6.math.expm1 */ "./node_modules/core-js/modules/es6.math.expm1.js");

__webpack_require__(/*! ./modules/es6.math.fround */ "./node_modules/core-js/modules/es6.math.fround.js");

__webpack_require__(/*! ./modules/es6.math.hypot */ "./node_modules/core-js/modules/es6.math.hypot.js");

__webpack_require__(/*! ./modules/es6.math.imul */ "./node_modules/core-js/modules/es6.math.imul.js");

__webpack_require__(/*! ./modules/es6.math.log10 */ "./node_modules/core-js/modules/es6.math.log10.js");

__webpack_require__(/*! ./modules/es6.math.log1p */ "./node_modules/core-js/modules/es6.math.log1p.js");

__webpack_require__(/*! ./modules/es6.math.log2 */ "./node_modules/core-js/modules/es6.math.log2.js");

__webpack_require__(/*! ./modules/es6.math.sign */ "./node_modules/core-js/modules/es6.math.sign.js");

__webpack_require__(/*! ./modules/es6.math.sinh */ "./node_modules/core-js/modules/es6.math.sinh.js");

__webpack_require__(/*! ./modules/es6.math.tanh */ "./node_modules/core-js/modules/es6.math.tanh.js");

__webpack_require__(/*! ./modules/es6.math.trunc */ "./node_modules/core-js/modules/es6.math.trunc.js");

__webpack_require__(/*! ./modules/es6.string.from-code-point */ "./node_modules/core-js/modules/es6.string.from-code-point.js");

__webpack_require__(/*! ./modules/es6.string.raw */ "./node_modules/core-js/modules/es6.string.raw.js");

__webpack_require__(/*! ./modules/es6.string.trim */ "./node_modules/core-js/modules/es6.string.trim.js");

__webpack_require__(/*! ./modules/es6.string.iterator */ "./node_modules/core-js/modules/es6.string.iterator.js");

__webpack_require__(/*! ./modules/es6.string.code-point-at */ "./node_modules/core-js/modules/es6.string.code-point-at.js");

__webpack_require__(/*! ./modules/es6.string.ends-with */ "./node_modules/core-js/modules/es6.string.ends-with.js");

__webpack_require__(/*! ./modules/es6.string.includes */ "./node_modules/core-js/modules/es6.string.includes.js");

__webpack_require__(/*! ./modules/es6.string.repeat */ "./node_modules/core-js/modules/es6.string.repeat.js");

__webpack_require__(/*! ./modules/es6.string.starts-with */ "./node_modules/core-js/modules/es6.string.starts-with.js");

__webpack_require__(/*! ./modules/es6.string.anchor */ "./node_modules/core-js/modules/es6.string.anchor.js");

__webpack_require__(/*! ./modules/es6.string.big */ "./node_modules/core-js/modules/es6.string.big.js");

__webpack_require__(/*! ./modules/es6.string.blink */ "./node_modules/core-js/modules/es6.string.blink.js");

__webpack_require__(/*! ./modules/es6.string.bold */ "./node_modules/core-js/modules/es6.string.bold.js");

__webpack_require__(/*! ./modules/es6.string.fixed */ "./node_modules/core-js/modules/es6.string.fixed.js");

__webpack_require__(/*! ./modules/es6.string.fontcolor */ "./node_modules/core-js/modules/es6.string.fontcolor.js");

__webpack_require__(/*! ./modules/es6.string.fontsize */ "./node_modules/core-js/modules/es6.string.fontsize.js");

__webpack_require__(/*! ./modules/es6.string.italics */ "./node_modules/core-js/modules/es6.string.italics.js");

__webpack_require__(/*! ./modules/es6.string.link */ "./node_modules/core-js/modules/es6.string.link.js");

__webpack_require__(/*! ./modules/es6.string.small */ "./node_modules/core-js/modules/es6.string.small.js");

__webpack_require__(/*! ./modules/es6.string.strike */ "./node_modules/core-js/modules/es6.string.strike.js");

__webpack_require__(/*! ./modules/es6.string.sub */ "./node_modules/core-js/modules/es6.string.sub.js");

__webpack_require__(/*! ./modules/es6.string.sup */ "./node_modules/core-js/modules/es6.string.sup.js");

__webpack_require__(/*! ./modules/es6.date.now */ "./node_modules/core-js/modules/es6.date.now.js");

__webpack_require__(/*! ./modules/es6.date.to-json */ "./node_modules/core-js/modules/es6.date.to-json.js");

__webpack_require__(/*! ./modules/es6.date.to-iso-string */ "./node_modules/core-js/modules/es6.date.to-iso-string.js");

__webpack_require__(/*! ./modules/es6.date.to-string */ "./node_modules/core-js/modules/es6.date.to-string.js");

__webpack_require__(/*! ./modules/es6.date.to-primitive */ "./node_modules/core-js/modules/es6.date.to-primitive.js");

__webpack_require__(/*! ./modules/es6.array.is-array */ "./node_modules/core-js/modules/es6.array.is-array.js");

__webpack_require__(/*! ./modules/es6.array.from */ "./node_modules/core-js/modules/es6.array.from.js");

__webpack_require__(/*! ./modules/es6.array.of */ "./node_modules/core-js/modules/es6.array.of.js");

__webpack_require__(/*! ./modules/es6.array.join */ "./node_modules/core-js/modules/es6.array.join.js");

__webpack_require__(/*! ./modules/es6.array.slice */ "./node_modules/core-js/modules/es6.array.slice.js");

__webpack_require__(/*! ./modules/es6.array.sort */ "./node_modules/core-js/modules/es6.array.sort.js");

__webpack_require__(/*! ./modules/es6.array.for-each */ "./node_modules/core-js/modules/es6.array.for-each.js");

__webpack_require__(/*! ./modules/es6.array.map */ "./node_modules/core-js/modules/es6.array.map.js");

__webpack_require__(/*! ./modules/es6.array.filter */ "./node_modules/core-js/modules/es6.array.filter.js");

__webpack_require__(/*! ./modules/es6.array.some */ "./node_modules/core-js/modules/es6.array.some.js");

__webpack_require__(/*! ./modules/es6.array.every */ "./node_modules/core-js/modules/es6.array.every.js");

__webpack_require__(/*! ./modules/es6.array.reduce */ "./node_modules/core-js/modules/es6.array.reduce.js");

__webpack_require__(/*! ./modules/es6.array.reduce-right */ "./node_modules/core-js/modules/es6.array.reduce-right.js");

__webpack_require__(/*! ./modules/es6.array.index-of */ "./node_modules/core-js/modules/es6.array.index-of.js");

__webpack_require__(/*! ./modules/es6.array.last-index-of */ "./node_modules/core-js/modules/es6.array.last-index-of.js");

__webpack_require__(/*! ./modules/es6.array.copy-within */ "./node_modules/core-js/modules/es6.array.copy-within.js");

__webpack_require__(/*! ./modules/es6.array.fill */ "./node_modules/core-js/modules/es6.array.fill.js");

__webpack_require__(/*! ./modules/es6.array.find */ "./node_modules/core-js/modules/es6.array.find.js");

__webpack_require__(/*! ./modules/es6.array.find-index */ "./node_modules/core-js/modules/es6.array.find-index.js");

__webpack_require__(/*! ./modules/es6.array.species */ "./node_modules/core-js/modules/es6.array.species.js");

__webpack_require__(/*! ./modules/es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");

__webpack_require__(/*! ./modules/es6.regexp.constructor */ "./node_modules/core-js/modules/es6.regexp.constructor.js");

__webpack_require__(/*! ./modules/es6.regexp.exec */ "./node_modules/core-js/modules/es6.regexp.exec.js");

__webpack_require__(/*! ./modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");

__webpack_require__(/*! ./modules/es6.regexp.flags */ "./node_modules/core-js/modules/es6.regexp.flags.js");

__webpack_require__(/*! ./modules/es6.regexp.match */ "./node_modules/core-js/modules/es6.regexp.match.js");

__webpack_require__(/*! ./modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");

__webpack_require__(/*! ./modules/es6.regexp.search */ "./node_modules/core-js/modules/es6.regexp.search.js");

__webpack_require__(/*! ./modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");

__webpack_require__(/*! ./modules/es6.promise */ "./node_modules/core-js/modules/es6.promise.js");

__webpack_require__(/*! ./modules/es6.map */ "./node_modules/core-js/modules/es6.map.js");

__webpack_require__(/*! ./modules/es6.set */ "./node_modules/core-js/modules/es6.set.js");

__webpack_require__(/*! ./modules/es6.weak-map */ "./node_modules/core-js/modules/es6.weak-map.js");

__webpack_require__(/*! ./modules/es6.weak-set */ "./node_modules/core-js/modules/es6.weak-set.js");

__webpack_require__(/*! ./modules/es6.typed.array-buffer */ "./node_modules/core-js/modules/es6.typed.array-buffer.js");

__webpack_require__(/*! ./modules/es6.typed.data-view */ "./node_modules/core-js/modules/es6.typed.data-view.js");

__webpack_require__(/*! ./modules/es6.typed.int8-array */ "./node_modules/core-js/modules/es6.typed.int8-array.js");

__webpack_require__(/*! ./modules/es6.typed.uint8-array */ "./node_modules/core-js/modules/es6.typed.uint8-array.js");

__webpack_require__(/*! ./modules/es6.typed.uint8-clamped-array */ "./node_modules/core-js/modules/es6.typed.uint8-clamped-array.js");

__webpack_require__(/*! ./modules/es6.typed.int16-array */ "./node_modules/core-js/modules/es6.typed.int16-array.js");

__webpack_require__(/*! ./modules/es6.typed.uint16-array */ "./node_modules/core-js/modules/es6.typed.uint16-array.js");

__webpack_require__(/*! ./modules/es6.typed.int32-array */ "./node_modules/core-js/modules/es6.typed.int32-array.js");

__webpack_require__(/*! ./modules/es6.typed.uint32-array */ "./node_modules/core-js/modules/es6.typed.uint32-array.js");

__webpack_require__(/*! ./modules/es6.typed.float32-array */ "./node_modules/core-js/modules/es6.typed.float32-array.js");

__webpack_require__(/*! ./modules/es6.typed.float64-array */ "./node_modules/core-js/modules/es6.typed.float64-array.js");

__webpack_require__(/*! ./modules/es6.reflect.apply */ "./node_modules/core-js/modules/es6.reflect.apply.js");

__webpack_require__(/*! ./modules/es6.reflect.construct */ "./node_modules/core-js/modules/es6.reflect.construct.js");

__webpack_require__(/*! ./modules/es6.reflect.define-property */ "./node_modules/core-js/modules/es6.reflect.define-property.js");

__webpack_require__(/*! ./modules/es6.reflect.delete-property */ "./node_modules/core-js/modules/es6.reflect.delete-property.js");

__webpack_require__(/*! ./modules/es6.reflect.enumerate */ "./node_modules/core-js/modules/es6.reflect.enumerate.js");

__webpack_require__(/*! ./modules/es6.reflect.get */ "./node_modules/core-js/modules/es6.reflect.get.js");

__webpack_require__(/*! ./modules/es6.reflect.get-own-property-descriptor */ "./node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js");

__webpack_require__(/*! ./modules/es6.reflect.get-prototype-of */ "./node_modules/core-js/modules/es6.reflect.get-prototype-of.js");

__webpack_require__(/*! ./modules/es6.reflect.has */ "./node_modules/core-js/modules/es6.reflect.has.js");

__webpack_require__(/*! ./modules/es6.reflect.is-extensible */ "./node_modules/core-js/modules/es6.reflect.is-extensible.js");

__webpack_require__(/*! ./modules/es6.reflect.own-keys */ "./node_modules/core-js/modules/es6.reflect.own-keys.js");

__webpack_require__(/*! ./modules/es6.reflect.prevent-extensions */ "./node_modules/core-js/modules/es6.reflect.prevent-extensions.js");

__webpack_require__(/*! ./modules/es6.reflect.set */ "./node_modules/core-js/modules/es6.reflect.set.js");

__webpack_require__(/*! ./modules/es6.reflect.set-prototype-of */ "./node_modules/core-js/modules/es6.reflect.set-prototype-of.js");

__webpack_require__(/*! ./modules/es7.array.includes */ "./node_modules/core-js/modules/es7.array.includes.js");

__webpack_require__(/*! ./modules/es7.array.flat-map */ "./node_modules/core-js/modules/es7.array.flat-map.js");

__webpack_require__(/*! ./modules/es7.array.flatten */ "./node_modules/core-js/modules/es7.array.flatten.js");

__webpack_require__(/*! ./modules/es7.string.at */ "./node_modules/core-js/modules/es7.string.at.js");

__webpack_require__(/*! ./modules/es7.string.pad-start */ "./node_modules/core-js/modules/es7.string.pad-start.js");

__webpack_require__(/*! ./modules/es7.string.pad-end */ "./node_modules/core-js/modules/es7.string.pad-end.js");

__webpack_require__(/*! ./modules/es7.string.trim-left */ "./node_modules/core-js/modules/es7.string.trim-left.js");

__webpack_require__(/*! ./modules/es7.string.trim-right */ "./node_modules/core-js/modules/es7.string.trim-right.js");

__webpack_require__(/*! ./modules/es7.string.match-all */ "./node_modules/core-js/modules/es7.string.match-all.js");

__webpack_require__(/*! ./modules/es7.symbol.async-iterator */ "./node_modules/core-js/modules/es7.symbol.async-iterator.js");

__webpack_require__(/*! ./modules/es7.symbol.observable */ "./node_modules/core-js/modules/es7.symbol.observable.js");

__webpack_require__(/*! ./modules/es7.object.get-own-property-descriptors */ "./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js");

__webpack_require__(/*! ./modules/es7.object.values */ "./node_modules/core-js/modules/es7.object.values.js");

__webpack_require__(/*! ./modules/es7.object.entries */ "./node_modules/core-js/modules/es7.object.entries.js");

__webpack_require__(/*! ./modules/es7.object.define-getter */ "./node_modules/core-js/modules/es7.object.define-getter.js");

__webpack_require__(/*! ./modules/es7.object.define-setter */ "./node_modules/core-js/modules/es7.object.define-setter.js");

__webpack_require__(/*! ./modules/es7.object.lookup-getter */ "./node_modules/core-js/modules/es7.object.lookup-getter.js");

__webpack_require__(/*! ./modules/es7.object.lookup-setter */ "./node_modules/core-js/modules/es7.object.lookup-setter.js");

__webpack_require__(/*! ./modules/es7.map.to-json */ "./node_modules/core-js/modules/es7.map.to-json.js");

__webpack_require__(/*! ./modules/es7.set.to-json */ "./node_modules/core-js/modules/es7.set.to-json.js");

__webpack_require__(/*! ./modules/es7.map.of */ "./node_modules/core-js/modules/es7.map.of.js");

__webpack_require__(/*! ./modules/es7.set.of */ "./node_modules/core-js/modules/es7.set.of.js");

__webpack_require__(/*! ./modules/es7.weak-map.of */ "./node_modules/core-js/modules/es7.weak-map.of.js");

__webpack_require__(/*! ./modules/es7.weak-set.of */ "./node_modules/core-js/modules/es7.weak-set.of.js");

__webpack_require__(/*! ./modules/es7.map.from */ "./node_modules/core-js/modules/es7.map.from.js");

__webpack_require__(/*! ./modules/es7.set.from */ "./node_modules/core-js/modules/es7.set.from.js");

__webpack_require__(/*! ./modules/es7.weak-map.from */ "./node_modules/core-js/modules/es7.weak-map.from.js");

__webpack_require__(/*! ./modules/es7.weak-set.from */ "./node_modules/core-js/modules/es7.weak-set.from.js");

__webpack_require__(/*! ./modules/es7.global */ "./node_modules/core-js/modules/es7.global.js");

__webpack_require__(/*! ./modules/es7.system.global */ "./node_modules/core-js/modules/es7.system.global.js");

__webpack_require__(/*! ./modules/es7.error.is-error */ "./node_modules/core-js/modules/es7.error.is-error.js");

__webpack_require__(/*! ./modules/es7.math.clamp */ "./node_modules/core-js/modules/es7.math.clamp.js");

__webpack_require__(/*! ./modules/es7.math.deg-per-rad */ "./node_modules/core-js/modules/es7.math.deg-per-rad.js");

__webpack_require__(/*! ./modules/es7.math.degrees */ "./node_modules/core-js/modules/es7.math.degrees.js");

__webpack_require__(/*! ./modules/es7.math.fscale */ "./node_modules/core-js/modules/es7.math.fscale.js");

__webpack_require__(/*! ./modules/es7.math.iaddh */ "./node_modules/core-js/modules/es7.math.iaddh.js");

__webpack_require__(/*! ./modules/es7.math.isubh */ "./node_modules/core-js/modules/es7.math.isubh.js");

__webpack_require__(/*! ./modules/es7.math.imulh */ "./node_modules/core-js/modules/es7.math.imulh.js");

__webpack_require__(/*! ./modules/es7.math.rad-per-deg */ "./node_modules/core-js/modules/es7.math.rad-per-deg.js");

__webpack_require__(/*! ./modules/es7.math.radians */ "./node_modules/core-js/modules/es7.math.radians.js");

__webpack_require__(/*! ./modules/es7.math.scale */ "./node_modules/core-js/modules/es7.math.scale.js");

__webpack_require__(/*! ./modules/es7.math.umulh */ "./node_modules/core-js/modules/es7.math.umulh.js");

__webpack_require__(/*! ./modules/es7.math.signbit */ "./node_modules/core-js/modules/es7.math.signbit.js");

__webpack_require__(/*! ./modules/es7.promise.finally */ "./node_modules/core-js/modules/es7.promise.finally.js");

__webpack_require__(/*! ./modules/es7.promise.try */ "./node_modules/core-js/modules/es7.promise.try.js");

__webpack_require__(/*! ./modules/es7.reflect.define-metadata */ "./node_modules/core-js/modules/es7.reflect.define-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.delete-metadata */ "./node_modules/core-js/modules/es7.reflect.delete-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.get-metadata */ "./node_modules/core-js/modules/es7.reflect.get-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.get-metadata-keys */ "./node_modules/core-js/modules/es7.reflect.get-metadata-keys.js");

__webpack_require__(/*! ./modules/es7.reflect.get-own-metadata */ "./node_modules/core-js/modules/es7.reflect.get-own-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.get-own-metadata-keys */ "./node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js");

__webpack_require__(/*! ./modules/es7.reflect.has-metadata */ "./node_modules/core-js/modules/es7.reflect.has-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.has-own-metadata */ "./node_modules/core-js/modules/es7.reflect.has-own-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.metadata */ "./node_modules/core-js/modules/es7.reflect.metadata.js");

__webpack_require__(/*! ./modules/es7.asap */ "./node_modules/core-js/modules/es7.asap.js");

__webpack_require__(/*! ./modules/es7.observable */ "./node_modules/core-js/modules/es7.observable.js");

__webpack_require__(/*! ./modules/web.timers */ "./node_modules/core-js/modules/web.timers.js");

__webpack_require__(/*! ./modules/web.immediate */ "./node_modules/core-js/modules/web.immediate.js");

__webpack_require__(/*! ./modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");

module.exports = __webpack_require__(/*! ./modules/_core */ "./node_modules/core-js/modules/_core.js");

/***/ }),

/***/ "./node_modules/highcharts/highcharts.js":
/*!***********************************************!*\
  !*** ./node_modules/highcharts/highcharts.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 Highcharts JS v8.0.4 (2020-03-10)

 (c) 2009-2018 Torstein Honsi

 License: www.highcharts.com/license
*/
(function (aa, S) {
   true && module.exports ? (S["default"] = S, module.exports = aa.document ? S(aa) : S) :  true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    return S(aa);
  }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
})("undefined" !== typeof window ? window : this, function (aa) {
  function S(d, g, W, u) {
    d.hasOwnProperty(g) || (d[g] = u.apply(null, W));
  }

  var r = {};
  S(r, "parts/Globals.js", [], function () {
    var d = "undefined" !== typeof aa ? aa : "undefined" !== typeof window ? window : {},
        g = d.document,
        W = d.navigator && d.navigator.userAgent || "",
        u = g && g.createElementNS && !!g.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect,
        r = /(edge|msie|trident)/i.test(W) && !d.opera,
        M = -1 !== W.indexOf("Firefox"),
        E = -1 !== W.indexOf("Chrome"),
        A = M && 4 > parseInt(W.split("Firefox/")[1], 10);
    return {
      product: "Highcharts",
      version: "8.0.4",
      deg2rad: 2 * Math.PI / 360,
      doc: g,
      hasBidiBug: A,
      hasTouch: !!d.TouchEvent,
      isMS: r,
      isWebKit: -1 !== W.indexOf("AppleWebKit"),
      isFirefox: M,
      isChrome: E,
      isSafari: !E && -1 !== W.indexOf("Safari"),
      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(W),
      SVG_NS: "http://www.w3.org/2000/svg",
      chartCount: 0,
      seriesTypes: {},
      symbolSizes: {},
      svg: u,
      win: d,
      marginNames: ["plotTop", "marginRight", "marginBottom", "plotLeft"],
      noop: function () {},
      charts: [],
      dateFormats: {}
    };
  });
  S(r, "parts/Utilities.js", [r["parts/Globals.js"]], function (d) {
    function g() {
      var b,
          a = arguments,
          m = {},
          f = function (b, a) {
        "object" !== typeof b && (b = {});
        Y(a, function (m, c) {
          !h(m, !0) || q(m) || N(m) ? b[c] = a[c] : b[c] = f(b[c] || {}, m);
        });
        return b;
      };

      !0 === a[0] && (m = a[1], a = Array.prototype.slice.call(a, 2));
      var c = a.length;

      for (b = 0; b < c; b++) m = f(m, a[b]);

      return m;
    }

    function W(b, a, m) {
      var f;
      t(a) ? c(m) ? b.setAttribute(a, m) : b && b.getAttribute && ((f = b.getAttribute(a)) || "class" !== a || (f = b.getAttribute(a + "Name"))) : Y(a, function (a, m) {
        b.setAttribute(m, a);
      });
      return f;
    }

    function u() {
      for (var b = arguments, a = b.length, m = 0; m < a; m++) {
        var f = b[m];
        if ("undefined" !== typeof f && null !== f) return f;
      }
    }

    function r(b, a) {
      if (!b) return a;
      var m = b.split(".").reverse();
      if (1 === m.length) return a[b];

      for (b = m.pop(); "undefined" !== typeof b && "undefined" !== typeof a && null !== a;) a = a[b], b = m.pop();

      return a;
    }

    d.timers = [];

    var M = d.charts,
        E = d.doc,
        A = d.win,
        G = d.error = function (b, a, m, f) {
      var c = P(b),
          p = c ? "Highcharts error #" + b + ": www.highcharts.com/errors/" + b + "/" : b.toString(),
          e = function () {
        if (a) throw Error(p);
        A.console && console.log(p);
      };

      if ("undefined" !== typeof f) {
        var x = "";
        c && (p += "?");
        d.objectEach(f, function (b, a) {
          x += "\n" + a + ": " + b;
          c && (p += encodeURI(a) + "=" + encodeURI(b));
        });
        p += x;
      }

      m ? d.fireEvent(m, "displayError", {
        code: b,
        message: p,
        params: f
      }, e) : e();
    },
        J = function () {
      function b(b, a, m) {
        this.options = a;
        this.elem = b;
        this.prop = m;
      }

      b.prototype.dSetter = function () {
        var b = this.paths[0],
            a = this.paths[1],
            m = [],
            f = this.now,
            c = b.length;
        if (1 === f) m = this.toD;else if (c === a.length && 1 > f) for (; c--;) {
          var p = parseFloat(b[c]);
          m[c] = isNaN(p) || "A" === a[c - 4] || "A" === a[c - 5] ? a[c] : f * parseFloat("" + (a[c] - p)) + p;
        } else m = a;
        this.elem.attr("d", m, null, !0);
      };

      b.prototype.update = function () {
        var b = this.elem,
            a = this.prop,
            m = this.now,
            f = this.options.step;
        if (this[a + "Setter"]) this[a + "Setter"]();else b.attr ? b.element && b.attr(a, m, null, !0) : b.style[a] = m + this.unit;
        f && f.call(b, m, this);
      };

      b.prototype.run = function (b, a, m) {
        var f = this,
            c = f.options,
            p = function (b) {
          return p.stopped ? !1 : f.step(b);
        },
            e = A.requestAnimationFrame || function (b) {
          setTimeout(b, 13);
        },
            x = function () {
          for (var b = 0; b < d.timers.length; b++) d.timers[b]() || d.timers.splice(b--, 1);

          d.timers.length && e(x);
        };

        b !== a || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = b, this.end = a, this.unit = m, this.now = this.start, this.pos = 0, p.elem = this.elem, p.prop = this.prop, p() && 1 === d.timers.push(p) && e(x)) : (delete c.curAnim[this.prop], c.complete && 0 === Object.keys(c.curAnim).length && c.complete.call(this.elem));
      };

      b.prototype.step = function (b) {
        var a = +new Date(),
            m = this.options,
            f = this.elem,
            c = m.complete,
            p = m.duration,
            e = m.curAnim;
        if (f.attr && !f.element) b = !1;else if (b || a >= p + this.startTime) {
          this.now = this.end;
          this.pos = 1;
          this.update();
          var x = e[this.prop] = !0;
          Y(e, function (b) {
            !0 !== b && (x = !1);
          });
          x && c && c.call(f);
          b = !1;
        } else this.pos = m.easing((a - this.startTime) / p), this.now = this.start + (this.end - this.start) * this.pos, this.update(), b = !0;
        return b;
      };

      b.prototype.initPath = function (b, a, m) {
        function f(b) {
          for (C = b.length; C--;) {
            var a = "M" === b[C] || "L" === b[C];
            var m = /[a-zA-Z]/.test(b[C + 3]);
            a && m && b.splice(C + 1, 0, b[C + 1], b[C + 2], b[C + 1], b[C + 2]);
          }
        }

        function c(b, a) {
          for (; b.length < v;) {
            b[0] = a[v - b.length];
            var m = b.slice(0, T);
            [].splice.apply(b, [0, 0].concat(m));
            k && (m = b.slice(b.length - T), [].splice.apply(b, [b.length, 0].concat(m)), C--);
          }

          b[0] = "M";
        }

        function p(b, a) {
          for (var m = (v - b.length) / T; 0 < m && m--;) l = b.slice().splice(b.length / n - T, T * n), l[0] = a[v - T - m * T], F && (l[T - 6] = l[T - 2], l[T - 5] = l[T - 1]), [].splice.apply(b, [b.length / n, 0].concat(l)), k && m--;
        }

        a = a || "";
        var e = b.startX,
            x = b.endX,
            F = -1 < a.indexOf("C"),
            T = F ? 7 : 3,
            l,
            C;
        a = a.split(" ");
        m = m.slice();
        var k = b.isArea,
            n = k ? 2 : 1;
        F && (f(a), f(m));

        if (e && x) {
          for (C = 0; C < e.length; C++) if (e[C] === x[0]) {
            var V = C;
            break;
          } else if (e[0] === x[x.length - e.length + C]) {
            V = C;
            var w = !0;
            break;
          } else if (e[e.length - 1] === x[x.length - e.length + C]) {
            V = e.length - C;
            break;
          }

          "undefined" === typeof V && (a = []);
        }

        if (a.length && P(V)) {
          var v = m.length + V * n * T;
          w ? (c(a, m), p(m, a)) : (c(m, a), p(a, m));
        }

        return [a, m];
      };

      b.prototype.fillSetter = function () {
        d.Fx.prototype.strokeSetter.apply(this, arguments);
      };

      b.prototype.strokeSetter = function () {
        this.elem.attr(this.prop, d.color(this.start).tweenTo(d.color(this.end), this.pos), null, !0);
      };

      return b;
    }();

    d.Fx = J;
    d.merge = g;

    var y = d.pInt = function (b, a) {
      return parseInt(b, a || 10);
    },
        t = d.isString = function (b) {
      return "string" === typeof b;
    },
        D = d.isArray = function (b) {
      b = Object.prototype.toString.call(b);
      return "[object Array]" === b || "[object Array Iterator]" === b;
    },
        h = d.isObject = function (b, a) {
      return !!b && "object" === typeof b && (!a || !D(b));
    },
        N = d.isDOMElement = function (b) {
      return h(b) && "number" === typeof b.nodeType;
    },
        q = d.isClass = function (b) {
      var a = b && b.constructor;
      return !(!h(b, !0) || N(b) || !a || !a.name || "Object" === a.name);
    },
        P = d.isNumber = function (b) {
      return "number" === typeof b && !isNaN(b) && Infinity > b && -Infinity < b;
    },
        e = d.erase = function (b, a) {
      for (var m = b.length; m--;) if (b[m] === a) {
        b.splice(m, 1);
        break;
      }
    },
        c = d.defined = function (b) {
      return "undefined" !== typeof b && null !== b;
    };

    d.attr = W;

    var k = d.splat = function (b) {
      return D(b) ? b : [b];
    },
        n = d.syncTimeout = function (b, a, m) {
      if (0 < a) return setTimeout(b, a, m);
      b.call(0, m);
      return -1;
    },
        f = d.clearTimeout = function (b) {
      c(b) && clearTimeout(b);
    },
        a = d.extend = function (b, a) {
      var m;
      b || (b = {});

      for (m in a) b[m] = a[m];

      return b;
    };

    d.pick = u;

    var l = d.css = function (b, m) {
      d.isMS && !d.svg && m && "undefined" !== typeof m.opacity && (m.filter = "alpha(opacity=" + 100 * m.opacity + ")");
      a(b.style, m);
    },
        v = d.createElement = function (b, m, f, c, p) {
      b = E.createElement(b);
      m && a(b, m);
      p && l(b, {
        padding: "0",
        border: "none",
        margin: "0"
      });
      f && l(b, f);
      c && c.appendChild(b);
      return b;
    },
        z = d.extendClass = function (b, m) {
      var f = function () {};

      f.prototype = new b();
      a(f.prototype, m);
      return f;
    },
        w = d.pad = function (b, a, m) {
      return Array((a || 2) + 1 - String(b).replace("-", "").length).join(m || "0") + b;
    },
        B = d.relativeLength = function (b, a, m) {
      return /%$/.test(b) ? a * parseFloat(b) / 100 + (m || 0) : parseFloat(b);
    },
        L = d.wrap = function (b, a, m) {
      var f = b[a];

      b[a] = function () {
        var b = Array.prototype.slice.call(arguments),
            a = arguments,
            c = this;

        c.proceed = function () {
          f.apply(c, arguments.length ? arguments : a);
        };

        b.unshift(f);
        b = m.apply(this, b);
        c.proceed = null;
        return b;
      };
    },
        Q = d.format = function (b, a, m) {
      var f = "{",
          c = !1,
          p = [],
          e = /f$/,
          x = /\.([0-9])/,
          F = d.defaultOptions.lang,
          C = m && m.time || d.time;

      for (m = m && m.numberFormatter || T; b;) {
        var l = b.indexOf(f);
        if (-1 === l) break;
        var k = b.slice(0, l);

        if (c) {
          k = k.split(":");
          f = r(k.shift() || "", a);
          if (k.length && "number" === typeof f) if (k = k.join(":"), e.test(k)) {
            var n = parseInt((k.match(x) || ["", "-1"])[1], 10);
            null !== f && (f = m(f, n, F.decimalPoint, -1 < k.indexOf(",") ? F.thousandsSep : ""));
          } else f = C.dateFormat(k, f);
          p.push(f);
        } else p.push(k);

        b = b.slice(l + 1);
        f = (c = !c) ? "}" : "{";
      }

      p.push(b);
      return p.join("");
    },
        H = d.getMagnitude = function (b) {
      return Math.pow(10, Math.floor(Math.log(b) / Math.LN10));
    },
        K = d.normalizeTickInterval = function (b, a, m, f, c) {
      var p = b;
      m = u(m, 1);
      var e = b / m;
      a || (a = c ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === f && (1 === m ? a = a.filter(function (b) {
        return 0 === b % 1;
      }) : .1 >= m && (a = [1 / m])));

      for (f = 0; f < a.length && !(p = a[f], c && p * m >= b || !c && e <= (a[f] + (a[f + 1] || a[f])) / 2); f++);

      return p = O(p * m, -Math.round(Math.log(.001) / Math.LN10));
    },
        p = d.stableSort = function (b, a) {
      var m = b.length,
          f,
          c;

      for (c = 0; c < m; c++) b[c].safeI = c;

      b.sort(function (b, m) {
        f = a(b, m);
        return 0 === f ? b.safeI - m.safeI : f;
      });

      for (c = 0; c < m; c++) delete b[c].safeI;
    },
        b = d.arrayMin = function (b) {
      for (var a = b.length, m = b[0]; a--;) b[a] < m && (m = b[a]);

      return m;
    },
        C = d.arrayMax = function (b) {
      for (var a = b.length, m = b[0]; a--;) b[a] > m && (m = b[a]);

      return m;
    },
        x = d.destroyObjectProperties = function (b, a) {
      Y(b, function (m, f) {
        m && m !== a && m.destroy && m.destroy();
        delete b[f];
      });
    },
        R = d.discardElement = function (b) {
      var a = d.garbageBin;
      a || (a = v("div"));
      b && a.appendChild(b);
      a.innerHTML = "";
    },
        O = d.correctFloat = function (b, a) {
      return parseFloat(b.toPrecision(a || 14));
    },
        X = d.setAnimation = function (b, a) {
      a.renderer.globalAnimation = u(b, a.options.chart.animation, !0);
    },
        U = d.animObject = function (b) {
      return h(b) ? g(b) : {
        duration: b ? 500 : 0
      };
    },
        m = d.timeUnits = {
      millisecond: 1,
      second: 1E3,
      minute: 6E4,
      hour: 36E5,
      day: 864E5,
      week: 6048E5,
      month: 24192E5,
      year: 314496E5
    },
        T = d.numberFormat = function (b, a, m, f) {
      b = +b || 0;
      a = +a;
      var c = d.defaultOptions.lang,
          p = (b.toString().split(".")[1] || "").split("e")[0].length,
          e = b.toString().split("e");
      if (-1 === a) a = Math.min(p, 20);else if (!P(a)) a = 2;else if (a && e[1] && 0 > e[1]) {
        var x = a + +e[1];
        0 <= x ? (e[0] = (+e[0]).toExponential(x).split("e")[0], a = x) : (e[0] = e[0].split(".")[0] || 0, b = 20 > a ? (e[0] * Math.pow(10, e[1])).toFixed(a) : 0, e[1] = 0);
      }
      var F = (Math.abs(e[1] ? e[0] : b) + Math.pow(10, -Math.max(a, p) - 1)).toFixed(a);
      p = String(y(F));
      x = 3 < p.length ? p.length % 3 : 0;
      m = u(m, c.decimalPoint);
      f = u(f, c.thousandsSep);
      b = (0 > b ? "-" : "") + (x ? p.substr(0, x) + f : "");
      b += p.substr(x).replace(/(\d{3})(?=\d)/g, "$1" + f);
      a && (b += m + F.slice(-a));
      e[1] && 0 !== +b && (b += "e" + e[1]);
      return b;
    };

    Math.easeInOutSine = function (b) {
      return -.5 * (Math.cos(Math.PI * b) - 1);
    };

    var Z = d.getStyle = function (b, a, m) {
      if ("width" === a) return a = Math.min(b.offsetWidth, b.scrollWidth), m = b.getBoundingClientRect && b.getBoundingClientRect().width, m < a && m >= a - 1 && (a = Math.floor(m)), Math.max(0, a - d.getStyle(b, "padding-left") - d.getStyle(b, "padding-right"));
      if ("height" === a) return Math.max(0, Math.min(b.offsetHeight, b.scrollHeight) - d.getStyle(b, "padding-top") - d.getStyle(b, "padding-bottom"));
      A.getComputedStyle || G(27, !0);
      if (b = A.getComputedStyle(b, void 0)) b = b.getPropertyValue(a), u(m, "opacity" !== a) && (b = y(b));
      return b;
    },
        ca = d.inArray = function (b, a, m) {
      return a.indexOf(b, m);
    },
        F = d.find = Array.prototype.find ? function (b, a) {
      return b.find(a);
    } : function (b, a) {
      var m,
          f = b.length;

      for (m = 0; m < f; m++) if (a(b[m], m)) return b[m];
    };

    d.keys = Object.keys;

    var V = d.offset = function (b) {
      var a = E.documentElement;
      b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {
        top: 0,
        left: 0
      };
      return {
        top: b.top + (A.pageYOffset || a.scrollTop) - (a.clientTop || 0),
        left: b.left + (A.pageXOffset || a.scrollLeft) - (a.clientLeft || 0)
      };
    },
        ba = d.stop = function (b, a) {
      for (var m = d.timers.length; m--;) d.timers[m].elem !== b || a && a !== d.timers[m].prop || (d.timers[m].stopped = !0);
    },
        Y = d.objectEach = function (b, a, m) {
      for (var f in b) Object.hasOwnProperty.call(b, f) && a.call(m || b[f], b[f], f, b);
    };

    Y({
      map: "map",
      each: "forEach",
      grep: "filter",
      reduce: "reduce",
      some: "some"
    }, function (b, a) {
      d[a] = function (a) {
        return Array.prototype[b].apply(a, [].slice.call(arguments, 1));
      };
    });

    var fa = d.addEvent = function (b, a, m, f) {
      void 0 === f && (f = {});
      var c = b.addEventListener || d.addEventListenerPolyfill;
      var p = "function" === typeof b && b.prototype ? b.prototype.protoEvents = b.prototype.protoEvents || {} : b.hcEvents = b.hcEvents || {};
      d.Point && b instanceof d.Point && b.series && b.series.chart && (b.series.chart.runTrackerClick = !0);
      c && c.call(b, a, m, !1);
      p[a] || (p[a] = []);
      p[a].push({
        fn: m,
        order: "number" === typeof f.order ? f.order : Infinity
      });
      p[a].sort(function (b, a) {
        return b.order - a.order;
      });
      return function () {
        da(b, a, m);
      };
    },
        da = d.removeEvent = function (b, a, m) {
      function f(a, m) {
        var f = b.removeEventListener || d.removeEventListenerPolyfill;
        f && f.call(b, a, m, !1);
      }

      function c(m) {
        var c;

        if (b.nodeName) {
          if (a) {
            var p = {};
            p[a] = !0;
          } else p = m;

          Y(p, function (b, a) {
            if (m[a]) for (c = m[a].length; c--;) f(a, m[a][c].fn);
          });
        }
      }

      var p;
      ["protoEvents", "hcEvents"].forEach(function (e, x) {
        var F = (x = x ? b : b.prototype) && x[e];
        F && (a ? (p = F[a] || [], m ? (F[a] = p.filter(function (b) {
          return m !== b.fn;
        }), f(a, m)) : (c(F), F[a] = [])) : (c(F), x[e] = {}));
      });
    },
        ha = d.fireEvent = function (b, m, f, c) {
      var p;
      f = f || {};

      if (E.createEvent && (b.dispatchEvent || b.fireEvent)) {
        var e = E.createEvent("Events");
        e.initEvent(m, !0, !0);
        a(e, f);
        b.dispatchEvent ? b.dispatchEvent(e) : b.fireEvent(m, e);
      } else f.target || a(f, {
        preventDefault: function () {
          f.defaultPrevented = !0;
        },
        target: b,
        type: m
      }), function (a, m) {
        void 0 === a && (a = []);
        void 0 === m && (m = []);
        var c = 0,
            e = 0,
            x = a.length + m.length;

        for (p = 0; p < x; p++) !1 === (a[c] ? m[e] ? a[c].order <= m[e].order ? a[c++] : m[e++] : a[c++] : m[e++]).fn.call(b, f) && f.preventDefault();
      }(b.protoEvents && b.protoEvents[m], b.hcEvents && b.hcEvents[m]);

      c && !f.defaultPrevented && c.call(b, f);
    },
        ia = d.animate = function (b, a, m) {
      var f,
          c = "",
          p,
          e;

      if (!h(m)) {
        var x = arguments;
        m = {
          duration: x[2],
          easing: x[3],
          complete: x[4]
        };
      }

      P(m.duration) || (m.duration = 400);
      m.easing = "function" === typeof m.easing ? m.easing : Math[m.easing] || Math.easeInOutSine;
      m.curAnim = g(a);
      Y(a, function (x, F) {
        ba(b, F);
        e = new J(b, m, F);
        p = null;
        "d" === F ? (e.paths = e.initPath(b, b.d, a.d), e.toD = a.d, f = 0, p = 1) : b.attr ? f = b.attr(F) : (f = parseFloat(Z(b, F)) || 0, "opacity" !== F && (c = "px"));
        p || (p = x);
        p && p.match && p.match("px") && (p = p.replace(/px/g, ""));
        e.run(f, p, c);
      });
    },
        ja = d.seriesType = function (b, a, m, f, c) {
      var p = d.getOptions(),
          e = d.seriesTypes;
      p.plotOptions[b] = g(p.plotOptions[a], m);
      e[b] = z(e[a] || function () {}, f);
      e[b].prototype.type = b;
      c && (e[b].prototype.pointClass = z(d.Point, c));
      return e[b];
    },
        ea = d.uniqueKey = function () {
      var b = Math.random().toString(36).substring(2, 9),
          a = 0;
      return function () {
        return "highcharts-" + b + "-" + a++;
      };
    }(),
        ka = d.isFunction = function (b) {
      return "function" === typeof b;
    };

    A.jQuery && (A.jQuery.fn.highcharts = function () {
      var b = [].slice.call(arguments);
      if (this[0]) return b[0] ? (new d[t(b[0]) ? b.shift() : "Chart"](this[0], b[0], b[1]), this) : M[W(this[0], "data-highcharts-chart")];
    });
    return {
      Fx: J,
      addEvent: fa,
      animate: ia,
      animObject: U,
      arrayMax: C,
      arrayMin: b,
      attr: W,
      clamp: function (b, a, m) {
        return b > a ? b < m ? b : m : a;
      },
      clearTimeout: f,
      correctFloat: O,
      createElement: v,
      css: l,
      defined: c,
      destroyObjectProperties: x,
      discardElement: R,
      erase: e,
      error: G,
      extend: a,
      extendClass: z,
      find: F,
      fireEvent: ha,
      format: Q,
      getMagnitude: H,
      getNestedProperty: r,
      getStyle: Z,
      inArray: ca,
      isArray: D,
      isClass: q,
      isDOMElement: N,
      isFunction: ka,
      isNumber: P,
      isObject: h,
      isString: t,
      merge: g,
      normalizeTickInterval: K,
      numberFormat: T,
      objectEach: Y,
      offset: V,
      pad: w,
      pick: u,
      pInt: y,
      relativeLength: B,
      removeEvent: da,
      seriesType: ja,
      setAnimation: X,
      splat: k,
      stableSort: p,
      stop: ba,
      syncTimeout: n,
      timeUnits: m,
      uniqueKey: ea,
      wrap: L
    };
  });
  S(r, "parts/Color.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var W = g.isNumber,
        u = g.merge,
        r = g.pInt;

    g = function () {
      function d(g) {
        this.parsers = [{
          regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
          parse: function (d) {
            return [r(d[1]), r(d[2]), r(d[3]), parseFloat(d[4], 10)];
          }
        }, {
          regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
          parse: function (d) {
            return [r(d[1]), r(d[2]), r(d[3]), 1];
          }
        }];
        this.rgba = [];
        if (!(this instanceof d)) return new d(g);
        this.init(g);
      }

      d.parse = function (g) {
        return new d(g);
      };

      d.prototype.init = function (g) {
        var A, G;
        if ((this.input = g = d.names[g && g.toLowerCase ? g.toLowerCase() : ""] || g) && g.stops) this.stops = g.stops.map(function (t) {
          return new d(t[1]);
        });else {
          if (g && g.charAt && "#" === g.charAt()) {
            var u = g.length;
            g = parseInt(g.substr(1), 16);
            7 === u ? A = [(g & 16711680) >> 16, (g & 65280) >> 8, g & 255, 1] : 4 === u && (A = [(g & 3840) >> 4 | (g & 3840) >> 8, (g & 240) >> 4 | g & 240, (g & 15) << 4 | g & 15, 1]);
          }

          if (!A) for (G = this.parsers.length; G-- && !A;) {
            var y = this.parsers[G];
            (u = y.regex.exec(g)) && (A = y.parse(u));
          }
        }
        this.rgba = A || [];
      };

      d.prototype.get = function (d) {
        var g = this.input,
            G = this.rgba;

        if ("undefined" !== typeof this.stops) {
          var E = u(g);
          E.stops = [].concat(E.stops);
          this.stops.forEach(function (g, t) {
            E.stops[t] = [E.stops[t][0], g.get(d)];
          });
        } else E = G && W(G[0]) ? "rgb" === d || !d && 1 === G[3] ? "rgb(" + G[0] + "," + G[1] + "," + G[2] + ")" : "a" === d ? G[3] : "rgba(" + G.join(",") + ")" : g;

        return E;
      };

      d.prototype.brighten = function (d) {
        var g,
            u = this.rgba;
        if (this.stops) this.stops.forEach(function (g) {
          g.brighten(d);
        });else if (W(d) && 0 !== d) for (g = 0; 3 > g; g++) u[g] += r(255 * d), 0 > u[g] && (u[g] = 0), 255 < u[g] && (u[g] = 255);
        return this;
      };

      d.prototype.setOpacity = function (d) {
        this.rgba[3] = d;
        return this;
      };

      d.prototype.tweenTo = function (d, g) {
        var u = this.rgba,
            A = d.rgba;
        A.length && u && u.length ? (d = 1 !== A[3] || 1 !== u[3], g = (d ? "rgba(" : "rgb(") + Math.round(A[0] + (u[0] - A[0]) * (1 - g)) + "," + Math.round(A[1] + (u[1] - A[1]) * (1 - g)) + "," + Math.round(A[2] + (u[2] - A[2]) * (1 - g)) + (d ? "," + (A[3] + (u[3] - A[3]) * (1 - g)) : "") + ")") : g = d.input || "none";
        return g;
      };

      d.names = {
        white: "#ffffff",
        black: "#000000"
      };
      return d;
    }();

    d.Color = g;
    d.color = g.parse;
    return d.Color;
  });
  S(r, "parts/SvgRenderer.js", [r["parts/Globals.js"], r["parts/Color.js"], r["parts/Utilities.js"]], function (d, g, r) {
    var u = g.parse,
        I = r.addEvent,
        M = r.animate,
        E = r.animObject,
        A = r.attr,
        G = r.createElement,
        J = r.css,
        y = r.defined,
        t = r.destroyObjectProperties,
        D = r.erase,
        h = r.extend,
        N = r.inArray,
        q = r.isArray,
        P = r.isNumber,
        e = r.isObject,
        c = r.isString,
        k = r.merge,
        n = r.objectEach,
        f = r.pick,
        a = r.pInt,
        l = r.removeEvent,
        v = r.splat,
        z = r.stop,
        w = r.uniqueKey,
        B = d.charts,
        L = d.deg2rad,
        Q = d.doc,
        H = d.hasTouch,
        K = d.isFirefox,
        p = d.isMS,
        b = d.isWebKit,
        C = d.noop,
        x = d.svg,
        R = d.SVG_NS,
        O = d.symbolSizes,
        X = d.win;

    var U = d.SVGElement = function () {
      return this;
    };

    h(U.prototype, {
      opacity: 1,
      SVG_NS: R,
      textProps: "direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline cursor".split(" "),
      init: function (b, a) {
        this.element = "span" === a ? G(a) : Q.createElementNS(this.SVG_NS, a);
        this.renderer = b;
        d.fireEvent(this, "afterInit");
      },
      animate: function (b, a, c) {
        var m = E(f(a, this.renderer.globalAnimation, !0));
        f(Q.hidden, Q.msHidden, Q.webkitHidden, !1) && (m.duration = 0);
        0 !== m.duration ? (c && (m.complete = c), M(this, b, m)) : (this.attr(b, void 0, c), n(b, function (b, a) {
          m.step && m.step.call(this, b, {
            prop: a,
            pos: 1
          });
        }, this));
        return this;
      },
      complexColor: function (b, a, f) {
        var m = this.renderer,
            c,
            p,
            e,
            x,
            T,
            C,
            l,
            v,
            z,
            Z,
            O,
            R = [],
            B;
        d.fireEvent(this.renderer, "complexColor", {
          args: arguments
        }, function () {
          b.radialGradient ? p = "radialGradient" : b.linearGradient && (p = "linearGradient");
          p && (e = b[p], T = m.gradients, l = b.stops, Z = f.radialReference, q(e) && (b[p] = e = {
            x1: e[0],
            y1: e[1],
            x2: e[2],
            y2: e[3],
            gradientUnits: "userSpaceOnUse"
          }), "radialGradient" === p && Z && !y(e.gradientUnits) && (x = e, e = k(e, m.getRadialAttr(Z, x), {
            gradientUnits: "userSpaceOnUse"
          })), n(e, function (b, a) {
            "id" !== a && R.push(a, b);
          }), n(l, function (b) {
            R.push(b);
          }), R = R.join(","), T[R] ? O = T[R].attr("id") : (e.id = O = w(), T[R] = C = m.createElement(p).attr(e).add(m.defs), C.radAttr = x, C.stops = [], l.forEach(function (b) {
            0 === b[1].indexOf("rgba") ? (c = u(b[1]), v = c.get("rgb"), z = c.get("a")) : (v = b[1], z = 1);
            b = m.createElement("stop").attr({
              offset: b[0],
              "stop-color": v,
              "stop-opacity": z
            }).add(C);
            C.stops.push(b);
          })), B = "url(" + m.url + "#" + O + ")", f.setAttribute(a, B), f.gradient = R, b.toString = function () {
            return B;
          });
        });
      },
      applyTextOutline: function (b) {
        var a = this.element,
            m;
        -1 !== b.indexOf("contrast") && (b = b.replace(/contrast/g, this.renderer.getContrast(a.style.fill)));
        b = b.split(" ");
        var f = b[b.length - 1];

        if ((m = b[0]) && "none" !== m && d.svg) {
          this.fakeTS = !0;
          b = [].slice.call(a.getElementsByTagName("tspan"));
          this.ySetter = this.xSetter;
          m = m.replace(/(^[\d\.]+)(.*?)$/g, function (b, a, m) {
            return 2 * a + m;
          });
          this.removeTextOutline(b);
          var c = a.textContent ? /^[\u0591-\u065F\u066A-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC]/.test(a.textContent) : !1;
          var p = a.firstChild;
          b.forEach(function (b, e) {
            0 === e && (b.setAttribute("x", a.getAttribute("x")), e = a.getAttribute("y"), b.setAttribute("y", e || 0), null === e && a.setAttribute("y", 0));
            e = b.cloneNode(!0);
            A(c && !K ? b : e, {
              "class": "highcharts-text-outline",
              fill: f,
              stroke: f,
              "stroke-width": m,
              "stroke-linejoin": "round"
            });
            a.insertBefore(e, p);
          });
          c && K && b[0] && (b = b[0].cloneNode(!0), b.textContent = " ", a.insertBefore(b, p));
        }
      },
      removeTextOutline: function (b) {
        for (var a = b.length, m; a--;) m = b[a], "highcharts-text-outline" === m.getAttribute("class") && D(b, this.element.removeChild(m));
      },
      symbolCustomAttribs: "x y width height r start end innerR anchorX anchorY rounded".split(" "),
      attr: function (b, a, f, c) {
        var m = this.element,
            p,
            e = this,
            x,
            C,
            l = this.symbolCustomAttribs;

        if ("string" === typeof b && "undefined" !== typeof a) {
          var T = b;
          b = {};
          b[T] = a;
        }

        "string" === typeof b ? e = (this[b + "Getter"] || this._defaultGetter).call(this, b, m) : (n(b, function (a, f) {
          x = !1;
          c || z(this, f);
          this.symbolName && -1 !== N(f, l) && (p || (this.symbolAttr(b), p = !0), x = !0);
          !this.rotation || "x" !== f && "y" !== f || (this.doTransform = !0);
          x || (C = this[f + "Setter"] || this._defaultSetter, C.call(this, a, f, m), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(f) && this.updateShadows(f, a, C));
        }, this), this.afterSetters());
        f && f.call(this);
        return e;
      },
      afterSetters: function () {
        this.doTransform && (this.updateTransform(), this.doTransform = !1);
      },
      updateShadows: function (b, a, f) {
        for (var m = this.shadows, c = m.length; c--;) f.call(m[c], "height" === b ? Math.max(a - (m[c].cutHeight || 0), 0) : "d" === b ? this.d : a, b, m[c]);
      },
      addClass: function (b, a) {
        var m = a ? "" : this.attr("class") || "";
        b = (b || "").split(/ /g).reduce(function (b, a) {
          -1 === m.indexOf(a) && b.push(a);
          return b;
        }, m ? [m] : []).join(" ");
        b !== m && this.attr("class", b);
        return this;
      },
      hasClass: function (b) {
        return -1 !== (this.attr("class") || "").split(" ").indexOf(b);
      },
      removeClass: function (b) {
        return this.attr("class", (this.attr("class") || "").replace(c(b) ? new RegExp(" ?" + b + " ?") : b, ""));
      },
      symbolAttr: function (b) {
        var a = this;
        "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (m) {
          a[m] = f(b[m], a[m]);
        });
        a.attr({
          d: a.renderer.symbols[a.symbolName](a.x, a.y, a.width, a.height, a)
        });
      },
      clip: function (b) {
        return this.attr("clip-path", b ? "url(" + this.renderer.url + "#" + b.id + ")" : "none");
      },
      crisp: function (b, a) {
        a = a || b.strokeWidth || 0;
        var m = Math.round(a) % 2 / 2;
        b.x = Math.floor(b.x || this.x || 0) + m;
        b.y = Math.floor(b.y || this.y || 0) + m;
        b.width = Math.floor((b.width || this.width || 0) - 2 * m);
        b.height = Math.floor((b.height || this.height || 0) - 2 * m);
        y(b.strokeWidth) && (b.strokeWidth = a);
        return b;
      },
      css: function (b) {
        var m = this.styles,
            f = {},
            c = this.element,
            p = "",
            e = !m,
            C = ["textOutline", "textOverflow", "width"];
        b && b.color && (b.fill = b.color);
        m && n(b, function (b, a) {
          b !== m[a] && (f[a] = b, e = !0);
        });

        if (e) {
          m && (b = h(m, f));
          if (b) if (null === b.width || "auto" === b.width) delete this.textWidth;else if ("text" === c.nodeName.toLowerCase() && b.width) var l = this.textWidth = a(b.width);
          this.styles = b;
          l && !x && this.renderer.forExport && delete b.width;

          if (c.namespaceURI === this.SVG_NS) {
            var k = function (b, a) {
              return "-" + a.toLowerCase();
            };

            n(b, function (b, a) {
              -1 === C.indexOf(a) && (p += a.replace(/([A-Z])/g, k) + ":" + b + ";");
            });
            p && A(c, "style", p);
          } else J(c, b);

          this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), b && b.textOutline && this.applyTextOutline(b.textOutline));
        }

        return this;
      },
      getStyle: function (b) {
        return X.getComputedStyle(this.element || this, "").getPropertyValue(b);
      },
      strokeWidth: function () {
        if (!this.renderer.styledMode) return this["stroke-width"] || 0;
        var b = this.getStyle("stroke-width"),
            f = 0;
        if (b.indexOf("px") === b.length - 2) f = a(b);else if ("" !== b) {
          var c = Q.createElementNS(R, "rect");
          A(c, {
            width: b,
            "stroke-width": 0
          });
          this.element.parentNode.appendChild(c);
          f = c.getBBox().width;
          c.parentNode.removeChild(c);
        }
        return f;
      },
      on: function (b, a) {
        var m,
            f,
            c = this.element,
            p;
        H && "click" === b ? (c.ontouchstart = function (b) {
          m = b.touches[0].clientX;
          f = b.touches[0].clientY;
        }, c.ontouchend = function (b) {
          m && 4 <= Math.sqrt(Math.pow(m - b.changedTouches[0].clientX, 2) + Math.pow(f - b.changedTouches[0].clientY, 2)) || a.call(c, b);
          p = !0;
          b.preventDefault();
        }, c.onclick = function (b) {
          p || a.call(c, b);
        }) : c["on" + b] = a;
        return this;
      },
      setRadialReference: function (b) {
        var a = this.renderer.gradients[this.element.gradient];
        this.element.radialReference = b;
        a && a.radAttr && a.animate(this.renderer.getRadialAttr(b, a.radAttr));
        return this;
      },
      translate: function (b, a) {
        return this.attr({
          translateX: b,
          translateY: a
        });
      },
      invert: function (b) {
        this.inverted = b;
        this.updateTransform();
        return this;
      },
      updateTransform: function () {
        var b = this.translateX || 0,
            a = this.translateY || 0,
            c = this.scaleX,
            p = this.scaleY,
            e = this.inverted,
            x = this.rotation,
            C = this.matrix,
            l = this.element;
        e && (b += this.width, a += this.height);
        b = ["translate(" + b + "," + a + ")"];
        y(C) && b.push("matrix(" + C.join(",") + ")");
        e ? b.push("rotate(90) scale(-1,1)") : x && b.push("rotate(" + x + " " + f(this.rotationOriginX, l.getAttribute("x"), 0) + " " + f(this.rotationOriginY, l.getAttribute("y") || 0) + ")");
        (y(c) || y(p)) && b.push("scale(" + f(c, 1) + " " + f(p, 1) + ")");
        b.length && l.setAttribute("transform", b.join(" "));
      },
      toFront: function () {
        var b = this.element;
        b.parentNode.appendChild(b);
        return this;
      },
      align: function (b, a, p) {
        var m,
            e = {};
        var x = this.renderer;
        var C = x.alignedObjects;
        var l, k;

        if (b) {
          if (this.alignOptions = b, this.alignByTranslate = a, !p || c(p)) this.alignTo = m = p || "renderer", D(C, this), C.push(this), p = null;
        } else b = this.alignOptions, a = this.alignByTranslate, m = this.alignTo;

        p = f(p, x[m], x);
        m = b.align;
        x = b.verticalAlign;
        C = (p.x || 0) + (b.x || 0);
        var T = (p.y || 0) + (b.y || 0);
        "right" === m ? l = 1 : "center" === m && (l = 2);
        l && (C += (p.width - (b.width || 0)) / l);
        e[a ? "translateX" : "x"] = Math.round(C);
        "bottom" === x ? k = 1 : "middle" === x && (k = 2);
        k && (T += (p.height - (b.height || 0)) / k);
        e[a ? "translateY" : "y"] = Math.round(T);
        this[this.placed ? "animate" : "attr"](e);
        this.placed = !0;
        this.alignAttr = e;
        return this;
      },
      getBBox: function (b, a) {
        var m,
            c = this.renderer,
            p = this.element,
            e = this.styles,
            x = this.textStr,
            C,
            l = c.cache,
            k = c.cacheKeys,
            T = p.namespaceURI === this.SVG_NS;
        a = f(a, this.rotation, 0);
        var n = c.styledMode ? p && U.prototype.getStyle.call(p, "font-size") : e && e.fontSize;

        if (y(x)) {
          var v = x.toString();
          -1 === v.indexOf("<") && (v = v.replace(/[0-9]/g, "0"));
          v += ["", a, n, this.textWidth, e && e.textOverflow].join();
        }

        v && !b && (m = l[v]);

        if (!m) {
          if (T || c.forExport) {
            try {
              (C = this.fakeTS && function (b) {
                [].forEach.call(p.querySelectorAll(".highcharts-text-outline"), function (a) {
                  a.style.display = b;
                });
              }) && C("none"), m = p.getBBox ? h({}, p.getBBox()) : {
                width: p.offsetWidth,
                height: p.offsetHeight
              }, C && C("");
            } catch (ea) {
              "";
            }

            if (!m || 0 > m.width) m = {
              width: 0,
              height: 0
            };
          } else m = this.htmlGetBBox();

          c.isSVG && (b = m.width, c = m.height, T && (m.height = c = {
            "11px,17": 14,
            "13px,20": 16
          }[e && e.fontSize + "," + Math.round(c)] || c), a && (e = a * L, m.width = Math.abs(c * Math.sin(e)) + Math.abs(b * Math.cos(e)), m.height = Math.abs(c * Math.cos(e)) + Math.abs(b * Math.sin(e))));

          if (v && 0 < m.height) {
            for (; 250 < k.length;) delete l[k.shift()];

            l[v] || k.push(v);
            l[v] = m;
          }
        }

        return m;
      },
      show: function (b) {
        return this.attr({
          visibility: b ? "inherit" : "visible"
        });
      },
      hide: function (b) {
        b ? this.attr({
          y: -9999
        }) : this.attr({
          visibility: "hidden"
        });
        return this;
      },
      fadeOut: function (b) {
        var a = this;
        a.animate({
          opacity: 0
        }, {
          duration: b || 150,
          complete: function () {
            a.attr({
              y: -9999
            });
          }
        });
      },
      add: function (b) {
        var a = this.renderer,
            m = this.element;
        b && (this.parentGroup = b);
        this.parentInverted = b && b.inverted;
        "undefined" !== typeof this.textStr && a.buildText(this);
        this.added = !0;
        if (!b || b.handleZ || this.zIndex) var f = this.zIndexSetter();
        f || (b ? b.element : a.box).appendChild(m);
        if (this.onAdd) this.onAdd();
        return this;
      },
      safeRemoveChild: function (b) {
        var a = b.parentNode;
        a && a.removeChild(b);
      },
      destroy: function () {
        var b = this,
            a = b.element || {},
            f = b.renderer,
            c = f.isSVG && "SPAN" === a.nodeName && b.parentGroup,
            p = a.ownerSVGElement,
            e = b.clipPath;
        a.onclick = a.onmouseout = a.onmouseover = a.onmousemove = a.point = null;
        z(b);
        e && p && ([].forEach.call(p.querySelectorAll("[clip-path],[CLIP-PATH]"), function (b) {
          -1 < b.getAttribute("clip-path").indexOf(e.element.id) && b.removeAttribute("clip-path");
        }), b.clipPath = e.destroy());

        if (b.stops) {
          for (p = 0; p < b.stops.length; p++) b.stops[p] = b.stops[p].destroy();

          b.stops = null;
        }

        b.safeRemoveChild(a);

        for (f.styledMode || b.destroyShadows(); c && c.div && 0 === c.div.childNodes.length;) a = c.parentGroup, b.safeRemoveChild(c.div), delete c.div, c = a;

        b.alignTo && D(f.alignedObjects, b);
        n(b, function (a, m) {
          b[m] && b[m].parentGroup === b && b[m].destroy && b[m].destroy();
          delete b[m];
        });
      },
      shadow: function (b, a, c) {
        var m = [],
            p,
            e = this.element;
        if (!b) this.destroyShadows();else if (!this.shadows) {
          var x = f(b.width, 3);
          var C = (b.opacity || .15) / x;
          var l = this.parentInverted ? "(-1,-1)" : "(" + f(b.offsetX, 1) + ", " + f(b.offsetY, 1) + ")";

          for (p = 1; p <= x; p++) {
            var k = e.cloneNode(0);
            var n = 2 * x + 1 - 2 * p;
            A(k, {
              stroke: b.color || "#000000",
              "stroke-opacity": C * p,
              "stroke-width": n,
              transform: "translate" + l,
              fill: "none"
            });
            k.setAttribute("class", (k.getAttribute("class") || "") + " highcharts-shadow");
            c && (A(k, "height", Math.max(A(k, "height") - n, 0)), k.cutHeight = n);
            a ? a.element.appendChild(k) : e.parentNode && e.parentNode.insertBefore(k, e);
            m.push(k);
          }

          this.shadows = m;
        }
        return this;
      },
      destroyShadows: function () {
        (this.shadows || []).forEach(function (b) {
          this.safeRemoveChild(b);
        }, this);
        this.shadows = void 0;
      },
      xGetter: function (b) {
        "circle" === this.element.nodeName && ("x" === b ? b = "cx" : "y" === b && (b = "cy"));
        return this._defaultGetter(b);
      },
      _defaultGetter: function (b) {
        b = f(this[b + "Value"], this[b], this.element ? this.element.getAttribute(b) : null, 0);
        /^[\-0-9\.]+$/.test(b) && (b = parseFloat(b));
        return b;
      },
      dSetter: function (b, a, f) {
        b && b.join && (b = b.join(" "));
        /(NaN| {2}|^$)/.test(b) && (b = "M 0 0");
        this[a] !== b && (f.setAttribute(a, b), this[a] = b);
      },
      dashstyleSetter: function (b) {
        var f,
            c = this["stroke-width"];
        "inherit" === c && (c = 1);

        if (b = b && b.toLowerCase()) {
          b = b.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");

          for (f = b.length; f--;) b[f] = a(b[f]) * c;

          b = b.join(",").replace(/NaN/g, "none");
          this.element.setAttribute("stroke-dasharray", b);
        }
      },
      alignSetter: function (b) {
        var a = {
          left: "start",
          center: "middle",
          right: "end"
        };
        a[b] && (this.alignValue = b, this.element.setAttribute("text-anchor", a[b]));
      },
      opacitySetter: function (b, a, f) {
        this[a] = b;
        f.setAttribute(a, b);
      },
      titleSetter: function (b) {
        var a = this.element.getElementsByTagName("title")[0];
        a || (a = Q.createElementNS(this.SVG_NS, "title"), this.element.appendChild(a));
        a.firstChild && a.removeChild(a.firstChild);
        a.appendChild(Q.createTextNode(String(f(b, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">")));
      },
      textSetter: function (b) {
        b !== this.textStr && (delete this.bBox, delete this.textPxLength, this.textStr = b, this.added && this.renderer.buildText(this));
      },
      setTextPath: function (b, a) {
        var f = this.element,
            c = {
          textAnchor: "text-anchor"
        },
            m = !1,
            p = this.textPathWrapper,
            e = !p;
        a = k(!0, {
          enabled: !0,
          attributes: {
            dy: -5,
            startOffset: "50%",
            textAnchor: "middle"
          }
        }, a);
        var x = a.attributes;

        if (b && a && a.enabled) {
          p && null === p.element.parentNode ? (e = !0, p = p.destroy()) : p && this.removeTextOutline.call(p.parentGroup, [].slice.call(f.getElementsByTagName("tspan")));
          this.options && this.options.padding && (x.dx = -this.options.padding);
          p || (this.textPathWrapper = p = this.renderer.createElement("textPath"), m = !0);
          var l = p.element;
          (a = b.element.getAttribute("id")) || b.element.setAttribute("id", a = w());
          if (e) for (b = f.getElementsByTagName("tspan"); b.length;) b[0].setAttribute("y", 0), P(x.dx) && b[0].setAttribute("x", -x.dx), l.appendChild(b[0]);
          m && p.add({
            element: this.text ? this.text.element : f
          });
          l.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + a);
          y(x.dy) && (l.parentNode.setAttribute("dy", x.dy), delete x.dy);
          y(x.dx) && (l.parentNode.setAttribute("dx", x.dx), delete x.dx);
          n(x, function (b, a) {
            l.setAttribute(c[a] || a, b);
          });
          f.removeAttribute("transform");
          this.removeTextOutline.call(p, [].slice.call(f.getElementsByTagName("tspan")));
          this.text && !this.renderer.styledMode && this.attr({
            fill: "none",
            "stroke-width": 0
          });
          this.applyTextOutline = this.updateTransform = C;
        } else p && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(f, b), this.updateTransform(), this.options.rotation && this.applyTextOutline(this.options.style.textOutline));

        return this;
      },
      destroyTextPath: function (b, a) {
        var f = b.getElementsByTagName("text")[0];

        if (f) {
          if (f.removeAttribute("dx"), f.removeAttribute("dy"), a.element.setAttribute("id", ""), f.getElementsByTagName("textPath").length) {
            for (b = this.textPathWrapper.element.childNodes; b.length;) f.appendChild(b[0]);

            f.removeChild(this.textPathWrapper.element);
          }
        } else if (b.getAttribute("dx") || b.getAttribute("dy")) b.removeAttribute("dx"), b.removeAttribute("dy");

        this.textPathWrapper = this.textPathWrapper.destroy();
      },
      fillSetter: function (b, a, f) {
        "string" === typeof b ? f.setAttribute(a, b) : b && this.complexColor(b, a, f);
      },
      visibilitySetter: function (b, a, f) {
        "inherit" === b ? f.removeAttribute(a) : this[a] !== b && f.setAttribute(a, b);
        this[a] = b;
      },
      zIndexSetter: function (b, f) {
        var c = this.renderer,
            m = this.parentGroup,
            p = (m || c).element || c.box,
            e = this.element,
            x = !1;
        c = p === c.box;
        var C = this.added;
        var l;
        y(b) ? (e.setAttribute("data-z-index", b), b = +b, this[f] === b && (C = !1)) : y(this[f]) && e.removeAttribute("data-z-index");
        this[f] = b;

        if (C) {
          (b = this.zIndex) && m && (m.handleZ = !0);
          f = p.childNodes;

          for (l = f.length - 1; 0 <= l && !x; l--) {
            m = f[l];
            C = m.getAttribute("data-z-index");
            var k = !y(C);
            if (m !== e) if (0 > b && k && !c && !l) p.insertBefore(e, f[l]), x = !0;else if (a(C) <= b || k && (!y(b) || 0 <= b)) p.insertBefore(e, f[l + 1] || null), x = !0;
          }

          x || (p.insertBefore(e, f[c ? 3 : 0] || null), x = !0);
        }

        return x;
      },
      _defaultSetter: function (b, a, f) {
        f.setAttribute(a, b);
      }
    });
    U.prototype.yGetter = U.prototype.xGetter;

    U.prototype.translateXSetter = U.prototype.translateYSetter = U.prototype.rotationSetter = U.prototype.verticalAlignSetter = U.prototype.rotationOriginXSetter = U.prototype.rotationOriginYSetter = U.prototype.scaleXSetter = U.prototype.scaleYSetter = U.prototype.matrixSetter = function (b, a) {
      this[a] = b;
      this.doTransform = !0;
    };

    U.prototype["stroke-widthSetter"] = U.prototype.strokeSetter = function (b, a, f) {
      this[a] = b;
      this.stroke && this["stroke-width"] ? (U.prototype.fillSetter.call(this, this.stroke, "stroke", f), f.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === a && 0 === b && this.hasStroke ? (f.removeAttribute("stroke"), this.hasStroke = !1) : this.renderer.styledMode && this["stroke-width"] && (f.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0);
    };

    g = d.SVGRenderer = function () {
      this.init.apply(this, arguments);
    };

    h(g.prototype, {
      Element: U,
      SVG_NS: R,
      init: function (a, f, c, p, e, x, C) {
        var m = this.createElement("svg").attr({
          version: "1.1",
          "class": "highcharts-root"
        });
        C || m.css(this.getStyle(p));
        p = m.element;
        a.appendChild(p);
        A(a, "dir", "ltr");
        -1 === a.innerHTML.indexOf("xmlns") && A(p, "xmlns", this.SVG_NS);
        this.isSVG = !0;
        this.box = p;
        this.boxWrapper = m;
        this.alignedObjects = [];
        this.url = (K || b) && Q.getElementsByTagName("base").length ? X.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "";
        this.createElement("desc").add().element.appendChild(Q.createTextNode("Created with Highcharts 8.0.4"));
        this.defs = this.createElement("defs").add();
        this.allowHTML = x;
        this.forExport = e;
        this.styledMode = C;
        this.gradients = {};
        this.cache = {};
        this.cacheKeys = [];
        this.imgCount = 0;
        this.setSize(f, c, !1);
        var l;
        K && a.getBoundingClientRect && (f = function () {
          J(a, {
            left: 0,
            top: 0
          });
          l = a.getBoundingClientRect();
          J(a, {
            left: Math.ceil(l.left) - l.left + "px",
            top: Math.ceil(l.top) - l.top + "px"
          });
        }, f(), this.unSubPixelFix = I(X, "resize", f));
      },
      definition: function (b) {
        function a(b, c) {
          var p;
          v(b).forEach(function (b) {
            var m = f.createElement(b.tagName),
                e = {};
            n(b, function (b, a) {
              "tagName" !== a && "children" !== a && "textContent" !== a && (e[a] = b);
            });
            m.attr(e);
            m.add(c || f.defs);
            b.textContent && m.element.appendChild(Q.createTextNode(b.textContent));
            a(b.children || [], m);
            p = m;
          });
          return p;
        }

        var f = this;
        return a(b);
      },
      getStyle: function (b) {
        return this.style = h({
          fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
          fontSize: "12px"
        }, b);
      },
      setStyle: function (b) {
        this.boxWrapper.css(this.getStyle(b));
      },
      isHidden: function () {
        return !this.boxWrapper.getBBox().width;
      },
      destroy: function () {
        var b = this.defs;
        this.box = null;
        this.boxWrapper = this.boxWrapper.destroy();
        t(this.gradients || {});
        this.gradients = null;
        b && (this.defs = b.destroy());
        this.unSubPixelFix && this.unSubPixelFix();
        return this.alignedObjects = null;
      },
      createElement: function (b) {
        var a = new this.Element();
        a.init(this, b);
        return a;
      },
      draw: C,
      getRadialAttr: function (b, a) {
        return {
          cx: b[0] - b[2] / 2 + a.cx * b[2],
          cy: b[1] - b[2] / 2 + a.cy * b[2],
          r: a.r * b[2]
        };
      },
      truncate: function (b, a, f, c, p, e, x) {
        var m = this,
            C = b.rotation,
            l,
            k = c ? 1 : 0,
            F = (f || c).length,
            n = F,
            v = [],
            w = function (b) {
          a.firstChild && a.removeChild(a.firstChild);
          b && a.appendChild(Q.createTextNode(b));
        },
            z = function (e, l) {
          l = l || e;
          if ("undefined" === typeof v[l]) if (a.getSubStringLength) try {
            v[l] = p + a.getSubStringLength(0, c ? l + 1 : l);
          } catch (la) {
            "";
          } else m.getSpanWidth && (w(x(f || c, e)), v[l] = p + m.getSpanWidth(b, a));
          return v[l];
        },
            O;

        b.rotation = 0;
        var T = z(a.textContent.length);

        if (O = p + T > e) {
          for (; k <= F;) n = Math.ceil((k + F) / 2), c && (l = x(c, n)), T = z(n, l && l.length - 1), k === F ? k = F + 1 : T > e ? F = n - 1 : k = n;

          0 === F ? w("") : f && F === f.length - 1 || w(l || x(f || c, n));
        }

        c && c.splice(0, n);
        b.actualWidth = T;
        b.rotation = C;
        return O;
      },
      escapes: {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "'": "&#39;",
        '"': "&quot;"
      },
      buildText: function (b) {
        var c = b.element,
            p = this,
            e = p.forExport,
            m = f(b.textStr, "").toString(),
            l = -1 !== m.indexOf("<"),
            C = c.childNodes,
            k,
            v = A(c, "x"),
            w = b.styles,
            z = b.textWidth,
            O = w && w.lineHeight,
            q = w && w.textOutline,
            B = w && "ellipsis" === w.textOverflow,
            d = w && "nowrap" === w.whiteSpace,
            N = w && w.fontSize,
            X,
            h = C.length;
        w = z && !b.added && this.box;

        var L = function (b) {
          var f;
          p.styledMode || (f = /(px|em)$/.test(b && b.style.fontSize) ? b.style.fontSize : N || p.style.fontSize || 12);
          return O ? a(O) : p.fontMetrics(f, b.getAttribute("style") ? b : c).h;
        },
            t = function (b, a) {
          n(p.escapes, function (f, c) {
            a && -1 !== a.indexOf(f) || (b = b.toString().replace(new RegExp(f, "g"), c));
          });
          return b;
        },
            U = function (b, a) {
          var f = b.indexOf("<");
          b = b.substring(f, b.indexOf(">") - f);
          f = b.indexOf(a + "=");
          if (-1 !== f && (f = f + a.length + 1, a = b.charAt(f), '"' === a || "'" === a)) return b = b.substring(f + 1), b.substring(0, b.indexOf(a));
        },
            P = /<br.*?>/g;

        var g = [m, B, d, O, q, N, z].join();

        if (g !== b.textCache) {
          for (b.textCache = g; h--;) c.removeChild(C[h]);

          l || q || B || z || -1 !== m.indexOf(" ") && (!d || P.test(m)) ? (w && w.appendChild(c), l ? (m = p.styledMode ? m.replace(/<(b|strong)>/g, '<span class="highcharts-strong">').replace(/<(i|em)>/g, '<span class="highcharts-emphasized">') : m.replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">'), m = m.replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(P)) : m = [m], m = m.filter(function (b) {
            return "" !== b;
          }), m.forEach(function (a, f) {
            var m = 0,
                l = 0;
            a = a.replace(/^\s+|\s+$/g, "").replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||");
            var C = a.split("|||");
            C.forEach(function (a) {
              if ("" !== a || 1 === C.length) {
                var n = {},
                    F = Q.createElementNS(p.SVG_NS, "tspan"),
                    w,
                    O;
                (w = U(a, "class")) && A(F, "class", w);
                if (w = U(a, "style")) w = w.replace(/(;| |^)color([ :])/, "$1fill$2"), A(F, "style", w);
                (O = U(a, "href")) && !e && (A(F, "onclick", 'location.href="' + O + '"'), A(F, "class", "highcharts-anchor"), p.styledMode || J(F, {
                  cursor: "pointer"
                }));
                a = t(a.replace(/<[a-zA-Z\/](.|\n)*?>/g, "") || " ");

                if (" " !== a) {
                  F.appendChild(Q.createTextNode(a));
                  m ? n.dx = 0 : f && null !== v && (n.x = v);
                  A(F, n);
                  c.appendChild(F);
                  !m && X && (!x && e && J(F, {
                    display: "block"
                  }), A(F, "dy", L(F)));

                  if (z) {
                    var q = a.replace(/([^\^])-/g, "$1- ").split(" ");
                    n = !d && (1 < C.length || f || 1 < q.length);
                    O = 0;
                    var T = L(F);
                    if (B) k = p.truncate(b, F, a, void 0, 0, Math.max(0, z - parseInt(N || 12, 10)), function (b, a) {
                      return b.substring(0, a) + "\u2026";
                    });else if (n) for (; q.length;) q.length && !d && 0 < O && (F = Q.createElementNS(R, "tspan"), A(F, {
                      dy: T,
                      x: v
                    }), w && A(F, "style", w), F.appendChild(Q.createTextNode(q.join(" ").replace(/- /g, "-"))), c.appendChild(F)), p.truncate(b, F, null, q, 0 === O ? l : 0, z, function (b, a) {
                      return q.slice(0, a).join(" ").replace(/- /g, "-");
                    }), l = b.actualWidth, O++;
                  }

                  m++;
                }
              }
            });
            X = X || c.childNodes.length;
          }), B && k && b.attr("title", t(b.textStr, ["&lt;", "&gt;"])), w && w.removeChild(c), q && b.applyTextOutline && b.applyTextOutline(q)) : c.appendChild(Q.createTextNode(t(m)));
        }
      },
      getContrast: function (b) {
        b = u(b).rgba;
        b[0] *= 1;
        b[1] *= 1.2;
        b[2] *= .5;
        return 459 < b[0] + b[1] + b[2] ? "#000000" : "#FFFFFF";
      },
      button: function (b, a, f, c, e, x, l, C, n, w) {
        var m = this.label(b, a, f, n, null, null, w, null, "button"),
            F = 0,
            v = this.styledMode;
        m.attr(k({
          padding: 8,
          r: 2
        }, e));

        if (!v) {
          e = k({
            fill: "#f7f7f7",
            stroke: "#cccccc",
            "stroke-width": 1,
            style: {
              color: "#333333",
              cursor: "pointer",
              fontWeight: "normal"
            }
          }, e);
          var z = e.style;
          delete e.style;
          x = k(e, {
            fill: "#e6e6e6"
          }, x);
          var O = x.style;
          delete x.style;
          l = k(e, {
            fill: "#e6ebf5",
            style: {
              color: "#000000",
              fontWeight: "bold"
            }
          }, l);
          var q = l.style;
          delete l.style;
          C = k(e, {
            style: {
              color: "#cccccc"
            }
          }, C);
          var R = C.style;
          delete C.style;
        }

        I(m.element, p ? "mouseover" : "mouseenter", function () {
          3 !== F && m.setState(1);
        });
        I(m.element, p ? "mouseout" : "mouseleave", function () {
          3 !== F && m.setState(F);
        });

        m.setState = function (b) {
          1 !== b && (m.state = F = b);
          m.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][b || 0]);
          v || m.attr([e, x, l, C][b || 0]).css([z, O, q, R][b || 0]);
        };

        v || m.attr(e).css(h({
          cursor: "default"
        }, z));
        return m.on("click", function (b) {
          3 !== F && c.call(m, b);
        });
      },
      crispLine: function (b, a) {
        b[1] === b[4] && (b[1] = b[4] = Math.round(b[1]) - a % 2 / 2);
        b[2] === b[5] && (b[2] = b[5] = Math.round(b[2]) + a % 2 / 2);
        return b;
      },
      path: function (b) {
        var a = this.styledMode ? {} : {
          fill: "none"
        };
        q(b) ? a.d = b : e(b) && h(a, b);
        return this.createElement("path").attr(a);
      },
      circle: function (b, a, f) {
        b = e(b) ? b : "undefined" === typeof b ? {} : {
          x: b,
          y: a,
          r: f
        };
        a = this.createElement("circle");

        a.xSetter = a.ySetter = function (b, a, f) {
          f.setAttribute("c" + a, b);
        };

        return a.attr(b);
      },
      arc: function (b, a, f, c, p, x) {
        e(b) ? (c = b, a = c.y, f = c.r, b = c.x) : c = {
          innerR: c,
          start: p,
          end: x
        };
        b = this.symbol("arc", b, a, f, f, c);
        b.r = f;
        return b;
      },
      rect: function (b, a, f, c, p, x) {
        p = e(b) ? b.r : p;
        var m = this.createElement("rect");
        b = e(b) ? b : "undefined" === typeof b ? {} : {
          x: b,
          y: a,
          width: Math.max(f, 0),
          height: Math.max(c, 0)
        };
        this.styledMode || ("undefined" !== typeof x && (b.strokeWidth = x, b = m.crisp(b)), b.fill = "none");
        p && (b.r = p);

        m.rSetter = function (b, a, f) {
          m.r = b;
          A(f, {
            rx: b,
            ry: b
          });
        };

        m.rGetter = function () {
          return m.r;
        };

        return m.attr(b);
      },
      setSize: function (b, a, c) {
        var p = this.alignedObjects,
            e = p.length;
        this.width = b;
        this.height = a;

        for (this.boxWrapper.animate({
          width: b,
          height: a
        }, {
          step: function () {
            this.attr({
              viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
            });
          },
          duration: f(c, !0) ? void 0 : 0
        }); e--;) p[e].align();
      },
      g: function (b) {
        var a = this.createElement("g");
        return b ? a.attr({
          "class": "highcharts-" + b
        }) : a;
      },
      image: function (b, a, f, c, p, e) {
        var x = {
          preserveAspectRatio: "none"
        },
            m = function (b, a) {
          b.setAttributeNS ? b.setAttributeNS("http://www.w3.org/1999/xlink", "href", a) : b.setAttribute("hc-svg-href", a);
        },
            l = function (a) {
          m(C.element, b);
          e.call(C, a);
        };

        1 < arguments.length && h(x, {
          x: a,
          y: f,
          width: c,
          height: p
        });
        var C = this.createElement("image").attr(x);
        e ? (m(C.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), x = new X.Image(), I(x, "load", l), x.src = b, x.complete && l({})) : m(C.element, b);
        return C;
      },
      symbol: function (b, a, c, p, e, x) {
        var m = this,
            l = /^url\((.*?)\)$/,
            C = l.test(b),
            k = !C && (this.symbols[b] ? b : "circle"),
            n = k && this.symbols[k],
            F = y(a) && n && n.call(this.symbols, Math.round(a), Math.round(c), p, e, x);

        if (n) {
          var w = this.path(F);
          m.styledMode || w.attr("fill", "none");
          h(w, {
            symbolName: k,
            x: a,
            y: c,
            width: p,
            height: e
          });
          x && h(w, x);
        } else if (C) {
          var v = b.match(l)[1];
          w = this.image(v);
          w.imgwidth = f(O[v] && O[v].width, x && x.width);
          w.imgheight = f(O[v] && O[v].height, x && x.height);

          var z = function () {
            w.attr({
              width: w.width,
              height: w.height
            });
          };

          ["width", "height"].forEach(function (b) {
            w[b + "Setter"] = function (b, a) {
              var f = {},
                  c = this["img" + a],
                  p = "width" === a ? "translateX" : "translateY";
              this[a] = b;
              y(c) && (x && "within" === x.backgroundSize && this.width && this.height && (c = Math.round(c * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(a, c), this.alignByTranslate || (f[p] = ((this[a] || 0) - c) / 2, this.attr(f)));
            };
          });
          y(a) && w.attr({
            x: a,
            y: c
          });
          w.isImg = !0;
          y(w.imgwidth) && y(w.imgheight) ? z() : (w.attr({
            width: 0,
            height: 0
          }), G("img", {
            onload: function () {
              var b = B[m.chartIndex];
              0 === this.width && (J(this, {
                position: "absolute",
                top: "-999em"
              }), Q.body.appendChild(this));
              O[v] = {
                width: this.width,
                height: this.height
              };
              w.imgwidth = this.width;
              w.imgheight = this.height;
              w.element && z();
              this.parentNode && this.parentNode.removeChild(this);
              m.imgCount--;
              if (!m.imgCount && b && !b.hasLoaded) b.onload();
            },
            src: v
          }), this.imgCount++);
        }

        return w;
      },
      symbols: {
        circle: function (b, a, f, c) {
          return this.arc(b + f / 2, a + c / 2, f / 2, c / 2, {
            start: .5 * Math.PI,
            end: 2.5 * Math.PI,
            open: !1
          });
        },
        square: function (b, a, f, c) {
          return ["M", b, a, "L", b + f, a, b + f, a + c, b, a + c, "Z"];
        },
        triangle: function (b, a, f, c) {
          return ["M", b + f / 2, a, "L", b + f, a + c, b, a + c, "Z"];
        },
        "triangle-down": function (b, a, f, c) {
          return ["M", b, a, "L", b + f, a, b + f / 2, a + c, "Z"];
        },
        diamond: function (b, a, f, c) {
          return ["M", b + f / 2, a, "L", b + f, a + c / 2, b + f / 2, a + c, b, a + c / 2, "Z"];
        },
        arc: function (b, a, c, p, e) {
          var x = e.start,
              m = e.r || c,
              l = e.r || p || c,
              C = e.end - .001;
          c = e.innerR;
          p = f(e.open, .001 > Math.abs(e.end - e.start - 2 * Math.PI));
          var k = Math.cos(x),
              n = Math.sin(x),
              w = Math.cos(C);
          C = Math.sin(C);
          x = f(e.longArc, .001 > e.end - x - Math.PI ? 0 : 1);
          m = ["M", b + m * k, a + l * n, "A", m, l, 0, x, f(e.clockwise, 1), b + m * w, a + l * C];
          y(c) && m.push(p ? "M" : "L", b + c * w, a + c * C, "A", c, c, 0, x, y(e.clockwise) ? 1 - e.clockwise : 0, b + c * k, a + c * n);
          m.push(p ? "" : "Z");
          return m;
        },
        callout: function (b, a, f, c, p) {
          var e = Math.min(p && p.r || 0, f, c),
              x = e + 6,
              l = p && p.anchorX;
          p = p && p.anchorY;
          var m = ["M", b + e, a, "L", b + f - e, a, "C", b + f, a, b + f, a, b + f, a + e, "L", b + f, a + c - e, "C", b + f, a + c, b + f, a + c, b + f - e, a + c, "L", b + e, a + c, "C", b, a + c, b, a + c, b, a + c - e, "L", b, a + e, "C", b, a, b, a, b + e, a];
          l && l > f ? p > a + x && p < a + c - x ? m.splice(13, 3, "L", b + f, p - 6, b + f + 6, p, b + f, p + 6, b + f, a + c - e) : m.splice(13, 3, "L", b + f, c / 2, l, p, b + f, c / 2, b + f, a + c - e) : l && 0 > l ? p > a + x && p < a + c - x ? m.splice(33, 3, "L", b, p + 6, b - 6, p, b, p - 6, b, a + e) : m.splice(33, 3, "L", b, c / 2, l, p, b, c / 2, b, a + e) : p && p > c && l > b + x && l < b + f - x ? m.splice(23, 3, "L", l + 6, a + c, l, a + c + 6, l - 6, a + c, b + e, a + c) : p && 0 > p && l > b + x && l < b + f - x && m.splice(3, 3, "L", l - 6, a, l, a - 6, l + 6, a, f - e, a);
          return m;
        }
      },
      clipRect: function (b, a, f, c) {
        var p = w() + "-",
            e = this.createElement("clipPath").attr({
          id: p
        }).add(this.defs);
        b = this.rect(b, a, f, c, 0).add(e);
        b.id = p;
        b.clipPath = e;
        b.count = 0;
        return b;
      },
      text: function (b, a, f, c) {
        var p = {};
        if (c && (this.allowHTML || !this.forExport)) return this.html(b, a, f);
        p.x = Math.round(a || 0);
        f && (p.y = Math.round(f));
        y(b) && (p.text = b);
        b = this.createElement("text").attr(p);
        c || (b.xSetter = function (b, a, f) {
          var c = f.getElementsByTagName("tspan"),
              p = f.getAttribute(a),
              e;

          for (e = 0; e < c.length; e++) {
            var x = c[e];
            x.getAttribute(a) === p && x.setAttribute(a, b);
          }

          f.setAttribute(a, b);
        });
        return b;
      },
      fontMetrics: function (b, f) {
        b = !this.styledMode && /px/.test(b) || !X.getComputedStyle ? b || f && f.style && f.style.fontSize || this.style && this.style.fontSize : f && U.prototype.getStyle.call(f, "font-size");
        b = /px/.test(b) ? a(b) : 12;
        f = 24 > b ? b + 3 : Math.round(1.2 * b);
        return {
          h: f,
          b: Math.round(.8 * f),
          f: b
        };
      },
      rotCorr: function (b, a, f) {
        var c = b;
        a && f && (c = Math.max(c * Math.cos(a * L), 4));
        return {
          x: -b / 3 * Math.sin(a * L),
          y: c
        };
      },
      label: function (b, a, f, c, p, e, x, C, n) {
        var m = this,
            w = m.styledMode,
            v = m.g("button" !== n && "label"),
            F = v.text = m.text("", 0, 0, x).attr({
          zIndex: 1
        }),
            z,
            O,
            q = 0,
            R = 3,
            B = 0,
            d,
            N,
            X,
            V,
            L,
            t = {},
            T,
            g,
            Q = /^url\((.*?)\)$/.test(c),
            H = w || Q,
            K = function () {
          return w ? z.strokeWidth() % 2 / 2 : (T ? parseInt(T, 10) : 0) % 2 / 2;
        };

        n && v.addClass("highcharts-" + n);

        var ba = function () {
          var b = F.element.style,
              a = {};
          O = ("undefined" === typeof d || "undefined" === typeof N || L) && y(F.textStr) && F.getBBox();
          v.width = (d || O.width || 0) + 2 * R + B;
          v.height = (N || O.height || 0) + 2 * R;
          g = R + Math.min(m.fontMetrics(b && b.fontSize, F).b, O ? O.height : Infinity);
          H && (z || (v.box = z = m.symbols[c] || Q ? m.symbol(c) : m.rect(), z.addClass(("button" === n ? "" : "highcharts-label-box") + (n ? " highcharts-" + n + "-box" : "")), z.add(v), b = K(), a.x = b, a.y = (C ? -g : 0) + b), a.width = Math.round(v.width), a.height = Math.round(v.height), z.attr(h(a, t)), t = {});
        };

        var u = function () {
          var b = B + R;
          var a = C ? 0 : g;
          y(d) && O && ("center" === L || "right" === L) && (b += {
            center: .5,
            right: 1
          }[L] * (d - O.width));
          if (b !== F.x || a !== F.y) F.attr("x", b), F.hasBoxWidthChanged && (O = F.getBBox(!0), ba()), "undefined" !== typeof a && F.attr("y", a);
          F.x = b;
          F.y = a;
        };

        var Y = function (b, a) {
          z ? z.attr(b, a) : t[b] = a;
        };

        v.onAdd = function () {
          F.add(v);
          v.attr({
            text: b || 0 === b ? b : "",
            x: a,
            y: f
          });
          z && y(p) && v.attr({
            anchorX: p,
            anchorY: e
          });
        };

        v.widthSetter = function (b) {
          d = P(b) ? b : null;
        };

        v.heightSetter = function (b) {
          N = b;
        };

        v["text-alignSetter"] = function (b) {
          L = b;
        };

        v.paddingSetter = function (b) {
          y(b) && b !== R && (R = v.padding = b, u());
        };

        v.paddingLeftSetter = function (b) {
          y(b) && b !== B && (B = b, u());
        };

        v.alignSetter = function (b) {
          b = {
            left: 0,
            center: .5,
            right: 1
          }[b];
          b !== q && (q = b, O && v.attr({
            x: X
          }));
        };

        v.textSetter = function (b) {
          "undefined" !== typeof b && F.attr({
            text: b
          });
          ba();
          u();
        };

        v["stroke-widthSetter"] = function (b, a) {
          b && (H = !0);
          T = this["stroke-width"] = b;
          Y(a, b);
        };

        w ? v.rSetter = function (b, a) {
          Y(a, b);
        } : v.strokeSetter = v.fillSetter = v.rSetter = function (b, a) {
          "r" !== a && ("fill" === a && b && (H = !0), v[a] = b);
          Y(a, b);
        };

        v.anchorXSetter = function (b, a) {
          p = v.anchorX = b;
          Y(a, Math.round(b) - K() - X);
        };

        v.anchorYSetter = function (b, a) {
          e = v.anchorY = b;
          Y(a, b - V);
        };

        v.xSetter = function (b) {
          v.x = b;
          q && (b -= q * ((d || O.width) + 2 * R), v["forceAnimate:x"] = !0);
          X = Math.round(b);
          v.attr("translateX", X);
        };

        v.ySetter = function (b) {
          V = v.y = Math.round(b);
          v.attr("translateY", V);
        };

        var D = v.css;
        x = {
          css: function (b) {
            if (b) {
              var a = {};
              b = k(b);
              v.textProps.forEach(function (f) {
                "undefined" !== typeof b[f] && (a[f] = b[f], delete b[f]);
              });
              F.css(a);
              "width" in a && ba();
              "fontSize" in a && (ba(), u());
            }

            return D.call(v, b);
          },
          getBBox: function () {
            return {
              width: O.width + 2 * R,
              height: O.height + 2 * R,
              x: O.x - R,
              y: O.y - R
            };
          },
          destroy: function () {
            l(v.element, "mouseenter");
            l(v.element, "mouseleave");
            F && (F = F.destroy());
            z && (z = z.destroy());
            U.prototype.destroy.call(v);
            v = m = ba = u = Y = null;
          }
        };
        w || (x.shadow = function (b) {
          b && (ba(), z && z.shadow(b));
          return v;
        });
        return h(v, x);
      }
    });
    d.Renderer = g;
  });
  S(r, "parts/Html.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.attr,
        u = g.createElement,
        I = g.css,
        M = g.defined,
        E = g.extend,
        A = g.pick,
        G = g.pInt,
        J = d.isFirefox,
        y = d.isMS,
        t = d.isWebKit,
        D = d.SVGElement;
    g = d.SVGRenderer;
    var h = d.win;
    E(D.prototype, {
      htmlCss: function (d) {
        var q = "SPAN" === this.element.tagName && d && "width" in d,
            N = A(q && d.width, void 0);

        if (q) {
          delete d.width;
          this.textWidth = N;
          var e = !0;
        }

        d && "ellipsis" === d.textOverflow && (d.whiteSpace = "nowrap", d.overflow = "hidden");
        this.styles = E(this.styles, d);
        I(this.element, d);
        e && this.htmlUpdateTransform();
        return this;
      },
      htmlGetBBox: function () {
        var d = this.element;
        return {
          x: d.offsetLeft,
          y: d.offsetTop,
          width: d.offsetWidth,
          height: d.offsetHeight
        };
      },
      htmlUpdateTransform: function () {
        if (this.added) {
          var d = this.renderer,
              q = this.element,
              h = this.translateX || 0,
              e = this.translateY || 0,
              c = this.x || 0,
              k = this.y || 0,
              n = this.textAlign || "left",
              f = {
            left: 0,
            center: .5,
            right: 1
          }[n],
              a = this.styles,
              l = a && a.whiteSpace;
          I(q, {
            marginLeft: h,
            marginTop: e
          });
          !d.styledMode && this.shadows && this.shadows.forEach(function (a) {
            I(a, {
              marginLeft: h + 1,
              marginTop: e + 1
            });
          });
          this.inverted && [].forEach.call(q.childNodes, function (a) {
            d.invertChild(a, q);
          });

          if ("SPAN" === q.tagName) {
            a = this.rotation;
            var v = this.textWidth && G(this.textWidth),
                z = [a, n, q.innerHTML, this.textWidth, this.textAlign].join(),
                w;
            (w = v !== this.oldTextWidth) && !(w = v > this.oldTextWidth) && ((w = this.textPxLength) || (I(q, {
              width: "",
              whiteSpace: l || "nowrap"
            }), w = q.offsetWidth), w = w > v);
            w && (/[ \-]/.test(q.textContent || q.innerText) || "ellipsis" === q.style.textOverflow) ? (I(q, {
              width: v + "px",
              display: "block",
              whiteSpace: l || "normal"
            }), this.oldTextWidth = v, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;
            z !== this.cTT && (l = d.fontMetrics(q.style.fontSize, q).b, !M(a) || a === (this.oldRotation || 0) && n === this.oldAlign || this.setSpanRotation(a, f, l), this.getSpanCorrection(!M(a) && this.textPxLength || q.offsetWidth, l, f, a, n));
            I(q, {
              left: c + (this.xCorr || 0) + "px",
              top: k + (this.yCorr || 0) + "px"
            });
            this.cTT = z;
            this.oldRotation = a;
            this.oldAlign = n;
          }
        } else this.alignOnAdd = !0;
      },
      setSpanRotation: function (d, q, h) {
        var e = {},
            c = this.renderer.getTransformKey();
        e[c] = e.transform = "rotate(" + d + "deg)";
        e[c + (J ? "Origin" : "-origin")] = e.transformOrigin = 100 * q + "% " + h + "px";
        I(this.element, e);
      },
      getSpanCorrection: function (d, q, h) {
        this.xCorr = -d * h;
        this.yCorr = -q;
      }
    });
    E(g.prototype, {
      getTransformKey: function () {
        return y && !/Edge/.test(h.navigator.userAgent) ? "-ms-transform" : t ? "-webkit-transform" : J ? "MozTransform" : h.opera ? "-o-transform" : "";
      },
      html: function (d, q, h) {
        var e = this.createElement("span"),
            c = e.element,
            k = e.renderer,
            n = k.isSVG,
            f = function (a, f) {
          ["opacity", "visibility"].forEach(function (c) {
            a[c + "Setter"] = function (e, l, k) {
              var v = a.div ? a.div.style : f;
              D.prototype[c + "Setter"].call(this, e, l, k);
              v && (v[l] = e);
            };
          });
          a.addedSetters = !0;
        };

        e.textSetter = function (a) {
          a !== c.innerHTML && (delete this.bBox, delete this.oldTextWidth);
          this.textStr = a;
          c.innerHTML = A(a, "");
          e.doTransform = !0;
        };

        n && f(e, e.element.style);

        e.xSetter = e.ySetter = e.alignSetter = e.rotationSetter = function (a, f) {
          "align" === f && (f = "textAlign");
          e[f] = a;
          e.doTransform = !0;
        };

        e.afterSetters = function () {
          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
        };

        e.attr({
          text: d,
          x: Math.round(q),
          y: Math.round(h)
        }).css({
          position: "absolute"
        });
        k.styledMode || e.css({
          fontFamily: this.style.fontFamily,
          fontSize: this.style.fontSize
        });
        c.style.whiteSpace = "nowrap";
        e.css = e.htmlCss;
        n && (e.add = function (a) {
          var l = k.box.parentNode,
              v = [];

          if (this.parentGroup = a) {
            var n = a.div;

            if (!n) {
              for (; a;) v.push(a), a = a.parentGroup;

              v.reverse().forEach(function (a) {
                function c(f, c) {
                  a[c] = f;
                  "translateX" === c ? w.left = f + "px" : w.top = f + "px";
                  a.doTransform = !0;
                }

                var k = r(a.element, "class");
                n = a.div = a.div || u("div", k ? {
                  className: k
                } : void 0, {
                  position: "absolute",
                  left: (a.translateX || 0) + "px",
                  top: (a.translateY || 0) + "px",
                  display: a.display,
                  opacity: a.opacity,
                  pointerEvents: a.styles && a.styles.pointerEvents
                }, n || l);
                var w = n.style;
                E(a, {
                  classSetter: function (a) {
                    return function (f) {
                      this.element.setAttribute("class", f);
                      a.className = f;
                    };
                  }(n),
                  on: function () {
                    v[0].div && e.on.apply({
                      element: v[0].div
                    }, arguments);
                    return a;
                  },
                  translateXSetter: c,
                  translateYSetter: c
                });
                a.addedSetters || f(a);
              });
            }
          } else n = l;

          n.appendChild(c);
          e.added = !0;
          e.alignOnAdd && e.htmlUpdateTransform();
          return e;
        });
        return e;
      }
    });
  });
  S(r, "parts/Tick.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.clamp,
        u = g.correctFloat,
        I = g.defined,
        M = g.destroyObjectProperties,
        E = g.extend,
        A = g.isNumber,
        G = g.merge,
        J = g.objectEach,
        y = g.pick,
        t = d.fireEvent,
        D = d.deg2rad;

    g = function () {
      function h(d, q, h, e, c) {
        this.isNewLabel = this.isNew = !0;
        this.axis = d;
        this.pos = q;
        this.type = h || "";
        this.parameters = c || {};
        this.tickmarkOffset = this.parameters.tickmarkOffset;
        this.options = this.parameters.options;
        h || e || this.addLabel();
      }

      h.prototype.addLabel = function () {
        var d = this,
            q = d.axis,
            h = q.options,
            e = q.chart,
            c = q.categories,
            k = q.names,
            n = d.pos,
            f = y(d.options && d.options.labels, h.labels),
            a = q.tickPositions,
            l = n === a[0],
            v = n === a[a.length - 1];
        k = this.parameters.category || (c ? y(c[n], k[n], n) : n);
        var z = d.label;
        c = (!f.step || 1 === f.step) && 1 === q.tickInterval;
        a = a.info;
        var w, B;

        if (q.isDatetimeAxis && a) {
          var L = e.time.resolveDTLFormat(h.dateTimeLabelFormats[!h.grid && a.higherRanks[n] || a.unitName]);
          var t = L.main;
        }

        d.isFirst = l;
        d.isLast = v;
        d.formatCtx = {
          axis: q,
          chart: e,
          isFirst: l,
          isLast: v,
          dateTimeLabelFormat: t,
          tickPositionInfo: a,
          value: q.isLog ? u(q.lin2log(k)) : k,
          pos: n
        };
        h = q.labelFormatter.call(d.formatCtx, this.formatCtx);
        if (B = L && L.list) d.shortenLabel = function () {
          for (w = 0; w < B.length; w++) if (z.attr({
            text: q.labelFormatter.call(E(d.formatCtx, {
              dateTimeLabelFormat: B[w]
            }))
          }), z.getBBox().width < q.getSlotWidth(d) - 2 * y(f.padding, 5)) return;

          z.attr({
            text: ""
          });
        };
        c && q._addedPlotLB && q.isXAxis && d.moveLabel(h, f);
        I(z) || d.movedLabel ? z && z.textStr !== h && !c && (!z.textWidth || f.style && f.style.width || z.styles.width || z.css({
          width: null
        }), z.attr({
          text: h
        }), z.textPxLength = z.getBBox().width) : (d.label = z = d.createLabel({
          x: 0,
          y: 0
        }, h, f), d.rotation = 0);
      };

      h.prototype.createLabel = function (d, q, h) {
        var e = this.axis,
            c = e.chart;
        if (d = I(q) && h.enabled ? c.renderer.text(q, d.x, d.y, h.useHTML).add(e.labelGroup) : null) c.styledMode || d.css(G(h.style)), d.textPxLength = d.getBBox().width;
        return d;
      };

      h.prototype.destroy = function () {
        M(this, this.axis);
      };

      h.prototype.getPosition = function (d, q, h, e) {
        var c = this.axis,
            k = c.chart,
            n = e && k.oldChartHeight || k.chartHeight;
        d = {
          x: d ? u(c.translate(q + h, null, null, e) + c.transB) : c.left + c.offset + (c.opposite ? (e && k.oldChartWidth || k.chartWidth) - c.right - c.left : 0),
          y: d ? n - c.bottom + c.offset - (c.opposite ? c.height : 0) : u(n - c.translate(q + h, null, null, e) - c.transB)
        };
        d.y = r(d.y, -1E5, 1E5);
        t(this, "afterGetPosition", {
          pos: d
        });
        return d;
      };

      h.prototype.getLabelPosition = function (d, q, h, e, c, k, n, f) {
        var a = this.axis,
            l = a.transA,
            v = a.isLinked && a.linkedParent ? a.linkedParent.reversed : a.reversed,
            z = a.staggerLines,
            w = a.tickRotCorr || {
          x: 0,
          y: 0
        },
            B = c.y,
            L = e || a.reserveSpaceDefault ? 0 : -a.labelOffset * ("center" === a.labelAlign ? .5 : 1),
            N = {};
        I(B) || (B = 0 === a.side ? h.rotation ? -8 : -h.getBBox().height : 2 === a.side ? w.y + 8 : Math.cos(h.rotation * D) * (w.y - h.getBBox(!1, 0).height / 2));
        d = d + c.x + L + w.x - (k && e ? k * l * (v ? -1 : 1) : 0);
        q = q + B - (k && !e ? k * l * (v ? 1 : -1) : 0);
        z && (h = n / (f || 1) % z, a.opposite && (h = z - h - 1), q += a.labelOffset / z * h);
        N.x = d;
        N.y = Math.round(q);
        t(this, "afterGetLabelPosition", {
          pos: N,
          tickmarkOffset: k,
          index: n
        });
        return N;
      };

      h.prototype.getLabelSize = function () {
        return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
      };

      h.prototype.getMarkPath = function (d, q, h, e, c, k) {
        return k.crispLine(["M", d, q, "L", d + (c ? 0 : -h), q + (c ? h : 0)], e);
      };

      h.prototype.handleOverflow = function (d) {
        var q = this.axis,
            h = q.options.labels,
            e = d.x,
            c = q.chart.chartWidth,
            k = q.chart.spacing,
            n = y(q.labelLeft, Math.min(q.pos, k[3]));
        k = y(q.labelRight, Math.max(q.isRadial ? 0 : q.pos + q.len, c - k[1]));
        var f = this.label,
            a = this.rotation,
            l = {
          left: 0,
          center: .5,
          right: 1
        }[q.labelAlign || f.attr("align")],
            v = f.getBBox().width,
            z = q.getSlotWidth(this),
            w = z,
            B = 1,
            L,
            t = {};
        if (a || "justify" !== y(h.overflow, "justify")) 0 > a && e - l * v < n ? L = Math.round(e / Math.cos(a * D) - n) : 0 < a && e + l * v > k && (L = Math.round((c - e) / Math.cos(a * D)));else if (c = e + (1 - l) * v, e - l * v < n ? w = d.x + w * (1 - l) - n : c > k && (w = k - d.x + w * l, B = -1), w = Math.min(z, w), w < z && "center" === q.labelAlign && (d.x += B * (z - w - l * (z - Math.min(v, w)))), v > w || q.autoRotation && (f.styles || {}).width) L = w;
        L && (this.shortenLabel ? this.shortenLabel() : (t.width = Math.floor(L), (h.style || {}).textOverflow || (t.textOverflow = "ellipsis"), f.css(t)));
      };

      h.prototype.moveLabel = function (d, q) {
        var h = this,
            e = h.label,
            c = !1,
            k = h.axis,
            n = k.reversed,
            f = k.chart.inverted;
        e && e.textStr === d ? (h.movedLabel = e, c = !0, delete h.label) : J(k.ticks, function (a) {
          c || a.isNew || a === h || !a.label || a.label.textStr !== d || (h.movedLabel = a.label, c = !0, a.labelPos = h.movedLabel.xy, delete a.label);
        });

        if (!c && (h.labelPos || e)) {
          var a = h.labelPos || e.xy;
          e = f ? a.x : n ? 0 : k.width + k.left;
          k = f ? n ? k.width + k.left : 0 : a.y;
          h.movedLabel = h.createLabel({
            x: e,
            y: k
          }, d, q);
          h.movedLabel && h.movedLabel.attr({
            opacity: 0
          });
        }
      };

      h.prototype.render = function (h, q, t) {
        var e = this.axis,
            c = e.horiz,
            k = this.pos,
            n = y(this.tickmarkOffset, e.tickmarkOffset);
        k = this.getPosition(c, k, n, q);
        n = k.x;
        var f = k.y;
        e = c && n === e.pos + e.len || !c && f === e.pos ? -1 : 1;
        t = y(t, 1);
        this.isActive = !0;
        this.renderGridLine(q, t, e);
        this.renderMark(k, t, e);
        this.renderLabel(k, q, t, h);
        this.isNew = !1;
        d.fireEvent(this, "afterRender");
      };

      h.prototype.renderGridLine = function (d, q, h) {
        var e = this.axis,
            c = e.options,
            k = this.gridLine,
            n = {},
            f = this.pos,
            a = this.type,
            l = y(this.tickmarkOffset, e.tickmarkOffset),
            v = e.chart.renderer,
            z = a ? a + "Grid" : "grid",
            w = c[z + "LineWidth"],
            B = c[z + "LineColor"];
        c = c[z + "LineDashStyle"];
        k || (e.chart.styledMode || (n.stroke = B, n["stroke-width"] = w, c && (n.dashstyle = c)), a || (n.zIndex = 1), d && (q = 0), this.gridLine = k = v.path().attr(n).addClass("highcharts-" + (a ? a + "-" : "") + "grid-line").add(e.gridGroup));
        if (k && (h = e.getPlotLinePath({
          value: f + l,
          lineWidth: k.strokeWidth() * h,
          force: "pass",
          old: d
        }))) k[d || this.isNew ? "attr" : "animate"]({
          d: h,
          opacity: q
        });
      };

      h.prototype.renderMark = function (d, q, h) {
        var e = this.axis,
            c = e.options,
            k = e.chart.renderer,
            n = this.type,
            f = n ? n + "Tick" : "tick",
            a = e.tickSize(f),
            l = this.mark,
            v = !l,
            z = d.x;
        d = d.y;
        var w = y(c[f + "Width"], !n && e.isXAxis ? 1 : 0);
        c = c[f + "Color"];
        a && (e.opposite && (a[0] = -a[0]), v && (this.mark = l = k.path().addClass("highcharts-" + (n ? n + "-" : "") + "tick").add(e.axisGroup), e.chart.styledMode || l.attr({
          stroke: c,
          "stroke-width": w
        })), l[v ? "attr" : "animate"]({
          d: this.getMarkPath(z, d, a[0], l.strokeWidth() * h, e.horiz, k),
          opacity: q
        }));
      };

      h.prototype.renderLabel = function (d, q, h, e) {
        var c = this.axis,
            k = c.horiz,
            n = c.options,
            f = this.label,
            a = n.labels,
            l = a.step;
        c = y(this.tickmarkOffset, c.tickmarkOffset);
        var v = !0,
            z = d.x;
        d = d.y;
        f && A(z) && (f.xy = d = this.getLabelPosition(z, d, f, k, a, c, e, l), this.isFirst && !this.isLast && !y(n.showFirstLabel, 1) || this.isLast && !this.isFirst && !y(n.showLastLabel, 1) ? v = !1 : !k || a.step || a.rotation || q || 0 === h || this.handleOverflow(d), l && e % l && (v = !1), v && A(d.y) ? (d.opacity = h, f[this.isNewLabel ? "attr" : "animate"](d), this.isNewLabel = !1) : (f.attr("y", -9999), this.isNewLabel = !0));
      };

      h.prototype.replaceMovedLabel = function () {
        var d = this.label,
            q = this.axis,
            h = q.reversed,
            e = this.axis.chart.inverted;

        if (d && !this.isNew) {
          var c = e ? d.xy.x : h ? q.left : q.width + q.left;
          h = e ? h ? q.width + q.top : q.top : d.xy.y;
          d.animate({
            x: c,
            y: h,
            opacity: 0
          }, void 0, d.destroy);
          delete this.label;
        }

        q.isDirty = !0;
        this.label = this.movedLabel;
        delete this.movedLabel;
      };

      return h;
    }();

    d.Tick = g;
    return d.Tick;
  });
  S(r, "parts/Time.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.defined,
        u = g.error,
        I = g.extend,
        M = g.isObject,
        E = g.merge,
        A = g.objectEach,
        G = g.pad,
        J = g.pick,
        y = g.splat,
        t = g.timeUnits,
        D = d.win;

    g = function () {
      function h(d) {
        this.options = {};
        this.variableTimezone = this.useUTC = !1;
        this.Date = D.Date;
        this.getTimezoneOffset = this.timezoneOffsetFunction();
        this.update(d);
      }

      h.prototype.get = function (d, q) {
        if (this.variableTimezone || this.timezoneOffset) {
          var h = q.getTime(),
              e = h - this.getTimezoneOffset(q);
          q.setTime(e);
          d = q["getUTC" + d]();
          q.setTime(h);
          return d;
        }

        return this.useUTC ? q["getUTC" + d]() : q["get" + d]();
      };

      h.prototype.set = function (d, q, h) {
        if (this.variableTimezone || this.timezoneOffset) {
          if ("Milliseconds" === d || "Seconds" === d || "Minutes" === d) return q["setUTC" + d](h);
          var e = this.getTimezoneOffset(q);
          e = q.getTime() - e;
          q.setTime(e);
          q["setUTC" + d](h);
          d = this.getTimezoneOffset(q);
          e = q.getTime() + d;
          return q.setTime(e);
        }

        return this.useUTC ? q["setUTC" + d](h) : q["set" + d](h);
      };

      h.prototype.update = function (d) {
        var q = J(d && d.useUTC, !0);
        this.options = d = E(!0, this.options || {}, d);
        this.Date = d.Date || D.Date || Date;
        this.timezoneOffset = (this.useUTC = q) && d.timezoneOffset;
        this.getTimezoneOffset = this.timezoneOffsetFunction();
        this.variableTimezone = !(q && !d.getTimezoneOffset && !d.timezone);
      };

      h.prototype.makeTime = function (h, q, t, e, c, k) {
        if (this.useUTC) {
          var n = this.Date.UTC.apply(0, arguments);
          var f = this.getTimezoneOffset(n);
          n += f;
          var a = this.getTimezoneOffset(n);
          f !== a ? n += a - f : f - 36E5 !== this.getTimezoneOffset(n - 36E5) || d.isSafari || (n -= 36E5);
        } else n = new this.Date(h, q, J(t, 1), J(e, 0), J(c, 0), J(k, 0)).getTime();

        return n;
      };

      h.prototype.timezoneOffsetFunction = function () {
        var d = this,
            q = this.options,
            h = D.moment;
        if (!this.useUTC) return function (e) {
          return 6E4 * new Date(e.toString()).getTimezoneOffset();
        };

        if (q.timezone) {
          if (h) return function (e) {
            return 6E4 * -h.tz(e, q.timezone).utcOffset();
          };
          u(25);
        }

        return this.useUTC && q.getTimezoneOffset ? function (e) {
          return 6E4 * q.getTimezoneOffset(e.valueOf());
        } : function () {
          return 6E4 * (d.timezoneOffset || 0);
        };
      };

      h.prototype.dateFormat = function (h, q, t) {
        var e;
        if (!r(q) || isNaN(q)) return (null === (e = d.defaultOptions.lang) || void 0 === e ? void 0 : e.invalidDate) || "";
        h = J(h, "%Y-%m-%d %H:%M:%S");
        var c = this;
        e = new this.Date(q);
        var k = this.get("Hours", e),
            n = this.get("Day", e),
            f = this.get("Date", e),
            a = this.get("Month", e),
            l = this.get("FullYear", e),
            v = d.defaultOptions.lang,
            z = null === v || void 0 === v ? void 0 : v.weekdays,
            w = null === v || void 0 === v ? void 0 : v.shortWeekdays;
        e = I({
          a: w ? w[n] : z[n].substr(0, 3),
          A: z[n],
          d: G(f),
          e: G(f, 2, " "),
          w: n,
          b: v.shortMonths[a],
          B: v.months[a],
          m: G(a + 1),
          o: a + 1,
          y: l.toString().substr(2, 2),
          Y: l,
          H: G(k),
          k: k,
          I: G(k % 12 || 12),
          l: k % 12 || 12,
          M: G(this.get("Minutes", e)),
          p: 12 > k ? "AM" : "PM",
          P: 12 > k ? "am" : "pm",
          S: G(e.getSeconds()),
          L: G(Math.floor(q % 1E3), 3)
        }, d.dateFormats);
        A(e, function (a, f) {
          for (; -1 !== h.indexOf("%" + f);) h = h.replace("%" + f, "function" === typeof a ? a.call(c, q) : a);
        });
        return t ? h.substr(0, 1).toUpperCase() + h.substr(1) : h;
      };

      h.prototype.resolveDTLFormat = function (d) {
        return M(d, !0) ? d : (d = y(d), {
          main: d[0],
          from: d[1],
          to: d[2]
        });
      };

      h.prototype.getTimeTicks = function (d, h, g, e) {
        var c = this,
            k = [],
            n = {};
        var f = new c.Date(h);
        var a = d.unitRange,
            l = d.count || 1,
            v;
        e = J(e, 1);

        if (r(h)) {
          c.set("Milliseconds", f, a >= t.second ? 0 : l * Math.floor(c.get("Milliseconds", f) / l));
          a >= t.second && c.set("Seconds", f, a >= t.minute ? 0 : l * Math.floor(c.get("Seconds", f) / l));
          a >= t.minute && c.set("Minutes", f, a >= t.hour ? 0 : l * Math.floor(c.get("Minutes", f) / l));
          a >= t.hour && c.set("Hours", f, a >= t.day ? 0 : l * Math.floor(c.get("Hours", f) / l));
          a >= t.day && c.set("Date", f, a >= t.month ? 1 : Math.max(1, l * Math.floor(c.get("Date", f) / l)));

          if (a >= t.month) {
            c.set("Month", f, a >= t.year ? 0 : l * Math.floor(c.get("Month", f) / l));
            var z = c.get("FullYear", f);
          }

          a >= t.year && c.set("FullYear", f, z - z % l);
          a === t.week && (z = c.get("Day", f), c.set("Date", f, c.get("Date", f) - z + e + (z < e ? -7 : 0)));
          z = c.get("FullYear", f);
          e = c.get("Month", f);
          var w = c.get("Date", f),
              q = c.get("Hours", f);
          h = f.getTime();
          c.variableTimezone && (v = g - h > 4 * t.month || c.getTimezoneOffset(h) !== c.getTimezoneOffset(g));
          h = f.getTime();

          for (f = 1; h < g;) k.push(h), h = a === t.year ? c.makeTime(z + f * l, 0) : a === t.month ? c.makeTime(z, e + f * l) : !v || a !== t.day && a !== t.week ? v && a === t.hour && 1 < l ? c.makeTime(z, e, w, q + f * l) : h + a * l : c.makeTime(z, e, w + f * l * (a === t.day ? 1 : 7)), f++;

          k.push(h);
          a <= t.hour && 1E4 > k.length && k.forEach(function (a) {
            0 === a % 18E5 && "000000000" === c.dateFormat("%H%M%S%L", a) && (n[a] = "day");
          });
        }

        k.info = I(d, {
          higherRanks: n,
          totalRange: a * l
        });
        return k;
      };

      h.defaultOptions = {
        Date: void 0,
        getTimezoneOffset: void 0,
        timezone: void 0,
        timezoneOffset: 0,
        useUTC: !0
      };
      return h;
    }();

    d.Time = g;
    return d.Time;
  });
  S(r, "parts/Options.js", [r["parts/Globals.js"], r["parts/Time.js"], r["parts/Color.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    r = r.parse;
    var I = u.merge;
    d.defaultOptions = {
      colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),
      symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
      lang: {
        loading: "Loading...",
        months: "January February March April May June July August September October November December".split(" "),
        shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
        weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
        decimalPoint: ".",
        numericSymbols: "kMGTPE".split(""),
        resetZoom: "Reset zoom",
        resetZoomTitle: "Reset zoom level 1:1",
        thousandsSep: " "
      },
      global: {},
      time: g.defaultOptions,
      chart: {
        styledMode: !1,
        borderRadius: 0,
        colorCount: 10,
        defaultSeriesType: "line",
        ignoreHiddenSeries: !0,
        spacing: [10, 10, 15, 10],
        resetZoomButton: {
          theme: {
            zIndex: 6
          },
          position: {
            align: "right",
            x: -10,
            y: 10
          }
        },
        width: null,
        height: null,
        borderColor: "#335cad",
        backgroundColor: "#ffffff",
        plotBorderColor: "#cccccc"
      },
      title: {
        text: "Chart title",
        align: "center",
        margin: 15,
        widthAdjust: -44
      },
      subtitle: {
        text: "",
        align: "center",
        widthAdjust: -44
      },
      caption: {
        margin: 15,
        text: "",
        align: "left",
        verticalAlign: "bottom"
      },
      plotOptions: {},
      labels: {
        style: {
          position: "absolute",
          color: "#333333"
        }
      },
      legend: {
        enabled: !0,
        align: "center",
        alignColumns: !0,
        layout: "horizontal",
        labelFormatter: function () {
          return this.name;
        },
        borderColor: "#999999",
        borderRadius: 0,
        navigation: {
          activeColor: "#003399",
          inactiveColor: "#cccccc"
        },
        itemStyle: {
          color: "#333333",
          cursor: "pointer",
          fontSize: "12px",
          fontWeight: "bold",
          textOverflow: "ellipsis"
        },
        itemHoverStyle: {
          color: "#000000"
        },
        itemHiddenStyle: {
          color: "#cccccc"
        },
        shadow: !1,
        itemCheckboxStyle: {
          position: "absolute",
          width: "13px",
          height: "13px"
        },
        squareSymbol: !0,
        symbolPadding: 5,
        verticalAlign: "bottom",
        x: 0,
        y: 0,
        title: {
          style: {
            fontWeight: "bold"
          }
        }
      },
      loading: {
        labelStyle: {
          fontWeight: "bold",
          position: "relative",
          top: "45%"
        },
        style: {
          position: "absolute",
          backgroundColor: "#ffffff",
          opacity: .5,
          textAlign: "center"
        }
      },
      tooltip: {
        enabled: !0,
        animation: d.svg,
        borderRadius: 3,
        dateTimeLabelFormats: {
          millisecond: "%A, %b %e, %H:%M:%S.%L",
          second: "%A, %b %e, %H:%M:%S",
          minute: "%A, %b %e, %H:%M",
          hour: "%A, %b %e, %H:%M",
          day: "%A, %b %e, %Y",
          week: "Week from %A, %b %e, %Y",
          month: "%B %Y",
          year: "%Y"
        },
        footerFormat: "",
        padding: 8,
        snap: d.isTouchDevice ? 25 : 10,
        headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
        pointFormat: '<span style="color:{point.color}">\u25cf</span> {series.name}: <b>{point.y}</b><br/>',
        backgroundColor: r("#f7f7f7").setOpacity(.85).get(),
        borderWidth: 1,
        shadow: !0,
        style: {
          color: "#333333",
          cursor: "default",
          fontSize: "12px",
          whiteSpace: "nowrap"
        }
      },
      credits: {
        enabled: !0,
        href: "https://www.highcharts.com?credits",
        position: {
          align: "right",
          x: -10,
          verticalAlign: "bottom",
          y: -5
        },
        style: {
          cursor: "pointer",
          color: "#999999",
          fontSize: "9px"
        },
        text: "Highcharts.com"
      }
    };

    d.setOptions = function (g) {
      d.defaultOptions = I(!0, d.defaultOptions, g);
      (g.time || g.global) && d.time.update(I(d.defaultOptions.global, d.defaultOptions.time, g.global, g.time));
      return d.defaultOptions;
    };

    d.getOptions = function () {
      return d.defaultOptions;
    };

    d.defaultPlotOptions = d.defaultOptions.plotOptions;
    d.time = new g(I(d.defaultOptions.global, d.defaultOptions.time));

    d.dateFormat = function (g, u, A) {
      return d.time.dateFormat(g, u, A);
    };

    "";
  });
  S(r, "parts/Axis.js", [r["parts/Globals.js"], r["parts/Color.js"], r["parts/Tick.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    var I = g.parse,
        M = u.addEvent,
        E = u.animObject,
        A = u.arrayMax,
        G = u.arrayMin,
        J = u.clamp,
        y = u.correctFloat,
        t = u.defined,
        D = u.destroyObjectProperties,
        h = u.error,
        N = u.extend,
        q = u.fireEvent,
        P = u.format,
        e = u.getMagnitude,
        c = u.isArray,
        k = u.isFunction,
        n = u.isNumber,
        f = u.isString,
        a = u.merge,
        l = u.normalizeTickInterval,
        v = u.objectEach,
        z = u.pick,
        w = u.relativeLength,
        B = u.removeEvent,
        L = u.splat,
        Q = u.syncTimeout,
        H = d.defaultOptions,
        K = d.deg2rad;

    g = function () {
      this.init.apply(this, arguments);
    };

    N(g.prototype, {
      defaultOptions: {
        dateTimeLabelFormats: {
          millisecond: {
            main: "%H:%M:%S.%L",
            range: !1
          },
          second: {
            main: "%H:%M:%S",
            range: !1
          },
          minute: {
            main: "%H:%M",
            range: !1
          },
          hour: {
            main: "%H:%M",
            range: !1
          },
          day: {
            main: "%e. %b"
          },
          week: {
            main: "%e. %b"
          },
          month: {
            main: "%b '%y"
          },
          year: {
            main: "%Y"
          }
        },
        endOnTick: !1,
        labels: {
          enabled: !0,
          indentation: 10,
          x: 0,
          style: {
            color: "#666666",
            cursor: "default",
            fontSize: "11px"
          }
        },
        maxPadding: .01,
        minorTickLength: 2,
        minorTickPosition: "outside",
        minPadding: .01,
        showEmpty: !0,
        startOfWeek: 1,
        startOnTick: !1,
        tickLength: 10,
        tickPixelInterval: 100,
        tickmarkPlacement: "between",
        tickPosition: "outside",
        title: {
          align: "middle",
          style: {
            color: "#666666"
          }
        },
        type: "linear",
        minorGridLineColor: "#f2f2f2",
        minorGridLineWidth: 1,
        minorTickColor: "#999999",
        lineColor: "#ccd6eb",
        lineWidth: 1,
        gridLineColor: "#e6e6e6",
        tickColor: "#ccd6eb"
      },
      defaultYAxisOptions: {
        endOnTick: !0,
        maxPadding: .05,
        minPadding: .05,
        tickPixelInterval: 72,
        showLastLabel: !0,
        labels: {
          x: -8
        },
        startOnTick: !0,
        title: {
          rotation: 270,
          text: "Values"
        },
        stackLabels: {
          allowOverlap: !1,
          enabled: !1,
          crop: !0,
          overflow: "justify",
          formatter: function () {
            var a = this.axis.chart.numberFormatter;
            return a(this.total, -1);
          },
          style: {
            color: "#000000",
            fontSize: "11px",
            fontWeight: "bold",
            textOutline: "1px contrast"
          }
        },
        gridLineWidth: 1,
        lineWidth: 0
      },
      defaultLeftAxisOptions: {
        labels: {
          x: -15
        },
        title: {
          rotation: 270
        }
      },
      defaultRightAxisOptions: {
        labels: {
          x: 15
        },
        title: {
          rotation: 90
        }
      },
      defaultBottomAxisOptions: {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        margin: 15,
        title: {
          rotation: 0
        }
      },
      defaultTopAxisOptions: {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        margin: 15,
        title: {
          rotation: 0
        }
      },
      init: function (a, b) {
        var f = b.isX,
            c = this;
        c.chart = a;
        c.horiz = a.inverted && !c.isZAxis ? !f : f;
        c.isXAxis = f;
        c.coll = c.coll || (f ? "xAxis" : "yAxis");
        q(this, "init", {
          userOptions: b
        });
        c.opposite = b.opposite;
        c.side = b.side || (c.horiz ? c.opposite ? 0 : 2 : c.opposite ? 1 : 3);
        c.setOptions(b);
        var p = this.options,
            e = p.type;
        c.labelFormatter = p.labels.formatter || c.defaultLabelFormatter;
        c.userOptions = b;
        c.minPixelPadding = 0;
        c.reversed = p.reversed;
        c.visible = !1 !== p.visible;
        c.zoomEnabled = !1 !== p.zoomEnabled;
        c.hasNames = "category" === e || !0 === p.categories;
        c.categories = p.categories || c.hasNames;
        c.names || (c.names = [], c.names.keys = {});
        c.plotLinesAndBandsGroups = {};
        c.isLog = "logarithmic" === e;
        c.isDatetimeAxis = "datetime" === e;
        c.positiveValuesOnly = c.isLog && !c.allowNegativeLog;
        c.isLinked = t(p.linkedTo);
        c.ticks = {};
        c.labelEdge = [];
        c.minorTicks = {};
        c.plotLinesAndBands = [];
        c.alternateBands = {};
        c.len = 0;
        c.minRange = c.userMinRange = p.minRange || p.maxZoom;
        c.range = p.range;
        c.offset = p.offset || 0;
        c.stacks = {};
        c.oldStacks = {};
        c.stacksTouched = 0;
        c.max = null;
        c.min = null;
        c.crosshair = z(p.crosshair, L(a.options.tooltip.crosshairs)[f ? 0 : 1], !1);
        b = c.options.events;
        -1 === a.axes.indexOf(c) && (f ? a.axes.splice(a.xAxis.length, 0, c) : a.axes.push(c), a[c.coll].push(c));
        c.series = c.series || [];
        a.inverted && !c.isZAxis && f && "undefined" === typeof c.reversed && (c.reversed = !0);
        v(b, function (b, a) {
          k(b) && M(c, a, b);
        });
        c.lin2log = p.linearToLogConverter || c.lin2log;
        c.isLog && (c.val2lin = c.log2lin, c.lin2val = c.lin2log);
        q(this, "afterInit");
      },
      setOptions: function (c) {
        this.options = a(this.defaultOptions, "yAxis" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], a(H[this.coll], c));
        q(this, "afterSetOptions", {
          userOptions: c
        });
      },
      defaultLabelFormatter: function () {
        var a = this.axis,
            b = this.value,
            c = a.chart.time,
            f = a.categories,
            e = this.dateTimeLabelFormat,
            l = H.lang,
            k = l.numericSymbols;
        l = l.numericSymbolMagnitude || 1E3;
        var v = k && k.length,
            m = a.options.labels.format;
        a = a.isLog ? Math.abs(b) : a.tickInterval;
        var n = this.chart,
            d = n.numberFormatter;
        if (m) var w = P(m, this, n);else if (f) w = b;else if (e) w = c.dateFormat(e, b);else if (v && 1E3 <= a) for (; v-- && "undefined" === typeof w;) c = Math.pow(l, v + 1), a >= c && 0 === 10 * b % c && null !== k[v] && 0 !== b && (w = d(b / c, -1) + k[v]);
        "undefined" === typeof w && (w = 1E4 <= Math.abs(b) ? d(b, -1) : d(b, -1, void 0, ""));
        return w;
      },
      getSeriesExtremes: function () {
        var a = this,
            b = a.chart,
            c;
        q(this, "getSeriesExtremes", null, function () {
          a.hasVisibleSeries = !1;
          a.dataMin = a.dataMax = a.threshold = null;
          a.softThreshold = !a.isXAxis;
          a.buildStacks && a.buildStacks();
          a.series.forEach(function (f) {
            if (f.visible || !b.options.chart.ignoreHiddenSeries) {
              var e = f.options,
                  p = e.threshold;
              a.hasVisibleSeries = !0;
              a.positiveValuesOnly && 0 >= p && (p = null);

              if (a.isXAxis) {
                if (e = f.xData, e.length) {
                  c = f.getXExtremes(e);
                  var x = c.min;
                  var l = c.max;
                  n(x) || x instanceof Date || (e = e.filter(n), c = f.getXExtremes(e), x = c.min, l = c.max);
                  e.length && (a.dataMin = Math.min(z(a.dataMin, x), x), a.dataMax = Math.max(z(a.dataMax, l), l));
                }
              } else if (f.getExtremes(), l = f.dataMax, x = f.dataMin, t(x) && t(l) && (a.dataMin = Math.min(z(a.dataMin, x), x), a.dataMax = Math.max(z(a.dataMax, l), l)), t(p) && (a.threshold = p), !e.softThreshold || a.positiveValuesOnly) a.softThreshold = !1;
            }
          });
        });
        q(this, "afterGetSeriesExtremes");
      },
      translate: function (a, b, c, f, e, l) {
        var p = this.linkedParent || this,
            x = 1,
            m = 0,
            C = f ? p.oldTransA : p.transA;
        f = f ? p.oldMin : p.min;
        var k = p.minPixelPadding;
        e = (p.isOrdinal || p.isBroken || p.isLog && e) && p.lin2val;
        C || (C = p.transA);
        c && (x *= -1, m = p.len);
        p.reversed && (x *= -1, m -= x * (p.sector || p.len));
        b ? (a = (a * x + m - k) / C + f, e && (a = p.lin2val(a))) : (e && (a = p.val2lin(a)), a = n(f) ? x * (a - f) * C + m + x * k + (n(l) ? C * l : 0) : void 0);
        return a;
      },
      toPixels: function (a, b) {
        return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);
      },
      toValue: function (a, b) {
        return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);
      },
      getPlotLinePath: function (a) {
        var b = this,
            c = b.chart,
            f = b.left,
            e = b.top,
            p = a.old,
            l = a.value,
            k = a.translatedValue,
            m = a.lineWidth,
            v = a.force,
            d,
            w,
            F,
            h,
            B = p && c.oldChartHeight || c.chartHeight,
            L = p && c.oldChartWidth || c.chartWidth,
            t,
            g = b.transB,
            H = function (b, a, c) {
          if ("pass" !== v && b < a || b > c) v ? b = J(b, a, c) : t = !0;
          return b;
        };

        a = {
          value: l,
          lineWidth: m,
          old: p,
          force: v,
          acrossPanes: a.acrossPanes,
          translatedValue: k
        };
        q(this, "getPlotLinePath", a, function (a) {
          k = z(k, b.translate(l, null, null, p));
          k = J(k, -1E5, 1E5);
          d = F = Math.round(k + g);
          w = h = Math.round(B - k - g);
          n(k) ? b.horiz ? (w = e, h = B - b.bottom, d = F = H(d, f, f + b.width)) : (d = f, F = L - b.right, w = h = H(w, e, e + b.height)) : (t = !0, v = !1);
          a.path = t && !v ? null : c.renderer.crispLine(["M", d, w, "L", F, h], m || 1);
        });
        return a.path;
      },
      getLinearTickPositions: function (a, b, c) {
        var f = y(Math.floor(b / a) * a);
        c = y(Math.ceil(c / a) * a);
        var e = [],
            p;
        y(f + a) === f && (p = 20);
        if (this.single) return [b];

        for (b = f; b <= c;) {
          e.push(b);
          b = y(b + a, p);
          if (b === l) break;
          var l = b;
        }

        return e;
      },
      getMinorTickInterval: function () {
        var a = this.options;
        return !0 === a.minorTicks ? z(a.minorTickInterval, "auto") : !1 === a.minorTicks ? null : a.minorTickInterval;
      },
      getMinorTickPositions: function () {
        var a = this,
            b = a.options,
            c = a.tickPositions,
            f = a.minorTickInterval,
            e = [],
            l = a.pointRangePadding || 0,
            k = a.min - l;
        l = a.max + l;
        var v = l - k;
        if (v && v / f < a.len / 3) if (a.isLog) this.paddedTicks.forEach(function (b, c, p) {
          c && e.push.apply(e, a.getLogTickPositions(f, p[c - 1], p[c], !0));
        });else if (a.isDatetimeAxis && "auto" === this.getMinorTickInterval()) e = e.concat(a.getTimeTicks(a.normalizeTimeTickInterval(f), k, l, b.startOfWeek));else for (b = k + (c[0] - k) % f; b <= l && b !== e[0]; b += f) e.push(b);
        0 !== e.length && a.trimTicks(e);
        return e;
      },
      adjustForMinRange: function () {
        var a = this.options,
            b = this.min,
            c = this.max,
            f,
            e,
            l,
            k,
            v;
        this.isXAxis && "undefined" === typeof this.minRange && !this.isLog && (t(a.min) || t(a.max) ? this.minRange = null : (this.series.forEach(function (b) {
          k = b.xData;

          for (e = v = b.xIncrement ? 1 : k.length - 1; 0 < e; e--) if (l = k[e] - k[e - 1], "undefined" === typeof f || l < f) f = l;
        }), this.minRange = Math.min(5 * f, this.dataMax - this.dataMin)));

        if (c - b < this.minRange) {
          var m = this.dataMax - this.dataMin >= this.minRange;
          var n = this.minRange;
          var d = (n - c + b) / 2;
          d = [b - d, z(a.min, b - d)];
          m && (d[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin);
          b = A(d);
          c = [b + n, z(a.max, b + n)];
          m && (c[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax);
          c = G(c);
          c - b < n && (d[0] = c - n, d[1] = z(a.min, c - n), b = A(d));
        }

        this.min = b;
        this.max = c;
      },
      getClosest: function () {
        var a;
        this.categories ? a = 1 : this.series.forEach(function (b) {
          var c = b.closestPointRange,
              f = b.visible || !b.chart.options.chart.ignoreHiddenSeries;
          !b.noSharedTooltip && t(c) && f && (a = t(a) ? Math.min(a, c) : c);
        });
        return a;
      },
      nameToX: function (a) {
        var b = c(this.categories),
            f = b ? this.categories : this.names,
            e = a.options.x;
        a.series.requireSorting = !1;
        t(e) || (e = !1 === this.options.uniqueNames ? a.series.autoIncrement() : b ? f.indexOf(a.name) : z(f.keys[a.name], -1));

        if (-1 === e) {
          if (!b) var p = f.length;
        } else p = e;

        "undefined" !== typeof p && (this.names[p] = a.name, this.names.keys[a.name] = p);
        return p;
      },
      updateNames: function () {
        var a = this,
            b = this.names;
        0 < b.length && (Object.keys(b.keys).forEach(function (a) {
          delete b.keys[a];
        }), b.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (b) {
          b.xIncrement = null;
          if (!b.points || b.isDirtyData) a.max = Math.max(a.max, b.xData.length - 1), b.processData(), b.generatePoints();
          b.data.forEach(function (c, f) {
            if (c && c.options && "undefined" !== typeof c.name) {
              var e = a.nameToX(c);
              "undefined" !== typeof e && e !== c.x && (c.x = e, b.xData[f] = e);
            }
          });
        }));
      },
      setAxisTranslation: function (a) {
        var b = this,
            c = b.max - b.min,
            e = b.axisPointRange || 0,
            p = 0,
            l = 0,
            k = b.linkedParent,
            v = !!b.categories,
            m = b.transA,
            d = b.isXAxis;

        if (d || v || e) {
          var n = b.getClosest();
          k ? (p = k.minPointOffset, l = k.pointRangePadding) : b.series.forEach(function (a) {
            var c = v ? 1 : d ? z(a.options.pointRange, n, 0) : b.axisPointRange || 0,
                x = a.options.pointPlacement;
            e = Math.max(e, c);
            if (!b.single || v) a = a.is("xrange") ? !d : d, p = Math.max(p, a && f(x) ? 0 : c / 2), l = Math.max(l, a && "on" === x ? 0 : c);
          });
          k = b.ordinalSlope && n ? b.ordinalSlope / n : 1;
          b.minPointOffset = p *= k;
          b.pointRangePadding = l *= k;
          b.pointRange = Math.min(e, b.single && v ? 1 : c);
          d && (b.closestPointRange = n);
        }

        a && (b.oldTransA = m);
        b.translationSlope = b.transA = m = b.staticScale || b.len / (c + l || 1);
        b.transB = b.horiz ? b.left : b.bottom;
        b.minPixelPadding = m * p;
        q(this, "afterSetAxisTranslation");
      },
      minFromRange: function () {
        return this.max - this.range;
      },
      setTickInterval: function (a) {
        var b = this,
            c = b.chart,
            f = b.options,
            p = b.isLog,
            k = b.isDatetimeAxis,
            v = b.isXAxis,
            d = b.isLinked,
            m = f.maxPadding,
            w = f.minPadding,
            B = f.tickInterval,
            L = f.tickPixelInterval,
            F = b.categories,
            V = n(b.threshold) ? b.threshold : null,
            g = b.softThreshold;
        k || F || d || this.getTickAmount();
        var H = z(b.userMin, f.min);
        var K = z(b.userMax, f.max);

        if (d) {
          b.linkedParent = c[b.coll][f.linkedTo];
          var Q = b.linkedParent.getExtremes();
          b.min = z(Q.min, Q.dataMin);
          b.max = z(Q.max, Q.dataMax);
          f.type !== b.linkedParent.options.type && h(11, 1, c);
        } else {
          if (!g && t(V)) if (b.dataMin >= V) Q = V, w = 0;else if (b.dataMax <= V) {
            var u = V;
            m = 0;
          }
          b.min = z(H, Q, b.dataMin);
          b.max = z(K, u, b.dataMax);
        }

        p && (b.positiveValuesOnly && !a && 0 >= Math.min(b.min, z(b.dataMin, b.min)) && h(10, 1, c), b.min = y(b.log2lin(b.min), 16), b.max = y(b.log2lin(b.max), 16));
        b.range && t(b.max) && (b.userMin = b.min = H = Math.max(b.dataMin, b.minFromRange()), b.userMax = K = b.max, b.range = null);
        q(b, "foundExtremes");
        b.beforePadding && b.beforePadding();
        b.adjustForMinRange();
        !(F || b.axisPointRange || b.usePercentage || d) && t(b.min) && t(b.max) && (c = b.max - b.min) && (!t(H) && w && (b.min -= c * w), !t(K) && m && (b.max += c * m));
        n(b.userMin) || (n(f.softMin) && f.softMin < b.min && (b.min = H = f.softMin), n(f.floor) && (b.min = Math.max(b.min, f.floor)));
        n(b.userMax) || (n(f.softMax) && f.softMax > b.max && (b.max = K = f.softMax), n(f.ceiling) && (b.max = Math.min(b.max, f.ceiling)));
        g && t(b.dataMin) && (V = V || 0, !t(H) && b.min < V && b.dataMin >= V ? b.min = b.options.minRange ? Math.min(V, b.max - b.minRange) : V : !t(K) && b.max > V && b.dataMax <= V && (b.max = b.options.minRange ? Math.max(V, b.min + b.minRange) : V));
        b.tickInterval = b.min === b.max || "undefined" === typeof b.min || "undefined" === typeof b.max ? 1 : d && !B && L === b.linkedParent.options.tickPixelInterval ? B = b.linkedParent.tickInterval : z(B, this.tickAmount ? (b.max - b.min) / Math.max(this.tickAmount - 1, 1) : void 0, F ? 1 : (b.max - b.min) * L / Math.max(b.len, L));
        v && !a && b.series.forEach(function (a) {
          a.processData(b.min !== b.oldMin || b.max !== b.oldMax);
        });
        b.setAxisTranslation(!0);
        b.beforeSetTickPositions && b.beforeSetTickPositions();
        b.postProcessTickInterval && (b.tickInterval = b.postProcessTickInterval(b.tickInterval));
        b.pointRange && !B && (b.tickInterval = Math.max(b.pointRange, b.tickInterval));
        a = z(f.minTickInterval, b.isDatetimeAxis && b.closestPointRange);
        !B && b.tickInterval < a && (b.tickInterval = a);
        k || p || B || (b.tickInterval = l(b.tickInterval, null, e(b.tickInterval), z(f.allowDecimals, !(.5 < b.tickInterval && 5 > b.tickInterval && 1E3 < b.max && 9999 > b.max)), !!this.tickAmount));
        this.tickAmount || (b.tickInterval = b.unsquish());
        this.setTickPositions();
      },
      setTickPositions: function () {
        var a = this.options,
            b = a.tickPositions;
        var c = this.getMinorTickInterval();
        var f = a.tickPositioner,
            e = a.startOnTick,
            l = a.endOnTick;
        this.tickmarkOffset = this.categories && "between" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
        this.minorTickInterval = "auto" === c && this.tickInterval ? this.tickInterval / 5 : c;
        this.single = this.min === this.max && t(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== a.allowDecimals);
        this.tickPositions = c = b && b.slice();
        !c && (!this.ordinalPositions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200) ? (c = [this.min, this.max], h(19, !1, this.chart)) : c = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), c.length > this.len && (c = [c[0], c.pop()], c[0] === c[1] && (c.length = 1)), this.tickPositions = c, f && (f = f.apply(this, [this.min, this.max]))) && (this.tickPositions = c = f);
        this.paddedTicks = c.slice(0);
        this.trimTicks(c, e, l);
        this.isLinked || (this.single && 2 > c.length && !this.categories && !this.series.some(function (b) {
          return b.is("heatmap") && "between" === b.options.pointPlacement;
        }) && (this.min -= .5, this.max += .5), b || f || this.adjustTickAmount());
        q(this, "afterSetTickPositions");
      },
      trimTicks: function (a, b, c) {
        var f = a[0],
            e = a[a.length - 1],
            p = !this.isOrdinal && this.minPointOffset || 0;
        q(this, "trimTicks");

        if (!this.isLinked) {
          if (b && -Infinity !== f) this.min = f;else for (; this.min - p > a[0];) a.shift();
          if (c) this.max = e;else for (; this.max + p < a[a.length - 1];) a.pop();
          0 === a.length && t(f) && !this.options.tickPositions && a.push((e + f) / 2);
        }
      },
      alignToOthers: function () {
        var a = {},
            b,
            c = this.options;
        !1 === this.chart.options.chart.alignTicks || !1 === c.alignTicks || !1 === c.startOnTick || !1 === c.endOnTick || this.isLog || this.chart[this.coll].forEach(function (c) {
          var f = c.options;
          f = [c.horiz ? f.left : f.top, f.width, f.height, f.pane].join();
          c.series.length && (a[f] ? b = !0 : a[f] = 1);
        });
        return b;
      },
      getTickAmount: function () {
        var a = this.options,
            b = a.tickAmount,
            c = a.tickPixelInterval;
        !t(a.tickInterval) && this.len < c && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (b = 2);
        !b && this.alignToOthers() && (b = Math.ceil(this.len / c) + 1);
        4 > b && (this.finalTickAmt = b, b = 5);
        this.tickAmount = b;
      },
      adjustTickAmount: function () {
        var a = this.options,
            b = this.tickInterval,
            c = this.tickPositions,
            f = this.tickAmount,
            e = this.finalTickAmt,
            l = c && c.length,
            k = z(this.threshold, this.softThreshold ? 0 : null),
            v;

        if (this.hasData()) {
          if (l < f) {
            for (v = this.min; c.length < f;) c.length % 2 || v === k ? c.push(y(c[c.length - 1] + b)) : c.unshift(y(c[0] - b));

            this.transA *= (l - 1) / (f - 1);
            this.min = a.startOnTick ? c[0] : Math.min(this.min, c[0]);
            this.max = a.endOnTick ? c[c.length - 1] : Math.max(this.max, c[c.length - 1]);
          } else l > f && (this.tickInterval *= 2, this.setTickPositions());

          if (t(e)) {
            for (b = a = c.length; b--;) (3 === e && 1 === b % 2 || 2 >= e && 0 < b && b < a - 1) && c.splice(b, 1);

            this.finalTickAmt = void 0;
          }
        }
      },
      setScale: function () {
        var a = this.series.some(function (b) {
          return b.isDirtyData || b.isDirty || b.xAxis && b.xAxis.isDirty;
        }),
            b;
        this.oldMin = this.min;
        this.oldMax = this.max;
        this.oldAxisLength = this.len;
        this.setAxisSize();
        (b = this.len !== this.oldAxisLength) || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();
        q(this, "afterSetScale");
      },
      setExtremes: function (a, b, c, f, e) {
        var p = this,
            l = p.chart;
        c = z(c, !0);
        p.series.forEach(function (b) {
          delete b.kdTree;
        });
        e = N(e, {
          min: a,
          max: b
        });
        q(p, "setExtremes", e, function () {
          p.userMin = a;
          p.userMax = b;
          p.eventArgs = e;
          c && l.redraw(f);
        });
      },
      zoom: function (a, b) {
        var c = this.dataMin,
            f = this.dataMax,
            e = this.options,
            p = Math.min(c, z(e.min, c)),
            l = Math.max(f, z(e.max, f));
        a = {
          newMin: a,
          newMax: b
        };
        q(this, "zoom", a, function (b) {
          var a = b.newMin,
              e = b.newMax;
          if (a !== this.min || e !== this.max) this.allowZoomOutside || (t(c) && (a < p && (a = p), a > l && (a = l)), t(f) && (e < p && (e = p), e > l && (e = l))), this.displayBtn = "undefined" !== typeof a || "undefined" !== typeof e, this.setExtremes(a, e, !1, void 0, {
            trigger: "zoom"
          });
          b.zoomed = !0;
        });
        return a.zoomed;
      },
      setAxisSize: function () {
        var a = this.chart,
            b = this.options,
            c = b.offsets || [0, 0, 0, 0],
            f = this.horiz,
            e = this.width = Math.round(w(z(b.width, a.plotWidth - c[3] + c[1]), a.plotWidth)),
            l = this.height = Math.round(w(z(b.height, a.plotHeight - c[0] + c[2]), a.plotHeight)),
            k = this.top = Math.round(w(z(b.top, a.plotTop + c[0]), a.plotHeight, a.plotTop));
        b = this.left = Math.round(w(z(b.left, a.plotLeft + c[3]), a.plotWidth, a.plotLeft));
        this.bottom = a.chartHeight - l - k;
        this.right = a.chartWidth - e - b;
        this.len = Math.max(f ? e : l, 0);
        this.pos = f ? b : k;
      },
      getExtremes: function () {
        var a = this.isLog;
        return {
          min: a ? y(this.lin2log(this.min)) : this.min,
          max: a ? y(this.lin2log(this.max)) : this.max,
          dataMin: this.dataMin,
          dataMax: this.dataMax,
          userMin: this.userMin,
          userMax: this.userMax
        };
      },
      getThreshold: function (a) {
        var b = this.isLog,
            c = b ? this.lin2log(this.min) : this.min;
        b = b ? this.lin2log(this.max) : this.max;
        null === a || -Infinity === a ? a = c : Infinity === a ? a = b : c > a ? a = c : b < a && (a = b);
        return this.translate(a, 0, 1, 0, 1);
      },
      autoLabelAlign: function (a) {
        var b = (z(a, 0) - 90 * this.side + 720) % 360;
        a = {
          align: "center"
        };
        q(this, "autoLabelAlign", a, function (a) {
          15 < b && 165 > b ? a.align = "right" : 195 < b && 345 > b && (a.align = "left");
        });
        return a.align;
      },
      tickSize: function (a) {
        var b = this.options,
            c = b[a + "Length"],
            f = z(b[a + "Width"], "tick" === a && this.isXAxis && !this.categories ? 1 : 0);

        if (f && c) {
          "inside" === b[a + "Position"] && (c = -c);
          var e = [c, f];
        }

        a = {
          tickSize: e
        };
        q(this, "afterTickSize", a);
        return a.tickSize;
      },
      labelMetrics: function () {
        var a = this.tickPositions && this.tickPositions[0] || 0;
        return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);
      },
      unsquish: function () {
        var a = this.options.labels,
            b = this.horiz,
            c = this.tickInterval,
            f = c,
            e = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / c),
            l,
            k = a.rotation,
            v = this.labelMetrics(),
            m,
            d = Number.MAX_VALUE,
            n,
            w = this.max - this.min,
            F = function (b) {
          var a = b / (e || 1);
          a = 1 < a ? Math.ceil(a) : 1;
          a * c > w && Infinity !== b && Infinity !== e && w && (a = Math.ceil(w / c));
          return y(a * c);
        };

        b ? (n = !a.staggerLines && !a.step && (t(k) ? [k] : e < z(a.autoRotationLimit, 80) && a.autoRotation)) && n.forEach(function (b) {
          if (b === k || b && -90 <= b && 90 >= b) {
            m = F(Math.abs(v.h / Math.sin(K * b)));
            var a = m + Math.abs(b / 360);
            a < d && (d = a, l = b, f = m);
          }
        }) : a.step || (f = F(v.h));
        this.autoRotation = n;
        this.labelRotation = z(l, k);
        return f;
      },
      getSlotWidth: function (a) {
        var b = this.chart,
            c = this.horiz,
            f = this.options.labels,
            e = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
            l = b.margin[3];
        return a && a.slotWidth || c && 2 > (f.step || 0) && !f.rotation && (this.staggerLines || 1) * this.len / e || !c && (f.style && parseInt(f.style.width, 10) || l && l - b.spacing[3] || .33 * b.chartWidth);
      },
      renderUnsquish: function () {
        var a = this.chart,
            b = a.renderer,
            c = this.tickPositions,
            e = this.ticks,
            l = this.options.labels,
            k = l && l.style || {},
            v = this.horiz,
            d = this.getSlotWidth(),
            m = Math.max(1, Math.round(d - 2 * (l.padding || 5))),
            n = {},
            w = this.labelMetrics(),
            h = l.style && l.style.textOverflow,
            F = 0;
        f(l.rotation) || (n.rotation = l.rotation || 0);
        c.forEach(function (b) {
          b = e[b];
          b.movedLabel && b.replaceMovedLabel();
          b && b.label && b.label.textPxLength > F && (F = b.label.textPxLength);
        });
        this.maxLabelLength = F;
        if (this.autoRotation) F > m && F > w.h ? n.rotation = this.labelRotation : this.labelRotation = 0;else if (d) {
          var z = m;

          if (!h) {
            var q = "clip";

            for (m = c.length; !v && m--;) {
              var B = c[m];
              if (B = e[B].label) B.styles && "ellipsis" === B.styles.textOverflow ? B.css({
                textOverflow: "clip"
              }) : B.textPxLength > d && B.css({
                width: d + "px"
              }), B.getBBox().height > this.len / c.length - (w.h - w.f) && (B.specificTextOverflow = "ellipsis");
            }
          }
        }
        n.rotation && (z = F > .5 * a.chartHeight ? .33 * a.chartHeight : F, h || (q = "ellipsis"));
        if (this.labelAlign = l.align || this.autoLabelAlign(this.labelRotation)) n.align = this.labelAlign;
        c.forEach(function (b) {
          var a = (b = e[b]) && b.label,
              c = k.width,
              f = {};
          a && (a.attr(n), b.shortenLabel ? b.shortenLabel() : z && !c && "nowrap" !== k.whiteSpace && (z < a.textPxLength || "SPAN" === a.element.tagName) ? (f.width = z, h || (f.textOverflow = a.specificTextOverflow || q), a.css(f)) : a.styles && a.styles.width && !f.width && !c && a.css({
            width: null
          }), delete a.specificTextOverflow, b.rotation = n.rotation);
        }, this);
        this.tickRotCorr = b.rotCorr(w.b, this.labelRotation || 0, 0 !== this.side);
      },
      hasData: function () {
        return this.series.some(function (a) {
          return a.hasData();
        }) || this.options.showEmpty && t(this.min) && t(this.max);
      },
      addTitle: function (c) {
        var b = this.chart.renderer,
            f = this.horiz,
            e = this.opposite,
            l = this.options.title,
            p,
            k = this.chart.styledMode;
        this.axisTitle || ((p = l.textAlign) || (p = (f ? {
          low: "left",
          middle: "center",
          high: "right"
        } : {
          low: e ? "right" : "left",
          middle: "center",
          high: e ? "left" : "right"
        })[l.align]), this.axisTitle = b.text(l.text, 0, 0, l.useHTML).attr({
          zIndex: 7,
          rotation: l.rotation || 0,
          align: p
        }).addClass("highcharts-axis-title"), k || this.axisTitle.css(a(l.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);
        k || l.style.width || this.isRadial || this.axisTitle.css({
          width: this.len
        });
        this.axisTitle[c ? "show" : "hide"](c);
      },
      generateTick: function (a) {
        var b = this.ticks;
        b[a] ? b[a].addLabel() : b[a] = new r(this, a);
      },
      getOffset: function () {
        var a = this,
            b = a.chart,
            c = b.renderer,
            f = a.options,
            e = a.tickPositions,
            l = a.ticks,
            k = a.horiz,
            d = a.side,
            m = b.inverted && !a.isZAxis ? [1, 0, 3, 2][d] : d,
            n,
            w = 0,
            h = 0,
            F = f.title,
            B = f.labels,
            L = 0,
            g = b.axisOffset;
        b = b.clipOffset;
        var H = [-1, 1, 1, -1][d],
            K = f.className,
            Q = a.axisParent;
        var y = a.hasData();
        a.showAxis = n = y || z(f.showEmpty, !0);
        a.staggerLines = a.horiz && B.staggerLines;
        a.axisGroup || (a.gridGroup = c.g("grid").attr({
          zIndex: f.gridZIndex || 1
        }).addClass("highcharts-" + this.coll.toLowerCase() + "-grid " + (K || "")).add(Q), a.axisGroup = c.g("axis").attr({
          zIndex: f.zIndex || 2
        }).addClass("highcharts-" + this.coll.toLowerCase() + " " + (K || "")).add(Q), a.labelGroup = c.g("axis-labels").attr({
          zIndex: B.zIndex || 7
        }).addClass("highcharts-" + a.coll.toLowerCase() + "-labels " + (K || "")).add(Q));
        y || a.isLinked ? (e.forEach(function (b, c) {
          a.generateTick(b, c);
        }), a.renderUnsquish(), a.reserveSpaceDefault = 0 === d || 2 === d || {
          1: "left",
          3: "right"
        }[d] === a.labelAlign, z(B.reserveSpace, "center" === a.labelAlign ? !0 : null, a.reserveSpaceDefault) && e.forEach(function (b) {
          L = Math.max(l[b].getLabelSize(), L);
        }), a.staggerLines && (L *= a.staggerLines), a.labelOffset = L * (a.opposite ? -1 : 1)) : v(l, function (b, a) {
          b.destroy();
          delete l[a];
        });

        if (F && F.text && !1 !== F.enabled && (a.addTitle(n), n && !1 !== F.reserveSpace)) {
          a.titleOffset = w = a.axisTitle.getBBox()[k ? "height" : "width"];
          var u = F.offset;
          h = t(u) ? 0 : z(F.margin, k ? 5 : 10);
        }

        a.renderLine();
        a.offset = H * z(f.offset, g[d] ? g[d] + (f.margin || 0) : 0);
        a.tickRotCorr = a.tickRotCorr || {
          x: 0,
          y: 0
        };
        c = 0 === d ? -a.labelMetrics().h : 2 === d ? a.tickRotCorr.y : 0;
        h = Math.abs(L) + h;
        L && (h = h - c + H * (k ? z(B.y, a.tickRotCorr.y + 8 * H) : B.x));
        a.axisTitleMargin = z(u, h);
        a.getMaxLabelDimensions && (a.maxLabelDimensions = a.getMaxLabelDimensions(l, e));
        k = this.tickSize("tick");
        g[d] = Math.max(g[d], a.axisTitleMargin + w + H * a.offset, h, e && e.length && k ? k[0] + H * a.offset : 0);
        f = f.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);
        b[m] = Math.max(b[m], f);
        q(this, "afterGetOffset");
      },
      getLinePath: function (a) {
        var b = this.chart,
            c = this.opposite,
            f = this.offset,
            e = this.horiz,
            l = this.left + (c ? this.width : 0) + f;
        f = b.chartHeight - this.bottom - (c ? this.height : 0) + f;
        c && (a *= -1);
        return b.renderer.crispLine(["M", e ? this.left : l, e ? f : this.top, "L", e ? b.chartWidth - this.right : l, e ? f : b.chartHeight - this.bottom], a);
      },
      renderLine: function () {
        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
          stroke: this.options.lineColor,
          "stroke-width": this.options.lineWidth,
          zIndex: 7
        }));
      },
      getTitlePosition: function () {
        var a = this.horiz,
            b = this.left,
            c = this.top,
            f = this.len,
            e = this.options.title,
            l = a ? b : c,
            k = this.opposite,
            d = this.offset,
            m = e.x || 0,
            v = e.y || 0,
            n = this.axisTitle,
            w = this.chart.renderer.fontMetrics(e.style && e.style.fontSize, n);
        n = Math.max(n.getBBox(null, 0).height - w.h - 1, 0);
        f = {
          low: l + (a ? 0 : f),
          middle: l + f / 2,
          high: l + (a ? f : 0)
        }[e.align];
        b = (a ? c + this.height : b) + (a ? 1 : -1) * (k ? -1 : 1) * this.axisTitleMargin + [-n, n, w.f, -n][this.side];
        a = {
          x: a ? f + m : b + (k ? this.width : 0) + d + m,
          y: a ? b + v - (k ? this.height : 0) + d : f + v
        };
        q(this, "afterGetTitlePosition", {
          titlePosition: a
        });
        return a;
      },
      renderMinorTick: function (a) {
        var b = this.chart.hasRendered && n(this.oldMin),
            c = this.minorTicks;
        c[a] || (c[a] = new r(this, a, "minor"));
        b && c[a].isNew && c[a].render(null, !0);
        c[a].render(null, !1, 1);
      },
      renderTick: function (a, b) {
        var c = this.isLinked,
            f = this.ticks,
            e = this.chart.hasRendered && n(this.oldMin);
        if (!c || a >= this.min && a <= this.max) f[a] || (f[a] = new r(this, a)), e && f[a].isNew && f[a].render(b, !0, -1), f[a].render(b);
      },
      render: function () {
        var a = this,
            b = a.chart,
            c = a.options,
            f = a.isLog,
            e = a.isLinked,
            l = a.tickPositions,
            k = a.axisTitle,
            w = a.ticks,
            m = a.minorTicks,
            h = a.alternateBands,
            z = c.stackLabels,
            B = c.alternateGridColor,
            F = a.tickmarkOffset,
            L = a.axisLine,
            t = a.showAxis,
            g = E(b.renderer.globalAnimation),
            H,
            K;
        a.labelEdge.length = 0;
        a.overlap = !1;
        [w, m, h].forEach(function (b) {
          v(b, function (b) {
            b.isActive = !1;
          });
        });
        if (a.hasData() || e) a.minorTickInterval && !a.categories && a.getMinorTickPositions().forEach(function (b) {
          a.renderMinorTick(b);
        }), l.length && (l.forEach(function (b, c) {
          a.renderTick(b, c);
        }), F && (0 === a.min || a.single) && (w[-1] || (w[-1] = new r(a, -1, null, !0)), w[-1].render(-1))), B && l.forEach(function (c, e) {
          K = "undefined" !== typeof l[e + 1] ? l[e + 1] + F : a.max - F;
          0 === e % 2 && c < a.max && K <= a.max + (b.polar ? -F : F) && (h[c] || (h[c] = new d.PlotLineOrBand(a)), H = c + F, h[c].options = {
            from: f ? a.lin2log(H) : H,
            to: f ? a.lin2log(K) : K,
            color: B
          }, h[c].render(), h[c].isActive = !0);
        }), a._addedPlotLB || ((c.plotLines || []).concat(c.plotBands || []).forEach(function (b) {
          a.addPlotBandOrLine(b);
        }), a._addedPlotLB = !0);
        [w, m, h].forEach(function (a) {
          var c,
              f = [],
              e = g.duration;
          v(a, function (b, a) {
            b.isActive || (b.render(a, !1, 0), b.isActive = !1, f.push(a));
          });
          Q(function () {
            for (c = f.length; c--;) a[f[c]] && !a[f[c]].isActive && (a[f[c]].destroy(), delete a[f[c]]);
          }, a !== h && b.hasRendered && e ? e : 0);
        });
        L && (L[L.isPlaced ? "animate" : "attr"]({
          d: this.getLinePath(L.strokeWidth())
        }), L.isPlaced = !0, L[t ? "show" : "hide"](t));
        k && t && (c = a.getTitlePosition(), n(c.y) ? (k[k.isNew ? "attr" : "animate"](c), k.isNew = !1) : (k.attr("y", -9999), k.isNew = !0));
        z && z.enabled && a.renderStackTotals();
        a.isDirty = !1;
        q(this, "afterRender");
      },
      redraw: function () {
        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (a) {
          a.render();
        }));
        this.series.forEach(function (a) {
          a.isDirty = !0;
        });
      },
      keepProps: "extKey hcEvents names series userMax userMin".split(" "),
      destroy: function (a) {
        var b = this,
            c = b.stacks,
            f = b.plotLinesAndBands,
            e;
        q(this, "destroy", {
          keepEvents: a
        });
        a || B(b);
        v(c, function (b, a) {
          D(b);
          c[a] = null;
        });
        [b.ticks, b.minorTicks, b.alternateBands].forEach(function (b) {
          D(b);
        });
        if (f) for (a = f.length; a--;) f[a].destroy();
        "stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (a) {
          b[a] && (b[a] = b[a].destroy());
        });

        for (e in b.plotLinesAndBandsGroups) b.plotLinesAndBandsGroups[e] = b.plotLinesAndBandsGroups[e].destroy();

        v(b, function (a, c) {
          -1 === b.keepProps.indexOf(c) && delete b[c];
        });
      },
      drawCrosshair: function (a, b) {
        var c = this.crosshair,
            f = z(c.snap, !0),
            e,
            l = this.cross,
            k = this.chart;
        q(this, "drawCrosshair", {
          e: a,
          point: b
        });
        a || (a = this.cross && this.cross.e);

        if (this.crosshair && !1 !== (t(b) || !f)) {
          f ? t(b) && (e = z("colorAxis" !== this.coll ? b.crosshairPos : null, this.isXAxis ? b.plotX : this.len - b.plotY)) : e = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);

          if (t(e)) {
            var d = {
              value: b && (this.isXAxis ? b.x : z(b.stackY, b.y)),
              translatedValue: e
            };
            k.polar && N(d, {
              isCrosshair: !0,
              chartX: a && a.chartX,
              chartY: a && a.chartY,
              point: b
            });
            d = this.getPlotLinePath(d) || null;
          }

          if (!t(d)) {
            this.hideCrosshair();
            return;
          }

          f = this.categories && !this.isRadial;
          l || (this.cross = l = k.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (f ? "category " : "thin ") + c.className).attr({
            zIndex: z(c.zIndex, 2)
          }).add(), k.styledMode || (l.attr({
            stroke: c.color || (f ? I("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
            "stroke-width": z(c.width, 1)
          }).css({
            "pointer-events": "none"
          }), c.dashStyle && l.attr({
            dashstyle: c.dashStyle
          })));
          l.show().attr({
            d: d
          });
          f && !c.width && l.attr({
            "stroke-width": this.transA
          });
          this.cross.e = a;
        } else this.hideCrosshair();

        q(this, "afterDrawCrosshair", {
          e: a,
          point: b
        });
      },
      hideCrosshair: function () {
        this.cross && this.cross.hide();
        q(this, "afterHideCrosshair");
      }
    });
    return d.Axis = g;
  });
  S(r, "parts/DateTimeAxis.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.getMagnitude,
        u = g.normalizeTickInterval,
        I = g.timeUnits;
    d = d.Axis;

    d.prototype.getTimeTicks = function () {
      return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
    };

    d.prototype.normalizeTimeTickInterval = function (d, g) {
      var A = g || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
      g = A[A.length - 1];
      var G = I[g[0]],
          E = g[1],
          y;

      for (y = 0; y < A.length && !(g = A[y], G = I[g[0]], E = g[1], A[y + 1] && d <= (G * E[E.length - 1] + I[A[y + 1][0]]) / 2); y++);

      G === I.year && d < 5 * G && (E = [1, 2, 5]);
      d = u(d / G, E, "year" === g[0] ? Math.max(r(d / G), 1) : 1);
      return {
        unitRange: G,
        count: d,
        unitName: g[0]
      };
    };
  });
  S(r, "parts/LogarithmicAxis.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.getMagnitude,
        u = g.normalizeTickInterval,
        I = g.pick;
    d = d.Axis;

    d.prototype.getLogTickPositions = function (d, g, A, G) {
      var E = this.options,
          y = this.len,
          t = [];
      G || (this._minorAutoInterval = null);
      if (.5 <= d) d = Math.round(d), t = this.getLinearTickPositions(d, g, A);else if (.08 <= d) {
        y = Math.floor(g);
        var D, h;

        for (E = .3 < d ? [1, 2, 4] : .15 < d ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; y < A + 1 && !h; y++) {
          var N = E.length;

          for (D = 0; D < N && !h; D++) {
            var q = this.log2lin(this.lin2log(y) * E[D]);
            q > g && (!G || P <= A) && "undefined" !== typeof P && t.push(P);
            P > A && (h = !0);
            var P = q;
          }
        }
      } else g = this.lin2log(g), A = this.lin2log(A), d = G ? this.getMinorTickInterval() : E.tickInterval, d = I("auto" === d ? null : d, this._minorAutoInterval, E.tickPixelInterval / (G ? 5 : 1) * (A - g) / ((G ? y / this.tickPositions.length : y) || 1)), d = u(d, null, r(d)), t = this.getLinearTickPositions(d, g, A).map(this.log2lin), G || (this._minorAutoInterval = d / 5);
      G || (this.tickInterval = d);
      return t;
    };

    d.prototype.log2lin = function (d) {
      return Math.log(d) / Math.LN10;
    };

    d.prototype.lin2log = function (d) {
      return Math.pow(10, d);
    };
  });
  S(r, "parts/PlotLineOrBand.js", [r["parts/Globals.js"], r["parts/Axis.js"], r["parts/Utilities.js"]], function (d, g, r) {
    var u = r.arrayMax,
        I = r.arrayMin,
        M = r.defined,
        E = r.destroyObjectProperties,
        A = r.erase,
        G = r.extend,
        J = r.merge,
        y = r.objectEach,
        t = r.pick,
        D = function () {
      function h(d, h) {
        this.axis = d;
        h && (this.options = h, this.id = h.id);
      }

      h.prototype.render = function () {
        d.fireEvent(this, "render");
        var h = this,
            q = h.axis,
            g = q.horiz,
            e = h.options,
            c = e.label,
            k = h.label,
            n = e.to,
            f = e.from,
            a = e.value,
            l = M(f) && M(n),
            v = M(a),
            z = h.svgElem,
            w = !z,
            B = [],
            L = e.color,
            Q = t(e.zIndex, 0),
            H = e.events;
        B = {
          "class": "highcharts-plot-" + (l ? "band " : "line ") + (e.className || "")
        };
        var K = {},
            p = q.chart.renderer,
            b = l ? "bands" : "lines";
        q.isLog && (f = q.log2lin(f), n = q.log2lin(n), a = q.log2lin(a));
        q.chart.styledMode || (v ? (B.stroke = L || "#999999", B["stroke-width"] = t(e.width, 1), e.dashStyle && (B.dashstyle = e.dashStyle)) : l && (B.fill = L || "#e6ebf5", e.borderWidth && (B.stroke = e.borderColor, B["stroke-width"] = e.borderWidth)));
        K.zIndex = Q;
        b += "-" + Q;
        (L = q.plotLinesAndBandsGroups[b]) || (q.plotLinesAndBandsGroups[b] = L = p.g("plot-" + b).attr(K).add());
        w && (h.svgElem = z = p.path().attr(B).add(L));
        if (v) B = q.getPlotLinePath({
          value: a,
          lineWidth: z.strokeWidth(),
          acrossPanes: e.acrossPanes
        });else if (l) B = q.getPlotBandPath(f, n, e);else return;
        (w || !z.d) && B && B.length ? (z.attr({
          d: B
        }), H && y(H, function (b, a) {
          z.on(a, function (b) {
            H[a].apply(h, [b]);
          });
        })) : z && (B ? (z.show(!0), z.animate({
          d: B
        })) : z.d && (z.hide(), k && (h.label = k = k.destroy())));
        c && (M(c.text) || M(c.formatter)) && B && B.length && 0 < q.width && 0 < q.height && !B.isFlat ? (c = J({
          align: g && l && "center",
          x: g ? !l && 4 : 10,
          verticalAlign: !g && l && "middle",
          y: g ? l ? 16 : 10 : l ? 6 : -4,
          rotation: g && !l && 90
        }, c), this.renderLabel(c, B, l, Q)) : k && k.hide();
        return h;
      };

      h.prototype.renderLabel = function (d, h, g, e) {
        var c = this.label,
            k = this.axis.chart.renderer;
        c || (c = {
          align: d.textAlign || d.align,
          rotation: d.rotation,
          "class": "highcharts-plot-" + (g ? "band" : "line") + "-label " + (d.className || "")
        }, c.zIndex = e, e = this.getLabelText(d), this.label = c = k.text(e, 0, 0, d.useHTML).attr(c).add(), this.axis.chart.styledMode || c.css(d.style));
        k = h.xBounds || [h[1], h[4], g ? h[6] : h[1]];
        h = h.yBounds || [h[2], h[5], g ? h[7] : h[2]];
        g = I(k);
        e = I(h);
        c.align(d, !1, {
          x: g,
          y: e,
          width: u(k) - g,
          height: u(h) - e
        });
        c.show(!0);
      };

      h.prototype.getLabelText = function (d) {
        return M(d.formatter) ? d.formatter.call(this) : d.text;
      };

      h.prototype.destroy = function () {
        A(this.axis.plotLinesAndBands, this);
        delete this.axis;
        E(this);
      };

      return h;
    }();

    G(g.prototype, {
      getPlotBandPath: function (d, g) {
        var h = this.getPlotLinePath({
          value: g,
          force: !0,
          acrossPanes: this.options.acrossPanes
        }),
            t = this.getPlotLinePath({
          value: d,
          force: !0,
          acrossPanes: this.options.acrossPanes
        }),
            e = [],
            c = this.horiz,
            k = 1;
        d = d < this.min && g < this.min || d > this.max && g > this.max;

        if (t && h) {
          if (d) {
            var n = t.toString() === h.toString();
            k = 0;
          }

          for (d = 0; d < t.length; d += 6) c && h[d + 1] === t[d + 1] ? (h[d + 1] += k, h[d + 4] += k) : c || h[d + 2] !== t[d + 2] || (h[d + 2] += k, h[d + 5] += k), e.push("M", t[d + 1], t[d + 2], "L", t[d + 4], t[d + 5], h[d + 4], h[d + 5], h[d + 1], h[d + 2], "z"), e.isFlat = n;
        }

        return e;
      },
      addPlotBand: function (d) {
        return this.addPlotBandOrLine(d, "plotBands");
      },
      addPlotLine: function (d) {
        return this.addPlotBandOrLine(d, "plotLines");
      },
      addPlotBandOrLine: function (d, g) {
        var h = new D(this, d).render(),
            t = this.userOptions;

        if (h) {
          if (g) {
            var e = t[g] || [];
            e.push(d);
            t[g] = e;
          }

          this.plotLinesAndBands.push(h);
        }

        return h;
      },
      removePlotBandOrLine: function (d) {
        for (var h = this.plotLinesAndBands, q = this.options, g = this.userOptions, e = h.length; e--;) h[e].id === d && h[e].destroy();

        [q.plotLines || [], g.plotLines || [], q.plotBands || [], g.plotBands || []].forEach(function (c) {
          for (e = c.length; e--;) c[e].id === d && A(c, c[e]);
        });
      },
      removePlotBand: function (d) {
        this.removePlotBandOrLine(d);
      },
      removePlotLine: function (d) {
        this.removePlotBandOrLine(d);
      }
    });
    d.PlotLineOrBand = D;
    return d.PlotLineOrBand;
  });
  S(r, "parts/Tooltip.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.clamp,
        u = g.css,
        I = g.defined,
        M = g.discardElement,
        E = g.extend,
        A = g.format,
        G = g.isNumber,
        J = g.isString,
        y = g.merge,
        t = g.pick,
        D = g.splat,
        h = g.syncTimeout,
        N = g.timeUnits;
    "";

    var q = d.doc,
        P = function () {
      function e(c, e) {
        this.crosshairs = [];
        this.distance = 0;
        this.isHidden = !0;
        this.isSticky = !1;
        this.now = {};
        this.options = {};
        this.outside = !1;
        this.chart = c;
        this.init(c, e);
      }

      e.prototype.applyFilter = function () {
        var c = this.chart;
        c.renderer.definition({
          tagName: "filter",
          id: "drop-shadow-" + c.index,
          opacity: .5,
          children: [{
            tagName: "feGaussianBlur",
            "in": "SourceAlpha",
            stdDeviation: 1
          }, {
            tagName: "feOffset",
            dx: 1,
            dy: 1
          }, {
            tagName: "feComponentTransfer",
            children: [{
              tagName: "feFuncA",
              type: "linear",
              slope: .3
            }]
          }, {
            tagName: "feMerge",
            children: [{
              tagName: "feMergeNode"
            }, {
              tagName: "feMergeNode",
              "in": "SourceGraphic"
            }]
          }]
        });
        c.renderer.definition({
          tagName: "style",
          textContent: ".highcharts-tooltip-" + c.index + "{filter:url(#drop-shadow-" + c.index + ")}"
        });
      };

      e.prototype.bodyFormatter = function (c) {
        return c.map(function (c) {
          var e = c.series.tooltipOptions;
          return (e[(c.point.formatPrefix || "point") + "Formatter"] || c.point.tooltipFormatter).call(c.point, e[(c.point.formatPrefix || "point") + "Format"] || "");
        });
      };

      e.prototype.cleanSplit = function (c) {
        this.chart.series.forEach(function (e) {
          var d = e && e.tt;
          d && (!d.isActive || c ? e.tt = d.destroy() : d.isActive = !1);
        });
      };

      e.prototype.defaultFormatter = function (c) {
        var e = this.points || D(this);
        var d = [c.tooltipFooterHeaderFormatter(e[0])];
        d = d.concat(c.bodyFormatter(e));
        d.push(c.tooltipFooterHeaderFormatter(e[0], !0));
        return d;
      };

      e.prototype.destroy = function () {
        this.label && (this.label = this.label.destroy());
        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());
        this.renderer && (this.renderer = this.renderer.destroy(), M(this.container));
        g.clearTimeout(this.hideTimer);
        g.clearTimeout(this.tooltipTimeout);
      };

      e.prototype.getAnchor = function (c, e) {
        var d = this.chart,
            f = d.pointer,
            a = d.inverted,
            l = d.plotTop,
            k = d.plotLeft,
            h = 0,
            w = 0,
            B,
            q;
        c = D(c);
        this.followPointer && e ? ("undefined" === typeof e.chartX && (e = f.normalize(e)), c = [e.chartX - k, e.chartY - l]) : c[0].tooltipPos ? c = c[0].tooltipPos : (c.forEach(function (c) {
          B = c.series.yAxis;
          q = c.series.xAxis;
          h += c.plotX + (!a && q ? q.left - k : 0);
          w += (c.plotLow ? (c.plotLow + c.plotHigh) / 2 : c.plotY) + (!a && B ? B.top - l : 0);
        }), h /= c.length, w /= c.length, c = [a ? d.plotWidth - w : h, this.shared && !a && 1 < c.length && e ? e.chartY - l : a ? d.plotHeight - h : w]);
        return c.map(Math.round);
      };

      e.prototype.getDateFormat = function (c, e, d, f) {
        var a = this.chart.time,
            l = a.dateFormat("%m-%d %H:%M:%S.%L", e),
            k = {
          millisecond: 15,
          second: 12,
          minute: 9,
          hour: 6,
          day: 3
        },
            n = "millisecond";

        for (w in N) {
          if (c === N.week && +a.dateFormat("%w", e) === d && "00:00:00.000" === l.substr(6)) {
            var w = "week";
            break;
          }

          if (N[w] > c) {
            w = n;
            break;
          }

          if (k[w] && l.substr(k[w]) !== "01-01 00:00:00.000".substr(k[w])) break;
          "week" !== w && (n = w);
        }

        if (w) var h = a.resolveDTLFormat(f[w]).main;
        return h;
      };

      e.prototype.getLabel = function () {
        var c,
            e = this,
            n = this.chart.renderer,
            f = this.chart.styledMode,
            a = this.options,
            l = "tooltip" + (I(a.className) ? " " + a.className : ""),
            v = (null === (c = a.style) || void 0 === c ? void 0 : c.pointerEvents) || (!this.followPointer && a.stickOnContact ? "auto" : "none"),
            h;

        c = function () {
          e.inContact = !0;
        };

        var w = function () {
          var a = e.chart.hoverSeries;
          e.inContact = !1;
          if (a && a.onMouseOut) a.onMouseOut();
        };

        if (!this.label) {
          this.outside && (this.container = h = d.doc.createElement("div"), h.className = "highcharts-tooltip-container", u(h, {
            position: "absolute",
            top: "1px",
            pointerEvents: v,
            zIndex: 3
          }), d.doc.body.appendChild(h), this.renderer = n = new d.Renderer(h, 0, 0, {}, void 0, void 0, n.styledMode));
          this.split ? this.label = n.g(l) : (this.label = n.label("", 0, 0, a.shape || "callout", null, null, a.useHTML, null, l).attr({
            padding: a.padding,
            r: a.borderRadius
          }), f || this.label.attr({
            fill: a.backgroundColor,
            "stroke-width": a.borderWidth
          }).css(a.style).css({
            pointerEvents: v
          }).shadow(a.shadow));
          f && (this.applyFilter(), this.label.addClass("highcharts-tooltip-" + this.chart.index));

          if (e.outside && !e.split) {
            var B = {
              x: this.label.xSetter,
              y: this.label.ySetter
            };

            this.label.xSetter = function (a, c) {
              B[c].call(this.label, e.distance);
              h.style.left = a + "px";
            };

            this.label.ySetter = function (a, c) {
              B[c].call(this.label, e.distance);
              h.style.top = a + "px";
            };
          }

          this.label.on("mouseenter", c).on("mouseleave", w).attr({
            zIndex: 8
          }).add();
        }

        return this.label;
      };

      e.prototype.getPosition = function (c, e, d) {
        var f = this.chart,
            a = this.distance,
            l = {},
            k = f.inverted && d.h || 0,
            n,
            w = this.outside,
            h = w ? q.documentElement.clientWidth - 2 * a : f.chartWidth,
            g = w ? Math.max(q.body.scrollHeight, q.documentElement.scrollHeight, q.body.offsetHeight, q.documentElement.offsetHeight, q.documentElement.clientHeight) : f.chartHeight,
            Q = f.pointer.getChartPosition(),
            H = f.containerScaling,
            K = function (b) {
          return H ? b * H.scaleX : b;
        },
            p = function (b) {
          return H ? b * H.scaleY : b;
        },
            b = function (b) {
          var l = "x" === b;
          return [b, l ? h : g, l ? c : e].concat(w ? [l ? K(c) : p(e), l ? Q.left - a + K(d.plotX + f.plotLeft) : Q.top - a + p(d.plotY + f.plotTop), 0, l ? h : g] : [l ? c : e, l ? d.plotX + f.plotLeft : d.plotY + f.plotTop, l ? f.plotLeft : f.plotTop, l ? f.plotLeft + f.plotWidth : f.plotTop + f.plotHeight]);
        },
            C = b("y"),
            x = b("x"),
            R = !this.followPointer && t(d.ttBelow, !f.inverted === !!d.negative),
            O = function (b, c, f, e, d, m, v) {
          var n = "y" === b ? p(a) : K(a),
              w = (f - e) / 2,
              x = e < d - a,
              h = d + a + e < c,
              F = d - n - f + w;
          d = d + n - w;
          if (R && h) l[b] = d;else if (!R && x) l[b] = F;else if (x) l[b] = Math.min(v - e, 0 > F - k ? F : F - k);else if (h) l[b] = Math.max(m, d + k + f > c ? d : d + k);else return !1;
        },
            y = function (b, c, f, e, d) {
          var k;
          d < a || d > c - a ? k = !1 : l[b] = d < f / 2 ? 1 : d > c - e / 2 ? c - e - 2 : d - f / 2;
          return k;
        },
            u = function (b) {
          var a = C;
          C = x;
          x = a;
          n = b;
        },
            m = function () {
          !1 !== O.apply(0, C) ? !1 !== y.apply(0, x) || n || (u(!0), m()) : n ? l.x = l.y = 0 : (u(!0), m());
        };

        (f.inverted || 1 < this.len) && u();
        m();
        return l;
      };

      e.prototype.getXDateFormat = function (c, e, d) {
        e = e.dateTimeLabelFormats;
        var f = d && d.closestPointRange;
        return (f ? this.getDateFormat(f, c.x, d.options.startOfWeek, e) : e.day) || e.year;
      };

      e.prototype.hide = function (c) {
        var e = this;
        g.clearTimeout(this.hideTimer);
        c = t(c, this.options.hideDelay, 500);
        this.isHidden || (this.hideTimer = h(function () {
          e.getLabel()[c ? "fadeOut" : "hide"]();
          e.isHidden = !0;
        }, c));
      };

      e.prototype.init = function (c, e) {
        this.chart = c;
        this.options = e;
        this.crosshairs = [];
        this.now = {
          x: 0,
          y: 0
        };
        this.isHidden = !0;
        this.split = e.split && !c.inverted && !c.polar;
        this.shared = e.shared || this.split;
        this.outside = t(e.outside, !(!c.scrollablePixelsX && !c.scrollablePixelsY));
      };

      e.prototype.isStickyOnContact = function () {
        return !(this.followPointer || !this.options.stickOnContact || !this.inContact);
      };

      e.prototype.move = function (c, e, d, f) {
        var a = this,
            l = a.now,
            k = !1 !== a.options.animation && !a.isHidden && (1 < Math.abs(c - l.x) || 1 < Math.abs(e - l.y)),
            n = a.followPointer || 1 < a.len;
        E(l, {
          x: k ? (2 * l.x + c) / 3 : c,
          y: k ? (l.y + e) / 2 : e,
          anchorX: n ? void 0 : k ? (2 * l.anchorX + d) / 3 : d,
          anchorY: n ? void 0 : k ? (l.anchorY + f) / 2 : f
        });
        a.getLabel().attr(l);
        a.drawTracker();
        k && (g.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
          a && a.move(c, e, d, f);
        }, 32));
      };

      e.prototype.refresh = function (c, e) {
        var k = this.chart,
            f = this.options,
            a = c,
            l = {},
            v = [],
            h = f.formatter || this.defaultFormatter;
        l = this.shared;
        var w = k.styledMode;

        if (f.enabled) {
          g.clearTimeout(this.hideTimer);
          this.followPointer = D(a)[0].series.tooltipOptions.followPointer;
          var B = this.getAnchor(a, e);
          e = B[0];
          var q = B[1];
          !l || a.series && a.series.noSharedTooltip ? l = a.getLabelConfig() : (k.pointer.applyInactiveState(a), a.forEach(function (a) {
            a.setState("hover");
            v.push(a.getLabelConfig());
          }), l = {
            x: a[0].category,
            y: a[0].y
          }, l.points = v, a = a[0]);
          this.len = v.length;
          k = h.call(l, this);
          h = a.series;
          this.distance = t(h.tooltipOptions.distance, 16);
          !1 === k ? this.hide() : (this.split ? this.renderSplit(k, D(c)) : (c = this.getLabel(), f.style.width && !w || c.css({
            width: this.chart.spacingBox.width
          }), c.attr({
            text: k && k.join ? k.join("") : k
          }), c.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + t(a.colorIndex, h.colorIndex)), w || c.attr({
            stroke: f.borderColor || a.color || h.color || "#666666"
          }), this.updatePosition({
            plotX: e,
            plotY: q,
            negative: a.negative,
            ttBelow: a.ttBelow,
            h: B[2] || 0
          })), this.isHidden && this.label && this.label.attr({
            opacity: 1
          }).show(), this.isHidden = !1);
          d.fireEvent(this, "refresh");
        }
      };

      e.prototype.renderSplit = function (c, e) {
        function k(b, a, c, f, e) {
          void 0 === e && (e = !0);
          c ? (a = u ? 0 : A, b = r(b - f / 2, O.left, O.right - f)) : (a -= m, b = e ? b - f - C : b + C, b = r(b, e ? b : O.left, O.right));
          return {
            x: b,
            y: a
          };
        }

        var f = this,
            a = f.chart,
            l = f.chart,
            v = l.plotHeight,
            h = l.plotLeft,
            w = l.plotTop,
            B = l.pointer,
            q = l.renderer,
            g = l.scrollablePixelsY,
            H = void 0 === g ? 0 : g;
        g = l.scrollingContainer;
        g = void 0 === g ? {
          scrollLeft: 0,
          scrollTop: 0
        } : g;
        var K = g.scrollLeft,
            p = g.scrollTop,
            b = l.styledMode,
            C = f.distance,
            x = f.options,
            R = f.options.positioner,
            O = {
          left: K,
          right: K + l.chartWidth,
          top: p,
          bottom: p + l.chartHeight
        },
            y = f.getLabel(),
            u = !(!a.xAxis[0] || !a.xAxis[0].opposite),
            m = w + p,
            D = 0,
            A = v - H;
        J(c) && (c = [!1, c]);
        c = c.slice(0, e.length + 1).reduce(function (a, c, l) {
          if (!1 !== c && "" !== c) {
            l = e[l - 1] || {
              isHeader: !0,
              plotX: e[0].plotX,
              plotY: v,
              series: {}
            };
            var d = l.isHeader,
                n = d ? f : l.series,
                F = n.tt,
                z = l.isHeader;
            var B = l.series;
            var g = "highcharts-color-" + t(l.colorIndex, B.colorIndex, "none");
            F || (F = {
              padding: x.padding,
              r: x.borderRadius
            }, b || (F.fill = x.backgroundColor, F["stroke-width"] = x.borderWidth), F = q.label("", 0, 0, x[z ? "headerShape" : "shape"] || "callout", void 0, void 0, x.useHTML).addClass((z ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + g).attr(F).add(y));
            F.isActive = !0;
            F.attr({
              text: c
            });
            b || F.css(x.style).shadow(x.shadow).attr({
              stroke: x.borderColor || l.color || B.color || "#333333"
            });
            c = n.tt = F;
            z = c.getBBox();
            n = z.width + c.strokeWidth();
            d && (D = z.height, A += D, u && (m -= D));
            B = l.plotX;
            B = void 0 === B ? 0 : B;
            g = l.plotY;
            g = void 0 === g ? 0 : g;
            var L = l.series;

            if (l.isHeader) {
              B = h + B;
              var K = w + v / 2;
            } else F = L.xAxis, L = L.yAxis, B = F.pos + r(B, -C, F.len + C), L.pos + g >= p + w && L.pos + g <= p + w + v - H && (K = L.pos + g);

            B = r(B, O.left - C, O.right + C);
            "number" === typeof K ? (z = z.height + 1, g = R ? R.call(f, n, z, l) : k(B, K, d, n), a.push({
              align: R ? 0 : void 0,
              anchorX: B,
              anchorY: K,
              boxWidth: n,
              point: l,
              rank: t(g.rank, d ? 1 : 0),
              size: z,
              target: g.y,
              tt: c,
              x: g.x
            })) : c.isActive = !1;
          }

          return a;
        }, []);
        !R && c.some(function (b) {
          return b.x < O.left;
        }) && (c = c.map(function (b) {
          var a = k(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);
          return E(b, {
            target: a.y,
            x: a.x
          });
        }));
        f.cleanSplit();
        d.distribute(c, A);
        c.forEach(function (b) {
          var a = b.pos;
          b.tt.attr({
            visibility: "undefined" === typeof a ? "hidden" : "inherit",
            x: b.x,
            y: a + m,
            anchorX: b.anchorX,
            anchorY: b.anchorY
          });
        });
        c = f.container;
        a = f.renderer;
        f.outside && c && a && (l = y.getBBox(), a.setSize(l.width + l.x, l.height + l.y, !1), B = B.getChartPosition(), c.style.left = B.left + "px", c.style.top = B.top + "px");
      };

      e.prototype.drawTracker = function () {
        if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {
          var c = this.chart,
              e = this.label,
              d = c.hoverPoint;

          if (e && d) {
            var f = {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            };
            d = this.getAnchor(d);
            var a = e.getBBox();
            d[0] += c.plotLeft - e.translateX;
            d[1] += c.plotTop - e.translateY;
            f.x = Math.min(0, d[0]);
            f.y = Math.min(0, d[1]);
            f.width = 0 > d[0] ? Math.max(Math.abs(d[0]), a.width - d[0]) : Math.max(Math.abs(d[0]), a.width);
            f.height = 0 > d[1] ? Math.max(Math.abs(d[1]), a.height - Math.abs(d[1])) : Math.max(Math.abs(d[1]), a.height);
            this.tracker ? this.tracker.attr(f) : (this.tracker = e.renderer.rect(f).addClass("highcharts-tracker").add(e), c.styledMode || this.tracker.attr({
              fill: "rgba(0,0,0,0)"
            }));
          }
        }
      };

      e.prototype.styledModeFormat = function (c) {
        return c.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
      };

      e.prototype.tooltipFooterHeaderFormatter = function (c, e) {
        var k = e ? "footer" : "header",
            f = c.series,
            a = f.tooltipOptions,
            l = a.xDateFormat,
            v = f.xAxis,
            h = v && "datetime" === v.options.type && G(c.key),
            w = a[k + "Format"];
        e = {
          isFooter: e,
          labelConfig: c
        };
        d.fireEvent(this, "headerFormatter", e, function (e) {
          h && !l && (l = this.getXDateFormat(c, a, v));
          h && l && (c.point && c.point.tooltipDateKeys || ["key"]).forEach(function (a) {
            w = w.replace("{point." + a + "}", "{point." + a + ":" + l + "}");
          });
          f.chart.styledMode && (w = this.styledModeFormat(w));
          e.text = A(w, {
            point: c,
            series: f
          }, this.chart);
        });
        return e.text;
      };

      e.prototype.update = function (c) {
        this.destroy();
        y(!0, this.chart.options.tooltip.userOptions, c);
        this.init(this.chart, y(!0, this.options, c));
      };

      e.prototype.updatePosition = function (c) {
        var e = this.chart,
            d = e.pointer,
            f = this.getLabel(),
            a = c.plotX + e.plotLeft,
            l = c.plotY + e.plotTop;
        d = d.getChartPosition();
        c = (this.options.positioner || this.getPosition).call(this, f.width, f.height, c);

        if (this.outside) {
          var v = (this.options.borderWidth || 0) + 2 * this.distance;
          this.renderer.setSize(f.width + v, f.height + v, !1);
          if (e = e.containerScaling) u(this.container, {
            transform: "scale(" + e.scaleX + ", " + e.scaleY + ")"
          }), a *= e.scaleX, l *= e.scaleY;
          a += d.left - c.x;
          l += d.top - c.y;
        }

        this.move(Math.round(c.x), Math.round(c.y || 0), a, l);
      };

      return e;
    }();

    d.Tooltip = P;
    return d.Tooltip;
  });
  S(r, "parts/Pointer.js", [r["parts/Globals.js"], r["parts/Utilities.js"], r["parts/Tooltip.js"], r["parts/Color.js"]], function (d, g, r, u) {
    var I = g.addEvent,
        M = g.attr,
        E = g.css,
        A = g.defined,
        G = g.extend,
        J = g.find,
        y = g.fireEvent,
        t = g.isNumber,
        D = g.isObject,
        h = g.objectEach,
        N = g.offset,
        q = g.pick,
        P = g.splat,
        e = u.parse,
        c = d.charts,
        k = d.noop;

    g = function () {
      function n(c, a) {
        this.lastValidTouch = {};
        this.pinchDown = [];
        this.runChartClick = !1;
        this.chart = c;
        this.hasDragged = !1;
        this.options = a;

        this.unbindContainerMouseLeave = function () {};

        this.init(c, a);
      }

      n.prototype.applyInactiveState = function (c) {
        var a = [],
            f;
        (c || []).forEach(function (c) {
          f = c.series;
          a.push(f);
          f.linkedParent && a.push(f.linkedParent);
          f.linkedSeries && (a = a.concat(f.linkedSeries));
          f.navigatorSeries && a.push(f.navigatorSeries);
        });
        this.chart.series.forEach(function (c) {
          -1 === a.indexOf(c) ? c.setState("inactive", !0) : c.options.inactiveOtherPoints && c.setAllPointsToState("inactive");
        });
      };

      n.prototype.destroy = function () {
        var c = this;
        "undefined" !== typeof c.unDocMouseMove && c.unDocMouseMove();
        this.unbindContainerMouseLeave();
        d.chartCount || (d.unbindDocumentMouseUp && (d.unbindDocumentMouseUp = d.unbindDocumentMouseUp()), d.unbindDocumentTouchEnd && (d.unbindDocumentTouchEnd = d.unbindDocumentTouchEnd()));
        clearInterval(c.tooltipTimeout);
        h(c, function (a, f) {
          c[f] = null;
        });
      };

      n.prototype.drag = function (c) {
        var a = this.chart,
            f = a.options.chart,
            d = c.chartX,
            k = c.chartY,
            w = this.zoomHor,
            n = this.zoomVert,
            h = a.plotLeft,
            q = a.plotTop,
            g = a.plotWidth,
            t = a.plotHeight,
            p = this.selectionMarker,
            b = this.mouseDownX || 0,
            C = this.mouseDownY || 0,
            x = D(f.panning) ? f.panning && f.panning.enabled : f.panning,
            y = f.panKey && c[f.panKey + "Key"];
        if (!p || !p.touch) if (d < h ? d = h : d > h + g && (d = h + g), k < q ? k = q : k > q + t && (k = q + t), this.hasDragged = Math.sqrt(Math.pow(b - d, 2) + Math.pow(C - k, 2)), 10 < this.hasDragged) {
          var O = a.isInsidePlot(b - h, C - q);
          a.hasCartesianSeries && (this.zoomX || this.zoomY) && O && !y && !p && (this.selectionMarker = p = a.renderer.rect(h, q, w ? 1 : g, n ? 1 : t, 0).attr({
            "class": "highcharts-selection-marker",
            zIndex: 7
          }).add(), a.styledMode || p.attr({
            fill: f.selectionMarkerFill || e("#335cad").setOpacity(.25).get()
          }));
          p && w && (d -= b, p.attr({
            width: Math.abs(d),
            x: (0 < d ? 0 : d) + b
          }));
          p && n && (d = k - C, p.attr({
            height: Math.abs(d),
            y: (0 < d ? 0 : d) + C
          }));
          O && !p && x && a.pan(c, f.panning);
        }
      };

      n.prototype.dragStart = function (c) {
        var a = this.chart;
        a.mouseIsDown = c.type;
        a.cancelClick = !1;
        a.mouseDownX = this.mouseDownX = c.chartX;
        a.mouseDownY = this.mouseDownY = c.chartY;
      };

      n.prototype.drop = function (c) {
        var a = this,
            f = this.chart,
            e = this.hasPinched;

        if (this.selectionMarker) {
          var d = {
            originalEvent: c,
            xAxis: [],
            yAxis: []
          },
              k = this.selectionMarker,
              n = k.attr ? k.attr("x") : k.x,
              h = k.attr ? k.attr("y") : k.y,
              q = k.attr ? k.attr("width") : k.width,
              g = k.attr ? k.attr("height") : k.height,
              K;
          if (this.hasDragged || e) f.axes.forEach(function (f) {
            if (f.zoomEnabled && A(f.min) && (e || a[{
              xAxis: "zoomX",
              yAxis: "zoomY"
            }[f.coll]])) {
              var b = f.horiz,
                  l = "touchend" === c.type ? f.minPixelPadding : 0,
                  k = f.toValue((b ? n : h) + l);
              b = f.toValue((b ? n + q : h + g) - l);
              d[f.coll].push({
                axis: f,
                min: Math.min(k, b),
                max: Math.max(k, b)
              });
              K = !0;
            }
          }), K && y(f, "selection", d, function (a) {
            f.zoom(G(a, e ? {
              animation: !1
            } : null));
          });
          t(f.index) && (this.selectionMarker = this.selectionMarker.destroy());
          e && this.scaleGroups();
        }

        f && t(f.index) && (E(f.container, {
          cursor: f._cursor
        }), f.cancelClick = 10 < this.hasDragged, f.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
      };

      n.prototype.findNearestKDPoint = function (c, a, e) {
        var f = this.chart,
            d = f.hoverPoint;
        f = f.tooltip;
        if (d && f && f.isStickyOnContact()) return d;
        var l;
        c.forEach(function (c) {
          var f = !(c.noSharedTooltip && a) && 0 > c.options.findNearestPointBy.indexOf("y");
          c = c.searchPoint(e, f);

          if ((f = D(c, !0)) && !(f = !D(l, !0))) {
            f = l.distX - c.distX;
            var d = l.dist - c.dist,
                k = (c.series.group && c.series.group.zIndex) - (l.series.group && l.series.group.zIndex);
            f = 0 < (0 !== f && a ? f : 0 !== d ? d : 0 !== k ? k : l.series.index > c.series.index ? -1 : 1);
          }

          f && (l = c);
        });
        return l;
      };

      n.prototype.getChartCoordinatesFromPoint = function (c, a) {
        var f = c.series,
            e = f.xAxis;
        f = f.yAxis;
        var d = q(c.clientX, c.plotX),
            k = c.shapeArgs;
        if (e && f) return a ? {
          chartX: e.len + e.pos - d,
          chartY: f.len + f.pos - c.plotY
        } : {
          chartX: d + e.pos,
          chartY: c.plotY + f.pos
        };
        if (k && k.x && k.y) return {
          chartX: k.x,
          chartY: k.y
        };
      };

      n.prototype.getChartPosition = function () {
        return this.chartPosition || (this.chartPosition = N(this.chart.container));
      };

      n.prototype.getCoordinates = function (c) {
        var a = {
          xAxis: [],
          yAxis: []
        };
        this.chart.axes.forEach(function (f) {
          a[f.isXAxis ? "xAxis" : "yAxis"].push({
            axis: f,
            value: f.toValue(c[f.horiz ? "chartX" : "chartY"])
          });
        });
        return a;
      };

      n.prototype.getHoverData = function (c, a, e, d, k, n) {
        var f,
            l = [];
        d = !(!d || !c);
        var v = a && !a.stickyTracking,
            h = {
          chartX: n ? n.chartX : void 0,
          chartY: n ? n.chartY : void 0,
          shared: k
        };
        y(this, "beforeGetHoverData", h);
        v = v ? [a] : e.filter(function (a) {
          return h.filter ? h.filter(a) : a.visible && !(!k && a.directTouch) && q(a.options.enableMouseTracking, !0) && a.stickyTracking;
        });
        a = (f = d || !n ? c : this.findNearestKDPoint(v, k, n)) && f.series;
        f && (k && !a.noSharedTooltip ? (v = e.filter(function (a) {
          return h.filter ? h.filter(a) : a.visible && !(!k && a.directTouch) && q(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;
        }), v.forEach(function (a) {
          var c = J(a.points, function (b) {
            return b.x === f.x && !b.isNull;
          });
          D(c) && (a.chart.isBoosting && (c = a.getPoint(c)), l.push(c));
        })) : l.push(f));
        h = {
          hoverPoint: f
        };
        y(this, "afterGetHoverData", h);
        return {
          hoverPoint: h.hoverPoint,
          hoverSeries: a,
          hoverPoints: l
        };
      };

      n.prototype.getPointFromEvent = function (c) {
        c = c.target;

        for (var a; c && !a;) a = c.point, c = c.parentNode;

        return a;
      };

      n.prototype.onTrackerMouseOut = function (c) {
        var a = this.chart.hoverSeries;
        c = c.relatedTarget || c.toElement;
        this.isDirectTouch = !1;
        if (!(!a || !c || a.stickyTracking || this.inClass(c, "highcharts-tooltip") || this.inClass(c, "highcharts-series-" + a.index) && this.inClass(c, "highcharts-tracker"))) a.onMouseOut();
      };

      n.prototype.inClass = function (c, a) {
        for (var f; c;) {
          if (f = M(c, "class")) {
            if (-1 !== f.indexOf(a)) return !0;
            if (-1 !== f.indexOf("highcharts-container")) return !1;
          }

          c = c.parentNode;
        }
      };

      n.prototype.init = function (c, a) {
        this.options = a;
        this.chart = c;
        this.runChartClick = a.chart.events && !!a.chart.events.click;
        this.pinchDown = [];
        this.lastValidTouch = {};
        r && (c.tooltip = new r(c, a.tooltip), this.followTouchMove = q(a.tooltip.followTouchMove, !0));
        this.setDOMEvents();
      };

      n.prototype.normalize = function (c, a) {
        var f = c.touches,
            e = f ? f.length ? f.item(0) : f.changedTouches[0] : c;
        a || (a = this.getChartPosition());
        f = e.pageX - a.left;
        a = e.pageY - a.top;
        if (e = this.chart.containerScaling) f /= e.scaleX, a /= e.scaleY;
        return G(c, {
          chartX: Math.round(f),
          chartY: Math.round(a)
        });
      };

      n.prototype.onContainerClick = function (c) {
        var a = this.chart,
            f = a.hoverPoint,
            e = a.plotLeft,
            d = a.plotTop;
        c = this.normalize(c);
        a.cancelClick || (f && this.inClass(c.target, "highcharts-tracker") ? (y(f.series, "click", G(c, {
          point: f
        })), a.hoverPoint && f.firePointEvent("click", c)) : (G(c, this.getCoordinates(c)), a.isInsidePlot(c.chartX - e, c.chartY - d) && y(a, "click", c)));
      };

      n.prototype.onContainerMouseDown = function (c) {
        c = this.normalize(c);
        2 !== c.button && (this.zoomOption(c), c.preventDefault && c.preventDefault(), this.dragStart(c));
      };

      n.prototype.onContainerMouseLeave = function (f) {
        var a = c[d.hoverChartIndex];
        a && (f.relatedTarget || f.toElement) && (a.pointer.reset(), a.pointer.chartPosition = void 0);
      };

      n.prototype.onContainerMouseMove = function (f) {
        var a = this.chart;
        A(d.hoverChartIndex) && c[d.hoverChartIndex] && c[d.hoverChartIndex].mouseIsDown || (d.hoverChartIndex = a.index);
        f = this.normalize(f);
        f.preventDefault || (f.returnValue = !1);
        "mousedown" === a.mouseIsDown && this.drag(f);
        a.openMenu || !this.inClass(f.target, "highcharts-tracker") && !a.isInsidePlot(f.chartX - a.plotLeft, f.chartY - a.plotTop) || this.runPointActions(f);
      };

      n.prototype.onDocumentTouchEnd = function (f) {
        c[d.hoverChartIndex] && c[d.hoverChartIndex].pointer.drop(f);
      };

      n.prototype.onContainerTouchMove = function (c) {
        this.touch(c);
      };

      n.prototype.onContainerTouchStart = function (c) {
        this.zoomOption(c);
        this.touch(c, !0);
      };

      n.prototype.onDocumentMouseMove = function (c) {
        var a = this.chart,
            f = this.chartPosition,
            e = a.tooltip;
        c = this.normalize(c, f);
        !f || e && e.isStickyOnContact() || a.isInsidePlot(c.chartX - a.plotLeft, c.chartY - a.plotTop) || this.inClass(c.target, "highcharts-tracker") || this.reset();
      };

      n.prototype.onDocumentMouseUp = function (f) {
        c[d.hoverChartIndex] && c[d.hoverChartIndex].pointer.drop(f);
      };

      n.prototype.pinch = function (c) {
        var a = this,
            f = a.chart,
            e = a.pinchDown,
            d = c.touches || [],
            n = d.length,
            h = a.lastValidTouch,
            g = a.hasZoom,
            t = a.selectionMarker,
            H = {},
            K = 1 === n && (a.inClass(c.target, "highcharts-tracker") && f.runTrackerClick || a.runChartClick),
            p = {};
        1 < n && (a.initiated = !0);
        g && a.initiated && !K && c.preventDefault();
        [].map.call(d, function (b) {
          return a.normalize(b);
        });
        "touchstart" === c.type ? ([].forEach.call(d, function (b, a) {
          e[a] = {
            chartX: b.chartX,
            chartY: b.chartY
          };
        }), h.x = [e[0].chartX, e[1] && e[1].chartX], h.y = [e[0].chartY, e[1] && e[1].chartY], f.axes.forEach(function (b) {
          if (b.zoomEnabled) {
            var a = f.bounds[b.horiz ? "h" : "v"],
                c = b.minPixelPadding,
                e = b.toPixels(Math.min(q(b.options.min, b.dataMin), b.dataMin)),
                d = b.toPixels(Math.max(q(b.options.max, b.dataMax), b.dataMax)),
                l = Math.max(e, d);
            a.min = Math.min(b.pos, Math.min(e, d) - c);
            a.max = Math.max(b.pos + b.len, l + c);
          }
        }), a.res = !0) : a.followTouchMove && 1 === n ? this.runPointActions(a.normalize(c)) : e.length && (t || (a.selectionMarker = t = G({
          destroy: k,
          touch: !0
        }, f.plotBox)), a.pinchTranslate(e, d, H, t, p, h), a.hasPinched = g, a.scaleGroups(H, p), a.res && (a.res = !1, this.reset(!1, 0)));
      };

      n.prototype.pinchTranslate = function (c, a, e, d, k, n) {
        this.zoomHor && this.pinchTranslateDirection(!0, c, a, e, d, k, n);
        this.zoomVert && this.pinchTranslateDirection(!1, c, a, e, d, k, n);
      };

      n.prototype.pinchTranslateDirection = function (c, a, e, d, k, n, h, q) {
        var f = this.chart,
            l = c ? "x" : "y",
            v = c ? "X" : "Y",
            p = "chart" + v,
            b = c ? "width" : "height",
            w = f["plot" + (c ? "Left" : "Top")],
            x,
            B,
            g = q || 1,
            z = f.inverted,
            t = f.bounds[c ? "h" : "v"],
            m = 1 === a.length,
            L = a[0][p],
            y = e[0][p],
            u = !m && a[1][p],
            F = !m && e[1][p];

        e = function () {
          "number" === typeof F && 20 < Math.abs(L - u) && (g = q || Math.abs(y - F) / Math.abs(L - u));
          B = (w - y) / g + L;
          x = f["plot" + (c ? "Width" : "Height")] / g;
        };

        e();
        a = B;

        if (a < t.min) {
          a = t.min;
          var V = !0;
        } else a + x > t.max && (a = t.max - x, V = !0);

        V ? (y -= .8 * (y - h[l][0]), "number" === typeof F && (F -= .8 * (F - h[l][1])), e()) : h[l] = [y, F];
        z || (n[l] = B - w, n[b] = x);
        n = z ? 1 / g : g;
        k[b] = x;
        k[l] = a;
        d[z ? c ? "scaleY" : "scaleX" : "scale" + v] = g;
        d["translate" + v] = n * w + (y - n * L);
      };

      n.prototype.reset = function (c, a) {
        var f = this.chart,
            e = f.hoverSeries,
            d = f.hoverPoint,
            k = f.hoverPoints,
            n = f.tooltip,
            h = n && n.shared ? k : d;
        c && h && P(h).forEach(function (a) {
          a.series.isCartesian && "undefined" === typeof a.plotX && (c = !1);
        });
        if (c) n && h && P(h).length && (n.refresh(h), n.shared && k ? k.forEach(function (a) {
          a.setState(a.state, !0);
          a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));
        }) : d && (d.setState(d.state, !0), f.axes.forEach(function (a) {
          a.crosshair && d.series[a.coll] === a && a.drawCrosshair(null, d);
        })));else {
          if (d) d.onMouseOut();
          k && k.forEach(function (a) {
            a.setState();
          });
          if (e) e.onMouseOut();
          n && n.hide(a);
          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
          f.axes.forEach(function (a) {
            a.hideCrosshair();
          });
          this.hoverX = f.hoverPoints = f.hoverPoint = null;
        }
      };

      n.prototype.runPointActions = function (f, a) {
        var e = this.chart,
            k = e.tooltip && e.tooltip.options.enabled ? e.tooltip : void 0,
            n = k ? k.shared : !1,
            h = a || e.hoverPoint,
            g = h && h.series || e.hoverSeries;
        g = this.getHoverData(h, g, e.series, (!f || "touchmove" !== f.type) && (!!a || g && g.directTouch && this.isDirectTouch), n, f);
        h = g.hoverPoint;
        var t = g.hoverPoints;
        a = (g = g.hoverSeries) && g.tooltipOptions.followPointer;
        n = n && g && !g.noSharedTooltip;

        if (h && (h !== e.hoverPoint || k && k.isHidden)) {
          (e.hoverPoints || []).forEach(function (a) {
            -1 === t.indexOf(a) && a.setState();
          });
          if (e.hoverSeries !== g) g.onMouseOver();
          this.applyInactiveState(t);
          (t || []).forEach(function (a) {
            a.setState("hover");
          });
          e.hoverPoint && e.hoverPoint.firePointEvent("mouseOut");
          if (!h.series) return;
          h.firePointEvent("mouseOver");
          e.hoverPoints = t;
          e.hoverPoint = h;
          k && k.refresh(n ? t : h, f);
        } else a && k && !k.isHidden && (h = k.getAnchor([{}], f), k.updatePosition({
          plotX: h[0],
          plotY: h[1]
        }));

        this.unDocMouseMove || (this.unDocMouseMove = I(e.container.ownerDocument, "mousemove", function (a) {
          var f = c[d.hoverChartIndex];
          if (f) f.pointer.onDocumentMouseMove(a);
        }));
        e.axes.forEach(function (a) {
          var c = q(a.crosshair.snap, !0),
              e = c ? J(t, function (c) {
            return c.series[a.coll] === a;
          }) : void 0;
          e || !c ? a.drawCrosshair(f, e) : a.hideCrosshair();
        });
      };

      n.prototype.scaleGroups = function (c, a) {
        var f = this.chart,
            e;
        f.series.forEach(function (d) {
          e = c || d.getPlotBox();
          d.xAxis && d.xAxis.zoomEnabled && d.group && (d.group.attr(e), d.markerGroup && (d.markerGroup.attr(e), d.markerGroup.clip(a ? f.clipRect : null)), d.dataLabelsGroup && d.dataLabelsGroup.attr(e));
        });
        f.clipRect.attr(a || f.clipBox);
      };

      n.prototype.setDOMEvents = function () {
        var c = this,
            a = c.chart.container,
            e = a.ownerDocument;

        a.onmousedown = function (a) {
          c.onContainerMouseDown(a);
        };

        a.onmousemove = function (a) {
          c.onContainerMouseMove(a);
        };

        a.onclick = function (a) {
          c.onContainerClick(a);
        };

        this.unbindContainerMouseLeave = I(a, "mouseleave", c.onContainerMouseLeave);
        d.unbindDocumentMouseUp || (d.unbindDocumentMouseUp = I(e, "mouseup", c.onDocumentMouseUp));
        d.hasTouch && (I(a, "touchstart", function (a) {
          c.onContainerTouchStart(a);
        }), I(a, "touchmove", function (a) {
          c.onContainerTouchMove(a);
        }), d.unbindDocumentTouchEnd || (d.unbindDocumentTouchEnd = I(e, "touchend", c.onDocumentTouchEnd)));
      };

      n.prototype.touch = function (c, a) {
        var f = this.chart,
            e;
        if (f.index !== d.hoverChartIndex) this.onContainerMouseLeave({
          relatedTarget: !0
        });
        d.hoverChartIndex = f.index;
        if (1 === c.touches.length) {
          if (c = this.normalize(c), (e = f.isInsidePlot(c.chartX - f.plotLeft, c.chartY - f.plotTop)) && !f.openMenu) {
            a && this.runPointActions(c);

            if ("touchmove" === c.type) {
              a = this.pinchDown;
              var k = a[0] ? 4 <= Math.sqrt(Math.pow(a[0].chartX - c.chartX, 2) + Math.pow(a[0].chartY - c.chartY, 2)) : !1;
            }

            q(k, !0) && this.pinch(c);
          } else a && this.reset();
        } else 2 === c.touches.length && this.pinch(c);
      };

      n.prototype.zoomOption = function (c) {
        var a = this.chart,
            f = a.options.chart,
            e = f.zoomType || "";
        a = a.inverted;
        /touch/.test(c.type) && (e = q(f.pinchType, e));
        this.zoomX = c = /x/.test(e);
        this.zoomY = e = /y/.test(e);
        this.zoomHor = c && !a || e && a;
        this.zoomVert = e && !a || c && a;
        this.hasZoom = c || e;
      };

      return n;
    }();

    d.Pointer = g;
    return d.Pointer;
  });
  S(r, "parts/MSPointer.js", [r["parts/Globals.js"], r["parts/Pointer.js"], r["parts/Utilities.js"]], function (d, g, r) {
    function u() {
      var d = [];

      d.item = function (d) {
        return this[d];
      };

      G(h, function (h) {
        d.push({
          pageX: h.pageX,
          pageY: h.pageY,
          target: h.target
        });
      });
      return d;
    }

    function I(h, g, e, c) {
      "touch" !== h.pointerType && h.pointerType !== h.MSPOINTER_TYPE_TOUCH || !y[d.hoverChartIndex] || (c(h), c = y[d.hoverChartIndex].pointer, c[g]({
        type: e,
        target: h.currentTarget,
        preventDefault: D,
        touches: u()
      }));
    }

    var M = this && this.__extends || function () {
      var d = function (h, e) {
        d = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (c, e) {
          c.__proto__ = e;
        } || function (c, e) {
          for (var d in e) e.hasOwnProperty(d) && (c[d] = e[d]);
        };

        return d(h, e);
      };

      return function (h, e) {
        function c() {
          this.constructor = h;
        }

        d(h, e);
        h.prototype = null === e ? Object.create(e) : (c.prototype = e.prototype, new c());
      };
    }(),
        E = r.addEvent,
        A = r.css,
        G = r.objectEach,
        J = r.removeEvent,
        y = d.charts,
        t = d.doc,
        D = d.noop,
        h = {},
        N = !!d.win.PointerEvent;

    return function (d) {
      function g() {
        return null !== d && d.apply(this, arguments) || this;
      }

      M(g, d);

      g.prototype.batchMSEvents = function (e) {
        e(this.chart.container, N ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
        e(this.chart.container, N ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
        e(t, N ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
      };

      g.prototype.destroy = function () {
        this.batchMSEvents(J);
        d.prototype.destroy.call(this);
      };

      g.prototype.init = function (e, c) {
        d.prototype.init.call(this, e, c);
        this.hasZoom && A(e.container, {
          "-ms-touch-action": "none",
          "touch-action": "none"
        });
      };

      g.prototype.onContainerPointerDown = function (e) {
        I(e, "onContainerTouchStart", "touchstart", function (c) {
          h[c.pointerId] = {
            pageX: c.pageX,
            pageY: c.pageY,
            target: c.currentTarget
          };
        });
      };

      g.prototype.onContainerPointerMove = function (e) {
        I(e, "onContainerTouchMove", "touchmove", function (c) {
          h[c.pointerId] = {
            pageX: c.pageX,
            pageY: c.pageY
          };
          h[c.pointerId].target || (h[c.pointerId].target = c.currentTarget);
        });
      };

      g.prototype.onDocumentPointerUp = function (e) {
        I(e, "onDocumentTouchEnd", "touchend", function (c) {
          delete h[c.pointerId];
        });
      };

      g.prototype.setDOMEvents = function () {
        d.prototype.setDOMEvents.call(this);
        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(E);
      };

      return g;
    }(g);
  });
  S(r, "parts/Legend.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.addEvent,
        u = g.css,
        I = g.defined,
        M = g.discardElement,
        E = g.find,
        A = g.fireEvent,
        G = g.format,
        J = g.isNumber,
        y = g.merge,
        t = g.pick,
        D = g.relativeLength,
        h = g.setAnimation,
        N = g.stableSort,
        q = g.syncTimeout;
    g = g.wrap;

    var P = d.isFirefox,
        e = d.marginNames,
        c = d.win,
        k = function () {
      function c(c, a) {
        this.allItems = [];
        this.contentGroup = this.box = void 0;
        this.display = !1;
        this.group = void 0;
        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
        this.options = {};
        this.padding = 0;
        this.pages = [];
        this.proximate = !1;
        this.scrollGroup = void 0;
        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
        this.chart = c;
        this.init(c, a);
      }

      c.prototype.init = function (c, a) {
        this.chart = c;
        this.setOptions(a);
        a.enabled && (this.render(), r(this.chart, "endResize", function () {
          this.legend.positionCheckboxes();
        }), this.proximate ? this.unchartrender = r(this.chart, "render", function () {
          this.legend.proximatePositions();
          this.legend.positionItems();
        }) : this.unchartrender && this.unchartrender());
      };

      c.prototype.setOptions = function (c) {
        var a = t(c.padding, 8);
        this.options = c;
        this.chart.styledMode || (this.itemStyle = c.itemStyle, this.itemHiddenStyle = y(this.itemStyle, c.itemHiddenStyle));
        this.itemMarginTop = c.itemMarginTop || 0;
        this.itemMarginBottom = c.itemMarginBottom || 0;
        this.padding = a;
        this.initialItemY = a - 5;
        this.symbolWidth = t(c.symbolWidth, 16);
        this.pages = [];
        this.proximate = "proximate" === c.layout && !this.chart.inverted;
        this.baseline = void 0;
      };

      c.prototype.update = function (c, a) {
        var f = this.chart;
        this.setOptions(y(!0, this.options, c));
        this.destroy();
        f.isDirtyLegend = f.isDirtyBox = !0;
        t(a, !0) && f.redraw();
        A(this, "afterUpdate");
      };

      c.prototype.colorizeItem = function (c, a) {
        c.legendGroup[a ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");

        if (!this.chart.styledMode) {
          var f = this.options,
              e = c.legendItem,
              d = c.legendLine,
              k = c.legendSymbol,
              h = this.itemHiddenStyle.color;
          f = a ? f.itemStyle.color : h;
          var n = a ? c.color || h : h,
              g = c.options && c.options.marker,
              q = {
            fill: n
          };
          e && e.css({
            fill: f,
            color: f
          });
          d && d.attr({
            stroke: n
          });
          k && (g && k.isMarker && (q = c.pointAttribs(), a || (q.stroke = q.fill = h)), k.attr(q));
        }

        A(this, "afterColorizeItem", {
          item: c,
          visible: a
        });
      };

      c.prototype.positionItems = function () {
        this.allItems.forEach(this.positionItem, this);
        this.chart.isResizing || this.positionCheckboxes();
      };

      c.prototype.positionItem = function (c) {
        var a = this.options,
            f = a.symbolPadding;
        a = !a.rtl;
        var e = c._legendItemPos,
            d = e[0];
        e = e[1];
        var k = c.checkbox;
        if ((c = c.legendGroup) && c.element) c[I(c.translateY) ? "animate" : "attr"]({
          translateX: a ? d : this.legendWidth - d - 2 * f - 4,
          translateY: e
        });
        k && (k.x = d, k.y = e);
      };

      c.prototype.destroyItem = function (c) {
        var a = c.checkbox;
        ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function (a) {
          c[a] && (c[a] = c[a].destroy());
        });
        a && M(c.checkbox);
      };

      c.prototype.destroy = function () {
        function c(a) {
          this[a] && (this[a] = this[a].destroy());
        }

        this.getAllItems().forEach(function (a) {
          ["legendItem", "legendGroup"].forEach(c, a);
        });
        "clipRect up down pager nav box title group".split(" ").forEach(c, this);
        this.display = null;
      };

      c.prototype.positionCheckboxes = function () {
        var c = this.group && this.group.alignAttr,
            a = this.clipHeight || this.legendHeight,
            e = this.titleHeight;

        if (c) {
          var d = c.translateY;
          this.allItems.forEach(function (f) {
            var k = f.checkbox;

            if (k) {
              var l = d + e + k.y + (this.scrollOffset || 0) + 3;
              u(k, {
                left: c.translateX + f.checkboxOffset + k.x - 20 + "px",
                top: l + "px",
                display: this.proximate || l > d - 6 && l < d + a - 6 ? "" : "none"
              });
            }
          }, this);
        }
      };

      c.prototype.renderTitle = function () {
        var c = this.options,
            a = this.padding,
            e = c.title,
            d = 0;
        e.text && (this.title || (this.title = this.chart.renderer.label(e.text, a - 3, a - 4, null, null, null, c.useHTML, null, "legend-title").attr({
          zIndex: 1
        }), this.chart.styledMode || this.title.css(e.style), this.title.add(this.group)), e.width || this.title.css({
          width: this.maxLegendWidth + "px"
        }), c = this.title.getBBox(), d = c.height, this.offsetWidth = c.width, this.contentGroup.attr({
          translateY: d
        }));
        this.titleHeight = d;
      };

      c.prototype.setText = function (c) {
        var a = this.options;
        c.legendItem.attr({
          text: a.labelFormat ? G(a.labelFormat, c, this.chart) : a.labelFormatter.call(c)
        });
      };

      c.prototype.renderItem = function (c) {
        var a = this.chart,
            e = a.renderer,
            f = this.options,
            d = this.symbolWidth,
            k = f.symbolPadding,
            h = this.itemStyle,
            n = this.itemHiddenStyle,
            g = "horizontal" === f.layout ? t(f.itemDistance, 20) : 0,
            q = !f.rtl,
            K = c.legendItem,
            p = !c.series,
            b = !p && c.series.drawLegendSymbol ? c.series : c,
            C = b.options;
        C = this.createCheckboxForItem && C && C.showCheckbox;
        g = d + k + g + (C ? 20 : 0);
        var x = f.useHTML,
            R = c.options.className;
        K || (c.legendGroup = e.g("legend-item").addClass("highcharts-" + b.type + "-series highcharts-color-" + c.colorIndex + (R ? " " + R : "") + (p ? " highcharts-series-" + c.index : "")).attr({
          zIndex: 1
        }).add(this.scrollGroup), c.legendItem = K = e.text("", q ? d + k : -k, this.baseline || 0, x), a.styledMode || K.css(y(c.visible ? h : n)), K.attr({
          align: q ? "left" : "right",
          zIndex: 2
        }).add(c.legendGroup), this.baseline || (this.fontMetrics = e.fontMetrics(a.styledMode ? 12 : h.fontSize, K), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, K.attr("y", this.baseline)), this.symbolHeight = f.symbolHeight || this.fontMetrics.f, b.drawLegendSymbol(this, c), this.setItemEvents && this.setItemEvents(c, K, x));
        C && !c.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(c);
        this.colorizeItem(c, c.visible);
        !a.styledMode && h.width || K.css({
          width: (f.itemWidth || this.widthOption || a.spacingBox.width) - g
        });
        this.setText(c);
        a = K.getBBox();
        c.itemWidth = c.checkboxOffset = f.itemWidth || c.legendItemWidth || a.width + g;
        this.maxItemWidth = Math.max(this.maxItemWidth, c.itemWidth);
        this.totalItemWidth += c.itemWidth;
        this.itemHeight = c.itemHeight = Math.round(c.legendItemHeight || a.height || this.symbolHeight);
      };

      c.prototype.layoutItem = function (c) {
        var a = this.options,
            e = this.padding,
            f = "horizontal" === a.layout,
            d = c.itemHeight,
            k = this.itemMarginBottom,
            h = this.itemMarginTop,
            n = f ? t(a.itemDistance, 20) : 0,
            g = this.maxLegendWidth;
        a = a.alignColumns && this.totalItemWidth > g ? this.maxItemWidth : c.itemWidth;
        f && this.itemX - e + a > g && (this.itemX = e, this.lastLineHeight && (this.itemY += h + this.lastLineHeight + k), this.lastLineHeight = 0);
        this.lastItemY = h + this.itemY + k;
        this.lastLineHeight = Math.max(d, this.lastLineHeight);
        c._legendItemPos = [this.itemX, this.itemY];
        f ? this.itemX += a : (this.itemY += h + d + k, this.lastLineHeight = d);
        this.offsetWidth = this.widthOption || Math.max((f ? this.itemX - e - (c.checkbox ? 0 : n) : a) + e, this.offsetWidth);
      };

      c.prototype.getAllItems = function () {
        var c = [];
        this.chart.series.forEach(function (a) {
          var e = a && a.options;
          a && t(e.showInLegend, I(e.linkedTo) ? !1 : void 0, !0) && (c = c.concat(a.legendItems || ("point" === e.legendType ? a.data : a)));
        });
        A(this, "afterGetAllItems", {
          allItems: c
        });
        return c;
      };

      c.prototype.getAlignment = function () {
        var c = this.options;
        return this.proximate ? c.align.charAt(0) + "tv" : c.floating ? "" : c.align.charAt(0) + c.verticalAlign.charAt(0) + c.layout.charAt(0);
      };

      c.prototype.adjustMargins = function (c, a) {
        var f = this.chart,
            d = this.options,
            k = this.getAlignment();
        k && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (l, h) {
          l.test(k) && !I(c[h]) && (f[e[h]] = Math.max(f[e[h]], f.legend[(h + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][h] * d[h % 2 ? "x" : "y"] + t(d.margin, 12) + a[h] + (f.titleOffset[h] || 0)));
        });
      };

      c.prototype.proximatePositions = function () {
        var c = this.chart,
            a = [],
            e = "left" === this.options.align;
        this.allItems.forEach(function (f) {
          var d = e;

          if (f.yAxis && f.points) {
            f.xAxis.options.reversed && (d = !d);
            var k = E(d ? f.points : f.points.slice(0).reverse(), function (a) {
              return J(a.plotY);
            });
            d = this.itemMarginTop + f.legendItem.getBBox().height + this.itemMarginBottom;
            var l = f.yAxis.top - c.plotTop;
            f.visible ? (k = k ? k.plotY : f.yAxis.height, k += l - .3 * d) : k = l + f.yAxis.height;
            a.push({
              target: k,
              size: d,
              item: f
            });
          }
        }, this);
        d.distribute(a, c.plotHeight);
        a.forEach(function (a) {
          a.item._legendItemPos[1] = c.plotTop - c.spacing[0] + a.pos;
        });
      };

      c.prototype.render = function () {
        var c = this.chart,
            a = c.renderer,
            e = this.group,
            d,
            k = this.box,
            h = this.options,
            n = this.padding;
        this.itemX = n;
        this.itemY = this.initialItemY;
        this.lastItemY = this.offsetWidth = 0;
        this.widthOption = D(h.width, c.spacingBox.width - n);
        var g = c.spacingBox.width - 2 * n - h.x;
        -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (g /= 2);
        this.maxLegendWidth = this.widthOption || g;
        e || (this.group = e = a.g("legend").attr({
          zIndex: 7
        }).add(), this.contentGroup = a.g().attr({
          zIndex: 1
        }).add(e), this.scrollGroup = a.g().add(this.contentGroup));
        this.renderTitle();
        g = this.getAllItems();
        N(g, function (a, c) {
          return (a.options && a.options.legendIndex || 0) - (c.options && c.options.legendIndex || 0);
        });
        h.reversed && g.reverse();
        this.allItems = g;
        this.display = d = !!g.length;
        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
        g.forEach(this.renderItem, this);
        g.forEach(this.layoutItem, this);
        g = (this.widthOption || this.offsetWidth) + n;
        var q = this.lastItemY + this.lastLineHeight + this.titleHeight;
        q = this.handleOverflow(q);
        q += n;
        k || (this.box = k = a.rect().addClass("highcharts-legend-box").attr({
          r: h.borderRadius
        }).add(e), k.isNew = !0);
        c.styledMode || k.attr({
          stroke: h.borderColor,
          "stroke-width": h.borderWidth || 0,
          fill: h.backgroundColor || "none"
        }).shadow(h.shadow);
        0 < g && 0 < q && (k[k.isNew ? "attr" : "animate"](k.crisp.call({}, {
          x: 0,
          y: 0,
          width: g,
          height: q
        }, k.strokeWidth())), k.isNew = !1);
        k[d ? "show" : "hide"]();
        c.styledMode && "none" === e.getStyle("display") && (g = q = 0);
        this.legendWidth = g;
        this.legendHeight = q;
        d && (a = c.spacingBox, k = a.y, /(lth|ct|rth)/.test(this.getAlignment()) && 0 < c.titleOffset[0] ? k += c.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < c.titleOffset[2] && (k -= c.titleOffset[2]), k !== a.y && (a = y(a, {
          y: k
        })), e.align(y(h, {
          width: g,
          height: q,
          verticalAlign: this.proximate ? "top" : h.verticalAlign
        }), !0, a));
        this.proximate || this.positionItems();
        A(this, "afterRender");
      };

      c.prototype.handleOverflow = function (c) {
        var a = this,
            e = this.chart,
            f = e.renderer,
            d = this.options,
            k = d.y,
            h = this.padding;
        k = e.spacingBox.height + ("top" === d.verticalAlign ? -k : k) - h;

        var n = d.maxHeight,
            g,
            q = this.clipRect,
            y = d.navigation,
            p = t(y.animation, !0),
            b = y.arrowSize || 12,
            C = this.nav,
            x = this.pages,
            R,
            O = this.allItems,
            u = function (b) {
          "number" === typeof b ? q.attr({
            height: b
          }) : q && (a.clipRect = q.destroy(), a.contentGroup.clip());
          a.contentGroup.div && (a.contentGroup.div.style.clip = b ? "rect(" + h + "px,9999px," + (h + b) + "px,0)" : "auto");
        },
            D = function (c) {
          a[c] = f.circle(0, 0, 1.3 * b).translate(b / 2, b / 2).add(C);
          e.styledMode || a[c].attr("fill", "rgba(0,0,0,0.0001)");
          return a[c];
        };

        "horizontal" !== d.layout || "middle" === d.verticalAlign || d.floating || (k /= 2);
        n && (k = Math.min(k, n));
        x.length = 0;
        c > k && !1 !== y.enabled ? (this.clipHeight = g = Math.max(k - 20 - this.titleHeight - h, 0), this.currentPage = t(this.currentPage, 1), this.fullHeight = c, O.forEach(function (b, a) {
          var c = b._legendItemPos[1],
              e = Math.round(b.legendItem.getBBox().height),
              f = x.length;
          if (!f || c - x[f - 1] > g && (R || c) !== x[f - 1]) x.push(R || c), f++;
          b.pageIx = f - 1;
          R && (O[a - 1].pageIx = f - 1);
          a === O.length - 1 && c + e - x[f - 1] > g && c !== R && (x.push(c), b.pageIx = f);
          c !== R && (R = c);
        }), q || (q = a.clipRect = f.clipRect(0, h, 9999, 0), a.contentGroup.clip(q)), u(g), C || (this.nav = C = f.g().attr({
          zIndex: 1
        }).add(this.group), this.up = f.symbol("triangle", 0, 0, b, b).add(C), D("upTracker").on("click", function () {
          a.scroll(-1, p);
        }), this.pager = f.text("", 15, 10).addClass("highcharts-legend-navigation"), e.styledMode || this.pager.css(y.style), this.pager.add(C), this.down = f.symbol("triangle-down", 0, 0, b, b).add(C), D("downTracker").on("click", function () {
          a.scroll(1, p);
        })), a.scroll(0), c = k) : C && (u(), this.nav = C.destroy(), this.scrollGroup.attr({
          translateY: 1
        }), this.clipHeight = 0);
        return c;
      };

      c.prototype.scroll = function (c, a) {
        var e = this,
            f = this.chart,
            k = this.pages,
            n = k.length,
            g = this.currentPage + c;
        c = this.clipHeight;
        var y = this.options.navigation,
            u = this.pager,
            H = this.padding;
        g > n && (g = n);
        0 < g && ("undefined" !== typeof a && h(a, f), this.nav.attr({
          translateX: H,
          translateY: c + this.padding + 7 + this.titleHeight,
          visibility: "visible"
        }), [this.up, this.upTracker].forEach(function (a) {
          a.attr({
            "class": 1 === g ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
          });
        }), u.attr({
          text: g + "/" + n
        }), [this.down, this.downTracker].forEach(function (a) {
          a.attr({
            x: 18 + this.pager.getBBox().width,
            "class": g === n ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
          });
        }, this), f.styledMode || (this.up.attr({
          fill: 1 === g ? y.inactiveColor : y.activeColor
        }), this.upTracker.css({
          cursor: 1 === g ? "default" : "pointer"
        }), this.down.attr({
          fill: g === n ? y.inactiveColor : y.activeColor
        }), this.downTracker.css({
          cursor: g === n ? "default" : "pointer"
        })), this.scrollOffset = -k[g - 1] + this.initialItemY, this.scrollGroup.animate({
          translateY: this.scrollOffset
        }), this.currentPage = g, this.positionCheckboxes(), a = d.animObject(t(a, f.renderer.globalAnimation, !0)), q(function () {
          A(e, "afterScroll", {
            currentPage: g
          });
        }, a.duration || 0));
      };

      return c;
    }();

    (/Trident\/7\.0/.test(c.navigator && c.navigator.userAgent) || P) && g(k.prototype, "positionItem", function (c, e) {
      var a = this,
          f = function () {
        e._legendItemPos && c.call(a, e);
      };

      f();
      a.bubbleLegend || setTimeout(f);
    });
    d.Legend = k;
    return d.Legend;
  });
  S(r, "parts/Chart.js", [r["parts/Globals.js"], r["parts/Legend.js"], r["parts/MSPointer.js"], r["parts/Pointer.js"], r["parts/Time.js"], r["parts/Utilities.js"]], function (d, g, r, u, I, M) {
    var E = M.addEvent,
        A = M.animate,
        G = M.animObject,
        J = M.attr,
        y = M.createElement,
        t = M.css,
        D = M.defined,
        h = M.discardElement,
        N = M.erase,
        q = M.error,
        P = M.extend,
        e = M.find,
        c = M.fireEvent,
        k = M.getStyle,
        n = M.isArray,
        f = M.isFunction,
        a = M.isNumber,
        l = M.isObject,
        v = M.isString,
        z = M.merge,
        w = M.numberFormat,
        B = M.objectEach,
        L = M.pick,
        Q = M.pInt,
        H = M.relativeLength,
        K = M.removeEvent,
        p = M.setAnimation,
        b = M.splat,
        C = M.syncTimeout,
        x = M.uniqueKey,
        R = d.doc,
        O = d.Axis,
        X = d.defaultOptions,
        U = d.charts,
        m = d.marginNames,
        T = d.seriesTypes,
        Z = d.win,
        ca = d.Chart = function () {
      this.getArgs.apply(this, arguments);
    };

    d.chart = function (b, a, c) {
      return new ca(b, a, c);
    };

    P(ca.prototype, {
      callbacks: [],
      getArgs: function () {
        var b = [].slice.call(arguments);
        if (v(b[0]) || b[0].nodeName) this.renderTo = b.shift();
        this.init(b[0], b[1]);
      },
      init: function (b, a) {
        var e,
            k = b.series,
            h = b.plotOptions || {};
        c(this, "init", {
          args: arguments
        }, function () {
          b.series = null;
          e = z(X, b);
          B(e.plotOptions, function (b, a) {
            l(b) && (b.tooltip = h[a] && z(h[a].tooltip) || void 0);
          });
          e.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;
          e.series = b.series = k;
          this.userOptions = b;
          var m = e.chart,
              n = m.events;
          this.margin = [];
          this.spacing = [];
          this.bounds = {
            h: {},
            v: {}
          };
          this.labelCollectors = [];
          this.callback = a;
          this.isResizing = 0;
          this.options = e;
          this.axes = [];
          this.series = [];
          this.time = b.time && Object.keys(b.time).length ? new I(b.time) : d.time;
          this.numberFormatter = m.numberFormatter || w;
          this.styledMode = m.styledMode;
          this.hasCartesianSeries = m.showAxes;
          var p = this;
          p.index = U.length;
          U.push(p);
          d.chartCount++;
          n && B(n, function (b, a) {
            f(b) && E(p, a, b);
          });
          p.xAxis = [];
          p.yAxis = [];
          p.pointCount = p.colorCounter = p.symbolCounter = 0;
          c(p, "afterInit");
          p.firstRender();
        });
      },
      initSeries: function (b) {
        var a = this.options.chart;
        a = b.type || a.type || a.defaultSeriesType;
        var c = T[a];
        c || q(17, !0, this, {
          missingModuleFor: a
        });
        a = new c();
        a.init(this, b);
        return a;
      },
      setSeriesData: function () {
        this.getSeriesOrderByLinks().forEach(function (b) {
          b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);
        });
      },
      getSeriesOrderByLinks: function () {
        return this.series.concat().sort(function (b, a) {
          return b.linkedSeries.length || a.linkedSeries.length ? a.linkedSeries.length - b.linkedSeries.length : 0;
        });
      },
      orderSeries: function (b) {
        var a = this.series;

        for (b = b || 0; b < a.length; b++) a[b] && (a[b].index = b, a[b].name = a[b].getName());
      },
      isInsidePlot: function (b, a, e) {
        var f = e ? a : b;
        b = e ? b : a;
        f = {
          x: f,
          y: b,
          isInsidePlot: 0 <= f && f <= this.plotWidth && 0 <= b && b <= this.plotHeight
        };
        c(this, "afterIsInsidePlot", f);
        return f.isInsidePlot;
      },
      redraw: function (b) {
        c(this, "beforeRedraw");
        var a = this.axes,
            e = this.series,
            f = this.pointer,
            d = this.legend,
            k = this.userOptions.legend,
            l = this.isDirtyLegend,
            h = this.hasCartesianSeries,
            m = this.isDirtyBox,
            n = this.renderer,
            x = n.isHidden(),
            g = [];
        this.setResponsive && this.setResponsive(!1);
        p(this.hasRendered ? b : !1, this);
        x && this.temporaryDisplay();
        this.layOutTitles();

        for (b = e.length; b--;) {
          var w = e[b];

          if (w.options.stacking) {
            var C = !0;

            if (w.isDirty) {
              var v = !0;
              break;
            }
          }
        }

        if (v) for (b = e.length; b--;) w = e[b], w.options.stacking && (w.isDirty = !0);
        e.forEach(function (b) {
          b.isDirty && ("point" === b.options.legendType ? (b.updateTotals && b.updateTotals(), l = !0) : k && (k.labelFormatter || k.labelFormat) && (l = !0));
          b.isDirtyData && c(b, "updatedData");
        });
        l && d && d.options.enabled && (d.render(), this.isDirtyLegend = !1);
        C && this.getStacks();
        h && a.forEach(function (b) {
          b.updateNames();
          b.setScale();
        });
        this.getMargins();
        h && (a.forEach(function (b) {
          b.isDirty && (m = !0);
        }), a.forEach(function (b) {
          var a = b.min + "," + b.max;
          b.extKey !== a && (b.extKey = a, g.push(function () {
            c(b, "afterSetExtremes", P(b.eventArgs, b.getExtremes()));
            delete b.eventArgs;
          }));
          (m || C) && b.redraw();
        }));
        m && this.drawChartBox();
        c(this, "predraw");
        e.forEach(function (b) {
          (m || b.isDirty) && b.visible && b.redraw();
          b.isDirtyData = !1;
        });
        f && f.reset(!0);
        n.draw();
        c(this, "redraw");
        c(this, "render");
        x && this.temporaryDisplay(!0);
        g.forEach(function (b) {
          b.call();
        });
      },
      get: function (b) {
        function a(a) {
          return a.id === b || a.options && a.options.id === b;
        }

        var c = this.series,
            f;
        var d = e(this.axes, a) || e(this.series, a);

        for (f = 0; !d && f < c.length; f++) d = e(c[f].points || [], a);

        return d;
      },
      getAxes: function () {
        var a = this,
            e = this.options,
            f = e.xAxis = b(e.xAxis || {});
        e = e.yAxis = b(e.yAxis || {});
        c(this, "getAxes");
        f.forEach(function (b, a) {
          b.index = a;
          b.isX = !0;
        });
        e.forEach(function (b, a) {
          b.index = a;
        });
        f.concat(e).forEach(function (b) {
          new O(a, b);
        });
        c(this, "afterGetAxes");
      },
      getSelectedPoints: function () {
        var b = [];
        this.series.forEach(function (a) {
          b = b.concat(a.getPointsCollection().filter(function (b) {
            return L(b.selectedStaging, b.selected);
          }));
        });
        return b;
      },
      getSelectedSeries: function () {
        return this.series.filter(function (b) {
          return b.selected;
        });
      },
      setTitle: function (b, a, c) {
        this.applyDescription("title", b);
        this.applyDescription("subtitle", a);
        this.applyDescription("caption", void 0);
        this.layOutTitles(c);
      },
      applyDescription: function (b, a) {
        var c = this,
            e = "title" === b ? {
          color: "#333333",
          fontSize: this.options.isStock ? "16px" : "18px"
        } : {
          color: "#666666"
        };
        e = this.options[b] = z(!this.styledMode && {
          style: e
        }, this.options[b], a);
        var f = this[b];
        f && a && (this[b] = f = f.destroy());
        e && !f && (f = this.renderer.text(e.text, 0, 0, e.useHTML).attr({
          align: e.align,
          "class": "highcharts-" + b,
          zIndex: e.zIndex || 4
        }).add(), f.update = function (a) {
          c[{
            title: "setTitle",
            subtitle: "setSubtitle",
            caption: "setCaption"
          }[b]](a);
        }, this.styledMode || f.css(e.style), this[b] = f);
      },
      layOutTitles: function (b) {
        var a = [0, 0, 0],
            e = this.renderer,
            f = this.spacingBox;
        ["title", "subtitle", "caption"].forEach(function (b) {
          var c = this[b],
              d = this.options[b],
              k = d.verticalAlign || "top";
          b = "title" === b ? -3 : "top" === k ? a[0] + 2 : 0;

          if (c) {
            if (!this.styledMode) var l = d.style.fontSize;
            l = e.fontMetrics(l, c).b;
            c.css({
              width: (d.width || f.width + (d.widthAdjust || 0)) + "px"
            });
            var h = Math.round(c.getBBox(d.useHTML).height);
            c.align(P({
              y: "bottom" === k ? l : b + l,
              height: h
            }, d), !1, "spacingBox");
            d.floating || ("top" === k ? a[0] = Math.ceil(a[0] + h) : "bottom" === k && (a[2] = Math.ceil(a[2] + h)));
          }
        }, this);
        a[0] && "top" === (this.options.title.verticalAlign || "top") && (a[0] += this.options.title.margin);
        a[2] && "bottom" === this.options.caption.verticalAlign && (a[2] += this.options.caption.margin);
        var d = !this.titleOffset || this.titleOffset.join(",") !== a.join(",");
        this.titleOffset = a;
        c(this, "afterLayOutTitles");
        !this.isDirtyBox && d && (this.isDirtyBox = this.isDirtyLegend = d, this.hasRendered && L(b, !0) && this.isDirtyBox && this.redraw());
      },
      getChartSize: function () {
        var b = this.options.chart,
            a = b.width;
        b = b.height;
        var c = this.renderTo;
        D(a) || (this.containerWidth = k(c, "width"));
        D(b) || (this.containerHeight = k(c, "height"));
        this.chartWidth = Math.max(0, a || this.containerWidth || 600);
        this.chartHeight = Math.max(0, H(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
      },
      temporaryDisplay: function (b) {
        var a = this.renderTo;
        if (b) for (; a && a.style;) a.hcOrigStyle && (t(a, a.hcOrigStyle), delete a.hcOrigStyle), a.hcOrigDetached && (R.body.removeChild(a), a.hcOrigDetached = !1), a = a.parentNode;else for (; a && a.style;) {
          R.body.contains(a) || a.parentNode || (a.hcOrigDetached = !0, R.body.appendChild(a));
          if ("none" === k(a, "display", !1) || a.hcOricDetached) a.hcOrigStyle = {
            display: a.style.display,
            height: a.style.height,
            overflow: a.style.overflow
          }, b = {
            display: "block",
            overflow: "hidden"
          }, a !== this.renderTo && (b.height = 0), t(a, b), a.offsetWidth || a.style.setProperty("display", "block", "important");
          a = a.parentNode;
          if (a === R.body) break;
        }
      },
      setClassName: function (b) {
        this.container.className = "highcharts-container " + (b || "");
      },
      getContainer: function () {
        var b = this.options,
            e = b.chart;
        var f = this.renderTo;
        var k = x(),
            l,
            h;
        f || (this.renderTo = f = e.renderTo);
        v(f) && (this.renderTo = f = R.getElementById(f));
        f || q(13, !0, this);
        var m = Q(J(f, "data-highcharts-chart"));
        a(m) && U[m] && U[m].hasRendered && U[m].destroy();
        J(f, "data-highcharts-chart", this.index);
        f.innerHTML = "";
        e.skipClone || f.offsetWidth || this.temporaryDisplay();
        this.getChartSize();
        m = this.chartWidth;
        var n = this.chartHeight;
        t(f, {
          overflow: "hidden"
        });
        this.styledMode || (l = P({
          position: "relative",
          overflow: "hidden",
          width: m + "px",
          height: n + "px",
          textAlign: "left",
          lineHeight: "normal",
          zIndex: 0,
          "-webkit-tap-highlight-color": "rgba(0,0,0,0)"
        }, e.style));
        this.container = f = y("div", {
          id: k
        }, l, f);
        this._cursor = f.style.cursor;
        this.renderer = new (d[e.renderer] || d.Renderer)(f, m, n, null, e.forExport, b.exporting && b.exporting.allowHTML, this.styledMode);
        p(void 0, this);
        this.setClassName(e.className);
        if (this.styledMode) for (h in b.defs) this.renderer.definition(b.defs[h]);else this.renderer.setStyle(e.style);
        this.renderer.chartIndex = this.index;
        c(this, "afterGetContainer");
      },
      getMargins: function (b) {
        var a = this.spacing,
            e = this.margin,
            f = this.titleOffset;
        this.resetMargins();
        f[0] && !D(e[0]) && (this.plotTop = Math.max(this.plotTop, f[0] + a[0]));
        f[2] && !D(e[2]) && (this.marginBottom = Math.max(this.marginBottom, f[2] + a[2]));
        this.legend && this.legend.display && this.legend.adjustMargins(e, a);
        c(this, "getMargins");
        b || this.getAxisMargins();
      },
      getAxisMargins: function () {
        var b = this,
            a = b.axisOffset = [0, 0, 0, 0],
            c = b.colorAxis,
            e = b.margin,
            f = function (b) {
          b.forEach(function (b) {
            b.visible && b.getOffset();
          });
        };

        b.hasCartesianSeries ? f(b.axes) : c && c.length && f(c);
        m.forEach(function (c, f) {
          D(e[f]) || (b[c] += a[f]);
        });
        b.setChartSize();
      },
      reflow: function (b) {
        var a = this,
            c = a.options.chart,
            e = a.renderTo,
            f = D(c.width) && D(c.height),
            d = c.width || k(e, "width");
        c = c.height || k(e, "height");
        e = b ? b.target : Z;

        if (!f && !a.isPrinting && d && c && (e === Z || e === R)) {
          if (d !== a.containerWidth || c !== a.containerHeight) M.clearTimeout(a.reflowTimeout), a.reflowTimeout = C(function () {
            a.container && a.setSize(void 0, void 0, !1);
          }, b ? 100 : 0);
          a.containerWidth = d;
          a.containerHeight = c;
        }
      },
      setReflow: function (b) {
        var a = this;
        !1 === b || this.unbindReflow ? !1 === b && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = E(Z, "resize", function (b) {
          a.options && a.reflow(b);
        }), E(this, "destroy", this.unbindReflow));
      },
      setSize: function (b, a, e) {
        var f = this,
            d = f.renderer;
        f.isResizing += 1;
        p(e, f);
        e = d.globalAnimation;
        f.oldChartHeight = f.chartHeight;
        f.oldChartWidth = f.chartWidth;
        "undefined" !== typeof b && (f.options.chart.width = b);
        "undefined" !== typeof a && (f.options.chart.height = a);
        f.getChartSize();
        f.styledMode || (e ? A : t)(f.container, {
          width: f.chartWidth + "px",
          height: f.chartHeight + "px"
        }, e);
        f.setChartSize(!0);
        d.setSize(f.chartWidth, f.chartHeight, e);
        f.axes.forEach(function (b) {
          b.isDirty = !0;
          b.setScale();
        });
        f.isDirtyLegend = !0;
        f.isDirtyBox = !0;
        f.layOutTitles();
        f.getMargins();
        f.redraw(e);
        f.oldChartHeight = null;
        c(f, "resize");
        C(function () {
          f && c(f, "endResize", null, function () {
            --f.isResizing;
          });
        }, G(e).duration || 0);
      },
      setChartSize: function (b) {
        var a = this.inverted,
            e = this.renderer,
            f = this.chartWidth,
            d = this.chartHeight,
            k = this.options.chart,
            l = this.spacing,
            h = this.clipOffset,
            m,
            n,
            p,
            x;
        this.plotLeft = m = Math.round(this.plotLeft);
        this.plotTop = n = Math.round(this.plotTop);
        this.plotWidth = p = Math.max(0, Math.round(f - m - this.marginRight));
        this.plotHeight = x = Math.max(0, Math.round(d - n - this.marginBottom));
        this.plotSizeX = a ? x : p;
        this.plotSizeY = a ? p : x;
        this.plotBorderWidth = k.plotBorderWidth || 0;
        this.spacingBox = e.spacingBox = {
          x: l[3],
          y: l[0],
          width: f - l[3] - l[1],
          height: d - l[0] - l[2]
        };
        this.plotBox = e.plotBox = {
          x: m,
          y: n,
          width: p,
          height: x
        };
        f = 2 * Math.floor(this.plotBorderWidth / 2);
        a = Math.ceil(Math.max(f, h[3]) / 2);
        e = Math.ceil(Math.max(f, h[0]) / 2);
        this.clipBox = {
          x: a,
          y: e,
          width: Math.floor(this.plotSizeX - Math.max(f, h[1]) / 2 - a),
          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(f, h[2]) / 2 - e))
        };
        b || this.axes.forEach(function (b) {
          b.setAxisSize();
          b.setAxisTranslation();
        });
        c(this, "afterSetChartSize", {
          skipAxes: b
        });
      },
      resetMargins: function () {
        c(this, "resetMargins");
        var b = this,
            a = b.options.chart;
        ["margin", "spacing"].forEach(function (c) {
          var e = a[c],
              f = l(e) ? e : [e, e, e, e];
          ["Top", "Right", "Bottom", "Left"].forEach(function (e, d) {
            b[c][d] = L(a[c + e], f[d]);
          });
        });
        m.forEach(function (a, c) {
          b[a] = L(b.margin[c], b.spacing[c]);
        });
        b.axisOffset = [0, 0, 0, 0];
        b.clipOffset = [0, 0, 0, 0];
      },
      drawChartBox: function () {
        var b = this.options.chart,
            a = this.renderer,
            e = this.chartWidth,
            f = this.chartHeight,
            d = this.chartBackground,
            k = this.plotBackground,
            l = this.plotBorder,
            h = this.styledMode,
            m = this.plotBGImage,
            n = b.backgroundColor,
            p = b.plotBackgroundColor,
            x = b.plotBackgroundImage,
            g,
            w = this.plotLeft,
            C = this.plotTop,
            v = this.plotWidth,
            q = this.plotHeight,
            t = this.plotBox,
            B = this.clipRect,
            z = this.clipBox,
            O = "animate";
        d || (this.chartBackground = d = a.rect().addClass("highcharts-background").add(), O = "attr");
        if (h) var y = g = d.strokeWidth();else {
          y = b.borderWidth || 0;
          g = y + (b.shadow ? 8 : 0);
          n = {
            fill: n || "none"
          };
          if (y || d["stroke-width"]) n.stroke = b.borderColor, n["stroke-width"] = y;
          d.attr(n).shadow(b.shadow);
        }
        d[O]({
          x: g / 2,
          y: g / 2,
          width: e - g - y % 2,
          height: f - g - y % 2,
          r: b.borderRadius
        });
        O = "animate";
        k || (O = "attr", this.plotBackground = k = a.rect().addClass("highcharts-plot-background").add());
        k[O](t);
        h || (k.attr({
          fill: p || "none"
        }).shadow(b.plotShadow), x && (m ? (x !== m.attr("href") && m.attr("href", x), m.animate(t)) : this.plotBGImage = a.image(x, w, C, v, q).add()));
        B ? B.animate({
          width: z.width,
          height: z.height
        }) : this.clipRect = a.clipRect(z);
        O = "animate";
        l || (O = "attr", this.plotBorder = l = a.rect().addClass("highcharts-plot-border").attr({
          zIndex: 1
        }).add());
        h || l.attr({
          stroke: b.plotBorderColor,
          "stroke-width": b.plotBorderWidth || 0,
          fill: "none"
        });
        l[O](l.crisp({
          x: w,
          y: C,
          width: v,
          height: q
        }, -l.strokeWidth()));
        this.isDirtyBox = !1;
        c(this, "afterDrawChartBox");
      },
      propFromSeries: function () {
        var b = this,
            a = b.options.chart,
            c,
            e = b.options.series,
            f,
            d;
        ["inverted", "angular", "polar"].forEach(function (k) {
          c = T[a.type || a.defaultSeriesType];
          d = a[k] || c && c.prototype[k];

          for (f = e && e.length; !d && f--;) (c = T[e[f].type]) && c.prototype[k] && (d = !0);

          b[k] = d;
        });
      },
      linkSeries: function () {
        var b = this,
            a = b.series;
        a.forEach(function (b) {
          b.linkedSeries.length = 0;
        });
        a.forEach(function (a) {
          var c = a.options.linkedTo;
          v(c) && (c = ":previous" === c ? b.series[a.index - 1] : b.get(c)) && c.linkedParent !== a && (c.linkedSeries.push(a), a.linkedParent = c, c.enabledDataSorting && a.setDataSortingOptions(), a.visible = L(a.options.visible, c.options.visible, a.visible));
        });
        c(this, "afterLinkSeries");
      },
      renderSeries: function () {
        this.series.forEach(function (b) {
          b.translate();
          b.render();
        });
      },
      renderLabels: function () {
        var b = this,
            a = b.options.labels;
        a.items && a.items.forEach(function (c) {
          var e = P(a.style, c.style),
              f = Q(e.left) + b.plotLeft,
              d = Q(e.top) + b.plotTop + 12;
          delete e.left;
          delete e.top;
          b.renderer.text(c.html, f, d).attr({
            zIndex: 2
          }).css(e).add();
        });
      },
      render: function () {
        var b = this.axes,
            a = this.colorAxis,
            c = this.renderer,
            e = this.options,
            f = 0,
            d = function (b) {
          b.forEach(function (b) {
            b.visible && b.render();
          });
        };

        this.setTitle();
        this.legend = new g(this, e.legend);
        this.getStacks && this.getStacks();
        this.getMargins(!0);
        this.setChartSize();
        e = this.plotWidth;
        b.some(function (b) {
          if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return f = 21, !0;
        });
        var k = this.plotHeight = Math.max(this.plotHeight - f, 0);
        b.forEach(function (b) {
          b.setScale();
        });
        this.getAxisMargins();
        var l = 1.1 < e / this.plotWidth;
        var h = 1.05 < k / this.plotHeight;
        if (l || h) b.forEach(function (b) {
          (b.horiz && l || !b.horiz && h) && b.setTickInterval(!0);
        }), this.getMargins();
        this.drawChartBox();
        this.hasCartesianSeries ? d(b) : a && a.length && d(a);
        this.seriesGroup || (this.seriesGroup = c.g("series-group").attr({
          zIndex: 3
        }).add());
        this.renderSeries();
        this.renderLabels();
        this.addCredits();
        this.setResponsive && this.setResponsive();
        this.updateContainerScaling();
        this.hasRendered = !0;
      },
      addCredits: function (b) {
        var a = this;
        b = z(!0, this.options.credits, b);
        b.enabled && !this.credits && (this.credits = this.renderer.text(b.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
          b.href && (Z.location.href = b.href);
        }).attr({
          align: b.position.align,
          zIndex: 8
        }), a.styledMode || this.credits.css(b.style), this.credits.add().align(b.position), this.credits.update = function (b) {
          a.credits = a.credits.destroy();
          a.addCredits(b);
        });
      },
      updateContainerScaling: function () {
        var b = this.container;

        if (b.offsetWidth && b.offsetHeight && b.getBoundingClientRect) {
          var a = b.getBoundingClientRect(),
              c = a.width / b.offsetWidth;
          b = a.height / b.offsetHeight;
          1 !== c || 1 !== b ? this.containerScaling = {
            scaleX: c,
            scaleY: b
          } : delete this.containerScaling;
        }
      },
      destroy: function () {
        var b = this,
            a = b.axes,
            e = b.series,
            f = b.container,
            k,
            l = f && f.parentNode;
        c(b, "destroy");
        b.renderer.forExport ? N(U, b) : U[b.index] = void 0;
        d.chartCount--;
        b.renderTo.removeAttribute("data-highcharts-chart");
        K(b);

        for (k = a.length; k--;) a[k] = a[k].destroy();

        this.scroller && this.scroller.destroy && this.scroller.destroy();

        for (k = e.length; k--;) e[k] = e[k].destroy();

        "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (a) {
          var c = b[a];
          c && c.destroy && (b[a] = c.destroy());
        });
        f && (f.innerHTML = "", K(f), l && h(f));
        B(b, function (a, c) {
          delete b[c];
        });
      },
      firstRender: function () {
        var b = this,
            a = b.options;

        if (!b.isReadyToRender || b.isReadyToRender()) {
          b.getContainer();
          b.resetMargins();
          b.setChartSize();
          b.propFromSeries();
          b.getAxes();
          (n(a.series) ? a.series : []).forEach(function (a) {
            b.initSeries(a);
          });
          b.linkSeries();
          b.setSeriesData();
          c(b, "beforeRender");
          u && (b.pointer = d.hasTouch || !Z.PointerEvent && !Z.MSPointerEvent ? new u(b, a) : new r(b, a));
          b.render();
          if (!b.renderer.imgCount && !b.hasLoaded) b.onload();
          b.temporaryDisplay(!0);
        }
      },
      onload: function () {
        this.callbacks.concat([this.callback]).forEach(function (b) {
          b && "undefined" !== typeof this.index && b.apply(this, [this]);
        }, this);
        c(this, "load");
        c(this, "render");
        D(this.index) && this.setReflow(this.options.chart.reflow);
        this.hasLoaded = !0;
      }
    });
  });
  S(r, "parts/ScrollablePlotArea.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.addEvent,
        u = g.createElement,
        I = g.pick,
        M = g.stop;
    g = d.Chart;
    "";
    r(g, "afterSetChartSize", function (g) {
      var u = this.options.chart.scrollablePlotArea,
          r = u && u.minWidth;
      u = u && u.minHeight;

      if (!this.renderer.forExport) {
        if (r) {
          if (this.scrollablePixelsX = r = Math.max(0, r - this.chartWidth)) {
            this.plotWidth += r;
            this.inverted ? (this.clipBox.height += r, this.plotBox.height += r) : (this.clipBox.width += r, this.plotBox.width += r);
            var E = {
              1: {
                name: "right",
                value: r
              }
            };
          }
        } else u && (this.scrollablePixelsY = r = Math.max(0, u - this.chartHeight)) && (this.plotHeight += r, this.inverted ? (this.clipBox.width += r, this.plotBox.width += r) : (this.clipBox.height += r, this.plotBox.height += r), E = {
          2: {
            name: "bottom",
            value: r
          }
        });

        E && !g.skipAxes && this.axes.forEach(function (g) {
          E[g.side] ? g.getPlotLinePath = function () {
            var t = E[g.side].name,
                y = this[t];
            this[t] = y - E[g.side].value;
            var h = d.Axis.prototype.getPlotLinePath.apply(this, arguments);
            this[t] = y;
            return h;
          } : (g.setAxisSize(), g.setAxisTranslation());
        });
      }
    });
    r(g, "render", function () {
      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
    });

    g.prototype.setUpScrolling = function () {
      var d = this,
          g = {
        WebkitOverflowScrolling: "touch",
        overflowX: "hidden",
        overflowY: "hidden"
      };
      this.scrollablePixelsX && (g.overflowX = "auto");
      this.scrollablePixelsY && (g.overflowY = "auto");
      this.scrollingContainer = u("div", {
        className: "highcharts-scrolling"
      }, g, this.renderTo);
      r(this.scrollingContainer, "scroll", function () {
        d.pointer && delete d.pointer.chartPosition;
      });
      this.innerContainer = u("div", {
        className: "highcharts-inner-container"
      }, null, this.scrollingContainer);
      this.innerContainer.appendChild(this.container);
      this.setUpScrolling = null;
    };

    g.prototype.moveFixedElements = function () {
      var d = this.container,
          g = this.fixedRenderer,
          u = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),
          r;
      this.scrollablePixelsX && !this.inverted ? r = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? r = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? r = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (r = ".highcharts-yaxis");
      u.push(r, r + "-labels");
      u.forEach(function (y) {
        [].forEach.call(d.querySelectorAll(y), function (d) {
          (d.namespaceURI === g.SVG_NS ? g.box : g.box.parentNode).appendChild(d);
          d.style.pointerEvents = "auto";
        });
      });
    };

    g.prototype.applyFixed = function () {
      var g,
          A = !this.fixedDiv,
          G = this.options.chart.scrollablePlotArea;
      A ? (this.fixedDiv = u("div", {
        className: "highcharts-fixed"
      }, {
        position: "absolute",
        overflow: "hidden",
        pointerEvents: "none",
        zIndex: 2
      }, null, !0), this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild), this.renderTo.style.overflow = "visible", this.fixedRenderer = g = new d.Renderer(this.fixedDiv, this.chartWidth, this.chartHeight), this.scrollableMask = g.path().attr({
        fill: this.options.chart.backgroundColor || "#fff",
        "fill-opacity": I(G.opacity, .85),
        zIndex: -1
      }).addClass("highcharts-scrollable-mask").add(), this.moveFixedElements(), r(this, "afterShowResetZoom", this.moveFixedElements), r(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
      g = this.chartWidth + (this.scrollablePixelsX || 0);
      var J = this.chartHeight + (this.scrollablePixelsY || 0);
      M(this.container);
      this.container.style.width = g + "px";
      this.container.style.height = J + "px";
      this.renderer.boxWrapper.attr({
        width: g,
        height: J,
        viewBox: [0, 0, g, J].join(" ")
      });
      this.chartBackground.attr({
        width: g,
        height: J
      });
      this.scrollablePixelsY && (this.scrollingContainer.style.height = this.chartHeight + "px");
      A && (G.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * G.scrollPositionX), G.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * G.scrollPositionY));
      J = this.axisOffset;
      A = this.plotTop - J[0] - 1;
      G = this.plotLeft - J[3] - 1;
      g = this.plotTop + this.plotHeight + J[2] + 1;
      J = this.plotLeft + this.plotWidth + J[1] + 1;
      var y = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
          t = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
      A = this.scrollablePixelsX ? ["M", 0, A, "L", this.plotLeft - 1, A, "L", this.plotLeft - 1, g, "L", 0, g, "Z", "M", y, A, "L", this.chartWidth, A, "L", this.chartWidth, g, "L", y, g, "Z"] : this.scrollablePixelsY ? ["M", G, 0, "L", G, this.plotTop - 1, "L", J, this.plotTop - 1, "L", J, 0, "Z", "M", G, t, "L", G, this.chartHeight, "L", J, this.chartHeight, "L", J, t, "Z"] : ["M", 0, 0];
      "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({
        d: A
      });
    };
  });
  S(r, "mixins/legend-symbol.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.merge,
        u = g.pick;
    d.LegendSymbolMixin = {
      drawRectangle: function (d, g) {
        var r = d.symbolHeight,
            A = d.options.squareSymbol;
        g.legendSymbol = this.chart.renderer.rect(A ? (d.symbolWidth - r) / 2 : 0, d.baseline - r + 1, A ? r : d.symbolWidth, r, u(d.options.symbolRadius, r / 2)).addClass("highcharts-point").attr({
          zIndex: 3
        }).add(g.legendGroup);
      },
      drawLineMarker: function (d) {
        var g = this.options,
            E = g.marker,
            A = d.symbolWidth,
            G = d.symbolHeight,
            J = G / 2,
            y = this.chart.renderer,
            t = this.legendGroup;
        d = d.baseline - Math.round(.3 * d.fontMetrics.b);
        var D = {};
        this.chart.styledMode || (D = {
          "stroke-width": g.lineWidth || 0
        }, g.dashStyle && (D.dashstyle = g.dashStyle));
        this.legendLine = y.path(["M", 0, d, "L", A, d]).addClass("highcharts-graph").attr(D).add(t);
        E && !1 !== E.enabled && A && (g = Math.min(u(E.radius, J), J), 0 === this.symbol.indexOf("url") && (E = r(E, {
          width: G,
          height: G
        }), g = 0), this.legendSymbol = E = y.symbol(this.symbol, A / 2 - g, d - g, 2 * g, 2 * g, E).addClass("highcharts-point").add(t), E.isMarker = !0);
      }
    };
    return d.LegendSymbolMixin;
  });
  S(r, "parts/Point.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    "";

    var r = g.animObject,
        u = g.defined,
        I = g.erase,
        M = g.extend,
        E = g.format,
        A = g.getNestedProperty,
        G = g.isArray,
        J = g.isNumber,
        y = g.isObject,
        t = g.syncTimeout,
        D = g.pick,
        h = g.removeEvent,
        N = g.uniqueKey,
        q = d.fireEvent;

    g = function () {
      function d() {
        this.colorIndex = this.category = void 0;
        this.formatPrefix = "point";
        this.id = void 0;
        this.isNull = !1;
        this.percentage = this.options = this.name = void 0;
        this.selected = !1;
        this.total = this.series = void 0;
        this.visible = !0;
        this.x = void 0;
      }

      d.prototype.animateBeforeDestroy = function () {
        var e = this,
            c = {
          x: e.startXPos,
          opacity: 0
        },
            d,
            h = e.getGraphicalProps();
        h.singular.forEach(function (f) {
          d = "dataLabel" === f;
          e[f] = e[f].animate(d ? {
            x: e[f].startXPos,
            y: e[f].startYPos,
            opacity: 0
          } : c);
        });
        h.plural.forEach(function (c) {
          e[c].forEach(function (a) {
            a.element && a.animate(M({
              x: e.startXPos
            }, a.startYPos ? {
              x: a.startXPos,
              y: a.startYPos
            } : {}));
          });
        });
      };

      d.prototype.applyOptions = function (e, c) {
        var k = this.series,
            h = k.options.pointValKey || k.pointValKey;
        e = d.prototype.optionsToObject.call(this, e);
        M(this, e);
        this.options = this.options ? M(this.options, e) : e;
        e.group && delete this.group;
        e.dataLabels && delete this.dataLabels;
        h && (this.y = d.prototype.getNestedProperty.call(this, h));
        this.formatPrefix = (this.isNull = D(this.isValid && !this.isValid(), null === this.x || !J(this.y))) ? "null" : "point";
        this.selected && (this.state = "select");
        "name" in this && "undefined" === typeof c && k.xAxis && k.xAxis.hasNames && (this.x = k.xAxis.nameToX(this));
        "undefined" === typeof this.x && k && (this.x = "undefined" === typeof c ? k.autoIncrement(this) : c);
        return this;
      };

      d.prototype.destroy = function () {
        function e() {
          if (c.graphic || c.dataLabel || c.dataLabels) h(c), c.destroyElements();

          for (l in c) c[l] = null;
        }

        var c = this,
            d = c.series,
            n = d.chart;
        d = d.options.dataSorting;
        var f = n.hoverPoints,
            a = r(c.series.chart.renderer.globalAnimation),
            l;
        c.legendItem && n.legend.destroyItem(c);
        f && (c.setState(), I(f, c), f.length || (n.hoverPoints = null));
        if (c === n.hoverPoint) c.onMouseOut();
        d && d.enabled ? (this.animateBeforeDestroy(), t(e, a.duration)) : e();
        n.pointCount--;
      };

      d.prototype.destroyElements = function (e) {
        var c = this;
        e = c.getGraphicalProps(e);
        e.singular.forEach(function (e) {
          c[e] = c[e].destroy();
        });
        e.plural.forEach(function (e) {
          c[e].forEach(function (c) {
            c.element && c.destroy();
          });
          delete c[e];
        });
      };

      d.prototype.firePointEvent = function (e, c, d) {
        var k = this,
            f = this.series.options;
        (f.point.events[e] || k.options && k.options.events && k.options.events[e]) && k.importEvents();
        "click" === e && f.allowPointSelect && (d = function (a) {
          k.select && k.select(null, a.ctrlKey || a.metaKey || a.shiftKey);
        });
        q(k, e, c, d);
      };

      d.prototype.getClassName = function () {
        return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
      };

      d.prototype.getGraphicalProps = function (e) {
        var c = this,
            d = [],
            h,
            f = {
          singular: [],
          plural: []
        };
        e = e || {
          graphic: 1,
          dataLabel: 1
        };
        e.graphic && d.push("graphic", "shadowGroup");
        e.dataLabel && d.push("dataLabel", "dataLabelUpper", "connector");

        for (h = d.length; h--;) {
          var a = d[h];
          c[a] && f.singular.push(a);
        }

        ["dataLabel", "connector"].forEach(function (a) {
          var d = a + "s";
          e[a] && c[d] && f.plural.push(d);
        });
        return f;
      };

      d.prototype.getLabelConfig = function () {
        return {
          x: this.category,
          y: this.y,
          color: this.color,
          colorIndex: this.colorIndex,
          key: this.name || this.category,
          series: this.series,
          point: this,
          percentage: this.percentage,
          total: this.total || this.stackTotal
        };
      };

      d.prototype.getNestedProperty = function (e) {
        if (e) return 0 === e.indexOf("custom.") ? A(e, this.options) : this[e];
      };

      d.prototype.getZone = function () {
        var e = this.series,
            c = e.zones;
        e = e.zoneAxis || "y";
        var d = 0,
            h;

        for (h = c[d]; this[e] >= h.value;) h = c[++d];

        this.nonZonedColor || (this.nonZonedColor = this.color);
        this.color = h && h.color && !this.options.color ? h.color : this.nonZonedColor;
        return h;
      };

      d.prototype.hasNewShapeType = function () {
        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
      };

      d.prototype.init = function (e, c, d) {
        this.series = e;
        this.applyOptions(c, d);
        this.id = u(this.id) ? this.id : N();
        this.resolveColor();
        e.chart.pointCount++;
        q(this, "afterInit");
        return this;
      };

      d.prototype.optionsToObject = function (e) {
        var c = {},
            k = this.series,
            h = k.options.keys,
            f = h || k.pointArrayMap || ["y"],
            a = f.length,
            l = 0,
            g = 0;
        if (J(e) || null === e) c[f[0]] = e;else if (G(e)) for (!h && e.length > a && (k = typeof e[0], "string" === k ? c.name = e[0] : "number" === k && (c.x = e[0]), l++); g < a;) h && "undefined" === typeof e[l] || (0 < f[g].indexOf(".") ? d.prototype.setNestedProperty(c, e[l], f[g]) : c[f[g]] = e[l]), l++, g++;else "object" === typeof e && (c = e, e.dataLabels && (k._hasPointLabels = !0), e.marker && (k._hasPointMarkers = !0));
        return c;
      };

      d.prototype.resolveColor = function () {
        var e = this.series;
        var c = e.chart.options.chart.colorCount;
        var d = e.chart.styledMode;
        d || this.options.color || (this.color = e.color);
        e.options.colorByPoint ? (d || (c = e.options.colors || e.chart.options.colors, this.color = this.color || c[e.colorCounter], c = c.length), d = e.colorCounter, e.colorCounter++, e.colorCounter === c && (e.colorCounter = 0)) : d = e.colorIndex;
        this.colorIndex = D(this.colorIndex, d);
      };

      d.prototype.setNestedProperty = function (e, c, d) {
        d.split(".").reduce(function (e, f, a, d) {
          e[f] = d.length - 1 === a ? c : y(e[f], !0) ? e[f] : {};
          return e[f];
        }, e);
        return e;
      };

      d.prototype.tooltipFormatter = function (e) {
        var c = this.series,
            d = c.tooltipOptions,
            h = D(d.valueDecimals, ""),
            f = d.valuePrefix || "",
            a = d.valueSuffix || "";
        c.chart.styledMode && (e = c.chart.tooltip.styledModeFormat(e));
        (c.pointArrayMap || ["y"]).forEach(function (c) {
          c = "{point." + c;
          if (f || a) e = e.replace(RegExp(c + "}", "g"), f + c + "}" + a);
          e = e.replace(RegExp(c + "}", "g"), c + ":,." + h + "f}");
        });
        return E(e, {
          point: this,
          series: this.series
        }, c.chart);
      };

      return d;
    }();

    d.Point = g;
    return d.Point;
  });
  S(r, "parts/Series.js", [r["parts/Globals.js"], r["mixins/legend-symbol.js"], r["parts/Point.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    "";

    var I = u.addEvent,
        M = u.animObject,
        E = u.arrayMax,
        A = u.arrayMin,
        G = u.clamp,
        J = u.correctFloat,
        y = u.defined,
        t = u.erase,
        D = u.error,
        h = u.extend,
        N = u.find,
        q = u.fireEvent,
        P = u.getNestedProperty,
        e = u.isArray,
        c = u.isFunction,
        k = u.isNumber,
        n = u.isString,
        f = u.merge,
        a = u.objectEach,
        l = u.pick,
        v = u.removeEvent,
        z = u.seriesType,
        w = u.splat,
        B = u.syncTimeout,
        L = d.defaultOptions,
        Q = d.defaultPlotOptions,
        H = d.seriesTypes,
        K = d.SVGElement,
        p = d.win;
    d.Series = z("line", null, {
      lineWidth: 2,
      allowPointSelect: !1,
      showCheckbox: !1,
      animation: {
        duration: 1E3
      },
      events: {},
      marker: {
        enabledThreshold: 2,
        lineColor: "#ffffff",
        lineWidth: 0,
        radius: 4,
        states: {
          normal: {
            animation: !0
          },
          hover: {
            animation: {
              duration: 50
            },
            enabled: !0,
            radiusPlus: 2,
            lineWidthPlus: 1
          },
          select: {
            fillColor: "#cccccc",
            lineColor: "#000000",
            lineWidth: 2
          }
        }
      },
      point: {
        events: {}
      },
      dataLabels: {
        align: "center",
        formatter: function () {
          var b = this.series.chart.numberFormatter;
          return "number" !== typeof this.y ? "" : b(this.y, -1);
        },
        padding: 5,
        style: {
          fontSize: "11px",
          fontWeight: "bold",
          color: "contrast",
          textOutline: "1px contrast"
        },
        verticalAlign: "bottom",
        x: 0,
        y: 0
      },
      cropThreshold: 300,
      opacity: 1,
      pointRange: 0,
      softThreshold: !0,
      states: {
        normal: {
          animation: !0
        },
        hover: {
          animation: {
            duration: 50
          },
          lineWidthPlus: 1,
          marker: {},
          halo: {
            size: 10,
            opacity: .25
          }
        },
        select: {
          animation: {
            duration: 0
          }
        },
        inactive: {
          animation: {
            duration: 50
          },
          opacity: .2
        }
      },
      stickyTracking: !0,
      turboThreshold: 1E3,
      findNearestPointBy: "x"
    }, {
      axisTypes: ["xAxis", "yAxis"],
      coll: "series",
      colorCounter: 0,
      cropShoulder: 1,
      directTouch: !1,
      eventsToUnbind: [],
      isCartesian: !0,
      parallelArrays: ["x", "y"],
      pointClass: r,
      requireSorting: !0,
      sorted: !0,
      init: function (b, e) {
        q(this, "init", {
          options: e
        });
        var f = this,
            d = b.series,
            k;
        this.eventOptions = this.eventOptions || {};
        f.chart = b;
        f.options = e = f.setOptions(e);
        f.linkedSeries = [];
        f.bindAxes();
        h(f, {
          name: e.name,
          state: "",
          visible: !1 !== e.visible,
          selected: !0 === e.selected
        });
        var p = e.events;
        a(p, function (b, a) {
          c(b) && f.eventOptions[a] !== b && (c(f.eventOptions[a]) && v(f, a, f.eventOptions[a]), f.eventOptions[a] = b, I(f, a, b));
        });
        if (p && p.click || e.point && e.point.events && e.point.events.click || e.allowPointSelect) b.runTrackerClick = !0;
        f.getColor();
        f.getSymbol();
        f.parallelArrays.forEach(function (b) {
          f[b + "Data"] || (f[b + "Data"] = []);
        });
        f.isCartesian && (b.hasCartesianSeries = !0);
        d.length && (k = d[d.length - 1]);
        f._i = l(k && k._i, -1) + 1;
        b.orderSeries(this.insert(d));
        e.dataSorting && e.dataSorting.enabled ? f.setDataSortingOptions() : f.points || f.data || f.setData(e.data, !1);
        q(this, "afterInit");
      },
      is: function (b) {
        return H[b] && this instanceof H[b];
      },
      insert: function (b) {
        var a = this.options.index,
            c;

        if (k(a)) {
          for (c = b.length; c--;) if (a >= l(b[c].options.index, b[c]._i)) {
            b.splice(c + 1, 0, this);
            break;
          }

          -1 === c && b.unshift(this);
          c += 1;
        } else b.push(this);

        return l(c, b.length - 1);
      },
      bindAxes: function () {
        var b = this,
            a = b.options,
            c = b.chart,
            e;
        q(this, "bindAxes", null, function () {
          (b.axisTypes || []).forEach(function (f) {
            c[f].forEach(function (c) {
              e = c.options;
              if (a[f] === e.index || "undefined" !== typeof a[f] && a[f] === e.id || "undefined" === typeof a[f] && 0 === e.index) b.insert(c.series), b[f] = c, c.isDirty = !0;
            });
            b[f] || b.optionalAxis === f || D(18, !0, c);
          });
        });
        q(this, "afterBindAxes");
      },
      updateParallelArrays: function (b, a) {
        var c = b.series,
            e = arguments,
            f = k(a) ? function (e) {
          var f = "y" === e && c.toYData ? c.toYData(b) : b[e];
          c[e + "Data"][a] = f;
        } : function (b) {
          Array.prototype[a].apply(c[b + "Data"], Array.prototype.slice.call(e, 2));
        };
        c.parallelArrays.forEach(f);
      },
      hasData: function () {
        return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
      },
      autoIncrement: function () {
        var b = this.options,
            a = this.xIncrement,
            c,
            e = b.pointIntervalUnit,
            f = this.chart.time;
        a = l(a, b.pointStart, 0);
        this.pointInterval = c = l(this.pointInterval, b.pointInterval, 1);
        e && (b = new f.Date(a), "day" === e ? f.set("Date", b, f.get("Date", b) + c) : "month" === e ? f.set("Month", b, f.get("Month", b) + c) : "year" === e && f.set("FullYear", b, f.get("FullYear", b) + c), c = b.getTime() - a);
        this.xIncrement = a + c;
        return a;
      },
      setDataSortingOptions: function () {
        var b = this.options;
        h(this, {
          requireSorting: !1,
          sorted: !1,
          enabledDataSorting: !0,
          allowDG: !1
        });
        y(b.pointRange) || (b.pointRange = 1);
      },
      setOptions: function (b) {
        var a = this.chart,
            c = a.options,
            e = c.plotOptions,
            d = a.userOptions || {};
        b = f(b);
        a = a.styledMode;
        var k = {
          plotOptions: e,
          userOptions: b
        };
        q(this, "setOptions", k);
        var h = k.plotOptions[this.type],
            m = d.plotOptions || {};
        this.userOptions = k.userOptions;
        d = f(h, e.series, d.plotOptions && d.plotOptions[this.type], b);
        this.tooltipOptions = f(L.tooltip, L.plotOptions.series && L.plotOptions.series.tooltip, L.plotOptions[this.type].tooltip, c.tooltip.userOptions, e.series && e.series.tooltip, e[this.type].tooltip, b.tooltip);
        this.stickyTracking = l(b.stickyTracking, m[this.type] && m[this.type].stickyTracking, m.series && m.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : d.stickyTracking);
        null === h.marker && delete d.marker;
        this.zoneAxis = d.zoneAxis;
        c = this.zones = (d.zones || []).slice();
        !d.negativeColor && !d.negativeFillColor || d.zones || (e = {
          value: d[this.zoneAxis + "Threshold"] || d.threshold || 0,
          className: "highcharts-negative"
        }, a || (e.color = d.negativeColor, e.fillColor = d.negativeFillColor), c.push(e));
        c.length && y(c[c.length - 1].value) && c.push(a ? {} : {
          color: this.color,
          fillColor: this.fillColor
        });
        q(this, "afterSetOptions", {
          options: d
        });
        return d;
      },
      getName: function () {
        return l(this.options.name, "Series " + (this.index + 1));
      },
      getCyclic: function (b, a, c) {
        var e = this.chart,
            f = this.userOptions,
            d = b + "Index",
            k = b + "Counter",
            h = c ? c.length : l(e.options.chart[b + "Count"], e[b + "Count"]);

        if (!a) {
          var p = l(f[d], f["_" + d]);
          y(p) || (e.series.length || (e[k] = 0), f["_" + d] = p = e[k] % h, e[k] += 1);
          c && (a = c[p]);
        }

        "undefined" !== typeof p && (this[d] = p);
        this[b] = a;
      },
      getColor: function () {
        this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.options.color = null : this.getCyclic("color", this.options.color || Q[this.type].color, this.chart.options.colors);
      },
      getPointsCollection: function () {
        return (this.hasGroupedData ? this.points : this.data) || [];
      },
      getSymbol: function () {
        this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
      },
      findPointIndex: function (b, a) {
        var c = b.id,
            e = b.x,
            f = this.points,
            d,
            h = this.options.dataSorting;
        if (c) var l = this.chart.get(c);else if (this.linkedParent || this.enabledDataSorting) {
          var p = h && h.matchByName ? "name" : "index";
          l = N(f, function (a) {
            return !a.touched && a[p] === b[p];
          });
          if (!l) return;
        }

        if (l) {
          var n = l && l.index;
          "undefined" !== typeof n && (d = !0);
        }

        "undefined" === typeof n && k(e) && (n = this.xData.indexOf(e, a));
        -1 !== n && "undefined" !== typeof n && this.cropped && (n = n >= this.cropStart ? n - this.cropStart : n);
        !d && f[n] && f[n].touched && (n = void 0);
        return n;
      },
      drawLegendSymbol: g.drawLineMarker,
      updateData: function (b, a) {
        var c = this.options,
            e = c.dataSorting,
            f = this.points,
            d = [],
            h,
            l,
            n,
            p = this.requireSorting,
            g = b.length === f.length,
            w = !0;
        this.xIncrement = null;
        b.forEach(function (b, a) {
          var l = y(b) && this.pointClass.prototype.optionsToObject.call({
            series: this
          }, b) || {};
          var m = l.x;

          if (l.id || k(m)) {
            if (m = this.findPointIndex(l, n), -1 === m || "undefined" === typeof m ? d.push(b) : f[m] && b !== c.data[m] ? (f[m].update(b, !1, null, !1), f[m].touched = !0, p && (n = m + 1)) : f[m] && (f[m].touched = !0), !g || a !== m || e && e.enabled || this.hasDerivedData) h = !0;
          } else d.push(b);
        }, this);
        if (h) for (b = f.length; b--;) (l = f[b]) && !l.touched && l.remove && l.remove(!1, a);else !g || e && e.enabled ? w = !1 : (b.forEach(function (b, a) {
          f[a].update && b !== f[a].y && f[a].update(b, !1, null, !1);
        }), d.length = 0);
        f.forEach(function (b) {
          b && (b.touched = !1);
        });
        if (!w) return !1;
        d.forEach(function (b) {
          this.addPoint(b, !1, null, null, !1);
        }, this);
        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = E(this.xData), this.autoIncrement());
        return !0;
      },
      setData: function (b, a, c, f) {
        var d = this,
            h = d.points,
            p = h && h.length || 0,
            m,
            g = d.options,
            w = d.chart,
            x = g.dataSorting,
            q = null,
            v = d.xAxis;
        q = g.turboThreshold;
        var C = this.xData,
            t = this.yData,
            B = (m = d.pointArrayMap) && m.length,
            z = g.keys,
            y = 0,
            L = 1,
            u;
        b = b || [];
        m = b.length;
        a = l(a, !0);
        x && x.enabled && (b = this.sortData(b));
        !1 !== f && m && p && !d.cropped && !d.hasGroupedData && d.visible && !d.isSeriesBoosting && (u = this.updateData(b, c));

        if (!u) {
          d.xIncrement = null;
          d.colorCounter = 0;
          this.parallelArrays.forEach(function (b) {
            d[b + "Data"].length = 0;
          });
          if (q && m > q) {
            if (q = d.getFirstValidPoint(b), k(q)) for (c = 0; c < m; c++) C[c] = this.autoIncrement(), t[c] = b[c];else if (e(q)) {
              if (B) for (c = 0; c < m; c++) f = b[c], C[c] = f[0], t[c] = f.slice(1, B + 1);else for (z && (y = z.indexOf("x"), L = z.indexOf("y"), y = 0 <= y ? y : 0, L = 0 <= L ? L : 1), c = 0; c < m; c++) f = b[c], C[c] = f[y], t[c] = f[L];
            } else D(12, !1, w);
          } else for (c = 0; c < m; c++) "undefined" !== typeof b[c] && (f = {
            series: d
          }, d.pointClass.prototype.applyOptions.apply(f, [b[c]]), d.updateParallelArrays(f, c));
          t && n(t[0]) && D(14, !0, w);
          d.data = [];
          d.options.data = d.userOptions.data = b;

          for (c = p; c--;) h[c] && h[c].destroy && h[c].destroy();

          v && (v.minRange = v.userMinRange);
          d.isDirty = w.isDirtyBox = !0;
          d.isDirtyData = !!h;
          c = !1;
        }

        "point" === g.legendType && (this.processData(), this.generatePoints());
        a && w.redraw(c);
      },
      sortData: function (b) {
        var a = this,
            c = a.options.dataSorting.sortKey || "y",
            e = function (b, a) {
          return y(a) && b.pointClass.prototype.optionsToObject.call({
            series: b
          }, a) || {};
        };

        b.forEach(function (c, f) {
          b[f] = e(a, c);
          b[f].index = f;
        }, this);
        b.concat().sort(function (b, a) {
          b = P(c, b);
          a = P(c, a);
          return a < b ? -1 : a > b ? 1 : 0;
        }).forEach(function (b, a) {
          b.x = a;
        }, this);
        a.linkedSeries && a.linkedSeries.forEach(function (a) {
          var c = a.options,
              f = c.data;
          c.dataSorting && c.dataSorting.enabled || !f || (f.forEach(function (c, d) {
            f[d] = e(a, c);
            b[d] && (f[d].x = b[d].x, f[d].index = d);
          }), a.setData(f, !1));
        });
        return b;
      },
      processData: function (b) {
        var a = this.xData,
            c = this.yData,
            e = a.length;
        var f = 0;
        var d = this.xAxis,
            k = this.options;
        var h = k.cropThreshold;
        var l = this.getExtremesFromAll || k.getExtremesFromAll,
            p = this.isCartesian;
        k = d && d.val2lin;
        var n = d && d.isLog,
            g = this.requireSorting;
        if (p && !this.isDirty && !d.isDirty && !this.yAxis.isDirty && !b) return !1;

        if (d) {
          b = d.getExtremes();
          var w = b.min;
          var q = b.max;
        }

        if (p && this.sorted && !l && (!h || e > h || this.forceCrop)) if (a[e - 1] < w || a[0] > q) a = [], c = [];else if (this.yData && (a[0] < w || a[e - 1] > q)) {
          f = this.cropData(this.xData, this.yData, w, q);
          a = f.xData;
          c = f.yData;
          f = f.start;
          var v = !0;
        }

        for (h = a.length || 1; --h;) if (e = n ? k(a[h]) - k(a[h - 1]) : a[h] - a[h - 1], 0 < e && ("undefined" === typeof t || e < t)) var t = e;else 0 > e && g && (D(15, !1, this.chart), g = !1);

        this.cropped = v;
        this.cropStart = f;
        this.processedXData = a;
        this.processedYData = c;
        this.closestPointRange = this.basePointRange = t;
      },
      cropData: function (b, a, c, e, f) {
        var d = b.length,
            k = 0,
            h = d,
            p;
        f = l(f, this.cropShoulder);

        for (p = 0; p < d; p++) if (b[p] >= c) {
          k = Math.max(0, p - f);
          break;
        }

        for (c = p; c < d; c++) if (b[c] > e) {
          h = c + f;
          break;
        }

        return {
          xData: b.slice(k, h),
          yData: a.slice(k, h),
          start: k,
          end: h
        };
      },
      generatePoints: function () {
        var b = this.options,
            a = b.data,
            c = this.data,
            e,
            f = this.processedXData,
            d = this.processedYData,
            k = this.pointClass,
            l = f.length,
            p = this.cropStart || 0,
            n = this.hasGroupedData;
        b = b.keys;
        var g = [],
            v;
        c || n || (c = [], c.length = a.length, c = this.data = c);
        b && n && (this.options.keys = !1);

        for (v = 0; v < l; v++) {
          var t = p + v;

          if (n) {
            var B = new k().init(this, [f[v]].concat(w(d[v])));
            B.dataGroup = this.groupMap[v];
            B.dataGroup.options && (B.options = B.dataGroup.options, h(B, B.dataGroup.options), delete B.dataLabels);
          } else (B = c[t]) || "undefined" === typeof a[t] || (c[t] = B = new k().init(this, a[t], f[v]));

          B && (B.index = t, g[v] = B);
        }

        this.options.keys = b;
        if (c && (l !== (e = c.length) || n)) for (v = 0; v < e; v++) v !== p || n || (v += l), c[v] && (c[v].destroyElements(), c[v].plotX = void 0);
        this.data = c;
        this.points = g;
        q(this, "afterGeneratePoints");
      },
      getXExtremes: function (b) {
        return {
          min: A(b),
          max: E(b)
        };
      },
      getExtremes: function (b) {
        var a = this.xAxis,
            c = this.yAxis,
            f = this.processedXData || this.xData,
            d = [],
            h = 0,
            l = 0;
        var m = 0;
        var p = this.requireSorting ? this.cropShoulder : 0,
            n = c ? c.positiveValuesOnly : !1,
            g;
        b = b || this.stackedYData || this.processedYData || [];
        c = b.length;
        a && (m = a.getExtremes(), l = m.min, m = m.max);

        for (g = 0; g < c; g++) {
          var w = f[g];
          var v = b[g];
          var t = (k(v) || e(v)) && (v.length || 0 < v || !n);
          w = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !a || (f[g + p] || w) >= l && (f[g - p] || w) <= m;
          if (t && w) if (t = v.length) for (; t--;) k(v[t]) && (d[h++] = v[t]);else d[h++] = v;
        }

        this.dataMin = A(d);
        this.dataMax = E(d);
        q(this, "afterGetExtremes");
      },
      getFirstValidPoint: function (b) {
        for (var a = null, c = b.length, e = 0; null === a && e < c;) a = b[e], e++;

        return a;
      },
      translate: function () {
        this.processedXData || this.processData();
        this.generatePoints();
        var b = this.options,
            a = b.stacking,
            c = this.xAxis,
            f = c.categories,
            d = this.enabledDataSorting,
            h = this.yAxis,
            p = this.points,
            m = p.length,
            n = !!this.modifyValue,
            g,
            w = this.pointPlacementToXValue(),
            v = !!w,
            t = b.threshold,
            B = b.startFromThreshold ? t : 0,
            z,
            L = this.zoneAxis || "y",
            u = Number.MAX_VALUE;

        for (g = 0; g < m; g++) {
          var K = p[g],
              r = K.x,
              H = K.y,
              D = K.low,
              A = a && h.stacks[(this.negStacks && H < (B ? 0 : t) ? "-" : "") + this.stackKey];
          h.positiveValuesOnly && null !== H && 0 >= H && (K.isNull = !0);
          K.plotX = z = J(G(c.translate(r, 0, 0, 0, 1, w, "flags" === this.type), -1E5, 1E5));

          if (a && this.visible && A && A[r]) {
            var N = this.getStackIndicator(N, r, this.index);

            if (!K.isNull) {
              var Q = A[r];
              var E = Q.points[N.key];
            }
          }

          e(E) && (D = E[0], H = E[1], D === B && N.key === A[r].base && (D = l(k(t) && t, h.min)), h.positiveValuesOnly && 0 >= D && (D = null), K.total = K.stackTotal = Q.total, K.percentage = Q.total && K.y / Q.total * 100, K.stackY = H, this.irregularWidths || Q.setOffset(this.pointXOffset || 0, this.barW || 0));
          K.yBottom = y(D) ? G(h.translate(D, 0, 1, 0, 1), -1E5, 1E5) : null;
          n && (H = this.modifyValue(H, K));
          K.plotY = "number" === typeof H && Infinity !== H ? G(h.translate(H, 0, 1, 0, 1), -1E5, 1E5) : void 0;
          K.isInside = this.isPointInside(K);
          K.clientX = v ? J(c.translate(r, 0, 0, 0, 1, w)) : z;
          K.negative = K[L] < (b[L + "Threshold"] || t || 0);
          K.category = f && "undefined" !== typeof f[K.x] ? f[K.x] : K.x;

          if (!K.isNull && !1 !== K.visible) {
            "undefined" !== typeof P && (u = Math.min(u, Math.abs(z - P)));
            var P = z;
          }

          K.zone = this.zones.length && K.getZone();
          !K.graphic && this.group && d && (K.isNew = !0);
        }

        this.closestPointRangePx = u;
        q(this, "afterTranslate");
      },
      getValidPoints: function (b, a, c) {
        var e = this.chart;
        return (b || this.points || []).filter(function (b) {
          return a && !e.isInsidePlot(b.plotX, b.plotY, e.inverted) ? !1 : !1 !== b.visible && (c || !b.isNull);
        });
      },
      getClipBox: function (b, a) {
        var c = this.options,
            e = this.chart,
            f = e.inverted,
            d = this.xAxis,
            k = d && this.yAxis;
        b && !1 === c.clip && k ? b = f ? {
          y: -e.chartWidth + k.len + k.pos,
          height: e.chartWidth,
          width: e.chartHeight,
          x: -e.chartHeight + d.len + d.pos
        } : {
          y: -k.pos,
          height: e.chartHeight,
          width: e.chartWidth,
          x: -d.pos
        } : (b = this.clipBox || e.clipBox, a && (b.width = e.plotSizeX, b.x = 0));
        return a ? {
          width: b.width,
          x: b.x
        } : b;
      },
      setClip: function (b) {
        var a = this.chart,
            c = this.options,
            e = a.renderer,
            f = a.inverted,
            d = this.clipBox,
            k = this.getClipBox(b),
            h = this.sharedClipKey || ["_sharedClip", b && b.duration, b && b.easing, k.height, c.xAxis, c.yAxis].join(),
            l = a[h],
            p = a[h + "m"];
        b && (k.width = 0, f && (k.x = a.plotHeight + (!1 !== c.clip ? 0 : a.plotTop)));
        l ? a.hasLoaded || l.attr(k) : (b && (a[h + "m"] = p = e.clipRect(f ? a.plotSizeX + 99 : -99, f ? -a.plotLeft : -a.plotTop, 99, f ? a.chartWidth : a.chartHeight)), a[h] = l = e.clipRect(k), l.count = {
          length: 0
        });
        b && !l.count[this.index] && (l.count[this.index] = !0, l.count.length += 1);
        if (!1 !== c.clip || b) this.group.clip(b || d ? l : a.clipRect), this.markerGroup.clip(p), this.sharedClipKey = h;
        b || (l.count[this.index] && (delete l.count[this.index], --l.count.length), 0 === l.count.length && h && a[h] && (d || (a[h] = a[h].destroy()), a[h + "m"] && (a[h + "m"] = a[h + "m"].destroy())));
      },
      animate: function (b) {
        var a = this.chart,
            c = M(this.options.animation);
        if (!a.hasRendered) if (b) this.setClip(c);else {
          var e = this.sharedClipKey;
          b = a[e];
          var f = this.getClipBox(c, !0);
          b && b.animate(f, c);
          a[e + "m"] && a[e + "m"].animate({
            width: f.width + 99,
            x: f.x - (a.inverted ? 0 : 99)
          }, c);
        }
      },
      afterAnimate: function () {
        this.setClip();
        q(this, "afterAnimate");
        this.finishedAnimating = !0;
      },
      drawPoints: function () {
        var b = this.points,
            a = this.chart,
            c,
            e,
            f = this.options.marker,
            d = this[this.specialGroup] || this.markerGroup,
            k = this.xAxis,
            h = l(f.enabled, !k || k.isRadial ? !0 : null, this.closestPointRangePx >= f.enabledThreshold * f.radius);
        if (!1 !== f.enabled || this._hasPointMarkers) for (c = 0; c < b.length; c++) {
          var p = b[c];
          var n = (e = p.graphic) ? "animate" : "attr";
          var g = p.marker || {};
          var w = !!p.marker;

          if ((h && "undefined" === typeof g.enabled || g.enabled) && !p.isNull && !1 !== p.visible) {
            var v = l(g.symbol, this.symbol);
            var q = this.markerAttribs(p, p.selected && "select");
            this.enabledDataSorting && (p.startXPos = k.reversed ? -q.width : k.width);
            var t = !1 !== p.isInside;
            e ? e[t ? "show" : "hide"](t).animate(q) : t && (0 < q.width || p.hasImage) && (p.graphic = e = a.renderer.symbol(v, q.x, q.y, q.width, q.height, w ? g : f).add(d), this.enabledDataSorting && a.hasRendered && (e.attr({
              x: p.startXPos
            }), n = "animate"));
            e && "animate" === n && e[t ? "show" : "hide"](t).animate(q);
            if (e && !a.styledMode) e[n](this.pointAttribs(p, p.selected && "select"));
            e && e.addClass(p.getClassName(), !0);
          } else e && (p.graphic = e.destroy());
        }
      },
      markerAttribs: function (b, a) {
        var c = this.options.marker,
            e = b.marker || {},
            f = e.symbol || c.symbol,
            d = l(e.radius, c.radius);
        a && (c = c.states[a], a = e.states && e.states[a], d = l(a && a.radius, c && c.radius, d + (c && c.radiusPlus || 0)));
        b.hasImage = f && 0 === f.indexOf("url");
        b.hasImage && (d = 0);
        b = {
          x: Math.floor(b.plotX) - d,
          y: b.plotY - d
        };
        d && (b.width = b.height = 2 * d);
        return b;
      },
      pointAttribs: function (b, a) {
        var c = this.options.marker,
            e = b && b.options,
            f = e && e.marker || {},
            d = this.color,
            k = e && e.color,
            h = b && b.color;
        e = l(f.lineWidth, c.lineWidth);
        var p = b && b.zone && b.zone.color;
        b = 1;
        d = k || p || h || d;
        k = f.fillColor || c.fillColor || d;
        d = f.lineColor || c.lineColor || d;
        a = a || "normal";
        c = c.states[a];
        a = f.states && f.states[a] || {};
        e = l(a.lineWidth, c.lineWidth, e + l(a.lineWidthPlus, c.lineWidthPlus, 0));
        k = a.fillColor || c.fillColor || k;
        d = a.lineColor || c.lineColor || d;
        b = l(a.opacity, c.opacity, b);
        return {
          stroke: d,
          "stroke-width": e,
          fill: k,
          opacity: b
        };
      },
      destroy: function (b) {
        var c = this,
            e = c.chart,
            f = /AppleWebKit\/533/.test(p.navigator.userAgent),
            d,
            k,
            h = c.data || [],
            l,
            n;
        q(c, "destroy");
        this.removeEvents(b);
        (c.axisTypes || []).forEach(function (b) {
          (n = c[b]) && n.series && (t(n.series, c), n.isDirty = n.forceRedraw = !0);
        });
        c.legendItem && c.chart.legend.destroyItem(c);

        for (k = h.length; k--;) (l = h[k]) && l.destroy && l.destroy();

        c.points = null;
        u.clearTimeout(c.animationTimeout);
        a(c, function (b, a) {
          b instanceof K && !b.survive && (d = f && "group" === a ? "hide" : "destroy", b[d]());
        });
        e.hoverSeries === c && (e.hoverSeries = null);
        t(e.series, c);
        e.orderSeries();
        a(c, function (a, e) {
          b && "hcEvents" === e || delete c[e];
        });
      },
      getGraphPath: function (b, a, c) {
        var e = this,
            f = e.options,
            d = f.step,
            k,
            h = [],
            l = [],
            p;
        b = b || e.points;
        (k = b.reversed) && b.reverse();
        (d = {
          right: 1,
          center: 2
        }[d] || d && 3) && k && (d = 4 - d);
        b = this.getValidPoints(b, !1, !(f.connectNulls && !a && !c));
        b.forEach(function (k, n) {
          var m = k.plotX,
              g = k.plotY,
              w = b[n - 1];
          (k.leftCliff || w && w.rightCliff) && !c && (p = !0);
          k.isNull && !y(a) && 0 < n ? p = !f.connectNulls : k.isNull && !a ? p = !0 : (0 === n || p ? n = ["M", k.plotX, k.plotY] : e.getPointSpline ? n = e.getPointSpline(b, k, n) : d ? (n = 1 === d ? ["L", w.plotX, g] : 2 === d ? ["L", (w.plotX + m) / 2, w.plotY, "L", (w.plotX + m) / 2, g] : ["L", m, w.plotY], n.push("L", m, g)) : n = ["L", m, g], l.push(k.x), d && (l.push(k.x), 2 === d && l.push(k.x)), h.push.apply(h, n), p = !1);
        });
        h.xMap = l;
        return e.graphPath = h;
      },
      drawGraph: function () {
        var b = this,
            a = this.options,
            c = (this.gappedPath || this.getGraphPath).call(this),
            e = this.chart.styledMode,
            f = [["graph", "highcharts-graph"]];
        e || f[0].push(a.lineColor || this.color || "#cccccc", a.dashStyle);
        f = b.getZonesGraphs(f);
        f.forEach(function (f, d) {
          var k = f[0],
              h = b[k],
              l = h ? "animate" : "attr";
          h ? (h.endX = b.preventGraphAnimation ? null : c.xMap, h.animate({
            d: c
          })) : c.length && (b[k] = h = b.chart.renderer.path(c).addClass(f[1]).attr({
            zIndex: 1
          }).add(b.group));
          h && !e && (k = {
            stroke: f[2],
            "stroke-width": a.lineWidth,
            fill: b.fillGraph && b.color || "none"
          }, f[3] ? k.dashstyle = f[3] : "square" !== a.linecap && (k["stroke-linecap"] = k["stroke-linejoin"] = "round"), h[l](k).shadow(2 > d && a.shadow));
          h && (h.startX = c.xMap, h.isArea = c.isArea);
        });
      },
      getZonesGraphs: function (a) {
        this.zones.forEach(function (b, c) {
          c = ["zone-graph-" + c, "highcharts-graph highcharts-zone-graph-" + c + " " + (b.className || "")];
          this.chart.styledMode || c.push(b.color || this.color, b.dashStyle || this.options.dashStyle);
          a.push(c);
        }, this);
        return a;
      },
      applyZones: function () {
        var a = this,
            c = this.chart,
            e = c.renderer,
            f = this.zones,
            d,
            k,
            h = this.clips || [],
            p,
            n = this.graph,
            g = this.area,
            w = Math.max(c.chartWidth, c.chartHeight),
            v = this[(this.zoneAxis || "y") + "Axis"],
            q = c.inverted,
            t,
            B,
            z,
            y = !1;

        if (f.length && (n || g) && v && "undefined" !== typeof v.min) {
          var K = v.reversed;
          var L = v.horiz;
          n && !this.showLine && n.hide();
          g && g.hide();
          var u = v.getExtremes();
          f.forEach(function (b, f) {
            d = K ? L ? c.plotWidth : 0 : L ? 0 : v.toPixels(u.min) || 0;
            d = G(l(k, d), 0, w);
            k = G(Math.round(v.toPixels(l(b.value, u.max), !0) || 0), 0, w);
            y && (d = k = v.toPixels(u.max));
            t = Math.abs(d - k);
            B = Math.min(d, k);
            z = Math.max(d, k);
            v.isXAxis ? (p = {
              x: q ? z : B,
              y: 0,
              width: t,
              height: w
            }, L || (p.x = c.plotHeight - p.x)) : (p = {
              x: 0,
              y: q ? z : B,
              width: w,
              height: t
            }, L && (p.y = c.plotWidth - p.y));
            q && e.isVML && (p = v.isXAxis ? {
              x: 0,
              y: K ? B : z,
              height: p.width,
              width: c.chartWidth
            } : {
              x: p.y - c.plotLeft - c.spacingBox.x,
              y: 0,
              width: p.height,
              height: c.chartHeight
            });
            h[f] ? h[f].animate(p) : h[f] = e.clipRect(p);
            n && a["zone-graph-" + f].clip(h[f]);
            g && a["zone-area-" + f].clip(h[f]);
            y = b.value > u.max;
            a.resetZones && 0 === k && (k = void 0);
          });
          this.clips = h;
        } else a.visible && (n && n.show(!0), g && g.show(!0));
      },
      invertGroups: function (a) {
        function b() {
          ["group", "markerGroup"].forEach(function (b) {
            c[b] && (e.renderer.isVML && c[b].attr({
              width: c.yAxis.len,
              height: c.xAxis.len
            }), c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(c.isRadialSeries ? !1 : a));
          });
        }

        var c = this,
            e = c.chart;
        c.xAxis && (c.eventsToUnbind.push(I(e, "resize", b)), b(), c.invertGroups = b);
      },
      plotGroup: function (a, c, e, f, d) {
        var b = this[a],
            k = !b;
        k && (this[a] = b = this.chart.renderer.g().attr({
          zIndex: f || .1
        }).add(d));
        b.addClass("highcharts-" + c + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (y(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (b.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
        b.attr({
          visibility: e
        })[k ? "attr" : "animate"](this.getPlotBox());
        return b;
      },
      getPlotBox: function () {
        var a = this.chart,
            c = this.xAxis,
            e = this.yAxis;
        a.inverted && (c = e, e = this.xAxis);
        return {
          translateX: c ? c.left : a.plotLeft,
          translateY: e ? e.top : a.plotTop,
          scaleX: 1,
          scaleY: 1
        };
      },
      removeEvents: function (a) {
        a ? this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (a) {
          a();
        }), this.eventsToUnbind.length = 0) : v(this);
      },
      render: function () {
        var a = this,
            c = a.chart,
            e = a.options,
            f = !a.finishedAnimating && c.renderer.isSVG && M(e.animation).duration,
            d = a.visible ? "inherit" : "hidden",
            k = e.zIndex,
            h = a.hasRendered,
            l = c.seriesGroup,
            p = c.inverted;
        q(this, "render");
        var n = a.plotGroup("group", "series", d, k, l);
        a.markerGroup = a.plotGroup("markerGroup", "markers", d, k, l);
        f && a.animate && a.animate(!0);
        n.inverted = a.isCartesian || a.invertable ? p : !1;
        a.drawGraph && (a.drawGraph(), a.applyZones());
        a.visible && a.drawPoints();
        a.drawDataLabels && a.drawDataLabels();
        a.redrawPoints && a.redrawPoints();
        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();
        a.invertGroups(p);
        !1 === e.clip || a.sharedClipKey || h || n.clip(c.clipRect);
        f && a.animate && a.animate();
        h || (a.animationTimeout = B(function () {
          a.afterAnimate();
        }, f || 0));
        a.isDirty = !1;
        a.hasRendered = !0;
        q(a, "afterRender");
      },
      redraw: function () {
        var a = this.chart,
            c = this.isDirty || this.isDirtyData,
            e = this.group,
            f = this.xAxis,
            d = this.yAxis;
        e && (a.inverted && e.attr({
          width: a.plotWidth,
          height: a.plotHeight
        }), e.animate({
          translateX: l(f && f.left, a.plotLeft),
          translateY: l(d && d.top, a.plotTop)
        }));
        this.translate();
        this.render();
        c && delete this.kdTree;
      },
      kdAxisArray: ["clientX", "plotY"],
      searchPoint: function (a, c) {
        var b = this.xAxis,
            e = this.yAxis,
            f = this.chart.inverted;
        return this.searchKDTree({
          clientX: f ? b.len - a.chartY + b.pos : a.chartX - b.pos,
          plotY: f ? e.len - a.chartX + e.pos : a.chartY - e.pos
        }, c, a);
      },
      buildKDTree: function (a) {
        function b(a, e, f) {
          var d;

          if (d = a && a.length) {
            var k = c.kdAxisArray[e % f];
            a.sort(function (a, b) {
              return a[k] - b[k];
            });
            d = Math.floor(d / 2);
            return {
              point: a[d],
              left: b(a.slice(0, d), e + 1, f),
              right: b(a.slice(d + 1), e + 1, f)
            };
          }
        }

        this.buildingKdTree = !0;
        var c = this,
            e = -1 < c.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        delete c.kdTree;
        B(function () {
          c.kdTree = b(c.getValidPoints(null, !c.directTouch), e, e);
          c.buildingKdTree = !1;
        }, c.options.kdNow || a && "touchstart" === a.type ? 0 : 1);
      },
      searchKDTree: function (a, c, e) {
        function b(a, c, e, l) {
          var p = c.point,
              n = f.kdAxisArray[e % l],
              g = p;
          var m = y(a[d]) && y(p[d]) ? Math.pow(a[d] - p[d], 2) : null;
          var w = y(a[k]) && y(p[k]) ? Math.pow(a[k] - p[k], 2) : null;
          w = (m || 0) + (w || 0);
          p.dist = y(w) ? Math.sqrt(w) : Number.MAX_VALUE;
          p.distX = y(m) ? Math.sqrt(m) : Number.MAX_VALUE;
          n = a[n] - p[n];
          w = 0 > n ? "left" : "right";
          m = 0 > n ? "right" : "left";
          c[w] && (w = b(a, c[w], e + 1, l), g = w[h] < g[h] ? w : p);
          c[m] && Math.sqrt(n * n) < g[h] && (a = b(a, c[m], e + 1, l), g = a[h] < g[h] ? a : g);
          return g;
        }

        var f = this,
            d = this.kdAxisArray[0],
            k = this.kdAxisArray[1],
            h = c ? "distX" : "dist";
        c = -1 < f.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        this.kdTree || this.buildingKdTree || this.buildKDTree(e);
        if (this.kdTree) return b(a, this.kdTree, c, c);
      },
      pointPlacementToXValue: function () {
        var a = this.options,
            c = a.pointRange,
            e = this.xAxis;
        a = a.pointPlacement;
        "between" === a && (a = e.reversed ? -.5 : .5);
        return k(a) ? a * l(c, e.pointRange) : 0;
      },
      isPointInside: function (a) {
        return "undefined" !== typeof a.plotY && "undefined" !== typeof a.plotX && 0 <= a.plotY && a.plotY <= this.yAxis.len && 0 <= a.plotX && a.plotX <= this.xAxis.len;
      }
    });
    "";
  });
  S(r, "parts/Stacking.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.correctFloat,
        u = g.defined,
        I = g.destroyObjectProperties,
        M = g.format,
        E = g.objectEach,
        A = g.pick;
    g = d.Axis;
    var G = d.Chart,
        J = d.Series;

    d.StackItem = function (d, g, u, h, r) {
      var q = d.chart.inverted;
      this.axis = d;
      this.isNegative = u;
      this.options = g = g || {};
      this.x = h;
      this.total = null;
      this.points = {};
      this.stack = r;
      this.rightCliff = this.leftCliff = 0;
      this.alignOptions = {
        align: g.align || (q ? u ? "left" : "right" : "center"),
        verticalAlign: g.verticalAlign || (q ? "middle" : u ? "bottom" : "top"),
        y: g.y,
        x: g.x
      };
      this.textAlign = g.textAlign || (q ? u ? "right" : "left" : "center");
    };

    d.StackItem.prototype = {
      destroy: function () {
        I(this, this.axis);
      },
      render: function (d) {
        var g = this.axis.chart,
            y = this.options,
            h = y.format;
        h = h ? M(h, this, g) : y.formatter.call(this);
        this.label ? this.label.attr({
          text: h,
          visibility: "hidden"
        }) : (this.label = g.renderer.label(h, null, null, y.shape, null, null, y.useHTML, !1, "stack-labels"), h = {
          text: h,
          rotation: y.rotation,
          padding: A(y.padding, 5),
          visibility: "hidden"
        }, this.label.attr(h), g.styledMode || this.label.css(y.style), this.label.added || this.label.add(d));
        this.label.labelrank = g.plotHeight;
      },
      setOffset: function (d, g, r, h, N) {
        var q = this.axis,
            t = q.chart;
        h = q.translate(q.usePercentage ? 100 : h ? h : this.total, 0, 0, 0, 1);
        r = q.translate(r ? r : 0);
        r = u(h) && Math.abs(h - r);
        d = A(N, t.xAxis[0].translate(this.x)) + d;
        q = u(h) && this.getStackBox(t, this, d, h, g, r, q);
        g = this.label;
        r = this.isNegative;
        d = "justify" === A(this.options.overflow, "justify");
        var e = this.textAlign;
        g && q && (N = g.getBBox(), h = g.padding, e = "left" === e ? t.inverted ? -h : h : "right" === e ? N.width : t.inverted && "center" === e ? N.width / 2 : t.inverted ? r ? N.width + h : -h : N.width / 2, r = t.inverted ? N.height / 2 : r ? -h : N.height, this.alignOptions.x = A(this.options.x, 0), this.alignOptions.y = A(this.options.y, 0), q.x -= e, q.y -= r, g.align(this.alignOptions, null, q), t.isInsidePlot(g.alignAttr.x + e - this.alignOptions.x, g.alignAttr.y + r - this.alignOptions.y) ? g.show() : (g.alignAttr.y = -9999, d = !1), d && J.prototype.justifyDataLabel.call(this.axis, g, this.alignOptions, g.alignAttr, N, q), g.attr({
          x: g.alignAttr.x,
          y: g.alignAttr.y
        }), A(!d && this.options.crop, !0) && ((t = t.isInsidePlot(g.x - h + g.width, g.y) && t.isInsidePlot(g.x + h, g.y)) || g.hide()));
      },
      getStackBox: function (d, g, r, h, u, q, A) {
        var e = g.axis.reversed,
            c = d.inverted;
        d = A.height + A.pos - (c ? d.plotLeft : d.plotTop);
        g = g.isNegative && !e || !g.isNegative && e;
        return {
          x: c ? g ? h : h - q : r,
          y: c ? d - r - u : g ? d - h - q : d - h,
          width: c ? q : u,
          height: c ? u : q
        };
      }
    };

    G.prototype.getStacks = function () {
      var d = this,
          g = d.inverted;
      d.yAxis.forEach(function (d) {
        d.stacks && d.hasVisibleSeries && (d.oldStacks = d.stacks);
      });
      d.series.forEach(function (t) {
        var h = t.xAxis && t.xAxis.options || {};
        !t.options.stacking || !0 !== t.visible && !1 !== d.options.chart.ignoreHiddenSeries || (t.stackKey = [t.type, A(t.options.stack, ""), g ? h.top : h.left, g ? h.height : h.width].join());
      });
    };

    g.prototype.buildStacks = function () {
      var g = this.series,
          t = A(this.options.reversedStacks, !0),
          r = g.length,
          h;

      if (!this.isXAxis) {
        this.usePercentage = !1;

        for (h = r; h--;) {
          var u = g[t ? h : r - h - 1];
          u.setStackedPoints();
        }

        for (h = 0; h < r; h++) g[h].modifyStacks();

        d.fireEvent(this, "afterBuildStacks");
      }
    };

    g.prototype.renderStackTotals = function () {
      var d = this.chart,
          g = d.renderer,
          r = this.stacks,
          h = this.stackTotalGroup;
      h || (this.stackTotalGroup = h = g.g("stack-labels").attr({
        visibility: "visible",
        zIndex: 6
      }).add());
      h.translate(d.plotLeft, d.plotTop);
      E(r, function (d) {
        E(d, function (d) {
          d.render(h);
        });
      });
    };

    g.prototype.resetStacks = function () {
      var d = this,
          g = d.stacks;
      d.isXAxis || E(g, function (g) {
        E(g, function (h, t) {
          h.touched < d.stacksTouched ? (h.destroy(), delete g[t]) : (h.total = null, h.cumulative = null);
        });
      });
    };

    g.prototype.cleanStacks = function () {
      if (!this.isXAxis) {
        if (this.oldStacks) var d = this.stacks = this.oldStacks;
        E(d, function (d) {
          E(d, function (d) {
            d.cumulative = d.total;
          });
        });
      }
    };

    J.prototype.setStackedPoints = function () {
      if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
        var g = this.processedXData,
            t = this.processedYData,
            D = [],
            h = t.length,
            N = this.options,
            q = N.threshold,
            G = A(N.startFromThreshold && q, 0),
            e = N.stack;
        N = N.stacking;
        var c = this.stackKey,
            k = "-" + c,
            n = this.negStacks,
            f = this.yAxis,
            a = f.stacks,
            l = f.oldStacks,
            v,
            z;
        f.stacksTouched += 1;

        for (z = 0; z < h; z++) {
          var w = g[z];
          var B = t[z];
          var L = this.getStackIndicator(L, w, this.index);
          var Q = L.key;
          var H = (v = n && B < (G ? 0 : q)) ? k : c;
          a[H] || (a[H] = {});
          a[H][w] || (l[H] && l[H][w] ? (a[H][w] = l[H][w], a[H][w].total = null) : a[H][w] = new d.StackItem(f, f.options.stackLabels, v, w, e));
          H = a[H][w];
          null !== B ? (H.points[Q] = H.points[this.index] = [A(H.cumulative, G)], u(H.cumulative) || (H.base = Q), H.touched = f.stacksTouched, 0 < L.index && !1 === this.singleStacks && (H.points[Q][0] = H.points[this.index + "," + w + ",0"][0])) : H.points[Q] = H.points[this.index] = null;
          "percent" === N ? (v = v ? c : k, n && a[v] && a[v][w] ? (v = a[v][w], H.total = v.total = Math.max(v.total, H.total) + Math.abs(B) || 0) : H.total = r(H.total + (Math.abs(B) || 0))) : H.total = r(H.total + (B || 0));
          H.cumulative = A(H.cumulative, G) + (B || 0);
          null !== B && (H.points[Q].push(H.cumulative), D[z] = H.cumulative);
        }

        "percent" === N && (f.usePercentage = !0);
        this.stackedYData = D;
        f.oldStacks = {};
      }
    };

    J.prototype.modifyStacks = function () {
      var d = this,
          g = d.stackKey,
          r = d.yAxis.stacks,
          h = d.processedXData,
          u,
          q = d.options.stacking;
      d[q + "Stacker"] && [g, "-" + g].forEach(function (g) {
        for (var e = h.length, c, k; e--;) if (c = h[e], u = d.getStackIndicator(u, c, d.index, g), k = (c = r[g] && r[g][c]) && c.points[u.key]) d[q + "Stacker"](k, c, e);
      });
    };

    J.prototype.percentStacker = function (d, g, u) {
      g = g.total ? 100 / g.total : 0;
      d[0] = r(d[0] * g);
      d[1] = r(d[1] * g);
      this.stackedYData[u] = d[1];
    };

    J.prototype.getStackIndicator = function (d, g, r, h) {
      !u(d) || d.x !== g || h && d.key !== h ? d = {
        x: g,
        index: 0,
        key: h
      } : d.index++;
      d.key = [r, g, d.index].join();
      return d;
    };
  });
  S(r, "parts/Dynamics.js", [r["parts/Globals.js"], r["parts/Point.js"], r["parts/Time.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    var I = u.addEvent,
        M = u.animate,
        E = u.createElement,
        A = u.css,
        G = u.defined,
        J = u.erase,
        y = u.error,
        t = u.extend,
        D = u.fireEvent,
        h = u.isArray,
        N = u.isNumber,
        q = u.isObject,
        P = u.isString,
        e = u.merge,
        c = u.objectEach,
        k = u.pick,
        n = u.relativeLength,
        f = u.setAnimation,
        a = u.splat,
        l = d.Axis;
    u = d.Chart;
    var v = d.Series,
        z = d.seriesTypes;

    d.cleanRecursively = function (a, e) {
      var f = {};
      c(a, function (c, k) {
        if (q(a[k], !0) && !a.nodeType && e[k]) c = d.cleanRecursively(a[k], e[k]), Object.keys(c).length && (f[k] = c);else if (q(a[k]) || a[k] !== e[k]) f[k] = a[k];
      });
      return f;
    };

    t(u.prototype, {
      addSeries: function (a, c, e) {
        var f,
            d = this;
        a && (c = k(c, !0), D(d, "addSeries", {
          options: a
        }, function () {
          f = d.initSeries(a);
          d.isDirtyLegend = !0;
          d.linkSeries();
          f.enabledDataSorting && f.setData(a.data, !1);
          D(d, "afterAddSeries", {
            series: f
          });
          c && d.redraw(e);
        }));
        return f;
      },
      addAxis: function (a, c, e, f) {
        return this.createAxis(c ? "xAxis" : "yAxis", {
          axis: a,
          redraw: e,
          animation: f
        });
      },
      addColorAxis: function (a, c, e) {
        return this.createAxis("colorAxis", {
          axis: a,
          redraw: c,
          animation: e
        });
      },
      createAxis: function (c, f) {
        var h = this.options,
            g = "colorAxis" === c,
            n = f.redraw,
            w = f.animation;
        f = e(f.axis, {
          index: this[c].length,
          isX: "xAxis" === c
        });
        var p = g ? new d.ColorAxis(this, f) : new l(this, f);
        h[c] = a(h[c] || {});
        h[c].push(f);
        g && (this.isDirtyLegend = !0, this.axes.forEach(function (a) {
          a.series = [];
        }), this.series.forEach(function (a) {
          a.bindAxes();
          a.isDirtyData = !0;
        }));
        k(n, !0) && this.redraw(w);
        return p;
      },
      showLoading: function (a) {
        var c = this,
            e = c.options,
            f = c.loadingDiv,
            d = e.loading,
            h = function () {
          f && A(f, {
            left: c.plotLeft + "px",
            top: c.plotTop + "px",
            width: c.plotWidth + "px",
            height: c.plotHeight + "px"
          });
        };

        f || (c.loadingDiv = f = E("div", {
          className: "highcharts-loading highcharts-loading-hidden"
        }, null, c.container), c.loadingSpan = E("span", {
          className: "highcharts-loading-inner"
        }, null, f), I(c, "redraw", h));
        f.className = "highcharts-loading";
        c.loadingSpan.innerHTML = k(a, e.lang.loading, "");
        c.styledMode || (A(f, t(d.style, {
          zIndex: 10
        })), A(c.loadingSpan, d.labelStyle), c.loadingShown || (A(f, {
          opacity: 0,
          display: ""
        }), M(f, {
          opacity: d.style.opacity || .5
        }, {
          duration: d.showDuration || 0
        })));
        c.loadingShown = !0;
        h();
      },
      hideLoading: function () {
        var a = this.options,
            c = this.loadingDiv;
        c && (c.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || M(c, {
          opacity: 0
        }, {
          duration: a.loading.hideDuration || 100,
          complete: function () {
            A(c, {
              display: "none"
            });
          }
        }));
        this.loadingShown = !1;
      },
      propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
      propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
      propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" "),
      collectionsWithUpdate: ["xAxis", "yAxis", "zAxis", "series"],
      update: function (f, h, l, g) {
        var v = this,
            w = {
          credits: "addCredits",
          title: "setTitle",
          subtitle: "setSubtitle",
          caption: "setCaption"
        },
            p,
            b,
            q,
            t = f.isResponsiveOptions,
            z = [];
        D(v, "update", {
          options: f
        });
        t || v.setResponsive(!1, !0);
        f = d.cleanRecursively(f, v.options);
        e(!0, v.userOptions, f);

        if (p = f.chart) {
          e(!0, v.options.chart, p);
          "className" in p && v.setClassName(p.className);
          "reflow" in p && v.setReflow(p.reflow);

          if ("inverted" in p || "polar" in p || "type" in p) {
            v.propFromSeries();
            var B = !0;
          }

          "alignTicks" in p && (B = !0);
          c(p, function (a, c) {
            -1 !== v.propsRequireUpdateSeries.indexOf("chart." + c) && (b = !0);
            -1 !== v.propsRequireDirtyBox.indexOf(c) && (v.isDirtyBox = !0);
            t || -1 === v.propsRequireReflow.indexOf(c) || (q = !0);
          });
          !v.styledMode && "style" in p && v.renderer.setStyle(p.style);
        }

        !v.styledMode && f.colors && (this.options.colors = f.colors);
        f.plotOptions && e(!0, this.options.plotOptions, f.plotOptions);
        f.time && this.time === d.time && (this.time = new r(f.time));
        c(f, function (a, c) {
          if (v[c] && "function" === typeof v[c].update) v[c].update(a, !1);else if ("function" === typeof v[w[c]]) v[w[c]](a);
          "chart" !== c && -1 !== v.propsRequireUpdateSeries.indexOf(c) && (b = !0);
        });
        this.collectionsWithUpdate.forEach(function (b) {
          if (f[b]) {
            if ("series" === b) {
              var c = [];
              v[b].forEach(function (a, b) {
                a.options.isInternal || c.push(k(a.options.index, b));
              });
            }

            a(f[b]).forEach(function (a, e) {
              (e = G(a.id) && v.get(a.id) || v[b][c ? c[e] : e]) && e.coll === b && (e.update(a, !1), l && (e.touched = !0));
              !e && l && v.collectionsWithInit[b] && (v.collectionsWithInit[b][0].apply(v, [a].concat(v.collectionsWithInit[b][1] || []).concat([!1])).touched = !0);
            });
            l && v[b].forEach(function (a) {
              a.touched || a.options.isInternal ? delete a.touched : z.push(a);
            });
          }
        });
        z.forEach(function (a) {
          a.remove && a.remove(!1);
        });
        B && v.axes.forEach(function (a) {
          a.update({}, !1);
        });
        b && v.getSeriesOrderByLinks().forEach(function (a) {
          a.chart && a.update({}, !1);
        }, this);
        f.loading && e(!0, v.options.loading, f.loading);
        B = p && p.width;
        p = p && p.height;
        P(p) && (p = n(p, B || v.chartWidth));
        q || N(B) && B !== v.chartWidth || N(p) && p !== v.chartHeight ? v.setSize(B, p, g) : k(h, !0) && v.redraw(g);
        D(v, "afterUpdate", {
          options: f,
          redraw: h,
          animation: g
        });
      },
      setSubtitle: function (a, c) {
        this.applyDescription("subtitle", a);
        this.layOutTitles(c);
      },
      setCaption: function (a, c) {
        this.applyDescription("caption", a);
        this.layOutTitles(c);
      }
    });
    u.prototype.collectionsWithInit = {
      xAxis: [u.prototype.addAxis, [!0]],
      yAxis: [u.prototype.addAxis, [!1]],
      series: [u.prototype.addSeries]
    };
    t(g.prototype, {
      update: function (a, c, e, f) {
        function d() {
          h.applyOptions(a);
          var f = b && h.hasDummyGraphic;
          f = null === h.y ? !f : f;
          b && f && (h.graphic = b.destroy(), delete h.hasDummyGraphic);
          q(a, !0) && (b && b.element && a && a.marker && "undefined" !== typeof a.marker.symbol && (h.graphic = b.destroy()), a && a.dataLabels && h.dataLabel && (h.dataLabel = h.dataLabel.destroy()), h.connector && (h.connector = h.connector.destroy()));
          g = h.index;
          l.updateParallelArrays(h, g);
          v.data[g] = q(v.data[g], !0) || q(a, !0) ? h.options : k(a, v.data[g]);
          l.isDirty = l.isDirtyData = !0;
          !l.fixedBox && l.hasCartesianSeries && (n.isDirtyBox = !0);
          "point" === v.legendType && (n.isDirtyLegend = !0);
          c && n.redraw(e);
        }

        var h = this,
            l = h.series,
            b = h.graphic,
            g,
            n = l.chart,
            v = l.options;
        c = k(c, !0);
        !1 === f ? d() : h.firePointEvent("update", {
          options: a
        }, d);
      },
      remove: function (a, c) {
        this.series.removePoint(this.series.data.indexOf(this), a, c);
      }
    });
    t(v.prototype, {
      addPoint: function (a, c, e, f, d) {
        var h = this.options,
            l = this.data,
            b = this.chart,
            g = this.xAxis;
        g = g && g.hasNames && g.names;
        var n = h.data,
            v = this.xData,
            q;
        c = k(c, !0);
        var w = {
          series: this
        };
        this.pointClass.prototype.applyOptions.apply(w, [a]);
        var t = w.x;
        var m = v.length;
        if (this.requireSorting && t < v[m - 1]) for (q = !0; m && v[m - 1] > t;) m--;
        this.updateParallelArrays(w, "splice", m, 0, 0);
        this.updateParallelArrays(w, m);
        g && w.name && (g[t] = w.name);
        n.splice(m, 0, a);
        q && (this.data.splice(m, 0, null), this.processData());
        "point" === h.legendType && this.generatePoints();
        e && (l[0] && l[0].remove ? l[0].remove(!1) : (l.shift(), this.updateParallelArrays(w, "shift"), n.shift()));
        !1 !== d && D(this, "addPoint", {
          point: w
        });
        this.isDirtyData = this.isDirty = !0;
        c && b.redraw(f);
      },
      removePoint: function (a, c, e) {
        var d = this,
            h = d.data,
            l = h[a],
            g = d.points,
            b = d.chart,
            n = function () {
          g && g.length === h.length && g.splice(a, 1);
          h.splice(a, 1);
          d.options.data.splice(a, 1);
          d.updateParallelArrays(l || {
            series: d
          }, "splice", a, 1);
          l && l.destroy();
          d.isDirty = !0;
          d.isDirtyData = !0;
          c && b.redraw();
        };

        f(e, b);
        c = k(c, !0);
        l ? l.firePointEvent("remove", null, n) : n();
      },
      remove: function (a, c, e, f) {
        function d() {
          h.destroy(f);
          h.remove = null;
          l.isDirtyLegend = l.isDirtyBox = !0;
          l.linkSeries();
          k(a, !0) && l.redraw(c);
        }

        var h = this,
            l = h.chart;
        !1 !== e ? D(h, "remove", null, d) : d();
      },
      update: function (a, c) {
        a = d.cleanRecursively(a, this.userOptions);
        D(this, "update", {
          options: a
        });
        var f = this,
            h = f.chart,
            l = f.userOptions,
            g = f.initialType || f.type,
            n = a.type || l.type || h.options.chart.type,
            b = !(this.hasDerivedData || a.dataGrouping || n && n !== this.type || "undefined" !== typeof a.pointStart || a.pointInterval || a.pointIntervalUnit || a.keys),
            v = z[g].prototype,
            q,
            w = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"],
            r = ["eventOptions", "navigatorSeries", "baseSeries"],
            B = f.finishedAnimating && {
          animation: !1
        },
            u = {};
        b && (r.push("data", "isDirtyData", "points", "processedXData", "processedYData", "xIncrement", "_hasPointMarkers", "_hasPointLabels", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== a.visible && r.push("area", "graph"), f.parallelArrays.forEach(function (a) {
          r.push(a + "Data");
        }), a.data && (a.dataSorting && t(f.options.dataSorting, a.dataSorting), this.setData(a.data, !1)));
        a = e(l, B, {
          index: "undefined" === typeof l.index ? f.index : l.index,
          pointStart: k(l.pointStart, f.xData[0])
        }, !b && {
          data: f.options.data
        }, a);
        b && a.data && (a.data = f.options.data);
        r = w.concat(r);
        r.forEach(function (a) {
          r[a] = f[a];
          delete f[a];
        });
        f.remove(!1, null, !1, !0);

        for (q in v) f[q] = void 0;

        z[n || g] ? t(f, z[n || g].prototype) : y(17, !0, h, {
          missingModuleFor: n || g
        });
        r.forEach(function (a) {
          f[a] = r[a];
        });
        f.init(h, a);

        if (b && this.points) {
          var m = f.options;
          !1 === m.visible ? (u.graphic = 1, u.dataLabel = 1) : f._hasPointLabels || (n = m.marker, v = m.dataLabels, n && (!1 === n.enabled || "symbol" in n) && (u.graphic = 1), v && !1 === v.enabled && (u.dataLabel = 1));
          this.points.forEach(function (a) {
            a && a.series && (a.resolveColor(), Object.keys(u).length && a.destroyElements(u), !1 === m.showInLegend && a.legendItem && h.legend.destroyItem(a));
          }, this);
        }

        a.zIndex !== l.zIndex && w.forEach(function (b) {
          f[b] && f[b].attr({
            zIndex: a.zIndex
          });
        });
        f.initialType = g;
        h.linkSeries();
        D(this, "afterUpdate");
        k(c, !0) && h.redraw(b ? void 0 : !1);
      },
      setName: function (a) {
        this.name = this.options.name = this.userOptions.name = a;
        this.chart.isDirtyLegend = !0;
      }
    });
    t(l.prototype, {
      update: function (a, f) {
        var d = this.chart,
            h = a && a.events || {};
        a = e(this.userOptions, a);
        d.options[this.coll].indexOf && (d.options[this.coll][d.options[this.coll].indexOf(this.userOptions)] = a);
        c(d.options[this.coll].events, function (a, c) {
          "undefined" === typeof h[c] && (h[c] = void 0);
        });
        this.destroy(!0);
        this.init(d, t(a, {
          events: h
        }));
        d.isDirtyBox = !0;
        k(f, !0) && d.redraw();
      },
      remove: function (a) {
        for (var c = this.chart, e = this.coll, f = this.series, d = f.length; d--;) f[d] && f[d].remove(!1);

        J(c.axes, this);
        J(c[e], this);
        h(c.options[e]) ? c.options[e].splice(this.options.index, 1) : delete c.options[e];
        c[e].forEach(function (a, c) {
          a.options.index = a.userOptions.index = c;
        });
        this.destroy();
        c.isDirtyBox = !0;
        k(a, !0) && c.redraw();
      },
      setTitle: function (a, c) {
        this.update({
          title: a
        }, c);
      },
      setCategories: function (a, c) {
        this.update({
          categories: a
        }, c);
      }
    });
  });
  S(r, "parts/AreaSeries.js", [r["parts/Globals.js"], r["parts/Color.js"], r["mixins/legend-symbol.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    var I = g.parse,
        M = u.objectEach,
        E = u.pick;
    g = u.seriesType;
    var A = d.Series;
    g("area", "line", {
      softThreshold: !1,
      threshold: 0
    }, {
      singleStacks: !1,
      getStackPoints: function (d) {
        var g = [],
            r = [],
            t = this.xAxis,
            u = this.yAxis,
            h = u.stacks[this.stackKey],
            A = {},
            q = this.index,
            G = u.series,
            e = G.length,
            c = E(u.options.reversedStacks, !0) ? 1 : -1,
            k;
        d = d || this.points;

        if (this.options.stacking) {
          for (k = 0; k < d.length; k++) d[k].leftNull = d[k].rightNull = void 0, A[d[k].x] = d[k];

          M(h, function (c, a) {
            null !== c.total && r.push(a);
          });
          r.sort(function (c, a) {
            return c - a;
          });
          var n = G.map(function (c) {
            return c.visible;
          });
          r.forEach(function (f, a) {
            var d = 0,
                v,
                z;
            if (A[f] && !A[f].isNull) g.push(A[f]), [-1, 1].forEach(function (d) {
              var l = 1 === d ? "rightNull" : "leftNull",
                  g = 0,
                  w = h[r[a + d]];
              if (w) for (k = q; 0 <= k && k < e;) v = w.points[k], v || (k === q ? A[f][l] = !0 : n[k] && (z = h[f].points[k]) && (g -= z[1] - z[0])), k += c;
              A[f][1 === d ? "rightCliff" : "leftCliff"] = g;
            });else {
              for (k = q; 0 <= k && k < e;) {
                if (v = h[f].points[k]) {
                  d = v[1];
                  break;
                }

                k += c;
              }

              d = u.translate(d, 0, 1, 0, 1);
              g.push({
                isNull: !0,
                plotX: t.translate(f, 0, 0, 0, 1),
                x: f,
                plotY: d,
                yBottom: d
              });
            }
          });
        }

        return g;
      },
      getGraphPath: function (d) {
        var g = A.prototype.getGraphPath,
            r = this.options,
            t = r.stacking,
            u = this.yAxis,
            h,
            N = [],
            q = [],
            G = this.index,
            e = u.stacks[this.stackKey],
            c = r.threshold,
            k = Math.round(u.getThreshold(r.threshold));
        r = E(r.connectNulls, "percent" === t);

        var n = function (f, h, l) {
          var g = d[f];
          f = t && e[g.x].points[G];
          var n = g[l + "Null"] || 0;
          l = g[l + "Cliff"] || 0;
          g = !0;

          if (l || n) {
            var v = (n ? f[0] : f[1]) + l;
            var w = f[0] + l;
            g = !!n;
          } else !t && d[h] && d[h].isNull && (v = w = c);

          "undefined" !== typeof v && (q.push({
            plotX: a,
            plotY: null === v ? k : u.getThreshold(v),
            isNull: g,
            isCliff: !0
          }), N.push({
            plotX: a,
            plotY: null === w ? k : u.getThreshold(w),
            doCurve: !1
          }));
        };

        d = d || this.points;
        t && (d = this.getStackPoints(d));

        for (h = 0; h < d.length; h++) {
          t || (d[h].leftCliff = d[h].rightCliff = d[h].leftNull = d[h].rightNull = void 0);
          var f = d[h].isNull;
          var a = E(d[h].rectPlotX, d[h].plotX);
          var l = E(d[h].yBottom, k);
          if (!f || r) r || n(h, h - 1, "left"), f && !t && r || (q.push(d[h]), N.push({
            x: h,
            plotX: a,
            plotY: l
          })), r || n(h, h + 1, "right");
        }

        h = g.call(this, q, !0, !0);
        N.reversed = !0;
        f = g.call(this, N, !0, !0);
        f.length && (f[0] = "L");
        f = h.concat(f);
        g = g.call(this, q, !1, r);
        f.xMap = h.xMap;
        this.areaPath = f;
        return g;
      },
      drawGraph: function () {
        this.areaPath = [];
        A.prototype.drawGraph.apply(this);
        var d = this,
            g = this.areaPath,
            r = this.options,
            t = [["area", "highcharts-area", this.color, r.fillColor]];
        this.zones.forEach(function (g, h) {
          t.push(["zone-area-" + h, "highcharts-area highcharts-zone-area-" + h + " " + g.className, g.color || d.color, g.fillColor || r.fillColor]);
        });
        t.forEach(function (t) {
          var h = t[0],
              u = d[h],
              q = u ? "animate" : "attr",
              y = {};
          u ? (u.endX = d.preventGraphAnimation ? null : g.xMap, u.animate({
            d: g
          })) : (y.zIndex = 0, u = d[h] = d.chart.renderer.path(g).addClass(t[1]).add(d.group), u.isArea = !0);
          d.chart.styledMode || (y.fill = E(t[3], I(t[2]).setOpacity(E(r.fillOpacity, .75)).get()));
          u[q](y);
          u.startX = g.xMap;
          u.shiftUnit = r.step ? 2 : 1;
        });
      },
      drawLegendSymbol: r.drawRectangle
    });
    "";
  });
  S(r, "parts/SplineSeries.js", [r["parts/Utilities.js"]], function (d) {
    var g = d.pick;
    d = d.seriesType;
    d("spline", "line", {}, {
      getPointSpline: function (d, r, I) {
        var u = r.plotX,
            E = r.plotY,
            A = d[I - 1];
        I = d[I + 1];

        if (A && !A.isNull && !1 !== A.doCurve && !r.isCliff && I && !I.isNull && !1 !== I.doCurve && !r.isCliff) {
          d = A.plotY;
          var G = I.plotX;
          I = I.plotY;
          var J = 0;
          var y = (1.5 * u + A.plotX) / 2.5;
          var t = (1.5 * E + d) / 2.5;
          G = (1.5 * u + G) / 2.5;
          var D = (1.5 * E + I) / 2.5;
          G !== y && (J = (D - t) * (G - u) / (G - y) + E - D);
          t += J;
          D += J;
          t > d && t > E ? (t = Math.max(d, E), D = 2 * E - t) : t < d && t < E && (t = Math.min(d, E), D = 2 * E - t);
          D > I && D > E ? (D = Math.max(I, E), t = 2 * E - D) : D < I && D < E && (D = Math.min(I, E), t = 2 * E - D);
          r.rightContX = G;
          r.rightContY = D;
        }

        r = ["C", g(A.rightContX, A.plotX), g(A.rightContY, A.plotY), g(y, u), g(t, E), u, E];
        A.rightContX = A.rightContY = null;
        return r;
      }
    });
    "";
  });
  S(r, "parts/AreaSplineSeries.js", [r["parts/Globals.js"], r["mixins/legend-symbol.js"], r["parts/Utilities.js"]], function (d, g, r) {
    r = r.seriesType;
    var u = d.seriesTypes.area.prototype;
    r("areaspline", "spline", d.defaultPlotOptions.area, {
      getStackPoints: u.getStackPoints,
      getGraphPath: u.getGraphPath,
      drawGraph: u.drawGraph,
      drawLegendSymbol: g.drawRectangle
    });
    "";
  });
  S(r, "parts/ColumnSeries.js", [r["parts/Globals.js"], r["parts/Color.js"], r["mixins/legend-symbol.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    "";

    var I = g.parse,
        M = u.animObject,
        E = u.clamp,
        A = u.defined,
        G = u.extend,
        J = u.isNumber,
        y = u.merge,
        t = u.pick;
    g = u.seriesType;
    var D = d.Series;
    g("column", "line", {
      borderRadius: 0,
      crisp: !0,
      groupPadding: .2,
      marker: null,
      pointPadding: .1,
      minPointLength: 0,
      cropThreshold: 50,
      pointRange: null,
      states: {
        hover: {
          halo: !1,
          brightness: .1
        },
        select: {
          color: "#cccccc",
          borderColor: "#000000"
        }
      },
      dataLabels: {
        align: null,
        verticalAlign: null,
        y: null
      },
      softThreshold: !1,
      startFromThreshold: !0,
      stickyTracking: !1,
      tooltip: {
        distance: 6
      },
      threshold: 0,
      borderColor: "#ffffff"
    }, {
      cropShoulder: 0,
      directTouch: !0,
      trackerGroups: ["group", "dataLabelsGroup"],
      negStacks: !0,
      init: function () {
        D.prototype.init.apply(this, arguments);
        var d = this,
            g = d.chart;
        g.hasRendered && g.series.forEach(function (h) {
          h.type === d.type && (h.isDirty = !0);
        });
      },
      getColumnMetrics: function () {
        var d = this,
            g = d.options,
            q = d.xAxis,
            r = d.yAxis,
            e = q.options.reversedStacks;
        e = q.reversed && !e || !q.reversed && e;
        var c,
            k = {},
            n = 0;
        !1 === g.grouping ? n = 1 : d.chart.series.forEach(function (a) {
          var e = a.yAxis,
              f = a.options;

          if (a.type === d.type && (a.visible || !d.chart.options.chart.ignoreHiddenSeries) && r.len === e.len && r.pos === e.pos) {
            if (f.stacking) {
              c = a.stackKey;
              "undefined" === typeof k[c] && (k[c] = n++);
              var h = k[c];
            } else !1 !== f.grouping && (h = n++);

            a.columnIndex = h;
          }
        });
        var f = Math.min(Math.abs(q.transA) * (q.ordinalSlope || g.pointRange || q.closestPointRange || q.tickInterval || 1), q.len),
            a = f * g.groupPadding,
            l = (f - 2 * a) / (n || 1);
        g = Math.min(g.maxPointWidth || q.len, t(g.pointWidth, l * (1 - 2 * g.pointPadding)));
        d.columnMetrics = {
          width: g,
          offset: (l - g) / 2 + (a + ((d.columnIndex || 0) + (e ? 1 : 0)) * l - f / 2) * (e ? -1 : 1)
        };
        return d.columnMetrics;
      },
      crispCol: function (d, g, q, t) {
        var e = this.chart,
            c = this.borderWidth,
            k = -(c % 2 ? .5 : 0);
        c = c % 2 ? .5 : 1;
        e.inverted && e.renderer.isVML && (c += 1);
        this.options.crisp && (q = Math.round(d + q) + k, d = Math.round(d) + k, q -= d);
        t = Math.round(g + t) + c;
        k = .5 >= Math.abs(g) && .5 < t;
        g = Math.round(g) + c;
        t -= g;
        k && t && (--g, t += 1);
        return {
          x: d,
          y: g,
          width: q,
          height: t
        };
      },
      translate: function () {
        var d = this,
            g = d.chart,
            q = d.options,
            r = d.dense = 2 > d.closestPointRange * d.xAxis.transA;
        r = d.borderWidth = t(q.borderWidth, r ? 0 : 1);
        var e = d.xAxis,
            c = d.yAxis,
            k = q.threshold,
            n = d.translatedThreshold = c.getThreshold(k),
            f = t(q.minPointLength, 5),
            a = d.getColumnMetrics(),
            l = a.width,
            v = d.barW = Math.max(l, 1 + 2 * r),
            z = d.pointXOffset = a.offset,
            w = d.dataMin,
            u = d.dataMax;
        g.inverted && (n -= .5);
        q.pointPadding && (v = Math.ceil(v));
        D.prototype.translate.apply(d);
        d.points.forEach(function (a) {
          var h = t(a.yBottom, n),
              q = 999 + Math.abs(h),
              r = l,
              p = a.plotX;
          q = E(a.plotY, -q, c.len + q);
          var b = a.plotX + z,
              B = v,
              x = Math.min(q, h),
              y = Math.max(q, h) - x;

          if (f && Math.abs(y) < f) {
            y = f;
            var L = !c.reversed && !a.negative || c.reversed && a.negative;
            a.y === k && d.dataMax <= k && c.min < k && w !== u && (L = !L);
            x = Math.abs(x - n) > f ? h - f : n - (L ? f : 0);
          }

          A(a.options.pointWidth) && (r = B = Math.ceil(a.options.pointWidth), b -= Math.round((r - l) / 2));
          a.barX = b;
          a.pointWidth = r;
          a.tooltipPos = g.inverted ? [c.len + c.pos - g.plotLeft - q, e.len + e.pos - g.plotTop - (p || 0) - z - B / 2, y] : [b + B / 2, q + c.pos - g.plotTop, y];
          a.shapeType = d.pointClass.prototype.shapeType || "rect";
          a.shapeArgs = d.crispCol.apply(d, a.isNull ? [b, n, B, 0] : [b, x, B, y]);
        });
      },
      getSymbol: d.noop,
      drawLegendSymbol: r.drawRectangle,
      drawGraph: function () {
        this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
      },
      pointAttribs: function (d, g) {
        var h = this.options,
            r = this.pointAttrToOptions || {};
        var e = r.stroke || "borderColor";
        var c = r["stroke-width"] || "borderWidth",
            k = d && d.color || this.color,
            n = d && d[e] || h[e] || this.color || k,
            f = d && d[c] || h[c] || this[c] || 0;
        r = d && d.options.dashStyle || h.dashStyle;
        var a = t(d && d.opacity, h.opacity, 1);

        if (d && this.zones.length) {
          var l = d.getZone();
          k = d.options.color || l && (l.color || d.nonZonedColor) || this.color;
          l && (n = l.borderColor || n, r = l.dashStyle || r, f = l.borderWidth || f);
        }

        g && d && (d = y(h.states[g], d.options.states && d.options.states[g] || {}), g = d.brightness, k = d.color || "undefined" !== typeof g && I(k).brighten(d.brightness).get() || k, n = d[e] || n, f = d[c] || f, r = d.dashStyle || r, a = t(d.opacity, a));
        e = {
          fill: k,
          stroke: n,
          "stroke-width": f,
          opacity: a
        };
        r && (e.dashstyle = r);
        return e;
      },
      drawPoints: function () {
        var d = this,
            g = this.chart,
            q = d.options,
            t = g.renderer,
            e = q.animationLimit || 250,
            c;
        d.points.forEach(function (k) {
          var h = k.graphic,
              f = !!h,
              a = h && g.pointCount < e ? "animate" : "attr";

          if (J(k.plotY) && null !== k.y) {
            c = k.shapeArgs;
            h && k.hasNewShapeType() && (h = h.destroy());
            d.enabledDataSorting && (k.startXPos = d.xAxis.reversed ? -(c ? c.width : 0) : d.xAxis.width);
            h || (k.graphic = h = t[k.shapeType](c).add(k.group || d.group)) && d.enabledDataSorting && g.hasRendered && g.pointCount < e && (h.attr({
              x: k.startXPos
            }), f = !0, a = "animate");
            if (h && f) h[a](y(c));
            if (q.borderRadius) h[a]({
              r: q.borderRadius
            });
            g.styledMode || h[a](d.pointAttribs(k, k.selected && "select")).shadow(!1 !== k.allowShadow && q.shadow, null, q.stacking && !q.borderRadius);
            h.addClass(k.getClassName(), !0);
          } else h && (k.graphic = h.destroy());
        });
      },
      animate: function (d) {
        var h = this,
            g = this.yAxis,
            t = h.options,
            e = this.chart.inverted,
            c = {},
            k = e ? "translateX" : "translateY";
        if (d) c.scaleY = .001, d = E(g.toPixels(t.threshold), g.pos, g.pos + g.len), e ? c.translateX = d - g.len : c.translateY = d, h.clipBox && h.setClip(), h.group.attr(c);else {
          var n = h.group.attr(k);
          h.group.animate({
            scaleY: 1
          }, G(M(h.options.animation), {
            step: function (e, a) {
              h.group && (c[k] = n + a.pos * (g.pos - n), h.group.attr(c));
            }
          }));
        }
      },
      remove: function () {
        var d = this,
            g = d.chart;
        g.hasRendered && g.series.forEach(function (h) {
          h.type === d.type && (h.isDirty = !0);
        });
        D.prototype.remove.apply(d, arguments);
      }
    });
    "";
  });
  S(r, "parts/BarSeries.js", [r["parts/Utilities.js"]], function (d) {
    d = d.seriesType;
    d("bar", "column", null, {
      inverted: !0
    });
    "";
  });
  S(r, "parts/ScatterSeries.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.addEvent;
    g = g.seriesType;
    var u = d.Series;
    g("scatter", "line", {
      lineWidth: 0,
      findNearestPointBy: "xy",
      jitter: {
        x: 0,
        y: 0
      },
      marker: {
        enabled: !0
      },
      tooltip: {
        headerFormat: '<span style="color:{point.color}">\u25cf</span> <span style="font-size: 10px"> {series.name}</span><br/>',
        pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
      }
    }, {
      sorted: !1,
      requireSorting: !1,
      noSharedTooltip: !0,
      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
      takeOrdinalPosition: !1,
      drawGraph: function () {
        this.options.lineWidth && u.prototype.drawGraph.call(this);
      },
      applyJitter: function () {
        var d = this,
            g = this.options.jitter,
            r = this.points.length;
        g && this.points.forEach(function (u, E) {
          ["x", "y"].forEach(function (A, y) {
            var t = "plot" + A.toUpperCase();

            if (g[A] && !u.isNull) {
              var D = d[A + "Axis"];
              var h = g[A] * D.transA;

              if (D && !D.isLog) {
                var G = Math.max(0, u[t] - h);
                D = Math.min(D.len, u[t] + h);
                y = 1E4 * Math.sin(E + y * r);
                u[t] = G + (D - G) * (y - Math.floor(y));
                "x" === A && (u.clientX = u.plotX);
              }
            }
          });
        });
      }
    });
    r(u, "afterTranslate", function () {
      this.applyJitter && this.applyJitter();
    });
    "";
  });
  S(r, "mixins/centered-series.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.isNumber,
        u = g.pick,
        I = g.relativeLength,
        M = d.deg2rad;
    d.CenteredSeriesMixin = {
      getCenter: function () {
        var d = this.options,
            g = this.chart,
            r = 2 * (d.slicedOffset || 0),
            J = g.plotWidth - 2 * r,
            y = g.plotHeight - 2 * r,
            t = d.center,
            D = Math.min(J, y),
            h = d.size,
            N = d.innerSize || 0;
        "string" === typeof h && (h = parseFloat(h));
        "string" === typeof N && (N = parseFloat(N));
        d = [u(t[0], "50%"), u(t[1], "50%"), u(h && 0 > h ? void 0 : d.size, "100%"), u(N && 0 > N ? void 0 : d.innerSize || 0, "0%")];
        g.angular && (d[3] = 0);

        for (t = 0; 4 > t; ++t) h = d[t], g = 2 > t || 2 === t && /%$/.test(h), d[t] = I(h, [J, y, D, d[2]][t]) + (g ? r : 0);

        d[3] > d[2] && (d[3] = d[2]);
        return d;
      },
      getStartAndEndRadians: function (d, g) {
        d = r(d) ? d : 0;
        g = r(g) && g > d && 360 > g - d ? g : d + 360;
        return {
          start: M * (d + -90),
          end: M * (g + -90)
        };
      }
    };
  });
  S(r, "parts/PieSeries.js", [r["parts/Globals.js"], r["mixins/legend-symbol.js"], r["parts/Point.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    var I = u.addEvent,
        M = u.clamp,
        E = u.defined,
        A = u.fireEvent,
        G = u.isNumber,
        J = u.merge,
        y = u.pick,
        t = u.relativeLength,
        D = u.seriesType,
        h = u.setAnimation;
    u = d.CenteredSeriesMixin;
    var N = u.getStartAndEndRadians,
        q = d.noop,
        P = d.Series;
    D("pie", "line", {
      center: [null, null],
      clip: !1,
      colorByPoint: !0,
      dataLabels: {
        allowOverlap: !0,
        connectorPadding: 5,
        connectorShape: "fixedOffset",
        crookDistance: "70%",
        distance: 30,
        enabled: !0,
        formatter: function () {
          return this.point.isNull ? void 0 : this.point.name;
        },
        softConnector: !0,
        x: 0
      },
      fillColor: void 0,
      ignoreHiddenPoint: !0,
      inactiveOtherPoints: !0,
      legendType: "point",
      marker: null,
      size: null,
      showInLegend: !1,
      slicedOffset: 10,
      stickyTracking: !1,
      tooltip: {
        followPointer: !0
      },
      borderColor: "#ffffff",
      borderWidth: 1,
      lineWidth: void 0,
      states: {
        hover: {
          brightness: .1
        }
      }
    }, {
      isCartesian: !1,
      requireSorting: !1,
      directTouch: !0,
      noSharedTooltip: !0,
      trackerGroups: ["group", "dataLabelsGroup"],
      axisTypes: [],
      pointAttribs: d.seriesTypes.column.prototype.pointAttribs,
      animate: function (e) {
        var c = this,
            d = c.points,
            g = c.startAngleRad;
        e || d.forEach(function (e) {
          var a = e.graphic,
              f = e.shapeArgs;
          a && f && (a.attr({
            r: y(e.startR, c.center && c.center[3] / 2),
            start: g,
            end: g
          }), a.animate({
            r: f.r,
            start: f.start,
            end: f.end
          }, c.options.animation));
        });
      },
      hasData: function () {
        return !!this.processedXData.length;
      },
      updateTotals: function () {
        var e,
            c = 0,
            d = this.points,
            g = d.length,
            f = this.options.ignoreHiddenPoint;

        for (e = 0; e < g; e++) {
          var a = d[e];
          c += f && !a.visible ? 0 : a.isNull ? 0 : a.y;
        }

        this.total = c;

        for (e = 0; e < g; e++) a = d[e], a.percentage = 0 < c && (a.visible || !f) ? a.y / c * 100 : 0, a.total = c;
      },
      generatePoints: function () {
        P.prototype.generatePoints.call(this);
        this.updateTotals();
      },
      getX: function (e, c, d) {
        var k = this.center,
            f = this.radii ? this.radii[d.index] : k[2] / 2;
        e = Math.asin(M((e - k[1]) / (f + d.labelDistance), -1, 1));
        return k[0] + (c ? -1 : 1) * Math.cos(e) * (f + d.labelDistance) + (0 < d.labelDistance ? (c ? -1 : 1) * this.options.dataLabels.padding : 0);
      },
      translate: function (e) {
        this.generatePoints();
        var c = 0,
            d = this.options,
            g = d.slicedOffset,
            f = g + (d.borderWidth || 0),
            a = N(d.startAngle, d.endAngle),
            h = this.startAngleRad = a.start;
        a = (this.endAngleRad = a.end) - h;
        var v = this.points,
            q = d.dataLabels.distance;
        d = d.ignoreHiddenPoint;
        var w,
            r = v.length;
        e || (this.center = e = this.getCenter());

        for (w = 0; w < r; w++) {
          var u = v[w];
          var D = h + c * a;
          if (!d || u.visible) c += u.percentage / 100;
          var H = h + c * a;
          u.shapeType = "arc";
          u.shapeArgs = {
            x: e[0],
            y: e[1],
            r: e[2] / 2,
            innerR: e[3] / 2,
            start: Math.round(1E3 * D) / 1E3,
            end: Math.round(1E3 * H) / 1E3
          };
          u.labelDistance = y(u.options.dataLabels && u.options.dataLabels.distance, q);
          u.labelDistance = t(u.labelDistance, u.shapeArgs.r);
          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, u.labelDistance);
          H = (H + D) / 2;
          H > 1.5 * Math.PI ? H -= 2 * Math.PI : H < -Math.PI / 2 && (H += 2 * Math.PI);
          u.slicedTranslation = {
            translateX: Math.round(Math.cos(H) * g),
            translateY: Math.round(Math.sin(H) * g)
          };
          var K = Math.cos(H) * e[2] / 2;
          var p = Math.sin(H) * e[2] / 2;
          u.tooltipPos = [e[0] + .7 * K, e[1] + .7 * p];
          u.half = H < -Math.PI / 2 || H > Math.PI / 2 ? 1 : 0;
          u.angle = H;
          D = Math.min(f, u.labelDistance / 5);
          u.labelPosition = {
            natural: {
              x: e[0] + K + Math.cos(H) * u.labelDistance,
              y: e[1] + p + Math.sin(H) * u.labelDistance
            },
            "final": {},
            alignment: 0 > u.labelDistance ? "center" : u.half ? "right" : "left",
            connectorPosition: {
              breakAt: {
                x: e[0] + K + Math.cos(H) * D,
                y: e[1] + p + Math.sin(H) * D
              },
              touchingSliceAt: {
                x: e[0] + K,
                y: e[1] + p
              }
            }
          };
        }

        A(this, "afterTranslate");
      },
      drawEmpty: function () {
        var e = this.options;

        if (0 === this.total) {
          var c = this.center[0];
          var d = this.center[1];
          this.graph || (this.graph = this.chart.renderer.circle(c, d, 0).addClass("highcharts-graph").add(this.group));
          this.graph.animate({
            "stroke-width": e.borderWidth,
            cx: c,
            cy: d,
            r: this.center[2] / 2,
            fill: e.fillColor || "none",
            stroke: e.color || "#cccccc"
          }, this.options.animation);
        } else this.graph && (this.graph = this.graph.destroy());
      },
      redrawPoints: function () {
        var e = this,
            c = e.chart,
            d = c.renderer,
            g,
            f,
            a,
            h,
            v = e.options.shadow;
        this.drawEmpty();
        !v || e.shadowGroup || c.styledMode || (e.shadowGroup = d.g("shadow").attr({
          zIndex: -1
        }).add(e.group));
        e.points.forEach(function (k) {
          var l = {};
          f = k.graphic;

          if (!k.isNull && f) {
            h = k.shapeArgs;
            g = k.getTranslate();

            if (!c.styledMode) {
              var n = k.shadowGroup;
              v && !n && (n = k.shadowGroup = d.g("shadow").add(e.shadowGroup));
              n && n.attr(g);
              a = e.pointAttribs(k, k.selected && "select");
            }

            k.delayedRendering ? (f.setRadialReference(e.center).attr(h).attr(g), c.styledMode || f.attr(a).attr({
              "stroke-linejoin": "round"
            }).shadow(v, n), k.delayedRendering = !1) : (f.setRadialReference(e.center), c.styledMode || J(!0, l, a), J(!0, l, h, g), f.animate(l));
            f.attr({
              visibility: k.visible ? "inherit" : "hidden"
            });
            f.addClass(k.getClassName());
          } else f && (k.graphic = f.destroy());
        });
      },
      drawPoints: function () {
        var e = this.chart.renderer;
        this.points.forEach(function (c) {
          c.graphic && c.hasNewShapeType() && (c.graphic = c.graphic.destroy());
          c.graphic || (c.graphic = e[c.shapeType](c.shapeArgs).add(c.series.group), c.delayedRendering = !0);
        });
      },
      searchPoint: q,
      sortByAngle: function (e, c) {
        e.sort(function (e, d) {
          return "undefined" !== typeof e.angle && (d.angle - e.angle) * c;
        });
      },
      drawLegendSymbol: g.drawRectangle,
      getCenter: u.getCenter,
      getSymbol: q,
      drawGraph: null
    }, {
      init: function () {
        r.prototype.init.apply(this, arguments);
        var e = this;
        e.name = y(e.name, "Slice");

        var c = function (c) {
          e.slice("select" === c.type);
        };

        I(e, "select", c);
        I(e, "unselect", c);
        return e;
      },
      isValid: function () {
        return G(this.y) && 0 <= this.y;
      },
      setVisible: function (e, c) {
        var d = this,
            g = d.series,
            f = g.chart,
            a = g.options.ignoreHiddenPoint;
        c = y(c, a);
        e !== d.visible && (d.visible = d.options.visible = e = "undefined" === typeof e ? !d.visible : e, g.options.data[g.data.indexOf(d)] = d.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (a) {
          if (d[a]) d[a][e ? "show" : "hide"](!0);
        }), d.legendItem && f.legend.colorizeItem(d, e), e || "hover" !== d.state || d.setState(""), a && (g.isDirty = !0), c && f.redraw());
      },
      slice: function (e, c, d) {
        var g = this.series;
        h(d, g.chart);
        y(c, !0);
        this.sliced = this.options.sliced = E(e) ? e : !this.sliced;
        g.options.data[g.data.indexOf(this)] = this.options;
        this.graphic.animate(this.getTranslate());
        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
      },
      getTranslate: function () {
        return this.sliced ? this.slicedTranslation : {
          translateX: 0,
          translateY: 0
        };
      },
      haloPath: function (e) {
        var c = this.shapeArgs;
        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + e, c.r + e, {
          innerR: c.r - 1,
          start: c.start,
          end: c.end
        });
      },
      connectorShapes: {
        fixedOffset: function (e, c, d) {
          var g = c.breakAt;
          c = c.touchingSliceAt;
          return ["M", e.x, e.y].concat(d.softConnector ? ["C", e.x + ("left" === e.alignment ? -5 : 5), e.y, 2 * g.x - c.x, 2 * g.y - c.y, g.x, g.y] : ["L", g.x, g.y]).concat(["L", c.x, c.y]);
        },
        straight: function (e, c) {
          c = c.touchingSliceAt;
          return ["M", e.x, e.y, "L", c.x, c.y];
        },
        crookedLine: function (e, c, d) {
          c = c.touchingSliceAt;
          var g = this.series,
              f = g.center[0],
              a = g.chart.plotWidth,
              k = g.chart.plotLeft;
          g = e.alignment;
          var h = this.shapeArgs.r;
          d = t(d.crookDistance, 1);
          d = "left" === g ? f + h + (a + k - f - h) * (1 - d) : k + (f - h) * d;
          f = ["L", d, e.y];
          if ("left" === g ? d > e.x || d < c.x : d < e.x || d > c.x) f = [];
          return ["M", e.x, e.y].concat(f).concat(["L", c.x, c.y]);
        }
      },
      getConnectorPath: function () {
        var e = this.labelPosition,
            c = this.series.options.dataLabels,
            d = c.connectorShape,
            g = this.connectorShapes;
        g[d] && (d = g[d]);
        return d.call(this, {
          x: e.final.x,
          y: e.final.y,
          alignment: e.alignment
        }, e.connectorPosition, c);
      }
    });
    "";
  });
  S(r, "parts/DataLabels.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.animObject,
        u = g.arrayMax,
        I = g.clamp,
        M = g.defined,
        E = g.extend,
        A = g.format,
        G = g.isArray,
        J = g.merge,
        y = g.objectEach,
        t = g.pick,
        D = g.relativeLength,
        h = g.splat,
        N = g.stableSort;
    g = d.noop;
    var q = d.Series,
        P = d.seriesTypes;

    d.distribute = function (e, c, g) {
      function h(a, c) {
        return a.target - c.target;
      }

      var f,
          a = !0,
          k = e,
          v = [];
      var q = 0;
      var w = k.reducedLen || c;

      for (f = e.length; f--;) q += e[f].size;

      if (q > w) {
        N(e, function (a, c) {
          return (c.rank || 0) - (a.rank || 0);
        });

        for (q = f = 0; q <= w;) q += e[f].size, f++;

        v = e.splice(f - 1, e.length);
      }

      N(e, h);

      for (e = e.map(function (a) {
        return {
          size: a.size,
          targets: [a.target],
          align: t(a.align, .5)
        };
      }); a;) {
        for (f = e.length; f--;) a = e[f], q = (Math.min.apply(0, a.targets) + Math.max.apply(0, a.targets)) / 2, a.pos = I(q - a.size * a.align, 0, c - a.size);

        f = e.length;

        for (a = !1; f--;) 0 < f && e[f - 1].pos + e[f - 1].size > e[f].pos && (e[f - 1].size += e[f].size, e[f - 1].targets = e[f - 1].targets.concat(e[f].targets), e[f - 1].align = .5, e[f - 1].pos + e[f - 1].size > c && (e[f - 1].pos = c - e[f - 1].size), e.splice(f, 1), a = !0);
      }

      k.push.apply(k, v);
      f = 0;
      e.some(function (a) {
        var e = 0;
        if (a.targets.some(function () {
          k[f].pos = a.pos + e;
          if ("undefined" !== typeof g && Math.abs(k[f].pos - k[f].target) > g) return k.slice(0, f + 1).forEach(function (a) {
            delete a.pos;
          }), k.reducedLen = (k.reducedLen || c) - .1 * c, k.reducedLen > .1 * c && d.distribute(k, c, g), !0;
          e += k[f].size;
          f++;
        })) return !0;
      });
      N(k, h);
    };

    q.prototype.drawDataLabels = function () {
      function e(a, c) {
        var b = c.filter;
        return b ? (c = b.operator, a = a[b.property], b = b.value, ">" === c && a > b || "<" === c && a < b || ">=" === c && a >= b || "<=" === c && a <= b || "==" === c && a == b || "===" === c && a === b ? !0 : !1) : !0;
      }

      function c(a, c) {
        var b = [],
            e;
        if (G(a) && !G(c)) b = a.map(function (a) {
          return J(a, c);
        });else if (G(c) && !G(a)) b = c.map(function (b) {
          return J(a, b);
        });else if (G(a) || G(c)) for (e = Math.max(a.length, c.length); e--;) b[e] = J(a[e], c[e]);else b = J(a, c);
        return b;
      }

      var g = this,
          n = g.chart,
          f = g.options,
          a = f.dataLabels,
          l = g.points,
          v,
          q = g.hasRendered || 0,
          w = r(f.animation).duration,
          u = Math.min(w, 200),
          L = !n.renderer.forExport && t(a.defer, 0 < u),
          D = n.renderer;
      a = c(c(n.options.plotOptions && n.options.plotOptions.series && n.options.plotOptions.series.dataLabels, n.options.plotOptions && n.options.plotOptions[g.type] && n.options.plotOptions[g.type].dataLabels), a);
      d.fireEvent(this, "drawDataLabels");

      if (G(a) || a.enabled || g._hasPointLabels) {
        var H = g.plotGroup("dataLabelsGroup", "data-labels", L && !q ? "hidden" : "inherit", a.zIndex || 6);
        L && (H.attr({
          opacity: +q
        }), q || setTimeout(function () {
          var a = g.dataLabelsGroup;
          a && (g.visible && H.show(!0), a[f.animation ? "animate" : "attr"]({
            opacity: 1
          }, {
            duration: u
          }));
        }, w - u));
        l.forEach(function (d) {
          v = h(c(a, d.dlOptions || d.options && d.options.dataLabels));
          v.forEach(function (a, b) {
            var c = a.enabled && (!d.isNull || d.dataLabelOnNull) && e(d, a),
                h = d.dataLabels ? d.dataLabels[b] : d.dataLabel,
                k = d.connectors ? d.connectors[b] : d.connector,
                l = t(a.distance, d.labelDistance),
                p = !h;

            if (c) {
              var v = d.getLabelConfig();
              var m = t(a[d.formatPrefix + "Format"], a.format);
              v = M(m) ? A(m, v, n) : (a[d.formatPrefix + "Formatter"] || a.formatter).call(v, a);
              m = a.style;
              var q = a.rotation;
              n.styledMode || (m.color = t(a.color, m.color, g.color, "#000000"), "contrast" === m.color ? (d.contrastColor = D.getContrast(d.color || g.color), m.color = !M(l) && a.inside || 0 > l || f.stacking ? d.contrastColor : "#000000") : delete d.contrastColor, f.cursor && (m.cursor = f.cursor));
              var w = {
                r: a.borderRadius || 0,
                rotation: q,
                padding: a.padding,
                zIndex: 1
              };
              n.styledMode || (w.fill = a.backgroundColor, w.stroke = a.borderColor, w["stroke-width"] = a.borderWidth);
              y(w, function (a, b) {
                "undefined" === typeof a && delete w[b];
              });
            }

            !h || c && M(v) ? c && M(v) && (h ? w.text = v : (d.dataLabels = d.dataLabels || [], h = d.dataLabels[b] = q ? D.text(v, 0, -9999, a.useHTML).addClass("highcharts-data-label") : D.label(v, 0, -9999, a.shape, null, null, a.useHTML, null, "data-label"), b || (d.dataLabel = h), h.addClass(" highcharts-data-label-color-" + d.colorIndex + " " + (a.className || "") + (a.useHTML ? " highcharts-tracker" : ""))), h.options = a, h.attr(w), n.styledMode || h.css(m).shadow(a.shadow), h.added || h.add(H), a.textPath && !a.useHTML && (h.setTextPath(d.getDataLabelPath && d.getDataLabelPath(h) || d.graphic, a.textPath), d.dataLabelPath && !a.textPath.enabled && (d.dataLabelPath = d.dataLabelPath.destroy())), g.alignDataLabel(d, h, a, null, p)) : (d.dataLabel = d.dataLabel && d.dataLabel.destroy(), d.dataLabels && (1 === d.dataLabels.length ? delete d.dataLabels : delete d.dataLabels[b]), b || delete d.dataLabel, k && (d.connector = d.connector.destroy(), d.connectors && (1 === d.connectors.length ? delete d.connectors : delete d.connectors[b])));
          });
        });
      }

      d.fireEvent(this, "afterDrawDataLabels");
    };

    q.prototype.alignDataLabel = function (d, c, g, h, f) {
      var a = this,
          e = this.chart,
          k = this.isCartesian && e.inverted,
          n = this.enabledDataSorting,
          q = t(d.dlBox && d.dlBox.centerX, d.plotX, -9999),
          r = t(d.plotY, -9999),
          u = c.getBBox(),
          y = g.rotation,
          A = g.align,
          K = e.isInsidePlot(q, Math.round(r), k),
          p = "justify" === t(g.overflow, n ? "none" : "justify"),
          b = this.visible && !1 !== d.visible && (d.series.forceDL || n && !p || K || g.inside && h && e.isInsidePlot(q, k ? h.x + 1 : h.y + h.height - 1, k));

      var C = function (b) {
        n && a.xAxis && !p && a.setDataLabelStartPos(d, c, f, K, b);
      };

      if (b) {
        var x = e.renderer.fontMetrics(e.styledMode ? void 0 : g.style.fontSize, c).b;
        h = E({
          x: k ? this.yAxis.len - r : q,
          y: Math.round(k ? this.xAxis.len - q : r),
          width: 0,
          height: 0
        }, h);
        E(g, {
          width: u.width,
          height: u.height
        });
        y ? (p = !1, q = e.renderer.rotCorr(x, y), q = {
          x: h.x + g.x + h.width / 2 + q.x,
          y: h.y + g.y + {
            top: 0,
            middle: .5,
            bottom: 1
          }[g.verticalAlign] * h.height
        }, C(q), c[f ? "attr" : "animate"](q).attr({
          align: A
        }), C = (y + 720) % 360, C = 180 < C && 360 > C, "left" === A ? q.y -= C ? u.height : 0 : "center" === A ? (q.x -= u.width / 2, q.y -= u.height / 2) : "right" === A && (q.x -= u.width, q.y -= C ? 0 : u.height), c.placed = !0, c.alignAttr = q) : (C(h), c.align(g, null, h), q = c.alignAttr);
        p && 0 <= h.height ? this.justifyDataLabel(c, g, q, u, h, f) : t(g.crop, !0) && (b = e.isInsidePlot(q.x, q.y) && e.isInsidePlot(q.x + u.width, q.y + u.height));
        if (g.shape && !y) c[f ? "attr" : "animate"]({
          anchorX: k ? e.plotWidth - d.plotY : d.plotX,
          anchorY: k ? e.plotHeight - d.plotX : d.plotY
        });
      }

      f && n && (c.placed = !1);
      b || n && !p || (c.hide(!0), c.placed = !1);
    };

    q.prototype.setDataLabelStartPos = function (d, c, g, h, f) {
      var a = this.chart,
          e = a.inverted,
          k = this.xAxis,
          n = k.reversed,
          q = e ? c.height / 2 : c.width / 2;
      d = (d = d.pointWidth) ? d / 2 : 0;
      k = e ? f.x : n ? -q - d : k.width - q + d;
      f = e ? n ? this.yAxis.height - q + d : -q - d : f.y;
      c.startXPos = k;
      c.startYPos = f;
      h ? "hidden" === c.visibility && (c.show(), c.attr({
        opacity: 0
      }).animate({
        opacity: 1
      })) : c.attr({
        opacity: 1
      }).animate({
        opacity: 0
      }, void 0, c.hide);
      a.hasRendered && (g && c.attr({
        x: c.startXPos,
        y: c.startYPos
      }), c.placed = !0);
    };

    q.prototype.justifyDataLabel = function (d, c, g, h, f, a) {
      var e = this.chart,
          k = c.align,
          n = c.verticalAlign,
          q = d.box ? 0 : d.padding || 0;
      var r = g.x + q;

      if (0 > r) {
        "right" === k ? (c.align = "left", c.inside = !0) : c.x = -r;
        var t = !0;
      }

      r = g.x + h.width - q;
      r > e.plotWidth && ("left" === k ? (c.align = "right", c.inside = !0) : c.x = e.plotWidth - r, t = !0);
      r = g.y + q;
      0 > r && ("bottom" === n ? (c.verticalAlign = "top", c.inside = !0) : c.y = -r, t = !0);
      r = g.y + h.height - q;
      r > e.plotHeight && ("top" === n ? (c.verticalAlign = "bottom", c.inside = !0) : c.y = e.plotHeight - r, t = !0);
      t && (d.placed = !a, d.align(c, null, f));
      return t;
    };

    P.pie && (P.pie.prototype.dataLabelPositioners = {
      radialDistributionY: function (d) {
        return d.top + d.distributeBox.pos;
      },
      radialDistributionX: function (d, c, g, h) {
        return d.getX(g < c.top + 2 || g > c.bottom - 2 ? h : g, c.half, c);
      },
      justify: function (d, c, g) {
        return g[0] + (d.half ? -1 : 1) * (c + d.labelDistance);
      },
      alignToPlotEdges: function (d, c, g, h) {
        d = d.getBBox().width;
        return c ? d + h : g - d - h;
      },
      alignToConnectors: function (d, c, g, h) {
        var e = 0,
            a;
        d.forEach(function (c) {
          a = c.dataLabel.getBBox().width;
          a > e && (e = a);
        });
        return c ? e + h : g - e - h;
      }
    }, P.pie.prototype.drawDataLabels = function () {
      var e = this,
          c = e.data,
          g,
          h = e.chart,
          f = e.options.dataLabels || {},
          a = f.connectorPadding,
          l,
          v = h.plotWidth,
          r = h.plotHeight,
          w = h.plotLeft,
          y = Math.round(h.chartWidth / 3),
          A,
          D = e.center,
          H = D[2] / 2,
          K = D[1],
          p,
          b,
          C,
          x,
          G = [[], []],
          E,
          N,
          I,
          m,
          P = [0, 0, 0, 0],
          S = e.dataLabelPositioners,
          W;
      e.visible && (f.enabled || e._hasPointLabels) && (c.forEach(function (a) {
        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({
          width: "auto"
        }).css({
          width: "auto",
          textOverflow: "clip"
        }), a.dataLabel.shortened = !1);
      }), q.prototype.drawDataLabels.apply(e), c.forEach(function (a) {
        a.dataLabel && (a.visible ? (G[a.half].push(a), a.dataLabel._pos = null, !M(f.style.width) && !M(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > y && (a.dataLabel.css({
          width: .7 * y
        }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));
      }), G.forEach(function (c, k) {
        var l = c.length,
            n = [],
            q;

        if (l) {
          e.sortByAngle(c, k - .5);

          if (0 < e.maxLabelDistance) {
            var u = Math.max(0, K - H - e.maxLabelDistance);
            var z = Math.min(K + H + e.maxLabelDistance, h.plotHeight);
            c.forEach(function (a) {
              0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, K - H - a.labelDistance), a.bottom = Math.min(K + H + a.labelDistance, h.plotHeight), q = a.dataLabel.getBBox().height || 21, a.distributeBox = {
                target: a.labelPosition.natural.y - a.top + q / 2,
                size: q,
                rank: a.y
              }, n.push(a.distributeBox));
            });
            u = z + q - u;
            d.distribute(n, u, u / 5);
          }

          for (m = 0; m < l; m++) {
            g = c[m];
            C = g.labelPosition;
            p = g.dataLabel;
            I = !1 === g.visible ? "hidden" : "inherit";
            N = u = C.natural.y;
            n && M(g.distributeBox) && ("undefined" === typeof g.distributeBox.pos ? I = "hidden" : (x = g.distributeBox.size, N = S.radialDistributionY(g)));
            delete g.positionIndex;
            if (f.justify) E = S.justify(g, H, D);else switch (f.alignTo) {
              case "connectors":
                E = S.alignToConnectors(c, k, v, w);
                break;

              case "plotEdges":
                E = S.alignToPlotEdges(p, k, v, w);
                break;

              default:
                E = S.radialDistributionX(e, g, N, u);
            }
            p._attr = {
              visibility: I,
              align: C.alignment
            };
            W = g.options.dataLabels || {};
            p._pos = {
              x: E + t(W.x, f.x) + ({
                left: a,
                right: -a
              }[C.alignment] || 0),
              y: N + t(W.y, f.y) - 10
            };
            C.final.x = E;
            C.final.y = N;
            t(f.crop, !0) && (b = p.getBBox().width, u = null, E - b < a && 1 === k ? (u = Math.round(b - E + a), P[3] = Math.max(u, P[3])) : E + b > v - a && 0 === k && (u = Math.round(E + b - v + a), P[1] = Math.max(u, P[1])), 0 > N - x / 2 ? P[0] = Math.max(Math.round(-N + x / 2), P[0]) : N + x / 2 > r && (P[2] = Math.max(Math.round(N + x / 2 - r), P[2])), p.sideOverflow = u);
          }
        }
      }), 0 === u(P) || this.verifyDataLabelOverflow(P)) && (this.placeDataLabels(), this.points.forEach(function (a) {
        W = J(f, a.options.dataLabels);

        if (l = t(W.connectorWidth, 1)) {
          var b;
          A = a.connector;

          if ((p = a.dataLabel) && p._pos && a.visible && 0 < a.labelDistance) {
            I = p._attr.visibility;
            if (b = !A) a.connector = A = h.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + a.colorIndex + (a.className ? " " + a.className : "")).add(e.dataLabelsGroup), h.styledMode || A.attr({
              "stroke-width": l,
              stroke: W.connectorColor || a.color || "#666666"
            });
            A[b ? "attr" : "animate"]({
              d: a.getConnectorPath()
            });
            A.attr("visibility", I);
          } else A && (a.connector = A.destroy());
        }
      }));
    }, P.pie.prototype.placeDataLabels = function () {
      this.points.forEach(function (d) {
        var c = d.dataLabel,
            e;
        c && d.visible && ((e = c._pos) ? (c.sideOverflow && (c._attr.width = Math.max(c.getBBox().width - c.sideOverflow, 0), c.css({
          width: c._attr.width + "px",
          textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
        }), c.shortened = !0), c.attr(c._attr), c[c.moved ? "animate" : "attr"](e), c.moved = !0) : c && c.attr({
          y: -9999
        }));
        delete d.distributeBox;
      }, this);
    }, P.pie.prototype.alignDataLabel = g, P.pie.prototype.verifyDataLabelOverflow = function (d) {
      var c = this.center,
          e = this.options,
          g = e.center,
          f = e.minSize || 80,
          a = null !== e.size;

      if (!a) {
        if (null !== g[0]) var h = Math.max(c[2] - Math.max(d[1], d[3]), f);else h = Math.max(c[2] - d[1] - d[3], f), c[0] += (d[3] - d[1]) / 2;
        null !== g[1] ? h = I(h, f, c[2] - Math.max(d[0], d[2])) : (h = I(h, f, c[2] - d[0] - d[2]), c[1] += (d[0] - d[2]) / 2);
        h < c[2] ? (c[2] = h, c[3] = Math.min(D(e.innerSize || 0, h), h), this.translate(c), this.drawDataLabels && this.drawDataLabels()) : a = !0;
      }

      return a;
    });
    P.column && (P.column.prototype.alignDataLabel = function (d, c, g, h, f) {
      var a = this.chart.inverted,
          e = d.series,
          k = d.dlBox || d.shapeArgs,
          n = t(d.below, d.plotY > t(this.translatedThreshold, e.yAxis.len)),
          r = t(g.inside, !!this.options.stacking);
      k && (h = J(k), 0 > h.y && (h.height += h.y, h.y = 0), k = h.y + h.height - e.yAxis.len, 0 < k && k < h.height && (h.height -= k), a && (h = {
        x: e.yAxis.len - h.y - h.height,
        y: e.xAxis.len - h.x - h.width,
        width: h.height,
        height: h.width
      }), r || (a ? (h.x += n ? 0 : h.width, h.width = 0) : (h.y += n ? h.height : 0, h.height = 0)));
      g.align = t(g.align, !a || r ? "center" : n ? "right" : "left");
      g.verticalAlign = t(g.verticalAlign, a || r ? "middle" : n ? "top" : "bottom");
      q.prototype.alignDataLabel.call(this, d, c, g, h, f);
      g.inside && d.contrastColor && c.css({
        color: d.contrastColor
      });
    });
  });
  S(r, "modules/overlapping-datalabels.src.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.addEvent,
        u = g.fireEvent,
        I = g.isArray,
        M = g.objectEach,
        E = g.pick;
    d = d.Chart;
    r(d, "render", function () {
      var d = [];
      (this.labelCollectors || []).forEach(function (g) {
        d = d.concat(g());
      });
      (this.yAxis || []).forEach(function (g) {
        g.options.stackLabels && !g.options.stackLabels.allowOverlap && M(g.stacks, function (g) {
          M(g, function (g) {
            d.push(g.label);
          });
        });
      });
      (this.series || []).forEach(function (g) {
        var r = g.options.dataLabels;
        g.visible && (!1 !== r.enabled || g._hasPointLabels) && (g.nodes || g.points).forEach(function (g) {
          g.visible && (I(g.dataLabels) ? g.dataLabels : g.dataLabel ? [g.dataLabel] : []).forEach(function (r) {
            var t = r.options;
            r.labelrank = E(t.labelrank, g.labelrank, g.shapeArgs && g.shapeArgs.height);
            t.allowOverlap || d.push(r);
          });
        });
      });
      this.hideOverlappingLabels(d);
    });

    d.prototype.hideOverlappingLabels = function (d) {
      var g = this,
          r = d.length,
          y = g.renderer,
          t,
          A,
          h,
          E = !1;

      var q = function (c) {
        var d = c.box ? 0 : c.padding || 0;
        var e = 0;

        if (c && (!c.alignAttr || c.placed)) {
          var f = c.alignAttr || {
            x: c.attr("x"),
            y: c.attr("y")
          };
          var a = c.parentGroup;
          c.width || (e = c.getBBox(), c.width = e.width, c.height = e.height, e = y.fontMetrics(null, c.element).h);
          return {
            x: f.x + (a.translateX || 0) + d,
            y: f.y + (a.translateY || 0) + d - e,
            width: c.width - 2 * d,
            height: c.height - 2 * d
          };
        }
      };

      for (A = 0; A < r; A++) if (t = d[A]) t.oldOpacity = t.opacity, t.newOpacity = 1, t.absoluteBox = q(t);

      d.sort(function (c, d) {
        return (d.labelrank || 0) - (c.labelrank || 0);
      });

      for (A = 0; A < r; A++) {
        var I = (q = d[A]) && q.absoluteBox;

        for (t = A + 1; t < r; ++t) {
          var e = (h = d[t]) && h.absoluteBox;
          !I || !e || q === h || 0 === q.newOpacity || 0 === h.newOpacity || e.x > I.x + I.width || e.x + e.width < I.x || e.y > I.y + I.height || e.y + e.height < I.y || ((q.labelrank < h.labelrank ? q : h).newOpacity = 0);
        }
      }

      d.forEach(function (c) {
        var d;

        if (c) {
          var e = c.newOpacity;
          c.oldOpacity !== e && (c.alignAttr && c.placed ? (e ? c.show(!0) : d = function () {
            c.hide(!0);
            c.placed = !1;
          }, E = !0, c.alignAttr.opacity = e, c[c.isOld ? "animate" : "attr"](c.alignAttr, null, d), u(g, "afterHideOverlappingLabel")) : c.attr({
            opacity: e
          }));
          c.isOld = !0;
        }
      });
      E && u(g, "afterHideAllOverlappingLabels");
    };
  });
  S(r, "parts/Interaction.js", [r["parts/Globals.js"], r["parts/Legend.js"], r["parts/Point.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    var I = u.addEvent,
        M = u.createElement,
        E = u.css,
        A = u.defined,
        G = u.extend,
        J = u.fireEvent,
        y = u.isArray,
        t = u.isFunction,
        D = u.isObject,
        h = u.merge,
        N = u.objectEach,
        q = u.pick;
    u = d.Chart;
    var P = d.defaultOptions,
        e = d.defaultPlotOptions,
        c = d.hasTouch,
        k = d.Series,
        n = d.seriesTypes,
        f = d.svg;
    d = d.TrackerMixin = {
      drawTrackerPoint: function () {
        var a = this,
            d = a.chart,
            e = d.pointer,
            f = function (a) {
          var c = e.getPointFromEvent(a);
          "undefined" !== typeof c && (e.isDirectTouch = !0, c.onMouseOver(a));
        },
            g;

        a.points.forEach(function (a) {
          g = y(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];
          a.graphic && (a.graphic.element.point = a);
          g.forEach(function (c) {
            c.div ? c.div.point = a : c.element.point = a;
          });
        });
        a._hasTracking || (a.trackerGroups.forEach(function (g) {
          if (a[g]) {
            a[g].addClass("highcharts-tracker").on("mouseover", f).on("mouseout", function (a) {
              e.onTrackerMouseOut(a);
            });
            if (c) a[g].on("touchstart", f);
            !d.styledMode && a.options.cursor && a[g].css(E).css({
              cursor: a.options.cursor
            });
          }
        }), a._hasTracking = !0);
        J(this, "afterDrawTracker");
      },
      drawTrackerGraph: function () {
        var a = this,
            d = a.options,
            e = d.trackByArea,
            g = [].concat(e ? a.areaPath : a.graphPath),
            h = g.length,
            k = a.chart,
            n = k.pointer,
            q = k.renderer,
            r = k.options.tooltip.snap,
            t = a.tracker,
            p,
            b = function () {
          if (k.hoverSeries !== a) a.onMouseOver();
        },
            u = "rgba(192,192,192," + (f ? .0001 : .002) + ")";

        if (h && !e) for (p = h + 1; p--;) "M" === g[p] && g.splice(p + 1, 0, g[p + 1] - r, g[p + 2], "L"), (p && "M" === g[p] || p === h) && g.splice(p, 0, "L", g[p - 2] + r, g[p - 1]);
        t ? t.attr({
          d: g
        }) : a.graph && (a.tracker = q.path(g).attr({
          visibility: a.visible ? "visible" : "hidden",
          zIndex: 2
        }).addClass(e ? "highcharts-tracker-area" : "highcharts-tracker-line").add(a.group), k.styledMode || a.tracker.attr({
          "stroke-linejoin": "round",
          stroke: u,
          fill: e ? u : "none",
          "stroke-width": a.graph.strokeWidth() + (e ? 0 : 2 * r)
        }), [a.tracker, a.markerGroup].forEach(function (a) {
          a.addClass("highcharts-tracker").on("mouseover", b).on("mouseout", function (a) {
            n.onTrackerMouseOut(a);
          });
          d.cursor && !k.styledMode && a.css({
            cursor: d.cursor
          });
          if (c) a.on("touchstart", b);
        }));
        J(this, "afterDrawTracker");
      }
    };
    n.column && (n.column.prototype.drawTracker = d.drawTrackerPoint);
    n.pie && (n.pie.prototype.drawTracker = d.drawTrackerPoint);
    n.scatter && (n.scatter.prototype.drawTracker = d.drawTrackerPoint);
    G(g.prototype, {
      setItemEvents: function (a, c, d) {
        var e = this,
            f = e.chart.renderer.boxWrapper,
            g = a instanceof r,
            k = "highcharts-legend-" + (g ? "point" : "series") + "-active",
            l = e.chart.styledMode;
        (d ? [c, a.legendSymbol] : [a.legendGroup]).forEach(function (d) {
          if (d) d.on("mouseover", function () {
            a.visible && e.allItems.forEach(function (c) {
              a !== c && c.setState("inactive", !g);
            });
            a.setState("hover");
            a.visible && f.addClass(k);
            l || c.css(e.options.itemHoverStyle);
          }).on("mouseout", function () {
            e.chart.styledMode || c.css(h(a.visible ? e.itemStyle : e.itemHiddenStyle));
            e.allItems.forEach(function (c) {
              a !== c && c.setState("", !g);
            });
            f.removeClass(k);
            a.setState();
          }).on("click", function (c) {
            var d = function () {
              a.setVisible && a.setVisible();
              e.allItems.forEach(function (b) {
                a !== b && b.setState(a.visible ? "inactive" : "", !g);
              });
            };

            f.removeClass(k);
            c = {
              browserEvent: c
            };
            a.firePointEvent ? a.firePointEvent("legendItemClick", c, d) : J(a, "legendItemClick", c, d);
          });
        });
      },
      createCheckboxForItem: function (a) {
        a.checkbox = M("input", {
          type: "checkbox",
          className: "highcharts-legend-checkbox",
          checked: a.selected,
          defaultChecked: a.selected
        }, this.options.itemCheckboxStyle, this.chart.container);
        I(a.checkbox, "click", function (c) {
          J(a.series || a, "checkboxClick", {
            checked: c.target.checked,
            item: a
          }, function () {
            a.select();
          });
        });
      }
    });
    G(u.prototype, {
      showResetZoom: function () {
        function a() {
          c.zoomOut();
        }

        var c = this,
            d = P.lang,
            e = c.options.chart.resetZoomButton,
            f = e.theme,
            g = f.states,
            h = "chart" === e.relativeTo || "spaceBox" === e.relativeTo ? null : "plotBox";
        J(this, "beforeShowResetZoom", null, function () {
          c.resetZoomButton = c.renderer.button(d.resetZoom, null, null, a, f, g && g.hover).attr({
            align: e.position.align,
            title: d.resetZoomTitle
          }).addClass("highcharts-reset-zoom").add().align(e.position, !1, h);
        });
        J(this, "afterShowResetZoom");
      },
      zoomOut: function () {
        J(this, "selection", {
          resetSelection: !0
        }, this.zoom);
      },
      zoom: function (a) {
        var c = this,
            d,
            e = c.pointer,
            f = !1,
            g = c.inverted ? e.mouseDownX : e.mouseDownY;
        !a || a.resetSelection ? (c.axes.forEach(function (a) {
          d = a.zoom();
        }), e.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {
          var h = a.axis,
              k = c.inverted ? h.left : h.top,
              l = c.inverted ? k + h.width : k + h.height,
              b = h.isXAxis,
              n = !1;
          if (!b && g >= k && g <= l || b || !A(g)) n = !0;
          e[b ? "zoomX" : "zoomY"] && n && (d = h.zoom(a.min, a.max), h.displayBtn && (f = !0));
        });
        var h = c.resetZoomButton;
        f && !h ? c.showResetZoom() : !f && D(h) && (c.resetZoomButton = h.destroy());
        d && c.redraw(q(c.options.chart.animation, a && a.animation, 100 > c.pointCount));
      },
      pan: function (a, c) {
        var d = this,
            e = d.hoverPoints,
            f = d.options.chart,
            g;
        c = "object" === typeof c ? c : {
          enabled: c,
          type: "x"
        };
        f && f.panning && (f.panning = c);
        var h = c.type;
        J(this, "pan", {
          originalEvent: a
        }, function () {
          e && e.forEach(function (a) {
            a.setState();
          });
          var c = [1];
          "xy" === h ? c = [1, 0] : "y" === h && (c = [0]);
          c.forEach(function (c) {
            var e = d[c ? "xAxis" : "yAxis"][0],
                f = e.options,
                b = e.horiz,
                h = a[b ? "chartX" : "chartY"];
            b = b ? "mouseDownX" : "mouseDownY";
            var k = d[b],
                l = (e.pointRange || 0) / 2,
                n = e.reversed && !d.inverted || !e.reversed && d.inverted ? -1 : 1,
                q = e.getExtremes(),
                v = e.toValue(k - h, !0) + l * n;
            n = e.toValue(k + e.len - h, !0) - l * n;
            var m = n < v;
            k = m ? n : v;
            v = m ? v : n;
            n = Math.min(q.dataMin, l ? q.min : e.toValue(e.toPixels(q.min) - e.minPixelPadding));
            l = Math.max(q.dataMax, l ? q.max : e.toValue(e.toPixels(q.max) + e.minPixelPadding));

            if (!f.ordinal) {
              c && (f = n - k, 0 < f && (v += f, k = n), f = v - l, 0 < f && (v = l, k -= f));
              if (e.series.length && k !== q.min && v !== q.max && c || e.panningState && k >= e.panningState.startMin && v <= e.panningState.startMax) e.setExtremes(k, v, !1, !1, {
                trigger: "pan"
              }), g = !0;
              d[b] = h;
            }
          });
          g && d.redraw(!1);
          E(d.container, {
            cursor: "move"
          });
        });
      }
    });
    G(r.prototype, {
      select: function (a, c) {
        var d = this,
            e = d.series,
            f = e.chart;
        this.selectedStaging = a = q(a, !d.selected);
        d.firePointEvent(a ? "select" : "unselect", {
          accumulate: c
        }, function () {
          d.selected = d.options.selected = a;
          e.options.data[e.data.indexOf(d)] = d.options;
          d.setState(a && "select");
          c || f.getSelectedPoints().forEach(function (a) {
            var c = a.series;
            a.selected && a !== d && (a.selected = a.options.selected = !1, c.options.data[c.data.indexOf(a)] = a.options, a.setState(f.hoverPoints && c.options.inactiveOtherPoints ? "inactive" : ""), a.firePointEvent("unselect"));
          });
        });
        delete this.selectedStaging;
      },
      onMouseOver: function (a) {
        var c = this.series.chart,
            d = c.pointer;
        a = a ? d.normalize(a) : d.getChartCoordinatesFromPoint(this, c.inverted);
        d.runPointActions(a, this);
      },
      onMouseOut: function () {
        var a = this.series.chart;
        this.firePointEvent("mouseOut");
        this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (a) {
          a.setState();
        });
        a.hoverPoints = a.hoverPoint = null;
      },
      importEvents: function () {
        if (!this.hasImportedEvents) {
          var a = this,
              c = h(a.series.options.point, a.options).events;
          a.events = c;
          N(c, function (c, d) {
            t(c) && I(a, d, c);
          });
          this.hasImportedEvents = !0;
        }
      },
      setState: function (a, c) {
        var d = this.series,
            f = this.state,
            g = d.options.states[a || "normal"] || {},
            h = e[d.type].marker && d.options.marker,
            k = h && !1 === h.enabled,
            l = h && h.states && h.states[a || "normal"] || {},
            n = !1 === l.enabled,
            r = d.stateMarkerGraphic,
            p = this.marker || {},
            b = d.chart,
            t = d.halo,
            u,
            y = h && d.markerAttribs;
        a = a || "";

        if (!(a === this.state && !c || this.selected && "select" !== a || !1 === g.enabled || a && (n || k && !1 === l.enabled) || a && p.states && p.states[a] && !1 === p.states[a].enabled)) {
          this.state = a;
          y && (u = d.markerAttribs(this, a));

          if (this.graphic) {
            f && this.graphic.removeClass("highcharts-point-" + f);
            a && this.graphic.addClass("highcharts-point-" + a);

            if (!b.styledMode) {
              var A = d.pointAttribs(this, a);
              var D = q(b.options.chart.animation, g.animation);
              d.options.inactiveOtherPoints && ((this.dataLabels || []).forEach(function (a) {
                a && a.animate({
                  opacity: A.opacity
                }, D);
              }), this.connector && this.connector.animate({
                opacity: A.opacity
              }, D));
              this.graphic.animate(A, D);
            }

            u && this.graphic.animate(u, q(b.options.chart.animation, l.animation, h.animation));
            r && r.hide();
          } else {
            if (a && l) {
              f = p.symbol || d.symbol;
              r && r.currentSymbol !== f && (r = r.destroy());
              if (u) if (r) r[c ? "animate" : "attr"]({
                x: u.x,
                y: u.y
              });else f && (d.stateMarkerGraphic = r = b.renderer.symbol(f, u.x, u.y, u.width, u.height).add(d.markerGroup), r.currentSymbol = f);
              !b.styledMode && r && r.attr(d.pointAttribs(this, a));
            }

            r && (r[a && this.isInside ? "show" : "hide"](), r.element.point = this);
          }

          a = g.halo;
          g = (r = this.graphic || r) && r.visibility || "inherit";
          a && a.size && r && "hidden" !== g && !this.isCluster ? (t || (d.halo = t = b.renderer.path().add(r.parentGroup)), t.show()[c ? "animate" : "attr"]({
            d: this.haloPath(a.size)
          }), t.attr({
            "class": "highcharts-halo highcharts-color-" + q(this.colorIndex, d.colorIndex) + (this.className ? " " + this.className : ""),
            visibility: g,
            zIndex: -1
          }), t.point = this, b.styledMode || t.attr(G({
            fill: this.color || d.color,
            "fill-opacity": a.opacity
          }, a.attributes))) : t && t.point && t.point.haloPath && t.animate({
            d: t.point.haloPath(0)
          }, null, t.hide);
          J(this, "afterSetState");
        }
      },
      haloPath: function (a) {
        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);
      }
    });
    G(k.prototype, {
      onMouseOver: function () {
        var a = this.chart,
            c = a.hoverSeries;
        if (c && c !== this) c.onMouseOut();
        this.options.events.mouseOver && J(this, "mouseOver");
        this.setState("hover");
        a.hoverSeries = this;
      },
      onMouseOut: function () {
        var a = this.options,
            c = this.chart,
            d = c.tooltip,
            e = c.hoverPoint;
        c.hoverSeries = null;
        if (e) e.onMouseOut();
        this && a.events.mouseOut && J(this, "mouseOut");
        !d || this.stickyTracking || d.shared && !this.noSharedTooltip || d.hide();
        c.series.forEach(function (a) {
          a.setState("", !0);
        });
      },
      setState: function (a, c) {
        var d = this,
            e = d.options,
            f = d.graph,
            g = e.inactiveOtherPoints,
            h = e.states,
            k = e.lineWidth,
            l = e.opacity,
            n = q(h[a || "normal"] && h[a || "normal"].animation, d.chart.options.chart.animation);
        e = 0;
        a = a || "";

        if (d.state !== a && ([d.group, d.markerGroup, d.dataLabelsGroup].forEach(function (c) {
          c && (d.state && c.removeClass("highcharts-series-" + d.state), a && c.addClass("highcharts-series-" + a));
        }), d.state = a, !d.chart.styledMode)) {
          if (h[a] && !1 === h[a].enabled) return;
          a && (k = h[a].lineWidth || k + (h[a].lineWidthPlus || 0), l = q(h[a].opacity, l));
          if (f && !f.dashstyle) for (h = {
            "stroke-width": k
          }, f.animate(h, n); d["zone-graph-" + e];) d["zone-graph-" + e].attr(h), e += 1;
          g || [d.group, d.markerGroup, d.dataLabelsGroup, d.labelBySeries].forEach(function (a) {
            a && a.animate({
              opacity: l
            }, n);
          });
        }

        c && g && d.points && d.setAllPointsToState(a);
      },
      setAllPointsToState: function (a) {
        this.points.forEach(function (c) {
          c.setState && c.setState(a);
        });
      },
      setVisible: function (a, c) {
        var d = this,
            e = d.chart,
            f = d.legendItem,
            g = e.options.chart.ignoreHiddenSeries,
            h = d.visible;
        var k = (d.visible = a = d.options.visible = d.userOptions.visible = "undefined" === typeof a ? !h : a) ? "show" : "hide";
        ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (a) {
          if (d[a]) d[a][k]();
        });
        if (e.hoverSeries === d || (e.hoverPoint && e.hoverPoint.series) === d) d.onMouseOut();
        f && e.legend.colorizeItem(d, a);
        d.isDirty = !0;
        d.options.stacking && e.series.forEach(function (a) {
          a.options.stacking && a.visible && (a.isDirty = !0);
        });
        d.linkedSeries.forEach(function (c) {
          c.setVisible(a, !1);
        });
        g && (e.isDirtyBox = !0);
        J(d, k);
        !1 !== c && e.redraw();
      },
      show: function () {
        this.setVisible(!0);
      },
      hide: function () {
        this.setVisible(!1);
      },
      select: function (a) {
        this.selected = a = this.options.selected = "undefined" === typeof a ? !this.selected : a;
        this.checkbox && (this.checkbox.checked = a);
        J(this, a ? "select" : "unselect");
      },
      drawTracker: d.drawTrackerGraph
    });
  });
  S(r, "parts/Responsive.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.find,
        u = g.isArray,
        I = g.isObject,
        M = g.merge,
        E = g.objectEach,
        A = g.pick,
        G = g.splat,
        J = g.uniqueKey;
    d = d.Chart;

    d.prototype.setResponsive = function (d, g) {
      var t = this.options.responsive,
          h = [],
          u = this.currentResponsive;
      !g && t && t.rules && t.rules.forEach(function (d) {
        "undefined" === typeof d._id && (d._id = J());
        this.matchResponsiveRule(d, h);
      }, this);
      g = M.apply(0, h.map(function (d) {
        return r(t.rules, function (g) {
          return g._id === d;
        }).chartOptions;
      }));
      g.isResponsiveOptions = !0;
      h = h.toString() || void 0;
      h !== (u && u.ruleIds) && (u && this.update(u.undoOptions, d, !0), h ? (u = this.currentOptions(g), u.isResponsiveOptions = !0, this.currentResponsive = {
        ruleIds: h,
        mergedOptions: g,
        undoOptions: u
      }, this.update(g, d, !0)) : this.currentResponsive = void 0);
    };

    d.prototype.matchResponsiveRule = function (d, g) {
      var r = d.condition;
      (r.callback || function () {
        return this.chartWidth <= A(r.maxWidth, Number.MAX_VALUE) && this.chartHeight <= A(r.maxHeight, Number.MAX_VALUE) && this.chartWidth >= A(r.minWidth, 0) && this.chartHeight >= A(r.minHeight, 0);
      }).call(this) && g.push(d._id);
    };

    d.prototype.currentOptions = function (d) {
      function g(d, h, t, e) {
        var c;
        E(d, function (d, n) {
          if (!e && -1 < r.collectionsWithUpdate.indexOf(n)) for (d = G(d), t[n] = [], c = 0; c < d.length; c++) h[n][c] && (t[n][c] = {}, g(d[c], h[n][c], t[n][c], e + 1));else I(d) ? (t[n] = u(d) ? [] : {}, g(d, h[n] || {}, t[n], e + 1)) : t[n] = "undefined" === typeof h[n] ? null : h[n];
        });
      }

      var r = this,
          h = {};
      g(d, this.options, h, 0);
      return h;
    };
  });
  S(r, "masters/highcharts.src.js", [r["parts/Globals.js"]], function (d) {
    return d;
  });
  r["masters/highcharts.src.js"]._modules = r;
  return r["masters/highcharts.src.js"];
});

/***/ }),

/***/ "./node_modules/highcharts/modules/exporting.js":
/*!******************************************************!*\
  !*** ./node_modules/highcharts/modules/exporting.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 Highcharts JS v8.0.4 (2020-03-10)

 Exporting module

 (c) 2010-2019 Torstein Honsi

 License: www.highcharts.com/license
*/
(function (e) {
   true && module.exports ? (e["default"] = e, module.exports = e) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! highcharts */ "./node_modules/highcharts/highcharts.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (m) {
    e(m);
    e.Highcharts = m;
    return e;
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(function (e) {
  function m(f, g, e, n) {
    f.hasOwnProperty(g) || (f[g] = n.apply(null, e));
  }

  e = e ? e._modules : {};
  m(e, "modules/full-screen.src.js", [e["parts/Globals.js"]], function (f) {
    var g = f.addEvent,
        e = f.Chart,
        n = function () {
      function g(h) {
        this.chart = h;
        this.isOpen = !1;
        h.container.parentNode instanceof Element && (h = h.container.parentNode, this.browserProps || ("function" === typeof h.requestFullscreen ? this.browserProps = {
          fullscreenChange: "fullscreenchange",
          requestFullscreen: "requestFullscreen",
          exitFullscreen: "exitFullscreen"
        } : h.mozRequestFullScreen ? this.browserProps = {
          fullscreenChange: "mozfullscreenchange",
          requestFullscreen: "mozRequestFullScreen",
          exitFullscreen: "mozCancelFullScreen"
        } : h.webkitRequestFullScreen ? this.browserProps = {
          fullscreenChange: "webkitfullscreenchange",
          requestFullscreen: "webkitRequestFullScreen",
          exitFullscreen: "webkitExitFullscreen"
        } : h.msRequestFullscreen && (this.browserProps = {
          fullscreenChange: "MSFullscreenChange",
          requestFullscreen: "msRequestFullscreen",
          exitFullscreen: "msExitFullscreen"
        })));
      }

      g.prototype.close = function () {
        var h = this.chart;
        if (this.isOpen && this.browserProps && h.container.ownerDocument instanceof Document) h.container.ownerDocument[this.browserProps.exitFullscreen]();
        this.unbindFullscreenEvent && this.unbindFullscreenEvent();
        this.isOpen = !1;
        this.setButtonText();
      };

      g.prototype.open = function () {
        var h = this,
            g = h.chart;

        if (h.browserProps) {
          h.unbindFullscreenEvent = f.addEvent(g.container.ownerDocument, h.browserProps.fullscreenChange, function () {
            h.isOpen ? (h.isOpen = !1, h.close()) : (h.isOpen = !0, h.setButtonText());
          });

          if (g.container.parentNode instanceof Element) {
            var e = g.container.parentNode[h.browserProps.requestFullscreen]();
            if (e) e["catch"](function () {
              alert("Full screen is not supported inside a frame.");
            });
          }

          f.addEvent(g, "destroy", h.unbindFullscreenEvent);
        }
      };

      g.prototype.setButtonText = function () {
        var h,
            g = this.chart,
            f = g.exportDivElements,
            e = g.options.exporting,
            n = null === (h = null === e || void 0 === e ? void 0 : e.buttons) || void 0 === h ? void 0 : h.contextButton.menuItems;
        h = g.options.lang;
        (null === e || void 0 === e ? 0 : e.menuItemDefinitions) && (null === h || void 0 === h ? 0 : h.exitFullscreen) && h.viewFullscreen && n && f && f.length && (f[n.indexOf("viewFullscreen")].innerHTML = this.isOpen ? h.exitFullscreen : e.menuItemDefinitions.viewFullscreen.text || h.viewFullscreen);
      };

      g.prototype.toggle = function () {
        this.isOpen ? this.close() : this.open();
      };

      return g;
    }();

    f.Fullscreen = n;
    g(e, "beforeRender", function () {
      this.fullscreen = new f.Fullscreen(this);
    });
    return f.Fullscreen;
  });
  m(e, "mixins/navigation.js", [], function () {
    return {
      initUpdate: function (f) {
        f.navigation || (f.navigation = {
          updates: [],
          update: function (g, f) {
            this.updates.forEach(function (e) {
              e.update.call(e.context, g, f);
            });
          }
        });
      },
      addUpdate: function (f, g) {
        g.navigation || this.initUpdate(g);
        g.navigation.updates.push({
          update: f,
          context: g
        });
      }
    };
  });
  m(e, "modules/exporting.src.js", [e["parts/Globals.js"], e["parts/Utilities.js"], e["mixins/navigation.js"]], function (f, g, e) {
    var n = g.addEvent,
        u = g.css,
        h = g.createElement,
        m = g.discardElement,
        x = g.extend,
        I = g.find,
        B = g.fireEvent,
        J = g.isObject,
        p = g.merge,
        E = g.objectEach,
        q = g.pick,
        K = g.removeEvent,
        L = g.uniqueKey,
        w = f.defaultOptions,
        y = f.doc,
        C = f.Chart,
        M = f.isTouchDevice,
        z = f.win,
        G = z.navigator.userAgent,
        F = f.SVGRenderer,
        H = f.Renderer.prototype.symbols,
        N = /Edge\/|Trident\/|MSIE /.test(G),
        O = /firefox/i.test(G);
    x(w.lang, {
      viewFullscreen: "View in full screen",
      exitFullscreen: "Exit from full screen",
      printChart: "Print chart",
      downloadPNG: "Download PNG image",
      downloadJPEG: "Download JPEG image",
      downloadPDF: "Download PDF document",
      downloadSVG: "Download SVG vector image",
      contextButtonTitle: "Chart context menu"
    });
    w.navigation || (w.navigation = {});
    p(!0, w.navigation, {
      buttonOptions: {
        theme: {},
        symbolSize: 14,
        symbolX: 12.5,
        symbolY: 10.5,
        align: "right",
        buttonSpacing: 3,
        height: 22,
        verticalAlign: "top",
        width: 24
      }
    });
    p(!0, w.navigation, {
      menuStyle: {
        border: "1px solid #999999",
        background: "#ffffff",
        padding: "5px 0"
      },
      menuItemStyle: {
        padding: "0.5em 1em",
        color: "#333333",
        background: "none",
        fontSize: M ? "14px" : "11px",
        transition: "background 250ms, color 250ms"
      },
      menuItemHoverStyle: {
        background: "#335cad",
        color: "#ffffff"
      },
      buttonOptions: {
        symbolFill: "#666666",
        symbolStroke: "#666666",
        symbolStrokeWidth: 3,
        theme: {
          padding: 5
        }
      }
    });
    w.exporting = {
      type: "image/png",
      url: "https://export.highcharts.com/",
      printMaxWidth: 780,
      scale: 2,
      buttons: {
        contextButton: {
          className: "highcharts-contextbutton",
          menuClassName: "highcharts-contextmenu",
          symbol: "menu",
          titleKey: "contextButtonTitle",
          menuItems: "viewFullscreen printChart separator downloadPNG downloadJPEG downloadPDF downloadSVG".split(" ")
        }
      },
      menuItemDefinitions: {
        viewFullscreen: {
          textKey: "viewFullscreen",
          onclick: function () {
            this.fullscreen.toggle();
          }
        },
        printChart: {
          textKey: "printChart",
          onclick: function () {
            this.print();
          }
        },
        separator: {
          separator: !0
        },
        downloadPNG: {
          textKey: "downloadPNG",
          onclick: function () {
            this.exportChart();
          }
        },
        downloadJPEG: {
          textKey: "downloadJPEG",
          onclick: function () {
            this.exportChart({
              type: "image/jpeg"
            });
          }
        },
        downloadPDF: {
          textKey: "downloadPDF",
          onclick: function () {
            this.exportChart({
              type: "application/pdf"
            });
          }
        },
        downloadSVG: {
          textKey: "downloadSVG",
          onclick: function () {
            this.exportChart({
              type: "image/svg+xml"
            });
          }
        }
      }
    };

    f.post = function (a, b, c) {
      var d = h("form", p({
        method: "post",
        action: a,
        enctype: "multipart/form-data"
      }, c), {
        display: "none"
      }, y.body);
      E(b, function (a, b) {
        h("input", {
          type: "hidden",
          name: b,
          value: a
        }, null, d);
      });
      d.submit();
      m(d);
    };

    f.isSafari && f.win.matchMedia("print").addListener(function (a) {
      f.printingChart && (a.matches ? f.printingChart.beforePrint() : f.printingChart.afterPrint());
    });
    x(C.prototype, {
      sanitizeSVG: function (a, b) {
        var c = a.indexOf("</svg>") + 6,
            d = a.substr(c);
        a = a.substr(0, c);
        b && b.exporting && b.exporting.allowHTML && d && (d = '<foreignObject x="0" y="0" width="' + b.chart.width + '" height="' + b.chart.height + '"><body xmlns="http://www.w3.org/1999/xhtml">' + d + "</body></foreignObject>", a = a.replace("</svg>", d + "</svg>"));
        a = a.replace(/zIndex="[^"]+"/g, "").replace(/symbolName="[^"]+"/g, "").replace(/jQuery[0-9]+="[^"]+"/g, "").replace(/url\(("|&quot;)(.*?)("|&quot;);?\)/g, "url($2)").replace(/url\([^#]+#/g, "url(#").replace(/<svg /, '<svg xmlns:xlink="http://www.w3.org/1999/xlink" ').replace(/ (|NS[0-9]+:)href=/g, " xlink:href=").replace(/\n/, " ").replace(/(fill|stroke)="rgba\(([ 0-9]+,[ 0-9]+,[ 0-9]+),([ 0-9\.]+)\)"/g, '$1="rgb($2)" $1-opacity="$3"').replace(/&nbsp;/g, "\u00a0").replace(/&shy;/g, "\u00ad");
        this.ieSanitizeSVG && (a = this.ieSanitizeSVG(a));
        return a;
      },
      getChartHTML: function () {
        this.styledMode && this.inlineStyles();
        return this.container.innerHTML;
      },
      getSVG: function (a) {
        var b,
            c = p(this.options, a);
        c.plotOptions = p(this.userOptions.plotOptions, a && a.plotOptions);
        c.time = p(this.userOptions.time, a && a.time);
        var d = h("div", null, {
          position: "absolute",
          top: "-9999em",
          width: this.chartWidth + "px",
          height: this.chartHeight + "px"
        }, y.body);
        var g = this.renderTo.style.width;
        var e = this.renderTo.style.height;
        g = c.exporting.sourceWidth || c.chart.width || /px$/.test(g) && parseInt(g, 10) || (c.isGantt ? 800 : 600);
        e = c.exporting.sourceHeight || c.chart.height || /px$/.test(e) && parseInt(e, 10) || 400;
        x(c.chart, {
          animation: !1,
          renderTo: d,
          forExport: !0,
          renderer: "SVGRenderer",
          width: g,
          height: e
        });
        c.exporting.enabled = !1;
        delete c.data;
        c.series = [];
        this.series.forEach(function (a) {
          b = p(a.userOptions, {
            animation: !1,
            enableMouseTracking: !1,
            showCheckbox: !1,
            visible: a.visible
          });
          b.isInternal || c.series.push(b);
        });
        this.axes.forEach(function (a) {
          a.userOptions.internalKey || (a.userOptions.internalKey = L());
        });
        var r = new f.Chart(c, this.callback);
        a && ["xAxis", "yAxis", "series"].forEach(function (b) {
          var d = {};
          a[b] && (d[b] = a[b], r.update(d));
        });
        this.axes.forEach(function (a) {
          var b = I(r.axes, function (b) {
            return b.options.internalKey === a.userOptions.internalKey;
          }),
              d = a.getExtremes(),
              c = d.userMin;
          d = d.userMax;
          b && ("undefined" !== typeof c && c !== b.min || "undefined" !== typeof d && d !== b.max) && b.setExtremes(c, d, !0, !1);
        });
        g = r.getChartHTML();
        B(this, "getSVG", {
          chartCopy: r
        });
        g = this.sanitizeSVG(g, c);
        c = null;
        r.destroy();
        m(d);
        return g;
      },
      getSVGForExport: function (a, b) {
        var c = this.options.exporting;
        return this.getSVG(p({
          chart: {
            borderRadius: 0
          }
        }, c.chartOptions, b, {
          exporting: {
            sourceWidth: a && a.sourceWidth || c.sourceWidth,
            sourceHeight: a && a.sourceHeight || c.sourceHeight
          }
        }));
      },
      getFilename: function () {
        var a = this.userOptions.title && this.userOptions.title.text,
            b = this.options.exporting.filename;
        if (b) return b.replace(/\//g, "-");
        "string" === typeof a && (b = a.toLowerCase().replace(/<\/?[^>]+(>|$)/g, "").replace(/[\s_]+/g, "-").replace(/[^a-z0-9\-]/g, "").replace(/^[\-]+/g, "").replace(/[\-]+/g, "-").substr(0, 24).replace(/[\-]+$/g, ""));
        if (!b || 5 > b.length) b = "chart";
        return b;
      },
      exportChart: function (a, b) {
        b = this.getSVGForExport(a, b);
        a = p(this.options.exporting, a);
        f.post(a.url, {
          filename: a.filename ? a.filename.replace(/\//g, "-") : this.getFilename(),
          type: a.type,
          width: a.width || 0,
          scale: a.scale,
          svg: b
        }, a.formAttributes);
      },
      moveContainers: function (a) {
        (this.fixedDiv ? [this.fixedDiv, this.scrollingContainer] : [this.container]).forEach(function (b) {
          a.appendChild(b);
        });
      },
      beforePrint: function () {
        var a = y.body,
            b = this.options.exporting.printMaxWidth,
            c = {
          childNodes: a.childNodes,
          origDisplay: [],
          resetParams: void 0
        };
        this.isPrinting = !0;
        this.pointer.reset(null, 0);
        B(this, "beforePrint");
        b && this.chartWidth > b && (c.resetParams = [this.options.chart.width, void 0, !1], this.setSize(b, void 0, !1));
        [].forEach.call(c.childNodes, function (a, b) {
          1 === a.nodeType && (c.origDisplay[b] = a.style.display, a.style.display = "none");
        });
        this.moveContainers(a);
        this.printReverseInfo = c;
      },
      afterPrint: function () {
        if (this.printReverseInfo) {
          var a = this.printReverseInfo.childNodes,
              b = this.printReverseInfo.origDisplay,
              c = this.printReverseInfo.resetParams;
          this.moveContainers(this.renderTo);
          [].forEach.call(a, function (a, c) {
            1 === a.nodeType && (a.style.display = b[c] || "");
          });
          this.isPrinting = !1;
          c && this.setSize.apply(this, c);
          delete this.printReverseInfo;
          delete f.printingChart;
          B(this, "afterPrint");
        }
      },
      print: function () {
        var a = this;
        a.isPrinting || (f.printingChart = a, f.isSafari || a.beforePrint(), setTimeout(function () {
          z.focus();
          z.print();
          f.isSafari || setTimeout(function () {
            a.afterPrint();
          }, 1E3);
        }, 1));
      },
      contextMenu: function (a, b, c, d, e, f, r) {
        var k = this,
            D = k.options.navigation,
            p = k.chartWidth,
            A = k.chartHeight,
            t = "cache-" + a,
            l = k[t],
            v = Math.max(e, f);

        if (!l) {
          k.exportContextMenu = k[t] = l = h("div", {
            className: a
          }, {
            position: "absolute",
            zIndex: 1E3,
            padding: v + "px",
            pointerEvents: "auto"
          }, k.fixedDiv || k.container);
          var m = h("ul", {
            className: "highcharts-menu"
          }, {
            listStyle: "none",
            margin: 0,
            padding: 0
          }, l);
          k.styledMode || u(m, x({
            MozBoxShadow: "3px 3px 10px #888",
            WebkitBoxShadow: "3px 3px 10px #888",
            boxShadow: "3px 3px 10px #888"
          }, D.menuStyle));

          l.hideMenu = function () {
            u(l, {
              display: "none"
            });
            r && r.setState(0);
            k.openMenu = !1;
            u(k.renderTo, {
              overflow: "hidden"
            });
            g.clearTimeout(l.hideTimer);
            B(k, "exportMenuHidden");
          };

          k.exportEvents.push(n(l, "mouseleave", function () {
            l.hideTimer = z.setTimeout(l.hideMenu, 500);
          }), n(l, "mouseenter", function () {
            g.clearTimeout(l.hideTimer);
          }), n(y, "mouseup", function (b) {
            k.pointer.inClass(b.target, a) || l.hideMenu();
          }), n(l, "click", function () {
            k.openMenu && l.hideMenu();
          }));
          b.forEach(function (a) {
            "string" === typeof a && (a = k.options.exporting.menuItemDefinitions[a]);

            if (J(a, !0)) {
              if (a.separator) var b = h("hr", null, null, m);else b = h("li", {
                className: "highcharts-menu-item",
                onclick: function (b) {
                  b && b.stopPropagation();
                  l.hideMenu();
                  a.onclick && a.onclick.apply(k, arguments);
                },
                innerHTML: a.text || k.options.lang[a.textKey]
              }, null, m), k.styledMode || (b.onmouseover = function () {
                u(this, D.menuItemHoverStyle);
              }, b.onmouseout = function () {
                u(this, D.menuItemStyle);
              }, u(b, x({
                cursor: "pointer"
              }, D.menuItemStyle)));
              k.exportDivElements.push(b);
            }
          });
          k.exportDivElements.push(m, l);
          k.exportMenuWidth = l.offsetWidth;
          k.exportMenuHeight = l.offsetHeight;
        }

        b = {
          display: "block"
        };
        c + k.exportMenuWidth > p ? b.right = p - c - e - v + "px" : b.left = c - v + "px";
        d + f + k.exportMenuHeight > A && "top" !== r.alignOptions.verticalAlign ? b.bottom = A - d - v + "px" : b.top = d + f - v + "px";
        u(l, b);
        u(k.renderTo, {
          overflow: ""
        });
        k.openMenu = !0;
        B(k, "exportMenuShown");
      },
      addButton: function (a) {
        var b = this,
            c = b.renderer,
            d = p(b.options.navigation.buttonOptions, a),
            g = d.onclick,
            e = d.menuItems,
            f = d.symbolSize || 12;
        b.btnCount || (b.btnCount = 0);
        b.exportDivElements || (b.exportDivElements = [], b.exportSVGElements = []);

        if (!1 !== d.enabled) {
          var k = d.theme,
              h = k.states,
              m = h && h.hover;
          h = h && h.select;
          var A;
          b.styledMode || (k.fill = q(k.fill, "#ffffff"), k.stroke = q(k.stroke, "none"));
          delete k.states;
          g ? A = function (a) {
            a && a.stopPropagation();
            g.call(b, a);
          } : e && (A = function (a) {
            a && a.stopPropagation();
            b.contextMenu(t.menuClassName, e, t.translateX, t.translateY, t.width, t.height, t);
            t.setState(2);
          });
          d.text && d.symbol ? k.paddingLeft = q(k.paddingLeft, 25) : d.text || x(k, {
            width: d.width,
            height: d.height,
            padding: 0
          });
          b.styledMode || (k["stroke-linecap"] = "round", k.fill = q(k.fill, "#ffffff"), k.stroke = q(k.stroke, "none"));
          var t = c.button(d.text, 0, 0, A, k, m, h).addClass(a.className).attr({
            title: q(b.options.lang[d._titleKey || d.titleKey], "")
          });
          t.menuClassName = a.menuClassName || "highcharts-menu-" + b.btnCount++;

          if (d.symbol) {
            var l = c.symbol(d.symbol, d.symbolX - f / 2, d.symbolY - f / 2, f, f, {
              width: f,
              height: f
            }).addClass("highcharts-button-symbol").attr({
              zIndex: 1
            }).add(t);
            b.styledMode || l.attr({
              stroke: d.symbolStroke,
              fill: d.symbolFill,
              "stroke-width": d.symbolStrokeWidth || 1
            });
          }

          t.add(b.exportingGroup).align(x(d, {
            width: t.width,
            x: q(d.x, b.buttonOffset)
          }), !0, "spacingBox");
          b.buttonOffset += (t.width + d.buttonSpacing) * ("right" === d.align ? -1 : 1);
          b.exportSVGElements.push(t, l);
        }
      },
      destroyExport: function (a) {
        var b = a ? a.target : this;
        a = b.exportSVGElements;
        var c = b.exportDivElements,
            d = b.exportEvents,
            f;
        a && (a.forEach(function (a, d) {
          a && (a.onclick = a.ontouchstart = null, f = "cache-" + a.menuClassName, b[f] && delete b[f], b.exportSVGElements[d] = a.destroy());
        }), a.length = 0);
        b.exportingGroup && (b.exportingGroup.destroy(), delete b.exportingGroup);
        c && (c.forEach(function (a, d) {
          g.clearTimeout(a.hideTimer);
          K(a, "mouseleave");
          b.exportDivElements[d] = a.onmouseout = a.onmouseover = a.ontouchstart = a.onclick = null;
          m(a);
        }), c.length = 0);
        d && (d.forEach(function (a) {
          a();
        }), d.length = 0);
      }
    });
    F.prototype.inlineToAttributes = "fill stroke strokeLinecap strokeLinejoin strokeWidth textAnchor x y".split(" ");
    F.prototype.inlineBlacklist = [/-/, /^(clipPath|cssText|d|height|width)$/, /^font$/, /[lL]ogical(Width|Height)$/, /perspective/, /TapHighlightColor/, /^transition/, /^length$/];
    F.prototype.unstyledElements = ["clipPath", "defs", "desc"];

    C.prototype.inlineStyles = function () {
      function a(a) {
        return a.replace(/([A-Z])/g, function (a, b) {
          return "-" + b.toLowerCase();
        });
      }

      function b(c) {
        function k(b, e) {
          v = u = !1;

          if (g) {
            for (q = g.length; q-- && !u;) u = g[q].test(e);

            v = !u;
          }

          "transform" === e && "none" === b && (v = !0);

          for (q = f.length; q-- && !v;) v = f[q].test(e) || "function" === typeof b;

          v || x[e] === b && "svg" !== c.nodeName || h[c.nodeName][e] === b || (-1 !== d.indexOf(e) ? c.setAttribute(a(e), b) : l += a(e) + ":" + b + ";");
        }

        var l = "",
            v,
            u,
            q;

        if (1 === c.nodeType && -1 === e.indexOf(c.nodeName)) {
          var r = z.getComputedStyle(c, null);
          var x = "svg" === c.nodeName ? {} : z.getComputedStyle(c.parentNode, null);

          if (!h[c.nodeName]) {
            m = n.getElementsByTagName("svg")[0];
            var w = n.createElementNS(c.namespaceURI, c.nodeName);
            m.appendChild(w);
            h[c.nodeName] = p(z.getComputedStyle(w, null));
            "text" === c.nodeName && delete h.text.fill;
            m.removeChild(w);
          }

          if (O || N) for (var y in r) k(r[y], y);else E(r, k);
          l && (r = c.getAttribute("style"), c.setAttribute("style", (r ? r + ";" : "") + l));
          "svg" === c.nodeName && c.setAttribute("stroke-width", "1px");
          "text" !== c.nodeName && [].forEach.call(c.children || c.childNodes, b);
        }
      }

      var c = this.renderer,
          d = c.inlineToAttributes,
          f = c.inlineBlacklist,
          g = c.inlineWhitelist,
          e = c.unstyledElements,
          h = {},
          m;
      c = y.createElement("iframe");
      u(c, {
        width: "1px",
        height: "1px",
        visibility: "hidden"
      });
      y.body.appendChild(c);
      var n = c.contentWindow.document;
      n.open();
      n.write('<svg xmlns="http://www.w3.org/2000/svg"></svg>');
      n.close();
      b(this.container.querySelector("svg"));
      m.parentNode.removeChild(m);
    };

    H.menu = function (a, b, c, d) {
      return ["M", a, b + 2.5, "L", a + c, b + 2.5, "M", a, b + d / 2 + .5, "L", a + c, b + d / 2 + .5, "M", a, b + d - 1.5, "L", a + c, b + d - 1.5];
    };

    H.menuball = function (a, b, c, d) {
      a = [];
      d = d / 3 - 2;
      return a = a.concat(this.circle(c - d, b, d, d), this.circle(c - d, b + d + 4, d, d), this.circle(c - d, b + 2 * (d + 4), d, d));
    };

    C.prototype.renderExporting = function () {
      var a = this,
          b = a.options.exporting,
          c = b.buttons,
          d = a.isDirtyExporting || !a.exportSVGElements;
      a.buttonOffset = 0;
      a.isDirtyExporting && a.destroyExport();
      d && !1 !== b.enabled && (a.exportEvents = [], a.exportingGroup = a.exportingGroup || a.renderer.g("exporting-group").attr({
        zIndex: 3
      }).add(), E(c, function (b) {
        a.addButton(b);
      }), a.isDirtyExporting = !1);
      n(a, "destroy", a.destroyExport);
    };

    n(C, "init", function () {
      var a = this;
      a.exporting = {
        update: function (b, c) {
          a.isDirtyExporting = !0;
          p(!0, a.options.exporting, b);
          q(c, !0) && a.redraw();
        }
      };
      e.addUpdate(function (b, c) {
        a.isDirtyExporting = !0;
        p(!0, a.options.navigation, b);
        q(c, !0) && a.redraw();
      }, a);
    });
    C.prototype.callbacks.push(function (a) {
      a.renderExporting();
      n(a, "redraw", a.renderExporting);
    });
  });
  m(e, "masters/modules/exporting.src.js", [], function () {});
});

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _styles_index_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles/index.scss */ "./src/styles/index.scss");
/* harmony import */ var _styles_index_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_styles_index_scss__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _scripts_card_searcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scripts/card_searcher */ "./src/scripts/card_searcher.js");
/* harmony import */ var _scripts_card_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scripts/card_generator */ "./src/scripts/card_generator.js");



window.addEventListener("DOMContentLoaded", function () {
  var board = document.createElement("div");
  var searchBar = document.createElement("form");
  var inputField = document.createElement("input");
  var submitButton = document.createElement("button");
  var searchIcon = document.createElement("i");
  var titleContainer = document.createElement('div');
  var title = document.createElement("h1");
  var titleImg = document.createElement("img");
  var navContainer = document.createElement('div');
  var gitLinkImg = document.createElement("i");
  var linkedinLinkImg = document.createElement("i");
  var angelLinkImg = document.createElement("i");
  var gitLink = document.createElement("a");
  var linkedinLink = document.createElement("a");
  var angelLink = document.createElement("a");
  var errorsContainer = document.createElement("div");
  var instructionsContainer = document.createElement('div');
  var instructionsButton = document.createElement("i");
  instructionsContainer.classList.add('instructions-container');
  instructionsContainer.append(instructionsButton);
  errorsContainer.setAttribute('id', "errors-container");
  gitLink.append(gitLinkImg);
  gitLink.classList.add('nav-link');
  gitLink.setAttribute("href", "https://github.com/Norton-Design/cardAugury");
  gitLink.setAttribute("target", "_blank");
  gitLink.setAttribute("rel", "noopener noreferrer");
  gitLink.setAttribute('title', 'Github Repo');
  linkedinLink.append(linkedinLinkImg);
  linkedinLink.classList.add('nav-link');
  linkedinLink.setAttribute("href", "https://www.linkedin.com/in/michael-norton-5b5559199/");
  linkedinLink.setAttribute("target", "_blank");
  linkedinLink.setAttribute("rel", "noopener noreferrer");
  linkedinLink.setAttribute('title', 'Linkedin Link');
  angelLink.append(angelLinkImg);
  angelLink.classList.add('nav-link');
  angelLink.setAttribute("href", "https://angel.co/u/michael-norton-17");
  angelLink.setAttribute("target", "_blank");
  angelLink.setAttribute("rel", "noopener noreferrer");
  angelLink.setAttribute("title", "Angellist Link");
  document.body.classList.add("center");
  document.body.append(board);
  board.classList.add("board", "center");
  board.setAttribute('id', "main-board");
  board.append(instructionsContainer);
  board.append(errorsContainer);
  board.append(titleContainer);
  board.append(searchBar);
  board.append(navContainer);
  titleContainer.append(titleImg);
  titleContainer.append(title);
  titleContainer.classList.add("title-container");
  navContainer.append(gitLink);
  navContainer.append(linkedinLink);
  navContainer.append(angelLink);
  navContainer.classList.add('nav');
  titleImg.setAttribute("src", "./src/images/final-owl2.png");
  title.innerHTML = "Card Augury";
  searchIcon.classList.add("fa");
  searchIcon.classList.add("fa-search");
  linkedinLinkImg.classList.add('fa');
  linkedinLinkImg.classList.add('fa-linkedin');
  gitLinkImg.classList.add('fa');
  gitLinkImg.classList.add('fa-github');
  angelLinkImg.classList.add('fa');
  angelLinkImg.classList.add('fa-angellist');
  submitButton.append(searchIcon);
  submitButton.classList.add('search-button');
  instructionsButton.classList.add("fa");
  instructionsButton.classList.add("fa-bars");
  inputField.setAttribute("id", "searchbar");
  inputField.setAttribute("placeholder", "Search for a card...");
  inputField.classList.add("searchbar");
  searchBar.classList.add("searchbar-container");
  searchBar.append(inputField);
  searchBar.append(submitButton);
  var modal = document.getElementById("modal");
  var span = document.getElementsByClassName("close")[0];

  window.onclick = function (event) {
    if (event.target == modal) {
      modal.style.display = "none";
    }
  };

  span.onclick = function () {
    modal.style.display = "none";
  };

  instructionsButton.onclick = function () {
    modal.style.display = "block";
  };

  submitButton.addEventListener('click', function (e) {
    e.preventDefault();
    Object(_scripts_card_searcher__WEBPACK_IMPORTED_MODULE_1__["cardSearcher"])().then(function (card) {
      var navCon = document.getElementsByClassName("nav")[0];

      if (navCon) {
        board.removeChild(navContainer);
      }

      Object(_scripts_card_generator__WEBPACK_IMPORTED_MODULE_2__["cardGenerator"])(card);
      board.append(navContainer);

      if (card.object) {
        board.style.margin = "0 5rem 0 rem 5rem";
        board.style.minHeight = 'inherit';
      }

      instructionsContainer.style.margin = "1.2rem 0";
    });
  });
});

/***/ }),

/***/ "./src/scripts/card_generator.js":
/*!***************************************!*\
  !*** ./src/scripts/card_generator.js ***!
  \***************************************/
/*! exports provided: cardGenerator, capitalize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cardGenerator", function() { return cardGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "capitalize", function() { return capitalize; });
/* harmony import */ var _set_fetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./set_fetcher */ "./src/scripts/set_fetcher.js");
/* harmony import */ var _set_stats_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./set_stats_util */ "./src/scripts/set_stats_util.js");
/* harmony import */ var _card_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./card_util */ "./src/scripts/card_util.js");
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! babel-polyfill */ "./node_modules/babel-polyfill/lib/index.js");
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(babel_polyfill__WEBPACK_IMPORTED_MODULE_3__);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }






var Highcharts = __webpack_require__(/*! highcharts */ "./node_modules/highcharts/highcharts.js");

__webpack_require__(/*! highcharts/modules/exporting */ "./node_modules/highcharts/modules/exporting.js")(Highcharts);

var cardGenerator = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(cardInfo) {
    var board, prevContainer, cardContainer, setStatContainer, imgLink, setBarChartPlaceholder, setPieChartPlaceholder, pieLoadingIcon, barLoadingIcon;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            board = document.getElementById("main-board");
            prevContainer = document.getElementById("card-container");
            cardContainer = document.createElement("div");
            setStatContainer = document.createElement('div');
            imgLink = cardInfo.image_uris.normal;
            setBarChartPlaceholder = document.createElement('div');
            setPieChartPlaceholder = document.createElement('div');
            pieLoadingIcon = document.createElement("i");
            barLoadingIcon = document.createElement("i");
            if (prevContainer) board.removeChild(prevContainer);
            pieLoadingIcon.classList.add("fa");
            pieLoadingIcon.classList.add("fa-spinner");
            barLoadingIcon.classList.add("fa");
            barLoadingIcon.classList.add("fa-spinner");
            setStatContainer.classList.add('set-stats-container');
            setBarChartPlaceholder.setAttribute("id", "set-bar-ph"); // <--- TARGET TO REPLACE THE BARCHART

            setPieChartPlaceholder.setAttribute("id", "set-pie-ph"); // <--- TARGET TO REPLACE THE PIECHART

            setBarChartPlaceholder.append(barLoadingIcon);
            setPieChartPlaceholder.append(pieLoadingIcon);
            board.append(cardContainer);
            setStatContainer.append(setBarChartPlaceholder);
            setStatContainer.append(setPieChartPlaceholder);
            cardContainer.append(imgCreator(imgLink));
            cardContainer.append(statBlockCreator(cardInfo));
            cardContainer.append(setStatContainer);
            cardContainer.setAttribute("id", "card-container");
            cardContainer.classList.add("card-container");
            Object(_set_fetcher__WEBPACK_IMPORTED_MODULE_0__["setFetcher"])(cardInfo).then(function (cardSet) {
              return setStatsCreator(cardInfo, cardSet);
            });

          case 28:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function cardGenerator(_x) {
    return _ref.apply(this, arguments);
  };
}();

var imgCreator = function imgCreator(imgLink) {
  var imgContainer = document.createElement("div");
  imgContainer.classList.add("image-container");
  var img = document.createElement("img");
  img.setAttribute("src", imgLink);
  imgContainer.append(img);
  return imgContainer;
};

var statBlockCreator = function statBlockCreator(cardInfo) {
  var name = cardInfo.name,
      mana_cost = cardInfo.mana_cost,
      rarity = cardInfo.rarity,
      oracle_text = cardInfo.oracle_text,
      set_name = cardInfo.set_name,
      type_line = cardInfo.type_line,
      flavor_text = cardInfo.flavor_text,
      legalities = cardInfo.legalities;
  var statBlockContainer = document.createElement("ul");
  statBlockContainer.classList.add("stat-block-container");
  var cardTitle = document.createElement("li");
  var title = document.createElement("h2");
  var cardCost = document.createElement("div");
  cardCost.append(Object(_card_util__WEBPACK_IMPORTED_MODULE_2__["manaImageGenerator"])(mana_cost));
  title.innerHTML = name;
  cardTitle.append(title);
  cardTitle.append(cardCost);
  cardTitle.classList.add("card-title-container");
  statBlockContainer.append(cardTitle); // SET THE LIST VALUES FOR THE CARD

  var hr = document.createElement("hr");
  statBlockContainer.append(hr);
  var cardType = document.createElement("li");
  cardType.innerHTML = capitalize(rarity) + ' ' + type_line;
  statBlockContainer.append(cardType);
  var cardSetName = document.createElement("li");
  cardSetName.innerHTML = set_name;
  statBlockContainer.append(cardSetName);
  statBlockContainer.append(document.createElement("hr"));
  Object(_card_util__WEBPACK_IMPORTED_MODULE_2__["oracleTextHandler"])(oracle_text, statBlockContainer);

  if (flavor_text) {
    var cardFlavorText = document.createElement("li");
    cardFlavorText.classList.add('flavor');
    cardFlavorText.innerHTML = flavor_text;
    statBlockContainer.append(cardFlavorText);
  }

  var legalitiesContainer = document.createElement('li');
  legalitiesContainer.classList.add('legalities-container');
  Object(_card_util__WEBPACK_IMPORTED_MODULE_2__["buildLegalities"])(legalities, legalitiesContainer);
  statBlockContainer.append(legalitiesContainer);
  return statBlockContainer;
};

var setStatsCreator = function setStatsCreator(cardInfo, cardSet) {
  // console.log(cardSet);
  Object(_set_stats_util__WEBPACK_IMPORTED_MODULE_1__["typeTotals"])(cardSet).then(function (totalBreakdown) {
    // console.log(totalBreakdown);
    var typeChart = Highcharts.chart("set-pie-ph", {
      chart: {
        plotBackgroundColor: null,
        plotBorderWidth: null,
        plotShadow: false,
        type: 'pie'
      },
      title: {
        text: "Card Types (".concat(cardInfo.set_name, ")"),
        style: {
          "font-family": "$title-font",
          "font-size": "1rem"
        }
      },
      tooltip: {
        pointFormat: '{series.name}: {point.percentage:.1f}%',
        footerFormat: '\n ({point.y})'
      },
      accessibility: {
        point: {
          valueSuffix: '%'
        }
      },
      plotOptions: {
        pie: {
          allowPointSelect: true,
          cursor: 'pointer',
          dataLabels: {
            enabled: true,
            format: '{point.name}',
            style: {
              fontWeight: 400,
              fontFamily: "$body-font"
            }
          }
        }
      },
      series: [{
        name: 'Types',
        colorByPoint: true,
        data: Object.entries(totalBreakdown.types).sort(function (a, b) {
          return a[1] - b[1];
        }).reverse().map(function (pair) {
          return {
            name: pair[0],
            y: pair[1]
          };
        })
      }]
    });
    var valueChart = Highcharts.chart("set-bar-ph", {
      chart: {
        type: 'column'
      },
      title: {
        text: "Most Valued (".concat(cardInfo.set_name, ")"),
        style: {
          "font-family": "$title-font",
          "font-size": "1rem"
        }
      },
      xAxis: {
        categories: totalBreakdown.nonPromoTopTen.map(function (card) {
          return card.name;
        }),
        crosshair: true,
        labels: {
          enabled: false
        }
      },
      yAxis: {
        min: 0,
        title: {
          text: 'USD',
          enabled: false
        } // opposite: true

      },
      tooltip: {
        headerFormat: '<span style="font-size:10px">{point.key}</span><table>',
        pointFormat: '<tr><td style="color:{series.color};padding:0">{series.name}: </td>' + '<td style="padding:0"><b>${point.y:.1f}</b></td></tr>',
        footerFormat: '</table>',
        shared: true,
        useHTML: true
      },
      plotOptions: {
        column: {
          pointPadding: 0.2,
          borderWidth: 0
        }
      },
      series: [{
        name: 'Value',
        colorByPoint: true,
        data: totalBreakdown.nonPromoTopTen.map(function (card) {
          return parseFloat(card.prices.usd);
        }),
        showInLegend: false
      }]
    });
  });
};

var capitalize = function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

/***/ }),

/***/ "./src/scripts/card_searcher.js":
/*!**************************************!*\
  !*** ./src/scripts/card_searcher.js ***!
  \**************************************/
/*! exports provided: card, cardSearcher, validSearchInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "card", function() { return card; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cardSearcher", function() { return cardSearcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validSearchInput", function() { return validSearchInput; });
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-polyfill */ "./node_modules/babel-polyfill/lib/index.js");
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_polyfill__WEBPACK_IMPORTED_MODULE_0__);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var card;

var cardSearcher = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e) {
    var inputStr, url, searchUrl, errorTarget, response, json, errorBanner, error, board;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            inputStr = document.getElementById("searchbar").value;
            url = 'https://api.scryfall.com/cards/named?fuzzy=';
            searchUrl = url + validSearchInput(inputStr);
            errorTarget = document.getElementById("errors-container");
            _context.next = 6;
            return fetch(searchUrl);

          case 6:
            response = _context.sent;
            _context.next = 9;
            return response.json();

          case 9:
            json = _context.sent;
            errorTarget.innerHTML = '';
            _context.next = 13;
            return json;

          case 13:
            card = _context.sent;

            if (!(card.object === "error")) {
              _context.next = 27;
              break;
            }

            //make error and append to board.input
            errorBanner = document.createElement('div');
            error = document.createElement('h2');
            board = document.getElementsByClassName("board")[0];
            board.style.margin = "5rem";
            errorBanner.setAttribute('id', "error-sub");
            error.setAttribute('id', 'error-message');
            error.innerHTML = card.details;
            errorBanner.append(error);
            errorTarget.append(errorBanner);
            return _context.abrupt("return");

          case 27:
            console.log(card);

          case 28:
            return _context.abrupt("return", card);

          case 29:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function cardSearcher(_x) {
    return _ref.apply(this, arguments);
  };
}();
var validSearchInput = function validSearchInput(searchInput) {
  return searchInput.split(' ').join("-");
};

/***/ }),

/***/ "./src/scripts/card_util.js":
/*!**********************************!*\
  !*** ./src/scripts/card_util.js ***!
  \**********************************/
/*! exports provided: manaImageGenerator, oracleTextHandler, buildLegalities */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "manaImageGenerator", function() { return manaImageGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "oracleTextHandler", function() { return oracleTextHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildLegalities", function() { return buildLegalities; });
/* harmony import */ var _card_generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./card_generator */ "./src/scripts/card_generator.js");

var manaImageGenerator = function manaImageGenerator(manaStr) {
  var results = document.createElement('div');
  results.classList.add("mana-symbol-container");
  if (!manaStr) return results;
  var subStr = '';

  for (var i = 0; i < manaStr.length; i++) {
    var letter = manaStr[i];

    if (letter === '{') {
      subStr = '';
    } else if (letter === '}') {
      var img = document.createElement("img");
      img.setAttribute("src", "https://img.scryfall.com/symbology/".concat(subStr, ".svg"));
      results.append(img);
    } else {
      subStr = subStr + letter;
    }
  }

  return results;
};
var oracleTextHandler = function oracleTextHandler(textStr, parentCon) {
  var collection = textStr.split("\n");
  collection.forEach(function (subStr) {
    var newListItem = document.createElement('li');
    newListItem.classList.add('oracle');
    newListItem.innerHTML = subStr;
    parentCon.append(newListItem);
  });
};
var buildLegalities = function buildLegalities(legalObj, legContainer) {
  var relevantFormats = ['commander', 'standard', 'pioneer', 'modern', 'historic', 'pauper', 'legacy', 'vintage', 'brawl', 'penny'];
  var innerContainer = document.createElement('dl');
  relevantFormats.forEach(function (formatStr) {
    var legalStatus = document.createElement('dd');
    legalStatus.classList.add('legal-status');
    var format = document.createElement('dt');
    format.innerHTML = Object(_card_generator__WEBPACK_IMPORTED_MODULE_0__["capitalize"])(formatStr);
    format.classList.add('format-name');

    switch (legalObj[formatStr]) {
      case 'legal':
        legalStatus.innerHTML = "LEGAL";
        legalStatus.classList.add('legal');
        break;

      case 'not_legal':
        legalStatus.innerHTML = "NOT LEGAL";
        legalStatus.classList.add('not-legal');
        break;

      case 'banned':
        legalStatus.innerHTML = "BANNED";
        legalStatus.classList.add('banned');
        break;

      case 'restricted':
        legalStatus.innerHTML = "REST.";
        legalStatus.classList.add('rest');
        break;
    }

    innerContainer.append(format);
    innerContainer.append(legalStatus);
  });
  legContainer.append(innerContainer);
};

/***/ }),

/***/ "./src/scripts/set_fetcher.js":
/*!************************************!*\
  !*** ./src/scripts/set_fetcher.js ***!
  \************************************/
/*! exports provided: setFetcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setFetcher", function() { return setFetcher; });
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-polyfill */ "./node_modules/babel-polyfill/lib/index.js");
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_polyfill__WEBPACK_IMPORTED_MODULE_0__);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }


var setFetcher = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(cardInfo) {
    var searchUrl, response, json, nextUrl, nextResponse, nextJson, finalUrl, finalResponse, finalJson;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            searchUrl = "https://api.scryfall.com/cards/search?order=usd&q=e%3A".concat(cardInfo.set, "&unique=prints");
            _context.next = 3;
            return fetch(searchUrl);

          case 3:
            response = _context.sent;
            _context.next = 6;
            return response.json();

          case 6:
            json = _context.sent;

            if (!json.has_more) {
              _context.next = 29;
              break;
            }

            nextUrl = json.next_page;
            _context.next = 11;
            return fetch(nextUrl);

          case 11:
            nextResponse = _context.sent;
            _context.next = 14;
            return nextResponse.json();

          case 14:
            nextJson = _context.sent;

            if (!nextJson.has_more) {
              _context.next = 26;
              break;
            }

            finalUrl = nextJson.next_page;
            _context.next = 19;
            return fetch(finalUrl);

          case 19:
            finalResponse = _context.sent;
            _context.next = 22;
            return finalResponse.json();

          case 22:
            finalJson = _context.sent;
            return _context.abrupt("return", setMerge([json, nextJson, finalJson]));

          case 26:
            return _context.abrupt("return", setMerge([json, nextJson]));

          case 27:
            _context.next = 32;
            break;

          case 29:
            _context.next = 31;
            return json;

          case 31:
            return _context.abrupt("return", _context.sent);

          case 32:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function setFetcher(_x) {
    return _ref.apply(this, arguments);
  };
}();

var setMerge = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(arrOfSets) {
    var baseSet, i, mergingSet;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            baseSet = arrOfSets[0];

            for (i = 1; i < arrOfSets.length; i++) {
              mergingSet = arrOfSets[i];
              baseSet.data = baseSet.data.concat(mergingSet.data);
            }

            return _context2.abrupt("return", baseSet);

          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function setMerge(_x2) {
    return _ref2.apply(this, arguments);
  };
}();

/***/ }),

/***/ "./src/scripts/set_stats_util.js":
/*!***************************************!*\
  !*** ./src/scripts/set_stats_util.js ***!
  \***************************************/
/*! exports provided: typeTotals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typeTotals", function() { return typeTotals; });
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-polyfill */ "./node_modules/babel-polyfill/lib/index.js");
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_polyfill__WEBPACK_IMPORTED_MODULE_0__);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }


var typeTotals = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(set) {
    var MTGCARDTYPES, cards, stats, i, card, currentCardTypes, cardValue;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            // return obj with all types as keys except basic lands
            MTGCARDTYPES = ['Artifact', 'Creature', 'Enchantment', 'Instant', 'Land', 'Planeswalker', 'Sorcery', 'Tribal'];
            cards = set.data;
            stats = {
              nonBasicsTotal: 0,
              totalSetValue: 0,
              nonPromoTopTen: [],
              totalSetValueAverage: 0,
              types: {},
              subTypes: {}
            };
            i = 0;

          case 4:
            if (!(i < cards.length)) {
              _context.next = 22;
              break;
            }

            card = cards[i];
            currentCardTypes = void 0; // REMOVE PROMO CARDS FROM THE POOL BECAUSE THEY'RE DUPES

            if (!card.promo) {
              _context.next = 9;
              break;
            }

            return _context.abrupt("continue", 19);

          case 9:
            currentCardTypes = typeLineParser(card.type_line); // <-- 

            if (!currentCardTypes.includes('Basic')) {
              _context.next = 14;
              break;
            }

            return _context.abrupt("continue", 19);

          case 14:
            cardValue = typeof card.prices.usd === "undefined" || card.prices.usd === null ? 0 : parseFloat(card.prices.usd);
            currentCardTypes.forEach(function (type) {
              if (MTGCARDTYPES.includes(type) && typeof stats.types[type] === 'undefined') {
                stats.types[type] = 1;
              } else if (MTGCARDTYPES.includes(type)) {
                stats.types[type] += 1;
              } else if (!MTGCARDTYPES.includes(type) && typeof stats.subTypes[type] === 'undefined') {
                stats.subTypes[type] = 1;
              } else {
                stats.subTypes[type] += 1;
              }
            });
            stats.nonBasicsTotal += 1;
            stats.totalSetValue += cardValue;

            if (stats.nonPromoTopTen.length < 10) {
              stats.nonPromoTopTen.push(card);
            }

          case 19:
            i++;
            _context.next = 4;
            break;

          case 22:
            stats.nonPromoTopTenValueAverage = cardAverager(stats.nonPromoTopTen);
            stats.totalSetValueAverage = stats.totalSetValue / stats.nonBasicsTotal;
            return _context.abrupt("return", stats);

          case 25:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function typeTotals(_x) {
    return _ref.apply(this, arguments);
  };
}();

var cardAverager = function cardAverager(cardArr) {
  var total = 0;
  cardArr.forEach(function (card) {
    return total += parseFloat(card.prices.usd);
  });
  return total / cardArr.length;
};

var typeLineParser = function typeLineParser(typeLineStr) {
  var typeArr = typeLineStr.split(' ');
  return typeArr.filter(function (type) {
    return type.length > 2;
  });
};

/***/ }),

/***/ "./src/styles/index.scss":
/*!*******************************!*\
  !*** ./src/styles/index.scss ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXBvbHlmaWxsL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcG9seWZpbGwvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1udW1iZXItdmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkdmFuY2Utc3RyaW5nLWluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1maWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19iaW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1pc28tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhdHRlbi1pbnRvLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mdW5jdGlvbi10by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1mcm91bmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1sb2cxcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLXNjYWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZm9yY2VkLXBhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX293bi1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWZsb2F0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wZXJmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb21pc2UtcmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy1hYnN0cmFjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZXBsYWNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1jb2xsZWN0aW9uLWZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1zcGVjaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaWN0LW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWh0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXBhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcmVwZWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy10cmltLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy13cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190YXNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VzZXItYWdlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdmFsaWRhdGUtY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmluZGV4LW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmpvaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkub2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zbGljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb21lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLm5vdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1qc29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYWNvc2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmF0YW5oLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2JydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY29zaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5pbXVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2luaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRhbmguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lmhhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5leGVjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ibGluay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udGNvbG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDMyLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstc2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmZsYXQtbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXNhcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLm9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguY2xhbXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5kZWctcGVyLXJhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmRlZ3JlZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5mc2NhbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pYWRkaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmltdWxoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaXN1YmguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5yYWQtcGVyLWRlZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnJhZGlhbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5zY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnNpZ25iaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC51bXVsaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnByb21pc2UudHJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC5mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC5vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcuYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLXNldC5mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstc2V0Lm9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudGltZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL3NoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpZ2hjaGFydHMvaGlnaGNoYXJ0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlnaGNoYXJ0cy9tb2R1bGVzL2V4cG9ydGluZy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9jYXJkX2dlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9jYXJkX3NlYXJjaGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2NhcmRfdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9zZXRfZmV0Y2hlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9zZXRfc3RhdHNfdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL2luZGV4LnNjc3MiXSwibmFtZXMiOlsid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImJvYXJkIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic2VhcmNoQmFyIiwiaW5wdXRGaWVsZCIsInN1Ym1pdEJ1dHRvbiIsInNlYXJjaEljb24iLCJ0aXRsZUNvbnRhaW5lciIsInRpdGxlIiwidGl0bGVJbWciLCJuYXZDb250YWluZXIiLCJnaXRMaW5rSW1nIiwibGlua2VkaW5MaW5rSW1nIiwiYW5nZWxMaW5rSW1nIiwiZ2l0TGluayIsImxpbmtlZGluTGluayIsImFuZ2VsTGluayIsImVycm9yc0NvbnRhaW5lciIsImluc3RydWN0aW9uc0NvbnRhaW5lciIsImluc3RydWN0aW9uc0J1dHRvbiIsImNsYXNzTGlzdCIsImFkZCIsImFwcGVuZCIsInNldEF0dHJpYnV0ZSIsImJvZHkiLCJpbm5lckhUTUwiLCJtb2RhbCIsImdldEVsZW1lbnRCeUlkIiwic3BhbiIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJvbmNsaWNrIiwiZXZlbnQiLCJ0YXJnZXQiLCJzdHlsZSIsImRpc3BsYXkiLCJlIiwicHJldmVudERlZmF1bHQiLCJjYXJkU2VhcmNoZXIiLCJ0aGVuIiwiY2FyZCIsIm5hdkNvbiIsInJlbW92ZUNoaWxkIiwiY2FyZEdlbmVyYXRvciIsIm9iamVjdCIsIm1hcmdpbiIsIm1pbkhlaWdodCIsIkhpZ2hjaGFydHMiLCJyZXF1aXJlIiwiY2FyZEluZm8iLCJwcmV2Q29udGFpbmVyIiwiY2FyZENvbnRhaW5lciIsInNldFN0YXRDb250YWluZXIiLCJpbWdMaW5rIiwiaW1hZ2VfdXJpcyIsIm5vcm1hbCIsInNldEJhckNoYXJ0UGxhY2Vob2xkZXIiLCJzZXRQaWVDaGFydFBsYWNlaG9sZGVyIiwicGllTG9hZGluZ0ljb24iLCJiYXJMb2FkaW5nSWNvbiIsImltZ0NyZWF0b3IiLCJzdGF0QmxvY2tDcmVhdG9yIiwic2V0RmV0Y2hlciIsImNhcmRTZXQiLCJzZXRTdGF0c0NyZWF0b3IiLCJpbWdDb250YWluZXIiLCJpbWciLCJuYW1lIiwibWFuYV9jb3N0IiwicmFyaXR5Iiwib3JhY2xlX3RleHQiLCJzZXRfbmFtZSIsInR5cGVfbGluZSIsImZsYXZvcl90ZXh0IiwibGVnYWxpdGllcyIsInN0YXRCbG9ja0NvbnRhaW5lciIsImNhcmRUaXRsZSIsImNhcmRDb3N0IiwibWFuYUltYWdlR2VuZXJhdG9yIiwiaHIiLCJjYXJkVHlwZSIsImNhcGl0YWxpemUiLCJjYXJkU2V0TmFtZSIsIm9yYWNsZVRleHRIYW5kbGVyIiwiY2FyZEZsYXZvclRleHQiLCJsZWdhbGl0aWVzQ29udGFpbmVyIiwiYnVpbGRMZWdhbGl0aWVzIiwidHlwZVRvdGFscyIsInRvdGFsQnJlYWtkb3duIiwidHlwZUNoYXJ0IiwiY2hhcnQiLCJwbG90QmFja2dyb3VuZENvbG9yIiwicGxvdEJvcmRlcldpZHRoIiwicGxvdFNoYWRvdyIsInR5cGUiLCJ0ZXh0IiwidG9vbHRpcCIsInBvaW50Rm9ybWF0IiwiZm9vdGVyRm9ybWF0IiwiYWNjZXNzaWJpbGl0eSIsInBvaW50IiwidmFsdWVTdWZmaXgiLCJwbG90T3B0aW9ucyIsInBpZSIsImFsbG93UG9pbnRTZWxlY3QiLCJjdXJzb3IiLCJkYXRhTGFiZWxzIiwiZW5hYmxlZCIsImZvcm1hdCIsImZvbnRXZWlnaHQiLCJmb250RmFtaWx5Iiwic2VyaWVzIiwiY29sb3JCeVBvaW50IiwiZGF0YSIsIk9iamVjdCIsImVudHJpZXMiLCJ0eXBlcyIsInNvcnQiLCJhIiwiYiIsInJldmVyc2UiLCJtYXAiLCJwYWlyIiwieSIsInZhbHVlQ2hhcnQiLCJ4QXhpcyIsImNhdGVnb3JpZXMiLCJub25Qcm9tb1RvcFRlbiIsImNyb3NzaGFpciIsImxhYmVscyIsInlBeGlzIiwibWluIiwiaGVhZGVyRm9ybWF0Iiwic2hhcmVkIiwidXNlSFRNTCIsImNvbHVtbiIsInBvaW50UGFkZGluZyIsImJvcmRlcldpZHRoIiwicGFyc2VGbG9hdCIsInByaWNlcyIsInVzZCIsInNob3dJbkxlZ2VuZCIsInN0ciIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJpbnB1dFN0ciIsInZhbHVlIiwidXJsIiwic2VhcmNoVXJsIiwidmFsaWRTZWFyY2hJbnB1dCIsImVycm9yVGFyZ2V0IiwiZmV0Y2giLCJyZXNwb25zZSIsImpzb24iLCJlcnJvckJhbm5lciIsImVycm9yIiwiZGV0YWlscyIsImNvbnNvbGUiLCJsb2ciLCJzZWFyY2hJbnB1dCIsInNwbGl0Iiwiam9pbiIsIm1hbmFTdHIiLCJyZXN1bHRzIiwic3ViU3RyIiwiaSIsImxlbmd0aCIsImxldHRlciIsInRleHRTdHIiLCJwYXJlbnRDb24iLCJjb2xsZWN0aW9uIiwiZm9yRWFjaCIsIm5ld0xpc3RJdGVtIiwibGVnYWxPYmoiLCJsZWdDb250YWluZXIiLCJyZWxldmFudEZvcm1hdHMiLCJpbm5lckNvbnRhaW5lciIsImZvcm1hdFN0ciIsImxlZ2FsU3RhdHVzIiwic2V0IiwiaGFzX21vcmUiLCJuZXh0VXJsIiwibmV4dF9wYWdlIiwibmV4dFJlc3BvbnNlIiwibmV4dEpzb24iLCJmaW5hbFVybCIsImZpbmFsUmVzcG9uc2UiLCJmaW5hbEpzb24iLCJzZXRNZXJnZSIsImFyck9mU2V0cyIsImJhc2VTZXQiLCJtZXJnaW5nU2V0IiwiY29uY2F0IiwiTVRHQ0FSRFRZUEVTIiwiY2FyZHMiLCJzdGF0cyIsIm5vbkJhc2ljc1RvdGFsIiwidG90YWxTZXRWYWx1ZSIsInRvdGFsU2V0VmFsdWVBdmVyYWdlIiwic3ViVHlwZXMiLCJjdXJyZW50Q2FyZFR5cGVzIiwicHJvbW8iLCJ0eXBlTGluZVBhcnNlciIsImluY2x1ZGVzIiwiY2FyZFZhbHVlIiwicHVzaCIsIm5vblByb21vVG9wVGVuVmFsdWVBdmVyYWdlIiwiY2FyZEF2ZXJhZ2VyIiwiY2FyZEFyciIsInRvdGFsIiwidHlwZUxpbmVTdHIiLCJ0eXBlQXJyIiwiZmlsdGVyIl0sIm1hcHBpbmdzIjoiO1FBQUE7UUFD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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNB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QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx5QkFBeUI7QUFDekIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUU7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wseUJBQXlCO0FBQ3pCLEtBQUs7QUFDTCx1QkFBdUI7O0FBRXZCLDJCQUEyQjs7QUFFM0IsMEJBQTBCOztBQUUxQiwyQkFBMkI7QUFDM0IsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLEU7Ozs7Ozs7Ozs7OztBQ2hrQmE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLDREQUFXOztBQUVoQyxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBZ0I7O0FBRTFDLGNBQWMsbUJBQU8sQ0FBQyw4REFBWTs7QUFFbEMsYUFBYSxtQkFBTyxDQUFDLDBEQUFVOztBQUUvQixXQUFXLG1CQUFPLENBQUMsd0RBQVM7O0FBRTVCLGtCQUFrQixtQkFBTyxDQUFDLHdFQUFpQjs7QUFFM0MsWUFBWSxtQkFBTyxDQUFDLDBEQUFVOztBQUU5QixpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBZ0I7O0FBRXpDLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFlOztBQUV2QyxlQUFlLG1CQUFPLENBQUMsa0VBQWM7O0FBRXJDLGNBQWMsbUJBQU8sQ0FBQyxnRUFBYTs7QUFFbkMsV0FBVyxtQkFBTyxDQUFDLHNFQUFnQjs7QUFFbkMsU0FBUyxtQkFBTyxDQUFDLGtFQUFjOztBQUUvQixnQkFBZ0IsbUJBQU8sQ0FBQyxvRUFBZTs7QUFFdkMscUJBQXFCLG1CQUFPLENBQUMsa0ZBQXNCOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTs7QUFFQSxRQUFRLFVBQVU7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFdBQVc7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSSxlQUFlLElBQUksZUFBZSxJQUFJO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQ0FBaUMsSUFBSSxlQUFlLElBQUksZUFBZSxJQUFJO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEVBQUU7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxXQUFXO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRSxxQ0FBcUMsT0FBTztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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Q0EsU0FBUzs7QUFFVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixRQUFROztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQSwrQkFBK0IsS0FBSzs7QUFFcEM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsRUFBRSxrQkFBa0IsVUFBVTtBQUNuRDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVcsZ0RBQWdELFFBQVE7QUFDbkU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0EsU0FBUyxFQUFFLEtBQUs7QUFDaEIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7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Q2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixHQUFHOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtNQUFrTSx1UUFBdVE7QUFDemMsZ0dBQWdHO0FBQ2hHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFVBQVU7QUFDaEUsMENBQTBDLFlBQVksaUJBQWlCLFlBQVksTUFBTSxRQUFRO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCLG1DQUFtQyw4QkFBOEIsaUNBQWlDO0FBQ3pKO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxFQUFFLHVKQUF1SixpQ0FBaUMsc0JBQXNCO0FBQ3pOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQsT0FBTztBQUM5RCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRFQUE0RTtBQUN2RjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkJBQTJCLDBEQUEwRCwwREFBMEQ7QUFDOUssU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVHQUF1RztBQUN2RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3R0FBd0csc0JBQXNCLCtCQUErQixjQUFjO0FBQzNLOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0IsS0FBSywwQkFBMEI7QUFDM0UsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbURBQW1EO0FBQzVEO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUEsd0JBQXdCLGNBQWM7QUFDdEMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLEtBQUs7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsb0JBQW9COztBQUV2QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHFCQUFxQixjQUFjLHFKQUFxSixXQUFXLGNBQWM7QUFDak47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxXQUFXOztBQUU1QztBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixLQUFLOztBQUUvQjs7QUFFQSwwQkFBMEIsS0FBSzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixLQUFLO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSwwQkFBMEIsS0FBSzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxLQUFLO0FBQ3pDLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SDtBQUN4SCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBLGdDQUFnQztBQUNoQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsbUJBQW1CO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDhFQUE4RSxLQUFLOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixjQUFjOztBQUVuQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBLGFBQWEsRUFBRTtBQUNmLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixPQUFPO0FBQzFCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FB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Zjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNElBQTRJLGVBQWUsRUFBRSxtVEFBbVQsNEJBQTRCO0FBQzVlO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsV0FBVzs7QUFFekM7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEIsV0FBVzs7QUFFdkMsd0pBQXdKO0FBQ3hKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtEO0FBQ2xELGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILDZEQUE2RDtBQUM3RCxDQUFDLEU7Ozs7Ozs7Ozs7O0FDeHRCRCxNQUFNOztBQUVOO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNENBQTRDOzs7QUFHNUMsbUI7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUFBLE1BQU0sQ0FBQ0MsZ0JBQVAsQ0FBd0Isa0JBQXhCLEVBQTRDLFlBQU07QUFDaEQsTUFBTUMsS0FBSyxHQUFHQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBZDtBQUNBLE1BQU1DLFNBQVMsR0FBR0YsUUFBUSxDQUFDQyxhQUFULENBQXVCLE1BQXZCLENBQWxCO0FBQ0EsTUFBTUUsVUFBVSxHQUFHSCxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBbkI7QUFDQSxNQUFNRyxZQUFZLEdBQUdKLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixRQUF2QixDQUFyQjtBQUNBLE1BQU1JLFVBQVUsR0FBR0wsUUFBUSxDQUFDQyxhQUFULENBQXVCLEdBQXZCLENBQW5CO0FBQ0EsTUFBTUssY0FBYyxHQUFHTixRQUFRLENBQUNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBdkI7QUFDQSxNQUFNTSxLQUFLLEdBQUdQLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixJQUF2QixDQUFkO0FBQ0EsTUFBTU8sUUFBUSxHQUFHUixRQUFRLENBQUNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBakI7QUFDQSxNQUFNUSxZQUFZLEdBQUdULFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixLQUF2QixDQUFyQjtBQUNBLE1BQU1TLFVBQVUsR0FBR1YsUUFBUSxDQUFDQyxhQUFULENBQXVCLEdBQXZCLENBQW5CO0FBQ0EsTUFBTVUsZUFBZSxHQUFHWCxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsR0FBdkIsQ0FBeEI7QUFDQSxNQUFNVyxZQUFZLEdBQUdaLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixHQUF2QixDQUFyQjtBQUNBLE1BQU1ZLE9BQU8sR0FBR2IsUUFBUSxDQUFDQyxhQUFULENBQXVCLEdBQXZCLENBQWhCO0FBQ0EsTUFBTWEsWUFBWSxHQUFHZCxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsR0FBdkIsQ0FBckI7QUFDQSxNQUFNYyxTQUFTLEdBQUdmLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixHQUF2QixDQUFsQjtBQUNBLE1BQU1lLGVBQWUsR0FBR2hCLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixLQUF2QixDQUF4QjtBQUNBLE1BQU1nQixxQkFBcUIsR0FBR2pCLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixLQUF2QixDQUE5QjtBQUNBLE1BQU1pQixrQkFBa0IsR0FBR2xCLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixHQUF2QixDQUEzQjtBQUVBZ0IsdUJBQXFCLENBQUNFLFNBQXRCLENBQWdDQyxHQUFoQyxDQUFvQyx3QkFBcEM7QUFDQUgsdUJBQXFCLENBQUNJLE1BQXRCLENBQTZCSCxrQkFBN0I7QUFFQUYsaUJBQWUsQ0FBQ00sWUFBaEIsQ0FBNkIsSUFBN0IsRUFBbUMsa0JBQW5DO0FBRUFULFNBQU8sQ0FBQ1EsTUFBUixDQUFlWCxVQUFmO0FBQ0FHLFNBQU8sQ0FBQ00sU0FBUixDQUFrQkMsR0FBbEIsQ0FBc0IsVUFBdEI7QUFDQVAsU0FBTyxDQUFDUyxZQUFSLENBQXFCLE1BQXJCLEVBQTZCLDZDQUE3QjtBQUNBVCxTQUFPLENBQUNTLFlBQVIsQ0FBcUIsUUFBckIsRUFBK0IsUUFBL0I7QUFDQVQsU0FBTyxDQUFDUyxZQUFSLENBQXFCLEtBQXJCLEVBQTRCLHFCQUE1QjtBQUNBVCxTQUFPLENBQUNTLFlBQVIsQ0FBcUIsT0FBckIsRUFBOEIsYUFBOUI7QUFFQVIsY0FBWSxDQUFDTyxNQUFiLENBQW9CVixlQUFwQjtBQUNBRyxjQUFZLENBQUNLLFNBQWIsQ0FBdUJDLEdBQXZCLENBQTJCLFVBQTNCO0FBQ0FOLGNBQVksQ0FBQ1EsWUFBYixDQUEwQixNQUExQixFQUFrQyx1REFBbEM7QUFDQVIsY0FBWSxDQUFDUSxZQUFiLENBQTBCLFFBQTFCLEVBQW9DLFFBQXBDO0FBQ0FSLGNBQVksQ0FBQ1EsWUFBYixDQUEwQixLQUExQixFQUFpQyxxQkFBakM7QUFDQVIsY0FBWSxDQUFDUSxZQUFiLENBQTBCLE9BQTFCLEVBQW1DLGVBQW5DO0FBRUFQLFdBQVMsQ0FBQ00sTUFBVixDQUFpQlQsWUFBakI7QUFDQUcsV0FBUyxDQUFDSSxTQUFWLENBQW9CQyxHQUFwQixDQUF3QixVQUF4QjtBQUNBTCxXQUFTLENBQUNPLFlBQVYsQ0FBdUIsTUFBdkIsRUFBK0Isc0NBQS9CO0FBQ0FQLFdBQVMsQ0FBQ08sWUFBVixDQUF1QixRQUF2QixFQUFpQyxRQUFqQztBQUNBUCxXQUFTLENBQUNPLFlBQVYsQ0FBdUIsS0FBdkIsRUFBOEIscUJBQTlCO0FBQ0FQLFdBQVMsQ0FBQ08sWUFBVixDQUF1QixPQUF2QixFQUFnQyxnQkFBaEM7QUFFQXRCLFVBQVEsQ0FBQ3VCLElBQVQsQ0FBY0osU0FBZCxDQUF3QkMsR0FBeEIsQ0FBNEIsUUFBNUI7QUFDQXBCLFVBQVEsQ0FBQ3VCLElBQVQsQ0FBY0YsTUFBZCxDQUFxQnRCLEtBQXJCO0FBRUFBLE9BQUssQ0FBQ29CLFNBQU4sQ0FBZ0JDLEdBQWhCLENBQW9CLE9BQXBCLEVBQTZCLFFBQTdCO0FBQ0FyQixPQUFLLENBQUN1QixZQUFOLENBQW1CLElBQW5CLEVBQXlCLFlBQXpCO0FBQ0F2QixPQUFLLENBQUNzQixNQUFOLENBQWFKLHFCQUFiO0FBQ0FsQixPQUFLLENBQUNzQixNQUFOLENBQWFMLGVBQWI7QUFDQWpCLE9BQUssQ0FBQ3NCLE1BQU4sQ0FBYWYsY0FBYjtBQUNBUCxPQUFLLENBQUNzQixNQUFOLENBQWFuQixTQUFiO0FBQ0FILE9BQUssQ0FBQ3NCLE1BQU4sQ0FBYVosWUFBYjtBQUVBSCxnQkFBYyxDQUFDZSxNQUFmLENBQXNCYixRQUF0QjtBQUNBRixnQkFBYyxDQUFDZSxNQUFmLENBQXNCZCxLQUF0QjtBQUNBRCxnQkFBYyxDQUFDYSxTQUFmLENBQXlCQyxHQUF6QixDQUE2QixpQkFBN0I7QUFFQVgsY0FBWSxDQUFDWSxNQUFiLENBQW9CUixPQUFwQjtBQUNBSixjQUFZLENBQUNZLE1BQWIsQ0FBb0JQLFlBQXBCO0FBQ0FMLGNBQVksQ0FBQ1ksTUFBYixDQUFvQk4sU0FBcEI7QUFDQU4sY0FBWSxDQUFDVSxTQUFiLENBQXVCQyxHQUF2QixDQUEyQixLQUEzQjtBQUVBWixVQUFRLENBQUNjLFlBQVQsQ0FBc0IsS0FBdEIsRUFBNkIsNkJBQTdCO0FBRUFmLE9BQUssQ0FBQ2lCLFNBQU4sR0FBa0IsYUFBbEI7QUFFQW5CLFlBQVUsQ0FBQ2MsU0FBWCxDQUFxQkMsR0FBckIsQ0FBeUIsSUFBekI7QUFDQWYsWUFBVSxDQUFDYyxTQUFYLENBQXFCQyxHQUFyQixDQUF5QixXQUF6QjtBQUVBVCxpQkFBZSxDQUFDUSxTQUFoQixDQUEwQkMsR0FBMUIsQ0FBOEIsSUFBOUI7QUFDQVQsaUJBQWUsQ0FBQ1EsU0FBaEIsQ0FBMEJDLEdBQTFCLENBQThCLGFBQTlCO0FBRUFWLFlBQVUsQ0FBQ1MsU0FBWCxDQUFxQkMsR0FBckIsQ0FBeUIsSUFBekI7QUFDQVYsWUFBVSxDQUFDUyxTQUFYLENBQXFCQyxHQUFyQixDQUF5QixXQUF6QjtBQUVBUixjQUFZLENBQUNPLFNBQWIsQ0FBdUJDLEdBQXZCLENBQTJCLElBQTNCO0FBQ0FSLGNBQVksQ0FBQ08sU0FBYixDQUF1QkMsR0FBdkIsQ0FBMkIsY0FBM0I7QUFFQWhCLGNBQVksQ0FBQ2lCLE1BQWIsQ0FBb0JoQixVQUFwQjtBQUNBRCxjQUFZLENBQUNlLFNBQWIsQ0FBdUJDLEdBQXZCLENBQTJCLGVBQTNCO0FBRUFGLG9CQUFrQixDQUFDQyxTQUFuQixDQUE2QkMsR0FBN0IsQ0FBaUMsSUFBakM7QUFDQUYsb0JBQWtCLENBQUNDLFNBQW5CLENBQTZCQyxHQUE3QixDQUFpQyxTQUFqQztBQUVBakIsWUFBVSxDQUFDbUIsWUFBWCxDQUF3QixJQUF4QixFQUE4QixXQUE5QjtBQUNBbkIsWUFBVSxDQUFDbUIsWUFBWCxDQUF3QixhQUF4QixFQUF1QyxzQkFBdkM7QUFDQW5CLFlBQVUsQ0FBQ2dCLFNBQVgsQ0FBcUJDLEdBQXJCLENBQXlCLFdBQXpCO0FBRUFsQixXQUFTLENBQUNpQixTQUFWLENBQW9CQyxHQUFwQixDQUF3QixxQkFBeEI7QUFDQWxCLFdBQVMsQ0FBQ21CLE1BQVYsQ0FBaUJsQixVQUFqQjtBQUNBRCxXQUFTLENBQUNtQixNQUFWLENBQWlCakIsWUFBakI7QUFFQSxNQUFNcUIsS0FBSyxHQUFHekIsUUFBUSxDQUFDMEIsY0FBVCxDQUF3QixPQUF4QixDQUFkO0FBQ0EsTUFBTUMsSUFBSSxHQUFHM0IsUUFBUSxDQUFDNEIsc0JBQVQsQ0FBZ0MsT0FBaEMsRUFBeUMsQ0FBekMsQ0FBYjs7QUFFQS9CLFFBQU0sQ0FBQ2dDLE9BQVAsR0FBaUIsVUFBU0MsS0FBVCxFQUFnQjtBQUMvQixRQUFJQSxLQUFLLENBQUNDLE1BQU4sSUFBZ0JOLEtBQXBCLEVBQTJCO0FBQ3pCQSxXQUFLLENBQUNPLEtBQU4sQ0FBWUMsT0FBWixHQUFzQixNQUF0QjtBQUNEO0FBQ0YsR0FKRDs7QUFNQU4sTUFBSSxDQUFDRSxPQUFMLEdBQWUsWUFBVztBQUN4QkosU0FBSyxDQUFDTyxLQUFOLENBQVlDLE9BQVosR0FBc0IsTUFBdEI7QUFDRCxHQUZEOztBQUlBZixvQkFBa0IsQ0FBQ1csT0FBbkIsR0FBNkIsWUFBVztBQUN0Q0osU0FBSyxDQUFDTyxLQUFOLENBQVlDLE9BQVosR0FBc0IsT0FBdEI7QUFDRCxHQUZEOztBQUlBN0IsY0FBWSxDQUFDTixnQkFBYixDQUE4QixPQUE5QixFQUF1QyxVQUFDb0MsQ0FBRCxFQUFPO0FBQzVDQSxLQUFDLENBQUNDLGNBQUY7QUFHQUMsK0VBQVksR0FDVEMsSUFESCxDQUNRLFVBQUFDLElBQUksRUFBSTtBQUNaLFVBQU1DLE1BQU0sR0FBR3ZDLFFBQVEsQ0FBQzRCLHNCQUFULENBQWdDLEtBQWhDLEVBQXVDLENBQXZDLENBQWY7O0FBQ0EsVUFBSVcsTUFBSixFQUFZO0FBQ1Z4QyxhQUFLLENBQUN5QyxXQUFOLENBQWtCL0IsWUFBbEI7QUFDRDs7QUFDRGdDLG1GQUFhLENBQUNILElBQUQsQ0FBYjtBQUNBdkMsV0FBSyxDQUFDc0IsTUFBTixDQUFhWixZQUFiOztBQUVBLFVBQUk2QixJQUFJLENBQUNJLE1BQVQsRUFBaUI7QUFDZjNDLGFBQUssQ0FBQ2lDLEtBQU4sQ0FBWVcsTUFBWixHQUFxQixtQkFBckI7QUFDQTVDLGFBQUssQ0FBQ2lDLEtBQU4sQ0FBWVksU0FBWixHQUF3QixTQUF4QjtBQUNEOztBQUNEM0IsMkJBQXFCLENBQUNlLEtBQXRCLENBQTRCVyxNQUE1QixHQUFxQyxVQUFyQztBQUNELEtBZEg7QUFlRCxHQW5CRDtBQW9CRCxDQXJJRCxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxJQUFNRSxVQUFVLEdBQUdDLG1CQUFPLENBQUMsMkRBQUQsQ0FBMUI7O0FBQ0FBLG1CQUFPLENBQUMsb0ZBQUQsQ0FBUCxDQUF3Q0QsVUFBeEM7O0FBRU8sSUFBTUosYUFBYTtBQUFBLHFFQUFHLGlCQUFPTSxRQUFQO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNyQmhELGlCQURxQixHQUNiQyxRQUFRLENBQUMwQixjQUFULENBQXdCLFlBQXhCLENBRGE7QUFFckJzQix5QkFGcUIsR0FFTGhELFFBQVEsQ0FBQzBCLGNBQVQsQ0FBd0IsZ0JBQXhCLENBRks7QUFHckJ1Qix5QkFIcUIsR0FHTGpELFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixLQUF2QixDQUhLO0FBSXJCaUQsNEJBSnFCLEdBSUZsRCxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FKRTtBQUtyQmtELG1CQUxxQixHQUtYSixRQUFRLENBQUNLLFVBQVQsQ0FBb0JDLE1BTFQ7QUFNckJDLGtDQU5xQixHQU1JdEQsUUFBUSxDQUFDQyxhQUFULENBQXVCLEtBQXZCLENBTko7QUFPckJzRCxrQ0FQcUIsR0FPSXZELFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixLQUF2QixDQVBKO0FBUXJCdUQsMEJBUnFCLEdBUUp4RCxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsR0FBdkIsQ0FSSTtBQVNyQndELDBCQVRxQixHQVNKekQsUUFBUSxDQUFDQyxhQUFULENBQXVCLEdBQXZCLENBVEk7QUFXM0IsZ0JBQUkrQyxhQUFKLEVBQW1CakQsS0FBSyxDQUFDeUMsV0FBTixDQUFrQlEsYUFBbEI7QUFFbkJRLDBCQUFjLENBQUNyQyxTQUFmLENBQXlCQyxHQUF6QixDQUE2QixJQUE3QjtBQUNBb0MsMEJBQWMsQ0FBQ3JDLFNBQWYsQ0FBeUJDLEdBQXpCLENBQTZCLFlBQTdCO0FBRUFxQywwQkFBYyxDQUFDdEMsU0FBZixDQUF5QkMsR0FBekIsQ0FBNkIsSUFBN0I7QUFDQXFDLDBCQUFjLENBQUN0QyxTQUFmLENBQXlCQyxHQUF6QixDQUE2QixZQUE3QjtBQUVBOEIsNEJBQWdCLENBQUMvQixTQUFqQixDQUEyQkMsR0FBM0IsQ0FBK0IscUJBQS9CO0FBQ0FrQyxrQ0FBc0IsQ0FBQ2hDLFlBQXZCLENBQW9DLElBQXBDLEVBQTBDLFlBQTFDLEVBcEIyQixDQW9COEI7O0FBQ3pEaUMsa0NBQXNCLENBQUNqQyxZQUF2QixDQUFvQyxJQUFwQyxFQUEwQyxZQUExQyxFQXJCMkIsQ0FxQjhCOztBQUV6RGdDLGtDQUFzQixDQUFDakMsTUFBdkIsQ0FBOEJvQyxjQUE5QjtBQUNBRixrQ0FBc0IsQ0FBQ2xDLE1BQXZCLENBQThCbUMsY0FBOUI7QUFFQXpELGlCQUFLLENBQUNzQixNQUFOLENBQWE0QixhQUFiO0FBRUFDLDRCQUFnQixDQUFDN0IsTUFBakIsQ0FBd0JpQyxzQkFBeEI7QUFDQUosNEJBQWdCLENBQUM3QixNQUFqQixDQUF3QmtDLHNCQUF4QjtBQUVBTix5QkFBYSxDQUFDNUIsTUFBZCxDQUFxQnFDLFVBQVUsQ0FBQ1AsT0FBRCxDQUEvQjtBQUNBRix5QkFBYSxDQUFDNUIsTUFBZCxDQUFxQnNDLGdCQUFnQixDQUFDWixRQUFELENBQXJDO0FBQ0FFLHlCQUFhLENBQUM1QixNQUFkLENBQXFCNkIsZ0JBQXJCO0FBQ0FELHlCQUFhLENBQUMzQixZQUFkLENBQTJCLElBQTNCLEVBQWlDLGdCQUFqQztBQUNBMkIseUJBQWEsQ0FBQzlCLFNBQWQsQ0FBd0JDLEdBQXhCLENBQTRCLGdCQUE1QjtBQUVBd0MsMkVBQVUsQ0FBQ2IsUUFBRCxDQUFWLENBQ0dWLElBREgsQ0FDUSxVQUFBd0IsT0FBTztBQUFBLHFCQUFJQyxlQUFlLENBQUNmLFFBQUQsRUFBV2MsT0FBWCxDQUFuQjtBQUFBLGFBRGY7O0FBckMyQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUFIOztBQUFBLGtCQUFicEIsYUFBYTtBQUFBO0FBQUE7QUFBQSxHQUFuQjs7QUF5Q1AsSUFBTWlCLFVBQVUsR0FBRyxTQUFiQSxVQUFhLENBQUFQLE9BQU8sRUFBSTtBQUM1QixNQUFNWSxZQUFZLEdBQUcvRCxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBckI7QUFDQThELGNBQVksQ0FBQzVDLFNBQWIsQ0FBdUJDLEdBQXZCLENBQTJCLGlCQUEzQjtBQUNBLE1BQU00QyxHQUFHLEdBQUdoRSxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWjtBQUNBK0QsS0FBRyxDQUFDMUMsWUFBSixDQUFpQixLQUFqQixFQUF3QjZCLE9BQXhCO0FBQ0FZLGNBQVksQ0FBQzFDLE1BQWIsQ0FBb0IyQyxHQUFwQjtBQUVBLFNBQU9ELFlBQVA7QUFDRCxDQVJEOztBQVVBLElBQU1KLGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBbUIsQ0FBQ1osUUFBRCxFQUFjO0FBQUEsTUFFbkNrQixJQUZtQyxHQVVqQ2xCLFFBVmlDLENBRW5Da0IsSUFGbUM7QUFBQSxNQUduQ0MsU0FIbUMsR0FVakNuQixRQVZpQyxDQUduQ21CLFNBSG1DO0FBQUEsTUFJbkNDLE1BSm1DLEdBVWpDcEIsUUFWaUMsQ0FJbkNvQixNQUptQztBQUFBLE1BS25DQyxXQUxtQyxHQVVqQ3JCLFFBVmlDLENBS25DcUIsV0FMbUM7QUFBQSxNQU1uQ0MsUUFObUMsR0FVakN0QixRQVZpQyxDQU1uQ3NCLFFBTm1DO0FBQUEsTUFPbkNDLFNBUG1DLEdBVWpDdkIsUUFWaUMsQ0FPbkN1QixTQVBtQztBQUFBLE1BUW5DQyxXQVJtQyxHQVVqQ3hCLFFBVmlDLENBUW5Dd0IsV0FSbUM7QUFBQSxNQVNuQ0MsVUFUbUMsR0FVakN6QixRQVZpQyxDQVNuQ3lCLFVBVG1DO0FBWXJDLE1BQU1DLGtCQUFrQixHQUFHekUsUUFBUSxDQUFDQyxhQUFULENBQXVCLElBQXZCLENBQTNCO0FBQ0F3RSxvQkFBa0IsQ0FBQ3RELFNBQW5CLENBQTZCQyxHQUE3QixDQUFpQyxzQkFBakM7QUFFQSxNQUFNc0QsU0FBUyxHQUFHMUUsUUFBUSxDQUFDQyxhQUFULENBQXVCLElBQXZCLENBQWxCO0FBQ0EsTUFBTU0sS0FBSyxHQUFHUCxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsSUFBdkIsQ0FBZDtBQUNBLE1BQU0wRSxRQUFRLEdBQUczRSxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBakI7QUFFQTBFLFVBQVEsQ0FBQ3RELE1BQVQsQ0FBZ0J1RCxxRUFBa0IsQ0FBQ1YsU0FBRCxDQUFsQztBQUVBM0QsT0FBSyxDQUFDaUIsU0FBTixHQUFrQnlDLElBQWxCO0FBQ0FTLFdBQVMsQ0FBQ3JELE1BQVYsQ0FBaUJkLEtBQWpCO0FBQ0FtRSxXQUFTLENBQUNyRCxNQUFWLENBQWlCc0QsUUFBakI7QUFDQUQsV0FBUyxDQUFDdkQsU0FBVixDQUFvQkMsR0FBcEIsQ0FBd0Isc0JBQXhCO0FBQ0FxRCxvQkFBa0IsQ0FBQ3BELE1BQW5CLENBQTBCcUQsU0FBMUIsRUF6QnFDLENBNEJyQzs7QUFDQSxNQUFNRyxFQUFFLEdBQUc3RSxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsSUFBdkIsQ0FBWDtBQUNBd0Usb0JBQWtCLENBQUNwRCxNQUFuQixDQUEwQndELEVBQTFCO0FBRUEsTUFBTUMsUUFBUSxHQUFHOUUsUUFBUSxDQUFDQyxhQUFULENBQXVCLElBQXZCLENBQWpCO0FBQ0E2RSxVQUFRLENBQUN0RCxTQUFULEdBQXFCdUQsVUFBVSxDQUFDWixNQUFELENBQVYsR0FBcUIsR0FBckIsR0FBMkJHLFNBQWhEO0FBQ0FHLG9CQUFrQixDQUFDcEQsTUFBbkIsQ0FBMEJ5RCxRQUExQjtBQUVBLE1BQU1FLFdBQVcsR0FBR2hGLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixJQUF2QixDQUFwQjtBQUNBK0UsYUFBVyxDQUFDeEQsU0FBWixHQUF3QjZDLFFBQXhCO0FBQ0FJLG9CQUFrQixDQUFDcEQsTUFBbkIsQ0FBMEIyRCxXQUExQjtBQUVBUCxvQkFBa0IsQ0FBQ3BELE1BQW5CLENBQTBCckIsUUFBUSxDQUFDQyxhQUFULENBQXVCLElBQXZCLENBQTFCO0FBRUFnRixzRUFBaUIsQ0FBQ2IsV0FBRCxFQUFjSyxrQkFBZCxDQUFqQjs7QUFFQSxNQUFJRixXQUFKLEVBQWdCO0FBQ2QsUUFBTVcsY0FBYyxHQUFHbEYsUUFBUSxDQUFDQyxhQUFULENBQXVCLElBQXZCLENBQXZCO0FBQ0FpRixrQkFBYyxDQUFDL0QsU0FBZixDQUF5QkMsR0FBekIsQ0FBNkIsUUFBN0I7QUFDQThELGtCQUFjLENBQUMxRCxTQUFmLEdBQTJCK0MsV0FBM0I7QUFDQUUsc0JBQWtCLENBQUNwRCxNQUFuQixDQUEwQjZELGNBQTFCO0FBQ0Q7O0FBRUQsTUFBTUMsbUJBQW1CLEdBQUduRixRQUFRLENBQUNDLGFBQVQsQ0FBdUIsSUFBdkIsQ0FBNUI7QUFDQWtGLHFCQUFtQixDQUFDaEUsU0FBcEIsQ0FBOEJDLEdBQTlCLENBQWtDLHNCQUFsQztBQUNBZ0Usb0VBQWUsQ0FBQ1osVUFBRCxFQUFhVyxtQkFBYixDQUFmO0FBQ0FWLG9CQUFrQixDQUFDcEQsTUFBbkIsQ0FBMEI4RCxtQkFBMUI7QUFFQSxTQUFPVixrQkFBUDtBQUNELENBekREOztBQTJEQSxJQUFNWCxlQUFlLEdBQUcsU0FBbEJBLGVBQWtCLENBQUNmLFFBQUQsRUFBV2MsT0FBWCxFQUF1QjtBQUM3QztBQUNBd0Isb0VBQVUsQ0FBQ3hCLE9BQUQsQ0FBVixDQUFvQnhCLElBQXBCLENBQXlCLFVBQUFpRCxjQUFjLEVBQUk7QUFDekM7QUFDQSxRQUFNQyxTQUFTLEdBQUcxQyxVQUFVLENBQUMyQyxLQUFYLENBQWlCLFlBQWpCLEVBQStCO0FBQy9DQSxXQUFLLEVBQUU7QUFDTEMsMkJBQW1CLEVBQUUsSUFEaEI7QUFFTEMsdUJBQWUsRUFBRSxJQUZaO0FBR0xDLGtCQUFVLEVBQUUsS0FIUDtBQUlMQyxZQUFJLEVBQUU7QUFKRCxPQUR3QztBQU8vQ3JGLFdBQUssRUFBRTtBQUNMc0YsWUFBSSx3QkFBaUI5QyxRQUFRLENBQUNzQixRQUExQixNQURDO0FBRUxyQyxhQUFLLEVBQUU7QUFDTCx5QkFBZSxhQURWO0FBRUwsdUJBQWE7QUFGUjtBQUZGLE9BUHdDO0FBYy9DOEQsYUFBTyxFQUFFO0FBQ1BDLG1CQUFXLEVBQUUsd0NBRE47QUFFUEMsb0JBQVksRUFBRTtBQUZQLE9BZHNDO0FBa0IvQ0MsbUJBQWEsRUFBRTtBQUNiQyxhQUFLLEVBQUU7QUFDTEMscUJBQVcsRUFBRTtBQURSO0FBRE0sT0FsQmdDO0FBdUIvQ0MsaUJBQVcsRUFBRTtBQUNYQyxXQUFHLEVBQUU7QUFDSEMsMEJBQWdCLEVBQUUsSUFEZjtBQUVIQyxnQkFBTSxFQUFFLFNBRkw7QUFHSEMsb0JBQVUsRUFBRTtBQUNWQyxtQkFBTyxFQUFFLElBREM7QUFFVkMsa0JBQU0sRUFBRSxjQUZFO0FBR1YxRSxpQkFBSyxFQUFFO0FBQ0wyRSx3QkFBVSxFQUFFLEdBRFA7QUFFTEMsd0JBQVUsRUFBRTtBQUZQO0FBSEc7QUFIVDtBQURNLE9BdkJrQztBQXFDL0NDLFlBQU0sRUFBRSxDQUFDO0FBQ1A1QyxZQUFJLEVBQUUsT0FEQztBQUVQNkMsb0JBQVksRUFBRSxJQUZQO0FBR1BDLFlBQUksRUFBRUMsTUFBTSxDQUFDQyxPQUFQLENBQWUzQixjQUFjLENBQUM0QixLQUE5QixFQUFxQ0MsSUFBckMsQ0FBMEMsVUFBQ0MsQ0FBRCxFQUFHQyxDQUFIO0FBQUEsaUJBQVNELENBQUMsQ0FBQyxDQUFELENBQUQsR0FBT0MsQ0FBQyxDQUFDLENBQUQsQ0FBakI7QUFBQSxTQUExQyxFQUFnRUMsT0FBaEUsR0FBMEVDLEdBQTFFLENBQThFLFVBQUFDLElBQUksRUFBSTtBQUMxRixpQkFBTztBQUFDdkQsZ0JBQUksRUFBRXVELElBQUksQ0FBQyxDQUFELENBQVg7QUFBZ0JDLGFBQUMsRUFBRUQsSUFBSSxDQUFDLENBQUQ7QUFBdkIsV0FBUDtBQUNELFNBRks7QUFIQyxPQUFEO0FBckN1QyxLQUEvQixDQUFsQjtBQThDQSxRQUFNRSxVQUFVLEdBQUc3RSxVQUFVLENBQUMyQyxLQUFYLENBQWlCLFlBQWpCLEVBQStCO0FBQ2hEQSxXQUFLLEVBQUU7QUFDTEksWUFBSSxFQUFFO0FBREQsT0FEeUM7QUFJbERyRixXQUFLLEVBQUU7QUFDSHNGLFlBQUkseUJBQWtCOUMsUUFBUSxDQUFDc0IsUUFBM0IsTUFERDtBQUVIckMsYUFBSyxFQUFFO0FBQ0wseUJBQWUsYUFEVjtBQUVMLHVCQUFhO0FBRlI7QUFGSixPQUoyQztBQVdsRDJGLFdBQUssRUFBRTtBQUNIQyxrQkFBVSxFQUFFdEMsY0FBYyxDQUFDdUMsY0FBZixDQUE4Qk4sR0FBOUIsQ0FBa0MsVUFBQWpGLElBQUk7QUFBQSxpQkFBSUEsSUFBSSxDQUFDMkIsSUFBVDtBQUFBLFNBQXRDLENBRFQ7QUFFSDZELGlCQUFTLEVBQUUsSUFGUjtBQUdIQyxjQUFNLEVBQUU7QUFBRXRCLGlCQUFPLEVBQUU7QUFBWDtBQUhMLE9BWDJDO0FBZ0JsRHVCLFdBQUssRUFBRTtBQUNIQyxXQUFHLEVBQUUsQ0FERjtBQUVIMUgsYUFBSyxFQUFFO0FBQ0hzRixjQUFJLEVBQUUsS0FESDtBQUVIWSxpQkFBTyxFQUFFO0FBRk4sU0FGSixDQU1IOztBQU5HLE9BaEIyQztBQXdCbERYLGFBQU8sRUFBRTtBQUNMb0Msb0JBQVksRUFBRSx3REFEVDtBQUVMbkMsbUJBQVcsRUFBRSx3RUFDVCx1REFIQztBQUlMQyxvQkFBWSxFQUFFLFVBSlQ7QUFLTG1DLGNBQU0sRUFBRSxJQUxIO0FBTUxDLGVBQU8sRUFBRTtBQU5KLE9BeEJ5QztBQWdDbERoQyxpQkFBVyxFQUFFO0FBQ1RpQyxjQUFNLEVBQUU7QUFDSkMsc0JBQVksRUFBRSxHQURWO0FBRUpDLHFCQUFXLEVBQUU7QUFGVDtBQURDLE9BaENxQztBQXNDbEQxQixZQUFNLEVBQUUsQ0FBQztBQUNMNUMsWUFBSSxFQUFFLE9BREQ7QUFFTDZDLG9CQUFZLEVBQUUsSUFGVDtBQUdMQyxZQUFJLEVBQUV6QixjQUFjLENBQUN1QyxjQUFmLENBQThCTixHQUE5QixDQUFrQyxVQUFBakYsSUFBSTtBQUFBLGlCQUFJa0csVUFBVSxDQUFDbEcsSUFBSSxDQUFDbUcsTUFBTCxDQUFZQyxHQUFiLENBQWQ7QUFBQSxTQUF0QyxDQUhEO0FBSUxDLG9CQUFZLEVBQUU7QUFKVCxPQUFEO0FBdEMwQyxLQUEvQixDQUFuQjtBQTZDRCxHQTdGRDtBQThGRCxDQWhHRDs7QUFrR08sSUFBTTVELFVBQVUsR0FBRyxTQUFiQSxVQUFhLENBQUE2RCxHQUFHLEVBQUc7QUFDOUIsU0FBT0EsR0FBRyxDQUFDQyxNQUFKLENBQVcsQ0FBWCxFQUFjQyxXQUFkLEtBQThCRixHQUFHLENBQUNHLEtBQUosQ0FBVSxDQUFWLENBQXJDO0FBQ0QsQ0FGTSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdk5BLElBQUl6RyxJQUFKO0FBQ1A7QUFFTyxJQUFNRixZQUFZO0FBQUEscUVBQUcsaUJBQU9GLENBQVA7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ3BCOEcsb0JBRG9CLEdBQ1RoSixRQUFRLENBQUMwQixjQUFULENBQXdCLFdBQXhCLEVBQXFDdUgsS0FENUI7QUFFcEJDLGVBRm9CLEdBRWQsNkNBRmM7QUFHcEJDLHFCQUhvQixHQUdSRCxHQUFHLEdBQUdFLGdCQUFnQixDQUFDSixRQUFELENBSGQ7QUFJcEJLLHVCQUpvQixHQUlOckosUUFBUSxDQUFDMEIsY0FBVCxDQUF3QixrQkFBeEIsQ0FKTTtBQUFBO0FBQUEsbUJBS0g0SCxLQUFLLENBQUNILFNBQUQsQ0FMRjs7QUFBQTtBQUtwQkksb0JBTG9CO0FBQUE7QUFBQSxtQkFNUEEsUUFBUSxDQUFDQyxJQUFULEVBTk87O0FBQUE7QUFNcEJBLGdCQU5vQjtBQVExQkgsdUJBQVcsQ0FBQzdILFNBQVosR0FBd0IsRUFBeEI7QUFSMEI7QUFBQSxtQkFTYmdJLElBVGE7O0FBQUE7QUFTMUJsSCxnQkFUMEI7O0FBQUEsa0JBV3RCQSxJQUFJLENBQUNJLE1BQUwsS0FBZ0IsT0FYTTtBQUFBO0FBQUE7QUFBQTs7QUFZeEI7QUFDTStHLHVCQWJrQixHQWFKekosUUFBUSxDQUFDQyxhQUFULENBQXVCLEtBQXZCLENBYkk7QUFjbEJ5SixpQkFka0IsR0FjVjFKLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixJQUF2QixDQWRVO0FBZWxCRixpQkFma0IsR0FlVkMsUUFBUSxDQUFDNEIsc0JBQVQsQ0FBZ0MsT0FBaEMsRUFBeUMsQ0FBekMsQ0FmVTtBQWlCeEI3QixpQkFBSyxDQUFDaUMsS0FBTixDQUFZVyxNQUFaLEdBQXFCLE1BQXJCO0FBRUE4Ryx1QkFBVyxDQUFDbkksWUFBWixDQUF5QixJQUF6QixFQUErQixXQUEvQjtBQUNBb0ksaUJBQUssQ0FBQ3BJLFlBQU4sQ0FBbUIsSUFBbkIsRUFBeUIsZUFBekI7QUFFQW9JLGlCQUFLLENBQUNsSSxTQUFOLEdBQWtCYyxJQUFJLENBQUNxSCxPQUF2QjtBQUNBRix1QkFBVyxDQUFDcEksTUFBWixDQUFtQnFJLEtBQW5CO0FBQ0FMLHVCQUFXLENBQUNoSSxNQUFaLENBQW1Cb0ksV0FBbkI7QUF4QndCOztBQUFBO0FBNEJ4QkcsbUJBQU8sQ0FBQ0MsR0FBUixDQUFZdkgsSUFBWjs7QUE1QndCO0FBQUEsNkNBK0JuQkEsSUEvQm1COztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQUg7O0FBQUEsa0JBQVpGLFlBQVk7QUFBQTtBQUFBO0FBQUEsR0FBbEI7QUFrQ0EsSUFBTWdILGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBbUIsQ0FBQVUsV0FBVztBQUFBLFNBQU1BLFdBQVcsQ0FBQ0MsS0FBWixDQUFrQixHQUFsQixFQUF1QkMsSUFBdkIsQ0FBNEIsR0FBNUIsQ0FBTjtBQUFBLENBQXBDLEM7Ozs7Ozs7Ozs7OztBQ3JDUDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFTyxJQUFNcEYsa0JBQWtCLEdBQUcsU0FBckJBLGtCQUFxQixDQUFBcUYsT0FBTyxFQUFJO0FBQ3pDLE1BQUlDLE9BQU8sR0FBR2xLLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixLQUF2QixDQUFkO0FBQ0FpSyxTQUFPLENBQUMvSSxTQUFSLENBQWtCQyxHQUFsQixDQUFzQix1QkFBdEI7QUFFQSxNQUFJLENBQUM2SSxPQUFMLEVBQWMsT0FBT0MsT0FBUDtBQUVkLE1BQUlDLE1BQU0sR0FBRyxFQUFiOztBQUVBLE9BQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0gsT0FBTyxDQUFDSSxNQUE1QixFQUFvQ0QsQ0FBQyxFQUFyQyxFQUF3QztBQUNwQyxRQUFNRSxNQUFNLEdBQUdMLE9BQU8sQ0FBQ0csQ0FBRCxDQUF0Qjs7QUFFQSxRQUFJRSxNQUFNLEtBQUssR0FBZixFQUFtQjtBQUNmSCxZQUFNLEdBQUcsRUFBVDtBQUNILEtBRkQsTUFFTyxJQUFJRyxNQUFNLEtBQUssR0FBZixFQUFtQjtBQUN0QixVQUFNdEcsR0FBRyxHQUFHaEUsUUFBUSxDQUFDQyxhQUFULENBQXVCLEtBQXZCLENBQVo7QUFDQStELFNBQUcsQ0FBQzFDLFlBQUosQ0FBaUIsS0FBakIsK0NBQThENkksTUFBOUQ7QUFFQUQsYUFBTyxDQUFDN0ksTUFBUixDQUFlMkMsR0FBZjtBQUNILEtBTE0sTUFLQTtBQUNIbUcsWUFBTSxHQUFHQSxNQUFNLEdBQUdHLE1BQWxCO0FBQ0g7QUFDSjs7QUFFRCxTQUFPSixPQUFQO0FBQ0gsQ0F4Qk07QUEwQkEsSUFBTWpGLGlCQUFpQixHQUFHLFNBQXBCQSxpQkFBb0IsQ0FBQ3NGLE9BQUQsRUFBVUMsU0FBVixFQUF3QjtBQUNyRCxNQUFJQyxVQUFVLEdBQUdGLE9BQU8sQ0FBQ1IsS0FBUixDQUFjLElBQWQsQ0FBakI7QUFFQVUsWUFBVSxDQUFDQyxPQUFYLENBQW1CLFVBQUFQLE1BQU0sRUFBSTtBQUN6QixRQUFNUSxXQUFXLEdBQUczSyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsSUFBdkIsQ0FBcEI7QUFDQTBLLGVBQVcsQ0FBQ3hKLFNBQVosQ0FBc0JDLEdBQXRCLENBQTBCLFFBQTFCO0FBQ0F1SixlQUFXLENBQUNuSixTQUFaLEdBQXdCMkksTUFBeEI7QUFDQUssYUFBUyxDQUFDbkosTUFBVixDQUFpQnNKLFdBQWpCO0FBQ0gsR0FMRDtBQU1ILENBVE07QUFXQSxJQUFNdkYsZUFBZSxHQUFHLFNBQWxCQSxlQUFrQixDQUFDd0YsUUFBRCxFQUFXQyxZQUFYLEVBQTRCO0FBQ3ZELE1BQU1DLGVBQWUsR0FBRyxDQUNwQixXQURvQixFQUVwQixVQUZvQixFQUdwQixTQUhvQixFQUlwQixRQUpvQixFQUtwQixVQUxvQixFQU1wQixRQU5vQixFQU9wQixRQVBvQixFQVFwQixTQVJvQixFQVNwQixPQVRvQixFQVVwQixPQVZvQixDQUF4QjtBQVlBLE1BQU1DLGNBQWMsR0FBRy9LLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixJQUF2QixDQUF2QjtBQUVBNkssaUJBQWUsQ0FBQ0osT0FBaEIsQ0FBd0IsVUFBQU0sU0FBUyxFQUFJO0FBQ2pDLFFBQU1DLFdBQVcsR0FBR2pMLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixJQUF2QixDQUFwQjtBQUNBZ0wsZUFBVyxDQUFDOUosU0FBWixDQUFzQkMsR0FBdEIsQ0FBMEIsY0FBMUI7QUFFQSxRQUFNc0YsTUFBTSxHQUFHMUcsUUFBUSxDQUFDQyxhQUFULENBQXVCLElBQXZCLENBQWY7QUFDQXlHLFVBQU0sQ0FBQ2xGLFNBQVAsR0FBbUJ1RCxrRUFBVSxDQUFDaUcsU0FBRCxDQUE3QjtBQUNBdEUsVUFBTSxDQUFDdkYsU0FBUCxDQUFpQkMsR0FBakIsQ0FBcUIsYUFBckI7O0FBRUEsWUFBT3dKLFFBQVEsQ0FBQ0ksU0FBRCxDQUFmO0FBQ0ksV0FBSyxPQUFMO0FBQ0lDLG1CQUFXLENBQUN6SixTQUFaLEdBQXdCLE9BQXhCO0FBQ0F5SixtQkFBVyxDQUFDOUosU0FBWixDQUFzQkMsR0FBdEIsQ0FBMEIsT0FBMUI7QUFDQTs7QUFDSixXQUFLLFdBQUw7QUFDSTZKLG1CQUFXLENBQUN6SixTQUFaLEdBQXdCLFdBQXhCO0FBQ0F5SixtQkFBVyxDQUFDOUosU0FBWixDQUFzQkMsR0FBdEIsQ0FBMEIsV0FBMUI7QUFDQTs7QUFDSixXQUFLLFFBQUw7QUFDSTZKLG1CQUFXLENBQUN6SixTQUFaLEdBQXdCLFFBQXhCO0FBQ0F5SixtQkFBVyxDQUFDOUosU0FBWixDQUFzQkMsR0FBdEIsQ0FBMEIsUUFBMUI7QUFDQTs7QUFDSixXQUFLLFlBQUw7QUFDSTZKLG1CQUFXLENBQUN6SixTQUFaLEdBQXdCLE9BQXhCO0FBQ0F5SixtQkFBVyxDQUFDOUosU0FBWixDQUFzQkMsR0FBdEIsQ0FBMEIsTUFBMUI7QUFDQTtBQWhCUjs7QUFtQkEySixrQkFBYyxDQUFDMUosTUFBZixDQUFzQnFGLE1BQXRCO0FBQ0FxRSxrQkFBYyxDQUFDMUosTUFBZixDQUFzQjRKLFdBQXRCO0FBQ0gsR0E3QkQ7QUErQkFKLGNBQVksQ0FBQ3hKLE1BQWIsQ0FBb0IwSixjQUFwQjtBQUNILENBL0NNLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkNQO0FBRU8sSUFBTW5ILFVBQVU7QUFBQSxxRUFBRyxpQkFBT2IsUUFBUDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDaEJvRyxxQkFEZ0IsbUVBQ3FEcEcsUUFBUSxDQUFDbUksR0FEOUQ7QUFBQTtBQUFBLG1CQUVDNUIsS0FBSyxDQUFDSCxTQUFELENBRk47O0FBQUE7QUFFaEJJLG9CQUZnQjtBQUFBO0FBQUEsbUJBR0hBLFFBQVEsQ0FBQ0MsSUFBVCxFQUhHOztBQUFBO0FBR2hCQSxnQkFIZ0I7O0FBQUEsaUJBS2xCQSxJQUFJLENBQUMyQixRQUxhO0FBQUE7QUFBQTtBQUFBOztBQU1kQyxtQkFOYyxHQU1KNUIsSUFBSSxDQUFDNkIsU0FORDtBQUFBO0FBQUEsbUJBT08vQixLQUFLLENBQUM4QixPQUFELENBUFo7O0FBQUE7QUFPZEUsd0JBUGM7QUFBQTtBQUFBLG1CQVFHQSxZQUFZLENBQUM5QixJQUFiLEVBUkg7O0FBQUE7QUFRZCtCLG9CQVJjOztBQUFBLGlCQVVoQkEsUUFBUSxDQUFDSixRQVZPO0FBQUE7QUFBQTtBQUFBOztBQVdaSyxvQkFYWSxHQVdERCxRQUFRLENBQUNGLFNBWFI7QUFBQTtBQUFBLG1CQVlVL0IsS0FBSyxDQUFDa0MsUUFBRCxDQVpmOztBQUFBO0FBWVpDLHlCQVpZO0FBQUE7QUFBQSxtQkFhTUEsYUFBYSxDQUFDakMsSUFBZCxFQWJOOztBQUFBO0FBYVprQyxxQkFiWTtBQUFBLDZDQWVYQyxRQUFRLENBQUMsQ0FBQ25DLElBQUQsRUFBTytCLFFBQVAsRUFBaUJHLFNBQWpCLENBQUQsQ0FmRzs7QUFBQTtBQUFBLDZDQWtCWEMsUUFBUSxDQUFDLENBQUNuQyxJQUFELEVBQU8rQixRQUFQLENBQUQsQ0FsQkc7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSxtQkFxQlQvQixJQXJCUzs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQUg7O0FBQUEsa0JBQVY1RixVQUFVO0FBQUE7QUFBQTtBQUFBLEdBQWhCOztBQXlCUCxJQUFNK0gsUUFBUTtBQUFBLHNFQUFHLGtCQUFPQyxTQUFQO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNYQyxtQkFEVyxHQUNERCxTQUFTLENBQUMsQ0FBRCxDQURSOztBQUdmLGlCQUFTeEIsQ0FBVCxHQUFhLENBQWIsRUFBZ0JBLENBQUMsR0FBR3dCLFNBQVMsQ0FBQ3ZCLE1BQTlCLEVBQXNDRCxDQUFDLEVBQXZDLEVBQTBDO0FBQ2xDMEIsd0JBRGtDLEdBQ3JCRixTQUFTLENBQUN4QixDQUFELENBRFk7QUFFeEN5QixxQkFBTyxDQUFDOUUsSUFBUixHQUFlOEUsT0FBTyxDQUFDOUUsSUFBUixDQUFhZ0YsTUFBYixDQUFvQkQsVUFBVSxDQUFDL0UsSUFBL0IsQ0FBZjtBQUNEOztBQU5jLDhDQVFSOEUsT0FSUTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUFIOztBQUFBLGtCQUFSRixRQUFRO0FBQUE7QUFBQTtBQUFBLEdBQWQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQkE7QUFFTyxJQUFNdEcsVUFBVTtBQUFBLHFFQUFHLGlCQUFNNkYsR0FBTjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDdEI7QUFDTWMsd0JBRmdCLEdBRUQsQ0FBQyxVQUFELEVBQWEsVUFBYixFQUF5QixhQUF6QixFQUF3QyxTQUF4QyxFQUFtRCxNQUFuRCxFQUEyRCxjQUEzRCxFQUEyRSxTQUEzRSxFQUFzRixRQUF0RixDQUZDO0FBR2hCQyxpQkFIZ0IsR0FHUmYsR0FBRyxDQUFDbkUsSUFISTtBQUloQm1GLGlCQUpnQixHQUlSO0FBQ1ZDLDRCQUFjLEVBQUUsQ0FETjtBQUVWQywyQkFBYSxFQUFFLENBRkw7QUFHVnZFLDRCQUFjLEVBQUUsRUFITjtBQUlWd0Usa0NBQW9CLEVBQUUsQ0FKWjtBQUtWbkYsbUJBQUssRUFBRSxFQUxHO0FBTVZvRixzQkFBUSxFQUFFO0FBTkEsYUFKUTtBQWFibEMsYUFiYSxHQWFULENBYlM7O0FBQUE7QUFBQSxrQkFhTkEsQ0FBQyxHQUFHNkIsS0FBSyxDQUFDNUIsTUFiSjtBQUFBO0FBQUE7QUFBQTs7QUFjWi9ILGdCQWRZLEdBY0wySixLQUFLLENBQUM3QixDQUFELENBZEE7QUFlZG1DLDRCQWZjLFdBZ0JsQjs7QUFoQmtCLGlCQWlCZGpLLElBQUksQ0FBQ2tLLEtBakJTO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBcUJsQkQsNEJBQWdCLEdBQUdFLGNBQWMsQ0FBQ25LLElBQUksQ0FBQ2dDLFNBQU4sQ0FBakMsQ0FyQmtCLENBcUJpQzs7QUFyQmpDLGlCQXVCZGlJLGdCQUFnQixDQUFDRyxRQUFqQixDQUEwQixPQUExQixDQXZCYztBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQTBCUkMscUJBMUJRLEdBMEJLLE9BQU9ySyxJQUFJLENBQUNtRyxNQUFMLENBQVlDLEdBQW5CLEtBQTJCLFdBQTNCLElBQTBDcEcsSUFBSSxDQUFDbUcsTUFBTCxDQUFZQyxHQUFaLEtBQW9CLElBQS9ELEdBQXVFLENBQXZFLEdBQTJFRixVQUFVLENBQUNsRyxJQUFJLENBQUNtRyxNQUFMLENBQVlDLEdBQWIsQ0ExQnpGO0FBMkJkNkQsNEJBQWdCLENBQUM3QixPQUFqQixDQUF5QixVQUFBOUUsSUFBSSxFQUFJO0FBQzdCLGtCQUFJb0csWUFBWSxDQUFDVSxRQUFiLENBQXNCOUcsSUFBdEIsS0FBK0IsT0FBT3NHLEtBQUssQ0FBQ2hGLEtBQU4sQ0FBWXRCLElBQVosQ0FBUCxLQUE2QixXQUFoRSxFQUE0RTtBQUN4RXNHLHFCQUFLLENBQUNoRixLQUFOLENBQVl0QixJQUFaLElBQW9CLENBQXBCO0FBQ0gsZUFGRCxNQUVPLElBQUlvRyxZQUFZLENBQUNVLFFBQWIsQ0FBc0I5RyxJQUF0QixDQUFKLEVBQWlDO0FBQ3BDc0cscUJBQUssQ0FBQ2hGLEtBQU4sQ0FBWXRCLElBQVosS0FBcUIsQ0FBckI7QUFDSCxlQUZNLE1BRUEsSUFBSSxDQUFDb0csWUFBWSxDQUFDVSxRQUFiLENBQXNCOUcsSUFBdEIsQ0FBRCxJQUFnQyxPQUFPc0csS0FBSyxDQUFDSSxRQUFOLENBQWUxRyxJQUFmLENBQVAsS0FBZ0MsV0FBcEUsRUFBaUY7QUFDcEZzRyxxQkFBSyxDQUFDSSxRQUFOLENBQWUxRyxJQUFmLElBQXVCLENBQXZCO0FBQ0gsZUFGTSxNQUVBO0FBQ0hzRyxxQkFBSyxDQUFDSSxRQUFOLENBQWUxRyxJQUFmLEtBQXdCLENBQXhCO0FBQ0g7QUFDSixhQVZEO0FBV0FzRyxpQkFBSyxDQUFDQyxjQUFOLElBQXdCLENBQXhCO0FBQ0FELGlCQUFLLENBQUNFLGFBQU4sSUFBdUJPLFNBQXZCOztBQUVBLGdCQUFJVCxLQUFLLENBQUNyRSxjQUFOLENBQXFCd0MsTUFBckIsR0FBOEIsRUFBbEMsRUFBcUM7QUFDakM2QixtQkFBSyxDQUFDckUsY0FBTixDQUFxQitFLElBQXJCLENBQTBCdEssSUFBMUI7QUFDSDs7QUEzQ2E7QUFhWThILGFBQUMsRUFiYjtBQUFBO0FBQUE7O0FBQUE7QUErQ3RCOEIsaUJBQUssQ0FBQ1csMEJBQU4sR0FBbUNDLFlBQVksQ0FBQ1osS0FBSyxDQUFDckUsY0FBUCxDQUEvQztBQUNBcUUsaUJBQUssQ0FBQ0csb0JBQU4sR0FBNkJILEtBQUssQ0FBQ0UsYUFBTixHQUFzQkYsS0FBSyxDQUFDQyxjQUF6RDtBQWhEc0IsNkNBa0RmRCxLQWxEZTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUFIOztBQUFBLGtCQUFWN0csVUFBVTtBQUFBO0FBQUE7QUFBQSxHQUFoQjs7QUFxRFAsSUFBTXlILFlBQVksR0FBRyxTQUFmQSxZQUFlLENBQUFDLE9BQU8sRUFBSTtBQUM1QixNQUFJQyxLQUFLLEdBQUcsQ0FBWjtBQUNBRCxTQUFPLENBQUNyQyxPQUFSLENBQWdCLFVBQUFwSSxJQUFJO0FBQUEsV0FBSTBLLEtBQUssSUFBSXhFLFVBQVUsQ0FBQ2xHLElBQUksQ0FBQ21HLE1BQUwsQ0FBWUMsR0FBYixDQUF2QjtBQUFBLEdBQXBCO0FBQ0EsU0FBT3NFLEtBQUssR0FBR0QsT0FBTyxDQUFDMUMsTUFBdkI7QUFDSCxDQUpEOztBQU1BLElBQU1vQyxjQUFjLEdBQUcsU0FBakJBLGNBQWlCLENBQUFRLFdBQVcsRUFBSTtBQUNsQyxNQUFNQyxPQUFPLEdBQUdELFdBQVcsQ0FBQ2xELEtBQVosQ0FBa0IsR0FBbEIsQ0FBaEI7QUFDQSxTQUFPbUQsT0FBTyxDQUFDQyxNQUFSLENBQWUsVUFBQXZILElBQUk7QUFBQSxXQUFJQSxJQUFJLENBQUN5RSxNQUFMLEdBQWMsQ0FBbEI7QUFBQSxHQUFuQixDQUFQO0FBQ0gsQ0FIRCxDOzs7Ozs7Ozs7OztBQzdEQSx1QyIsImZpbGUiOiJtYWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvZGlzdC9cIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXguanNcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvc2hpbVwiKTtcblxucmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZVwiKTtcblxucmVxdWlyZShcImNvcmUtanMvZm4vcmVnZXhwL2VzY2FwZVwiKTtcblxuaWYgKGdsb2JhbC5fYmFiZWxQb2x5ZmlsbCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IG9uZSBpbnN0YW5jZSBvZiBiYWJlbC1wb2x5ZmlsbCBpcyBhbGxvd2VkXCIpO1xufVxuXG5nbG9iYWwuX2JhYmVsUG9seWZpbGwgPSB0cnVlO1xudmFyIERFRklORV9QUk9QRVJUWSA9IFwiZGVmaW5lUHJvcGVydHlcIjtcblxuZnVuY3Rpb24gZGVmaW5lKE8sIGtleSwgdmFsdWUpIHtcbiAgT1trZXldIHx8IE9iamVjdFtERUZJTkVfUFJPUEVSVFldKE8sIGtleSwge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG59XG5cbmRlZmluZShTdHJpbmcucHJvdG90eXBlLCBcInBhZExlZnRcIiwgXCJcIi5wYWRTdGFydCk7XG5kZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgXCJwYWRSaWdodFwiLCBcIlwiLnBhZEVuZCk7XG5cInBvcCxyZXZlcnNlLHNoaWZ0LGtleXMsdmFsdWVzLGVudHJpZXMsaW5kZXhPZixldmVyeSxzb21lLGZvckVhY2gsbWFwLGZpbHRlcixmaW5kLGZpbmRJbmRleCxpbmNsdWRlcyxqb2luLHNsaWNlLGNvbmNhdCxwdXNoLHNwbGljZSx1bnNoaWZ0LHNvcnQsbGFzdEluZGV4T2YscmVkdWNlLHJlZHVjZVJpZ2h0LGNvcHlXaXRoaW4sZmlsbFwiLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgW11ba2V5XSAmJiBkZWZpbmUoQXJyYXksIGtleSwgRnVuY3Rpb24uY2FsbC5iaW5kKFtdW2tleV0pKTtcbn0pOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvbWFzdGVyL0xJQ0VOU0UgZmlsZS4gQW5cbiAqIGFkZGl0aW9uYWwgZ3JhbnQgb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpblxuICogdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG4hZnVuY3Rpb24gKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9IC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG5cblxuICAgIHJldHVybjtcbiAgfSAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuXG5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7IC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuXG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7IC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cblxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJub3JtYWxcIixcbiAgICAgICAgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidGhyb3dcIixcbiAgICAgICAgYXJnOiBlcnJcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiOyAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cblxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9OyAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cblxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG5cblxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG5cbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID0gR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7IC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG5cbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTsgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cblxuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9fYXdhaXQ6IGFyZ1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwucHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBnbG9iYWwucHJvY2Vzcy5kb21haW4pIHtcbiAgICAgIGludm9rZSA9IGdsb2JhbC5wcm9jZXNzLmRvbWFpbi5iaW5kKGludm9rZSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPSAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH0gLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cblxuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG5cbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjsgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkpO1xuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9IC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcblxuXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG5cbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lID8gR2VuU3RhdGVDb21wbGV0ZWQgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7IC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG5cblxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcblxuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlOyAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7IC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9IC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cblxuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH0gLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuXG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjsgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHtcbiAgICAgIHRyeUxvYzogbG9jc1swXVxuICAgIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3tcbiAgICAgIHRyeUxvYzogXCJyb290XCJcbiAgICB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuXG4gICAga2V5cy5yZXZlcnNlKCk7IC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuXG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cblxuXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcblxuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSxcbiAgICAgICAgICAgIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH0gLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZG9uZVJlc3VsdFxuICAgIH07XG4gIH1cblxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgZG9uZTogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcbiAgICByZXNldDogZnVuY3Rpb24gKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwOyAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cblxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYWJydXB0OiBmdW5jdGlvbiAodHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJiAodHlwZSA9PT0gXCJicmVha1wiIHx8IHR5cGUgPT09IFwiY29udGludWVcIikgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uIChyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fCByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcbiAgICBmaW5pc2g6IGZ1bmN0aW9uIChmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcblxuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uICh0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cblxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiAoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0oIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbi8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuLy8gdXNlIGluZGlyZWN0IGV2YWwgKHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cbnR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpcyk7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuUmVnRXhwLmVzY2FwZTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07IiwidmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgbXNnKSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ251bWJlcicgJiYgY29mKGl0KSAhPSAnTnVtYmVyJykgdGhyb3cgVHlwZUVycm9yKG1zZyk7XG4gIHJldHVybiAraXQ7XG59OyIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpO1xuXG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbmlmIChBcnJheVByb3RvW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHJlcXVpcmUoJy4vX2hpZGUnKShBcnJheVByb3RvLCBVTlNDT1BBQkxFUywge30pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7IC8vIGBBZHZhbmNlU3RyaW5nSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUywgaW5kZXgsIHVuaWNvZGUpIHtcbiAgcmV0dXJuIGluZGV4ICsgKHVuaWNvZGUgPyBhdChTLCBpbmRleCkubGVuZ3RoIDogMSk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH1cblxuICByZXR1cm4gaXQ7XG59OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59OyIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXRcbi8qID0gMCAqL1xuLCBzdGFydFxuLyogPSAwLCBlbmQgPSBAbGVuZ3RoICovXG4pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIHRvID0gdG9BYnNvbHV0ZUluZGV4KHRhcmdldCwgbGVuKTtcbiAgdmFyIGZyb20gPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGNvdW50ID0gTWF0aC5taW4oKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuKSkgLSBmcm9tLCBsZW4gLSB0byk7XG4gIHZhciBpbmMgPSAxO1xuXG4gIGlmIChmcm9tIDwgdG8gJiYgdG8gPCBmcm9tICsgY291bnQpIHtcbiAgICBpbmMgPSAtMTtcbiAgICBmcm9tICs9IGNvdW50IC0gMTtcbiAgICB0byArPSBjb3VudCAtIDE7XG4gIH1cblxuICB3aGlsZSAoY291bnQtLSA+IDApIHtcbiAgICBpZiAoZnJvbSBpbiBPKSBPW3RvXSA9IE9bZnJvbV07ZWxzZSBkZWxldGUgT1t0b107XG4gICAgdG8gKz0gaW5jO1xuICAgIGZyb20gKz0gaW5jO1xuICB9XG5cbiAgcmV0dXJuIE87XG59OyIsIi8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWVcbi8qICwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovXG4pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKTtcblxuICB3aGlsZSAoZW5kUG9zID4gaW5kZXgpIE9baW5kZXgrK10gPSB2YWx1ZTtcblxuICByZXR1cm4gTztcbn07IiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXIsIElURVJBVE9SKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yT2YoaXRlciwgZmFsc2UsIHJlc3VsdC5wdXNoLCByZXN1bHQsIElURVJBVE9SKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07IiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlOyAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlOyAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTsiLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG5cbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbnZhciBhc2MgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCAkY3JlYXRlKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgdmFyIGNyZWF0ZSA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJT2JqZWN0KE8pO1xuICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsLCByZXM7XG5cbiAgICBmb3IgKDsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG5cbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHJlc3VsdFtpbmRleF0gPSByZXM7IC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXMpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHNvbWVcblxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgLy8gZmluZFxuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbCk7XG4gICAgICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgICB9IGVsc2UgaWYgKElTX0VWRVJZKSByZXR1cm4gZmFsc2U7IC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07IiwidmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgY2FsbGJhY2tmbiwgYUxlbiwgbWVtbywgaXNSaWdodCkge1xuICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gIHZhciBPID0gdG9PYmplY3QodGhhdCk7XG4gIHZhciBzZWxmID0gSU9iamVjdChPKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGluZGV4ID0gaXNSaWdodCA/IGxlbmd0aCAtIDEgOiAwO1xuICB2YXIgaSA9IGlzUmlnaHQgPyAtMSA6IDE7XG4gIGlmIChhTGVuIDwgMikgZm9yICg7Oykge1xuICAgIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICBtZW1vID0gc2VsZltpbmRleF07XG4gICAgICBpbmRleCArPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaW5kZXggKz0gaTtcblxuICAgIGlmIChpc1JpZ2h0ID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaXNSaWdodCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICB9XG5cbiAgcmV0dXJuIG1lbW87XG59OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG5cbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgdmFyIEM7XG5cbiAgaWYgKGlzQXJyYXkob3JpZ2luYWwpKSB7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yOyAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTsiLCIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcblxudmFyIGFycmF5U2xpY2UgPSBbXS5zbGljZTtcbnZhciBmYWN0b3JpZXMgPSB7fTtcblxudmFyIGNvbnN0cnVjdCA9IGZ1bmN0aW9uIChGLCBsZW4sIGFyZ3MpIHtcbiAgaWYgKCEobGVuIGluIGZhY3RvcmllcykpIHtcbiAgICBmb3IgKHZhciBuID0gW10sIGkgPSAwOyBpIDwgbGVuOyBpKyspIG5baV0gPSAnYVsnICsgaSArICddJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG5cblxuICAgIGZhY3Rvcmllc1tsZW5dID0gRnVuY3Rpb24oJ0YsYScsICdyZXR1cm4gbmV3IEYoJyArIG4uam9pbignLCcpICsgJyknKTtcbiAgfVxuXG4gIHJldHVybiBmYWN0b3JpZXNbbGVuXShGLCBhcmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXRcbi8qICwgLi4uYXJncyAqL1xuKSB7XG4gIHZhciBmbiA9IGFGdW5jdGlvbih0aGlzKTtcbiAgdmFyIHBhcnRBcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgdmFyIGJvdW5kID0gZnVuY3Rpb24gKClcbiAgLyogYXJncy4uLiAqL1xuICB7XG4gICAgdmFyIGFyZ3MgPSBwYXJ0QXJncy5jb25jYXQoYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgYm91bmQgPyBjb25zdHJ1Y3QoZm4sIGFyZ3MubGVuZ3RoLCBhcmdzKSA6IGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG5cbiAgaWYgKGlzT2JqZWN0KGZuLnByb3RvdHlwZSkpIGJvdW5kLnByb3RvdHlwZSA9IGZuLnByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kO1xufTsiLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuXG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7IC8vIEVTMyB3cm9uZyBoZXJlXG5cblxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBhcmd1bWVudHM7XG59KCkpID09ICdBcmd1bWVudHMnOyAvLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxuXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCcgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFQgLy8gYnVpbHRpblRhZyBjYXNlXG4gIDogQVJHID8gY29mKE8pIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59OyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5cbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG5cbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xuXG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG5cbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcblxudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbnZhciAkaXRlckRlZmluZSA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJyk7XG5cbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG5cbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcblxudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcblxudmFyIGZhc3RLZXkgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleTtcblxudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xuXG52YXIgU0laRSA9IERFU0NSSVBUT1JTID8gJ19zJyA6ICdzaXplJztcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24gKHRoYXQsIGtleSkge1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xuICB2YXIgZW50cnk7XG4gIGlmIChpbmRleCAhPT0gJ0YnKSByZXR1cm4gdGhhdC5faVtpbmRleF07IC8vIGZyb3plbiBvYmplY3QgY2FzZVxuXG4gIGZvciAoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgaWYgKGVudHJ5LmsgPT0ga2V5KSByZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7IC8vIGNvbGxlY3Rpb24gdHlwZVxuXG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuXG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAvLyBmaXJzdCBlbnRyeVxuXG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAvLyBsYXN0IGVudHJ5XG5cbiAgICAgIHRoYXRbU0laRV0gPSAwOyAvLyBzaXplXG5cbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgZm9yICh2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBkYXRhID0gdGhhdC5faSwgZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKGVudHJ5LnApIGVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuXG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkubjtcbiAgICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKHByZXYpIHByZXYubiA9IG5leHQ7XG4gICAgICAgICAgaWYgKG5leHQpIG5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYgKHRoYXQuX2YgPT0gZW50cnkpIHRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmICh0aGF0Ll9sID09IGVudHJ5KSB0aGF0Ll9sID0gcHJldjtcbiAgICAgICAgICB0aGF0W1NJWkVdLS07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuXG4gICAgICAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi9cbiAgICAgICkge1xuICAgICAgICB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpO1xuICAgICAgICB2YXIgZW50cnk7XG5cbiAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZikge1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7IC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuXG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChERVNDUklQVE9SUykgZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh0aGlzLCBOQU1FKVtTSVpFXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgdmFyIHByZXYsIGluZGV4OyAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcblxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudiA9IHZhbHVlOyAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksXG4gICAgICAgIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSxcbiAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLFxuICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdC5fbCxcbiAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLFxuICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlIC8vIDwtIHJlbW92ZWRcblxuICAgICAgfTtcbiAgICAgIGlmICghdGhhdC5fZikgdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYgKHByZXYpIHByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrOyAvLyBhZGQgdG8gaW5kZXhcblxuICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHRoYXQuX2lbaW5kZXhdID0gZW50cnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgTkFNRSwgSVNfTUFQKSB7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgdGhpcy5fdCA9IHZhbGlkYXRlKGl0ZXJhdGVkLCBOQU1FKTsgLy8gdGFyZ2V0XG5cbiAgICAgIHRoaXMuX2sgPSBraW5kOyAvLyBraW5kXG5cbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7IC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGtpbmQgPSB0aGF0Ll9rO1xuICAgICAgdmFyIGVudHJ5ID0gdGhhdC5fbDsgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG5cbiAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7IC8vIGdldCBuZXh0IGVudHJ5XG5cblxuICAgICAgaWYgKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9IC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcblxuXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7IC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG5cbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xuXG52YXIgZnJvbSA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIGlmIChjbGFzc29mKHRoaXMpICE9IE5BTUUpIHRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgcmV0dXJuIGZyb20odGhpcyk7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG5cbnZhciBnZXRXZWFrID0gcmVxdWlyZSgnLi9fbWV0YScpLmdldFdlYWs7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xuXG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxudmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xuXG52YXIgJGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuXG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG5cbnZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbnZhciBhcnJheUZpbmRJbmRleCA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpO1xudmFyIGlkID0gMDsgLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG5cbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgcmV0dXJuIHRoYXQuX2wgfHwgKHRoYXQuX2wgPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSgpKTtcbn07XG5cbnZhciBVbmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmEgPSBbXTtcbn07XG5cbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbiAoc3RvcmUsIGtleSkge1xuICByZXR1cm4gYXJyYXlGaW5kKHN0b3JlLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5cblVuY2F1Z2h0RnJvemVuU3RvcmUucHJvdG90eXBlID0ge1xuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZiAoZW50cnkpIHJldHVybiBlbnRyeVsxXTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICEhZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZiAoZW50cnkpIGVudHJ5WzFdID0gdmFsdWU7ZWxzZSB0aGlzLmEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9LFxuICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBpbmRleCA9IGFycmF5RmluZEluZGV4KHRoaXMuYSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgICB9KTtcbiAgICBpZiAofmluZGV4KSB0aGlzLmEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAvLyBjb2xsZWN0aW9uIHR5cGVcblxuICAgICAgdGhhdC5faSA9IGlkKys7IC8vIGNvbGxlY3Rpb24gaWRcblxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgLy8gbGVhayBzdG9yZSBmb3IgdW5jYXVnaHQgZnJvemVuIG9iamVjdHNcblxuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4zLjMuMiBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuNC4zLjMgV2Vha1NldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgTkFNRSkpWydkZWxldGUnXShrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpICYmIGRlbGV0ZSBkYXRhW3RoaXMuX2ldO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjMuMy40IFdlYWtNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy40LjMuNCBXZWFrU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgTkFNRSkpLmhhcyhrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIGRhdGEgPSBnZXRXZWFrKGFuT2JqZWN0KGtleSksIHRydWUpO1xuICAgIGlmIChkYXRhID09PSB0cnVlKSB1bmNhdWdodEZyb3plblN0b3JlKHRoYXQpLnNldChrZXksIHZhbHVlKTtlbHNlIGRhdGFbdGhhdC5faV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhhdDtcbiAgfSxcbiAgdWZzdG9yZTogdW5jYXVnaHRGcm96ZW5TdG9yZVxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcblxudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG5cbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xuXG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxudmFyICRpdGVyRGV0ZWN0ID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKTtcblxudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcblxudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSykge1xuICB2YXIgQmFzZSA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIEMgPSBCYXNlO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlO1xuICB2YXIgTyA9IHt9O1xuXG4gIHZhciBmaXhNZXRob2QgPSBmdW5jdGlvbiAoS0VZKSB7XG4gICAgdmFyIGZuID0gcHJvdG9bS0VZXTtcbiAgICByZWRlZmluZShwcm90bywgS0VZLCBLRVkgPT0gJ2RlbGV0ZScgPyBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKSB7XG4gICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICB9IDogS0VZID09ICdnZXQnID8gZnVuY3Rpb24gZ2V0KGEpIHtcbiAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IHVuZGVmaW5lZCA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICB9IDogS0VZID09ICdhZGQnID8gZnVuY3Rpb24gYWRkKGEpIHtcbiAgICAgIGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gOiBmdW5jdGlvbiBzZXQoYSwgYikge1xuICAgICAgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gIH07XG5cbiAgaWYgKHR5cGVvZiBDICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IHByb3RvLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSkge1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gICAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQygpOyAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG5cbiAgICB2YXIgSEFTTlRfQ0hBSU5JTkcgPSBpbnN0YW5jZVtBRERFUl0oSVNfV0VBSyA/IHt9IDogLTAsIDEpICE9IGluc3RhbmNlOyAvLyBWOCB+ICBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcblxuICAgIHZhciBUSFJPV1NfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIGluc3RhbmNlLmhhcygxKTtcbiAgICB9KTsgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuXG4gICAgdmFyIEFDQ0VQVF9JVEVSQUJMRVMgPSAkaXRlckRldGVjdChmdW5jdGlvbiAoaXRlcikge1xuICAgICAgbmV3IEMoaXRlcik7XG4gICAgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgLy8gZm9yIGVhcmx5IGltcGxlbWVudGF0aW9ucyAtMCBhbmQgKzAgbm90IHRoZSBzYW1lXG5cbiAgICB2YXIgQlVHR1lfWkVSTyA9ICFJU19XRUFLICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFY4IH4gQ2hyb21pdW0gNDItIGZhaWxzIG9ubHkgd2l0aCA1KyBlbGVtZW50c1xuICAgICAgdmFyICRpbnN0YW5jZSA9IG5ldyBDKCk7XG4gICAgICB2YXIgaW5kZXggPSA1O1xuXG4gICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuXG4gICAgICByZXR1cm4gISRpbnN0YW5jZS5oYXMoLTApO1xuICAgIH0pO1xuXG4gICAgaWYgKCFBQ0NFUFRfSVRFUkFCTEVTKSB7XG4gICAgICBDID0gd3JhcHBlcihmdW5jdGlvbiAodGFyZ2V0LCBpdGVyYWJsZSkge1xuICAgICAgICBhbkluc3RhbmNlKHRhcmdldCwgQywgTkFNRSk7XG4gICAgICAgIHZhciB0aGF0ID0gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UoKSwgdGFyZ2V0LCBDKTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH0pO1xuICAgICAgQy5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgIHByb3RvLmNvbnN0cnVjdG9yID0gQztcbiAgICB9XG5cbiAgICBpZiAoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTykge1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG5cbiAgICBpZiAoQlVHR1lfWkVSTyB8fCBIQVNOVF9DSEFJTklORykgZml4TWV0aG9kKEFEREVSKTsgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcblxuICAgIGlmIChJU19XRUFLICYmIHByb3RvLmNsZWFyKSBkZWxldGUgcHJvdG8uY2xlYXI7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEMgIT0gQmFzZSksIE8pO1xuICBpZiAoIUlTX1dFQUspIGNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcbiAgcmV0dXJuIEM7XG59OyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZlcnNpb246ICcyLjYuMTEnXG59O1xuaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCBpbiBvYmplY3QpICRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07IiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcblxuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgICB9O1xuXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKVxuICAvKiAuLi5hcmdzICovXG4gIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07IiwiJ3VzZSBzdHJpY3QnOyAvLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxuXG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG52YXIgZ2V0VGltZSA9IERhdGUucHJvdG90eXBlLmdldFRpbWU7XG52YXIgJHRvSVNPU3RyaW5nID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmc7XG5cbnZhciBseiA9IGZ1bmN0aW9uIChudW0pIHtcbiAgcmV0dXJuIG51bSA+IDkgPyBudW0gOiAnMCcgKyBudW07XG59OyAvLyBQaGFudG9tSlMgLyBvbGQgV2ViS2l0IGhhcyBhIGJyb2tlbiBpbXBsZW1lbnRhdGlvbnNcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICR0b0lTT1N0cmluZy5jYWxsKG5ldyBEYXRlKC01ZTEzIC0gMSkpICE9ICcwMzg1LTA3LTI1VDA3OjA2OjM5Ljk5OVonO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgJHRvSVNPU3RyaW5nLmNhbGwobmV3IERhdGUoTmFOKSk7XG59KSA/IGZ1bmN0aW9uIHRvSVNPU3RyaW5nKCkge1xuICBpZiAoIWlzRmluaXRlKGdldFRpbWUuY2FsbCh0aGlzKSkpIHRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZScpO1xuICB2YXIgZCA9IHRoaXM7XG4gIHZhciB5ID0gZC5nZXRVVENGdWxsWWVhcigpO1xuICB2YXIgbSA9IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIHZhciBzID0geSA8IDAgPyAnLScgOiB5ID4gOTk5OSA/ICcrJyA6ICcnO1xuICByZXR1cm4gcyArICgnMDAwMDAnICsgTWF0aC5hYnMoeSkpLnNsaWNlKHMgPyAtNiA6IC00KSArICctJyArIGx6KGQuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICsgbHooZC5nZXRVVENEYXRlKCkpICsgJ1QnICsgbHooZC5nZXRVVENIb3VycygpKSArICc6JyArIGx6KGQuZ2V0VVRDTWludXRlcygpKSArICc6JyArIGx6KGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChtID4gOTkgPyBtIDogJzAnICsgbHoobSkpICsgJ1onO1xufSA6ICR0b0lTT1N0cmluZzsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxudmFyIE5VTUJFUiA9ICdudW1iZXInO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChoaW50KSB7XG4gIGlmIChoaW50ICE9PSAnc3RyaW5nJyAmJiBoaW50ICE9PSBOVU1CRVIgJiYgaGludCAhPT0gJ2RlZmF1bHQnKSB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCBoaW50Jyk7XG4gIHJldHVybiB0b1ByaW1pdGl2ZShhbk9iamVjdCh0aGlzKSwgaGludCAhPSBOVU1CRVIpO1xufTsiLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59OyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiA3O1xuICAgIH1cbiAgfSkuYSAhPSA3O1xufSk7IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50OyAvLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcblxuXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59OyIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZicuc3BsaXQoJywnKTsiLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG5cbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciByZXN1bHQgPSBnZXRLZXlzKGl0KTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG5cbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcblxuICAgIHdoaWxlIChzeW1ib2xzLmxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59OyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG5cbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xuXG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xuXG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG5cbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG4gIHZhciBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG5cbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDsgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcblxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07IC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG5cbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDsgLy8gZXh0ZW5kIGdsb2JhbFxuXG4gICAgaWYgKHRhcmdldCkgcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7IC8vIGV4cG9ydFxuXG4gICAgaWYgKGV4cG9ydHNba2V5XSAhPSBvdXQpIGhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmIChJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dCkgZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcblxuZ2xvYmFsLmNvcmUgPSBjb3JlOyAvLyB0eXBlIGJpdG1hcFxuXG4kZXhwb3J0LkYgPSAxOyAvLyBmb3JjZWRcblxuJGV4cG9ydC5HID0gMjsgLy8gZ2xvYmFsXG5cbiRleHBvcnQuUyA9IDQ7IC8vIHN0YXRpY1xuXG4kZXhwb3J0LlAgPSA4OyAvLyBwcm90b1xuXG4kZXhwb3J0LkIgPSAxNjsgLy8gYmluZFxuXG4kZXhwb3J0LlcgPSAzMjsgLy8gd3JhcFxuXG4kZXhwb3J0LlUgPSA2NDsgLy8gc2FmZVxuXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcblxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0OyIsInZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIHJlID0gLy4vO1xuXG4gIHRyeSB7XG4gICAgJy8uLydbS0VZXShyZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgcmVbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gIScvLi8nW0tFWV0ocmUpO1xuICAgIH0gY2F0Y2ggKGYpIHtcbiAgICAgIC8qIGVtcHR5ICovXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vZXM2LnJlZ2V4cC5leGVjJyk7XG5cbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5cbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xuXG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjJyk7XG5cbnZhciBTUEVDSUVTID0gd2tzKCdzcGVjaWVzJyk7XG52YXIgUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyAjcmVwbGFjZSBuZWVkcyBidWlsdC1pbiBzdXBwb3J0IGZvciBuYW1lZCBncm91cHMuXG4gIC8vICNtYXRjaCB3b3JrcyBmaW5lIGJlY2F1c2UgaXQganVzdCByZXR1cm4gdGhlIGV4ZWMgcmVzdWx0cywgZXZlbiBpZiBpdCBoYXNcbiAgLy8gYSBcImdyb3BzXCIgcHJvcGVydHkuXG4gIHZhciByZSA9IC8uLztcblxuICByZS5leGVjID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICByZXN1bHQuZ3JvdXBzID0ge1xuICAgICAgYTogJzcnXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiAnJy5yZXBsYWNlKHJlLCAnJDxhPicpICE9PSAnNyc7XG59KTtcblxudmFyIFNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gQ2hyb21lIDUxIGhhcyBhIGJ1Z2d5IFwic3BsaXRcIiBpbXBsZW1lbnRhdGlvbiB3aGVuIFJlZ0V4cCNleGVjICE9PSBuYXRpdmVFeGVjXG4gIHZhciByZSA9IC8oPzopLztcbiAgdmFyIG9yaWdpbmFsRXhlYyA9IHJlLmV4ZWM7XG5cbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gb3JpZ2luYWxFeGVjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIHJlc3VsdCA9ICdhYicuc3BsaXQocmUpO1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMiAmJiByZXN1bHRbMF0gPT09ICdhJyAmJiByZXN1bHRbMV0gPT09ICdiJztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBsZW5ndGgsIGV4ZWMpIHtcbiAgdmFyIFNZTUJPTCA9IHdrcyhLRVkpO1xuICB2YXIgREVMRUdBVEVTX1RPX1NZTUJPTCA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3RyaW5nIG1ldGhvZHMgY2FsbCBzeW1ib2wtbmFtZWQgUmVnRXAgbWV0aG9kc1xuICAgIHZhciBPID0ge307XG5cbiAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gNztcbiAgICB9O1xuXG4gICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcbiAgfSk7XG4gIHZhciBERUxFR0FURVNfVE9fRVhFQyA9IERFTEVHQVRFU19UT19TWU1CT0wgPyAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN5bWJvbC1uYW1lZCBSZWdFeHAgbWV0aG9kcyBjYWxsIC5leGVjXG4gICAgdmFyIGV4ZWNDYWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgcmUgPSAvYS87XG5cbiAgICByZS5leGVjID0gZnVuY3Rpb24gKCkge1xuICAgICAgZXhlY0NhbGxlZCA9IHRydWU7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgaWYgKEtFWSA9PT0gJ3NwbGl0Jykge1xuICAgICAgLy8gUmVnRXhwW0BAc3BsaXRdIGRvZXNuJ3QgY2FsbCB0aGUgcmVnZXgncyBleGVjIG1ldGhvZCwgYnV0IGZpcnN0IGNyZWF0ZXNcbiAgICAgIC8vIGEgbmV3IG9uZS4gV2UgbmVlZCB0byByZXR1cm4gdGhlIHBhdGNoZWQgcmVnZXggd2hlbiBjcmVhdGluZyB0aGUgbmV3IG9uZS5cbiAgICAgIHJlLmNvbnN0cnVjdG9yID0ge307XG5cbiAgICAgIHJlLmNvbnN0cnVjdG9yW1NQRUNJRVNdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJlW1NZTUJPTF0oJycpO1xuICAgIHJldHVybiAhZXhlY0NhbGxlZDtcbiAgfSkgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKCFERUxFR0FURVNfVE9fU1lNQk9MIHx8ICFERUxFR0FURVNfVE9fRVhFQyB8fCBLRVkgPT09ICdyZXBsYWNlJyAmJiAhUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgfHwgS0VZID09PSAnc3BsaXQnICYmICFTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMpIHtcbiAgICB2YXIgbmF0aXZlUmVnRXhwTWV0aG9kID0gLy4vW1NZTUJPTF07XG4gICAgdmFyIGZucyA9IGV4ZWMoZGVmaW5lZCwgU1lNQk9MLCAnJ1tLRVldLCBmdW5jdGlvbiBtYXliZUNhbGxOYXRpdmUobmF0aXZlTWV0aG9kLCByZWdleHAsIHN0ciwgYXJnMiwgZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgIGlmIChyZWdleHAuZXhlYyA9PT0gcmVnZXhwRXhlYykge1xuICAgICAgICBpZiAoREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgICAgICAvLyBUaGUgbmF0aXZlIFN0cmluZyBtZXRob2QgYWxyZWFkeSBkZWxlZ2F0ZXMgdG8gQEBtZXRob2QgKHRoaXNcbiAgICAgICAgICAvLyBwb2x5ZmlsbGVkIGZ1bmN0aW9uKSwgbGVhc2luZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgICAgICAgLy8gV2UgYXZvaWQgaXQgYnkgZGlyZWN0bHkgY2FsbGluZyB0aGUgbmF0aXZlIEBAbWV0aG9kIG1ldGhvZC5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuYXRpdmVSZWdFeHBNZXRob2QuY2FsbChyZWdleHAsIHN0ciwgYXJnMilcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBuYXRpdmVNZXRob2QuY2FsbChzdHIsIHJlZ2V4cCwgYXJnMilcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIHN0cmZuID0gZm5zWzBdO1xuICAgIHZhciByeGZuID0gZm5zWzFdO1xuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xuICAgIGhpZGUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMiAvLyAyMS4yLjUuOCBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV0oc3RyaW5nLCByZXBsYWNlVmFsdWUpXG4gICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICA/IGZ1bmN0aW9uIChzdHJpbmcsIGFyZykge1xuICAgICAgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7XG4gICAgfSAvLyAyMS4yLjUuNiBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdKHN0cmluZylcbiAgICAvLyAyMS4yLjUuOSBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXShzdHJpbmcpXG4gICAgOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcyk7XG4gICAgfSk7XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnOyAvLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFnc1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QodGhpcyk7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZiAodGhhdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07IiwiJ3VzZSBzdHJpY3QnOyAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLWZsYXRNYXAvI3NlYy1GbGF0dGVuSW50b0FycmF5XG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG5cbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRSA9IHJlcXVpcmUoJy4vX3drcycpKCdpc0NvbmNhdFNwcmVhZGFibGUnKTtcblxuZnVuY3Rpb24gZmxhdHRlbkludG9BcnJheSh0YXJnZXQsIG9yaWdpbmFsLCBzb3VyY2UsIHNvdXJjZUxlbiwgc3RhcnQsIGRlcHRoLCBtYXBwZXIsIHRoaXNBcmcpIHtcbiAgdmFyIHRhcmdldEluZGV4ID0gc3RhcnQ7XG4gIHZhciBzb3VyY2VJbmRleCA9IDA7XG4gIHZhciBtYXBGbiA9IG1hcHBlciA/IGN0eChtYXBwZXIsIHRoaXNBcmcsIDMpIDogZmFsc2U7XG4gIHZhciBlbGVtZW50LCBzcHJlYWRhYmxlO1xuXG4gIHdoaWxlIChzb3VyY2VJbmRleCA8IHNvdXJjZUxlbikge1xuICAgIGlmIChzb3VyY2VJbmRleCBpbiBzb3VyY2UpIHtcbiAgICAgIGVsZW1lbnQgPSBtYXBGbiA/IG1hcEZuKHNvdXJjZVtzb3VyY2VJbmRleF0sIHNvdXJjZUluZGV4LCBvcmlnaW5hbCkgOiBzb3VyY2Vbc291cmNlSW5kZXhdO1xuICAgICAgc3ByZWFkYWJsZSA9IGZhbHNlO1xuXG4gICAgICBpZiAoaXNPYmplY3QoZWxlbWVudCkpIHtcbiAgICAgICAgc3ByZWFkYWJsZSA9IGVsZW1lbnRbSVNfQ09OQ0FUX1NQUkVBREFCTEVdO1xuICAgICAgICBzcHJlYWRhYmxlID0gc3ByZWFkYWJsZSAhPT0gdW5kZWZpbmVkID8gISFzcHJlYWRhYmxlIDogaXNBcnJheShlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNwcmVhZGFibGUgJiYgZGVwdGggPiAwKSB7XG4gICAgICAgIHRhcmdldEluZGV4ID0gZmxhdHRlbkludG9BcnJheSh0YXJnZXQsIG9yaWdpbmFsLCBlbGVtZW50LCB0b0xlbmd0aChlbGVtZW50Lmxlbmd0aCksIHRhcmdldEluZGV4LCBkZXB0aCAtIDEpIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0YXJnZXRJbmRleCA+PSAweDFmZmZmZmZmZmZmZmZmKSB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgdGFyZ2V0W3RhcmdldEluZGV4XSA9IGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldEluZGV4Kys7XG4gICAgfVxuXG4gICAgc291cmNlSW5kZXgrKztcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRJbmRleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuSW50b0FycmF5OyIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcblxudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcblxudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcblxudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKSB7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXRlcmFibGU7XG4gIH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpO1xuICB2YXIgZiA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7IC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG5leHBvcnRzLkJSRUFLID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCduYXRpdmUtZnVuY3Rpb24tdG8tc3RyaW5nJywgRnVuY3Rpb24udG9TdHJpbmcpOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGggPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG46IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59OyIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07IiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OyIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDc7XG4gICAgfVxuICB9KS5hICE9IDc7XG59KTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCB0YXJnZXQsIEMpIHtcbiAgdmFyIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIHZhciBQO1xuXG4gIGlmIChTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIGlzT2JqZWN0KFApICYmIHNldFByb3RvdHlwZU9mKSB7XG4gICAgc2V0UHJvdG90eXBlT2YodGhhdCwgUCk7XG4gIH1cblxuICByZXR1cm4gdGhhdDtcbn07IiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgYXJncywgdGhhdCkge1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG5cbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiB1biA/IGZuKCkgOiBmbi5jYWxsKHRoYXQpO1xuXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIHVuID8gZm4oYXJnc1swXSkgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSkgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSkgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuXG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSkgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9XG5cbiAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTsiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59OyIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcblxudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG5cbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTsiLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59OyIsIi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KSB7XG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTsiLCIvLyA3LjIuOCBJc1JlZ0V4cChhcmd1bWVudClcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5cbnZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjb2YoaXQpID09ICdSZWdFeHAnKTtcbn07IiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpOyAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG5cbnZhciBkZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuXG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xuXG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTsgLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcblxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtcbiAgICBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpXG4gIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcblxudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5cbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcblxudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcblxudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcblxudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcblxudmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG5cbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuXG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuXG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7XG4gICAgICAgIH07XG5cbiAgICAgIGNhc2UgVkFMVUVTOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTsgLy8gRml4IG5hdGl2ZVxuXG4gIGlmICgkYW55TmF0aXZlKSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UoKSkpO1xuXG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpOyAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcblxuICAgICAgaWYgKCFMSUJSQVJZICYmIHR5cGVvZiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0gIT0gJ2Z1bmN0aW9uJykgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfSAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG5cblxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG5cbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgfSAvLyBEZWZpbmUgaXRlcmF0b3JcblxuXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH0gLy8gUGx1ZyBmb3IgbGlicmFyeVxuXG5cbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcblxuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59OyIsInZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xuXG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcblxuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcbiAgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcblxuXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyAyO1xuICB9KTtcbn0gY2F0Y2ggKGUpIHtcbiAgLyogZW1wdHkgKi9cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuXG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogc2FmZSA9IHRydWVcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaXRlcjtcbiAgICB9O1xuXG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfVxuXG4gIHJldHVybiBzYWZlO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBkb25lOiAhIWRvbmVcbiAgfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7fTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlOyIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG0xID0gTWF0aC5leHBtMTtcbm1vZHVsZS5leHBvcnRzID0gISRleHBtMSAvLyBPbGQgRkYgYnVnXG58fCAkZXhwbTEoMTApID4gMjIwMjUuNDY1Nzk0ODA2NzE5IHx8ICRleHBtMSgxMCkgPCAyMjAyNS40NjU3OTQ4MDY3MTY1MTY4IC8vIFRvciBCcm93c2VyIGJ1Z1xufHwgJGV4cG0xKC0yZS0xNykgIT0gLTJlLTE3ID8gZnVuY3Rpb24gZXhwbTEoeCkge1xuICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiB4ID4gLTFlLTYgJiYgeCA8IDFlLTYgPyB4ICsgeCAqIHggLyAyIDogTWF0aC5leHAoeCkgLSAxO1xufSA6ICRleHBtMTsiLCIvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbnZhciBzaWduID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJyk7XG5cbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBFUFNJTE9OID0gcG93KDIsIC01Mik7XG52YXIgRVBTSUxPTjMyID0gcG93KDIsIC0yMyk7XG52YXIgTUFYMzIgPSBwb3coMiwgMTI3KSAqICgyIC0gRVBTSUxPTjMyKTtcbnZhciBNSU4zMiA9IHBvdygyLCAtMTI2KTtcblxudmFyIHJvdW5kVGllc1RvRXZlbiA9IGZ1bmN0aW9uIChuKSB7XG4gIHJldHVybiBuICsgMSAvIEVQU0lMT04gLSAxIC8gRVBTSUxPTjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5mcm91bmQgfHwgZnVuY3Rpb24gZnJvdW5kKHgpIHtcbiAgdmFyICRhYnMgPSBNYXRoLmFicyh4KTtcbiAgdmFyICRzaWduID0gc2lnbih4KTtcbiAgdmFyIGEsIHJlc3VsdDtcbiAgaWYgKCRhYnMgPCBNSU4zMikgcmV0dXJuICRzaWduICogcm91bmRUaWVzVG9FdmVuKCRhYnMgLyBNSU4zMiAvIEVQU0lMT04zMikgKiBNSU4zMiAqIEVQU0lMT04zMjtcbiAgYSA9ICgxICsgRVBTSUxPTjMyIC8gRVBTSUxPTikgKiAkYWJzO1xuICByZXN1bHQgPSBhIC0gKGEgLSAkYWJzKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuXG4gIGlmIChyZXN1bHQgPiBNQVgzMiB8fCByZXN1bHQgIT0gcmVzdWx0KSByZXR1cm4gJHNpZ24gKiBJbmZpbml0eTtcbiAgcmV0dXJuICRzaWduICogcmVzdWx0O1xufTsiLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmxvZzFwIHx8IGZ1bmN0aW9uIGxvZzFwKHgpIHtcbiAgcmV0dXJuICh4ID0gK3gpID4gLTFlLTggJiYgeCA8IDFlLTggPyB4IC0geCAqIHggLyAyIDogTWF0aC5sb2coMSArIHgpO1xufTsiLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguc2NhbGUgfHwgZnVuY3Rpb24gc2NhbGUoeCwgaW5Mb3csIGluSGlnaCwgb3V0TG93LCBvdXRIaWdoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgfHwgeCAhPSB4IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgfHwgaW5Mb3cgIT0gaW5Mb3cgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICB8fCBpbkhpZ2ggIT0gaW5IaWdoIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgfHwgb3V0TG93ICE9IG91dExvdyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHx8IG91dEhpZ2ggIT0gb3V0SGlnaCkgcmV0dXJuIE5hTjtcbiAgaWYgKHggPT09IEluZmluaXR5IHx8IHggPT09IC1JbmZpbml0eSkgcmV0dXJuIHg7XG4gIHJldHVybiAoeCAtIGluTG93KSAqIChvdXRIaWdoIC0gb3V0TG93KSAvIChpbkhpZ2ggLSBpbkxvdykgKyBvdXRMb3c7XG59OyIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uIHNpZ24oeCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiAoeCA9ICt4KSA9PSAwIHx8IHggIT0geCA/IHggOiB4IDwgMCA/IC0xIDogMTtcbn07IiwidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuXG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5cbnZhciBpZCA9IDA7XG5cbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG5cbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHtcbiAgICB2YWx1ZToge1xuICAgICAgaTogJ08nICsgKytpZCxcbiAgICAgIC8vIG9iamVjdCBJRFxuICAgICAgdzoge30gLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcblxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG5cbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7IC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG5cbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJzsgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcblxuICAgIHNldE1ldGEoaXQpOyAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH1cblxuICByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG5cbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlOyAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTsgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcblxuICAgIHNldE1ldGEoaXQpOyAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9XG5cbiAgcmV0dXJuIGl0W01FVEFdLnc7XG59OyAvLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcblxuXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogTUVUQSxcbiAgTkVFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWs6IGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTsiLCJ2YXIgTWFwID0gcmVxdWlyZSgnLi9lczYubWFwJyk7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnbWV0YWRhdGEnKTtcblxudmFyIHN0b3JlID0gc2hhcmVkLnN0b3JlIHx8IChzaGFyZWQuc3RvcmUgPSBuZXcgKHJlcXVpcmUoJy4vZXM2LndlYWstbWFwJykpKCkpO1xuXG52YXIgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldEtleSwgY3JlYXRlKSB7XG4gIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuXG4gIGlmICghdGFyZ2V0TWV0YWRhdGEpIHtcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBzdG9yZS5zZXQodGFyZ2V0LCB0YXJnZXRNZXRhZGF0YSA9IG5ldyBNYXAoKSk7XG4gIH1cblxuICB2YXIga2V5TWV0YWRhdGEgPSB0YXJnZXRNZXRhZGF0YS5nZXQodGFyZ2V0S2V5KTtcblxuICBpZiAoIWtleU1ldGFkYXRhKSB7XG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgdGFyZ2V0TWV0YWRhdGEuc2V0KHRhcmdldEtleSwga2V5TWV0YWRhdGEgPSBuZXcgTWFwKCkpO1xuICB9XG5cbiAgcmV0dXJuIGtleU1ldGFkYXRhO1xufTtcblxudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gIHJldHVybiBtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBtZXRhZGF0YU1hcC5oYXMoTWV0YWRhdGFLZXkpO1xufTtcblxudmFyIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gIHJldHVybiBtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbWV0YWRhdGFNYXAuZ2V0KE1ldGFkYXRhS2V5KTtcbn07XG5cbnZhciBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlLCBPLCBQKSB7XG4gIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgdHJ1ZSkuc2V0KE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlKTtcbn07XG5cbnZhciBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldEtleSkge1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKHRhcmdldCwgdGFyZ2V0S2V5LCBmYWxzZSk7XG4gIHZhciBrZXlzID0gW107XG4gIGlmIChtZXRhZGF0YU1hcCkgbWV0YWRhdGFNYXAuZm9yRWFjaChmdW5jdGlvbiAoXywga2V5KSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH0pO1xuICByZXR1cm4ga2V5cztcbn07XG5cbnZhciB0b01ldGFLZXkgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiBTdHJpbmcoaXQpO1xufTtcblxudmFyIGV4cCA9IGZ1bmN0aW9uIChPKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIE8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0b3JlOiBzdG9yZSxcbiAgbWFwOiBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwLFxuICBoYXM6IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEsXG4gIGdldDogb3JkaW5hcnlHZXRPd25NZXRhZGF0YSxcbiAgc2V0OiBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhLFxuICBrZXlzOiBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyxcbiAga2V5OiB0b01ldGFLZXksXG4gIGV4cDogZXhwXG59OyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG5cbnZhciBPYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuXG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgIGZuID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkoKTtlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTsgLy8gTm9kZS5qc1xuXG5cbiAgaWYgKGlzTm9kZSkge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07IC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyBTYWZhcmkgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzM5XG5cbiAgfSBlbHNlIGlmIChPYnNlcnZlciAmJiAhKGdsb2JhbC5uYXZpZ2F0b3IgJiYgZ2xvYmFsLm5hdmlnYXRvci5zdGFuZGFsb25lKSkge1xuICAgIHZhciB0b2dnbGUgPSB0cnVlO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG5cbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07IC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG5cbiAgfSBlbHNlIGlmIChQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSkge1xuICAgIC8vIFByb21pc2UucmVzb2x2ZSB3aXRob3V0IGFuIGFyZ3VtZW50IHRocm93cyBhbiBlcnJvciBpbiBMRyBXZWJPUyAyXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcblxuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTsgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgICAvLyAtIHNldEltbWVkaWF0ZVxuICAgIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gICAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgICAvLyAtIHNldFRpbWVvdXRcblxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIHRhc2sgPSB7XG4gICAgICBmbjogZm4sXG4gICAgICBuZXh0OiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuXG4gICAgaWYgKCFoZWFkKSB7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH1cblxuICAgIGxhc3QgPSB0YXNrO1xuICB9O1xufTsiLCIndXNlIHN0cmljdCc7IC8vIDI1LjQuMS41IE5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG5cbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbmZ1bmN0aW9uIFByb21pc2VDYXBhYmlsaXR5KEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59OyIsIid1c2Ugc3RyaWN0JzsgLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxuXG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xuXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcblxudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xuXG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247IC8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxuXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgQltrXSA9IGs7XG4gIH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG5cbiAgd2hpbGUgKGFMZW4gPiBpbmRleCkge1xuICAgIHZhciBTID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG5cbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAga2V5ID0ga2V5c1tqKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBpc0VudW0uY2FsbChTLCBrZXkpKSBUW2tleV0gPSBTW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFQ7XG59IDogJGFzc2lnbjsiLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgZFBzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpO1xuXG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAvKiBlbXB0eSAqL1xufTtcblxudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnOyAvLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG5cbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcblxuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG5cbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuXG4gIHdoaWxlIChpLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuXG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcblxuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDsgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG5cbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTsiLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcblxudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59OyIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG5cbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG5cbiAgcmV0dXJuIE87XG59OyIsIid1c2Ugc3RyaWN0JzsgLy8gRm9yY2VkIHJlcGxhY2VtZW50IHByb3RvdHlwZSBhY2Nlc3NvcnMgbWV0aG9kc1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKSB8fCAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBLID0gTWF0aC5yYW5kb20oKTsgLy8gSW4gRkYgdGhyb3dzIG9ubHkgZGVmaW5lIG1ldGhvZHNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmLCBuby11c2VsZXNzLWNhbGxcblxuICBfX2RlZmluZVNldHRlcl9fLmNhbGwobnVsbCwgSywgZnVuY3Rpb24gKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH0pO1xuXG4gIGRlbGV0ZSByZXF1aXJlKCcuL19nbG9iYWwnKVtLXTtcbn0pOyIsInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5cbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuXG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xuXG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59OyIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xuXG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07IiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcblxudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59OyIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7IiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuXG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9XG5cbiAgcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59OyIsInZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcblxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xuXG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG5cbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTsgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuXG5cbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07IiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xuXG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59OyIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlOyIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG5cbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgZXhlYykge1xuICB2YXIgZm4gPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV07XG4gIHZhciBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgZm4oMSk7XG4gIH0pLCAnT2JqZWN0JywgZXhwKTtcbn07IiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcblxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG52YXIgaXNFbnVtID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmY7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlzRW50cmllcykge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoaXQpO1xuICAgIHZhciBrZXlzID0gZ2V0S2V5cyhPKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIga2V5O1xuXG4gICAgd2hpbGUgKGxlbmd0aCA+IGkpIHtcbiAgICAgIGtleSA9IGtleXNbaSsrXTtcblxuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBpc0VudW0uY2FsbChPLCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGlzRW50cmllcyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59OyIsIi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKTtcblxudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIFJlZmxlY3QgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3QgJiYgUmVmbGVjdC5vd25LZXlzIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnT1BOLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHJldHVybiBnZXRTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0U3ltYm9scyhpdCkpIDoga2V5cztcbn07IiwidmFyICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucGFyc2VGbG9hdDtcblxudmFyICR0cmltID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltO1xuXG5tb2R1bGUuZXhwb3J0cyA9IDEgLyAkcGFyc2VGbG9hdChyZXF1aXJlKCcuL19zdHJpbmctd3MnKSArICctMCcpICE9PSAtSW5maW5pdHkgPyBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cikge1xuICB2YXIgc3RyaW5nID0gJHRyaW0oU3RyaW5nKHN0ciksIDMpO1xuICB2YXIgcmVzdWx0ID0gJHBhcnNlRmxvYXQoc3RyaW5nKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gMCAmJiBzdHJpbmcuY2hhckF0KDApID09ICctJyA/IC0wIDogcmVzdWx0O1xufSA6ICRwYXJzZUZsb2F0OyIsInZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wYXJzZUludDtcblxudmFyICR0cmltID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltO1xuXG52YXIgd3MgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKTtcblxudmFyIGhleCA9IC9eWy0rXT8wW3hYXS87XG5tb2R1bGUuZXhwb3J0cyA9ICRwYXJzZUludCh3cyArICcwOCcpICE9PSA4IHx8ICRwYXJzZUludCh3cyArICcweDE2JykgIT09IDIyID8gZnVuY3Rpb24gcGFyc2VJbnQoc3RyLCByYWRpeCkge1xuICB2YXIgc3RyaW5nID0gJHRyaW0oU3RyaW5nKHN0ciksIDMpO1xuICByZXR1cm4gJHBhcnNlSW50KHN0cmluZywgcmFkaXggPj4+IDAgfHwgKGhleC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKSk7XG59IDogJHBhcnNlSW50OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4ge1xuICAgICAgZTogZmFsc2UsXG4gICAgICB2OiBleGVjKClcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGU6IHRydWUsXG4gICAgICB2OiBlXG4gICAgfTtcbiAgfVxufTsiLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdChDKTtcbiAgaWYgKGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpIHJldHVybiB4O1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpO1xuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gIHJlc29sdmUoeCk7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59OyIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBzYWZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07IiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcblxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuXG52YXIgU1JDID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpO1xuXG52YXIgJHRvU3RyaW5nID0gcmVxdWlyZSgnLi9fZnVuY3Rpb24tdG8tc3RyaW5nJyk7XG5cbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyIFRQTCA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuICR0b1N0cmluZy5jYWxsKGl0KTtcbn07XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbCwgc2FmZSkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYgKE9ba2V5XSA9PT0gdmFsKSByZXR1cm47XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcblxuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKCFzYWZlKSB7XG4gICAgZGVsZXRlIE9ba2V5XTtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfSBlbHNlIGlmIChPW2tleV0pIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH0gLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG5cbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcblxudmFyIGJ1aWx0aW5FeGVjID0gUmVnRXhwLnByb3RvdHlwZS5leGVjOyAvLyBgUmVnRXhwRXhlY2AgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHBleGVjXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFIsIFMpIHtcbiAgdmFyIGV4ZWMgPSBSLmV4ZWM7XG5cbiAgaWYgKHR5cGVvZiBleGVjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlc3VsdCA9IGV4ZWMuY2FsbChSLCBTKTtcblxuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVnRXhwIGV4ZWMgbWV0aG9kIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGFuIE9iamVjdCBvciBudWxsJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChjbGFzc29mKFIpICE9PSAnUmVnRXhwJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZ0V4cCNleGVjIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgcmVjZWl2ZXInKTtcbiAgfVxuXG4gIHJldHVybiBidWlsdGluRXhlYy5jYWxsKFIsIFMpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciByZWdleHBGbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG5cbnZhciBuYXRpdmVFeGVjID0gUmVnRXhwLnByb3RvdHlwZS5leGVjOyAvLyBUaGlzIGFsd2F5cyByZWZlcnMgdG8gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgYmVjYXVzZSB0aGVcbi8vIFN0cmluZyNyZXBsYWNlIHBvbHlmaWxsIHVzZXMgLi9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljLmpzLFxuLy8gd2hpY2ggbG9hZHMgdGhpcyBmaWxlIGJlZm9yZSBwYXRjaGluZyB0aGUgbWV0aG9kLlxuXG52YXIgbmF0aXZlUmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcbnZhciBwYXRjaGVkRXhlYyA9IG5hdGl2ZUV4ZWM7XG52YXIgTEFTVF9JTkRFWCA9ICdsYXN0SW5kZXgnO1xuXG52YXIgVVBEQVRFU19MQVNUX0lOREVYX1dST05HID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmUxID0gL2EvLFxuICAgICAgcmUyID0gL2IqL2c7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTEsICdhJyk7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTIsICdhJyk7XG4gIHJldHVybiByZTFbTEFTVF9JTkRFWF0gIT09IDAgfHwgcmUyW0xBU1RfSU5ERVhdICE9PSAwO1xufSgpOyAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cCwgY29waWVkIGZyb20gZXM1LXNoaW0ncyBTdHJpbmcjc3BsaXQgcGF0Y2guXG5cblxudmFyIE5QQ0dfSU5DTFVERUQgPSAvKCk/Py8uZXhlYygnJylbMV0gIT09IHVuZGVmaW5lZDtcbnZhciBQQVRDSCA9IFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyB8fCBOUENHX0lOQ0xVREVEO1xuXG5pZiAoUEFUQ0gpIHtcbiAgcGF0Y2hlZEV4ZWMgPSBmdW5jdGlvbiBleGVjKHN0cikge1xuICAgIHZhciByZSA9IHRoaXM7XG4gICAgdmFyIGxhc3RJbmRleCwgcmVDb3B5LCBtYXRjaCwgaTtcblxuICAgIGlmIChOUENHX0lOQ0xVREVEKSB7XG4gICAgICByZUNvcHkgPSBuZXcgUmVnRXhwKCdeJyArIHJlLnNvdXJjZSArICckKD8hXFxcXHMpJywgcmVnZXhwRmxhZ3MuY2FsbChyZSkpO1xuICAgIH1cblxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcpIGxhc3RJbmRleCA9IHJlW0xBU1RfSU5ERVhdO1xuICAgIG1hdGNoID0gbmF0aXZlRXhlYy5jYWxsKHJlLCBzdHIpO1xuXG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyAmJiBtYXRjaCkge1xuICAgICAgcmVbTEFTVF9JTkRFWF0gPSByZS5nbG9iYWwgPyBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCA6IGxhc3RJbmRleDtcbiAgICB9XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCAmJiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICBuYXRpdmVSZXBsYWNlLmNhbGwobWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaGVkRXhlYzsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyZWdFeHAsIHJlcGxhY2UpIHtcbiAgdmFyIHJlcGxhY2VyID0gcmVwbGFjZSA9PT0gT2JqZWN0KHJlcGxhY2UpID8gZnVuY3Rpb24gKHBhcnQpIHtcbiAgICByZXR1cm4gcmVwbGFjZVtwYXJ0XTtcbiAgfSA6IHJlcGxhY2U7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gU3RyaW5nKGl0KS5yZXBsYWNlKHJlZ0V4cCwgcmVwbGFjZXIpO1xuICB9O1xufTsiLCIvLyA3LjIuOSBTYW1lVmFsdWUoeCwgeSlcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcbn07IiwiJ3VzZSBzdHJpY3QnOyAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vXG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcblxudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTExFQ1RJT04pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsIENPTExFQ1RJT04sIHtcbiAgICBmcm9tOiBmdW5jdGlvbiBmcm9tKHNvdXJjZVxuICAgIC8qICwgbWFwRm4sIHRoaXNBcmcgKi9cbiAgICApIHtcbiAgICAgIHZhciBtYXBGbiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBtYXBwaW5nLCBBLCBuLCBjYjtcbiAgICAgIGFGdW5jdGlvbih0aGlzKTtcbiAgICAgIG1hcHBpbmcgPSBtYXBGbiAhPT0gdW5kZWZpbmVkO1xuICAgICAgaWYgKG1hcHBpbmcpIGFGdW5jdGlvbihtYXBGbik7XG4gICAgICBpZiAoc291cmNlID09IHVuZGVmaW5lZCkgcmV0dXJuIG5ldyB0aGlzKCk7XG4gICAgICBBID0gW107XG5cbiAgICAgIGlmIChtYXBwaW5nKSB7XG4gICAgICAgIG4gPSAwO1xuICAgICAgICBjYiA9IGN0eChtYXBGbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICAgICAgZm9yT2Yoc291cmNlLCBmYWxzZSwgZnVuY3Rpb24gKG5leHRJdGVtKSB7XG4gICAgICAgICAgQS5wdXNoKGNiKG5leHRJdGVtLCBuKyspKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPZihzb3VyY2UsIGZhbHNlLCBBLnB1c2gsIEEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IHRoaXMoQSk7XG4gICAgfVxuICB9KTtcbn07IiwiJ3VzZSBzdHJpY3QnOyAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vXG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTExFQ1RJT04pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsIENPTExFQ1RJT04sIHtcbiAgICBvZjogZnVuY3Rpb24gb2YoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBBID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkgQVtsZW5ndGhdID0gYXJndW1lbnRzW2xlbmd0aF07XG5cbiAgICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgICB9XG4gIH0pO1xufTsiLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIGNoZWNrID0gZnVuY3Rpb24gKE8sIHByb3RvKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBpZiAoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCkgdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgZnVuY3Rpb24gKHRlc3QsIGJ1Z2d5LCBzZXQpIHtcbiAgICB0cnkge1xuICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGJ1Z2d5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztlbHNlIHNldChPLCBwcm90byk7XG4gICAgICByZXR1cm4gTztcbiAgICB9O1xuICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xuXG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgQyA9IGdsb2JhbFtLRVldO1xuICBpZiAoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSkgZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbn07IiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5cbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcblxudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdGFnXG4gIH0pO1xufTsiLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcblxudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07IiwidmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246IGNvcmUudmVyc2lvbixcbiAgbW9kZTogcmVxdWlyZSgnLi9fbGlicmFyeScpID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTsiLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIEQpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtZXRob2QsIGFyZykge1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGxcbiAgICBhcmcgPyBtZXRob2QuY2FsbChudWxsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvKiBlbXB0eSAqL1xuICAgIH0sIDEpIDogbWV0aG9kLmNhbGwobnVsbCk7XG4gIH0pO1xufTsiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xuXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTsgLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmYgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGEgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59OyIsIi8vIGhlbHBlciBmb3IgU3RyaW5nI3tzdGFydHNXaXRoLCBlbmRzV2l0aCwgaW5jbHVkZXN9XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcblxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHNlYXJjaFN0cmluZywgTkFNRSkge1xuICBpZiAoaXNSZWdFeHAoc2VhcmNoU3RyaW5nKSkgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmcjJyArIE5BTUUgKyBcIiBkb2Vzbid0IGFjY2VwdCByZWdleCFcIik7XG4gIHJldHVybiBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG59OyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG52YXIgcXVvdCA9IC9cIi9nOyAvLyBCLjIuMy4yLjEgQ3JlYXRlSFRNTChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSlcblxudmFyIGNyZWF0ZUhUTUwgPSBmdW5jdGlvbiAoc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgdmFyIFMgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKTtcbiAgdmFyIHAxID0gJzwnICsgdGFnO1xuICBpZiAoYXR0cmlidXRlICE9PSAnJykgcDEgKz0gJyAnICsgYXR0cmlidXRlICsgJz1cIicgKyBTdHJpbmcodmFsdWUpLnJlcGxhY2UocXVvdCwgJyZxdW90OycpICsgJ1wiJztcbiAgcmV0dXJuIHAxICsgJz4nICsgUyArICc8LycgKyB0YWcgKyAnPic7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCBleGVjKSB7XG4gIHZhciBPID0ge307XG4gIE9bTkFNRV0gPSBleGVjKGNyZWF0ZUhUTUwpO1xuICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGVzdCA9ICcnW05BTUVdKCdcIicpO1xuICAgIHJldHVybiB0ZXN0ICE9PSB0ZXN0LnRvTG93ZXJDYXNlKCkgfHwgdGVzdC5zcGxpdCgnXCInKS5sZW5ndGggPiAzO1xuICB9KSwgJ1N0cmluZycsIE8pO1xufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbnZhciByZXBlYXQgPSByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jyk7XG5cbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBtYXhMZW5ndGgsIGZpbGxTdHJpbmcsIGxlZnQpIHtcbiAgdmFyIFMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gIHZhciBzdHJpbmdMZW5ndGggPSBTLmxlbmd0aDtcbiAgdmFyIGZpbGxTdHIgPSBmaWxsU3RyaW5nID09PSB1bmRlZmluZWQgPyAnICcgOiBTdHJpbmcoZmlsbFN0cmluZyk7XG4gIHZhciBpbnRNYXhMZW5ndGggPSB0b0xlbmd0aChtYXhMZW5ndGgpO1xuICBpZiAoaW50TWF4TGVuZ3RoIDw9IHN0cmluZ0xlbmd0aCB8fCBmaWxsU3RyID09ICcnKSByZXR1cm4gUztcbiAgdmFyIGZpbGxMZW4gPSBpbnRNYXhMZW5ndGggLSBzdHJpbmdMZW5ndGg7XG4gIHZhciBzdHJpbmdGaWxsZXIgPSByZXBlYXQuY2FsbChmaWxsU3RyLCBNYXRoLmNlaWwoZmlsbExlbiAvIGZpbGxTdHIubGVuZ3RoKSk7XG4gIGlmIChzdHJpbmdGaWxsZXIubGVuZ3RoID4gZmlsbExlbikgc3RyaW5nRmlsbGVyID0gc3RyaW5nRmlsbGVyLnNsaWNlKDAsIGZpbGxMZW4pO1xuICByZXR1cm4gbGVmdCA/IHN0cmluZ0ZpbGxlciArIFMgOiBTICsgc3RyaW5nRmlsbGVyO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG5cbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGVhdChjb3VudCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGRlZmluZWQodGhpcykpO1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBuID0gdG9JbnRlZ2VyKGNvdW50KTtcbiAgaWYgKG4gPCAwIHx8IG4gPT0gSW5maW5pdHkpIHRocm93IFJhbmdlRXJyb3IoXCJDb3VudCBjYW4ndCBiZSBuZWdhdGl2ZVwiKTtcblxuICBmb3IgKDsgbiA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKSBpZiAobiAmIDEpIHJlcyArPSBzdHI7XG5cbiAgcmV0dXJuIHJlcztcbn07IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbnZhciBzcGFjZXMgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKTtcblxudmFyIHNwYWNlID0gJ1snICsgc3BhY2VzICsgJ10nO1xudmFyIG5vbiA9ICdcXHUyMDBiXFx1MDA4NSc7XG52YXIgbHRyaW0gPSBSZWdFeHAoJ14nICsgc3BhY2UgKyBzcGFjZSArICcqJyk7XG52YXIgcnRyaW0gPSBSZWdFeHAoc3BhY2UgKyBzcGFjZSArICcqJCcpO1xuXG52YXIgZXhwb3J0ZXIgPSBmdW5jdGlvbiAoS0VZLCBleGVjLCBBTElBUykge1xuICB2YXIgZXhwID0ge307XG4gIHZhciBGT1JDRSA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISFzcGFjZXNbS0VZXSgpIHx8IG5vbltLRVldKCkgIT0gbm9uO1xuICB9KTtcbiAgdmFyIGZuID0gZXhwW0tFWV0gPSBGT1JDRSA/IGV4ZWModHJpbSkgOiBzcGFjZXNbS0VZXTtcbiAgaWYgKEFMSUFTKSBleHBbQUxJQVNdID0gZm47XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0UsICdTdHJpbmcnLCBleHApO1xufTsgLy8gMSAtPiBTdHJpbmcjdHJpbUxlZnRcbi8vIDIgLT4gU3RyaW5nI3RyaW1SaWdodFxuLy8gMyAtPiBTdHJpbmcjdHJpbVxuXG5cbnZhciB0cmltID0gZXhwb3J0ZXIudHJpbSA9IGZ1bmN0aW9uIChzdHJpbmcsIFRZUEUpIHtcbiAgc3RyaW5nID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIGlmIChUWVBFICYgMSkgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobHRyaW0sICcnKTtcbiAgaWYgKFRZUEUgJiAyKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuICByZXR1cm4gc3RyaW5nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRlcjsiLCJtb2R1bGUuZXhwb3J0cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgKyAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7IiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xuXG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG5cbnZhciBodG1sID0gcmVxdWlyZSgnLi9faHRtbCcpO1xuXG52YXIgY2VsID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpO1xuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgc2V0VGFzayA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXJUYXNrID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsLkRpc3BhdGNoO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG5cbnZhciBydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZCA9ICt0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5cbiAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG5cbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07IC8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcblxuXG5pZiAoIXNldFRhc2sgfHwgIWNsZWFyVGFzaykge1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaSA9IDE7XG5cbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG5cbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcblxuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuXG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTsgLy8gTm9kZS5qcyAwLjgtXG5cblxuICBpZiAocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9OyAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcblxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3coY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9OyAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG5cbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpOyAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuXG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpOyAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07IC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG5cbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTsiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07IiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9pbmRleFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcbiAgdmFyIG51bWJlciA9IHRvSW50ZWdlcihpdCk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChudW1iZXIpO1xuICBpZiAobnVtYmVyICE9PSBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIGxlbmd0aCEnKTtcbiAgcmV0dXJuIGxlbmd0aDtcbn07IiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTsiLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xuXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG5cbnZhciBtaW4gPSBNYXRoLm1pbjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07IiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpOyAvLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSkge1xuICB2YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcblxuICB2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbiAgdmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxuICB2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4gIHZhciAkdHlwZWQgPSByZXF1aXJlKCcuL190eXBlZCcpO1xuXG4gIHZhciAkYnVmZmVyID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJyk7XG5cbiAgdmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xuXG4gIHZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcblxuICB2YXIgcHJvcGVydHlEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuXG4gIHZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xuXG4gIHZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xuXG4gIHZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG5cbiAgdmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbiAgdmFyIHRvSW5kZXggPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xuXG4gIHZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xuXG4gIHZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4gIHZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcblxuICB2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcblxuICB2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxuICB2YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxuICB2YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG5cbiAgdmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcblxuICB2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbiAgdmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG5cbiAgdmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbiAgdmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xuXG4gIHZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcblxuICB2YXIgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJyk7XG5cbiAgdmFyIGNyZWF0ZUFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpO1xuXG4gIHZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbiAgdmFyIEFycmF5SXRlcmF0b3JzID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcblxuICB2YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5cbiAgdmFyICRpdGVyRGV0ZWN0ID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKTtcblxuICB2YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJyk7XG5cbiAgdmFyIGFycmF5RmlsbCA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKTtcblxuICB2YXIgYXJyYXlDb3B5V2l0aGluID0gcmVxdWlyZSgnLi9fYXJyYXktY29weS13aXRoaW4nKTtcblxuICB2YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbiAgdmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcblxuICB2YXIgZFAgPSAkRFAuZjtcbiAgdmFyIGdPUEQgPSAkR09QRC5mO1xuICB2YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xuICB2YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbiAgdmFyIFVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheTtcbiAgdmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG4gIHZhciBTSEFSRURfQlVGRkVSID0gJ1NoYXJlZCcgKyBBUlJBWV9CVUZGRVI7XG4gIHZhciBCWVRFU19QRVJfRUxFTUVOVCA9ICdCWVRFU19QRVJfRUxFTUVOVCc7XG4gIHZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheVtQUk9UT1RZUEVdO1xuICB2YXIgJEFycmF5QnVmZmVyID0gJGJ1ZmZlci5BcnJheUJ1ZmZlcjtcbiAgdmFyICREYXRhVmlldyA9ICRidWZmZXIuRGF0YVZpZXc7XG4gIHZhciBhcnJheUZvckVhY2ggPSBjcmVhdGVBcnJheU1ldGhvZCgwKTtcbiAgdmFyIGFycmF5RmlsdGVyID0gY3JlYXRlQXJyYXlNZXRob2QoMik7XG4gIHZhciBhcnJheVNvbWUgPSBjcmVhdGVBcnJheU1ldGhvZCgzKTtcbiAgdmFyIGFycmF5RXZlcnkgPSBjcmVhdGVBcnJheU1ldGhvZCg0KTtcbiAgdmFyIGFycmF5RmluZCA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpO1xuICB2YXIgYXJyYXlGaW5kSW5kZXggPSBjcmVhdGVBcnJheU1ldGhvZCg2KTtcbiAgdmFyIGFycmF5SW5jbHVkZXMgPSBjcmVhdGVBcnJheUluY2x1ZGVzKHRydWUpO1xuICB2YXIgYXJyYXlJbmRleE9mID0gY3JlYXRlQXJyYXlJbmNsdWRlcyhmYWxzZSk7XG4gIHZhciBhcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JzLnZhbHVlcztcbiAgdmFyIGFycmF5S2V5cyA9IEFycmF5SXRlcmF0b3JzLmtleXM7XG4gIHZhciBhcnJheUVudHJpZXMgPSBBcnJheUl0ZXJhdG9ycy5lbnRyaWVzO1xuICB2YXIgYXJyYXlMYXN0SW5kZXhPZiA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2Y7XG4gIHZhciBhcnJheVJlZHVjZSA9IEFycmF5UHJvdG8ucmVkdWNlO1xuICB2YXIgYXJyYXlSZWR1Y2VSaWdodCA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHQ7XG4gIHZhciBhcnJheUpvaW4gPSBBcnJheVByb3RvLmpvaW47XG4gIHZhciBhcnJheVNvcnQgPSBBcnJheVByb3RvLnNvcnQ7XG4gIHZhciBhcnJheVNsaWNlID0gQXJyYXlQcm90by5zbGljZTtcbiAgdmFyIGFycmF5VG9TdHJpbmcgPSBBcnJheVByb3RvLnRvU3RyaW5nO1xuICB2YXIgYXJyYXlUb0xvY2FsZVN0cmluZyA9IEFycmF5UHJvdG8udG9Mb2NhbGVTdHJpbmc7XG4gIHZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbiAgdmFyIFRBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbiAgdmFyIFRZUEVEX0NPTlNUUlVDVE9SID0gdWlkKCd0eXBlZF9jb25zdHJ1Y3RvcicpO1xuICB2YXIgREVGX0NPTlNUUlVDVE9SID0gdWlkKCdkZWZfY29uc3RydWN0b3InKTtcbiAgdmFyIEFMTF9DT05TVFJVQ1RPUlMgPSAkdHlwZWQuQ09OU1RSO1xuICB2YXIgVFlQRURfQVJSQVkgPSAkdHlwZWQuVFlQRUQ7XG4gIHZhciBWSUVXID0gJHR5cGVkLlZJRVc7XG4gIHZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoISc7XG4gIHZhciAkbWFwID0gY3JlYXRlQXJyYXlNZXRob2QoMSwgZnVuY3Rpb24gKE8sIGxlbmd0aCkge1xuICAgIHJldHVybiBhbGxvY2F0ZShzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGVuZ3RoKTtcbiAgfSk7XG4gIHZhciBMSVRUTEVfRU5ESUFOID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVWludDE2QXJyYXkoWzFdKS5idWZmZXIpWzBdID09PSAxO1xuICB9KTtcbiAgdmFyIEZPUkNFRF9TRVQgPSAhIVVpbnQ4QXJyYXkgJiYgISFVaW50OEFycmF5W1BST1RPVFlQRV0uc2V0ICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgVWludDhBcnJheSgxKS5zZXQoe30pO1xuICB9KTtcblxuICB2YXIgdG9PZmZzZXQgPSBmdW5jdGlvbiAoaXQsIEJZVEVTKSB7XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihpdCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIGlmIChpc09iamVjdChpdCkgJiYgVFlQRURfQVJSQVkgaW4gaXQpIHJldHVybiBpdDtcbiAgICB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIHR5cGVkIGFycmF5IScpO1xuICB9O1xuXG4gIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIChDLCBsZW5ndGgpIHtcbiAgICBpZiAoIShpc09iamVjdChDKSAmJiBUWVBFRF9DT05TVFJVQ1RPUiBpbiBDKSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJdCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciEnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEMobGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgc3BlY2llc0Zyb21MaXN0ID0gZnVuY3Rpb24gKE8sIGxpc3QpIHtcbiAgICByZXR1cm4gZnJvbUxpc3Qoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxpc3QpO1xuICB9O1xuXG4gIHZhciBmcm9tTGlzdCA9IGZ1bmN0aW9uIChDLCBsaXN0KSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IGFsbG9jYXRlKEMsIGxlbmd0aCk7XG5cbiAgICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24gKGl0LCBrZXksIGludGVybmFsKSB7XG4gICAgZFAoaXQsIGtleSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kW2ludGVybmFsXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgJGZyb20gPSBmdW5jdGlvbiBmcm9tKHNvdXJjZVxuICAvKiAsIG1hcGZuLCB0aGlzQXJnICovXG4gICkge1xuICAgIHZhciBPID0gdG9PYmplY3Qoc291cmNlKTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIG1hcGZuID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGksIGxlbmd0aCwgdmFsdWVzLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuXG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIWlzQXJyYXlJdGVyKGl0ZXJGbikpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgdmFsdWVzID0gW10sIGkgPSAwOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGkrKykge1xuICAgICAgICB2YWx1ZXMucHVzaChzdGVwLnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgTyA9IHZhbHVlcztcbiAgICB9XG5cbiAgICBpZiAobWFwcGluZyAmJiBhTGVuID4gMikgbWFwZm4gPSBjdHgobWFwZm4sIGFyZ3VtZW50c1syXSwgMik7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCksIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7IGxlbmd0aCA+IGk7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gbWFwcGluZyA/IG1hcGZuKE9baV0sIGkpIDogT1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciAkb2YgPSBmdW5jdGlvbiBvZigpXG4gIC8qIC4uLml0ZW1zICovXG4gIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpO1xuXG4gICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTsgLy8gaU9TIFNhZmFyaSA2LnggZmFpbHMgaGVyZVxuXG5cbiAgdmFyIFRPX0xPQ0FMRV9CVUcgPSAhIVVpbnQ4QXJyYXkgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIGFycmF5VG9Mb2NhbGVTdHJpbmcuY2FsbChuZXcgVWludDhBcnJheSgxKSk7XG4gIH0pO1xuXG4gIHZhciAkdG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpIHtcbiAgICByZXR1cm4gYXJyYXlUb0xvY2FsZVN0cmluZy5hcHBseShUT19MT0NBTEVfQlVHID8gYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpKSA6IHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBwcm90byA9IHtcbiAgICBjb3B5V2l0aGluOiBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnRcbiAgICAvKiAsIGVuZCAqL1xuICAgICkge1xuICAgICAgcmV0dXJuIGFycmF5Q29weVdpdGhpbi5jYWxsKHZhbGlkYXRlKHRoaXMpLCB0YXJnZXQsIHN0YXJ0LCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmblxuICAgIC8qICwgdGhpc0FyZyAqL1xuICAgICkge1xuICAgICAgcmV0dXJuIGFycmF5RXZlcnkodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbGw6IGZ1bmN0aW9uIGZpbGwodmFsdWVcbiAgICAvKiAsIHN0YXJ0LCBlbmQgKi9cbiAgICApIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUZpbGwuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuXG4gICAgLyogLCB0aGlzQXJnICovXG4gICAgKSB7XG4gICAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5RmlsdGVyKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpO1xuICAgIH0sXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChwcmVkaWNhdGVcbiAgICAvKiAsIHRoaXNBcmcgKi9cbiAgICApIHtcbiAgICAgIHJldHVybiBhcnJheUZpbmQodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlXG4gICAgLyogLCB0aGlzQXJnICovXG4gICAgKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kSW5kZXgodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuXG4gICAgLyogLCB0aGlzQXJnICovXG4gICAgKSB7XG4gICAgICBhcnJheUZvckVhY2godmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudFxuICAgIC8qICwgZnJvbUluZGV4ICovXG4gICAgKSB7XG4gICAgICByZXR1cm4gYXJyYXlJbmRleE9mKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoRWxlbWVudFxuICAgIC8qICwgZnJvbUluZGV4ICovXG4gICAgKSB7XG4gICAgICByZXR1cm4gYXJyYXlJbmNsdWRlcyh2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUpvaW4uYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudFxuICAgIC8qICwgZnJvbUluZGV4ICovXG4gICAgKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlMYXN0SW5kZXhPZi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gbWFwKG1hcGZuXG4gICAgLyogLCB0aGlzQXJnICovXG4gICAgKSB7XG4gICAgICByZXR1cm4gJG1hcCh2YWxpZGF0ZSh0aGlzKSwgbWFwZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm5cbiAgICAvKiAsIGluaXRpYWxWYWx1ZSAqL1xuICAgICkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm5cbiAgICAvKiAsIGluaXRpYWxWYWx1ZSAqL1xuICAgICkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlUmlnaHQuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGxlbmd0aCA9IHZhbGlkYXRlKHRoYXQpLmxlbmd0aDtcbiAgICAgIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKGxlbmd0aCAvIDIpO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbWlkZGxlKSB7XG4gICAgICAgIHZhbHVlID0gdGhhdFtpbmRleF07XG4gICAgICAgIHRoYXRbaW5kZXgrK10gPSB0aGF0Wy0tbGVuZ3RoXTtcbiAgICAgICAgdGhhdFtsZW5ndGhdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGF0O1xuICAgIH0sXG4gICAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuXG4gICAgLyogLCB0aGlzQXJnICovXG4gICAgKSB7XG4gICAgICByZXR1cm4gYXJyYXlTb21lKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgICAgcmV0dXJuIGFycmF5U29ydC5jYWxsKHZhbGlkYXRlKHRoaXMpLCBjb21wYXJlZm4pO1xuICAgIH0sXG4gICAgc3ViYXJyYXk6IGZ1bmN0aW9uIHN1YmFycmF5KGJlZ2luLCBlbmQpIHtcbiAgICAgIHZhciBPID0gdmFsaWRhdGUodGhpcyk7XG4gICAgICB2YXIgbGVuZ3RoID0gTy5sZW5ndGg7XG4gICAgICB2YXIgJGJlZ2luID0gdG9BYnNvbHV0ZUluZGV4KGJlZ2luLCBsZW5ndGgpO1xuICAgICAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSkpKE8uYnVmZmVyLCBPLmJ5dGVPZmZzZXQgKyAkYmVnaW4gKiBPLkJZVEVTX1BFUl9FTEVNRU5ULCB0b0xlbmd0aCgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW5ndGgpKSAtICRiZWdpbikpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgJHNsaWNlID0gZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpLCBzdGFydCwgZW5kKSk7XG4gIH07XG5cbiAgdmFyICRzZXQgPSBmdW5jdGlvbiBzZXQoYXJyYXlMaWtlXG4gIC8qICwgb2Zmc2V0ICovXG4gICkge1xuICAgIHZhbGlkYXRlKHRoaXMpO1xuICAgIHZhciBvZmZzZXQgPSB0b09mZnNldChhcmd1bWVudHNbMV0sIDEpO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICB2YXIgc3JjID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgoc3JjLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBpZiAobGVuICsgb2Zmc2V0ID4gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBsZW4pIHRoaXNbb2Zmc2V0ICsgaW5kZXhdID0gc3JjW2luZGV4KytdO1xuICB9O1xuXG4gIHZhciAkaXRlcmF0b3JzID0ge1xuICAgIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlFbnRyaWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAga2V5czogZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgIHJldHVybiBhcnJheUtleXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiBhcnJheVZhbHVlcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzVEFJbmRleCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHJldHVybiBpc09iamVjdCh0YXJnZXQpICYmIHRhcmdldFtUWVBFRF9BUlJBWV0gJiYgdHlwZW9mIGtleSAhPSAnc3ltYm9sJyAmJiBrZXkgaW4gdGFyZ2V0ICYmIFN0cmluZygra2V5KSA9PSBTdHJpbmcoa2V5KTtcbiAgfTtcblxuICB2YXIgJGdldERlc2MgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSkgPyBwcm9wZXJ0eURlc2MoMiwgdGFyZ2V0W2tleV0pIDogZ09QRCh0YXJnZXQsIGtleSk7XG4gIH07XG5cbiAgdmFyICRzZXREZXNjID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICBpZiAoaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSkgJiYgaXNPYmplY3QoZGVzYykgJiYgaGFzKGRlc2MsICd2YWx1ZScpICYmICFoYXMoZGVzYywgJ2dldCcpICYmICFoYXMoZGVzYywgJ3NldCcpIC8vIFRPRE86IGFkZCB2YWxpZGF0aW9uIGRlc2NyaXB0b3Igdy9vIGNhbGxpbmcgYWNjZXNzb3JzXG4gICAgJiYgIWRlc2MuY29uZmlndXJhYmxlICYmICghaGFzKGRlc2MsICd3cml0YWJsZScpIHx8IGRlc2Mud3JpdGFibGUpICYmICghaGFzKGRlc2MsICdlbnVtZXJhYmxlJykgfHwgZGVzYy5lbnVtZXJhYmxlKSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBkZXNjLnZhbHVlO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gZFAodGFyZ2V0LCBrZXksIGRlc2MpO1xuICB9O1xuXG4gIGlmICghQUxMX0NPTlNUUlVDVE9SUykge1xuICAgICRHT1BELmYgPSAkZ2V0RGVzYztcbiAgICAkRFAuZiA9ICRzZXREZXNjO1xuICB9XG5cbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhQUxMX0NPTlNUUlVDVE9SUywgJ09iamVjdCcsIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXREZXNjLFxuICAgIGRlZmluZVByb3BlcnR5OiAkc2V0RGVzY1xuICB9KTtcblxuICBpZiAoZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIGFycmF5VG9TdHJpbmcuY2FsbCh7fSk7XG4gIH0pKSB7XG4gICAgYXJyYXlUb1N0cmluZyA9IGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0aGlzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyICRUeXBlZEFycmF5UHJvdG90eXBlJCA9IHJlZGVmaW5lQWxsKHt9LCBwcm90byk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJGl0ZXJhdG9ycyk7XG4gIGhpZGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBJVEVSQVRPUiwgJGl0ZXJhdG9ycy52YWx1ZXMpO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIHtcbiAgICBzbGljZTogJHNsaWNlLFxuICAgIHNldDogJHNldCxcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgICAgLyogbm9vcCAqL1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGFycmF5VG9TdHJpbmcsXG4gICAgdG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZ1xuICB9KTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J1ZmZlcicsICdiJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlT2Zmc2V0JywgJ28nKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVMZW5ndGgnLCAnbCcpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnbGVuZ3RoJywgJ2UnKTtcbiAgZFAoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCBUQUcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzW1RZUEVEX0FSUkFZXTtcbiAgICB9XG4gIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIEJZVEVTLCB3cmFwcGVyLCBDTEFNUEVEKSB7XG4gICAgQ0xBTVBFRCA9ICEhQ0xBTVBFRDtcbiAgICB2YXIgTkFNRSA9IEtFWSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5JztcbiAgICB2YXIgR0VUVEVSID0gJ2dldCcgKyBLRVk7XG4gICAgdmFyIFNFVFRFUiA9ICdzZXQnICsgS0VZO1xuICAgIHZhciBUeXBlZEFycmF5ID0gZ2xvYmFsW05BTUVdO1xuICAgIHZhciBCYXNlID0gVHlwZWRBcnJheSB8fCB7fTtcbiAgICB2YXIgVEFDID0gVHlwZWRBcnJheSAmJiBnZXRQcm90b3R5cGVPZihUeXBlZEFycmF5KTtcbiAgICB2YXIgRk9SQ0VEID0gIVR5cGVkQXJyYXkgfHwgISR0eXBlZC5BQlY7XG4gICAgdmFyIE8gPSB7fTtcbiAgICB2YXIgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkgJiYgVHlwZWRBcnJheVtQUk9UT1RZUEVdO1xuXG4gICAgdmFyIGdldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgcmV0dXJuIGRhdGEudltHRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIExJVFRMRV9FTkRJQU4pO1xuICAgIH07XG5cbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgaWYgKENMQU1QRUQpIHZhbHVlID0gKHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSkpIDwgMCA/IDAgOiB2YWx1ZSA+IDB4ZmYgPyAweGZmIDogdmFsdWUgJiAweGZmO1xuICAgICAgZGF0YS52W1NFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgdmFsdWUsIExJVFRMRV9FTkRJQU4pO1xuICAgIH07XG5cbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgZFAodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldHRlcih0aGlzLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKEZPUkNFRCkge1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FLCAnX2QnKTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBidWZmZXIsIGJ5dGVMZW5ndGgsIGxlbmd0aCwga2xhc3M7XG5cbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgICAgIGxlbmd0aCA9IHRvSW5kZXgoZGF0YSk7XG4gICAgICAgICAgYnl0ZUxlbmd0aCA9IGxlbmd0aCAqIEJZVEVTO1xuICAgICAgICAgIGJ1ZmZlciA9IG5ldyAkQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mICRBcnJheUJ1ZmZlciB8fCAoa2xhc3MgPSBjbGFzc29mKGRhdGEpKSA9PSBBUlJBWV9CVUZGRVIgfHwga2xhc3MgPT0gU0hBUkVEX0JVRkZFUikge1xuICAgICAgICAgIGJ1ZmZlciA9IGRhdGE7XG4gICAgICAgICAgb2Zmc2V0ID0gdG9PZmZzZXQoJG9mZnNldCwgQllURVMpO1xuICAgICAgICAgIHZhciAkbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKCRsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCRsZW4gJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCA8IDApIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IHRvTGVuZ3RoKCRsZW5ndGgpICogQllURVM7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCArIG9mZnNldCA+ICRsZW4pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZW5ndGggPSBieXRlTGVuZ3RoIC8gQllURVM7XG4gICAgICAgIH0gZWxzZSBpZiAoVFlQRURfQVJSQVkgaW4gZGF0YSkge1xuICAgICAgICAgIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhpZGUodGhhdCwgJ19kJywge1xuICAgICAgICAgIGI6IGJ1ZmZlcixcbiAgICAgICAgICBvOiBvZmZzZXQsXG4gICAgICAgICAgbDogYnl0ZUxlbmd0aCxcbiAgICAgICAgICBlOiBsZW5ndGgsXG4gICAgICAgICAgdjogbmV3ICREYXRhVmlldyhidWZmZXIpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkgYWRkRWxlbWVudCh0aGF0LCBpbmRleCsrKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IGNyZWF0ZSgkVHlwZWRBcnJheVByb3RvdHlwZSQpO1xuICAgICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBUeXBlZEFycmF5KTtcbiAgICB9IGVsc2UgaWYgKCFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBUeXBlZEFycmF5KDEpO1xuICAgIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgtMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSkgfHwgISRpdGVyRGV0ZWN0KGZ1bmN0aW9uIChpdGVyKSB7XG4gICAgICBuZXcgVHlwZWRBcnJheSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuXG4gICAgICBuZXcgVHlwZWRBcnJheShudWxsKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcblxuICAgICAgbmV3IFR5cGVkQXJyYXkoMS41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcblxuICAgICAgbmV3IFR5cGVkQXJyYXkoaXRlcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSwgdHJ1ZSkpIHtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSk7XG4gICAgICAgIHZhciBrbGFzczsgLy8gYHdzYCBtb2R1bGUgYnVnLCB0ZW1wb3JhcmlseSByZW1vdmUgdmFsaWRhdGlvbiBsZW5ndGggZm9yIFVpbnQ4QXJyYXlcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvcHVsbC82NDVcblxuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSByZXR1cm4gbmV3IEJhc2UodG9JbmRleChkYXRhKSk7XG5cbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpIHtcbiAgICAgICAgICByZXR1cm4gJGxlbmd0aCAhPT0gdW5kZWZpbmVkID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpLCAkbGVuZ3RoKSA6ICRvZmZzZXQgIT09IHVuZGVmaW5lZCA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSkgOiBuZXcgQmFzZShkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChUWVBFRF9BUlJBWSBpbiBkYXRhKSByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBhcnJheUZvckVhY2goVEFDICE9PSBGdW5jdGlvbi5wcm90b3R5cGUgPyBnT1BOKEJhc2UpLmNvbmNhdChnT1BOKFRBQykpIDogZ09QTihCYXNlKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gVHlwZWRBcnJheSkpIGhpZGUoVHlwZWRBcnJheSwga2V5LCBCYXNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBUeXBlZEFycmF5UHJvdG90eXBlO1xuICAgICAgaWYgKCFMSUJSQVJZKSBUeXBlZEFycmF5UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHlwZWRBcnJheTtcbiAgICB9XG5cbiAgICB2YXIgJG5hdGl2ZUl0ZXJhdG9yID0gVHlwZWRBcnJheVByb3RvdHlwZVtJVEVSQVRPUl07XG4gICAgdmFyIENPUlJFQ1RfSVRFUl9OQU1FID0gISEkbmF0aXZlSXRlcmF0b3IgJiYgKCRuYXRpdmVJdGVyYXRvci5uYW1lID09ICd2YWx1ZXMnIHx8ICRuYXRpdmVJdGVyYXRvci5uYW1lID09IHVuZGVmaW5lZCk7XG4gICAgdmFyICRpdGVyYXRvciA9ICRpdGVyYXRvcnMudmFsdWVzO1xuICAgIGhpZGUoVHlwZWRBcnJheSwgVFlQRURfQ09OU1RSVUNUT1IsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVFlQRURfQVJSQVksIE5BTUUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBERUZfQ09OU1RSVUNUT1IsIFR5cGVkQXJyYXkpO1xuXG4gICAgaWYgKENMQU1QRUQgPyBuZXcgVHlwZWRBcnJheSgxKVtUQUddICE9IE5BTUUgOiAhKFRBRyBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSkge1xuICAgICAgZFAoVHlwZWRBcnJheVByb3RvdHlwZSwgVEFHLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBOQU1FO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBPW05BTUVdID0gVHlwZWRBcnJheTtcbiAgICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChUeXBlZEFycmF5ICE9IEJhc2UpLCBPKTtcbiAgICAkZXhwb3J0KCRleHBvcnQuUywgTkFNRSwge1xuICAgICAgQllURVNfUEVSX0VMRU1FTlQ6IEJZVEVTXG4gICAgfSk7XG4gICAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBCYXNlLm9mLmNhbGwoVHlwZWRBcnJheSwgMSk7XG4gICAgfSksIE5BTUUsIHtcbiAgICAgIGZyb206ICRmcm9tLFxuICAgICAgb2Y6ICRvZlxuICAgIH0pO1xuICAgIGlmICghKEJZVEVTX1BFUl9FTEVNRU5UIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKSBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XG4gICAgJGV4cG9ydCgkZXhwb3J0LlAsIE5BTUUsIHByb3RvKTtcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0VEX1NFVCwgTkFNRSwge1xuICAgICAgc2V0OiAkc2V0XG4gICAgfSk7XG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhQ09SUkVDVF9JVEVSX05BTUUsIE5BTUUsICRpdGVyYXRvcnMpO1xuICAgIGlmICghTElCUkFSWSAmJiBUeXBlZEFycmF5UHJvdG90eXBlLnRvU3RyaW5nICE9IGFycmF5VG9TdHJpbmcpIFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgPSBhcnJheVRvU3RyaW5nO1xuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoMSkuc2xpY2UoKTtcbiAgICB9KSwgTkFNRSwge1xuICAgICAgc2xpY2U6ICRzbGljZVxuICAgIH0pO1xuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbMSwgMl0udG9Mb2NhbGVTdHJpbmcoKSAhPSBuZXcgVHlwZWRBcnJheShbMSwgMl0pLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcuY2FsbChbMSwgMl0pO1xuICAgIH0pKSwgTkFNRSwge1xuICAgICAgdG9Mb2NhbGVTdHJpbmc6ICR0b0xvY2FsZVN0cmluZ1xuICAgIH0pO1xuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IENPUlJFQ1RfSVRFUl9OQU1FID8gJG5hdGl2ZUl0ZXJhdG9yIDogJGl0ZXJhdG9yO1xuICAgIGlmICghTElCUkFSWSAmJiAhQ09SUkVDVF9JVEVSX05BTUUpIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgSVRFUkFUT1IsICRpdGVyYXRvcik7XG4gIH07XG59IGVsc2UgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIC8qIGVtcHR5ICovXG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xuXG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcblxudmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG5cbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xuXG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcblxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xuXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxudmFyIHRvSW5kZXggPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xuXG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcblxudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcblxudmFyIGFycmF5RmlsbCA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKTtcblxudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcblxudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG52YXIgREFUQV9WSUVXID0gJ0RhdGFWaWV3JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoISc7XG52YXIgV1JPTkdfSU5ERVggPSAnV3JvbmcgaW5kZXghJztcbnZhciAkQXJyYXlCdWZmZXIgPSBnbG9iYWxbQVJSQVlfQlVGRkVSXTtcbnZhciAkRGF0YVZpZXcgPSBnbG9iYWxbREFUQV9WSUVXXTtcbnZhciBNYXRoID0gZ2xvYmFsLk1hdGg7XG52YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93LXJlc3RyaWN0ZWQtbmFtZXNcblxudmFyIEluZmluaXR5ID0gZ2xvYmFsLkluZmluaXR5O1xudmFyIEJhc2VCdWZmZXIgPSAkQXJyYXlCdWZmZXI7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIExOMiA9IE1hdGguTE4yO1xudmFyIEJVRkZFUiA9ICdidWZmZXInO1xudmFyIEJZVEVfTEVOR1RIID0gJ2J5dGVMZW5ndGgnO1xudmFyIEJZVEVfT0ZGU0VUID0gJ2J5dGVPZmZzZXQnO1xudmFyICRCVUZGRVIgPSBERVNDUklQVE9SUyA/ICdfYicgOiBCVUZGRVI7XG52YXIgJExFTkdUSCA9IERFU0NSSVBUT1JTID8gJ19sJyA6IEJZVEVfTEVOR1RIO1xudmFyICRPRkZTRVQgPSBERVNDUklQVE9SUyA/ICdfbycgOiBCWVRFX09GRlNFVDsgLy8gSUVFRTc1NCBjb252ZXJzaW9ucyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2llZWU3NTRcblxuZnVuY3Rpb24gcGFja0lFRUU3NTQodmFsdWUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KG5CeXRlcyk7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSBtTGVuID09PSAyMyA/IHBvdygyLCAtMjQpIC0gcG93KDIsIC03NykgOiAwO1xuICB2YXIgaSA9IDA7XG4gIHZhciBzID0gdmFsdWUgPCAwIHx8IHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDAgPyAxIDogMDtcbiAgdmFyIGUsIG0sIGM7XG4gIHZhbHVlID0gYWJzKHZhbHVlKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuXG4gIGlmICh2YWx1ZSAhPSB2YWx1ZSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgbSA9IHZhbHVlICE9IHZhbHVlID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IGZsb29yKGxvZyh2YWx1ZSkgLyBMTjIpO1xuXG4gICAgaWYgKHZhbHVlICogKGMgPSBwb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBwb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIHBvdygyLCBlQmlhcyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW2krK10gPSBtICYgMjU1LCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcblxuICBlID0gZSA8PCBtTGVuIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW2krK10gPSBlICYgMjU1LCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbLS1pXSB8PSBzICogMTI4O1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiB1bnBhY2tJRUVFNzU0KGJ1ZmZlciwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgbkJpdHMgPSBlTGVuIC0gNztcbiAgdmFyIGkgPSBuQnl0ZXMgLSAxO1xuICB2YXIgcyA9IGJ1ZmZlcltpLS1dO1xuICB2YXIgZSA9IHMgJiAxMjc7XG4gIHZhciBtO1xuICBzID4+PSA3O1xuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gIGUgPj49IC1uQml0cztcbiAgbkJpdHMgKz0gbUxlbjtcblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogcyA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgcG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cblxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIHBvdygyLCBlIC0gbUxlbik7XG59XG5cbmZ1bmN0aW9uIHVucGFja0kzMihieXRlcykge1xuICByZXR1cm4gYnl0ZXNbM10gPDwgMjQgfCBieXRlc1syXSA8PCAxNiB8IGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbn1cblxuZnVuY3Rpb24gcGFja0k4KGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmXTtcbn1cblxuZnVuY3Rpb24gcGFja0kxNihpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmZdO1xufVxuXG5mdW5jdGlvbiBwYWNrSTMyKGl0KSB7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZiwgaXQgPj4gMTYgJiAweGZmLCBpdCA+PiAyNCAmIDB4ZmZdO1xufVxuXG5mdW5jdGlvbiBwYWNrRjY0KGl0KSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgNTIsIDgpO1xufVxuXG5mdW5jdGlvbiBwYWNrRjMyKGl0KSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgMjMsIDQpO1xufVxuXG5mdW5jdGlvbiBhZGRHZXR0ZXIoQywga2V5LCBpbnRlcm5hbCkge1xuICBkUChDW1BST1RPVFlQRV0sIGtleSwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXNbaW50ZXJuYWxdO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldCh2aWV3LCBieXRlcywgaW5kZXgsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleDtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChudW1JbmRleCk7XG4gIGlmIChpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2I7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXTtcbiAgdmFyIHBhY2sgPSBzdG9yZS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcyk7XG4gIHJldHVybiBpc0xpdHRsZUVuZGlhbiA/IHBhY2sgOiBwYWNrLnJldmVyc2UoKTtcbn1cblxuZnVuY3Rpb24gc2V0KHZpZXcsIGJ5dGVzLCBpbmRleCwgY29udmVyc2lvbiwgdmFsdWUsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleDtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChudW1JbmRleCk7XG4gIGlmIChpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2I7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXTtcbiAgdmFyIHBhY2sgPSBjb252ZXJzaW9uKCt2YWx1ZSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlczsgaSsrKSBzdG9yZVtzdGFydCArIGldID0gcGFja1tpc0xpdHRsZUVuZGlhbiA/IGkgOiBieXRlcyAtIGkgLSAxXTtcbn1cblxuaWYgKCEkdHlwZWQuQUJWKSB7XG4gICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuICAgIHZhciBieXRlTGVuZ3RoID0gdG9JbmRleChsZW5ndGgpO1xuICAgIHRoaXMuX2IgPSBhcnJheUZpbGwuY2FsbChuZXcgQXJyYXkoYnl0ZUxlbmd0aCksIDApO1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuICAgIGFuSW5zdGFuY2UoYnVmZmVyLCAkQXJyYXlCdWZmZXIsIERBVEFfVklFVyk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlclskTEVOR1RIXTtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGJ5dGVPZmZzZXQpO1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID09PSB1bmRlZmluZWQgPyBidWZmZXJMZW5ndGggLSBvZmZzZXQgOiB0b0xlbmd0aChieXRlTGVuZ3RoKTtcbiAgICBpZiAob2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHRoaXNbJEJVRkZFUl0gPSBidWZmZXI7XG4gICAgdGhpc1skT0ZGU0VUXSA9IG9mZnNldDtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICBpZiAoREVTQ1JJUFRPUlMpIHtcbiAgICBhZGRHZXR0ZXIoJEFycmF5QnVmZmVyLCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQlVGRkVSLCAnX2InKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9PRkZTRVQsICdfbycpO1xuICB9XG5cbiAgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBnZXRJbnQ4OiBmdW5jdGlvbiBnZXRJbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF0gPDwgMjQgPj4gMjQ7XG4gICAgfSxcbiAgICBnZXRVaW50ODogZnVuY3Rpb24gZ2V0VWludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcbiAgICB9LFxuICAgIGdldEludDE2OiBmdW5jdGlvbiBnZXRJbnQxNihieXRlT2Zmc2V0XG4gICAgLyogLCBsaXR0bGVFbmRpYW4gKi9cbiAgICApIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIChieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF0pIDw8IDE2ID4+IDE2O1xuICAgIH0sXG4gICAgZ2V0VWludDE2OiBmdW5jdGlvbiBnZXRVaW50MTYoYnl0ZU9mZnNldFxuICAgIC8qICwgbGl0dGxlRW5kaWFuICovXG4gICAgKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG4gICAgfSxcbiAgICBnZXRJbnQzMjogZnVuY3Rpb24gZ2V0SW50MzIoYnl0ZU9mZnNldFxuICAgIC8qICwgbGl0dGxlRW5kaWFuICovXG4gICAgKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKTtcbiAgICB9LFxuICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXRcbiAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICkge1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSkgPj4+IDA7XG4gICAgfSxcbiAgICBnZXRGbG9hdDMyOiBmdW5jdGlvbiBnZXRGbG9hdDMyKGJ5dGVPZmZzZXRcbiAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICkge1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDIzLCA0KTtcbiAgICB9LFxuICAgIGdldEZsb2F0NjQ6IGZ1bmN0aW9uIGdldEZsb2F0NjQoYnl0ZU9mZnNldFxuICAgIC8qICwgbGl0dGxlRW5kaWFuICovXG4gICAgKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgNTIsIDgpO1xuICAgIH0sXG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRJbnQxNjogZnVuY3Rpb24gc2V0SW50MTYoYnl0ZU9mZnNldCwgdmFsdWVcbiAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICkge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDE2OiBmdW5jdGlvbiBzZXRVaW50MTYoYnl0ZU9mZnNldCwgdmFsdWVcbiAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICkge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0SW50MzI6IGZ1bmN0aW9uIHNldEludDMyKGJ5dGVPZmZzZXQsIHZhbHVlXG4gICAgLyogLCBsaXR0bGVFbmRpYW4gKi9cbiAgICApIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQzMjogZnVuY3Rpb24gc2V0VWludDMyKGJ5dGVPZmZzZXQsIHZhbHVlXG4gICAgLyogLCBsaXR0bGVFbmRpYW4gKi9cbiAgICApIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0MzI6IGZ1bmN0aW9uIHNldEZsb2F0MzIoYnl0ZU9mZnNldCwgdmFsdWVcbiAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICkge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tGMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQ2NDogZnVuY3Rpb24gc2V0RmxvYXQ2NChieXRlT2Zmc2V0LCB2YWx1ZVxuICAgIC8qICwgbGl0dGxlRW5kaWFuICovXG4gICAgKSB7XG4gICAgICBzZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgcGFja0Y2NCwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIGlmICghZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICRBcnJheUJ1ZmZlcigxKTtcbiAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgJEFycmF5QnVmZmVyKC0xKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcblxuICAgIG5ldyAkQXJyYXlCdWZmZXIoMS41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcblxuICAgIG5ldyAkQXJyYXlCdWZmZXIoTmFOKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcblxuICAgIHJldHVybiAkQXJyYXlCdWZmZXIubmFtZSAhPSBBUlJBWV9CVUZGRVI7XG4gIH0pKSB7XG4gICAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgICBhbkluc3RhbmNlKHRoaXMsICRBcnJheUJ1ZmZlcik7XG4gICAgICByZXR1cm4gbmV3IEJhc2VCdWZmZXIodG9JbmRleChsZW5ndGgpKTtcbiAgICB9O1xuXG4gICAgdmFyIEFycmF5QnVmZmVyUHJvdG8gPSAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXSA9IEJhc2VCdWZmZXJbUFJPVE9UWVBFXTtcblxuICAgIGZvciAodmFyIGtleXMgPSBnT1BOKEJhc2VCdWZmZXIpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7KSB7XG4gICAgICBpZiAoISgoa2V5ID0ga2V5c1tqKytdKSBpbiAkQXJyYXlCdWZmZXIpKSBoaWRlKCRBcnJheUJ1ZmZlciwga2V5LCBCYXNlQnVmZmVyW2tleV0pO1xuICAgIH1cblxuICAgIGlmICghTElCUkFSWSkgQXJyYXlCdWZmZXJQcm90by5jb25zdHJ1Y3RvciA9ICRBcnJheUJ1ZmZlcjtcbiAgfSAvLyBpT1MgU2FmYXJpIDcueCBidWdcblxuXG4gIHZhciB2aWV3ID0gbmV3ICREYXRhVmlldyhuZXcgJEFycmF5QnVmZmVyKDIpKTtcbiAgdmFyICRzZXRJbnQ4ID0gJERhdGFWaWV3W1BST1RPVFlQRV0uc2V0SW50ODtcbiAgdmlldy5zZXRJbnQ4KDAsIDIxNDc0ODM2NDgpO1xuICB2aWV3LnNldEludDgoMSwgMjE0NzQ4MzY0OSk7XG4gIGlmICh2aWV3LmdldEludDgoMCkgfHwgIXZpZXcuZ2V0SW50OCgxKSkgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfVxuICB9LCB0cnVlKTtcbn1cblxuc2V0VG9TdHJpbmdUYWcoJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuc2V0VG9TdHJpbmdUYWcoJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuaGlkZSgkRGF0YVZpZXdbUFJPVE9UWVBFXSwgJHR5cGVkLlZJRVcsIHRydWUpO1xuZXhwb3J0c1tBUlJBWV9CVUZGRVJdID0gJEFycmF5QnVmZmVyO1xuZXhwb3J0c1tEQVRBX1ZJRVddID0gJERhdGFWaWV3OyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5cbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcblxudmFyIFRZUEVEID0gdWlkKCd0eXBlZF9hcnJheScpO1xudmFyIFZJRVcgPSB1aWQoJ3ZpZXcnKTtcbnZhciBBQlYgPSAhIShnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZ2xvYmFsLkRhdGFWaWV3KTtcbnZhciBDT05TVFIgPSBBQlY7XG52YXIgaSA9IDA7XG52YXIgbCA9IDk7XG52YXIgVHlwZWQ7XG52YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9ycyA9ICdJbnQ4QXJyYXksVWludDhBcnJheSxVaW50OENsYW1wZWRBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheScuc3BsaXQoJywnKTtcblxud2hpbGUgKGkgPCBsKSB7XG4gIGlmIChUeXBlZCA9IGdsb2JhbFtUeXBlZEFycmF5Q29uc3RydWN0b3JzW2krK11dKSB7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFRZUEVELCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gIH0gZWxzZSBDT05TVFIgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFCVjogQUJWLFxuICBDT05TVFI6IENPTlNUUixcbiAgVFlQRUQ6IFRZUEVELFxuICBWSUVXOiBWSUVXXG59OyIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07IiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgbmF2aWdhdG9yID0gZ2xvYmFsLm5hdmlnYXRvcjtcbm1vZHVsZS5leHBvcnRzID0gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUWVBFKSB7XG4gIGlmICghaXNPYmplY3QoaXQpIHx8IGl0Ll90ICE9PSBUWVBFKSB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkIScpO1xuICByZXR1cm4gaXQ7XG59OyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG5cbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xuXG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7XG4gICAgdmFsdWU6IHdrc0V4dC5mKG5hbWUpXG4gIH0pO1xufTsiLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTsiLCJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJyk7XG5cbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcblxudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcblxudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9IFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlOyIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xuXG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcblxudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdIHx8IGl0WydAQGl0ZXJhdG9yJ10gfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2JlbmphbWluZ3IvUmV4RXhwLmVzY2FwZVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRyZSA9IHJlcXVpcmUoJy4vX3JlcGxhY2VyJykoL1tcXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVnRXhwJywge1xuICBlc2NhcGU6IGZ1bmN0aW9uIGVzY2FwZShpdCkge1xuICAgIHJldHVybiAkcmUoaXQpO1xuICB9XG59KTsiLCIvLyAyMi4xLjMuMyBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0LCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGNvcHlXaXRoaW46IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJylcbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnY29weVdpdGhpbicpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRldmVyeSA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg0KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmV2ZXJ5LCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNSAvIDE1LjQuNC4xNiBBcnJheS5wcm90b3R5cGUuZXZlcnkoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm5cbiAgLyogLCB0aGlzQXJnICovXG4gICkge1xuICAgIHJldHVybiAkZXZlcnkodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7IiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBmaWxsOiByZXF1aXJlKCcuL19hcnJheS1maWxsJylcbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnZmlsbCcpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRmaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMik7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5maWx0ZXIsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy43IC8gMTUuNC40LjIwIEFycmF5LnByb3RvdHlwZS5maWx0ZXIoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmblxuICAvKiAsIHRoaXNBcmcgKi9cbiAgKSB7XG4gICAgcmV0dXJuICRmaWx0ZXIodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyAyMi4xLjMuOSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRmaW5kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDYpO1xuXG52YXIgS0VZID0gJ2ZpbmRJbmRleCc7XG52YXIgZm9yY2VkID0gdHJ1ZTsgLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcblxuaWYgKEtFWSBpbiBbXSkgQXJyYXkoMSlbS0VZXShmdW5jdGlvbiAoKSB7XG4gIGZvcmNlZCA9IGZhbHNlO1xufSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChjYWxsYmFja2ZuXG4gIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqL1xuICApIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTsiLCIndXNlIHN0cmljdCc7IC8vIDIyLjEuMy44IEFycmF5LnByb3RvdHlwZS5maW5kKHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRmaW5kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDUpO1xuXG52YXIgS0VZID0gJ2ZpbmQnO1xudmFyIGZvcmNlZCA9IHRydWU7IC8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5cbmlmIChLRVkgaW4gW10pIEFycmF5KDEpW0tFWV0oZnVuY3Rpb24gKCkge1xuICBmb3JjZWQgPSBmYWxzZTtcbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChjYWxsYmFja2ZuXG4gIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqL1xuICApIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkZm9yRWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKTtcblxudmFyIFNUUklDVCA9IHJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5mb3JFYWNoLCB0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhU1RSSUNULCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMCAvIDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm5cbiAgLyogLCB0aGlzQXJnICovXG4gICkge1xuICAgIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG5cbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikge1xuICBBcnJheS5mcm9tKGl0ZXIpO1xufSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbShhcnJheUxpa2UsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICBmcm9tOiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZVxuICAvKiAsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkICovXG4gICkge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTsgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG5cbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuXG4gICAgICBmb3IgKHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkaW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xuXG52YXIgJG5hdGl2ZSA9IFtdLmluZGV4T2Y7XG52YXIgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmluZGV4T2YoMSwgLTApIDwgMDtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjExIC8gMTUuNC40LjE0IEFycmF5LnByb3RvdHlwZS5pbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50XG4gIC8qICwgZnJvbUluZGV4ID0gMCAqL1xuICApIHtcbiAgICByZXR1cm4gTkVHQVRJVkVfWkVSTyAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgPyAkbmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMCA6ICRpbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIi8vIDIyLjEuMi4yIC8gMTUuNC4zLjIgQXJyYXkuaXNBcnJheShhcmcpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0FycmF5Jywge1xuICBpc0FycmF5OiByZXF1aXJlKCcuL19pcy1hcnJheScpXG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG5cbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG5cbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcblxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTsgLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxuXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcblxuICB0aGlzLl9pID0gMDsgLy8gbmV4dCBpbmRleFxuXG4gIHRoaXMuX2sgPSBraW5kOyAvLyBraW5kXG4gIC8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuXG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cblxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpOyAvLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5cbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTsiLCIndXNlIHN0cmljdCc7IC8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUuam9pbihzZXBhcmF0b3IpXG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbnZhciBhcnJheUpvaW4gPSBbXS5qb2luOyAvLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2Ugc3RyaW5nc1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChyZXF1aXJlKCcuL19pb2JqZWN0JykgIT0gT2JqZWN0IHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoYXJyYXlKb2luKSksICdBcnJheScsIHtcbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodG9JT2JqZWN0KHRoaXMpLCBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcsJyA6IHNlcGFyYXRvcik7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbnZhciAkbmF0aXZlID0gW10ubGFzdEluZGV4T2Y7XG52YXIgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmxhc3RJbmRleE9mKDEsIC0wKSA8IDA7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNCAvIDE1LjQuNC4xNSBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudFxuICAvKiAsIGZyb21JbmRleCA9IEBbKi0xXSAqL1xuICApIHtcbiAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgaWYgKE5FR0FUSVZFX1pFUk8pIHJldHVybiAkbmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMDtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSBpbmRleCA9IE1hdGgubWluKGluZGV4LCB0b0ludGVnZXIoYXJndW1lbnRzWzFdKSk7XG4gICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBsZW5ndGggKyBpbmRleDtcblxuICAgIGZvciAoOyBpbmRleCA+PSAwOyBpbmRleC0tKSBpZiAoaW5kZXggaW4gTykgaWYgKE9baW5kZXhdID09PSBzZWFyY2hFbGVtZW50KSByZXR1cm4gaW5kZXggfHwgMDtcblxuICAgIHJldHVybiAtMTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJG1hcCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgxKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLm1hcCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE1IC8gMTUuNC40LjE5IEFycmF5LnByb3RvdHlwZS5tYXAoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmblxuICAvKiAsIHRoaXNBcmcgKi9cbiAgKSB7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTsgLy8gV2ViS2l0IEFycmF5Lm9mIGlzbid0IGdlbmVyaWNcblxuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cblxuICByZXR1cm4gIShBcnJheS5vZi5jYWxsKEYpIGluc3RhbmNlb2YgRik7XG59KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMyBBcnJheS5vZiggLi4uaXRlbXMpXG4gIG9mOiBmdW5jdGlvbiBvZigpXG4gIC8qIC4uLmFyZ3MgKi9cbiAge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBuZXcgKHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXkpKGFMZW4pO1xuXG4gICAgd2hpbGUgKGFMZW4gPiBpbmRleCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgYXJndW1lbnRzW2luZGV4KytdKTtcblxuICAgIHJlc3VsdC5sZW5ndGggPSBhTGVuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZVJpZ2h0LCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTkgLyAxNS40LjQuMjIgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm5cbiAgLyogLCBpbml0aWFsVmFsdWUgKi9cbiAgKSB7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCB0cnVlKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTggLyAxNS40LjQuMjEgQXJyYXkucHJvdG90eXBlLnJlZHVjZShjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm5cbiAgLyogLCBpbml0aWFsVmFsdWUgKi9cbiAgKSB7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCBmYWxzZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGh0bWwgPSByZXF1aXJlKCcuL19odG1sJyk7XG5cbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcblxudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG52YXIgYXJyYXlTbGljZSA9IFtdLnNsaWNlOyAvLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZ3MgYW5kIERPTSBvYmplY3RzXG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIGlmIChodG1sKSBhcnJheVNsaWNlLmNhbGwoaHRtbCk7XG59KSwgJ0FycmF5Jywge1xuICBzbGljZTogZnVuY3Rpb24gc2xpY2UoYmVnaW4sIGVuZCkge1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0aGlzLmxlbmd0aCk7XG4gICAgdmFyIGtsYXNzID0gY29mKHRoaXMpO1xuICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kO1xuICAgIGlmIChrbGFzcyA9PSAnQXJyYXknKSByZXR1cm4gYXJyYXlTbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHZhciBzdGFydCA9IHRvQWJzb2x1dGVJbmRleChiZWdpbiwgbGVuKTtcbiAgICB2YXIgdXBUbyA9IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbik7XG4gICAgdmFyIHNpemUgPSB0b0xlbmd0aCh1cFRvIC0gc3RhcnQpO1xuICAgIHZhciBjbG9uZWQgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBzaXplOyBpKyspIGNsb25lZFtpXSA9IGtsYXNzID09ICdTdHJpbmcnID8gdGhpcy5jaGFyQXQoc3RhcnQgKyBpKSA6IHRoaXNbc3RhcnQgKyBpXTtcblxuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRzb21lID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDMpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uc29tZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjIzIC8gMTUuNC40LjE3IEFycmF5LnByb3RvdHlwZS5zb21lKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmblxuICAvKiAsIHRoaXNBcmcgKi9cbiAgKSB7XG4gICAgcmV0dXJuICRzb21lKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbnZhciAkc29ydCA9IFtdLnNvcnQ7XG52YXIgdGVzdCA9IFsxLCAyLCAzXTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gSUU4LVxuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIFY4IGJ1Z1xuICB0ZXN0LnNvcnQobnVsbCk7IC8vIE9sZCBXZWJLaXRcbn0pIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJHNvcnQpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjUgQXJyYXkucHJvdG90eXBlLnNvcnQoY29tcGFyZWZuKVxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZCA/ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcykpIDogJHNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSwgYUZ1bmN0aW9uKGNvbXBhcmVmbikpO1xuICB9XG59KTsiLCJyZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdBcnJheScpOyIsIi8vIDIwLjMuMy4xIC8gMTUuOS40LjQgRGF0ZS5ub3coKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdEYXRlJywge1xuICBub3c6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cbn0pOyIsIi8vIDIwLjMuNC4zNiAvIDE1LjkuNS40MyBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZygpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgdG9JU09TdHJpbmcgPSByZXF1aXJlKCcuL19kYXRlLXRvLWlzby1zdHJpbmcnKTsgLy8gUGhhbnRvbUpTIC8gb2xkIFdlYktpdCBoYXMgYSBicm9rZW4gaW1wbGVtZW50YXRpb25zXG5cblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgIT09IHRvSVNPU3RyaW5nKSwgJ0RhdGUnLCB7XG4gIHRvSVNPU3RyaW5nOiB0b0lTT1N0cmluZ1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgRGF0ZShOYU4pLnRvSlNPTigpICE9PSBudWxsIHx8IERhdGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHtcbiAgICB0b0lTT1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KSAhPT0gMTtcbn0pLCAnRGF0ZScsIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKGtleSkge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIHB2ID0gdG9QcmltaXRpdmUoTyk7XG4gICAgcmV0dXJuIHR5cGVvZiBwdiA9PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUocHYpID8gbnVsbCA6IE8udG9JU09TdHJpbmcoKTtcbiAgfVxufSk7IiwidmFyIFRPX1BSSU1JVElWRSA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1ByaW1pdGl2ZScpO1xuXG52YXIgcHJvdG8gPSBEYXRlLnByb3RvdHlwZTtcbmlmICghKFRPX1BSSU1JVElWRSBpbiBwcm90bykpIHJlcXVpcmUoJy4vX2hpZGUnKShwcm90bywgVE9fUFJJTUlUSVZFLCByZXF1aXJlKCcuL19kYXRlLXRvLXByaW1pdGl2ZScpKTsiLCJ2YXIgRGF0ZVByb3RvID0gRGF0ZS5wcm90b3R5cGU7XG52YXIgSU5WQUxJRF9EQVRFID0gJ0ludmFsaWQgRGF0ZSc7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSBEYXRlUHJvdG9bVE9fU1RSSU5HXTtcbnZhciBnZXRUaW1lID0gRGF0ZVByb3RvLmdldFRpbWU7XG5cbmlmIChuZXcgRGF0ZShOYU4pICsgJycgIT0gSU5WQUxJRF9EQVRFKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoRGF0ZVByb3RvLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciB2YWx1ZSA9IGdldFRpbWUuY2FsbCh0aGlzKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuXG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/ICR0b1N0cmluZy5jYWxsKHRoaXMpIDogSU5WQUxJRF9EQVRFO1xuICB9KTtcbn0iLCIvLyAxOS4yLjMuMiAvIDE1LjMuNC41IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKHRoaXNBcmcsIGFyZ3MuLi4pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0Z1bmN0aW9uJywge1xuICBiaW5kOiByZXF1aXJlKCcuL19iaW5kJylcbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxudmFyIEhBU19JTlNUQU5DRSA9IHJlcXVpcmUoJy4vX3drcycpKCdoYXNJbnN0YW5jZScpO1xuXG52YXIgRnVuY3Rpb25Qcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgLy8gMTkuMi4zLjYgRnVuY3Rpb24ucHJvdG90eXBlW0BAaGFzSW5zdGFuY2VdKFYpXG5cbmlmICghKEhBU19JTlNUQU5DRSBpbiBGdW5jdGlvblByb3RvKSkgcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihGdW5jdGlvblByb3RvLCBIQVNfSU5TVEFOQ0UsIHtcbiAgdmFsdWU6IGZ1bmN0aW9uIChPKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzICE9ICdmdW5jdGlvbicgfHwgIWlzT2JqZWN0KE8pKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFpc09iamVjdCh0aGlzLnByb3RvdHlwZSkpIHJldHVybiBPIGluc3RhbmNlb2YgdGhpczsgLy8gZm9yIGVudmlyb25tZW50IHcvbyBuYXRpdmUgYEBAaGFzSW5zdGFuY2VgIGxvZ2ljIGVub3VnaCBgaW5zdGFuY2VvZmAsIGJ1dCBhZGQgdGhpczpcblxuICAgIHdoaWxlIChPID0gZ2V0UHJvdG90eXBlT2YoTykpIGlmICh0aGlzLnByb3RvdHlwZSA9PT0gTykgcmV0dXJuIHRydWU7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pOyIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5cbnZhciBGUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgbmFtZVJFID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvO1xudmFyIE5BTUUgPSAnbmFtZSc7IC8vIDE5LjIuNC4yIG5hbWVcblxuTkFNRSBpbiBGUHJvdG8gfHwgcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiBkUChGUHJvdG8sIE5BTUUsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuICgnJyArIHRoaXMpLm1hdGNoKG5hbWVSRSlbMV07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcblxudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xuXG52YXIgTUFQID0gJ01hcCc7IC8vIDIzLjEgTWFwIE9iamVjdHNcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoTUFQLCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7IiwiLy8gMjAuMi4yLjMgTWF0aC5hY29zaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGxvZzFwID0gcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpO1xuXG52YXIgc3FydCA9IE1hdGguc3FydDtcbnZhciAkYWNvc2ggPSBNYXRoLmFjb3NoO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhY29zaCAvLyBWOCBidWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNTA5XG4mJiBNYXRoLmZsb29yKCRhY29zaChOdW1iZXIuTUFYX1ZBTFVFKSkgPT0gNzEwIC8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hY29zaChJbmZpbml0eSkgLT4gTmFOXG4mJiAkYWNvc2goSW5maW5pdHkpID09IEluZmluaXR5KSwgJ01hdGgnLCB7XG4gIGFjb3NoOiBmdW5jdGlvbiBhY29zaCh4KSB7XG4gICAgcmV0dXJuICh4ID0gK3gpIDwgMSA/IE5hTiA6IHggPiA5NDkwNjI2NS42MjQyNTE1NiA/IE1hdGgubG9nKHgpICsgTWF0aC5MTjIgOiBsb2cxcCh4IC0gMSArIHNxcnQoeCAtIDEpICogc3FydCh4ICsgMSkpO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJGFzaW5oID0gTWF0aC5hc2luaDtcblxuZnVuY3Rpb24gYXNpbmgoeCkge1xuICByZXR1cm4gIWlzRmluaXRlKHggPSAreCkgfHwgeCA9PSAwID8geCA6IHggPCAwID8gLWFzaW5oKC14KSA6IE1hdGgubG9nKHggKyBNYXRoLnNxcnQoeCAqIHggKyAxKSk7XG59IC8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hc2luaCgwKSAtPiAtMFxuXG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXNpbmggJiYgMSAvICRhc2luaCgwKSA+IDApLCAnTWF0aCcsIHtcbiAgYXNpbmg6IGFzaW5oXG59KTsiLCIvLyAyMC4yLjIuNyBNYXRoLmF0YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJGF0YW5oID0gTWF0aC5hdGFuaDsgLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmF0YW5oKC0wKSAtPiAwXG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXRhbmggJiYgMSAvICRhdGFuaCgtMCkgPCAwKSwgJ01hdGgnLCB7XG4gIGF0YW5oOiBmdW5jdGlvbiBhdGFuaCh4KSB7XG4gICAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogTWF0aC5sb2coKDEgKyB4KSAvICgxIC0geCkpIC8gMjtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjkgTWF0aC5jYnJ0KHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNicnQ6IGZ1bmN0aW9uIGNicnQoeCkge1xuICAgIHJldHVybiBzaWduKHggPSAreCkgKiBNYXRoLnBvdyhNYXRoLmFicyh4KSwgMSAvIDMpO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMTEgTWF0aC5jbHozMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjbHozMjogZnVuY3Rpb24gY2x6MzIoeCkge1xuICAgIHJldHVybiAoeCA+Pj49IDApID8gMzEgLSBNYXRoLmZsb29yKE1hdGgubG9nKHggKyAwLjUpICogTWF0aC5MT0cyRSkgOiAzMjtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjEyIE1hdGguY29zaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGV4cCA9IE1hdGguZXhwO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjb3NoOiBmdW5jdGlvbiBjb3NoKHgpIHtcbiAgICByZXR1cm4gKGV4cCh4ID0gK3gpICsgZXhwKC14KSkgLyAyO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRleHBtMSA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoJGV4cG0xICE9IE1hdGguZXhwbTEpLCAnTWF0aCcsIHtcbiAgZXhwbTE6ICRleHBtMVxufSk7IiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGZyb3VuZDogcmVxdWlyZSgnLi9fbWF0aC1mcm91bmQnKVxufSk7IiwiLy8gMjAuMi4yLjE3IE1hdGguaHlwb3QoW3ZhbHVlMVssIHZhbHVlMlssIOKApiBdXV0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgYWJzID0gTWF0aC5hYnM7XG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGh5cG90OiBmdW5jdGlvbiBoeXBvdCh2YWx1ZTEsIHZhbHVlMikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBsYXJnID0gMDtcbiAgICB2YXIgYXJnLCBkaXY7XG5cbiAgICB3aGlsZSAoaSA8IGFMZW4pIHtcbiAgICAgIGFyZyA9IGFicyhhcmd1bWVudHNbaSsrXSk7XG5cbiAgICAgIGlmIChsYXJnIDwgYXJnKSB7XG4gICAgICAgIGRpdiA9IGxhcmcgLyBhcmc7XG4gICAgICAgIHN1bSA9IHN1bSAqIGRpdiAqIGRpdiArIDE7XG4gICAgICAgIGxhcmcgPSBhcmc7XG4gICAgICB9IGVsc2UgaWYgKGFyZyA+IDApIHtcbiAgICAgICAgZGl2ID0gYXJnIC8gbGFyZztcbiAgICAgICAgc3VtICs9IGRpdiAqIGRpdjtcbiAgICAgIH0gZWxzZSBzdW0gKz0gYXJnO1xuICAgIH1cblxuICAgIHJldHVybiBsYXJnID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogbGFyZyAqIE1hdGguc3FydChzdW0pO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMTggTWF0aC5pbXVsKHgsIHkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJGltdWwgPSBNYXRoLmltdWw7IC8vIHNvbWUgV2ViS2l0IHZlcnNpb25zIGZhaWxzIHdpdGggYmlnIG51bWJlcnMsIHNvbWUgaGFzIHdyb25nIGFyaXR5XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAkaW11bCgweGZmZmZmZmZmLCA1KSAhPSAtNSB8fCAkaW11bC5sZW5ndGggIT0gMjtcbn0pLCAnTWF0aCcsIHtcbiAgaW11bDogZnVuY3Rpb24gaW11bCh4LCB5KSB7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZjtcbiAgICB2YXIgeG4gPSAreDtcbiAgICB2YXIgeW4gPSAreTtcbiAgICB2YXIgeGwgPSBVSU5UMTYgJiB4bjtcbiAgICB2YXIgeWwgPSBVSU5UMTYgJiB5bjtcbiAgICByZXR1cm4gMCB8IHhsICogeWwgKyAoKFVJTlQxNiAmIHhuID4+PiAxNikgKiB5bCArIHhsICogKFVJTlQxNiAmIHluID4+PiAxNikgPDwgMTYgPj4+IDApO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMjEgTWF0aC5sb2cxMCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cxMDogZnVuY3Rpb24gbG9nMTAoeCkge1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAqIE1hdGguTE9HMTBFO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cxcDogcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpXG59KTsiLCIvLyAyMC4yLjIuMjIgTWF0aC5sb2cyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzI6IGZ1bmN0aW9uIGxvZzIoeCkge1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4yO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHNpZ246IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpXG59KTsiLCIvLyAyMC4yLjIuMzAgTWF0aC5zaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG5cbnZhciBleHAgPSBNYXRoLmV4cDsgLy8gVjggbmVhciBDaHJvbWl1bSAzOCBoYXMgYSBwcm9ibGVtIHdpdGggdmVyeSBzbWFsbCBudW1iZXJzXG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhTWF0aC5zaW5oKC0yZS0xNykgIT0gLTJlLTE3O1xufSksICdNYXRoJywge1xuICBzaW5oOiBmdW5jdGlvbiBzaW5oKHgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoeCA9ICt4KSA8IDEgPyAoZXhwbTEoeCkgLSBleHBtMSgteCkpIC8gMiA6IChleHAoeCAtIDEpIC0gZXhwKC14IC0gMSkpICogKE1hdGguRSAvIDIpO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMzMgTWF0aC50YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG5cbnZhciBleHAgPSBNYXRoLmV4cDtcbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdGFuaDogZnVuY3Rpb24gdGFuaCh4KSB7XG4gICAgdmFyIGEgPSBleHBtMSh4ID0gK3gpO1xuICAgIHZhciBiID0gZXhwbTEoLXgpO1xuICAgIHJldHVybiBhID09IEluZmluaXR5ID8gMSA6IGIgPT0gSW5maW5pdHkgPyAtMSA6IChhIC0gYikgLyAoZXhwKHgpICsgZXhwKC14KSk7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4zNCBNYXRoLnRydW5jKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRydW5jOiBmdW5jdGlvbiB0cnVuYyhpdCkge1xuICAgIHJldHVybiAoaXQgPiAwID8gTWF0aC5mbG9vciA6IE1hdGguY2VpbCkoaXQpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5cbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcblxudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xuXG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcblxudmFyICR0cmltID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltO1xuXG52YXIgTlVNQkVSID0gJ051bWJlcic7XG52YXIgJE51bWJlciA9IGdsb2JhbFtOVU1CRVJdO1xudmFyIEJhc2UgPSAkTnVtYmVyO1xudmFyIHByb3RvID0gJE51bWJlci5wcm90b3R5cGU7IC8vIE9wZXJhIH4xMiBoYXMgYnJva2VuIE9iamVjdCN0b1N0cmluZ1xuXG52YXIgQlJPS0VOX0NPRiA9IGNvZihyZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJykocHJvdG8pKSA9PSBOVU1CRVI7XG52YXIgVFJJTSA9ICgndHJpbScgaW4gU3RyaW5nLnByb3RvdHlwZSk7IC8vIDcuMS4zIFRvTnVtYmVyKGFyZ3VtZW50KVxuXG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGl0ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIGZhbHNlKTtcblxuICBpZiAodHlwZW9mIGl0ID09ICdzdHJpbmcnICYmIGl0Lmxlbmd0aCA+IDIpIHtcbiAgICBpdCA9IFRSSU0gPyBpdC50cmltKCkgOiAkdHJpbShpdCwgMyk7XG4gICAgdmFyIGZpcnN0ID0gaXQuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgdGhpcmQsIHJhZGl4LCBtYXhDb2RlO1xuXG4gICAgaWYgKGZpcnN0ID09PSA0MyB8fCBmaXJzdCA9PT0gNDUpIHtcbiAgICAgIHRoaXJkID0gaXQuY2hhckNvZGVBdCgyKTtcbiAgICAgIGlmICh0aGlyZCA9PT0gODggfHwgdGhpcmQgPT09IDEyMCkgcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeFxuICAgIH0gZWxzZSBpZiAoZmlyc3QgPT09IDQ4KSB7XG4gICAgICBzd2l0Y2ggKGl0LmNoYXJDb2RlQXQoMSkpIHtcbiAgICAgICAgY2FzZSA2NjpcbiAgICAgICAgY2FzZSA5ODpcbiAgICAgICAgICByYWRpeCA9IDI7XG4gICAgICAgICAgbWF4Q29kZSA9IDQ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBmYXN0IGVxdWFsIC9eMGJbMDFdKyQvaVxuXG4gICAgICAgIGNhc2UgNzk6XG4gICAgICAgIGNhc2UgMTExOlxuICAgICAgICAgIHJhZGl4ID0gODtcbiAgICAgICAgICBtYXhDb2RlID0gNTU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGZhc3QgZXF1YWwgL14wb1swLTddKyQvaVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICtpdDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgZGlnaXRzID0gaXQuc2xpY2UoMiksIGkgPSAwLCBsID0gZGlnaXRzLmxlbmd0aCwgY29kZTsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb2RlID0gZGlnaXRzLmNoYXJDb2RlQXQoaSk7IC8vIHBhcnNlSW50IHBhcnNlcyBhIHN0cmluZyB0byBhIGZpcnN0IHVuYXZhaWxhYmxlIHN5bWJvbFxuICAgICAgICAvLyBidXQgVG9OdW1iZXIgc2hvdWxkIHJldHVybiBOYU4gaWYgYSBzdHJpbmcgY29udGFpbnMgdW5hdmFpbGFibGUgc3ltYm9sc1xuXG4gICAgICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IG1heENvZGUpIHJldHVybiBOYU47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJzZUludChkaWdpdHMsIHJhZGl4KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gK2l0O1xufTtcblxuaWYgKCEkTnVtYmVyKCcgMG8xJykgfHwgISROdW1iZXIoJzBiMScpIHx8ICROdW1iZXIoJysweDEnKSkge1xuICAkTnVtYmVyID0gZnVuY3Rpb24gTnVtYmVyKHZhbHVlKSB7XG4gICAgdmFyIGl0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgPyAwIDogdmFsdWU7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiB0aGF0IGluc3RhbmNlb2YgJE51bWJlciAvLyBjaGVjayBvbiAxLi5jb25zdHJ1Y3Rvcihmb28pIGNhc2VcbiAgICAmJiAoQlJPS0VOX0NPRiA/IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb3RvLnZhbHVlT2YuY2FsbCh0aGF0KTtcbiAgICB9KSA6IGNvZih0aGF0KSAhPSBOVU1CRVIpID8gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UodG9OdW1iZXIoaXQpKSwgdGhhdCwgJE51bWJlcikgOiB0b051bWJlcihpdCk7XG4gIH07XG5cbiAgZm9yICh2YXIga2V5cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BOKEJhc2UpIDogKCAvLyBFUzM6XG4gICdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSwnICsgLy8gRVM2IChpbiBjYXNlLCBpZiBtb2R1bGVzIHdpdGggRVM2IE51bWJlciBzdGF0aWNzIHJlcXVpcmVkIGJlZm9yZSk6XG4gICdFUFNJTE9OLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLE1BWF9TQUZFX0lOVEVHRVIsJyArICdNSU5fU0FGRV9JTlRFR0VSLHBhcnNlRmxvYXQscGFyc2VJbnQsaXNJbnRlZ2VyJykuc3BsaXQoJywnKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyBqKyspIHtcbiAgICBpZiAoaGFzKEJhc2UsIGtleSA9IGtleXNbal0pICYmICFoYXMoJE51bWJlciwga2V5KSkge1xuICAgICAgZFAoJE51bWJlciwga2V5LCBnT1BEKEJhc2UsIGtleSkpO1xuICAgIH1cbiAgfVxuXG4gICROdW1iZXIucHJvdG90eXBlID0gcHJvdG87XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJE51bWJlcjtcblxuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgTlVNQkVSLCAkTnVtYmVyKTtcbn0iLCIvLyAyMC4xLjIuMSBOdW1iZXIuRVBTSUxPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIEVQU0lMT046IE1hdGgucG93KDIsIC01Milcbn0pOyIsIi8vIDIwLjEuMi4yIE51bWJlci5pc0Zpbml0ZShudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgX2lzRmluaXRlID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuaXNGaW5pdGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH1cbn0pOyIsIi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzSW50ZWdlcjogcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpXG59KTsiLCIvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzTmFOOiBmdW5jdGlvbiBpc05hTihudW1iZXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pOyIsIi8vIDIwLjEuMi41IE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBpc0ludGVnZXIgPSByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJyk7XG5cbnZhciBhYnMgPSBNYXRoLmFicztcbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc1NhZmVJbnRlZ2VyOiBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKG51bWJlcikge1xuICAgIHJldHVybiBpc0ludGVnZXIobnVtYmVyKSAmJiBhYnMobnVtYmVyKSA8PSAweDFmZmZmZmZmZmZmZmZmO1xuICB9XG59KTsiLCIvLyAyMC4xLjIuNiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIE1BWF9TQUZFX0lOVEVHRVI6IDB4MWZmZmZmZmZmZmZmZmZcbn0pOyIsIi8vIDIwLjEuMi4xMCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIE1JTl9TQUZFX0lOVEVHRVI6IC0weDFmZmZmZmZmZmZmZmZmXG59KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19wYXJzZS1mbG9hdCcpOyAvLyAyMC4xLjIuMTIgTnVtYmVyLnBhcnNlRmxvYXQoc3RyaW5nKVxuXG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUZsb2F0ICE9ICRwYXJzZUZsb2F0KSwgJ051bWJlcicsIHtcbiAgcGFyc2VGbG9hdDogJHBhcnNlRmxvYXRcbn0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTsgLy8gMjAuMS4yLjEzIE51bWJlci5wYXJzZUludChzdHJpbmcsIHJhZGl4KVxuXG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUludCAhPSAkcGFyc2VJbnQpLCAnTnVtYmVyJywge1xuICBwYXJzZUludDogJHBhcnNlSW50XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG5cbnZhciBhTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuL19hLW51bWJlci12YWx1ZScpO1xuXG52YXIgcmVwZWF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpO1xuXG52YXIgJHRvRml4ZWQgPSAxLjAudG9GaXhlZDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgZGF0YSA9IFswLCAwLCAwLCAwLCAwLCAwXTtcbnZhciBFUlJPUiA9ICdOdW1iZXIudG9GaXhlZDogaW5jb3JyZWN0IGludm9jYXRpb24hJztcbnZhciBaRVJPID0gJzAnO1xuXG52YXIgbXVsdGlwbHkgPSBmdW5jdGlvbiAobiwgYykge1xuICB2YXIgaSA9IC0xO1xuICB2YXIgYzIgPSBjO1xuXG4gIHdoaWxlICgrK2kgPCA2KSB7XG4gICAgYzIgKz0gbiAqIGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGMyICUgMWU3O1xuICAgIGMyID0gZmxvb3IoYzIgLyAxZTcpO1xuICB9XG59O1xuXG52YXIgZGl2aWRlID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIGkgPSA2O1xuICB2YXIgYyA9IDA7XG5cbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgYyArPSBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBmbG9vcihjIC8gbik7XG4gICAgYyA9IGMgJSBuICogMWU3O1xuICB9XG59O1xuXG52YXIgbnVtVG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpID0gNjtcbiAgdmFyIHMgPSAnJztcblxuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBpZiAocyAhPT0gJycgfHwgaSA9PT0gMCB8fCBkYXRhW2ldICE9PSAwKSB7XG4gICAgICB2YXIgdCA9IFN0cmluZyhkYXRhW2ldKTtcbiAgICAgIHMgPSBzID09PSAnJyA/IHQgOiBzICsgcmVwZWF0LmNhbGwoWkVSTywgNyAtIHQubGVuZ3RoKSArIHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHM7XG59O1xuXG52YXIgcG93ID0gZnVuY3Rpb24gKHgsIG4sIGFjYykge1xuICByZXR1cm4gbiA9PT0gMCA/IGFjYyA6IG4gJSAyID09PSAxID8gcG93KHgsIG4gLSAxLCBhY2MgKiB4KSA6IHBvdyh4ICogeCwgbiAvIDIsIGFjYyk7XG59O1xuXG52YXIgbG9nID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIG4gPSAwO1xuICB2YXIgeDIgPSB4O1xuXG4gIHdoaWxlICh4MiA+PSA0MDk2KSB7XG4gICAgbiArPSAxMjtcbiAgICB4MiAvPSA0MDk2O1xuICB9XG5cbiAgd2hpbGUgKHgyID49IDIpIHtcbiAgICBuICs9IDE7XG4gICAgeDIgLz0gMjtcbiAgfVxuXG4gIHJldHVybiBuO1xufTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoISEkdG9GaXhlZCAmJiAoMC4wMDAwOC50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8IDAuOS50b0ZpeGVkKDApICE9PSAnMScgfHwgMS4yNTUudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8IDEwMDAwMDAwMDAwMDAwMDAxMjguMC50b0ZpeGVkKDApICE9PSAnMTAwMDAwMDAwMDAwMDAwMDEyOCcpIHx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvRml4ZWQuY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvRml4ZWQ6IGZ1bmN0aW9uIHRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpIHtcbiAgICB2YXIgeCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCBFUlJPUik7XG4gICAgdmFyIGYgPSB0b0ludGVnZXIoZnJhY3Rpb25EaWdpdHMpO1xuICAgIHZhciBzID0gJyc7XG4gICAgdmFyIG0gPSBaRVJPO1xuICAgIHZhciBlLCB6LCBqLCBrO1xuICAgIGlmIChmIDwgMCB8fCBmID4gMjApIHRocm93IFJhbmdlRXJyb3IoRVJST1IpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG5cbiAgICBpZiAoeCAhPSB4KSByZXR1cm4gJ05hTic7XG4gICAgaWYgKHggPD0gLTFlMjEgfHwgeCA+PSAxZTIxKSByZXR1cm4gU3RyaW5nKHgpO1xuXG4gICAgaWYgKHggPCAwKSB7XG4gICAgICBzID0gJy0nO1xuICAgICAgeCA9IC14O1xuICAgIH1cblxuICAgIGlmICh4ID4gMWUtMjEpIHtcbiAgICAgIGUgPSBsb2coeCAqIHBvdygyLCA2OSwgMSkpIC0gNjk7XG4gICAgICB6ID0gZSA8IDAgPyB4ICogcG93KDIsIC1lLCAxKSA6IHggLyBwb3coMiwgZSwgMSk7XG4gICAgICB6ICo9IDB4MTAwMDAwMDAwMDAwMDA7XG4gICAgICBlID0gNTIgLSBlO1xuXG4gICAgICBpZiAoZSA+IDApIHtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIGogPSBmO1xuXG4gICAgICAgIHdoaWxlIChqID49IDcpIHtcbiAgICAgICAgICBtdWx0aXBseSgxZTcsIDApO1xuICAgICAgICAgIGogLT0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIG11bHRpcGx5KHBvdygxMCwgaiwgMSksIDApO1xuICAgICAgICBqID0gZSAtIDE7XG5cbiAgICAgICAgd2hpbGUgKGogPj0gMjMpIHtcbiAgICAgICAgICBkaXZpZGUoMSA8PCAyMyk7XG4gICAgICAgICAgaiAtPSAyMztcbiAgICAgICAgfVxuXG4gICAgICAgIGRpdmlkZSgxIDw8IGopO1xuICAgICAgICBtdWx0aXBseSgxLCAxKTtcbiAgICAgICAgZGl2aWRlKDIpO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11bHRpcGx5KDAsIHopO1xuICAgICAgICBtdWx0aXBseSgxIDw8IC1lLCAwKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCkgKyByZXBlYXQuY2FsbChaRVJPLCBmKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZiA+IDApIHtcbiAgICAgIGsgPSBtLmxlbmd0aDtcbiAgICAgIG0gPSBzICsgKGsgPD0gZiA/ICcwLicgKyByZXBlYXQuY2FsbChaRVJPLCBmIC0gaykgKyBtIDogbS5zbGljZSgwLCBrIC0gZikgKyAnLicgKyBtLnNsaWNlKGsgLSBmKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBzICsgbTtcbiAgICB9XG5cbiAgICByZXR1cm4gbTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxudmFyIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJyk7XG5cbnZhciAkdG9QcmVjaXNpb24gPSAxLjAudG9QcmVjaXNpb247XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICgkZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBJRTctXG4gIHJldHVybiAkdG9QcmVjaXNpb24uY2FsbCgxLCB1bmRlZmluZWQpICE9PSAnMSc7XG59KSB8fCAhJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvUHJlY2lzaW9uLmNhbGwoe30pO1xufSkpLCAnTnVtYmVyJywge1xuICB0b1ByZWNpc2lvbjogZnVuY3Rpb24gdG9QcmVjaXNpb24ocHJlY2lzaW9uKSB7XG4gICAgdmFyIHRoYXQgPSBhTnVtYmVyVmFsdWUodGhpcywgJ051bWJlciN0b1ByZWNpc2lvbjogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gICAgcmV0dXJuIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gJHRvUHJlY2lzaW9uLmNhbGwodGhhdCkgOiAkdG9QcmVjaXNpb24uY2FsbCh0aGF0LCBwcmVjaXNpb24pO1xuICB9XG59KTsiLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7XG4gIGFzc2lnbjogcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpXG59KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpOyAvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcblxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgY3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbn0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7IC8vIDE5LjEuMi4zIC8gMTUuMi4zLjcgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcblxuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0Jywge1xuICBkZWZpbmVQcm9wZXJ0aWVzOiByZXF1aXJlKCcuL19vYmplY3QtZHBzJylcbn0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7IC8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG5cblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtcbiAgZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbn0pOyIsIi8vIDE5LjEuMi41IE9iamVjdC5mcmVlemUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdmcmVlemUnLCBmdW5jdGlvbiAoJGZyZWV6ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKGl0KSB7XG4gICAgcmV0dXJuICRmcmVlemUgJiYgaXNPYmplY3QoaXQpID8gJGZyZWV6ZShtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5TmFtZXMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKS5mO1xufSk7IiwiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxudmFyICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjExIE9iamVjdC5pc0V4dGVuc2libGUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRXh0ZW5zaWJsZScsIGZ1bmN0aW9uICgkaXNFeHRlbnNpYmxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUoaXQpIDogdHJ1ZSA6IGZhbHNlO1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjEyIE9iamVjdC5pc0Zyb3plbihPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNGcm96ZW4nLCBmdW5jdGlvbiAoJGlzRnJvemVuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc0Zyb3plbihpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNGcm96ZW4gPyAkaXNGcm96ZW4oaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjEzIE9iamVjdC5pc1NlYWxlZChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNTZWFsZWQnLCBmdW5jdGlvbiAoJGlzU2VhbGVkKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc1NlYWxlZChpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNTZWFsZWQgPyAkaXNTZWFsZWQoaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7IiwiLy8gMTkuMS4zLjEwIE9iamVjdC5pcyh2YWx1ZTEsIHZhbHVlMilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBpczogcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpXG59KTsiLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTUgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgncHJldmVudEV4dGVuc2lvbnMnLCBmdW5jdGlvbiAoJHByZXZlbnRFeHRlbnNpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyhpdCkge1xuICAgIHJldHVybiAkcHJldmVudEV4dGVuc2lvbnMgJiYgaXNPYmplY3QoaXQpID8gJHByZXZlbnRFeHRlbnNpb25zKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjE3IE9iamVjdC5zZWFsKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnc2VhbCcsIGZ1bmN0aW9uICgkc2VhbCkge1xuICByZXR1cm4gZnVuY3Rpb24gc2VhbChpdCkge1xuICAgIHJldHVybiAkc2VhbCAmJiBpc09iamVjdChpdCkgPyAkc2VhbChtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgc2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldFxufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcblxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG5cbnZhciB0ZXN0ID0ge307XG50ZXN0W3JlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXSA9ICd6JztcblxuaWYgKHRlc3QgKyAnJyAhPSAnW29iamVjdCB6XScpIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG4gIH0sIHRydWUpO1xufSIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7IC8vIDE4LjIuNCBwYXJzZUZsb2F0KHN0cmluZylcblxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUZsb2F0ICE9ICRwYXJzZUZsb2F0KSwge1xuICBwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdFxufSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX3BhcnNlLWludCcpOyAvLyAxOC4yLjUgcGFyc2VJbnQoc3RyaW5nLCByYWRpeClcblxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUludCAhPSAkcGFyc2VJbnQpLCB7XG4gIHBhcnNlSW50OiAkcGFyc2VJbnRcbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xuXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcblxudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbnZhciB0YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldDtcblxudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG5cbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcblxudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG5cbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7XG5cbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xuXG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucztcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4IHx8ICcnO1xudmFyICRQcm9taXNlID0gZ2xvYmFsW1BST01JU0VdO1xudmFyIGlzTm9kZSA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG52YXIgZW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gIC8qIGVtcHR5ICovXG59O1xuXG52YXIgSW50ZXJuYWwsIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mO1xudmFyIFVTRV9OQVRJVkUgPSAhIWZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSA9ICRQcm9taXNlLnJlc29sdmUoMSk7XG5cbiAgICB2YXIgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgICBleGVjKGVtcHR5LCBlbXB0eSk7XG4gICAgfTsgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuXG5cbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZSAvLyB2OCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODMwNTY1XG4gICAgLy8gd2UgY2FuJ3QgZGV0ZWN0IGl0IHN5bmNocm9ub3VzbHksIHNvIGp1c3QgY2hlY2sgdmVyc2lvbnNcbiAgICAmJiB2OC5pbmRleE9mKCc2LjYnKSAhPT0gMCAmJiB1c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lLzY2JykgPT09IC0xO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfVxufSgpOyAvLyBoZWxwZXJzXG5cbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xuXG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHByb21pc2UsIGlzUmVqZWN0KSB7XG4gIGlmIChwcm9taXNlLl9uKSByZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIG9rID0gcHJvbWlzZS5fcyA9PSAxO1xuICAgIHZhciBpID0gMDtcblxuICAgIHZhciBydW4gPSBmdW5jdGlvbiAocmVhY3Rpb24pIHtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gICAgICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gICAgICB2YXIgcmVqZWN0ID0gcmVhY3Rpb24ucmVqZWN0O1xuICAgICAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgICAgIHZhciByZXN1bHQsIHRoZW4sIGV4aXRlZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faCA9PSAyKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtlbHNlIHtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7IC8vIG1heSB0aHJvd1xuXG4gICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgICAgIGV4aXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkgcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuXG5cbiAgICBwcm9taXNlLl9jID0gW107XG4gICAgcHJvbWlzZS5fbiA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhcHJvbWlzZS5faCkgb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcblxudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIHVuaGFuZGxlZCA9IGlzVW5oYW5kbGVkKHByb21pc2UpO1xuICAgIHZhciByZXN1bHQsIGhhbmRsZXIsIGNvbnNvbGU7XG5cbiAgICBpZiAodW5oYW5kbGVkKSB7XG4gICAgICByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzTm9kZSkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pIHtcbiAgICAgICAgICBoYW5kbGVyKHtcbiAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgICAgICByZWFzb246IHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG5cbiAgICAgIHByb21pc2UuX2ggPSBpc05vZGUgfHwgaXNVbmhhbmRsZWQocHJvbWlzZSkgPyAyIDogMTtcbiAgICB9XG5cbiAgICBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmICh1bmhhbmRsZWQgJiYgcmVzdWx0LmUpIHRocm93IHJlc3VsdC52O1xuICB9KTtcbn07XG5cbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHJldHVybiBwcm9taXNlLl9oICE9PSAxICYmIChwcm9taXNlLl9hIHx8IHByb21pc2UuX2MpLmxlbmd0aCA9PT0gMDtcbn07XG5cbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlcjtcblxuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnJlamVjdGlvbmhhbmRsZWQpIHtcbiAgICAgIGhhbmRsZXIoe1xuICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuICAgICAgICByZWFzb246IHByb21pc2UuX3ZcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmIChwcm9taXNlLl9kKSByZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcblxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZiAoIXByb21pc2UuX2EpIHByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG5cbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIHZhciB0aGVuO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG5cbiAgdHJ5IHtcbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuXG4gICAgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7XG4gICAgICAgICAgX3c6IHByb21pc2UsXG4gICAgICAgICAgX2Q6IGZhbHNlXG4gICAgICAgIH07IC8vIHdyYXBcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAkcmVqZWN0LmNhbGwoe1xuICAgICAgX3c6IHByb21pc2UsXG4gICAgICBfZDogZmFsc2VcbiAgICB9LCBlKTsgLy8gd3JhcFxuICB9XG59OyAvLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuXG5cbmlmICghVVNFX05BVElWRSkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG5cbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoY3R4KCRyZXNvbHZlLCB0aGlzLCAxKSwgY3R4KCRyZWplY3QsIHRoaXMsIDEpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICRyZWplY3QuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH1cbiAgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cblxuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICB0aGlzLl9jID0gW107IC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcblxuICAgIHRoaXMuX3MgPSAwOyAvLyA8LSBzdGF0ZVxuXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAvLyA8LSBkb25lXG5cbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAvLyA8LSB2YWx1ZVxuXG4gICAgdGhpcy5faCA9IDA7IC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG5cbiAgICB0aGlzLl9uID0gZmFsc2U7IC8vIDwtIG5vdGlmeVxuICB9O1xuXG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRQcm9taXNlKSk7XG4gICAgICByZWFjdGlvbi5vayA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IGlzTm9kZSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuXG4gICAgICBpZiAodGhpcy5fYSkgdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9zKSBub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcblxuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gY3R4KCRyZXNvbHZlLCBwcm9taXNlLCAxKTtcbiAgICB0aGlzLnJlamVjdCA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcblxuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSAkUHJvbWlzZSB8fCBDID09PSBXcmFwcGVyID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7XG4gIFByb21pc2U6ICRQcm9taXNlXG59KTtcblxucmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKSgkUHJvbWlzZSwgUFJPTUlTRSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5cbldyYXBwZXIgPSByZXF1aXJlKCcuL19jb3JlJylbUFJPTUlTRV07IC8vIHN0YXRpY3NcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKTtcbiAgICB2YXIgJCRyZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKExJQlJBUlkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoTElCUkFSWSAmJiB0aGlzID09PSBXcmFwcGVyID8gJFByb21pc2UgOiB0aGlzLCB4KTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyICRpbmRleCA9IGluZGV4Kys7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1skaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTsiLCIvLyAyNi4xLjEgUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgckFwcGx5ID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmFwcGx5O1xudmFyIGZBcHBseSA9IEZ1bmN0aW9uLmFwcGx5OyAvLyBNUyBFZGdlIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJBcHBseShmdW5jdGlvbiAoKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdCkge1xuICAgIHZhciBUID0gYUZ1bmN0aW9uKHRhcmdldCk7XG4gICAgdmFyIEwgPSBhbk9iamVjdChhcmd1bWVudHNMaXN0KTtcbiAgICByZXR1cm4gckFwcGx5ID8gckFwcGx5KFQsIHRoaXNBcmd1bWVudCwgTCkgOiBmQXBwbHkuY2FsbChULCB0aGlzQXJndW1lbnQsIEwpO1xuICB9XG59KTsiLCIvLyAyNi4xLjIgUmVmbGVjdC5jb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0IFssIG5ld1RhcmdldF0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xuXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9fYmluZCcpO1xuXG52YXIgckNvbnN0cnVjdCA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5jb25zdHJ1Y3Q7IC8vIE1TIEVkZ2Ugc3VwcG9ydHMgb25seSAyIGFyZ3VtZW50cyBhbmQgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuLy8gRkYgTmlnaHRseSBzZXRzIHRoaXJkIGFyZ3VtZW50IGFzIGBuZXcudGFyZ2V0YCwgYnV0IGRvZXMgbm90IGNyZWF0ZSBgdGhpc2AgZnJvbSBpdFxuXG52YXIgTkVXX1RBUkdFVF9CVUcgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfVxuXG4gIHJldHVybiAhKHJDb25zdHJ1Y3QoZnVuY3Rpb24gKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH0sIFtdLCBGKSBpbnN0YW5jZW9mIEYpO1xufSk7XG52YXIgQVJHU19CVUcgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByQ29uc3RydWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9KTtcbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTkVXX1RBUkdFVF9CVUcgfHwgQVJHU19CVUcpLCAnUmVmbGVjdCcsIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzXG4gIC8qICwgbmV3VGFyZ2V0ICovXG4gICkge1xuICAgIGFGdW5jdGlvbihUYXJnZXQpO1xuICAgIGFuT2JqZWN0KGFyZ3MpO1xuICAgIHZhciBuZXdUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IFRhcmdldCA6IGFGdW5jdGlvbihhcmd1bWVudHNbMl0pO1xuICAgIGlmIChBUkdTX0JVRyAmJiAhTkVXX1RBUkdFVF9CVUcpIHJldHVybiByQ29uc3RydWN0KFRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcblxuICAgIGlmIChUYXJnZXQgPT0gbmV3VGFyZ2V0KSB7XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIG9wdGltaXphdGlvbiBmb3IgMC00IGFyZ3VtZW50c1xuICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoKTtcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSk7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcblxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICB9IC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgbG90IG9mIGFyZ3VtZW50cyBjYXNlXG5cblxuICAgICAgdmFyICRhcmdzID0gW251bGxdO1xuICAgICAgJGFyZ3MucHVzaC5hcHBseSgkYXJncywgYXJncyk7XG4gICAgICByZXR1cm4gbmV3IChiaW5kLmFwcGx5KFRhcmdldCwgJGFyZ3MpKSgpO1xuICAgIH0gLy8gd2l0aCBhbHRlcmVkIG5ld1RhcmdldCwgbm90IHN1cHBvcnQgYnVpbHQtaW4gY29uc3RydWN0b3JzXG5cblxuICAgIHZhciBwcm90byA9IG5ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgdmFyIGluc3RhbmNlID0gY3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0LnByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IEZ1bmN0aW9uLmFwcGx5LmNhbGwoVGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfVxufSk7IiwiLy8gMjYuMS4zIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcylcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7IC8vIE1TIEVkZ2UgaGFzIGJyb2tlbiBSZWZsZWN0LmRlZmluZVByb3BlcnR5IC0gdGhyb3dpbmcgaW5zdGVhZCBvZiByZXR1cm5pbmcgZmFsc2VcblxuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShkUC5mKHt9LCAxLCB7XG4gICAgdmFsdWU6IDFcbiAgfSksIDEsIHtcbiAgICB2YWx1ZTogMlxuICB9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpIHtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUocHJvcGVydHlLZXksIHRydWUpO1xuICAgIGFuT2JqZWN0KGF0dHJpYnV0ZXMpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGRQLmYodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTsiLCIvLyAyNi4xLjQgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgdmFyIGRlc2MgPSBnT1BEKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgICByZXR1cm4gZGVzYyAmJiAhZGVzYy5jb25maWd1cmFibGUgPyBmYWxzZSA6IGRlbGV0ZSB0YXJnZXRbcHJvcGVydHlLZXldO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIDI2LjEuNSBSZWZsZWN0LmVudW1lcmF0ZSh0YXJnZXQpXG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgRW51bWVyYXRlID0gZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBhbk9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuXG4gIHRoaXMuX2kgPSAwOyAvLyBuZXh0IGluZGV4XG5cbiAgdmFyIGtleXMgPSB0aGlzLl9rID0gW107IC8vIGtleXNcblxuICB2YXIga2V5O1xuXG4gIGZvciAoa2V5IGluIGl0ZXJhdGVkKSBrZXlzLnB1c2goa2V5KTtcbn07XG5cbnJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJykoRW51bWVyYXRlLCAnT2JqZWN0JywgZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHZhciBrZXlzID0gdGhhdC5faztcbiAgdmFyIGtleTtcblxuICBkbyB7XG4gICAgaWYgKHRoYXQuX2kgPj0ga2V5cy5sZW5ndGgpIHJldHVybiB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgZG9uZTogdHJ1ZVxuICAgIH07XG4gIH0gd2hpbGUgKCEoKGtleSA9IGtleXNbdGhhdC5faSsrXSkgaW4gdGhhdC5fdCkpO1xuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IGtleSxcbiAgICBkb25lOiBmYWxzZVxuICB9O1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZW51bWVyYXRlOiBmdW5jdGlvbiBlbnVtZXJhdGUodGFyZ2V0KSB7XG4gICAgcmV0dXJuIG5ldyBFbnVtZXJhdGUodGFyZ2V0KTtcbiAgfVxufSk7IiwiLy8gMjYuMS43IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgfVxufSk7IiwiLy8gMjYuMS44IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGdldFByb3RvID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdldFByb3RvKGFuT2JqZWN0KHRhcmdldCkpO1xuICB9XG59KTsiLCIvLyAyNi4xLjYgUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSBbLCByZWNlaXZlcl0pXG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG5cbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3BlcnR5S2V5XG4vKiAsIHJlY2VpdmVyICovXG4pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl07XG4gIHZhciBkZXNjLCBwcm90bztcbiAgaWYgKGFuT2JqZWN0KHRhcmdldCkgPT09IHJlY2VpdmVyKSByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgaWYgKGRlc2MgPSBnT1BELmYodGFyZ2V0LCBwcm9wZXJ0eUtleSkpIHJldHVybiBoYXMoZGVzYywgJ3ZhbHVlJykgPyBkZXNjLnZhbHVlIDogZGVzYy5nZXQgIT09IHVuZGVmaW5lZCA/IGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpIDogdW5kZWZpbmVkO1xuICBpZiAoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSkgcmV0dXJuIGdldChwcm90bywgcHJvcGVydHlLZXksIHJlY2VpdmVyKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXQ6IGdldFxufSk7IiwiLy8gMjYuMS45IFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gcHJvcGVydHlLZXkgaW4gdGFyZ2V0O1xuICB9XG59KTsiLCIvLyAyNi4xLjEwIFJlZmxlY3QuaXNFeHRlbnNpYmxlKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgJGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gaXNFeHRlbnNpYmxlKHRhcmdldCkge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcmV0dXJuICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKHRhcmdldCkgOiB0cnVlO1xuICB9XG59KTsiLCIvLyAyNi4xLjExIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIG93bktleXM6IHJlcXVpcmUoJy4vX293bi1rZXlzJylcbn0pOyIsIi8vIDI2LjEuMTIgUmVmbGVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyICRwcmV2ZW50RXh0ZW5zaW9ucyA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucztcbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCkge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKCRwcmV2ZW50RXh0ZW5zaW9ucykgJHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTsiLCIvLyAyNi4xLjE0IFJlZmxlY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBzZXRQcm90byA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpO1xuXG5pZiAoc2V0UHJvdG8pICRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgc2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pIHtcbiAgICBzZXRQcm90by5jaGVjayh0YXJnZXQsIHByb3RvKTtcblxuICAgIHRyeSB7XG4gICAgICBzZXRQcm90by5zZXQodGFyZ2V0LCBwcm90byk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTsiLCIvLyAyNi4xLjEzIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYgWywgcmVjZWl2ZXJdKVxudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcblxudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWXG4vKiAsIHJlY2VpdmVyICovXG4pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDQgPyB0YXJnZXQgOiBhcmd1bWVudHNbM107XG4gIHZhciBvd25EZXNjID0gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgdmFyIGV4aXN0aW5nRGVzY3JpcHRvciwgcHJvdG87XG5cbiAgaWYgKCFvd25EZXNjKSB7XG4gICAgaWYgKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpIHtcbiAgICAgIHJldHVybiBzZXQocHJvdG8sIHByb3BlcnR5S2V5LCBWLCByZWNlaXZlcik7XG4gICAgfVxuXG4gICAgb3duRGVzYyA9IGNyZWF0ZURlc2MoMCk7XG4gIH1cblxuICBpZiAoaGFzKG93bkRlc2MsICd2YWx1ZScpKSB7XG4gICAgaWYgKG93bkRlc2Mud3JpdGFibGUgPT09IGZhbHNlIHx8ICFpc09iamVjdChyZWNlaXZlcikpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChleGlzdGluZ0Rlc2NyaXB0b3IgPSBnT1BELmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5KSkge1xuICAgICAgaWYgKGV4aXN0aW5nRGVzY3JpcHRvci5nZXQgfHwgZXhpc3RpbmdEZXNjcmlwdG9yLnNldCB8fCBleGlzdGluZ0Rlc2NyaXB0b3Iud3JpdGFibGUgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICBleGlzdGluZ0Rlc2NyaXB0b3IudmFsdWUgPSBWO1xuICAgICAgZFAuZihyZWNlaXZlciwgcHJvcGVydHlLZXksIGV4aXN0aW5nRGVzY3JpcHRvcik7XG4gICAgfSBlbHNlIGRQLmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5LCBjcmVhdGVEZXNjKDAsIFYpKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIG93bkRlc2Muc2V0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IChvd25EZXNjLnNldC5jYWxsKHJlY2VpdmVyLCBWKSwgdHJ1ZSk7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgc2V0OiBzZXRcbn0pOyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xuXG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcblxudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG5cbnZhciAkZmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xuXG52YXIgJFJlZ0V4cCA9IGdsb2JhbC5SZWdFeHA7XG52YXIgQmFzZSA9ICRSZWdFeHA7XG52YXIgcHJvdG8gPSAkUmVnRXhwLnByb3RvdHlwZTtcbnZhciByZTEgPSAvYS9nO1xudmFyIHJlMiA9IC9hL2c7IC8vIFwibmV3XCIgY3JlYXRlcyBhIG5ldyBvYmplY3QsIG9sZCB3ZWJraXQgYnVnZ3kgaGVyZVxuXG52YXIgQ09SUkVDVF9ORVcgPSBuZXcgJFJlZ0V4cChyZTEpICE9PSByZTE7XG5cbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICghQ09SUkVDVF9ORVcgfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJlMltyZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKV0gPSBmYWxzZTsgLy8gUmVnRXhwIGNvbnN0cnVjdG9yIGNhbiBhbHRlciBmbGFncyBhbmQgSXNSZWdFeHAgd29ya3MgY29ycmVjdCB3aXRoIEBAbWF0Y2hcblxuICByZXR1cm4gJFJlZ0V4cChyZTEpICE9IHJlMSB8fCAkUmVnRXhwKHJlMikgPT0gcmUyIHx8ICRSZWdFeHAocmUxLCAnaScpICE9ICcvYS9pJztcbn0pKSkge1xuICAkUmVnRXhwID0gZnVuY3Rpb24gUmVnRXhwKHAsIGYpIHtcbiAgICB2YXIgdGlSRSA9IHRoaXMgaW5zdGFuY2VvZiAkUmVnRXhwO1xuICAgIHZhciBwaVJFID0gaXNSZWdFeHAocCk7XG4gICAgdmFyIGZpVSA9IGYgPT09IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gIXRpUkUgJiYgcGlSRSAmJiBwLmNvbnN0cnVjdG9yID09PSAkUmVnRXhwICYmIGZpVSA/IHAgOiBpbmhlcml0SWZSZXF1aXJlZChDT1JSRUNUX05FVyA/IG5ldyBCYXNlKHBpUkUgJiYgIWZpVSA/IHAuc291cmNlIDogcCwgZikgOiBCYXNlKChwaVJFID0gcCBpbnN0YW5jZW9mICRSZWdFeHApID8gcC5zb3VyY2UgOiBwLCBwaVJFICYmIGZpVSA/ICRmbGFncy5jYWxsKHApIDogZiksIHRpUkUgPyB0aGlzIDogcHJvdG8sICRSZWdFeHApO1xuICB9O1xuXG4gIHZhciBwcm94eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBrZXkgaW4gJFJlZ0V4cCB8fCBkUCgkUmVnRXhwLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQmFzZVtrZXldO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgIEJhc2Vba2V5XSA9IGl0O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGtleXMgPSBnT1BOKEJhc2UpLCBpID0gMDsga2V5cy5sZW5ndGggPiBpOykgcHJveHkoa2V5c1tpKytdKTtcblxuICBwcm90by5jb25zdHJ1Y3RvciA9ICRSZWdFeHA7XG4gICRSZWdFeHAucHJvdG90eXBlID0gcHJvdG87XG5cbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShnbG9iYWwsICdSZWdFeHAnLCAkUmVnRXhwKTtcbn1cblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnUmVnRXhwJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjJyk7XG5cbnJlcXVpcmUoJy4vX2V4cG9ydCcpKHtcbiAgdGFyZ2V0OiAnUmVnRXhwJyxcbiAgcHJvdG86IHRydWUsXG4gIGZvcmNlZDogcmVnZXhwRXhlYyAhPT0gLy4vLmV4ZWNcbn0sIHtcbiAgZXhlYzogcmVnZXhwRXhlY1xufSk7IiwiLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3MoKVxuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgLy4vZy5mbGFncyAhPSAnZycpIHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoUmVnRXhwLnByb3RvdHlwZSwgJ2ZsYWdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogcmVxdWlyZSgnLi9fZmxhZ3MnKVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuL19hZHZhbmNlLXN0cmluZy1pbmRleCcpO1xuXG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7IC8vIEBAbWF0Y2ggbG9naWNcblxuXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ21hdGNoJywgMSwgZnVuY3Rpb24gKGRlZmluZWQsIE1BVENILCAkbWF0Y2gsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICByZXR1cm4gWy8vIGBTdHJpbmcucHJvdG90eXBlLm1hdGNoYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5tYXRjaFxuICBmdW5jdGlvbiBtYXRjaChyZWdleHApIHtcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtNQVRDSF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbTUFUQ0hdKFN0cmluZyhPKSk7XG4gIH0sIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQG1hdGNoXG4gIGZ1bmN0aW9uIChyZWdleHApIHtcbiAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKCRtYXRjaCwgcmVnZXhwLCB0aGlzKTtcbiAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG4gICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcbiAgICBpZiAoIXJ4Lmdsb2JhbCkgcmV0dXJuIHJlZ0V4cEV4ZWMocngsIFMpO1xuICAgIHZhciBmdWxsVW5pY29kZSA9IHJ4LnVuaWNvZGU7XG4gICAgcngubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgQSA9IFtdO1xuICAgIHZhciBuID0gMDtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgd2hpbGUgKChyZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKSkgIT09IG51bGwpIHtcbiAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgQVtuXSA9IG1hdGNoU3RyO1xuICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgIG4rKztcbiAgICB9XG5cbiAgICByZXR1cm4gbiA9PT0gMCA/IG51bGwgOiBBO1xuICB9XTtcbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcblxudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IHJlcXVpcmUoJy4vX2FkdmFuY2Utc3RyaW5nLWluZGV4Jyk7XG5cbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcblxudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MUyA9IC9cXCQoWyQmYCddfFxcZFxcZD98PFtePl0qPikvZztcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRCA9IC9cXCQoWyQmYCddfFxcZFxcZD8pL2c7XG5cbnZhciBtYXliZVRvU3RyaW5nID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gaXQgOiBTdHJpbmcoaXQpO1xufTsgLy8gQEByZXBsYWNlIGxvZ2ljXG5cblxucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdyZXBsYWNlJywgMiwgZnVuY3Rpb24gKGRlZmluZWQsIFJFUExBQ0UsICRyZXBsYWNlLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgcmV0dXJuIFsvLyBgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlXG4gIGZ1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkge1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZWFyY2hWYWx1ZVtSRVBMQUNFXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwoc2VhcmNoVmFsdWUsIE8sIHJlcGxhY2VWYWx1ZSkgOiAkcmVwbGFjZS5jYWxsKFN0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gIH0sIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV1gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAcmVwbGFjZVxuICBmdW5jdGlvbiAocmVnZXhwLCByZXBsYWNlVmFsdWUpIHtcbiAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKCRyZXBsYWNlLCByZWdleHAsIHRoaXMsIHJlcGxhY2VWYWx1ZSk7XG4gICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG4gICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgdmFyIGZ1bmN0aW9uYWxSZXBsYWNlID0gdHlwZW9mIHJlcGxhY2VWYWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAoIWZ1bmN0aW9uYWxSZXBsYWNlKSByZXBsYWNlVmFsdWUgPSBTdHJpbmcocmVwbGFjZVZhbHVlKTtcbiAgICB2YXIgZ2xvYmFsID0gcnguZ2xvYmFsO1xuXG4gICAgaWYgKGdsb2JhbCkge1xuICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgIHJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSBicmVhaztcbiAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgaWYgKCFnbG9iYWwpIGJyZWFrO1xuICAgICAgdmFyIG1hdGNoU3RyID0gU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICBpZiAobWF0Y2hTdHIgPT09ICcnKSByeC5sYXN0SW5kZXggPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgdG9MZW5ndGgocngubGFzdEluZGV4KSwgZnVsbFVuaWNvZGUpO1xuICAgIH1cblxuICAgIHZhciBhY2N1bXVsYXRlZFJlc3VsdCA9ICcnO1xuICAgIHZhciBuZXh0U291cmNlUG9zaXRpb24gPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgICAgdmFyIG1hdGNoZWQgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IG1heChtaW4odG9JbnRlZ2VyKHJlc3VsdC5pbmRleCksIFMubGVuZ3RoKSwgMCk7XG4gICAgICB2YXIgY2FwdHVyZXMgPSBbXTsgLy8gTk9URTogVGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAvLyAgIGNhcHR1cmVzID0gcmVzdWx0LnNsaWNlKDEpLm1hcChtYXliZVRvU3RyaW5nKVxuICAgICAgLy8gYnV0IGZvciBzb21lIHJlYXNvbiBgbmF0aXZlU2xpY2UuY2FsbChyZXN1bHQsIDEsIHJlc3VsdC5sZW5ndGgpYCAoY2FsbGVkIGluXG4gICAgICAvLyB0aGUgc2xpY2UgcG9seWZpbGwgd2hlbiBzbGljaW5nIG5hdGl2ZSBhcnJheXMpIFwiZG9lc24ndCB3b3JrXCIgaW4gc2FmYXJpIDkgYW5kXG4gICAgICAvLyBjYXVzZXMgYSBjcmFzaCAoaHR0cHM6Ly9wYXN0ZWJpbi5jb20vTjIxUXplUUEpIHdoZW4gdHJ5aW5nIHRvIGRlYnVnIGl0LlxuXG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykgY2FwdHVyZXMucHVzaChtYXliZVRvU3RyaW5nKHJlc3VsdFtqXSkpO1xuXG4gICAgICB2YXIgbmFtZWRDYXB0dXJlcyA9IHJlc3VsdC5ncm91cHM7XG5cbiAgICAgIGlmIChmdW5jdGlvbmFsUmVwbGFjZSkge1xuICAgICAgICB2YXIgcmVwbGFjZXJBcmdzID0gW21hdGNoZWRdLmNvbmNhdChjYXB0dXJlcywgcG9zaXRpb24sIFMpO1xuICAgICAgICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSByZXBsYWNlckFyZ3MucHVzaChuYW1lZENhcHR1cmVzKTtcbiAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gU3RyaW5nKHJlcGxhY2VWYWx1ZS5hcHBseSh1bmRlZmluZWQsIHJlcGxhY2VyQXJncykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgUywgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zaXRpb24gPj0gbmV4dFNvdXJjZVBvc2l0aW9uKSB7XG4gICAgICAgIGFjY3VtdWxhdGVkUmVzdWx0ICs9IFMuc2xpY2UobmV4dFNvdXJjZVBvc2l0aW9uLCBwb3NpdGlvbikgKyByZXBsYWNlbWVudDtcbiAgICAgICAgbmV4dFNvdXJjZVBvc2l0aW9uID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWNjdW11bGF0ZWRSZXN1bHQgKyBTLnNsaWNlKG5leHRTb3VyY2VQb3NpdGlvbik7XG4gIH1dOyAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZXRzdWJzdGl0dXRpb25cblxuICBmdW5jdGlvbiBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgc3RyLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VtZW50KSB7XG4gICAgdmFyIHRhaWxQb3MgPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICAgIHZhciBtID0gY2FwdHVyZXMubGVuZ3RoO1xuICAgIHZhciBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQ7XG5cbiAgICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBuYW1lZENhcHR1cmVzID0gdG9PYmplY3QobmFtZWRDYXB0dXJlcyk7XG4gICAgICBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFM7XG4gICAgfVxuXG4gICAgcmV0dXJuICRyZXBsYWNlLmNhbGwocmVwbGFjZW1lbnQsIHN5bWJvbHMsIGZ1bmN0aW9uIChtYXRjaCwgY2gpIHtcbiAgICAgIHZhciBjYXB0dXJlO1xuXG4gICAgICBzd2l0Y2ggKGNoLmNoYXJBdCgwKSkge1xuICAgICAgICBjYXNlICckJzpcbiAgICAgICAgICByZXR1cm4gJyQnO1xuXG4gICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgIHJldHVybiBtYXRjaGVkO1xuXG4gICAgICAgIGNhc2UgJ2AnOlxuICAgICAgICAgIHJldHVybiBzdHIuc2xpY2UoMCwgcG9zaXRpb24pO1xuXG4gICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgcmV0dXJuIHN0ci5zbGljZSh0YWlsUG9zKTtcblxuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBjYXB0dXJlID0gbmFtZWRDYXB0dXJlc1tjaC5zbGljZSgxLCAtMSldO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gXFxkXFxkP1xuICAgICAgICAgIHZhciBuID0gK2NoO1xuICAgICAgICAgIGlmIChuID09PSAwKSByZXR1cm4gbWF0Y2g7XG5cbiAgICAgICAgICBpZiAobiA+IG0pIHtcbiAgICAgICAgICAgIHZhciBmID0gZmxvb3IobiAvIDEwKTtcbiAgICAgICAgICAgIGlmIChmID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgICBpZiAoZiA8PSBtKSByZXR1cm4gY2FwdHVyZXNbZiAtIDFdID09PSB1bmRlZmluZWQgPyBjaC5jaGFyQXQoMSkgOiBjYXB0dXJlc1tmIC0gMV0gKyBjaC5jaGFyQXQoMSk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FwdHVyZSA9IGNhcHR1cmVzW24gLSAxXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhcHR1cmUgPT09IHVuZGVmaW5lZCA/ICcnIDogY2FwdHVyZTtcbiAgICB9KTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIHNhbWVWYWx1ZSA9IHJlcXVpcmUoJy4vX3NhbWUtdmFsdWUnKTtcblxudmFyIHJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYy1hYnN0cmFjdCcpOyAvLyBAQHNlYXJjaCBsb2dpY1xuXG5cbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc2VhcmNoJywgMSwgZnVuY3Rpb24gKGRlZmluZWQsIFNFQVJDSCwgJHNlYXJjaCwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHJldHVybiBbLy8gYFN0cmluZy5wcm90b3R5cGUuc2VhcmNoYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zZWFyY2hcbiAgZnVuY3Rpb24gc2VhcmNoKHJlZ2V4cCkge1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW1NFQVJDSF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbU0VBUkNIXShTdHJpbmcoTykpO1xuICB9LCAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF1gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAc2VhcmNoXG4gIGZ1bmN0aW9uIChyZWdleHApIHtcbiAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKCRzZWFyY2gsIHJlZ2V4cCwgdGhpcyk7XG4gICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG4gICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgdmFyIHByZXZpb3VzTGFzdEluZGV4ID0gcngubGFzdEluZGV4O1xuICAgIGlmICghc2FtZVZhbHVlKHByZXZpb3VzTGFzdEluZGV4LCAwKSkgcngubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgaWYgKCFzYW1lVmFsdWUocngubGFzdEluZGV4LCBwcmV2aW91c0xhc3RJbmRleCkpIHJ4Lmxhc3RJbmRleCA9IHByZXZpb3VzTGFzdEluZGV4O1xuICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgPyAtMSA6IHJlc3VsdC5pbmRleDtcbiAgfV07XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcblxudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IHJlcXVpcmUoJy4vX2FkdmFuY2Utc3RyaW5nLWluZGV4Jyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG52YXIgY2FsbFJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xuXG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjJyk7XG5cbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbnZhciAkbWluID0gTWF0aC5taW47XG52YXIgJHB1c2ggPSBbXS5wdXNoO1xudmFyICRTUExJVCA9ICdzcGxpdCc7XG52YXIgTEVOR1RIID0gJ2xlbmd0aCc7XG52YXIgTEFTVF9JTkRFWCA9ICdsYXN0SW5kZXgnO1xudmFyIE1BWF9VSU5UMzIgPSAweGZmZmZmZmZmOyAvLyBiYWJlbC1taW5pZnkgdHJhbnNwaWxlcyBSZWdFeHAoJ3gnLCAneScpIC0+IC94L3kgYW5kIGl0IGNhdXNlcyBTeW50YXhFcnJvclxuXG52YXIgU1VQUE9SVFNfWSA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIFJlZ0V4cChNQVhfVUlOVDMyLCAneScpO1xufSk7IC8vIEBAc3BsaXQgbG9naWNcblxucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzcGxpdCcsIDIsIGZ1bmN0aW9uIChkZWZpbmVkLCBTUExJVCwgJHNwbGl0LCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgdmFyIGludGVybmFsU3BsaXQ7XG5cbiAgaWYgKCdhYmJjJ1skU1BMSVRdKC8oYikqLylbMV0gPT0gJ2MnIHx8ICd0ZXN0J1skU1BMSVRdKC8oPzopLywgLTEpW0xFTkdUSF0gIT0gNCB8fCAnYWInWyRTUExJVF0oLyg/OmFiKSovKVtMRU5HVEhdICE9IDIgfHwgJy4nWyRTUExJVF0oLyguPykoLj8pLylbTEVOR1RIXSAhPSA0IHx8ICcuJ1skU1BMSVRdKC8oKSgpLylbTEVOR1RIXSA+IDEgfHwgJydbJFNQTElUXSgvLj8vKVtMRU5HVEhdKSB7XG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwKSByZXR1cm4gW107IC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG5cbiAgICAgIGlmICghaXNSZWdFeHAoc2VwYXJhdG9yKSkgcmV0dXJuICRzcGxpdC5jYWxsKHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICB2YXIgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgKyAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpO1xuICAgICAgdmFyIGxhc3RMYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIHNwbGl0TGltaXQgPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX1VJTlQzMiA6IGxpbWl0ID4+PiAwOyAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuXG4gICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgdmFyIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG5cbiAgICAgIHdoaWxlIChtYXRjaCA9IHJlZ2V4cEV4ZWMuY2FsbChzZXBhcmF0b3JDb3B5LCBzdHJpbmcpKSB7XG4gICAgICAgIGxhc3RJbmRleCA9IHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF07XG5cbiAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICBpZiAobWF0Y2hbTEVOR1RIXSA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmdbTEVOR1RIXSkgJHB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZiAob3V0cHV0W0xFTkdUSF0gPj0gc3BsaXRMaW1pdCkgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSA9PT0gbWF0Y2guaW5kZXgpIHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0rKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuXG4gICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nW0xFTkdUSF0pIHtcbiAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgIH0gZWxzZSBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuXG4gICAgICByZXR1cm4gb3V0cHV0W0xFTkdUSF0gPiBzcGxpdExpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgIH07IC8vIENoYWtyYSwgVjhcblxuICB9IGVsc2UgaWYgKCcwJ1skU1BMSVRdKHVuZGVmaW5lZCwgMClbTEVOR1RIXSkge1xuICAgIGludGVybmFsU3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiAkc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGludGVybmFsU3BsaXQgPSAkc3BsaXQ7XG4gIH1cblxuICByZXR1cm4gWy8vIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zcGxpdFxuICBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBzcGxpdHRlciA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgIHJldHVybiBzcGxpdHRlciAhPT0gdW5kZWZpbmVkID8gc3BsaXR0ZXIuY2FsbChzZXBhcmF0b3IsIE8sIGxpbWl0KSA6IGludGVybmFsU3BsaXQuY2FsbChTdHJpbmcoTyksIHNlcGFyYXRvciwgbGltaXQpO1xuICB9LCAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBzcGxpdFxuICAvL1xuICAvLyBOT1RFOiBUaGlzIGNhbm5vdCBiZSBwcm9wZXJseSBwb2x5ZmlsbGVkIGluIGVuZ2luZXMgdGhhdCBkb24ndCBzdXBwb3J0XG4gIC8vIHRoZSAneScgZmxhZy5cbiAgZnVuY3Rpb24gKHJlZ2V4cCwgbGltaXQpIHtcbiAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKGludGVybmFsU3BsaXQsIHJlZ2V4cCwgdGhpcywgbGltaXQsIGludGVybmFsU3BsaXQgIT09ICRzcGxpdCk7XG4gICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG4gICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IocngsIFJlZ0V4cCk7XG4gICAgdmFyIHVuaWNvZGVNYXRjaGluZyA9IHJ4LnVuaWNvZGU7XG4gICAgdmFyIGZsYWdzID0gKHJ4Lmlnbm9yZUNhc2UgPyAnaScgOiAnJykgKyAocngubXVsdGlsaW5lID8gJ20nIDogJycpICsgKHJ4LnVuaWNvZGUgPyAndScgOiAnJykgKyAoU1VQUE9SVFNfWSA/ICd5JyA6ICdnJyk7IC8vIF4oPyArIHJ4ICsgKSBpcyBuZWVkZWQsIGluIGNvbWJpbmF0aW9uIHdpdGggc29tZSBTIHNsaWNpbmcsIHRvXG4gICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuXG4gICAgdmFyIHNwbGl0dGVyID0gbmV3IEMoU1VQUE9SVFNfWSA/IHJ4IDogJ14oPzonICsgcnguc291cmNlICsgJyknLCBmbGFncyk7XG4gICAgdmFyIGxpbSA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfVUlOVDMyIDogbGltaXQgPj4+IDA7XG4gICAgaWYgKGxpbSA9PT0gMCkgcmV0dXJuIFtdO1xuICAgIGlmIChTLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTKSA9PT0gbnVsbCA/IFtTXSA6IFtdO1xuICAgIHZhciBwID0gMDtcbiAgICB2YXIgcSA9IDA7XG4gICAgdmFyIEEgPSBbXTtcblxuICAgIHdoaWxlIChxIDwgUy5sZW5ndGgpIHtcbiAgICAgIHNwbGl0dGVyLmxhc3RJbmRleCA9IFNVUFBPUlRTX1kgPyBxIDogMDtcbiAgICAgIHZhciB6ID0gY2FsbFJlZ0V4cEV4ZWMoc3BsaXR0ZXIsIFNVUFBPUlRTX1kgPyBTIDogUy5zbGljZShxKSk7XG4gICAgICB2YXIgZTtcblxuICAgICAgaWYgKHogPT09IG51bGwgfHwgKGUgPSAkbWluKHRvTGVuZ3RoKHNwbGl0dGVyLmxhc3RJbmRleCArIChTVVBQT1JUU19ZID8gMCA6IHEpKSwgUy5sZW5ndGgpKSA9PT0gcCkge1xuICAgICAgICBxID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHEsIHVuaWNvZGVNYXRjaGluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBBLnB1c2goUy5zbGljZShwLCBxKSk7XG4gICAgICAgIGlmIChBLmxlbmd0aCA9PT0gbGltKSByZXR1cm4gQTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSB6Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIEEucHVzaCh6W2ldKTtcbiAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgIH1cblxuICAgICAgICBxID0gcCA9IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgQS5wdXNoKFMuc2xpY2UocCkpO1xuICAgIHJldHVybiBBO1xuICB9XTtcbn0pOyIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9lczYucmVnZXhwLmZsYWdzJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgJGZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcblxudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcblxudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gLy4vW1RPX1NUUklOR107XG5cbnZhciBkZWZpbmUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZuLCB0cnVlKTtcbn07IC8vIDIxLjIuNS4xNCBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nKClcblxuXG5pZiAocmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbCh7XG4gICAgc291cmNlOiAnYScsXG4gICAgZmxhZ3M6ICdiJ1xuICB9KSAhPSAnL2EvYic7XG59KSkge1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcbiAgICByZXR1cm4gJy8nLmNvbmNhdChSLnNvdXJjZSwgJy8nLCAnZmxhZ3MnIGluIFIgPyBSLmZsYWdzIDogIURFU0NSSVBUT1JTICYmIFIgaW5zdGFuY2VvZiBSZWdFeHAgPyAkZmxhZ3MuY2FsbChSKSA6IHVuZGVmaW5lZCk7XG4gIH0pOyAvLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxufSBlbHNlIGlmICgkdG9TdHJpbmcubmFtZSAhPSBUT19TVFJJTkcpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgfSk7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcblxudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xuXG52YXIgU0VUID0gJ1NldCc7IC8vIDIzLjIgU2V0IE9iamVjdHNcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59LCB7XG4gIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHZhbGlkYXRlKHRoaXMsIFNFVCksIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTsiLCIndXNlIHN0cmljdCc7IC8vIEIuMi4zLjIgU3RyaW5nLnByb3RvdHlwZS5hbmNob3IobmFtZSlcblxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYW5jaG9yJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFuY2hvcihuYW1lKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnbmFtZScsIG5hbWUpO1xuICB9O1xufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBCLjIuMy4zIFN0cmluZy5wcm90b3R5cGUuYmlnKClcblxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmlnJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJpZygpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmlnJywgJycsICcnKTtcbiAgfTtcbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gQi4yLjMuNCBTdHJpbmcucHJvdG90eXBlLmJsaW5rKClcblxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmxpbmsnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gYmxpbmsoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2JsaW5rJywgJycsICcnKTtcbiAgfTtcbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gQi4yLjMuNSBTdHJpbmcucHJvdG90eXBlLmJvbGQoKVxuXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdib2xkJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJvbGQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2InLCAnJywgJycpO1xuICB9O1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykoZmFsc2UpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjMgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdChwb3MpXG4gIGNvZGVQb2ludEF0OiBmdW5jdGlvbiBjb2RlUG9pbnRBdChwb3MpIHtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pOyIsIi8vIDIxLjEuMy42IFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgoc2VhcmNoU3RyaW5nIFssIGVuZFBvc2l0aW9uXSlcbid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcblxudmFyIEVORFNfV0lUSCA9ICdlbmRzV2l0aCc7XG52YXIgJGVuZHNXaXRoID0gJydbRU5EU19XSVRIXTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoRU5EU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgZW5kc1dpdGg6IGZ1bmN0aW9uIGVuZHNXaXRoKHNlYXJjaFN0cmluZ1xuICAvKiAsIGVuZFBvc2l0aW9uID0gQGxlbmd0aCAqL1xuICApIHtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBFTkRTX1dJVEgpO1xuICAgIHZhciBlbmRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aCk7XG4gICAgdmFyIGVuZCA9IGVuZFBvc2l0aW9uID09PSB1bmRlZmluZWQgPyBsZW4gOiBNYXRoLm1pbih0b0xlbmd0aChlbmRQb3NpdGlvbiksIGxlbik7XG4gICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkZW5kc1dpdGggPyAkZW5kc1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGVuZCkgOiB0aGF0LnNsaWNlKGVuZCAtIHNlYXJjaC5sZW5ndGgsIGVuZCkgPT09IHNlYXJjaDtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBCLjIuMy42IFN0cmluZy5wcm90b3R5cGUuZml4ZWQoKVxuXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmaXhlZCcsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmaXhlZCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAndHQnLCAnJywgJycpO1xuICB9O1xufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBCLjIuMy43IFN0cmluZy5wcm90b3R5cGUuZm9udGNvbG9yKGNvbG9yKVxuXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250Y29sb3InLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9udGNvbG9yKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnY29sb3InLCBjb2xvcik7XG4gIH07XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIEIuMi4zLjggU3RyaW5nLnByb3RvdHlwZS5mb250c2l6ZShzaXplKVxuXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250c2l6ZScsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb250c2l6ZShzaXplKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnc2l6ZScsIHNpemUpO1xuICB9O1xufSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5cbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyICRmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7IC8vIGxlbmd0aCBzaG91bGQgYmUgMSwgb2xkIEZGIHByb2JsZW1cblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoISEkZnJvbUNvZGVQb2ludCAmJiAkZnJvbUNvZGVQb2ludC5sZW5ndGggIT0gMSksICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi4yIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNvZGVQb2ludHMpXG4gIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoeCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgY29kZTtcblxuICAgIHdoaWxlIChhTGVuID4gaSkge1xuICAgICAgY29kZSA9ICthcmd1bWVudHNbaSsrXTtcbiAgICAgIGlmICh0b0Fic29sdXRlSW5kZXgoY29kZSwgMHgxMGZmZmYpICE9PSBjb2RlKSB0aHJvdyBSYW5nZUVycm9yKGNvZGUgKyAnIGlzIG5vdCBhIHZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICAgIHJlcy5wdXNoKGNvZGUgPCAweDEwMDAwID8gZnJvbUNoYXJDb2RlKGNvZGUpIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweGQ4MDAsIGNvZGUgJSAweDQwMCArIDB4ZGMwMCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pOyIsIi8vIDIxLjEuMy43IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApXG4ndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcblxudmFyIElOQ0xVREVTID0gJ2luY2x1ZGVzJztcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoSU5DTFVERVMpLCAnU3RyaW5nJywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nXG4gIC8qICwgcG9zaXRpb24gPSAwICovXG4gICkge1xuICAgIHJldHVybiAhIX5jb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgSU5DTFVERVMpLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gQi4yLjMuOSBTdHJpbmcucHJvdG90eXBlLml0YWxpY3MoKVxuXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdpdGFsaWNzJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGl0YWxpY3MoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2knLCAnJywgJycpO1xuICB9O1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7IC8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcblxuXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG5cbiAgdGhpcy5faSA9IDA7IC8vIG5leHQgaW5kZXhcbiAgLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4ge1xuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgZG9uZTogdHJ1ZVxuICB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiBwb2ludCxcbiAgICBkb25lOiBmYWxzZVxuICB9O1xufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBCLjIuMy4xMCBTdHJpbmcucHJvdG90eXBlLmxpbmsodXJsKVxuXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdsaW5rJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGxpbmsodXJsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnaHJlZicsIHVybCk7XG4gIH07XG59KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi40IFN0cmluZy5yYXcoY2FsbFNpdGUsIC4uLnN1YnN0aXR1dGlvbnMpXG4gIHJhdzogZnVuY3Rpb24gcmF3KGNhbGxTaXRlKSB7XG4gICAgdmFyIHRwbCA9IHRvSU9iamVjdChjYWxsU2l0ZS5yYXcpO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aCh0cGwubGVuZ3RoKTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChsZW4gPiBpKSB7XG4gICAgICByZXMucHVzaChTdHJpbmcodHBsW2krK10pKTtcbiAgICAgIGlmIChpIDwgYUxlbikgcmVzLnB1c2goU3RyaW5nKGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQoY291bnQpXG4gIHJlcGVhdDogcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpXG59KTsiLCIndXNlIHN0cmljdCc7IC8vIEIuMi4zLjExIFN0cmluZy5wcm90b3R5cGUuc21hbGwoKVxuXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzbWFsbCcsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzbWFsbCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc21hbGwnLCAnJywgJycpO1xuICB9O1xufSk7IiwiLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcbid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbnZhciBjb250ZXh0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKTtcblxudmFyIFNUQVJUU19XSVRIID0gJ3N0YXJ0c1dpdGgnO1xudmFyICRzdGFydHNXaXRoID0gJydbU1RBUlRTX1dJVEhdO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShTVEFSVFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nXG4gIC8qICwgcG9zaXRpb24gPSAwICovXG4gICkge1xuICAgIHZhciB0aGF0ID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIFNUQVJUU19XSVRIKTtcbiAgICB2YXIgaW5kZXggPSB0b0xlbmd0aChNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdGhhdC5sZW5ndGgpKTtcbiAgICB2YXIgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuICRzdGFydHNXaXRoID8gJHN0YXJ0c1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGluZGV4KSA6IHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBCLjIuMy4xMiBTdHJpbmcucHJvdG90eXBlLnN0cmlrZSgpXG5cbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N0cmlrZScsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdHJpa2UoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N0cmlrZScsICcnLCAnJyk7XG4gIH07XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIEIuMi4zLjEzIFN0cmluZy5wcm90b3R5cGUuc3ViKClcblxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3ViJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1YigpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3ViJywgJycsICcnKTtcbiAgfTtcbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gQi4yLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5zdXAoKVxuXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdXAnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc3VwKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdXAnLCAnJywgJycpO1xuICB9O1xufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyAyMS4xLjMuMjUgU3RyaW5nLnByb3RvdHlwZS50cmltKClcblxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbScsIGZ1bmN0aW9uICgkdHJpbSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbSgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMyk7XG4gIH07XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG5cbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5cbnZhciBNRVRBID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWTtcblxudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKTtcblxudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcblxudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xuXG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG5cbnZhciB3a3NEZWZpbmUgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJyk7XG5cbnZhciBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpO1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxudmFyIF9jcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG5cbnZhciBnT1BORXh0ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0Jyk7XG5cbnZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG5cbnZhciAkR09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG5cbnZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xuXG52YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTtcblxudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIEhJRERFTiA9IHdrcygnX2hpZGRlbicpO1xudmFyIFRPX1BSSU1JVElWRSA9IHdrcygndG9QcmltaXRpdmUnKTtcbnZhciBpc0VudW0gPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9QU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgVVNFX05BVElWRSA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbicgJiYgISEkR09QUy5mO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDsgLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG5cbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkOyAvLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcblxudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZFAodGhpcywgJ2EnLCB7XG4gICAgICAgIHZhbHVlOiA3XG4gICAgICB9KS5hO1xuICAgIH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuXG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG5cbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFELmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzKGl0LCBISURERU4pKSBkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7XG4gICAgICAgIGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfVxuXG4gIHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApIHtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIHZhciBrZXk7XG5cbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcblxuICByZXR1cm4gaXQ7XG59O1xuXG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCkge1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcblxuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvO1xuICB2YXIgbmFtZXMgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59OyAvLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcblxuXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuXG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90bykgJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKSBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogJHNldFxuICAgIH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG5cbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICAkR09QUy5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtcbiAgU3ltYm9sOiAkU3ltYm9sXG59KTtcblxuZm9yICh2YXIgZXM2U3ltYm9scyA9IC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4naGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KSB3a3MoZXM2U3ltYm9sc1tqKytdKTtcblxuZm9yICh2YXIgd2VsbEtub3duU3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGsgPSAwOyB3ZWxsS25vd25TeW1ib2xzLmxlbmd0aCA+IGs7KSB3a3NEZWZpbmUod2VsbEtub3duU3ltYm9sc1trKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKSA/IFN5bWJvbFJlZ2lzdHJ5W2tleV0gOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gU3ltYm9sUmVnaXN0cnkpIGlmIChTeW1ib2xSZWdpc3RyeVtrZXldID09PSBzeW0pIHJldHVybiBrZXk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkge1xuICAgIHNldHRlciA9IHRydWU7XG4gIH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkge1xuICAgIHNldHRlciA9IGZhbHNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pOyAvLyBDaHJvbWUgMzggYW5kIDM5IGBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzYCBmYWlscyBvbiBwcmltaXRpdmVzXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNDQzXG5cbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgJEdPUFMuZigxKTtcbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBGQUlMU19PTl9QUklNSVRJVkVTLCAnT2JqZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICAgIHJldHVybiAkR09QUy5mKHRvT2JqZWN0KGl0KSk7XG4gIH1cbn0pOyAvLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcblxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7IC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7XG4gICAgYTogU1xuICB9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHtcbiAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciByZXBsYWNlciwgJHJlcGxhY2VyO1xuXG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuXG4gICAgJHJlcGxhY2VyID0gcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcblxuICAgIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgJHJlcGxhY2VyID09ICdmdW5jdGlvbicpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7IC8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcblxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7IC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cblxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpOyAvLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7IC8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICR0eXBlZCA9IHJlcXVpcmUoJy4vX3R5cGVkJyk7XG5cbnZhciBidWZmZXIgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciBBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLkFycmF5QnVmZmVyO1xuXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG52YXIgJEFycmF5QnVmZmVyID0gYnVmZmVyLkFycmF5QnVmZmVyO1xudmFyICREYXRhVmlldyA9IGJ1ZmZlci5EYXRhVmlldztcbnZhciAkaXNWaWV3ID0gJHR5cGVkLkFCViAmJiBBcnJheUJ1ZmZlci5pc1ZpZXc7XG52YXIgJHNsaWNlID0gJEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZTtcbnZhciBWSUVXID0gJHR5cGVkLlZJRVc7XG52YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEFycmF5QnVmZmVyICE9PSAkQXJyYXlCdWZmZXIpLCB7XG4gIEFycmF5QnVmZmVyOiAkQXJyYXlCdWZmZXJcbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhJHR5cGVkLkNPTlNUUiwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuMy4xIEFycmF5QnVmZmVyLmlzVmlldyhhcmcpXG4gIGlzVmlldzogZnVuY3Rpb24gaXNWaWV3KGl0KSB7XG4gICAgcmV0dXJuICRpc1ZpZXcgJiYgJGlzVmlldyhpdCkgfHwgaXNPYmplY3QoaXQpICYmIFZJRVcgaW4gaXQ7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlUgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFuZXcgJEFycmF5QnVmZmVyKDIpLnNsaWNlKDEsIHVuZGVmaW5lZCkuYnl0ZUxlbmd0aDtcbn0pLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS40LjMgQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgaWYgKCRzbGljZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJHNsaWNlLmNhbGwoYW5PYmplY3QodGhpcyksIHN0YXJ0KTsgLy8gRkYgZml4XG5cbiAgICB2YXIgbGVuID0gYW5PYmplY3QodGhpcykuYnl0ZUxlbmd0aDtcbiAgICB2YXIgZmlyc3QgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gICAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZCwgbGVuKTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJEFycmF5QnVmZmVyKSkodG9MZW5ndGgoZmluIC0gZmlyc3QpKTtcbiAgICB2YXIgdmlld1MgPSBuZXcgJERhdGFWaWV3KHRoaXMpO1xuICAgIHZhciB2aWV3VCA9IG5ldyAkRGF0YVZpZXcocmVzdWx0KTtcbiAgICB2YXIgaW5kZXggPSAwO1xuXG4gICAgd2hpbGUgKGZpcnN0IDwgZmluKSB7XG4gICAgICB2aWV3VC5zZXRVaW50OChpbmRleCsrLCB2aWV3Uy5nZXRVaW50OChmaXJzdCsrKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoQVJSQVlfQlVGRkVSKTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL190eXBlZCcpLkFCViwge1xuICBEYXRhVmlldzogcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJykuRGF0YVZpZXdcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDY0JywgOCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0NjRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MTYnLCAyLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQxNicsIDIsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OENsYW1wZWRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSwgdHJ1ZSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciBlYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xuXG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xuXG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKTtcblxudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcblxudmFyIE5BVElWRV9XRUFLX01BUCA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcblxudmFyIElTX0lFMTEgPSAhZ2xvYmFsLkFjdGl2ZVhPYmplY3QgJiYgJ0FjdGl2ZVhPYmplY3QnIGluIGdsb2JhbDtcbnZhciBXRUFLX01BUCA9ICdXZWFrTWFwJztcbnZhciBnZXRXZWFrID0gbWV0YS5nZXRXZWFrO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IHdlYWsudWZzdG9yZTtcbnZhciBJbnRlcm5hbE1hcDtcblxudmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCkge1xuICAgIHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufTtcblxudmFyIG1ldGhvZHMgPSB7XG4gIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCkpLmdldChrZXkpO1xuICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3RoaXMuX2ldIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gd2Vhay5kZWYodmFsaWRhdGUodGhpcywgV0VBS19NQVApLCBrZXksIHZhbHVlKTtcbiAgfVxufTsgLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcblxudmFyICRXZWFrTWFwID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoV0VBS19NQVAsIHdyYXBwZXIsIG1ldGhvZHMsIHdlYWssIHRydWUsIHRydWUpOyAvLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XG5cblxuaWYgKE5BVElWRV9XRUFLX01BUCAmJiBJU19JRTExKSB7XG4gIEludGVybmFsTWFwID0gd2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBXRUFLX01BUCk7XG4gIGFzc2lnbihJbnRlcm5hbE1hcC5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICBtZXRhLk5FRUQgPSB0cnVlO1xuICBlYWNoKFsnZGVsZXRlJywgJ2hhcycsICdnZXQnLCAnc2V0J10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcHJvdG8gPSAkV2Vha01hcC5wcm90b3R5cGU7XG4gICAgdmFyIG1ldGhvZCA9IHByb3RvW2tleV07XG4gICAgcmVkZWZpbmUocHJvdG8sIGtleSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGludGVybmFsIHdlYWttYXAgc2hpbVxuICAgICAgaWYgKGlzT2JqZWN0KGEpICYmICFpc0V4dGVuc2libGUoYSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mKSB0aGlzLl9mID0gbmV3IEludGVybmFsTWFwKCk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Zba2V5XShhLCBiKTtcblxuICAgICAgICByZXR1cm4ga2V5ID09ICdzZXQnID8gdGhpcyA6IHJlc3VsdDsgLy8gc3RvcmUgYWxsIHRoZSByZXN0IG9uIG5hdGl2ZSB3ZWFrbWFwXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXRob2QuY2FsbCh0aGlzLCBhLCBiKTtcbiAgICB9KTtcbiAgfSk7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xuXG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG5cbnZhciBXRUFLX1NFVCA9ICdXZWFrU2V0JzsgLy8gMjMuNCBXZWFrU2V0IE9iamVjdHNcblxucmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFdFQUtfU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrU2V0KCkge1xuICAgIHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufSwge1xuICAvLyAyMy40LjMuMSBXZWFrU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHZhbGlkYXRlKHRoaXMsIFdFQUtfU0VUKSwgdmFsdWUsIHRydWUpO1xuICB9XG59LCB3ZWFrLCBmYWxzZSwgdHJ1ZSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLWZsYXRNYXAvI3NlYy1BcnJheS5wcm90b3R5cGUuZmxhdE1hcFxuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgZmxhdHRlbkludG9BcnJheSA9IHJlcXVpcmUoJy4vX2ZsYXR0ZW4taW50by1hcnJheScpO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBmbGF0TWFwOiBmdW5jdGlvbiBmbGF0TWFwKGNhbGxiYWNrZm5cbiAgLyogLCB0aGlzQXJnICovXG4gICkge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIHNvdXJjZUxlbiwgQTtcbiAgICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gICAgc291cmNlTGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7XG4gICAgZmxhdHRlbkludG9BcnJheShBLCBPLCBPLCBzb3VyY2VMZW4sIDAsIDEsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnZmxhdE1hcCcpOyIsIid1c2Ugc3RyaWN0JzsgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1mbGF0TWFwLyNzZWMtQXJyYXkucHJvdG90eXBlLmZsYXR0ZW5cblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGZsYXR0ZW5JbnRvQXJyYXkgPSByZXF1aXJlKCcuL19mbGF0dGVuLWludG8tYXJyYXknKTtcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xuXG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgZmxhdHRlbjogZnVuY3Rpb24gZmxhdHRlbigpXG4gIC8qIGRlcHRoQXJnID0gMSAqL1xuICB7XG4gICAgdmFyIGRlcHRoQXJnID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIHNvdXJjZUxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCAwKTtcbiAgICBmbGF0dGVuSW50b0FycmF5KEEsIE8sIE8sIHNvdXJjZUxlbiwgMCwgZGVwdGhBcmcgPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGhBcmcpKTtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmbGF0dGVuJyk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9BcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRpbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbFxuICAvKiAsIGZyb21JbmRleCA9IDAgKi9cbiAgKSB7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2luY2x1ZGVzJyk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3J3YWxkcm9uL3RjMzktbm90ZXMvYmxvYi9tYXN0ZXIvZXM2LzIwMTQtMDkvc2VwdC0yNS5tZCM1MTAtZ2xvYmFsYXNhcC1mb3ItZW5xdWV1aW5nLWEtbWljcm90YXNrXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcblxudmFyIHByb2Nlc3MgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wcm9jZXNzO1xuXG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuJGV4cG9ydCgkZXhwb3J0LkcsIHtcbiAgYXNhcDogZnVuY3Rpb24gYXNhcChmbikge1xuICAgIHZhciBkb21haW4gPSBpc05vZGUgJiYgcHJvY2Vzcy5kb21haW47XG4gICAgbWljcm90YXNrKGRvbWFpbiA/IGRvbWFpbi5iaW5kKGZuKSA6IGZuKTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9wcm9wb3NhbC1pcy1lcnJvclxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0Vycm9yJywge1xuICBpc0Vycm9yOiBmdW5jdGlvbiBpc0Vycm9yKGl0KSB7XG4gICAgcmV0dXJuIGNvZihpdCkgPT09ICdFcnJvcic7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHtcbiAgZ2xvYmFsOiByZXF1aXJlKCcuL19nbG9iYWwnKVxufSk7IiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtbWFwLmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnTWFwJyk7IiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtbWFwLm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdNYXAnKTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ01hcCcsIHtcbiAgdG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnTWFwJylcbn0pOyIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2xhbXA6IGZ1bmN0aW9uIGNsYW1wKHgsIGxvd2VyLCB1cHBlcikge1xuICAgIHJldHVybiBNYXRoLm1pbih1cHBlciwgTWF0aC5tYXgobG93ZXIsIHgpKTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBERUdfUEVSX1JBRDogTWF0aC5QSSAvIDE4MFxufSk7IiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIFJBRF9QRVJfREVHID0gMTgwIC8gTWF0aC5QSTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgZGVncmVlczogZnVuY3Rpb24gZGVncmVlcyhyYWRpYW5zKSB7XG4gICAgcmV0dXJuIHJhZGlhbnMgKiBSQURfUEVSX0RFRztcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHNjYWxlID0gcmVxdWlyZSgnLi9fbWF0aC1zY2FsZScpO1xuXG52YXIgZnJvdW5kID0gcmVxdWlyZSgnLi9fbWF0aC1mcm91bmQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBmc2NhbGU6IGZ1bmN0aW9uIGZzY2FsZSh4LCBpbkxvdywgaW5IaWdoLCBvdXRMb3csIG91dEhpZ2gpIHtcbiAgICByZXR1cm4gZnJvdW5kKHNjYWxlKHgsIGluTG93LCBpbkhpZ2gsIG91dExvdywgb3V0SGlnaCkpO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpYWRkaDogZnVuY3Rpb24gaWFkZGgoeDAsIHgxLCB5MCwgeTEpIHtcbiAgICB2YXIgJHgwID0geDAgPj4+IDA7XG4gICAgdmFyICR4MSA9IHgxID4+PiAwO1xuICAgIHZhciAkeTAgPSB5MCA+Pj4gMDtcbiAgICByZXR1cm4gJHgxICsgKHkxID4+PiAwKSArICgoJHgwICYgJHkwIHwgKCR4MCB8ICR5MCkgJiB+KCR4MCArICR5MCA+Pj4gMCkpID4+PiAzMSkgfCAwO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpbXVsaDogZnVuY3Rpb24gaW11bGgodSwgdikge1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmY7XG4gICAgdmFyICR1ID0gK3U7XG4gICAgdmFyICR2ID0gK3Y7XG4gICAgdmFyIHUwID0gJHUgJiBVSU5UMTY7XG4gICAgdmFyIHYwID0gJHYgJiBVSU5UMTY7XG4gICAgdmFyIHUxID0gJHUgPj4gMTY7XG4gICAgdmFyIHYxID0gJHYgPj4gMTY7XG4gICAgdmFyIHQgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4gMTYpICsgKCh1MCAqIHYxID4+PiAwKSArICh0ICYgVUlOVDE2KSA+PiAxNik7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlzdWJoOiBmdW5jdGlvbiBpc3ViaCh4MCwgeDEsIHkwLCB5MSkge1xuICAgIHZhciAkeDAgPSB4MCA+Pj4gMDtcbiAgICB2YXIgJHgxID0geDEgPj4+IDA7XG4gICAgdmFyICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgLSAoeTEgPj4+IDApIC0gKCh+JHgwICYgJHkwIHwgfigkeDAgXiAkeTApICYgJHgwIC0gJHkwID4+PiAwKSA+Pj4gMzEpIHwgMDtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBSQURfUEVSX0RFRzogMTgwIC8gTWF0aC5QSVxufSk7IiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIERFR19QRVJfUkFEID0gTWF0aC5QSSAvIDE4MDtcbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgcmFkaWFuczogZnVuY3Rpb24gcmFkaWFucyhkZWdyZWVzKSB7XG4gICAgcmV0dXJuIGRlZ3JlZXMgKiBERUdfUEVSX1JBRDtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBzY2FsZTogcmVxdWlyZSgnLi9fbWF0aC1zY2FsZScpXG59KTsiLCIvLyBodHRwOi8vamZiYXN0aWVuLmdpdGh1Yi5pby9wYXBlcnMvTWF0aC5zaWduYml0Lmh0bWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgc2lnbmJpdDogZnVuY3Rpb24gc2lnbmJpdCh4KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJldHVybiAoeCA9ICt4KSAhPSB4ID8geCA6IHggPT0gMCA/IDEgLyB4ID09IEluZmluaXR5IDogeCA+IDA7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHVtdWxoOiBmdW5jdGlvbiB1bXVsaCh1LCB2KSB7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZjtcbiAgICB2YXIgJHUgPSArdTtcbiAgICB2YXIgJHYgPSArdjtcbiAgICB2YXIgdTAgPSAkdSAmIFVJTlQxNjtcbiAgICB2YXIgdjAgPSAkdiAmIFVJTlQxNjtcbiAgICB2YXIgdTEgPSAkdSA+Pj4gMTY7XG4gICAgdmFyIHYxID0gJHYgPj4+IDE2O1xuICAgIHZhciB0ID0gKHUxICogdjAgPj4+IDApICsgKHUwICogdjAgPj4+IDE2KTtcbiAgICByZXR1cm4gdTEgKiB2MSArICh0ID4+PiAxNikgKyAoKHUwICogdjEgPj4+IDApICsgKHQgJiBVSU5UMTYpID4+PiAxNik7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTsgLy8gQi4yLjIuMiBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKVxuXG5cbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2RlZmluZUdldHRlcl9fOiBmdW5jdGlvbiBfX2RlZmluZUdldHRlcl9fKFAsIGdldHRlcikge1xuICAgICRkZWZpbmVQcm9wZXJ0eS5mKHRvT2JqZWN0KHRoaXMpLCBQLCB7XG4gICAgICBnZXQ6IGFGdW5jdGlvbihnZXR0ZXIpLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7IC8vIEIuMi4yLjMgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKFAsIHNldHRlcilcblxuXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19kZWZpbmVTZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVTZXR0ZXJfXyhQLCBzZXR0ZXIpIHtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwge1xuICAgICAgc2V0OiBhRnVuY3Rpb24oc2V0dGVyKSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJGVudHJpZXMgPSByZXF1aXJlKCcuL19vYmplY3QtdG8tYXJyYXknKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoaXQpIHtcbiAgICByZXR1cm4gJGVudHJpZXMoaXQpO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIG93bktleXMgPSByZXF1aXJlKCcuL19vd24ta2V5cycpO1xuXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG5cbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICAgIHZhciBnZXREZXNjID0gZ09QRC5mO1xuICAgIHZhciBrZXlzID0gb3duS2V5cyhPKTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXksIGRlc2M7XG5cbiAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiBpKSB7XG4gICAgICBkZXNjID0gZ2V0RGVzYyhPLCBrZXkgPSBrZXlzW2krK10pO1xuICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBrZXksIGRlc2MpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7IC8vIEIuMi4yLjQgT2JqZWN0LnByb3RvdHlwZS5fX2xvb2t1cEdldHRlcl9fKFApXG5cblxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fbG9va3VwR2V0dGVyX186IGZ1bmN0aW9uIF9fbG9va3VwR2V0dGVyX18oUCkge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIEsgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgICB2YXIgRDtcblxuICAgIGRvIHtcbiAgICAgIGlmIChEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKSByZXR1cm4gRC5nZXQ7XG4gICAgfSB3aGlsZSAoTyA9IGdldFByb3RvdHlwZU9mKE8pKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjsgLy8gQi4yLjIuNSBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwU2V0dGVyX18oUClcblxuXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19sb29rdXBTZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBTZXR0ZXJfXyhQKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgSyA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICAgIHZhciBEO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKEQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgSykpIHJldHVybiBELnNldDtcbiAgICB9IHdoaWxlIChPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkdmFsdWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykoZmFsc2UpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoaXQpIHtcbiAgICByZXR1cm4gJHZhbHVlcyhpdCk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xuXG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcblxudmFyIE9CU0VSVkFCTEUgPSByZXF1aXJlKCcuL193a3MnKSgnb2JzZXJ2YWJsZScpO1xuXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xuXG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcblxudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5cbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG52YXIgUkVUVVJOID0gZm9yT2YuUkVUVVJOO1xuXG52YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiA9PSBudWxsID8gdW5kZWZpbmVkIDogYUZ1bmN0aW9uKGZuKTtcbn07XG5cbnZhciBjbGVhbnVwU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICB2YXIgY2xlYW51cCA9IHN1YnNjcmlwdGlvbi5fYztcblxuICBpZiAoY2xlYW51cCkge1xuICAgIHN1YnNjcmlwdGlvbi5fYyA9IHVuZGVmaW5lZDtcbiAgICBjbGVhbnVwKCk7XG4gIH1cbn07XG5cbnZhciBzdWJzY3JpcHRpb25DbG9zZWQgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gIHJldHVybiBzdWJzY3JpcHRpb24uX28gPT09IHVuZGVmaW5lZDtcbn07XG5cbnZhciBjbG9zZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgaWYgKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSkge1xuICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcbiAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gIH1cbn07XG5cbnZhciBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHN1YnNjcmliZXIpIHtcbiAgYW5PYmplY3Qob2JzZXJ2ZXIpO1xuICB0aGlzLl9jID0gdW5kZWZpbmVkO1xuICB0aGlzLl9vID0gb2JzZXJ2ZXI7XG4gIG9ic2VydmVyID0gbmV3IFN1YnNjcmlwdGlvbk9ic2VydmVyKHRoaXMpO1xuXG4gIHRyeSB7XG4gICAgdmFyIGNsZWFudXAgPSBzdWJzY3JpYmVyKG9ic2VydmVyKTtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gY2xlYW51cDtcblxuICAgIGlmIChjbGVhbnVwICE9IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgY2xlYW51cC51bnN1YnNjcmliZSA9PT0gJ2Z1bmN0aW9uJykgY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9O2Vsc2UgYUZ1bmN0aW9uKGNsZWFudXApO1xuICAgICAgdGhpcy5fYyA9IGNsZWFudXA7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN1YnNjcmlwdGlvbkNsb3NlZCh0aGlzKSkgY2xlYW51cFN1YnNjcmlwdGlvbih0aGlzKTtcbn07XG5cblN1YnNjcmlwdGlvbi5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICB1bnN1YnNjcmliZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgY2xvc2VTdWJzY3JpcHRpb24odGhpcyk7XG4gIH1cbn0pO1xuXG52YXIgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gIHRoaXMuX3MgPSBzdWJzY3JpcHRpb247XG59O1xuXG5TdWJzY3JpcHRpb25PYnNlcnZlci5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICBuZXh0OiBmdW5jdGlvbiBuZXh0KHZhbHVlKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG5cbiAgICBpZiAoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKSB7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLm5leHQpO1xuICAgICAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsb3NlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKHZhbHVlKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYgKHN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKSB0aHJvdyB2YWx1ZTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmVycm9yKTtcbiAgICAgIGlmICghbSkgdGhyb3cgdmFsdWU7XG4gICAgICB2YWx1ZSA9IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHZhbHVlKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG5cbiAgICBpZiAoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKSB7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmNvbXBsZXRlKTtcbiAgICAgICAgdmFsdWUgPSBtID8gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSkgOiB1bmRlZmluZWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG5cbnZhciAkT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlcikge1xuICBhbkluc3RhbmNlKHRoaXMsICRPYnNlcnZhYmxlLCAnT2JzZXJ2YWJsZScsICdfZicpLl9mID0gYUZ1bmN0aW9uKHN1YnNjcmliZXIpO1xufTtcblxucmVkZWZpbmVBbGwoJE9ic2VydmFibGUucHJvdG90eXBlLCB7XG4gIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb24ob2JzZXJ2ZXIsIHRoaXMuX2YpO1xuICB9LFxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgKGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgYUZ1bmN0aW9uKGZuKTtcbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGF0LnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4odmFsdWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IHJlamVjdCxcbiAgICAgICAgY29tcGxldGU6IHJlc29sdmVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59KTtcbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLCB7XG4gIGZyb206IGZ1bmN0aW9uIGZyb20oeCkge1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGU7XG4gICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZChhbk9iamVjdCh4KVtPQlNFUlZBQkxFXSk7XG5cbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IGFuT2JqZWN0KG1ldGhvZC5jYWxsKHgpKTtcbiAgICAgIHJldHVybiBvYnNlcnZhYmxlLmNvbnN0cnVjdG9yID09PSBDID8gb2JzZXJ2YWJsZSA6IG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZS5zdWJzY3JpYmUob2JzZXJ2ZXIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZm9yT2YoeCwgZmFsc2UsIGZ1bmN0aW9uIChpdCkge1xuICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0KTtcbiAgICAgICAgICAgICAgaWYgKGRvbmUpIHJldHVybiBSRVRVUk47XG4gICAgICAgICAgICB9KSA9PT0gUkVUVVJOKSByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHRocm93IGU7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfSxcbiAgb2Y6IGZ1bmN0aW9uIG9mKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBuZXcgQXJyYXkobCk7IGkgPCBsOykgaXRlbXNbaV0gPSBhcmd1bWVudHNbaSsrXTtcblxuICAgIHJldHVybiBuZXcgKHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6ICRPYnNlcnZhYmxlKShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW1zLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0ZW1zW2pdKTtcbiAgICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn0pO1xuaGlkZSgkT2JzZXJ2YWJsZS5wcm90b3R5cGUsIE9CU0VSVkFCTEUsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59KTtcbiRleHBvcnQoJGV4cG9ydC5HLCB7XG4gIE9ic2VydmFibGU6ICRPYnNlcnZhYmxlXG59KTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnT2JzZXJ2YWJsZScpOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtZmluYWxseVxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdQcm9taXNlJywge1xuICAnZmluYWxseSc6IGZ1bmN0aW9uIChvbkZpbmFsbHkpIHtcbiAgICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpO1xuICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIG9uRmluYWxseSA9PSAnZnVuY3Rpb24nO1xuICAgIHJldHVybiB0aGlzLnRoZW4oaXNGdW5jdGlvbiA/IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICAgIH0pO1xuICAgIH0gOiBvbkZpbmFsbHksIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0pO1xuICAgIH0gOiBvbkZpbmFsbHkpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtdHJ5XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcblxudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUHJvbWlzZScsIHtcbiAgJ3RyeSc6IGZ1bmN0aW9uIChjYWxsYmFja2ZuKSB7XG4gICAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZih0aGlzKTtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShjYWxsYmFja2ZuKTtcbiAgICAocmVzdWx0LmUgPyBwcm9taXNlQ2FwYWJpbGl0eS5yZWplY3QgOiBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlKShyZXN1bHQudik7XG4gICAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pOyIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xudmFyIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5zZXQ7XG5tZXRhZGF0YS5leHAoe1xuICBkZWZpbmVNZXRhZGF0YTogZnVuY3Rpb24gZGVmaW5lTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgdGFyZ2V0S2V5KSB7XG4gICAgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgYW5PYmplY3QodGFyZ2V0KSwgdG9NZXRhS2V5KHRhcmdldEtleSkpO1xuICB9XG59KTsiLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcbnZhciBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gbWV0YWRhdGEubWFwO1xudmFyIHN0b3JlID0gbWV0YWRhdGEuc3RvcmU7XG5tZXRhZGF0YS5leHAoe1xuICBkZWxldGVNZXRhZGF0YTogZnVuY3Rpb24gZGVsZXRlTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldFxuICAvKiAsIHRhcmdldEtleSAqL1xuICApIHtcbiAgICB2YXIgdGFyZ2V0S2V5ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKTtcbiAgICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKGFuT2JqZWN0KHRhcmdldCksIHRhcmdldEtleSwgZmFsc2UpO1xuICAgIGlmIChtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkIHx8ICFtZXRhZGF0YU1hcFsnZGVsZXRlJ10obWV0YWRhdGFLZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG1ldGFkYXRhTWFwLnNpemUpIHJldHVybiB0cnVlO1xuICAgIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuICAgIHRhcmdldE1ldGFkYXRhWydkZWxldGUnXSh0YXJnZXRLZXkpO1xuICAgIHJldHVybiAhIXRhcmdldE1ldGFkYXRhLnNpemUgfHwgc3RvcmVbJ2RlbGV0ZSddKHRhcmdldCk7XG4gIH1cbn0pOyIsInZhciBTZXQgPSByZXF1aXJlKCcuL2VzNi5zZXQnKTtcblxudmFyIGZyb20gPSByZXF1aXJlKCcuL19hcnJheS1mcm9tLWl0ZXJhYmxlJyk7XG5cbnZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnZhciBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IG1ldGFkYXRhLmtleXM7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlNZXRhZGF0YUtleXMgPSBmdW5jdGlvbiAoTywgUCkge1xuICB2YXIgb0tleXMgPSBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICBpZiAocGFyZW50ID09PSBudWxsKSByZXR1cm4gb0tleXM7XG4gIHZhciBwS2V5cyA9IG9yZGluYXJ5TWV0YWRhdGFLZXlzKHBhcmVudCwgUCk7XG4gIHJldHVybiBwS2V5cy5sZW5ndGggPyBvS2V5cy5sZW5ndGggPyBmcm9tKG5ldyBTZXQob0tleXMuY29uY2F0KHBLZXlzKSkpIDogcEtleXMgOiBvS2V5cztcbn07XG5cbm1ldGFkYXRhLmV4cCh7XG4gIGdldE1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0TWV0YWRhdGFLZXlzKHRhcmdldFxuICAvKiAsIHRhcmdldEtleSAqL1xuICApIHtcbiAgICByZXR1cm4gb3JkaW5hcnlNZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG4gIH1cbn0pOyIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzO1xudmFyIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXQ7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlHZXRNZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTywgUCkge1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmIChoYXNPd24pIHJldHVybiBvcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gb3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKSA6IHVuZGVmaW5lZDtcbn07XG5cbm1ldGFkYXRhLmV4cCh7XG4gIGdldE1ldGFkYXRhOiBmdW5jdGlvbiBnZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0XG4gIC8qICwgdGFyZ2V0S2V5ICovXG4gICkge1xuICAgIHJldHVybiBvcmRpbmFyeUdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbiAgfVxufSk7IiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IG1ldGFkYXRhLmtleXM7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xubWV0YWRhdGEuZXhwKHtcbiAgZ2V0T3duTWV0YWRhdGFLZXlzOiBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YUtleXModGFyZ2V0XG4gIC8qICwgdGFyZ2V0S2V5ICovXG4gICkge1xuICAgIHJldHVybiBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMV0pKTtcbiAgfVxufSk7IiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gbWV0YWRhdGEuZ2V0O1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcbm1ldGFkYXRhLmV4cCh7XG4gIGdldE93bk1ldGFkYXRhOiBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0XG4gIC8qICwgdGFyZ2V0S2V5ICovXG4gICkge1xuICAgIHJldHVybiBvcmRpbmFyeUdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbiAgfVxufSk7IiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXM7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlIYXNNZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTywgUCkge1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmIChoYXNPd24pIHJldHVybiB0cnVlO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBvcmRpbmFyeUhhc01ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApIDogZmFsc2U7XG59O1xuXG5tZXRhZGF0YS5leHAoe1xuICBoYXNNZXRhZGF0YTogZnVuY3Rpb24gaGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldFxuICAvKiAsIHRhcmdldEtleSAqL1xuICApIHtcbiAgICByZXR1cm4gb3JkaW5hcnlIYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG4gIH1cbn0pOyIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhcztcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5tZXRhZGF0YS5leHAoe1xuICBoYXNPd25NZXRhZGF0YTogZnVuY3Rpb24gaGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldFxuICAvKiAsIHRhcmdldEtleSAqL1xuICApIHtcbiAgICByZXR1cm4gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG4gIH1cbn0pOyIsInZhciAkbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxudmFyIHRvTWV0YUtleSA9ICRtZXRhZGF0YS5rZXk7XG52YXIgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9ICRtZXRhZGF0YS5zZXQ7XG4kbWV0YWRhdGEuZXhwKHtcbiAgbWV0YWRhdGE6IGZ1bmN0aW9uIG1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQsIHRhcmdldEtleSkge1xuICAgICAgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgKHRhcmdldEtleSAhPT0gdW5kZWZpbmVkID8gYW5PYmplY3QgOiBhRnVuY3Rpb24pKHRhcmdldCksIHRvTWV0YUtleSh0YXJnZXRLZXkpKTtcbiAgICB9O1xuICB9XG59KTsiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1zZXQuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdTZXQnKTsiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1zZXQub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1NldCcpOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnU2V0Jywge1xuICB0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKVxufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIGF0OiBmdW5jdGlvbiBhdChwb3MpIHtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9TdHJpbmcucHJvdG90eXBlLm1hdGNoQWxsL1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xuXG52YXIgZ2V0RmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xuXG52YXIgUmVnRXhwUHJvdG8gPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yID0gZnVuY3Rpb24gKHJlZ2V4cCwgc3RyaW5nKSB7XG4gIHRoaXMuX3IgPSByZWdleHA7XG4gIHRoaXMuX3MgPSBzdHJpbmc7XG59O1xuXG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKCRSZWdFeHBTdHJpbmdJdGVyYXRvciwgJ1JlZ0V4cCBTdHJpbmcnLCBmdW5jdGlvbiBuZXh0KCkge1xuICB2YXIgbWF0Y2ggPSB0aGlzLl9yLmV4ZWModGhpcy5fcyk7XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogbWF0Y2gsXG4gICAgZG9uZTogbWF0Y2ggPT09IG51bGxcbiAgfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgbWF0Y2hBbGw6IGZ1bmN0aW9uIG1hdGNoQWxsKHJlZ2V4cCkge1xuICAgIGRlZmluZWQodGhpcyk7XG4gICAgaWYgKCFpc1JlZ0V4cChyZWdleHApKSB0aHJvdyBUeXBlRXJyb3IocmVnZXhwICsgJyBpcyBub3QgYSByZWdleHAhJyk7XG4gICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgdmFyIGZsYWdzID0gJ2ZsYWdzJyBpbiBSZWdFeHBQcm90byA/IFN0cmluZyhyZWdleHAuZmxhZ3MpIDogZ2V0RmxhZ3MuY2FsbChyZWdleHApO1xuICAgIHZhciByeCA9IG5ldyBSZWdFeHAocmVnZXhwLnNvdXJjZSwgfmZsYWdzLmluZGV4T2YoJ2cnKSA/IGZsYWdzIDogJ2cnICsgZmxhZ3MpO1xuICAgIHJ4Lmxhc3RJbmRleCA9IHRvTGVuZ3RoKHJlZ2V4cC5sYXN0SW5kZXgpO1xuICAgIHJldHVybiBuZXcgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yKHJ4LCBTKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJHBhZCA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcblxudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4vX3VzZXItYWdlbnQnKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzI4MFxuXG5cbnZhciBXRUJLSVRfQlVHID0gL1ZlcnNpb25cXC8xMFxcLlxcZCsoXFwuXFxkKyk/KCBNb2JpbGVcXC9cXHcrKT8gU2FmYXJpXFwvLy50ZXN0KHVzZXJBZ2VudCk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIFdFQktJVF9CVUcsICdTdHJpbmcnLCB7XG4gIHBhZEVuZDogZnVuY3Rpb24gcGFkRW5kKG1heExlbmd0aFxuICAvKiAsIGZpbGxTdHJpbmcgPSAnICcgKi9cbiAgKSB7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgZmFsc2UpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkcGFkID0gcmVxdWlyZSgnLi9fc3RyaW5nLXBhZCcpO1xuXG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi9fdXNlci1hZ2VudCcpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMjgwXG5cblxudmFyIFdFQktJVF9CVUcgPSAvVmVyc2lvblxcLzEwXFwuXFxkKyhcXC5cXGQrKT8oIE1vYmlsZVxcL1xcdyspPyBTYWZhcmlcXC8vLnRlc3QodXNlckFnZW50KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogV0VCS0lUX0JVRywgJ1N0cmluZycsIHtcbiAgcGFkU3RhcnQ6IGZ1bmN0aW9uIHBhZFN0YXJ0KG1heExlbmd0aFxuICAvKiAsIGZpbGxTdHJpbmcgPSAnICcgKi9cbiAgKSB7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxuXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltTGVmdCcsIGZ1bmN0aW9uICgkdHJpbSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbUxlZnQoKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDEpO1xuICB9O1xufSwgJ3RyaW1TdGFydCcpOyIsIid1c2Ugc3RyaWN0JzsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxuXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltUmlnaHQnLCBmdW5jdGlvbiAoJHRyaW0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW1SaWdodCgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMik7XG4gIH07XG59LCAndHJpbUVuZCcpOyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpOyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTeXN0ZW0nLCB7XG4gIGdsb2JhbDogcmVxdWlyZSgnLi9fZ2xvYmFsJylcbn0pOyIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWttYXAuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdXZWFrTWFwJyk7IiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha21hcC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnV2Vha01hcCcpOyIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWtzZXQuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdXZWFrU2V0Jyk7IiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha3NldC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnV2Vha1NldCcpOyIsInZhciAkaXRlcmF0b3JzID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcblxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xuXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5cbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcblxudmFyIElURVJBVE9SID0gd2tzKCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBJdGVyYXRvcnMuQXJyYXk7XG52YXIgRE9NSXRlcmFibGVzID0ge1xuICBDU1NSdWxlTGlzdDogdHJ1ZSxcbiAgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IGZhbHNlLFxuICBDU1NWYWx1ZUxpc3Q6IGZhbHNlLFxuICBDbGllbnRSZWN0TGlzdDogZmFsc2UsXG4gIERPTVJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NU3RyaW5nTGlzdDogZmFsc2UsXG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IGZhbHNlLFxuICBGaWxlTGlzdDogZmFsc2UsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MRm9ybUVsZW1lbnQ6IGZhbHNlLFxuICBIVE1MU2VsZWN0RWxlbWVudDogZmFsc2UsXG4gIE1lZGlhTGlzdDogdHJ1ZSxcbiAgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIE1pbWVUeXBlQXJyYXk6IGZhbHNlLFxuICBOYW1lZE5vZGVNYXA6IGZhbHNlLFxuICBOb2RlTGlzdDogdHJ1ZSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogZmFsc2UsXG4gIFBsdWdpbjogZmFsc2UsXG4gIFBsdWdpbkFycmF5OiBmYWxzZSxcbiAgU1ZHTGVuZ3RoTGlzdDogZmFsc2UsXG4gIFNWR051bWJlckxpc3Q6IGZhbHNlLFxuICBTVkdQYXRoU2VnTGlzdDogZmFsc2UsXG4gIFNWR1BvaW50TGlzdDogZmFsc2UsXG4gIFNWR1N0cmluZ0xpc3Q6IGZhbHNlLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiBmYWxzZSxcbiAgU291cmNlQnVmZmVyTGlzdDogZmFsc2UsXG4gIFN0eWxlU2hlZXRMaXN0OiB0cnVlLFxuICAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgVGV4dFRyYWNrQ3VlTGlzdDogZmFsc2UsXG4gIFRleHRUcmFja0xpc3Q6IGZhbHNlLFxuICBUb3VjaExpc3Q6IGZhbHNlXG59O1xuXG5mb3IgKHZhciBjb2xsZWN0aW9ucyA9IGdldEtleXMoRE9NSXRlcmFibGVzKSwgaSA9IDA7IGkgPCBjb2xsZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IGNvbGxlY3Rpb25zW2ldO1xuICB2YXIgZXhwbGljaXQgPSBET01JdGVyYWJsZXNbTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICB2YXIga2V5O1xuXG4gIGlmIChwcm90bykge1xuICAgIGlmICghcHJvdG9bSVRFUkFUT1JdKSBoaWRlKHByb3RvLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIGlmICghcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IEFycmF5VmFsdWVzO1xuICAgIGlmIChleHBsaWNpdCkgZm9yIChrZXkgaW4gJGl0ZXJhdG9ycykgaWYgKCFwcm90b1trZXldKSByZWRlZmluZShwcm90bywga2V5LCAkaXRlcmF0b3JzW2tleV0sIHRydWUpO1xuICB9XG59IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICR0YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpO1xuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICR0YXNrLnNldCxcbiAgY2xlYXJJbW1lZGlhdGU6ICR0YXNrLmNsZWFyXG59KTsiLCIvLyBpZTktIHNldFRpbWVvdXQgJiBzZXRJbnRlcnZhbCBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZml4XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7XG5cbnZhciBzbGljZSA9IFtdLnNsaWNlO1xudmFyIE1TSUUgPSAvTVNJRSAuXFwuLy50ZXN0KHVzZXJBZ2VudCk7IC8vIDwtIGRpcnR5IGllOS0gY2hlY2tcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAoc2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZm4sIHRpbWVcbiAgLyogLCAuLi5hcmdzICovXG4gICkge1xuICAgIHZhciBib3VuZEFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICB2YXIgYXJncyA9IGJvdW5kQXJncyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IGZhbHNlO1xuICAgIHJldHVybiBzZXQoYm91bmRBcmdzID8gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICAodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSA6IGZuLCB0aW1lKTtcbiAgfTtcbn07XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CICsgJGV4cG9ydC5GICogTVNJRSwge1xuICBzZXRUaW1lb3V0OiB3cmFwKGdsb2JhbC5zZXRUaW1lb3V0KSxcbiAgc2V0SW50ZXJ2YWw6IHdyYXAoZ2xvYmFsLnNldEludGVydmFsKVxufSk7IiwicmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNlYWwnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnBhcnNlLWludCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXInKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYWNvc2gnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hdGFuaCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY2JydCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY2x6MzInKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNvc2gnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5mcm91bmQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmh5cG90Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5pbXVsJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cxMCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzInKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpZ24nKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpbmgnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnRhbmgnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnRydW5jJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZyb20tY29kZS1wb2ludCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yYXcnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGgnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJpZycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5ibGluaycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN1YicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdXAnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLm5vdycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5vZicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmpvaW4nKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zbGljZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNvcnQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lm1hcCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNvbWUnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmluZGV4LW9mJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmlsbCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLmV4ZWMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hcCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnNldCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstbWFwJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYud2Vhay1zZXQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXInKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQ4LWFycmF5Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXknKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXknKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXknKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXknKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHknKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmZsYXQtbWFwJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXJyYXkuZmxhdHRlbicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5hdCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXInKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtZ2V0dGVyJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1zZXR0ZXInKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXAudG8tanNvbicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWFwLm9mJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0Lm9mJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1tYXAub2YnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy53ZWFrLXNldC5vZicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC5mcm9tJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0LmZyb20nKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy53ZWFrLW1hcC5mcm9tJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1zZXQuZnJvbScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lmdsb2JhbCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguY2xhbXAnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmRlZy1wZXItcmFkJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5kZWdyZWVzJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5mc2NhbGUnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlhZGRoJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pc3ViaCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaW11bGgnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnJhZC1wZXItZGVnJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5yYWRpYW5zJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5zY2FsZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGgudW11bGgnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnNpZ25iaXQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5wcm9taXNlLmZpbmFsbHknKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLWtleXMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEta2V5cycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtb3duLW1ldGFkYXRhJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5tZXRhZGF0YScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFzYXAnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIudGltZXJzJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuaW1tZWRpYXRlJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tb2R1bGVzL19jb3JlJyk7IiwiLypcbiBIaWdoY2hhcnRzIEpTIHY4LjAuNCAoMjAyMC0wMy0xMClcblxuIChjKSAyMDA5LTIwMTggVG9yc3RlaW4gSG9uc2lcblxuIExpY2Vuc2U6IHd3dy5oaWdoY2hhcnRzLmNvbS9saWNlbnNlXG4qL1xuKGZ1bmN0aW9uIChhYSwgUykge1xuICBcIm9iamVjdFwiID09PSB0eXBlb2YgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzID8gKFNbXCJkZWZhdWx0XCJdID0gUywgbW9kdWxlLmV4cG9ydHMgPSBhYS5kb2N1bWVudCA/IFMoYWEpIDogUykgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShcImhpZ2hjaGFydHMvaGlnaGNoYXJ0c1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFMoYWEpO1xuICB9KSA6IChhYS5IaWdoY2hhcnRzICYmIGFhLkhpZ2hjaGFydHMuZXJyb3IoMTYsICEwKSwgYWEuSGlnaGNoYXJ0cyA9IFMoYWEpKTtcbn0pKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiB3aW5kb3cgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiAoYWEpIHtcbiAgZnVuY3Rpb24gUyhkLCBnLCBXLCB1KSB7XG4gICAgZC5oYXNPd25Qcm9wZXJ0eShnKSB8fCAoZFtnXSA9IHUuYXBwbHkobnVsbCwgVykpO1xuICB9XG5cbiAgdmFyIHIgPSB7fTtcbiAgUyhyLCBcInBhcnRzL0dsb2JhbHMuanNcIiwgW10sIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZCA9IFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBhYSA/IGFhIDogXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHdpbmRvdyA/IHdpbmRvdyA6IHt9LFxuICAgICAgICBnID0gZC5kb2N1bWVudCxcbiAgICAgICAgVyA9IGQubmF2aWdhdG9yICYmIGQubmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBcIlwiLFxuICAgICAgICB1ID0gZyAmJiBnLmNyZWF0ZUVsZW1lbnROUyAmJiAhIWcuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIikuY3JlYXRlU1ZHUmVjdCxcbiAgICAgICAgciA9IC8oZWRnZXxtc2llfHRyaWRlbnQpL2kudGVzdChXKSAmJiAhZC5vcGVyYSxcbiAgICAgICAgTSA9IC0xICE9PSBXLmluZGV4T2YoXCJGaXJlZm94XCIpLFxuICAgICAgICBFID0gLTEgIT09IFcuaW5kZXhPZihcIkNocm9tZVwiKSxcbiAgICAgICAgQSA9IE0gJiYgNCA+IHBhcnNlSW50KFcuc3BsaXQoXCJGaXJlZm94L1wiKVsxXSwgMTApO1xuICAgIHJldHVybiB7XG4gICAgICBwcm9kdWN0OiBcIkhpZ2hjaGFydHNcIixcbiAgICAgIHZlcnNpb246IFwiOC4wLjRcIixcbiAgICAgIGRlZzJyYWQ6IDIgKiBNYXRoLlBJIC8gMzYwLFxuICAgICAgZG9jOiBnLFxuICAgICAgaGFzQmlkaUJ1ZzogQSxcbiAgICAgIGhhc1RvdWNoOiAhIWQuVG91Y2hFdmVudCxcbiAgICAgIGlzTVM6IHIsXG4gICAgICBpc1dlYktpdDogLTEgIT09IFcuaW5kZXhPZihcIkFwcGxlV2ViS2l0XCIpLFxuICAgICAgaXNGaXJlZm94OiBNLFxuICAgICAgaXNDaHJvbWU6IEUsXG4gICAgICBpc1NhZmFyaTogIUUgJiYgLTEgIT09IFcuaW5kZXhPZihcIlNhZmFyaVwiKSxcbiAgICAgIGlzVG91Y2hEZXZpY2U6IC8oTW9iaWxlfEFuZHJvaWR8V2luZG93cyBQaG9uZSkvLnRlc3QoVyksXG4gICAgICBTVkdfTlM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICAgIGNoYXJ0Q291bnQ6IDAsXG4gICAgICBzZXJpZXNUeXBlczoge30sXG4gICAgICBzeW1ib2xTaXplczoge30sXG4gICAgICBzdmc6IHUsXG4gICAgICB3aW46IGQsXG4gICAgICBtYXJnaW5OYW1lczogW1wicGxvdFRvcFwiLCBcIm1hcmdpblJpZ2h0XCIsIFwibWFyZ2luQm90dG9tXCIsIFwicGxvdExlZnRcIl0sXG4gICAgICBub29wOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIGNoYXJ0czogW10sXG4gICAgICBkYXRlRm9ybWF0czoge31cbiAgICB9O1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL1V0aWxpdGllcy5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl1dLCBmdW5jdGlvbiAoZCkge1xuICAgIGZ1bmN0aW9uIGcoKSB7XG4gICAgICB2YXIgYixcbiAgICAgICAgICBhID0gYXJndW1lbnRzLFxuICAgICAgICAgIG0gPSB7fSxcbiAgICAgICAgICBmID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIGIgJiYgKGIgPSB7fSk7XG4gICAgICAgIFkoYSwgZnVuY3Rpb24gKG0sIGMpIHtcbiAgICAgICAgICAhaChtLCAhMCkgfHwgcShtKSB8fCBOKG0pID8gYltjXSA9IGFbY10gOiBiW2NdID0gZihiW2NdIHx8IHt9LCBtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfTtcblxuICAgICAgITAgPT09IGFbMF0gJiYgKG0gPSBhWzFdLCBhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYSwgMikpO1xuICAgICAgdmFyIGMgPSBhLmxlbmd0aDtcblxuICAgICAgZm9yIChiID0gMDsgYiA8IGM7IGIrKykgbSA9IGYobSwgYVtiXSk7XG5cbiAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFcoYiwgYSwgbSkge1xuICAgICAgdmFyIGY7XG4gICAgICB0KGEpID8gYyhtKSA/IGIuc2V0QXR0cmlidXRlKGEsIG0pIDogYiAmJiBiLmdldEF0dHJpYnV0ZSAmJiAoKGYgPSBiLmdldEF0dHJpYnV0ZShhKSkgfHwgXCJjbGFzc1wiICE9PSBhIHx8IChmID0gYi5nZXRBdHRyaWJ1dGUoYSArIFwiTmFtZVwiKSkpIDogWShhLCBmdW5jdGlvbiAoYSwgbSkge1xuICAgICAgICBiLnNldEF0dHJpYnV0ZShtLCBhKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdSgpIHtcbiAgICAgIGZvciAodmFyIGIgPSBhcmd1bWVudHMsIGEgPSBiLmxlbmd0aCwgbSA9IDA7IG0gPCBhOyBtKyspIHtcbiAgICAgICAgdmFyIGYgPSBiW21dO1xuICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGYgJiYgbnVsbCAhPT0gZikgcmV0dXJuIGY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcihiLCBhKSB7XG4gICAgICBpZiAoIWIpIHJldHVybiBhO1xuICAgICAgdmFyIG0gPSBiLnNwbGl0KFwiLlwiKS5yZXZlcnNlKCk7XG4gICAgICBpZiAoMSA9PT0gbS5sZW5ndGgpIHJldHVybiBhW2JdO1xuXG4gICAgICBmb3IgKGIgPSBtLnBvcCgpOyBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYiAmJiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYSAmJiBudWxsICE9PSBhOykgYSA9IGFbYl0sIGIgPSBtLnBvcCgpO1xuXG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBkLnRpbWVycyA9IFtdO1xuXG4gICAgdmFyIE0gPSBkLmNoYXJ0cyxcbiAgICAgICAgRSA9IGQuZG9jLFxuICAgICAgICBBID0gZC53aW4sXG4gICAgICAgIEcgPSBkLmVycm9yID0gZnVuY3Rpb24gKGIsIGEsIG0sIGYpIHtcbiAgICAgIHZhciBjID0gUChiKSxcbiAgICAgICAgICBwID0gYyA/IFwiSGlnaGNoYXJ0cyBlcnJvciAjXCIgKyBiICsgXCI6IHd3dy5oaWdoY2hhcnRzLmNvbS9lcnJvcnMvXCIgKyBiICsgXCIvXCIgOiBiLnRvU3RyaW5nKCksXG4gICAgICAgICAgZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGEpIHRocm93IEVycm9yKHApO1xuICAgICAgICBBLmNvbnNvbGUgJiYgY29uc29sZS5sb2cocCk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGYpIHtcbiAgICAgICAgdmFyIHggPSBcIlwiO1xuICAgICAgICBjICYmIChwICs9IFwiP1wiKTtcbiAgICAgICAgZC5vYmplY3RFYWNoKGYsIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgeCArPSBcIlxcblwiICsgYSArIFwiOiBcIiArIGI7XG4gICAgICAgICAgYyAmJiAocCArPSBlbmNvZGVVUkkoYSkgKyBcIj1cIiArIGVuY29kZVVSSShiKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwICs9IHg7XG4gICAgICB9XG5cbiAgICAgIG0gPyBkLmZpcmVFdmVudChtLCBcImRpc3BsYXlFcnJvclwiLCB7XG4gICAgICAgIGNvZGU6IGIsXG4gICAgICAgIG1lc3NhZ2U6IHAsXG4gICAgICAgIHBhcmFtczogZlxuICAgICAgfSwgZSkgOiBlKCk7XG4gICAgfSxcbiAgICAgICAgSiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIGIoYiwgYSwgbSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBhO1xuICAgICAgICB0aGlzLmVsZW0gPSBiO1xuICAgICAgICB0aGlzLnByb3AgPSBtO1xuICAgICAgfVxuXG4gICAgICBiLnByb3RvdHlwZS5kU2V0dGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMucGF0aHNbMF0sXG4gICAgICAgICAgICBhID0gdGhpcy5wYXRoc1sxXSxcbiAgICAgICAgICAgIG0gPSBbXSxcbiAgICAgICAgICAgIGYgPSB0aGlzLm5vdyxcbiAgICAgICAgICAgIGMgPSBiLmxlbmd0aDtcbiAgICAgICAgaWYgKDEgPT09IGYpIG0gPSB0aGlzLnRvRDtlbHNlIGlmIChjID09PSBhLmxlbmd0aCAmJiAxID4gZikgZm9yICg7IGMtLTspIHtcbiAgICAgICAgICB2YXIgcCA9IHBhcnNlRmxvYXQoYltjXSk7XG4gICAgICAgICAgbVtjXSA9IGlzTmFOKHApIHx8IFwiQVwiID09PSBhW2MgLSA0XSB8fCBcIkFcIiA9PT0gYVtjIC0gNV0gPyBhW2NdIDogZiAqIHBhcnNlRmxvYXQoXCJcIiArIChhW2NdIC0gcCkpICsgcDtcbiAgICAgICAgfSBlbHNlIG0gPSBhO1xuICAgICAgICB0aGlzLmVsZW0uYXR0cihcImRcIiwgbSwgbnVsbCwgITApO1xuICAgICAgfTtcblxuICAgICAgYi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMuZWxlbSxcbiAgICAgICAgICAgIGEgPSB0aGlzLnByb3AsXG4gICAgICAgICAgICBtID0gdGhpcy5ub3csXG4gICAgICAgICAgICBmID0gdGhpcy5vcHRpb25zLnN0ZXA7XG4gICAgICAgIGlmICh0aGlzW2EgKyBcIlNldHRlclwiXSkgdGhpc1thICsgXCJTZXR0ZXJcIl0oKTtlbHNlIGIuYXR0ciA/IGIuZWxlbWVudCAmJiBiLmF0dHIoYSwgbSwgbnVsbCwgITApIDogYi5zdHlsZVthXSA9IG0gKyB0aGlzLnVuaXQ7XG4gICAgICAgIGYgJiYgZi5jYWxsKGIsIG0sIHRoaXMpO1xuICAgICAgfTtcblxuICAgICAgYi5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGIsIGEsIG0pIHtcbiAgICAgICAgdmFyIGYgPSB0aGlzLFxuICAgICAgICAgICAgYyA9IGYub3B0aW9ucyxcbiAgICAgICAgICAgIHAgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHJldHVybiBwLnN0b3BwZWQgPyAhMSA6IGYuc3RlcChiKTtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIGUgPSBBLnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHNldFRpbWVvdXQoYiwgMTMpO1xuICAgICAgICB9LFxuICAgICAgICAgICAgeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGQudGltZXJzLmxlbmd0aDsgYisrKSBkLnRpbWVyc1tiXSgpIHx8IGQudGltZXJzLnNwbGljZShiLS0sIDEpO1xuXG4gICAgICAgICAgZC50aW1lcnMubGVuZ3RoICYmIGUoeCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYiAhPT0gYSB8fCB0aGlzLmVsZW1bXCJmb3JjZUFuaW1hdGU6XCIgKyB0aGlzLnByb3BdID8gKHRoaXMuc3RhcnRUaW1lID0gK25ldyBEYXRlKCksIHRoaXMuc3RhcnQgPSBiLCB0aGlzLmVuZCA9IGEsIHRoaXMudW5pdCA9IG0sIHRoaXMubm93ID0gdGhpcy5zdGFydCwgdGhpcy5wb3MgPSAwLCBwLmVsZW0gPSB0aGlzLmVsZW0sIHAucHJvcCA9IHRoaXMucHJvcCwgcCgpICYmIDEgPT09IGQudGltZXJzLnB1c2gocCkgJiYgZSh4KSkgOiAoZGVsZXRlIGMuY3VyQW5pbVt0aGlzLnByb3BdLCBjLmNvbXBsZXRlICYmIDAgPT09IE9iamVjdC5rZXlzKGMuY3VyQW5pbSkubGVuZ3RoICYmIGMuY29tcGxldGUuY2FsbCh0aGlzLmVsZW0pKTtcbiAgICAgIH07XG5cbiAgICAgIGIucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9ICtuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgbSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGYgPSB0aGlzLmVsZW0sXG4gICAgICAgICAgICBjID0gbS5jb21wbGV0ZSxcbiAgICAgICAgICAgIHAgPSBtLmR1cmF0aW9uLFxuICAgICAgICAgICAgZSA9IG0uY3VyQW5pbTtcbiAgICAgICAgaWYgKGYuYXR0ciAmJiAhZi5lbGVtZW50KSBiID0gITE7ZWxzZSBpZiAoYiB8fCBhID49IHAgKyB0aGlzLnN0YXJ0VGltZSkge1xuICAgICAgICAgIHRoaXMubm93ID0gdGhpcy5lbmQ7XG4gICAgICAgICAgdGhpcy5wb3MgPSAxO1xuICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgdmFyIHggPSBlW3RoaXMucHJvcF0gPSAhMDtcbiAgICAgICAgICBZKGUsIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAhMCAhPT0gYiAmJiAoeCA9ICExKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB4ICYmIGMgJiYgYy5jYWxsKGYpO1xuICAgICAgICAgIGIgPSAhMTtcbiAgICAgICAgfSBlbHNlIHRoaXMucG9zID0gbS5lYXNpbmcoKGEgLSB0aGlzLnN0YXJ0VGltZSkgLyBwKSwgdGhpcy5ub3cgPSB0aGlzLnN0YXJ0ICsgKHRoaXMuZW5kIC0gdGhpcy5zdGFydCkgKiB0aGlzLnBvcywgdGhpcy51cGRhdGUoKSwgYiA9ICEwO1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH07XG5cbiAgICAgIGIucHJvdG90eXBlLmluaXRQYXRoID0gZnVuY3Rpb24gKGIsIGEsIG0pIHtcbiAgICAgICAgZnVuY3Rpb24gZihiKSB7XG4gICAgICAgICAgZm9yIChDID0gYi5sZW5ndGg7IEMtLTspIHtcbiAgICAgICAgICAgIHZhciBhID0gXCJNXCIgPT09IGJbQ10gfHwgXCJMXCIgPT09IGJbQ107XG4gICAgICAgICAgICB2YXIgbSA9IC9bYS16QS1aXS8udGVzdChiW0MgKyAzXSk7XG4gICAgICAgICAgICBhICYmIG0gJiYgYi5zcGxpY2UoQyArIDEsIDAsIGJbQyArIDFdLCBiW0MgKyAyXSwgYltDICsgMV0sIGJbQyArIDJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjKGIsIGEpIHtcbiAgICAgICAgICBmb3IgKDsgYi5sZW5ndGggPCB2Oykge1xuICAgICAgICAgICAgYlswXSA9IGFbdiAtIGIubGVuZ3RoXTtcbiAgICAgICAgICAgIHZhciBtID0gYi5zbGljZSgwLCBUKTtcbiAgICAgICAgICAgIFtdLnNwbGljZS5hcHBseShiLCBbMCwgMF0uY29uY2F0KG0pKTtcbiAgICAgICAgICAgIGsgJiYgKG0gPSBiLnNsaWNlKGIubGVuZ3RoIC0gVCksIFtdLnNwbGljZS5hcHBseShiLCBbYi5sZW5ndGgsIDBdLmNvbmNhdChtKSksIEMtLSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYlswXSA9IFwiTVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcChiLCBhKSB7XG4gICAgICAgICAgZm9yICh2YXIgbSA9ICh2IC0gYi5sZW5ndGgpIC8gVDsgMCA8IG0gJiYgbS0tOykgbCA9IGIuc2xpY2UoKS5zcGxpY2UoYi5sZW5ndGggLyBuIC0gVCwgVCAqIG4pLCBsWzBdID0gYVt2IC0gVCAtIG0gKiBUXSwgRiAmJiAobFtUIC0gNl0gPSBsW1QgLSAyXSwgbFtUIC0gNV0gPSBsW1QgLSAxXSksIFtdLnNwbGljZS5hcHBseShiLCBbYi5sZW5ndGggLyBuLCAwXS5jb25jYXQobCkpLCBrICYmIG0tLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGEgPSBhIHx8IFwiXCI7XG4gICAgICAgIHZhciBlID0gYi5zdGFydFgsXG4gICAgICAgICAgICB4ID0gYi5lbmRYLFxuICAgICAgICAgICAgRiA9IC0xIDwgYS5pbmRleE9mKFwiQ1wiKSxcbiAgICAgICAgICAgIFQgPSBGID8gNyA6IDMsXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgQztcbiAgICAgICAgYSA9IGEuc3BsaXQoXCIgXCIpO1xuICAgICAgICBtID0gbS5zbGljZSgpO1xuICAgICAgICB2YXIgayA9IGIuaXNBcmVhLFxuICAgICAgICAgICAgbiA9IGsgPyAyIDogMTtcbiAgICAgICAgRiAmJiAoZihhKSwgZihtKSk7XG5cbiAgICAgICAgaWYgKGUgJiYgeCkge1xuICAgICAgICAgIGZvciAoQyA9IDA7IEMgPCBlLmxlbmd0aDsgQysrKSBpZiAoZVtDXSA9PT0geFswXSkge1xuICAgICAgICAgICAgdmFyIFYgPSBDO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmIChlWzBdID09PSB4W3gubGVuZ3RoIC0gZS5sZW5ndGggKyBDXSkge1xuICAgICAgICAgICAgViA9IEM7XG4gICAgICAgICAgICB2YXIgdyA9ICEwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmIChlW2UubGVuZ3RoIC0gMV0gPT09IHhbeC5sZW5ndGggLSBlLmxlbmd0aCArIENdKSB7XG4gICAgICAgICAgICBWID0gZS5sZW5ndGggLSBDO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIFYgJiYgKGEgPSBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYS5sZW5ndGggJiYgUChWKSkge1xuICAgICAgICAgIHZhciB2ID0gbS5sZW5ndGggKyBWICogbiAqIFQ7XG4gICAgICAgICAgdyA/IChjKGEsIG0pLCBwKG0sIGEpKSA6IChjKG0sIGEpLCBwKGEsIG0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbYSwgbV07XG4gICAgICB9O1xuXG4gICAgICBiLnByb3RvdHlwZS5maWxsU2V0dGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkLkZ4LnByb3RvdHlwZS5zdHJva2VTZXR0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICAgIGIucHJvdG90eXBlLnN0cm9rZVNldHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbGVtLmF0dHIodGhpcy5wcm9wLCBkLmNvbG9yKHRoaXMuc3RhcnQpLnR3ZWVuVG8oZC5jb2xvcih0aGlzLmVuZCksIHRoaXMucG9zKSwgbnVsbCwgITApO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGI7XG4gICAgfSgpO1xuXG4gICAgZC5GeCA9IEo7XG4gICAgZC5tZXJnZSA9IGc7XG5cbiAgICB2YXIgeSA9IGQucEludCA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoYiwgYSB8fCAxMCk7XG4gICAgfSxcbiAgICAgICAgdCA9IGQuaXNTdHJpbmcgPSBmdW5jdGlvbiAoYikge1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT09IHR5cGVvZiBiO1xuICAgIH0sXG4gICAgICAgIEQgPSBkLmlzQXJyYXkgPSBmdW5jdGlvbiAoYikge1xuICAgICAgYiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKTtcbiAgICAgIHJldHVybiBcIltvYmplY3QgQXJyYXldXCIgPT09IGIgfHwgXCJbb2JqZWN0IEFycmF5IEl0ZXJhdG9yXVwiID09PSBiO1xuICAgIH0sXG4gICAgICAgIGggPSBkLmlzT2JqZWN0ID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgIHJldHVybiAhIWIgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGIgJiYgKCFhIHx8ICFEKGIpKTtcbiAgICB9LFxuICAgICAgICBOID0gZC5pc0RPTUVsZW1lbnQgPSBmdW5jdGlvbiAoYikge1xuICAgICAgcmV0dXJuIGgoYikgJiYgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGIubm9kZVR5cGU7XG4gICAgfSxcbiAgICAgICAgcSA9IGQuaXNDbGFzcyA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICB2YXIgYSA9IGIgJiYgYi5jb25zdHJ1Y3RvcjtcbiAgICAgIHJldHVybiAhKCFoKGIsICEwKSB8fCBOKGIpIHx8ICFhIHx8ICFhLm5hbWUgfHwgXCJPYmplY3RcIiA9PT0gYS5uYW1lKTtcbiAgICB9LFxuICAgICAgICBQID0gZC5pc051bWJlciA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIiA9PT0gdHlwZW9mIGIgJiYgIWlzTmFOKGIpICYmIEluZmluaXR5ID4gYiAmJiAtSW5maW5pdHkgPCBiO1xuICAgIH0sXG4gICAgICAgIGUgPSBkLmVyYXNlID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgIGZvciAodmFyIG0gPSBiLmxlbmd0aDsgbS0tOykgaWYgKGJbbV0gPT09IGEpIHtcbiAgICAgICAgYi5zcGxpY2UobSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIGMgPSBkLmRlZmluZWQgPSBmdW5jdGlvbiAoYikge1xuICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBiICYmIG51bGwgIT09IGI7XG4gICAgfTtcblxuICAgIGQuYXR0ciA9IFc7XG5cbiAgICB2YXIgayA9IGQuc3BsYXQgPSBmdW5jdGlvbiAoYikge1xuICAgICAgcmV0dXJuIEQoYikgPyBiIDogW2JdO1xuICAgIH0sXG4gICAgICAgIG4gPSBkLnN5bmNUaW1lb3V0ID0gZnVuY3Rpb24gKGIsIGEsIG0pIHtcbiAgICAgIGlmICgwIDwgYSkgcmV0dXJuIHNldFRpbWVvdXQoYiwgYSwgbSk7XG4gICAgICBiLmNhbGwoMCwgbSk7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSxcbiAgICAgICAgZiA9IGQuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIGMoYikgJiYgY2xlYXJUaW1lb3V0KGIpO1xuICAgIH0sXG4gICAgICAgIGEgPSBkLmV4dGVuZCA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICB2YXIgbTtcbiAgICAgIGIgfHwgKGIgPSB7fSk7XG5cbiAgICAgIGZvciAobSBpbiBhKSBiW21dID0gYVttXTtcblxuICAgICAgcmV0dXJuIGI7XG4gICAgfTtcblxuICAgIGQucGljayA9IHU7XG5cbiAgICB2YXIgbCA9IGQuY3NzID0gZnVuY3Rpb24gKGIsIG0pIHtcbiAgICAgIGQuaXNNUyAmJiAhZC5zdmcgJiYgbSAmJiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgbS5vcGFjaXR5ICYmIChtLmZpbHRlciA9IFwiYWxwaGEob3BhY2l0eT1cIiArIDEwMCAqIG0ub3BhY2l0eSArIFwiKVwiKTtcbiAgICAgIGEoYi5zdHlsZSwgbSk7XG4gICAgfSxcbiAgICAgICAgdiA9IGQuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChiLCBtLCBmLCBjLCBwKSB7XG4gICAgICBiID0gRS5jcmVhdGVFbGVtZW50KGIpO1xuICAgICAgbSAmJiBhKGIsIG0pO1xuICAgICAgcCAmJiBsKGIsIHtcbiAgICAgICAgcGFkZGluZzogXCIwXCIsXG4gICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgIG1hcmdpbjogXCIwXCJcbiAgICAgIH0pO1xuICAgICAgZiAmJiBsKGIsIGYpO1xuICAgICAgYyAmJiBjLmFwcGVuZENoaWxkKGIpO1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSxcbiAgICAgICAgeiA9IGQuZXh0ZW5kQ2xhc3MgPSBmdW5jdGlvbiAoYiwgbSkge1xuICAgICAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgZi5wcm90b3R5cGUgPSBuZXcgYigpO1xuICAgICAgYShmLnByb3RvdHlwZSwgbSk7XG4gICAgICByZXR1cm4gZjtcbiAgICB9LFxuICAgICAgICB3ID0gZC5wYWQgPSBmdW5jdGlvbiAoYiwgYSwgbSkge1xuICAgICAgcmV0dXJuIEFycmF5KChhIHx8IDIpICsgMSAtIFN0cmluZyhiKS5yZXBsYWNlKFwiLVwiLCBcIlwiKS5sZW5ndGgpLmpvaW4obSB8fCBcIjBcIikgKyBiO1xuICAgIH0sXG4gICAgICAgIEIgPSBkLnJlbGF0aXZlTGVuZ3RoID0gZnVuY3Rpb24gKGIsIGEsIG0pIHtcbiAgICAgIHJldHVybiAvJSQvLnRlc3QoYikgPyBhICogcGFyc2VGbG9hdChiKSAvIDEwMCArIChtIHx8IDApIDogcGFyc2VGbG9hdChiKTtcbiAgICB9LFxuICAgICAgICBMID0gZC53cmFwID0gZnVuY3Rpb24gKGIsIGEsIG0pIHtcbiAgICAgIHZhciBmID0gYlthXTtcblxuICAgICAgYlthXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgYSA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGMgPSB0aGlzO1xuXG4gICAgICAgIGMucHJvY2VlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmLmFwcGx5KGMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHMgOiBhKTtcbiAgICAgICAgfTtcblxuICAgICAgICBiLnVuc2hpZnQoZik7XG4gICAgICAgIGIgPSBtLmFwcGx5KHRoaXMsIGIpO1xuICAgICAgICBjLnByb2NlZWQgPSBudWxsO1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgUSA9IGQuZm9ybWF0ID0gZnVuY3Rpb24gKGIsIGEsIG0pIHtcbiAgICAgIHZhciBmID0gXCJ7XCIsXG4gICAgICAgICAgYyA9ICExLFxuICAgICAgICAgIHAgPSBbXSxcbiAgICAgICAgICBlID0gL2YkLyxcbiAgICAgICAgICB4ID0gL1xcLihbMC05XSkvLFxuICAgICAgICAgIEYgPSBkLmRlZmF1bHRPcHRpb25zLmxhbmcsXG4gICAgICAgICAgQyA9IG0gJiYgbS50aW1lIHx8IGQudGltZTtcblxuICAgICAgZm9yIChtID0gbSAmJiBtLm51bWJlckZvcm1hdHRlciB8fCBUOyBiOykge1xuICAgICAgICB2YXIgbCA9IGIuaW5kZXhPZihmKTtcbiAgICAgICAgaWYgKC0xID09PSBsKSBicmVhaztcbiAgICAgICAgdmFyIGsgPSBiLnNsaWNlKDAsIGwpO1xuXG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgayA9IGsuc3BsaXQoXCI6XCIpO1xuICAgICAgICAgIGYgPSByKGsuc2hpZnQoKSB8fCBcIlwiLCBhKTtcbiAgICAgICAgICBpZiAoay5sZW5ndGggJiYgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGYpIGlmIChrID0gay5qb2luKFwiOlwiKSwgZS50ZXN0KGspKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHBhcnNlSW50KChrLm1hdGNoKHgpIHx8IFtcIlwiLCBcIi0xXCJdKVsxXSwgMTApO1xuICAgICAgICAgICAgbnVsbCAhPT0gZiAmJiAoZiA9IG0oZiwgbiwgRi5kZWNpbWFsUG9pbnQsIC0xIDwgay5pbmRleE9mKFwiLFwiKSA/IEYudGhvdXNhbmRzU2VwIDogXCJcIikpO1xuICAgICAgICAgIH0gZWxzZSBmID0gQy5kYXRlRm9ybWF0KGssIGYpO1xuICAgICAgICAgIHAucHVzaChmKTtcbiAgICAgICAgfSBlbHNlIHAucHVzaChrKTtcblxuICAgICAgICBiID0gYi5zbGljZShsICsgMSk7XG4gICAgICAgIGYgPSAoYyA9ICFjKSA/IFwifVwiIDogXCJ7XCI7XG4gICAgICB9XG5cbiAgICAgIHAucHVzaChiKTtcbiAgICAgIHJldHVybiBwLmpvaW4oXCJcIik7XG4gICAgfSxcbiAgICAgICAgSCA9IGQuZ2V0TWFnbml0dWRlID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyhiKSAvIE1hdGguTE4xMCkpO1xuICAgIH0sXG4gICAgICAgIEsgPSBkLm5vcm1hbGl6ZVRpY2tJbnRlcnZhbCA9IGZ1bmN0aW9uIChiLCBhLCBtLCBmLCBjKSB7XG4gICAgICB2YXIgcCA9IGI7XG4gICAgICBtID0gdShtLCAxKTtcbiAgICAgIHZhciBlID0gYiAvIG07XG4gICAgICBhIHx8IChhID0gYyA/IFsxLCAxLjIsIDEuNSwgMiwgMi41LCAzLCA0LCA1LCA2LCA4LCAxMF0gOiBbMSwgMiwgMi41LCA1LCAxMF0sICExID09PSBmICYmICgxID09PSBtID8gYSA9IGEuZmlsdGVyKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHJldHVybiAwID09PSBiICUgMTtcbiAgICAgIH0pIDogLjEgPj0gbSAmJiAoYSA9IFsxIC8gbV0pKSk7XG5cbiAgICAgIGZvciAoZiA9IDA7IGYgPCBhLmxlbmd0aCAmJiAhKHAgPSBhW2ZdLCBjICYmIHAgKiBtID49IGIgfHwgIWMgJiYgZSA8PSAoYVtmXSArIChhW2YgKyAxXSB8fCBhW2ZdKSkgLyAyKTsgZisrKTtcblxuICAgICAgcmV0dXJuIHAgPSBPKHAgKiBtLCAtTWF0aC5yb3VuZChNYXRoLmxvZyguMDAxKSAvIE1hdGguTE4xMCkpO1xuICAgIH0sXG4gICAgICAgIHAgPSBkLnN0YWJsZVNvcnQgPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgdmFyIG0gPSBiLmxlbmd0aCxcbiAgICAgICAgICBmLFxuICAgICAgICAgIGM7XG5cbiAgICAgIGZvciAoYyA9IDA7IGMgPCBtOyBjKyspIGJbY10uc2FmZUkgPSBjO1xuXG4gICAgICBiLnNvcnQoZnVuY3Rpb24gKGIsIG0pIHtcbiAgICAgICAgZiA9IGEoYiwgbSk7XG4gICAgICAgIHJldHVybiAwID09PSBmID8gYi5zYWZlSSAtIG0uc2FmZUkgOiBmO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAoYyA9IDA7IGMgPCBtOyBjKyspIGRlbGV0ZSBiW2NdLnNhZmVJO1xuICAgIH0sXG4gICAgICAgIGIgPSBkLmFycmF5TWluID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIGZvciAodmFyIGEgPSBiLmxlbmd0aCwgbSA9IGJbMF07IGEtLTspIGJbYV0gPCBtICYmIChtID0gYlthXSk7XG5cbiAgICAgIHJldHVybiBtO1xuICAgIH0sXG4gICAgICAgIEMgPSBkLmFycmF5TWF4ID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIGZvciAodmFyIGEgPSBiLmxlbmd0aCwgbSA9IGJbMF07IGEtLTspIGJbYV0gPiBtICYmIChtID0gYlthXSk7XG5cbiAgICAgIHJldHVybiBtO1xuICAgIH0sXG4gICAgICAgIHggPSBkLmRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgIFkoYiwgZnVuY3Rpb24gKG0sIGYpIHtcbiAgICAgICAgbSAmJiBtICE9PSBhICYmIG0uZGVzdHJveSAmJiBtLmRlc3Ryb3koKTtcbiAgICAgICAgZGVsZXRlIGJbZl07XG4gICAgICB9KTtcbiAgICB9LFxuICAgICAgICBSID0gZC5kaXNjYXJkRWxlbWVudCA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICB2YXIgYSA9IGQuZ2FyYmFnZUJpbjtcbiAgICAgIGEgfHwgKGEgPSB2KFwiZGl2XCIpKTtcbiAgICAgIGIgJiYgYS5hcHBlbmRDaGlsZChiKTtcbiAgICAgIGEuaW5uZXJIVE1MID0gXCJcIjtcbiAgICB9LFxuICAgICAgICBPID0gZC5jb3JyZWN0RmxvYXQgPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYi50b1ByZWNpc2lvbihhIHx8IDE0KSk7XG4gICAgfSxcbiAgICAgICAgWCA9IGQuc2V0QW5pbWF0aW9uID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgIGEucmVuZGVyZXIuZ2xvYmFsQW5pbWF0aW9uID0gdShiLCBhLm9wdGlvbnMuY2hhcnQuYW5pbWF0aW9uLCAhMCk7XG4gICAgfSxcbiAgICAgICAgVSA9IGQuYW5pbU9iamVjdCA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICByZXR1cm4gaChiKSA/IGcoYikgOiB7XG4gICAgICAgIGR1cmF0aW9uOiBiID8gNTAwIDogMFxuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBtID0gZC50aW1lVW5pdHMgPSB7XG4gICAgICBtaWxsaXNlY29uZDogMSxcbiAgICAgIHNlY29uZDogMUUzLFxuICAgICAgbWludXRlOiA2RTQsXG4gICAgICBob3VyOiAzNkU1LFxuICAgICAgZGF5OiA4NjRFNSxcbiAgICAgIHdlZWs6IDYwNDhFNSxcbiAgICAgIG1vbnRoOiAyNDE5MkU1LFxuICAgICAgeWVhcjogMzE0NDk2RTVcbiAgICB9LFxuICAgICAgICBUID0gZC5udW1iZXJGb3JtYXQgPSBmdW5jdGlvbiAoYiwgYSwgbSwgZikge1xuICAgICAgYiA9ICtiIHx8IDA7XG4gICAgICBhID0gK2E7XG4gICAgICB2YXIgYyA9IGQuZGVmYXVsdE9wdGlvbnMubGFuZyxcbiAgICAgICAgICBwID0gKGIudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikuc3BsaXQoXCJlXCIpWzBdLmxlbmd0aCxcbiAgICAgICAgICBlID0gYi50b1N0cmluZygpLnNwbGl0KFwiZVwiKTtcbiAgICAgIGlmICgtMSA9PT0gYSkgYSA9IE1hdGgubWluKHAsIDIwKTtlbHNlIGlmICghUChhKSkgYSA9IDI7ZWxzZSBpZiAoYSAmJiBlWzFdICYmIDAgPiBlWzFdKSB7XG4gICAgICAgIHZhciB4ID0gYSArICtlWzFdO1xuICAgICAgICAwIDw9IHggPyAoZVswXSA9ICgrZVswXSkudG9FeHBvbmVudGlhbCh4KS5zcGxpdChcImVcIilbMF0sIGEgPSB4KSA6IChlWzBdID0gZVswXS5zcGxpdChcIi5cIilbMF0gfHwgMCwgYiA9IDIwID4gYSA/IChlWzBdICogTWF0aC5wb3coMTAsIGVbMV0pKS50b0ZpeGVkKGEpIDogMCwgZVsxXSA9IDApO1xuICAgICAgfVxuICAgICAgdmFyIEYgPSAoTWF0aC5hYnMoZVsxXSA/IGVbMF0gOiBiKSArIE1hdGgucG93KDEwLCAtTWF0aC5tYXgoYSwgcCkgLSAxKSkudG9GaXhlZChhKTtcbiAgICAgIHAgPSBTdHJpbmcoeShGKSk7XG4gICAgICB4ID0gMyA8IHAubGVuZ3RoID8gcC5sZW5ndGggJSAzIDogMDtcbiAgICAgIG0gPSB1KG0sIGMuZGVjaW1hbFBvaW50KTtcbiAgICAgIGYgPSB1KGYsIGMudGhvdXNhbmRzU2VwKTtcbiAgICAgIGIgPSAoMCA+IGIgPyBcIi1cIiA6IFwiXCIpICsgKHggPyBwLnN1YnN0cigwLCB4KSArIGYgOiBcIlwiKTtcbiAgICAgIGIgKz0gcC5zdWJzdHIoeCkucmVwbGFjZSgvKFxcZHszfSkoPz1cXGQpL2csIFwiJDFcIiArIGYpO1xuICAgICAgYSAmJiAoYiArPSBtICsgRi5zbGljZSgtYSkpO1xuICAgICAgZVsxXSAmJiAwICE9PSArYiAmJiAoYiArPSBcImVcIiArIGVbMV0pO1xuICAgICAgcmV0dXJuIGI7XG4gICAgfTtcblxuICAgIE1hdGguZWFzZUluT3V0U2luZSA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICByZXR1cm4gLS41ICogKE1hdGguY29zKE1hdGguUEkgKiBiKSAtIDEpO1xuICAgIH07XG5cbiAgICB2YXIgWiA9IGQuZ2V0U3R5bGUgPSBmdW5jdGlvbiAoYiwgYSwgbSkge1xuICAgICAgaWYgKFwid2lkdGhcIiA9PT0gYSkgcmV0dXJuIGEgPSBNYXRoLm1pbihiLm9mZnNldFdpZHRoLCBiLnNjcm9sbFdpZHRoKSwgbSA9IGIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIGIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgsIG0gPCBhICYmIG0gPj0gYSAtIDEgJiYgKGEgPSBNYXRoLmZsb29yKG0pKSwgTWF0aC5tYXgoMCwgYSAtIGQuZ2V0U3R5bGUoYiwgXCJwYWRkaW5nLWxlZnRcIikgLSBkLmdldFN0eWxlKGIsIFwicGFkZGluZy1yaWdodFwiKSk7XG4gICAgICBpZiAoXCJoZWlnaHRcIiA9PT0gYSkgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKGIub2Zmc2V0SGVpZ2h0LCBiLnNjcm9sbEhlaWdodCkgLSBkLmdldFN0eWxlKGIsIFwicGFkZGluZy10b3BcIikgLSBkLmdldFN0eWxlKGIsIFwicGFkZGluZy1ib3R0b21cIikpO1xuICAgICAgQS5nZXRDb21wdXRlZFN0eWxlIHx8IEcoMjcsICEwKTtcbiAgICAgIGlmIChiID0gQS5nZXRDb21wdXRlZFN0eWxlKGIsIHZvaWQgMCkpIGIgPSBiLmdldFByb3BlcnR5VmFsdWUoYSksIHUobSwgXCJvcGFjaXR5XCIgIT09IGEpICYmIChiID0geShiKSk7XG4gICAgICByZXR1cm4gYjtcbiAgICB9LFxuICAgICAgICBjYSA9IGQuaW5BcnJheSA9IGZ1bmN0aW9uIChiLCBhLCBtKSB7XG4gICAgICByZXR1cm4gYS5pbmRleE9mKGIsIG0pO1xuICAgIH0sXG4gICAgICAgIEYgPSBkLmZpbmQgPSBBcnJheS5wcm90b3R5cGUuZmluZCA/IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICByZXR1cm4gYi5maW5kKGEpO1xuICAgIH0gOiBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgdmFyIG0sXG4gICAgICAgICAgZiA9IGIubGVuZ3RoO1xuXG4gICAgICBmb3IgKG0gPSAwOyBtIDwgZjsgbSsrKSBpZiAoYShiW21dLCBtKSkgcmV0dXJuIGJbbV07XG4gICAgfTtcblxuICAgIGQua2V5cyA9IE9iamVjdC5rZXlzO1xuXG4gICAgdmFyIFYgPSBkLm9mZnNldCA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICB2YXIgYSA9IEUuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgYiA9IGIucGFyZW50RWxlbWVudCB8fCBiLnBhcmVudE5vZGUgPyBiLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDoge1xuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDBcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IGIudG9wICsgKEEucGFnZVlPZmZzZXQgfHwgYS5zY3JvbGxUb3ApIC0gKGEuY2xpZW50VG9wIHx8IDApLFxuICAgICAgICBsZWZ0OiBiLmxlZnQgKyAoQS5wYWdlWE9mZnNldCB8fCBhLnNjcm9sbExlZnQpIC0gKGEuY2xpZW50TGVmdCB8fCAwKVxuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBiYSA9IGQuc3RvcCA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICBmb3IgKHZhciBtID0gZC50aW1lcnMubGVuZ3RoOyBtLS07KSBkLnRpbWVyc1ttXS5lbGVtICE9PSBiIHx8IGEgJiYgYSAhPT0gZC50aW1lcnNbbV0ucHJvcCB8fCAoZC50aW1lcnNbbV0uc3RvcHBlZCA9ICEwKTtcbiAgICB9LFxuICAgICAgICBZID0gZC5vYmplY3RFYWNoID0gZnVuY3Rpb24gKGIsIGEsIG0pIHtcbiAgICAgIGZvciAodmFyIGYgaW4gYikgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoYiwgZikgJiYgYS5jYWxsKG0gfHwgYltmXSwgYltmXSwgZiwgYik7XG4gICAgfTtcblxuICAgIFkoe1xuICAgICAgbWFwOiBcIm1hcFwiLFxuICAgICAgZWFjaDogXCJmb3JFYWNoXCIsXG4gICAgICBncmVwOiBcImZpbHRlclwiLFxuICAgICAgcmVkdWNlOiBcInJlZHVjZVwiLFxuICAgICAgc29tZTogXCJzb21lXCJcbiAgICB9LCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgZFthXSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGVbYl0uYXBwbHkoYSwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICB2YXIgZmEgPSBkLmFkZEV2ZW50ID0gZnVuY3Rpb24gKGIsIGEsIG0sIGYpIHtcbiAgICAgIHZvaWQgMCA9PT0gZiAmJiAoZiA9IHt9KTtcbiAgICAgIHZhciBjID0gYi5hZGRFdmVudExpc3RlbmVyIHx8IGQuYWRkRXZlbnRMaXN0ZW5lclBvbHlmaWxsO1xuICAgICAgdmFyIHAgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBiICYmIGIucHJvdG90eXBlID8gYi5wcm90b3R5cGUucHJvdG9FdmVudHMgPSBiLnByb3RvdHlwZS5wcm90b0V2ZW50cyB8fCB7fSA6IGIuaGNFdmVudHMgPSBiLmhjRXZlbnRzIHx8IHt9O1xuICAgICAgZC5Qb2ludCAmJiBiIGluc3RhbmNlb2YgZC5Qb2ludCAmJiBiLnNlcmllcyAmJiBiLnNlcmllcy5jaGFydCAmJiAoYi5zZXJpZXMuY2hhcnQucnVuVHJhY2tlckNsaWNrID0gITApO1xuICAgICAgYyAmJiBjLmNhbGwoYiwgYSwgbSwgITEpO1xuICAgICAgcFthXSB8fCAocFthXSA9IFtdKTtcbiAgICAgIHBbYV0ucHVzaCh7XG4gICAgICAgIGZuOiBtLFxuICAgICAgICBvcmRlcjogXCJudW1iZXJcIiA9PT0gdHlwZW9mIGYub3JkZXIgPyBmLm9yZGVyIDogSW5maW5pdHlcbiAgICAgIH0pO1xuICAgICAgcFthXS5zb3J0KGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIHJldHVybiBiLm9yZGVyIC0gYS5vcmRlcjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGEoYiwgYSwgbSk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgICAgIGRhID0gZC5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uIChiLCBhLCBtKSB7XG4gICAgICBmdW5jdGlvbiBmKGEsIG0pIHtcbiAgICAgICAgdmFyIGYgPSBiLnJlbW92ZUV2ZW50TGlzdGVuZXIgfHwgZC5yZW1vdmVFdmVudExpc3RlbmVyUG9seWZpbGw7XG4gICAgICAgIGYgJiYgZi5jYWxsKGIsIGEsIG0sICExKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYyhtKSB7XG4gICAgICAgIHZhciBjO1xuXG4gICAgICAgIGlmIChiLm5vZGVOYW1lKSB7XG4gICAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgIHZhciBwID0ge307XG4gICAgICAgICAgICBwW2FdID0gITA7XG4gICAgICAgICAgfSBlbHNlIHAgPSBtO1xuXG4gICAgICAgICAgWShwLCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgICAgaWYgKG1bYV0pIGZvciAoYyA9IG1bYV0ubGVuZ3RoOyBjLS07KSBmKGEsIG1bYV1bY10uZm4pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwO1xuICAgICAgW1wicHJvdG9FdmVudHNcIiwgXCJoY0V2ZW50c1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChlLCB4KSB7XG4gICAgICAgIHZhciBGID0gKHggPSB4ID8gYiA6IGIucHJvdG90eXBlKSAmJiB4W2VdO1xuICAgICAgICBGICYmIChhID8gKHAgPSBGW2FdIHx8IFtdLCBtID8gKEZbYV0gPSBwLmZpbHRlcihmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHJldHVybiBtICE9PSBiLmZuO1xuICAgICAgICB9KSwgZihhLCBtKSkgOiAoYyhGKSwgRlthXSA9IFtdKSkgOiAoYyhGKSwgeFtlXSA9IHt9KSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgICAgICBoYSA9IGQuZmlyZUV2ZW50ID0gZnVuY3Rpb24gKGIsIG0sIGYsIGMpIHtcbiAgICAgIHZhciBwO1xuICAgICAgZiA9IGYgfHwge307XG5cbiAgICAgIGlmIChFLmNyZWF0ZUV2ZW50ICYmIChiLmRpc3BhdGNoRXZlbnQgfHwgYi5maXJlRXZlbnQpKSB7XG4gICAgICAgIHZhciBlID0gRS5jcmVhdGVFdmVudChcIkV2ZW50c1wiKTtcbiAgICAgICAgZS5pbml0RXZlbnQobSwgITAsICEwKTtcbiAgICAgICAgYShlLCBmKTtcbiAgICAgICAgYi5kaXNwYXRjaEV2ZW50ID8gYi5kaXNwYXRjaEV2ZW50KGUpIDogYi5maXJlRXZlbnQobSwgZSk7XG4gICAgICB9IGVsc2UgZi50YXJnZXQgfHwgYShmLCB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZi5kZWZhdWx0UHJldmVudGVkID0gITA7XG4gICAgICAgIH0sXG4gICAgICAgIHRhcmdldDogYixcbiAgICAgICAgdHlwZTogbVxuICAgICAgfSksIGZ1bmN0aW9uIChhLCBtKSB7XG4gICAgICAgIHZvaWQgMCA9PT0gYSAmJiAoYSA9IFtdKTtcbiAgICAgICAgdm9pZCAwID09PSBtICYmIChtID0gW10pO1xuICAgICAgICB2YXIgYyA9IDAsXG4gICAgICAgICAgICBlID0gMCxcbiAgICAgICAgICAgIHggPSBhLmxlbmd0aCArIG0ubGVuZ3RoO1xuXG4gICAgICAgIGZvciAocCA9IDA7IHAgPCB4OyBwKyspICExID09PSAoYVtjXSA/IG1bZV0gPyBhW2NdLm9yZGVyIDw9IG1bZV0ub3JkZXIgPyBhW2MrK10gOiBtW2UrK10gOiBhW2MrK10gOiBtW2UrK10pLmZuLmNhbGwoYiwgZikgJiYgZi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfShiLnByb3RvRXZlbnRzICYmIGIucHJvdG9FdmVudHNbbV0sIGIuaGNFdmVudHMgJiYgYi5oY0V2ZW50c1ttXSk7XG5cbiAgICAgIGMgJiYgIWYuZGVmYXVsdFByZXZlbnRlZCAmJiBjLmNhbGwoYiwgZik7XG4gICAgfSxcbiAgICAgICAgaWEgPSBkLmFuaW1hdGUgPSBmdW5jdGlvbiAoYiwgYSwgbSkge1xuICAgICAgdmFyIGYsXG4gICAgICAgICAgYyA9IFwiXCIsXG4gICAgICAgICAgcCxcbiAgICAgICAgICBlO1xuXG4gICAgICBpZiAoIWgobSkpIHtcbiAgICAgICAgdmFyIHggPSBhcmd1bWVudHM7XG4gICAgICAgIG0gPSB7XG4gICAgICAgICAgZHVyYXRpb246IHhbMl0sXG4gICAgICAgICAgZWFzaW5nOiB4WzNdLFxuICAgICAgICAgIGNvbXBsZXRlOiB4WzRdXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIFAobS5kdXJhdGlvbikgfHwgKG0uZHVyYXRpb24gPSA0MDApO1xuICAgICAgbS5lYXNpbmcgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBtLmVhc2luZyA/IG0uZWFzaW5nIDogTWF0aFttLmVhc2luZ10gfHwgTWF0aC5lYXNlSW5PdXRTaW5lO1xuICAgICAgbS5jdXJBbmltID0gZyhhKTtcbiAgICAgIFkoYSwgZnVuY3Rpb24gKHgsIEYpIHtcbiAgICAgICAgYmEoYiwgRik7XG4gICAgICAgIGUgPSBuZXcgSihiLCBtLCBGKTtcbiAgICAgICAgcCA9IG51bGw7XG4gICAgICAgIFwiZFwiID09PSBGID8gKGUucGF0aHMgPSBlLmluaXRQYXRoKGIsIGIuZCwgYS5kKSwgZS50b0QgPSBhLmQsIGYgPSAwLCBwID0gMSkgOiBiLmF0dHIgPyBmID0gYi5hdHRyKEYpIDogKGYgPSBwYXJzZUZsb2F0KFooYiwgRikpIHx8IDAsIFwib3BhY2l0eVwiICE9PSBGICYmIChjID0gXCJweFwiKSk7XG4gICAgICAgIHAgfHwgKHAgPSB4KTtcbiAgICAgICAgcCAmJiBwLm1hdGNoICYmIHAubWF0Y2goXCJweFwiKSAmJiAocCA9IHAucmVwbGFjZSgvcHgvZywgXCJcIikpO1xuICAgICAgICBlLnJ1bihmLCBwLCBjKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgICAgIGphID0gZC5zZXJpZXNUeXBlID0gZnVuY3Rpb24gKGIsIGEsIG0sIGYsIGMpIHtcbiAgICAgIHZhciBwID0gZC5nZXRPcHRpb25zKCksXG4gICAgICAgICAgZSA9IGQuc2VyaWVzVHlwZXM7XG4gICAgICBwLnBsb3RPcHRpb25zW2JdID0gZyhwLnBsb3RPcHRpb25zW2FdLCBtKTtcbiAgICAgIGVbYl0gPSB6KGVbYV0gfHwgZnVuY3Rpb24gKCkge30sIGYpO1xuICAgICAgZVtiXS5wcm90b3R5cGUudHlwZSA9IGI7XG4gICAgICBjICYmIChlW2JdLnByb3RvdHlwZS5wb2ludENsYXNzID0geihkLlBvaW50LCBjKSk7XG4gICAgICByZXR1cm4gZVtiXTtcbiAgICB9LFxuICAgICAgICBlYSA9IGQudW5pcXVlS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGIgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOSksXG4gICAgICAgICAgYSA9IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJoaWdoY2hhcnRzLVwiICsgYiArIFwiLVwiICsgYSsrO1xuICAgICAgfTtcbiAgICB9KCksXG4gICAgICAgIGthID0gZC5pc0Z1bmN0aW9uID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBiO1xuICAgIH07XG5cbiAgICBBLmpRdWVyeSAmJiAoQS5qUXVlcnkuZm4uaGlnaGNoYXJ0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBiID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXNbMF0pIHJldHVybiBiWzBdID8gKG5ldyBkW3QoYlswXSkgPyBiLnNoaWZ0KCkgOiBcIkNoYXJ0XCJdKHRoaXNbMF0sIGJbMF0sIGJbMV0pLCB0aGlzKSA6IE1bVyh0aGlzWzBdLCBcImRhdGEtaGlnaGNoYXJ0cy1jaGFydFwiKV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIEZ4OiBKLFxuICAgICAgYWRkRXZlbnQ6IGZhLFxuICAgICAgYW5pbWF0ZTogaWEsXG4gICAgICBhbmltT2JqZWN0OiBVLFxuICAgICAgYXJyYXlNYXg6IEMsXG4gICAgICBhcnJheU1pbjogYixcbiAgICAgIGF0dHI6IFcsXG4gICAgICBjbGFtcDogZnVuY3Rpb24gKGIsIGEsIG0pIHtcbiAgICAgICAgcmV0dXJuIGIgPiBhID8gYiA8IG0gPyBiIDogbSA6IGE7XG4gICAgICB9LFxuICAgICAgY2xlYXJUaW1lb3V0OiBmLFxuICAgICAgY29ycmVjdEZsb2F0OiBPLFxuICAgICAgY3JlYXRlRWxlbWVudDogdixcbiAgICAgIGNzczogbCxcbiAgICAgIGRlZmluZWQ6IGMsXG4gICAgICBkZXN0cm95T2JqZWN0UHJvcGVydGllczogeCxcbiAgICAgIGRpc2NhcmRFbGVtZW50OiBSLFxuICAgICAgZXJhc2U6IGUsXG4gICAgICBlcnJvcjogRyxcbiAgICAgIGV4dGVuZDogYSxcbiAgICAgIGV4dGVuZENsYXNzOiB6LFxuICAgICAgZmluZDogRixcbiAgICAgIGZpcmVFdmVudDogaGEsXG4gICAgICBmb3JtYXQ6IFEsXG4gICAgICBnZXRNYWduaXR1ZGU6IEgsXG4gICAgICBnZXROZXN0ZWRQcm9wZXJ0eTogcixcbiAgICAgIGdldFN0eWxlOiBaLFxuICAgICAgaW5BcnJheTogY2EsXG4gICAgICBpc0FycmF5OiBELFxuICAgICAgaXNDbGFzczogcSxcbiAgICAgIGlzRE9NRWxlbWVudDogTixcbiAgICAgIGlzRnVuY3Rpb246IGthLFxuICAgICAgaXNOdW1iZXI6IFAsXG4gICAgICBpc09iamVjdDogaCxcbiAgICAgIGlzU3RyaW5nOiB0LFxuICAgICAgbWVyZ2U6IGcsXG4gICAgICBub3JtYWxpemVUaWNrSW50ZXJ2YWw6IEssXG4gICAgICBudW1iZXJGb3JtYXQ6IFQsXG4gICAgICBvYmplY3RFYWNoOiBZLFxuICAgICAgb2Zmc2V0OiBWLFxuICAgICAgcGFkOiB3LFxuICAgICAgcGljazogdSxcbiAgICAgIHBJbnQ6IHksXG4gICAgICByZWxhdGl2ZUxlbmd0aDogQixcbiAgICAgIHJlbW92ZUV2ZW50OiBkYSxcbiAgICAgIHNlcmllc1R5cGU6IGphLFxuICAgICAgc2V0QW5pbWF0aW9uOiBYLFxuICAgICAgc3BsYXQ6IGssXG4gICAgICBzdGFibGVTb3J0OiBwLFxuICAgICAgc3RvcDogYmEsXG4gICAgICBzeW5jVGltZW91dDogbixcbiAgICAgIHRpbWVVbml0czogbSxcbiAgICAgIHVuaXF1ZUtleTogZWEsXG4gICAgICB3cmFwOiBMXG4gICAgfTtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9Db2xvci5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZykge1xuICAgIHZhciBXID0gZy5pc051bWJlcixcbiAgICAgICAgdSA9IGcubWVyZ2UsXG4gICAgICAgIHIgPSBnLnBJbnQ7XG5cbiAgICBnID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gZChnKSB7XG4gICAgICAgIHRoaXMucGFyc2VycyA9IFt7XG4gICAgICAgICAgcmVnZXg6IC9yZ2JhXFwoXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XT8oPzpcXC5bMC05XSspPylcXHMqXFwpLyxcbiAgICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBbcihkWzFdKSwgcihkWzJdKSwgcihkWzNdKSwgcGFyc2VGbG9hdChkWzRdLCAxMCldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIHJlZ2V4OiAvcmdiXFwoXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccypcXCkvLFxuICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtyKGRbMV0pLCByKGRbMl0pLCByKGRbM10pLCAxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1dO1xuICAgICAgICB0aGlzLnJnYmEgPSBbXTtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGQpKSByZXR1cm4gbmV3IGQoZyk7XG4gICAgICAgIHRoaXMuaW5pdChnKTtcbiAgICAgIH1cblxuICAgICAgZC5wYXJzZSA9IGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIHJldHVybiBuZXcgZChnKTtcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZykge1xuICAgICAgICB2YXIgQSwgRztcbiAgICAgICAgaWYgKCh0aGlzLmlucHV0ID0gZyA9IGQubmFtZXNbZyAmJiBnLnRvTG93ZXJDYXNlID8gZy50b0xvd2VyQ2FzZSgpIDogXCJcIl0gfHwgZykgJiYgZy5zdG9wcykgdGhpcy5zdG9wcyA9IGcuc3RvcHMubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBkKHRbMV0pO1xuICAgICAgICB9KTtlbHNlIHtcbiAgICAgICAgICBpZiAoZyAmJiBnLmNoYXJBdCAmJiBcIiNcIiA9PT0gZy5jaGFyQXQoKSkge1xuICAgICAgICAgICAgdmFyIHUgPSBnLmxlbmd0aDtcbiAgICAgICAgICAgIGcgPSBwYXJzZUludChnLnN1YnN0cigxKSwgMTYpO1xuICAgICAgICAgICAgNyA9PT0gdSA/IEEgPSBbKGcgJiAxNjcxMTY4MCkgPj4gMTYsIChnICYgNjUyODApID4+IDgsIGcgJiAyNTUsIDFdIDogNCA9PT0gdSAmJiAoQSA9IFsoZyAmIDM4NDApID4+IDQgfCAoZyAmIDM4NDApID4+IDgsIChnICYgMjQwKSA+PiA0IHwgZyAmIDI0MCwgKGcgJiAxNSkgPDwgNCB8IGcgJiAxNSwgMV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghQSkgZm9yIChHID0gdGhpcy5wYXJzZXJzLmxlbmd0aDsgRy0tICYmICFBOykge1xuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLnBhcnNlcnNbR107XG4gICAgICAgICAgICAodSA9IHkucmVnZXguZXhlYyhnKSkgJiYgKEEgPSB5LnBhcnNlKHUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZ2JhID0gQSB8fCBbXTtcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBnID0gdGhpcy5pbnB1dCxcbiAgICAgICAgICAgIEcgPSB0aGlzLnJnYmE7XG5cbiAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiB0aGlzLnN0b3BzKSB7XG4gICAgICAgICAgdmFyIEUgPSB1KGcpO1xuICAgICAgICAgIEUuc3RvcHMgPSBbXS5jb25jYXQoRS5zdG9wcyk7XG4gICAgICAgICAgdGhpcy5zdG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChnLCB0KSB7XG4gICAgICAgICAgICBFLnN0b3BzW3RdID0gW0Uuc3RvcHNbdF1bMF0sIGcuZ2V0KGQpXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIEUgPSBHICYmIFcoR1swXSkgPyBcInJnYlwiID09PSBkIHx8ICFkICYmIDEgPT09IEdbM10gPyBcInJnYihcIiArIEdbMF0gKyBcIixcIiArIEdbMV0gKyBcIixcIiArIEdbMl0gKyBcIilcIiA6IFwiYVwiID09PSBkID8gR1szXSA6IFwicmdiYShcIiArIEcuam9pbihcIixcIikgKyBcIilcIiA6IGc7XG5cbiAgICAgICAgcmV0dXJuIEU7XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS5icmlnaHRlbiA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBnLFxuICAgICAgICAgICAgdSA9IHRoaXMucmdiYTtcbiAgICAgICAgaWYgKHRoaXMuc3RvcHMpIHRoaXMuc3RvcHMuZm9yRWFjaChmdW5jdGlvbiAoZykge1xuICAgICAgICAgIGcuYnJpZ2h0ZW4oZCk7XG4gICAgICAgIH0pO2Vsc2UgaWYgKFcoZCkgJiYgMCAhPT0gZCkgZm9yIChnID0gMDsgMyA+IGc7IGcrKykgdVtnXSArPSByKDI1NSAqIGQpLCAwID4gdVtnXSAmJiAodVtnXSA9IDApLCAyNTUgPCB1W2ddICYmICh1W2ddID0gMjU1KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS5zZXRPcGFjaXR5ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdGhpcy5yZ2JhWzNdID0gZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS50d2VlblRvID0gZnVuY3Rpb24gKGQsIGcpIHtcbiAgICAgICAgdmFyIHUgPSB0aGlzLnJnYmEsXG4gICAgICAgICAgICBBID0gZC5yZ2JhO1xuICAgICAgICBBLmxlbmd0aCAmJiB1ICYmIHUubGVuZ3RoID8gKGQgPSAxICE9PSBBWzNdIHx8IDEgIT09IHVbM10sIGcgPSAoZCA/IFwicmdiYShcIiA6IFwicmdiKFwiKSArIE1hdGgucm91bmQoQVswXSArICh1WzBdIC0gQVswXSkgKiAoMSAtIGcpKSArIFwiLFwiICsgTWF0aC5yb3VuZChBWzFdICsgKHVbMV0gLSBBWzFdKSAqICgxIC0gZykpICsgXCIsXCIgKyBNYXRoLnJvdW5kKEFbMl0gKyAodVsyXSAtIEFbMl0pICogKDEgLSBnKSkgKyAoZCA/IFwiLFwiICsgKEFbM10gKyAodVszXSAtIEFbM10pICogKDEgLSBnKSkgOiBcIlwiKSArIFwiKVwiKSA6IGcgPSBkLmlucHV0IHx8IFwibm9uZVwiO1xuICAgICAgICByZXR1cm4gZztcbiAgICAgIH07XG5cbiAgICAgIGQubmFtZXMgPSB7XG4gICAgICAgIHdoaXRlOiBcIiNmZmZmZmZcIixcbiAgICAgICAgYmxhY2s6IFwiIzAwMDAwMFwiXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfSgpO1xuXG4gICAgZC5Db2xvciA9IGc7XG4gICAgZC5jb2xvciA9IGcucGFyc2U7XG4gICAgcmV0dXJuIGQuQ29sb3I7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvU3ZnUmVuZGVyZXIuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvQ29sb3IuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZywgcikge1xuICAgIHZhciB1ID0gZy5wYXJzZSxcbiAgICAgICAgSSA9IHIuYWRkRXZlbnQsXG4gICAgICAgIE0gPSByLmFuaW1hdGUsXG4gICAgICAgIEUgPSByLmFuaW1PYmplY3QsXG4gICAgICAgIEEgPSByLmF0dHIsXG4gICAgICAgIEcgPSByLmNyZWF0ZUVsZW1lbnQsXG4gICAgICAgIEogPSByLmNzcyxcbiAgICAgICAgeSA9IHIuZGVmaW5lZCxcbiAgICAgICAgdCA9IHIuZGVzdHJveU9iamVjdFByb3BlcnRpZXMsXG4gICAgICAgIEQgPSByLmVyYXNlLFxuICAgICAgICBoID0gci5leHRlbmQsXG4gICAgICAgIE4gPSByLmluQXJyYXksXG4gICAgICAgIHEgPSByLmlzQXJyYXksXG4gICAgICAgIFAgPSByLmlzTnVtYmVyLFxuICAgICAgICBlID0gci5pc09iamVjdCxcbiAgICAgICAgYyA9IHIuaXNTdHJpbmcsXG4gICAgICAgIGsgPSByLm1lcmdlLFxuICAgICAgICBuID0gci5vYmplY3RFYWNoLFxuICAgICAgICBmID0gci5waWNrLFxuICAgICAgICBhID0gci5wSW50LFxuICAgICAgICBsID0gci5yZW1vdmVFdmVudCxcbiAgICAgICAgdiA9IHIuc3BsYXQsXG4gICAgICAgIHogPSByLnN0b3AsXG4gICAgICAgIHcgPSByLnVuaXF1ZUtleSxcbiAgICAgICAgQiA9IGQuY2hhcnRzLFxuICAgICAgICBMID0gZC5kZWcycmFkLFxuICAgICAgICBRID0gZC5kb2MsXG4gICAgICAgIEggPSBkLmhhc1RvdWNoLFxuICAgICAgICBLID0gZC5pc0ZpcmVmb3gsXG4gICAgICAgIHAgPSBkLmlzTVMsXG4gICAgICAgIGIgPSBkLmlzV2ViS2l0LFxuICAgICAgICBDID0gZC5ub29wLFxuICAgICAgICB4ID0gZC5zdmcsXG4gICAgICAgIFIgPSBkLlNWR19OUyxcbiAgICAgICAgTyA9IGQuc3ltYm9sU2l6ZXMsXG4gICAgICAgIFggPSBkLndpbjtcblxuICAgIHZhciBVID0gZC5TVkdFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGgoVS5wcm90b3R5cGUsIHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICBTVkdfTlM6IFIsXG4gICAgICB0ZXh0UHJvcHM6IFwiZGlyZWN0aW9uIGZvbnRTaXplIGZvbnRXZWlnaHQgZm9udEZhbWlseSBmb250U3R5bGUgY29sb3IgbGluZUhlaWdodCB3aWR0aCB0ZXh0QWxpZ24gdGV4dERlY29yYXRpb24gdGV4dE92ZXJmbG93IHRleHRPdXRsaW5lIGN1cnNvclwiLnNwbGl0KFwiIFwiKSxcbiAgICAgIGluaXQ6IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IFwic3BhblwiID09PSBhID8gRyhhKSA6IFEuY3JlYXRlRWxlbWVudE5TKHRoaXMuU1ZHX05TLCBhKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IGI7XG4gICAgICAgIGQuZmlyZUV2ZW50KHRoaXMsIFwiYWZ0ZXJJbml0XCIpO1xuICAgICAgfSxcbiAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uIChiLCBhLCBjKSB7XG4gICAgICAgIHZhciBtID0gRShmKGEsIHRoaXMucmVuZGVyZXIuZ2xvYmFsQW5pbWF0aW9uLCAhMCkpO1xuICAgICAgICBmKFEuaGlkZGVuLCBRLm1zSGlkZGVuLCBRLndlYmtpdEhpZGRlbiwgITEpICYmIChtLmR1cmF0aW9uID0gMCk7XG4gICAgICAgIDAgIT09IG0uZHVyYXRpb24gPyAoYyAmJiAobS5jb21wbGV0ZSA9IGMpLCBNKHRoaXMsIGIsIG0pKSA6ICh0aGlzLmF0dHIoYiwgdm9pZCAwLCBjKSwgbihiLCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIG0uc3RlcCAmJiBtLnN0ZXAuY2FsbCh0aGlzLCBiLCB7XG4gICAgICAgICAgICBwcm9wOiBhLFxuICAgICAgICAgICAgcG9zOiAxXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgY29tcGxleENvbG9yOiBmdW5jdGlvbiAoYiwgYSwgZikge1xuICAgICAgICB2YXIgbSA9IHRoaXMucmVuZGVyZXIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgcCxcbiAgICAgICAgICAgIGUsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgVCxcbiAgICAgICAgICAgIEMsXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdixcbiAgICAgICAgICAgIHosXG4gICAgICAgICAgICBaLFxuICAgICAgICAgICAgTyxcbiAgICAgICAgICAgIFIgPSBbXSxcbiAgICAgICAgICAgIEI7XG4gICAgICAgIGQuZmlyZUV2ZW50KHRoaXMucmVuZGVyZXIsIFwiY29tcGxleENvbG9yXCIsIHtcbiAgICAgICAgICBhcmdzOiBhcmd1bWVudHNcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGIucmFkaWFsR3JhZGllbnQgPyBwID0gXCJyYWRpYWxHcmFkaWVudFwiIDogYi5saW5lYXJHcmFkaWVudCAmJiAocCA9IFwibGluZWFyR3JhZGllbnRcIik7XG4gICAgICAgICAgcCAmJiAoZSA9IGJbcF0sIFQgPSBtLmdyYWRpZW50cywgbCA9IGIuc3RvcHMsIFogPSBmLnJhZGlhbFJlZmVyZW5jZSwgcShlKSAmJiAoYltwXSA9IGUgPSB7XG4gICAgICAgICAgICB4MTogZVswXSxcbiAgICAgICAgICAgIHkxOiBlWzFdLFxuICAgICAgICAgICAgeDI6IGVbMl0sXG4gICAgICAgICAgICB5MjogZVszXSxcbiAgICAgICAgICAgIGdyYWRpZW50VW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIlxuICAgICAgICAgIH0pLCBcInJhZGlhbEdyYWRpZW50XCIgPT09IHAgJiYgWiAmJiAheShlLmdyYWRpZW50VW5pdHMpICYmICh4ID0gZSwgZSA9IGsoZSwgbS5nZXRSYWRpYWxBdHRyKFosIHgpLCB7XG4gICAgICAgICAgICBncmFkaWVudFVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCJcbiAgICAgICAgICB9KSksIG4oZSwgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICAgIFwiaWRcIiAhPT0gYSAmJiBSLnB1c2goYSwgYik7XG4gICAgICAgICAgfSksIG4obCwgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIFIucHVzaChiKTtcbiAgICAgICAgICB9KSwgUiA9IFIuam9pbihcIixcIiksIFRbUl0gPyBPID0gVFtSXS5hdHRyKFwiaWRcIikgOiAoZS5pZCA9IE8gPSB3KCksIFRbUl0gPSBDID0gbS5jcmVhdGVFbGVtZW50KHApLmF0dHIoZSkuYWRkKG0uZGVmcyksIEMucmFkQXR0ciA9IHgsIEMuc3RvcHMgPSBbXSwgbC5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAwID09PSBiWzFdLmluZGV4T2YoXCJyZ2JhXCIpID8gKGMgPSB1KGJbMV0pLCB2ID0gYy5nZXQoXCJyZ2JcIiksIHogPSBjLmdldChcImFcIikpIDogKHYgPSBiWzFdLCB6ID0gMSk7XG4gICAgICAgICAgICBiID0gbS5jcmVhdGVFbGVtZW50KFwic3RvcFwiKS5hdHRyKHtcbiAgICAgICAgICAgICAgb2Zmc2V0OiBiWzBdLFxuICAgICAgICAgICAgICBcInN0b3AtY29sb3JcIjogdixcbiAgICAgICAgICAgICAgXCJzdG9wLW9wYWNpdHlcIjogelxuICAgICAgICAgICAgfSkuYWRkKEMpO1xuICAgICAgICAgICAgQy5zdG9wcy5wdXNoKGIpO1xuICAgICAgICAgIH0pKSwgQiA9IFwidXJsKFwiICsgbS51cmwgKyBcIiNcIiArIE8gKyBcIilcIiwgZi5zZXRBdHRyaWJ1dGUoYSwgQiksIGYuZ3JhZGllbnQgPSBSLCBiLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEI7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGFwcGx5VGV4dE91dGxpbmU6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgbTtcbiAgICAgICAgLTEgIT09IGIuaW5kZXhPZihcImNvbnRyYXN0XCIpICYmIChiID0gYi5yZXBsYWNlKC9jb250cmFzdC9nLCB0aGlzLnJlbmRlcmVyLmdldENvbnRyYXN0KGEuc3R5bGUuZmlsbCkpKTtcbiAgICAgICAgYiA9IGIuc3BsaXQoXCIgXCIpO1xuICAgICAgICB2YXIgZiA9IGJbYi5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoKG0gPSBiWzBdKSAmJiBcIm5vbmVcIiAhPT0gbSAmJiBkLnN2Zykge1xuICAgICAgICAgIHRoaXMuZmFrZVRTID0gITA7XG4gICAgICAgICAgYiA9IFtdLnNsaWNlLmNhbGwoYS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRzcGFuXCIpKTtcbiAgICAgICAgICB0aGlzLnlTZXR0ZXIgPSB0aGlzLnhTZXR0ZXI7XG4gICAgICAgICAgbSA9IG0ucmVwbGFjZSgvKF5bXFxkXFwuXSspKC4qPykkL2csIGZ1bmN0aW9uIChiLCBhLCBtKSB7XG4gICAgICAgICAgICByZXR1cm4gMiAqIGEgKyBtO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMucmVtb3ZlVGV4dE91dGxpbmUoYik7XG4gICAgICAgICAgdmFyIGMgPSBhLnRleHRDb250ZW50ID8gL15bXFx1MDU5MS1cXHUwNjVGXFx1MDY2QS1cXHUwN0ZGXFx1RkIxRC1cXHVGREZEXFx1RkU3MC1cXHVGRUZDXS8udGVzdChhLnRleHRDb250ZW50KSA6ICExO1xuICAgICAgICAgIHZhciBwID0gYS5maXJzdENoaWxkO1xuICAgICAgICAgIGIuZm9yRWFjaChmdW5jdGlvbiAoYiwgZSkge1xuICAgICAgICAgICAgMCA9PT0gZSAmJiAoYi5zZXRBdHRyaWJ1dGUoXCJ4XCIsIGEuZ2V0QXR0cmlidXRlKFwieFwiKSksIGUgPSBhLmdldEF0dHJpYnV0ZShcInlcIiksIGIuc2V0QXR0cmlidXRlKFwieVwiLCBlIHx8IDApLCBudWxsID09PSBlICYmIGEuc2V0QXR0cmlidXRlKFwieVwiLCAwKSk7XG4gICAgICAgICAgICBlID0gYi5jbG9uZU5vZGUoITApO1xuICAgICAgICAgICAgQShjICYmICFLID8gYiA6IGUsIHtcbiAgICAgICAgICAgICAgXCJjbGFzc1wiOiBcImhpZ2hjaGFydHMtdGV4dC1vdXRsaW5lXCIsXG4gICAgICAgICAgICAgIGZpbGw6IGYsXG4gICAgICAgICAgICAgIHN0cm9rZTogZixcbiAgICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogbSxcbiAgICAgICAgICAgICAgXCJzdHJva2UtbGluZWpvaW5cIjogXCJyb3VuZFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGEuaW5zZXJ0QmVmb3JlKGUsIHApO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGMgJiYgSyAmJiBiWzBdICYmIChiID0gYlswXS5jbG9uZU5vZGUoITApLCBiLnRleHRDb250ZW50ID0gXCIgXCIsIGEuaW5zZXJ0QmVmb3JlKGIsIHApKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlbW92ZVRleHRPdXRsaW5lOiBmdW5jdGlvbiAoYikge1xuICAgICAgICBmb3IgKHZhciBhID0gYi5sZW5ndGgsIG07IGEtLTspIG0gPSBiW2FdLCBcImhpZ2hjaGFydHMtdGV4dC1vdXRsaW5lXCIgPT09IG0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgJiYgRChiLCB0aGlzLmVsZW1lbnQucmVtb3ZlQ2hpbGQobSkpO1xuICAgICAgfSxcbiAgICAgIHN5bWJvbEN1c3RvbUF0dHJpYnM6IFwieCB5IHdpZHRoIGhlaWdodCByIHN0YXJ0IGVuZCBpbm5lclIgYW5jaG9yWCBhbmNob3JZIHJvdW5kZWRcIi5zcGxpdChcIiBcIiksXG4gICAgICBhdHRyOiBmdW5jdGlvbiAoYiwgYSwgZiwgYykge1xuICAgICAgICB2YXIgbSA9IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgIHAsXG4gICAgICAgICAgICBlID0gdGhpcyxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICBDLFxuICAgICAgICAgICAgbCA9IHRoaXMuc3ltYm9sQ3VzdG9tQXR0cmlicztcblxuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGIgJiYgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGEpIHtcbiAgICAgICAgICB2YXIgVCA9IGI7XG4gICAgICAgICAgYiA9IHt9O1xuICAgICAgICAgIGJbVF0gPSBhO1xuICAgICAgICB9XG5cbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGIgPyBlID0gKHRoaXNbYiArIFwiR2V0dGVyXCJdIHx8IHRoaXMuX2RlZmF1bHRHZXR0ZXIpLmNhbGwodGhpcywgYiwgbSkgOiAobihiLCBmdW5jdGlvbiAoYSwgZikge1xuICAgICAgICAgIHggPSAhMTtcbiAgICAgICAgICBjIHx8IHoodGhpcywgZik7XG4gICAgICAgICAgdGhpcy5zeW1ib2xOYW1lICYmIC0xICE9PSBOKGYsIGwpICYmIChwIHx8ICh0aGlzLnN5bWJvbEF0dHIoYiksIHAgPSAhMCksIHggPSAhMCk7XG4gICAgICAgICAgIXRoaXMucm90YXRpb24gfHwgXCJ4XCIgIT09IGYgJiYgXCJ5XCIgIT09IGYgfHwgKHRoaXMuZG9UcmFuc2Zvcm0gPSAhMCk7XG4gICAgICAgICAgeCB8fCAoQyA9IHRoaXNbZiArIFwiU2V0dGVyXCJdIHx8IHRoaXMuX2RlZmF1bHRTZXR0ZXIsIEMuY2FsbCh0aGlzLCBhLCBmLCBtKSwgIXRoaXMuc3R5bGVkTW9kZSAmJiB0aGlzLnNoYWRvd3MgJiYgL14od2lkdGh8aGVpZ2h0fHZpc2liaWxpdHl8eHx5fGR8dHJhbnNmb3JtfGN4fGN5fHIpJC8udGVzdChmKSAmJiB0aGlzLnVwZGF0ZVNoYWRvd3MoZiwgYSwgQykpO1xuICAgICAgICB9LCB0aGlzKSwgdGhpcy5hZnRlclNldHRlcnMoKSk7XG4gICAgICAgIGYgJiYgZi5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0sXG4gICAgICBhZnRlclNldHRlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kb1RyYW5zZm9ybSAmJiAodGhpcy51cGRhdGVUcmFuc2Zvcm0oKSwgdGhpcy5kb1RyYW5zZm9ybSA9ICExKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVTaGFkb3dzOiBmdW5jdGlvbiAoYiwgYSwgZikge1xuICAgICAgICBmb3IgKHZhciBtID0gdGhpcy5zaGFkb3dzLCBjID0gbS5sZW5ndGg7IGMtLTspIGYuY2FsbChtW2NdLCBcImhlaWdodFwiID09PSBiID8gTWF0aC5tYXgoYSAtIChtW2NdLmN1dEhlaWdodCB8fCAwKSwgMCkgOiBcImRcIiA9PT0gYiA/IHRoaXMuZCA6IGEsIGIsIG1bY10pO1xuICAgICAgfSxcbiAgICAgIGFkZENsYXNzOiBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICB2YXIgbSA9IGEgPyBcIlwiIDogdGhpcy5hdHRyKFwiY2xhc3NcIikgfHwgXCJcIjtcbiAgICAgICAgYiA9IChiIHx8IFwiXCIpLnNwbGl0KC8gL2cpLnJlZHVjZShmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIC0xID09PSBtLmluZGV4T2YoYSkgJiYgYi5wdXNoKGEpO1xuICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9LCBtID8gW21dIDogW10pLmpvaW4oXCIgXCIpO1xuICAgICAgICBiICE9PSBtICYmIHRoaXMuYXR0cihcImNsYXNzXCIsIGIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBoYXNDbGFzczogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIC0xICE9PSAodGhpcy5hdHRyKFwiY2xhc3NcIikgfHwgXCJcIikuc3BsaXQoXCIgXCIpLmluZGV4T2YoYik7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoXCJjbGFzc1wiLCAodGhpcy5hdHRyKFwiY2xhc3NcIikgfHwgXCJcIikucmVwbGFjZShjKGIpID8gbmV3IFJlZ0V4cChcIiA/XCIgKyBiICsgXCIgP1wiKSA6IGIsIFwiXCIpKTtcbiAgICAgIH0sXG4gICAgICBzeW1ib2xBdHRyOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIFwieCB5IHIgc3RhcnQgZW5kIHdpZHRoIGhlaWdodCBpbm5lclIgYW5jaG9yWCBhbmNob3JZIGNsb2Nrd2lzZVwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgYVttXSA9IGYoYlttXSwgYVttXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhLmF0dHIoe1xuICAgICAgICAgIGQ6IGEucmVuZGVyZXIuc3ltYm9sc1thLnN5bWJvbE5hbWVdKGEueCwgYS55LCBhLndpZHRoLCBhLmhlaWdodCwgYSlcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgY2xpcDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cihcImNsaXAtcGF0aFwiLCBiID8gXCJ1cmwoXCIgKyB0aGlzLnJlbmRlcmVyLnVybCArIFwiI1wiICsgYi5pZCArIFwiKVwiIDogXCJub25lXCIpO1xuICAgICAgfSxcbiAgICAgIGNyaXNwOiBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICBhID0gYSB8fCBiLnN0cm9rZVdpZHRoIHx8IDA7XG4gICAgICAgIHZhciBtID0gTWF0aC5yb3VuZChhKSAlIDIgLyAyO1xuICAgICAgICBiLnggPSBNYXRoLmZsb29yKGIueCB8fCB0aGlzLnggfHwgMCkgKyBtO1xuICAgICAgICBiLnkgPSBNYXRoLmZsb29yKGIueSB8fCB0aGlzLnkgfHwgMCkgKyBtO1xuICAgICAgICBiLndpZHRoID0gTWF0aC5mbG9vcigoYi53aWR0aCB8fCB0aGlzLndpZHRoIHx8IDApIC0gMiAqIG0pO1xuICAgICAgICBiLmhlaWdodCA9IE1hdGguZmxvb3IoKGIuaGVpZ2h0IHx8IHRoaXMuaGVpZ2h0IHx8IDApIC0gMiAqIG0pO1xuICAgICAgICB5KGIuc3Ryb2tlV2lkdGgpICYmIChiLnN0cm9rZVdpZHRoID0gYSk7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSxcbiAgICAgIGNzczogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLnN0eWxlcyxcbiAgICAgICAgICAgIGYgPSB7fSxcbiAgICAgICAgICAgIGMgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgICBwID0gXCJcIixcbiAgICAgICAgICAgIGUgPSAhbSxcbiAgICAgICAgICAgIEMgPSBbXCJ0ZXh0T3V0bGluZVwiLCBcInRleHRPdmVyZmxvd1wiLCBcIndpZHRoXCJdO1xuICAgICAgICBiICYmIGIuY29sb3IgJiYgKGIuZmlsbCA9IGIuY29sb3IpO1xuICAgICAgICBtICYmIG4oYiwgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBiICE9PSBtW2FdICYmIChmW2FdID0gYiwgZSA9ICEwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICBtICYmIChiID0gaChtLCBmKSk7XG4gICAgICAgICAgaWYgKGIpIGlmIChudWxsID09PSBiLndpZHRoIHx8IFwiYXV0b1wiID09PSBiLndpZHRoKSBkZWxldGUgdGhpcy50ZXh0V2lkdGg7ZWxzZSBpZiAoXCJ0ZXh0XCIgPT09IGMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAmJiBiLndpZHRoKSB2YXIgbCA9IHRoaXMudGV4dFdpZHRoID0gYShiLndpZHRoKTtcbiAgICAgICAgICB0aGlzLnN0eWxlcyA9IGI7XG4gICAgICAgICAgbCAmJiAheCAmJiB0aGlzLnJlbmRlcmVyLmZvckV4cG9ydCAmJiBkZWxldGUgYi53aWR0aDtcblxuICAgICAgICAgIGlmIChjLm5hbWVzcGFjZVVSSSA9PT0gdGhpcy5TVkdfTlMpIHtcbiAgICAgICAgICAgIHZhciBrID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiLVwiICsgYS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbihiLCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgICAgICAtMSA9PT0gQy5pbmRleE9mKGEpICYmIChwICs9IGEucmVwbGFjZSgvKFtBLVpdKS9nLCBrKSArIFwiOlwiICsgYiArIFwiO1wiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcCAmJiBBKGMsIFwic3R5bGVcIiwgcCk7XG4gICAgICAgICAgfSBlbHNlIEooYywgYik7XG5cbiAgICAgICAgICB0aGlzLmFkZGVkICYmIChcInRleHRcIiA9PT0gdGhpcy5lbGVtZW50Lm5vZGVOYW1lICYmIHRoaXMucmVuZGVyZXIuYnVpbGRUZXh0KHRoaXMpLCBiICYmIGIudGV4dE91dGxpbmUgJiYgdGhpcy5hcHBseVRleHRPdXRsaW5lKGIudGV4dE91dGxpbmUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGdldFN0eWxlOiBmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gWC5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudCB8fCB0aGlzLCBcIlwiKS5nZXRQcm9wZXJ0eVZhbHVlKGIpO1xuICAgICAgfSxcbiAgICAgIHN0cm9rZVdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJlci5zdHlsZWRNb2RlKSByZXR1cm4gdGhpc1tcInN0cm9rZS13aWR0aFwiXSB8fCAwO1xuICAgICAgICB2YXIgYiA9IHRoaXMuZ2V0U3R5bGUoXCJzdHJva2Utd2lkdGhcIiksXG4gICAgICAgICAgICBmID0gMDtcbiAgICAgICAgaWYgKGIuaW5kZXhPZihcInB4XCIpID09PSBiLmxlbmd0aCAtIDIpIGYgPSBhKGIpO2Vsc2UgaWYgKFwiXCIgIT09IGIpIHtcbiAgICAgICAgICB2YXIgYyA9IFEuY3JlYXRlRWxlbWVudE5TKFIsIFwicmVjdFwiKTtcbiAgICAgICAgICBBKGMsIHtcbiAgICAgICAgICAgIHdpZHRoOiBiLFxuICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgIGYgPSBjLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgICBjLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9LFxuICAgICAgb246IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIHZhciBtLFxuICAgICAgICAgICAgZixcbiAgICAgICAgICAgIGMgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgICBwO1xuICAgICAgICBIICYmIFwiY2xpY2tcIiA9PT0gYiA/IChjLm9udG91Y2hzdGFydCA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgbSA9IGIudG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICAgIGYgPSBiLnRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgfSwgYy5vbnRvdWNoZW5kID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBtICYmIDQgPD0gTWF0aC5zcXJ0KE1hdGgucG93KG0gLSBiLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFgsIDIpICsgTWF0aC5wb3coZiAtIGIuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WSwgMikpIHx8IGEuY2FsbChjLCBiKTtcbiAgICAgICAgICBwID0gITA7XG4gICAgICAgICAgYi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9LCBjLm9uY2xpY2sgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHAgfHwgYS5jYWxsKGMsIGIpO1xuICAgICAgICB9KSA6IGNbXCJvblwiICsgYl0gPSBhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBzZXRSYWRpYWxSZWZlcmVuY2U6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5yZW5kZXJlci5ncmFkaWVudHNbdGhpcy5lbGVtZW50LmdyYWRpZW50XTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnJhZGlhbFJlZmVyZW5jZSA9IGI7XG4gICAgICAgIGEgJiYgYS5yYWRBdHRyICYmIGEuYW5pbWF0ZSh0aGlzLnJlbmRlcmVyLmdldFJhZGlhbEF0dHIoYiwgYS5yYWRBdHRyKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cih7XG4gICAgICAgICAgdHJhbnNsYXRlWDogYixcbiAgICAgICAgICB0cmFuc2xhdGVZOiBhXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGludmVydDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdGhpcy5pbnZlcnRlZCA9IGI7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMudHJhbnNsYXRlWCB8fCAwLFxuICAgICAgICAgICAgYSA9IHRoaXMudHJhbnNsYXRlWSB8fCAwLFxuICAgICAgICAgICAgYyA9IHRoaXMuc2NhbGVYLFxuICAgICAgICAgICAgcCA9IHRoaXMuc2NhbGVZLFxuICAgICAgICAgICAgZSA9IHRoaXMuaW52ZXJ0ZWQsXG4gICAgICAgICAgICB4ID0gdGhpcy5yb3RhdGlvbixcbiAgICAgICAgICAgIEMgPSB0aGlzLm1hdHJpeCxcbiAgICAgICAgICAgIGwgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIGUgJiYgKGIgKz0gdGhpcy53aWR0aCwgYSArPSB0aGlzLmhlaWdodCk7XG4gICAgICAgIGIgPSBbXCJ0cmFuc2xhdGUoXCIgKyBiICsgXCIsXCIgKyBhICsgXCIpXCJdO1xuICAgICAgICB5KEMpICYmIGIucHVzaChcIm1hdHJpeChcIiArIEMuam9pbihcIixcIikgKyBcIilcIik7XG4gICAgICAgIGUgPyBiLnB1c2goXCJyb3RhdGUoOTApIHNjYWxlKC0xLDEpXCIpIDogeCAmJiBiLnB1c2goXCJyb3RhdGUoXCIgKyB4ICsgXCIgXCIgKyBmKHRoaXMucm90YXRpb25PcmlnaW5YLCBsLmdldEF0dHJpYnV0ZShcInhcIiksIDApICsgXCIgXCIgKyBmKHRoaXMucm90YXRpb25PcmlnaW5ZLCBsLmdldEF0dHJpYnV0ZShcInlcIikgfHwgMCkgKyBcIilcIik7XG4gICAgICAgICh5KGMpIHx8IHkocCkpICYmIGIucHVzaChcInNjYWxlKFwiICsgZihjLCAxKSArIFwiIFwiICsgZihwLCAxKSArIFwiKVwiKTtcbiAgICAgICAgYi5sZW5ndGggJiYgbC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgYi5qb2luKFwiIFwiKSk7XG4gICAgICB9LFxuICAgICAgdG9Gcm9udDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgYi5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBhbGlnbjogZnVuY3Rpb24gKGIsIGEsIHApIHtcbiAgICAgICAgdmFyIG0sXG4gICAgICAgICAgICBlID0ge307XG4gICAgICAgIHZhciB4ID0gdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgdmFyIEMgPSB4LmFsaWduZWRPYmplY3RzO1xuICAgICAgICB2YXIgbCwgaztcblxuICAgICAgICBpZiAoYikge1xuICAgICAgICAgIGlmICh0aGlzLmFsaWduT3B0aW9ucyA9IGIsIHRoaXMuYWxpZ25CeVRyYW5zbGF0ZSA9IGEsICFwIHx8IGMocCkpIHRoaXMuYWxpZ25UbyA9IG0gPSBwIHx8IFwicmVuZGVyZXJcIiwgRChDLCB0aGlzKSwgQy5wdXNoKHRoaXMpLCBwID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGIgPSB0aGlzLmFsaWduT3B0aW9ucywgYSA9IHRoaXMuYWxpZ25CeVRyYW5zbGF0ZSwgbSA9IHRoaXMuYWxpZ25UbztcblxuICAgICAgICBwID0gZihwLCB4W21dLCB4KTtcbiAgICAgICAgbSA9IGIuYWxpZ247XG4gICAgICAgIHggPSBiLnZlcnRpY2FsQWxpZ247XG4gICAgICAgIEMgPSAocC54IHx8IDApICsgKGIueCB8fCAwKTtcbiAgICAgICAgdmFyIFQgPSAocC55IHx8IDApICsgKGIueSB8fCAwKTtcbiAgICAgICAgXCJyaWdodFwiID09PSBtID8gbCA9IDEgOiBcImNlbnRlclwiID09PSBtICYmIChsID0gMik7XG4gICAgICAgIGwgJiYgKEMgKz0gKHAud2lkdGggLSAoYi53aWR0aCB8fCAwKSkgLyBsKTtcbiAgICAgICAgZVthID8gXCJ0cmFuc2xhdGVYXCIgOiBcInhcIl0gPSBNYXRoLnJvdW5kKEMpO1xuICAgICAgICBcImJvdHRvbVwiID09PSB4ID8gayA9IDEgOiBcIm1pZGRsZVwiID09PSB4ICYmIChrID0gMik7XG4gICAgICAgIGsgJiYgKFQgKz0gKHAuaGVpZ2h0IC0gKGIuaGVpZ2h0IHx8IDApKSAvIGspO1xuICAgICAgICBlW2EgPyBcInRyYW5zbGF0ZVlcIiA6IFwieVwiXSA9IE1hdGgucm91bmQoVCk7XG4gICAgICAgIHRoaXNbdGhpcy5wbGFjZWQgPyBcImFuaW1hdGVcIiA6IFwiYXR0clwiXShlKTtcbiAgICAgICAgdGhpcy5wbGFjZWQgPSAhMDtcbiAgICAgICAgdGhpcy5hbGlnbkF0dHIgPSBlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBnZXRCQm94OiBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICB2YXIgbSxcbiAgICAgICAgICAgIGMgPSB0aGlzLnJlbmRlcmVyLFxuICAgICAgICAgICAgcCA9IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgIGUgPSB0aGlzLnN0eWxlcyxcbiAgICAgICAgICAgIHggPSB0aGlzLnRleHRTdHIsXG4gICAgICAgICAgICBDLFxuICAgICAgICAgICAgbCA9IGMuY2FjaGUsXG4gICAgICAgICAgICBrID0gYy5jYWNoZUtleXMsXG4gICAgICAgICAgICBUID0gcC5uYW1lc3BhY2VVUkkgPT09IHRoaXMuU1ZHX05TO1xuICAgICAgICBhID0gZihhLCB0aGlzLnJvdGF0aW9uLCAwKTtcbiAgICAgICAgdmFyIG4gPSBjLnN0eWxlZE1vZGUgPyBwICYmIFUucHJvdG90eXBlLmdldFN0eWxlLmNhbGwocCwgXCJmb250LXNpemVcIikgOiBlICYmIGUuZm9udFNpemU7XG5cbiAgICAgICAgaWYgKHkoeCkpIHtcbiAgICAgICAgICB2YXIgdiA9IHgudG9TdHJpbmcoKTtcbiAgICAgICAgICAtMSA9PT0gdi5pbmRleE9mKFwiPFwiKSAmJiAodiA9IHYucmVwbGFjZSgvWzAtOV0vZywgXCIwXCIpKTtcbiAgICAgICAgICB2ICs9IFtcIlwiLCBhLCBuLCB0aGlzLnRleHRXaWR0aCwgZSAmJiBlLnRleHRPdmVyZmxvd10uam9pbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdiAmJiAhYiAmJiAobSA9IGxbdl0pO1xuXG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgIGlmIChUIHx8IGMuZm9yRXhwb3J0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAoQyA9IHRoaXMuZmFrZVRTICYmIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAgICAgW10uZm9yRWFjaC5jYWxsKHAucXVlcnlTZWxlY3RvckFsbChcIi5oaWdoY2hhcnRzLXRleHQtb3V0bGluZVwiKSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgIGEuc3R5bGUuZGlzcGxheSA9IGI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pICYmIEMoXCJub25lXCIpLCBtID0gcC5nZXRCQm94ID8gaCh7fSwgcC5nZXRCQm94KCkpIDoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBwLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcC5vZmZzZXRIZWlnaHRcbiAgICAgICAgICAgICAgfSwgQyAmJiBDKFwiXCIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZWEpIHtcbiAgICAgICAgICAgICAgXCJcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFtIHx8IDAgPiBtLndpZHRoKSBtID0ge1xuICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBtID0gdGhpcy5odG1sR2V0QkJveCgpO1xuXG4gICAgICAgICAgYy5pc1NWRyAmJiAoYiA9IG0ud2lkdGgsIGMgPSBtLmhlaWdodCwgVCAmJiAobS5oZWlnaHQgPSBjID0ge1xuICAgICAgICAgICAgXCIxMXB4LDE3XCI6IDE0LFxuICAgICAgICAgICAgXCIxM3B4LDIwXCI6IDE2XG4gICAgICAgICAgfVtlICYmIGUuZm9udFNpemUgKyBcIixcIiArIE1hdGgucm91bmQoYyldIHx8IGMpLCBhICYmIChlID0gYSAqIEwsIG0ud2lkdGggPSBNYXRoLmFicyhjICogTWF0aC5zaW4oZSkpICsgTWF0aC5hYnMoYiAqIE1hdGguY29zKGUpKSwgbS5oZWlnaHQgPSBNYXRoLmFicyhjICogTWF0aC5jb3MoZSkpICsgTWF0aC5hYnMoYiAqIE1hdGguc2luKGUpKSkpO1xuXG4gICAgICAgICAgaWYgKHYgJiYgMCA8IG0uaGVpZ2h0KSB7XG4gICAgICAgICAgICBmb3IgKDsgMjUwIDwgay5sZW5ndGg7KSBkZWxldGUgbFtrLnNoaWZ0KCldO1xuXG4gICAgICAgICAgICBsW3ZdIHx8IGsucHVzaCh2KTtcbiAgICAgICAgICAgIGxbdl0gPSBtO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgICAgfSxcbiAgICAgIHNob3c6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoe1xuICAgICAgICAgIHZpc2liaWxpdHk6IGIgPyBcImluaGVyaXRcIiA6IFwidmlzaWJsZVwiXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGhpZGU6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIGIgPyB0aGlzLmF0dHIoe1xuICAgICAgICAgIHk6IC05OTk5XG4gICAgICAgIH0pIDogdGhpcy5hdHRyKHtcbiAgICAgICAgICB2aXNpYmlsaXR5OiBcImhpZGRlblwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBmYWRlT3V0OiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIGEuYW5pbWF0ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IGIgfHwgMTUwLFxuICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhLmF0dHIoe1xuICAgICAgICAgICAgICB5OiAtOTk5OVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBhZGQ6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5yZW5kZXJlcixcbiAgICAgICAgICAgIG0gPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIGIgJiYgKHRoaXMucGFyZW50R3JvdXAgPSBiKTtcbiAgICAgICAgdGhpcy5wYXJlbnRJbnZlcnRlZCA9IGIgJiYgYi5pbnZlcnRlZDtcbiAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHRoaXMudGV4dFN0ciAmJiBhLmJ1aWxkVGV4dCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRlZCA9ICEwO1xuICAgICAgICBpZiAoIWIgfHwgYi5oYW5kbGVaIHx8IHRoaXMuekluZGV4KSB2YXIgZiA9IHRoaXMuekluZGV4U2V0dGVyKCk7XG4gICAgICAgIGYgfHwgKGIgPyBiLmVsZW1lbnQgOiBhLmJveCkuYXBwZW5kQ2hpbGQobSk7XG4gICAgICAgIGlmICh0aGlzLm9uQWRkKSB0aGlzLm9uQWRkKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHNhZmVSZW1vdmVDaGlsZDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSBiLnBhcmVudE5vZGU7XG4gICAgICAgIGEgJiYgYS5yZW1vdmVDaGlsZChiKTtcbiAgICAgIH0sXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcyxcbiAgICAgICAgICAgIGEgPSBiLmVsZW1lbnQgfHwge30sXG4gICAgICAgICAgICBmID0gYi5yZW5kZXJlcixcbiAgICAgICAgICAgIGMgPSBmLmlzU1ZHICYmIFwiU1BBTlwiID09PSBhLm5vZGVOYW1lICYmIGIucGFyZW50R3JvdXAsXG4gICAgICAgICAgICBwID0gYS5vd25lclNWR0VsZW1lbnQsXG4gICAgICAgICAgICBlID0gYi5jbGlwUGF0aDtcbiAgICAgICAgYS5vbmNsaWNrID0gYS5vbm1vdXNlb3V0ID0gYS5vbm1vdXNlb3ZlciA9IGEub25tb3VzZW1vdmUgPSBhLnBvaW50ID0gbnVsbDtcbiAgICAgICAgeihiKTtcbiAgICAgICAgZSAmJiBwICYmIChbXS5mb3JFYWNoLmNhbGwocC5xdWVyeVNlbGVjdG9yQWxsKFwiW2NsaXAtcGF0aF0sW0NMSVAtUEFUSF1cIiksIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgLTEgPCBiLmdldEF0dHJpYnV0ZShcImNsaXAtcGF0aFwiKS5pbmRleE9mKGUuZWxlbWVudC5pZCkgJiYgYi5yZW1vdmVBdHRyaWJ1dGUoXCJjbGlwLXBhdGhcIik7XG4gICAgICAgIH0pLCBiLmNsaXBQYXRoID0gZS5kZXN0cm95KCkpO1xuXG4gICAgICAgIGlmIChiLnN0b3BzKSB7XG4gICAgICAgICAgZm9yIChwID0gMDsgcCA8IGIuc3RvcHMubGVuZ3RoOyBwKyspIGIuc3RvcHNbcF0gPSBiLnN0b3BzW3BdLmRlc3Ryb3koKTtcblxuICAgICAgICAgIGIuc3RvcHMgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgYi5zYWZlUmVtb3ZlQ2hpbGQoYSk7XG5cbiAgICAgICAgZm9yIChmLnN0eWxlZE1vZGUgfHwgYi5kZXN0cm95U2hhZG93cygpOyBjICYmIGMuZGl2ICYmIDAgPT09IGMuZGl2LmNoaWxkTm9kZXMubGVuZ3RoOykgYSA9IGMucGFyZW50R3JvdXAsIGIuc2FmZVJlbW92ZUNoaWxkKGMuZGl2KSwgZGVsZXRlIGMuZGl2LCBjID0gYTtcblxuICAgICAgICBiLmFsaWduVG8gJiYgRChmLmFsaWduZWRPYmplY3RzLCBiKTtcbiAgICAgICAgbihiLCBmdW5jdGlvbiAoYSwgbSkge1xuICAgICAgICAgIGJbbV0gJiYgYlttXS5wYXJlbnRHcm91cCA9PT0gYiAmJiBiW21dLmRlc3Ryb3kgJiYgYlttXS5kZXN0cm95KCk7XG4gICAgICAgICAgZGVsZXRlIGJbbV07XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHNoYWRvdzogZnVuY3Rpb24gKGIsIGEsIGMpIHtcbiAgICAgICAgdmFyIG0gPSBbXSxcbiAgICAgICAgICAgIHAsXG4gICAgICAgICAgICBlID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBpZiAoIWIpIHRoaXMuZGVzdHJveVNoYWRvd3MoKTtlbHNlIGlmICghdGhpcy5zaGFkb3dzKSB7XG4gICAgICAgICAgdmFyIHggPSBmKGIud2lkdGgsIDMpO1xuICAgICAgICAgIHZhciBDID0gKGIub3BhY2l0eSB8fCAuMTUpIC8geDtcbiAgICAgICAgICB2YXIgbCA9IHRoaXMucGFyZW50SW52ZXJ0ZWQgPyBcIigtMSwtMSlcIiA6IFwiKFwiICsgZihiLm9mZnNldFgsIDEpICsgXCIsIFwiICsgZihiLm9mZnNldFksIDEpICsgXCIpXCI7XG5cbiAgICAgICAgICBmb3IgKHAgPSAxOyBwIDw9IHg7IHArKykge1xuICAgICAgICAgICAgdmFyIGsgPSBlLmNsb25lTm9kZSgwKTtcbiAgICAgICAgICAgIHZhciBuID0gMiAqIHggKyAxIC0gMiAqIHA7XG4gICAgICAgICAgICBBKGssIHtcbiAgICAgICAgICAgICAgc3Ryb2tlOiBiLmNvbG9yIHx8IFwiIzAwMDAwMFwiLFxuICAgICAgICAgICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IEMgKiBwLFxuICAgICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBuLFxuICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlXCIgKyBsLFxuICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBrLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIChrLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpICsgXCIgaGlnaGNoYXJ0cy1zaGFkb3dcIik7XG4gICAgICAgICAgICBjICYmIChBKGssIFwiaGVpZ2h0XCIsIE1hdGgubWF4KEEoaywgXCJoZWlnaHRcIikgLSBuLCAwKSksIGsuY3V0SGVpZ2h0ID0gbik7XG4gICAgICAgICAgICBhID8gYS5lbGVtZW50LmFwcGVuZENoaWxkKGspIDogZS5wYXJlbnROb2RlICYmIGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaywgZSk7XG4gICAgICAgICAgICBtLnB1c2goayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zaGFkb3dzID0gbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBkZXN0cm95U2hhZG93czogZnVuY3Rpb24gKCkge1xuICAgICAgICAodGhpcy5zaGFkb3dzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgdGhpcy5zYWZlUmVtb3ZlQ2hpbGQoYik7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLnNoYWRvd3MgPSB2b2lkIDA7XG4gICAgICB9LFxuICAgICAgeEdldHRlcjogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgXCJjaXJjbGVcIiA9PT0gdGhpcy5lbGVtZW50Lm5vZGVOYW1lICYmIChcInhcIiA9PT0gYiA/IGIgPSBcImN4XCIgOiBcInlcIiA9PT0gYiAmJiAoYiA9IFwiY3lcIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdEdldHRlcihiKTtcbiAgICAgIH0sXG4gICAgICBfZGVmYXVsdEdldHRlcjogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgYiA9IGYodGhpc1tiICsgXCJWYWx1ZVwiXSwgdGhpc1tiXSwgdGhpcy5lbGVtZW50ID8gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShiKSA6IG51bGwsIDApO1xuICAgICAgICAvXltcXC0wLTlcXC5dKyQvLnRlc3QoYikgJiYgKGIgPSBwYXJzZUZsb2F0KGIpKTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9LFxuICAgICAgZFNldHRlcjogZnVuY3Rpb24gKGIsIGEsIGYpIHtcbiAgICAgICAgYiAmJiBiLmpvaW4gJiYgKGIgPSBiLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgLyhOYU58IHsyfXxeJCkvLnRlc3QoYikgJiYgKGIgPSBcIk0gMCAwXCIpO1xuICAgICAgICB0aGlzW2FdICE9PSBiICYmIChmLnNldEF0dHJpYnV0ZShhLCBiKSwgdGhpc1thXSA9IGIpO1xuICAgICAgfSxcbiAgICAgIGRhc2hzdHlsZVNldHRlcjogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGYsXG4gICAgICAgICAgICBjID0gdGhpc1tcInN0cm9rZS13aWR0aFwiXTtcbiAgICAgICAgXCJpbmhlcml0XCIgPT09IGMgJiYgKGMgPSAxKTtcblxuICAgICAgICBpZiAoYiA9IGIgJiYgYi50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgYiA9IGIucmVwbGFjZShcInNob3J0ZGFzaGRvdGRvdFwiLCBcIjMsMSwxLDEsMSwxLFwiKS5yZXBsYWNlKFwic2hvcnRkYXNoZG90XCIsIFwiMywxLDEsMVwiKS5yZXBsYWNlKFwic2hvcnRkb3RcIiwgXCIxLDEsXCIpLnJlcGxhY2UoXCJzaG9ydGRhc2hcIiwgXCIzLDEsXCIpLnJlcGxhY2UoXCJsb25nZGFzaFwiLCBcIjgsMyxcIikucmVwbGFjZSgvZG90L2csIFwiMSwzLFwiKS5yZXBsYWNlKFwiZGFzaFwiLCBcIjQsMyxcIikucmVwbGFjZSgvLCQvLCBcIlwiKS5zcGxpdChcIixcIik7XG5cbiAgICAgICAgICBmb3IgKGYgPSBiLmxlbmd0aDsgZi0tOykgYltmXSA9IGEoYltmXSkgKiBjO1xuXG4gICAgICAgICAgYiA9IGIuam9pbihcIixcIikucmVwbGFjZSgvTmFOL2csIFwibm9uZVwiKTtcbiAgICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBiKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFsaWduU2V0dGVyOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHtcbiAgICAgICAgICBsZWZ0OiBcInN0YXJ0XCIsXG4gICAgICAgICAgY2VudGVyOiBcIm1pZGRsZVwiLFxuICAgICAgICAgIHJpZ2h0OiBcImVuZFwiXG4gICAgICAgIH07XG4gICAgICAgIGFbYl0gJiYgKHRoaXMuYWxpZ25WYWx1ZSA9IGIsIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0ZXh0LWFuY2hvclwiLCBhW2JdKSk7XG4gICAgICB9LFxuICAgICAgb3BhY2l0eVNldHRlcjogZnVuY3Rpb24gKGIsIGEsIGYpIHtcbiAgICAgICAgdGhpc1thXSA9IGI7XG4gICAgICAgIGYuc2V0QXR0cmlidXRlKGEsIGIpO1xuICAgICAgfSxcbiAgICAgIHRpdGxlU2V0dGVyOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRpdGxlXCIpWzBdO1xuICAgICAgICBhIHx8IChhID0gUS5jcmVhdGVFbGVtZW50TlModGhpcy5TVkdfTlMsIFwidGl0bGVcIiksIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChhKSk7XG4gICAgICAgIGEuZmlyc3RDaGlsZCAmJiBhLnJlbW92ZUNoaWxkKGEuZmlyc3RDaGlsZCk7XG4gICAgICAgIGEuYXBwZW5kQ2hpbGQoUS5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoZihiLCBcIlwiKSkucmVwbGFjZSgvPFtePl0qPi9nLCBcIlwiKS5yZXBsYWNlKC8mbHQ7L2csIFwiPFwiKS5yZXBsYWNlKC8mZ3Q7L2csIFwiPlwiKSkpO1xuICAgICAgfSxcbiAgICAgIHRleHRTZXR0ZXI6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIGIgIT09IHRoaXMudGV4dFN0ciAmJiAoZGVsZXRlIHRoaXMuYkJveCwgZGVsZXRlIHRoaXMudGV4dFB4TGVuZ3RoLCB0aGlzLnRleHRTdHIgPSBiLCB0aGlzLmFkZGVkICYmIHRoaXMucmVuZGVyZXIuYnVpbGRUZXh0KHRoaXMpKTtcbiAgICAgIH0sXG4gICAgICBzZXRUZXh0UGF0aDogZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgdmFyIGYgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgICBjID0ge1xuICAgICAgICAgIHRleHRBbmNob3I6IFwidGV4dC1hbmNob3JcIlxuICAgICAgICB9LFxuICAgICAgICAgICAgbSA9ICExLFxuICAgICAgICAgICAgcCA9IHRoaXMudGV4dFBhdGhXcmFwcGVyLFxuICAgICAgICAgICAgZSA9ICFwO1xuICAgICAgICBhID0gayghMCwge1xuICAgICAgICAgIGVuYWJsZWQ6ICEwLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIGR5OiAtNSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBcIjUwJVwiLFxuICAgICAgICAgICAgdGV4dEFuY2hvcjogXCJtaWRkbGVcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSwgYSk7XG4gICAgICAgIHZhciB4ID0gYS5hdHRyaWJ1dGVzO1xuXG4gICAgICAgIGlmIChiICYmIGEgJiYgYS5lbmFibGVkKSB7XG4gICAgICAgICAgcCAmJiBudWxsID09PSBwLmVsZW1lbnQucGFyZW50Tm9kZSA/IChlID0gITAsIHAgPSBwLmRlc3Ryb3koKSkgOiBwICYmIHRoaXMucmVtb3ZlVGV4dE91dGxpbmUuY2FsbChwLnBhcmVudEdyb3VwLCBbXS5zbGljZS5jYWxsKGYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0c3BhblwiKSkpO1xuICAgICAgICAgIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucGFkZGluZyAmJiAoeC5keCA9IC10aGlzLm9wdGlvbnMucGFkZGluZyk7XG4gICAgICAgICAgcCB8fCAodGhpcy50ZXh0UGF0aFdyYXBwZXIgPSBwID0gdGhpcy5yZW5kZXJlci5jcmVhdGVFbGVtZW50KFwidGV4dFBhdGhcIiksIG0gPSAhMCk7XG4gICAgICAgICAgdmFyIGwgPSBwLmVsZW1lbnQ7XG4gICAgICAgICAgKGEgPSBiLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaWRcIikpIHx8IGIuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBhID0gdygpKTtcbiAgICAgICAgICBpZiAoZSkgZm9yIChiID0gZi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRzcGFuXCIpOyBiLmxlbmd0aDspIGJbMF0uc2V0QXR0cmlidXRlKFwieVwiLCAwKSwgUCh4LmR4KSAmJiBiWzBdLnNldEF0dHJpYnV0ZShcInhcIiwgLXguZHgpLCBsLmFwcGVuZENoaWxkKGJbMF0pO1xuICAgICAgICAgIG0gJiYgcC5hZGQoe1xuICAgICAgICAgICAgZWxlbWVudDogdGhpcy50ZXh0ID8gdGhpcy50ZXh0LmVsZW1lbnQgOiBmXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbC5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwgXCJocmVmXCIsIHRoaXMucmVuZGVyZXIudXJsICsgXCIjXCIgKyBhKTtcbiAgICAgICAgICB5KHguZHkpICYmIChsLnBhcmVudE5vZGUuc2V0QXR0cmlidXRlKFwiZHlcIiwgeC5keSksIGRlbGV0ZSB4LmR5KTtcbiAgICAgICAgICB5KHguZHgpICYmIChsLnBhcmVudE5vZGUuc2V0QXR0cmlidXRlKFwiZHhcIiwgeC5keCksIGRlbGV0ZSB4LmR4KTtcbiAgICAgICAgICBuKHgsIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgICBsLnNldEF0dHJpYnV0ZShjW2FdIHx8IGEsIGIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGYucmVtb3ZlQXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuICAgICAgICAgIHRoaXMucmVtb3ZlVGV4dE91dGxpbmUuY2FsbChwLCBbXS5zbGljZS5jYWxsKGYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0c3BhblwiKSkpO1xuICAgICAgICAgIHRoaXMudGV4dCAmJiAhdGhpcy5yZW5kZXJlci5zdHlsZWRNb2RlICYmIHRoaXMuYXR0cih7XG4gICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmFwcGx5VGV4dE91dGxpbmUgPSB0aGlzLnVwZGF0ZVRyYW5zZm9ybSA9IEM7XG4gICAgICAgIH0gZWxzZSBwICYmIChkZWxldGUgdGhpcy51cGRhdGVUcmFuc2Zvcm0sIGRlbGV0ZSB0aGlzLmFwcGx5VGV4dE91dGxpbmUsIHRoaXMuZGVzdHJveVRleHRQYXRoKGYsIGIpLCB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpLCB0aGlzLm9wdGlvbnMucm90YXRpb24gJiYgdGhpcy5hcHBseVRleHRPdXRsaW5lKHRoaXMub3B0aW9ucy5zdHlsZS50ZXh0T3V0bGluZSkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3lUZXh0UGF0aDogZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgdmFyIGYgPSBiLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGV4dFwiKVswXTtcblxuICAgICAgICBpZiAoZikge1xuICAgICAgICAgIGlmIChmLnJlbW92ZUF0dHJpYnV0ZShcImR4XCIpLCBmLnJlbW92ZUF0dHJpYnV0ZShcImR5XCIpLCBhLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJcIiksIGYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0ZXh0UGF0aFwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAoYiA9IHRoaXMudGV4dFBhdGhXcmFwcGVyLmVsZW1lbnQuY2hpbGROb2RlczsgYi5sZW5ndGg7KSBmLmFwcGVuZENoaWxkKGJbMF0pO1xuXG4gICAgICAgICAgICBmLnJlbW92ZUNoaWxkKHRoaXMudGV4dFBhdGhXcmFwcGVyLmVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChiLmdldEF0dHJpYnV0ZShcImR4XCIpIHx8IGIuZ2V0QXR0cmlidXRlKFwiZHlcIikpIGIucmVtb3ZlQXR0cmlidXRlKFwiZHhcIiksIGIucmVtb3ZlQXR0cmlidXRlKFwiZHlcIik7XG5cbiAgICAgICAgdGhpcy50ZXh0UGF0aFdyYXBwZXIgPSB0aGlzLnRleHRQYXRoV3JhcHBlci5kZXN0cm95KCk7XG4gICAgICB9LFxuICAgICAgZmlsbFNldHRlcjogZnVuY3Rpb24gKGIsIGEsIGYpIHtcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGIgPyBmLnNldEF0dHJpYnV0ZShhLCBiKSA6IGIgJiYgdGhpcy5jb21wbGV4Q29sb3IoYiwgYSwgZik7XG4gICAgICB9LFxuICAgICAgdmlzaWJpbGl0eVNldHRlcjogZnVuY3Rpb24gKGIsIGEsIGYpIHtcbiAgICAgICAgXCJpbmhlcml0XCIgPT09IGIgPyBmLnJlbW92ZUF0dHJpYnV0ZShhKSA6IHRoaXNbYV0gIT09IGIgJiYgZi5zZXRBdHRyaWJ1dGUoYSwgYik7XG4gICAgICAgIHRoaXNbYV0gPSBiO1xuICAgICAgfSxcbiAgICAgIHpJbmRleFNldHRlcjogZnVuY3Rpb24gKGIsIGYpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLnJlbmRlcmVyLFxuICAgICAgICAgICAgbSA9IHRoaXMucGFyZW50R3JvdXAsXG4gICAgICAgICAgICBwID0gKG0gfHwgYykuZWxlbWVudCB8fCBjLmJveCxcbiAgICAgICAgICAgIGUgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgICB4ID0gITE7XG4gICAgICAgIGMgPSBwID09PSBjLmJveDtcbiAgICAgICAgdmFyIEMgPSB0aGlzLmFkZGVkO1xuICAgICAgICB2YXIgbDtcbiAgICAgICAgeShiKSA/IChlLnNldEF0dHJpYnV0ZShcImRhdGEtei1pbmRleFwiLCBiKSwgYiA9ICtiLCB0aGlzW2ZdID09PSBiICYmIChDID0gITEpKSA6IHkodGhpc1tmXSkgJiYgZS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXotaW5kZXhcIik7XG4gICAgICAgIHRoaXNbZl0gPSBiO1xuXG4gICAgICAgIGlmIChDKSB7XG4gICAgICAgICAgKGIgPSB0aGlzLnpJbmRleCkgJiYgbSAmJiAobS5oYW5kbGVaID0gITApO1xuICAgICAgICAgIGYgPSBwLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgICBmb3IgKGwgPSBmLmxlbmd0aCAtIDE7IDAgPD0gbCAmJiAheDsgbC0tKSB7XG4gICAgICAgICAgICBtID0gZltsXTtcbiAgICAgICAgICAgIEMgPSBtLmdldEF0dHJpYnV0ZShcImRhdGEtei1pbmRleFwiKTtcbiAgICAgICAgICAgIHZhciBrID0gIXkoQyk7XG4gICAgICAgICAgICBpZiAobSAhPT0gZSkgaWYgKDAgPiBiICYmIGsgJiYgIWMgJiYgIWwpIHAuaW5zZXJ0QmVmb3JlKGUsIGZbbF0pLCB4ID0gITA7ZWxzZSBpZiAoYShDKSA8PSBiIHx8IGsgJiYgKCF5KGIpIHx8IDAgPD0gYikpIHAuaW5zZXJ0QmVmb3JlKGUsIGZbbCArIDFdIHx8IG51bGwpLCB4ID0gITA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeCB8fCAocC5pbnNlcnRCZWZvcmUoZSwgZltjID8gMyA6IDBdIHx8IG51bGwpLCB4ID0gITApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9LFxuICAgICAgX2RlZmF1bHRTZXR0ZXI6IGZ1bmN0aW9uIChiLCBhLCBmKSB7XG4gICAgICAgIGYuc2V0QXR0cmlidXRlKGEsIGIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFUucHJvdG90eXBlLnlHZXR0ZXIgPSBVLnByb3RvdHlwZS54R2V0dGVyO1xuXG4gICAgVS5wcm90b3R5cGUudHJhbnNsYXRlWFNldHRlciA9IFUucHJvdG90eXBlLnRyYW5zbGF0ZVlTZXR0ZXIgPSBVLnByb3RvdHlwZS5yb3RhdGlvblNldHRlciA9IFUucHJvdG90eXBlLnZlcnRpY2FsQWxpZ25TZXR0ZXIgPSBVLnByb3RvdHlwZS5yb3RhdGlvbk9yaWdpblhTZXR0ZXIgPSBVLnByb3RvdHlwZS5yb3RhdGlvbk9yaWdpbllTZXR0ZXIgPSBVLnByb3RvdHlwZS5zY2FsZVhTZXR0ZXIgPSBVLnByb3RvdHlwZS5zY2FsZVlTZXR0ZXIgPSBVLnByb3RvdHlwZS5tYXRyaXhTZXR0ZXIgPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgdGhpc1thXSA9IGI7XG4gICAgICB0aGlzLmRvVHJhbnNmb3JtID0gITA7XG4gICAgfTtcblxuICAgIFUucHJvdG90eXBlW1wic3Ryb2tlLXdpZHRoU2V0dGVyXCJdID0gVS5wcm90b3R5cGUuc3Ryb2tlU2V0dGVyID0gZnVuY3Rpb24gKGIsIGEsIGYpIHtcbiAgICAgIHRoaXNbYV0gPSBiO1xuICAgICAgdGhpcy5zdHJva2UgJiYgdGhpc1tcInN0cm9rZS13aWR0aFwiXSA/IChVLnByb3RvdHlwZS5maWxsU2V0dGVyLmNhbGwodGhpcywgdGhpcy5zdHJva2UsIFwic3Ryb2tlXCIsIGYpLCBmLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCB0aGlzW1wic3Ryb2tlLXdpZHRoXCJdKSwgdGhpcy5oYXNTdHJva2UgPSAhMCkgOiBcInN0cm9rZS13aWR0aFwiID09PSBhICYmIDAgPT09IGIgJiYgdGhpcy5oYXNTdHJva2UgPyAoZi5yZW1vdmVBdHRyaWJ1dGUoXCJzdHJva2VcIiksIHRoaXMuaGFzU3Ryb2tlID0gITEpIDogdGhpcy5yZW5kZXJlci5zdHlsZWRNb2RlICYmIHRoaXNbXCJzdHJva2Utd2lkdGhcIl0gJiYgKGYuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIHRoaXNbXCJzdHJva2Utd2lkdGhcIl0pLCB0aGlzLmhhc1N0cm9rZSA9ICEwKTtcbiAgICB9O1xuXG4gICAgZyA9IGQuU1ZHUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgaChnLnByb3RvdHlwZSwge1xuICAgICAgRWxlbWVudDogVSxcbiAgICAgIFNWR19OUzogUixcbiAgICAgIGluaXQ6IGZ1bmN0aW9uIChhLCBmLCBjLCBwLCBlLCB4LCBDKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5jcmVhdGVFbGVtZW50KFwic3ZnXCIpLmF0dHIoe1xuICAgICAgICAgIHZlcnNpb246IFwiMS4xXCIsXG4gICAgICAgICAgXCJjbGFzc1wiOiBcImhpZ2hjaGFydHMtcm9vdFwiXG4gICAgICAgIH0pO1xuICAgICAgICBDIHx8IG0uY3NzKHRoaXMuZ2V0U3R5bGUocCkpO1xuICAgICAgICBwID0gbS5lbGVtZW50O1xuICAgICAgICBhLmFwcGVuZENoaWxkKHApO1xuICAgICAgICBBKGEsIFwiZGlyXCIsIFwibHRyXCIpO1xuICAgICAgICAtMSA9PT0gYS5pbm5lckhUTUwuaW5kZXhPZihcInhtbG5zXCIpICYmIEEocCwgXCJ4bWxuc1wiLCB0aGlzLlNWR19OUyk7XG4gICAgICAgIHRoaXMuaXNTVkcgPSAhMDtcbiAgICAgICAgdGhpcy5ib3ggPSBwO1xuICAgICAgICB0aGlzLmJveFdyYXBwZXIgPSBtO1xuICAgICAgICB0aGlzLmFsaWduZWRPYmplY3RzID0gW107XG4gICAgICAgIHRoaXMudXJsID0gKEsgfHwgYikgJiYgUS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJhc2VcIikubGVuZ3RoID8gWC5sb2NhdGlvbi5ocmVmLnNwbGl0KFwiI1wiKVswXS5yZXBsYWNlKC88W14+XSo+L2csIFwiXCIpLnJlcGxhY2UoLyhbXFwoJ1xcKV0pL2csIFwiXFxcXCQxXCIpLnJlcGxhY2UoLyAvZywgXCIlMjBcIikgOiBcIlwiO1xuICAgICAgICB0aGlzLmNyZWF0ZUVsZW1lbnQoXCJkZXNjXCIpLmFkZCgpLmVsZW1lbnQuYXBwZW5kQ2hpbGQoUS5jcmVhdGVUZXh0Tm9kZShcIkNyZWF0ZWQgd2l0aCBIaWdoY2hhcnRzIDguMC40XCIpKTtcbiAgICAgICAgdGhpcy5kZWZzID0gdGhpcy5jcmVhdGVFbGVtZW50KFwiZGVmc1wiKS5hZGQoKTtcbiAgICAgICAgdGhpcy5hbGxvd0hUTUwgPSB4O1xuICAgICAgICB0aGlzLmZvckV4cG9ydCA9IGU7XG4gICAgICAgIHRoaXMuc3R5bGVkTW9kZSA9IEM7XG4gICAgICAgIHRoaXMuZ3JhZGllbnRzID0ge307XG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5jYWNoZUtleXMgPSBbXTtcbiAgICAgICAgdGhpcy5pbWdDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuc2V0U2l6ZShmLCBjLCAhMSk7XG4gICAgICAgIHZhciBsO1xuICAgICAgICBLICYmIGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIChmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIEooYSwge1xuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHRvcDogMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGwgPSBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIEooYSwge1xuICAgICAgICAgICAgbGVmdDogTWF0aC5jZWlsKGwubGVmdCkgLSBsLmxlZnQgKyBcInB4XCIsXG4gICAgICAgICAgICB0b3A6IE1hdGguY2VpbChsLnRvcCkgLSBsLnRvcCArIFwicHhcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmKCksIHRoaXMudW5TdWJQaXhlbEZpeCA9IEkoWCwgXCJyZXNpemVcIiwgZikpO1xuICAgICAgfSxcbiAgICAgIGRlZmluaXRpb246IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIGZ1bmN0aW9uIGEoYiwgYykge1xuICAgICAgICAgIHZhciBwO1xuICAgICAgICAgIHYoYikuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgdmFyIG0gPSBmLmNyZWF0ZUVsZW1lbnQoYi50YWdOYW1lKSxcbiAgICAgICAgICAgICAgICBlID0ge307XG4gICAgICAgICAgICBuKGIsIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgICAgIFwidGFnTmFtZVwiICE9PSBhICYmIFwiY2hpbGRyZW5cIiAhPT0gYSAmJiBcInRleHRDb250ZW50XCIgIT09IGEgJiYgKGVbYV0gPSBiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbS5hdHRyKGUpO1xuICAgICAgICAgICAgbS5hZGQoYyB8fCBmLmRlZnMpO1xuICAgICAgICAgICAgYi50ZXh0Q29udGVudCAmJiBtLmVsZW1lbnQuYXBwZW5kQ2hpbGQoUS5jcmVhdGVUZXh0Tm9kZShiLnRleHRDb250ZW50KSk7XG4gICAgICAgICAgICBhKGIuY2hpbGRyZW4gfHwgW10sIG0pO1xuICAgICAgICAgICAgcCA9IG07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhKGIpO1xuICAgICAgfSxcbiAgICAgIGdldFN0eWxlOiBmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZSA9IGgoe1xuICAgICAgICAgIGZvbnRGYW1pbHk6ICdcIkx1Y2lkYSBHcmFuZGVcIiwgXCJMdWNpZGEgU2FucyBVbmljb2RlXCIsIEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWYnLFxuICAgICAgICAgIGZvbnRTaXplOiBcIjEycHhcIlxuICAgICAgICB9LCBiKTtcbiAgICAgIH0sXG4gICAgICBzZXRTdHlsZTogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdGhpcy5ib3hXcmFwcGVyLmNzcyh0aGlzLmdldFN0eWxlKGIpKTtcbiAgICAgIH0sXG4gICAgICBpc0hpZGRlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuYm94V3JhcHBlci5nZXRCQm94KCkud2lkdGg7XG4gICAgICB9LFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMuZGVmcztcbiAgICAgICAgdGhpcy5ib3ggPSBudWxsO1xuICAgICAgICB0aGlzLmJveFdyYXBwZXIgPSB0aGlzLmJveFdyYXBwZXIuZGVzdHJveSgpO1xuICAgICAgICB0KHRoaXMuZ3JhZGllbnRzIHx8IHt9KTtcbiAgICAgICAgdGhpcy5ncmFkaWVudHMgPSBudWxsO1xuICAgICAgICBiICYmICh0aGlzLmRlZnMgPSBiLmRlc3Ryb3koKSk7XG4gICAgICAgIHRoaXMudW5TdWJQaXhlbEZpeCAmJiB0aGlzLnVuU3ViUGl4ZWxGaXgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxpZ25lZE9iamVjdHMgPSBudWxsO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gbmV3IHRoaXMuRWxlbWVudCgpO1xuICAgICAgICBhLmluaXQodGhpcywgYik7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSxcbiAgICAgIGRyYXc6IEMsXG4gICAgICBnZXRSYWRpYWxBdHRyOiBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGN4OiBiWzBdIC0gYlsyXSAvIDIgKyBhLmN4ICogYlsyXSxcbiAgICAgICAgICBjeTogYlsxXSAtIGJbMl0gLyAyICsgYS5jeSAqIGJbMl0sXG4gICAgICAgICAgcjogYS5yICogYlsyXVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRydW5jYXRlOiBmdW5jdGlvbiAoYiwgYSwgZiwgYywgcCwgZSwgeCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMsXG4gICAgICAgICAgICBDID0gYi5yb3RhdGlvbixcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBrID0gYyA/IDEgOiAwLFxuICAgICAgICAgICAgRiA9IChmIHx8IGMpLmxlbmd0aCxcbiAgICAgICAgICAgIG4gPSBGLFxuICAgICAgICAgICAgdiA9IFtdLFxuICAgICAgICAgICAgdyA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYS5maXJzdENoaWxkICYmIGEucmVtb3ZlQ2hpbGQoYS5maXJzdENoaWxkKTtcbiAgICAgICAgICBiICYmIGEuYXBwZW5kQ2hpbGQoUS5jcmVhdGVUZXh0Tm9kZShiKSk7XG4gICAgICAgIH0sXG4gICAgICAgICAgICB6ID0gZnVuY3Rpb24gKGUsIGwpIHtcbiAgICAgICAgICBsID0gbCB8fCBlO1xuICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgdltsXSkgaWYgKGEuZ2V0U3ViU3RyaW5nTGVuZ3RoKSB0cnkge1xuICAgICAgICAgICAgdltsXSA9IHAgKyBhLmdldFN1YlN0cmluZ0xlbmd0aCgwLCBjID8gbCArIDEgOiBsKTtcbiAgICAgICAgICB9IGNhdGNoIChsYSkge1xuICAgICAgICAgICAgXCJcIjtcbiAgICAgICAgICB9IGVsc2UgbS5nZXRTcGFuV2lkdGggJiYgKHcoeChmIHx8IGMsIGUpKSwgdltsXSA9IHAgKyBtLmdldFNwYW5XaWR0aChiLCBhKSk7XG4gICAgICAgICAgcmV0dXJuIHZbbF07XG4gICAgICAgIH0sXG4gICAgICAgICAgICBPO1xuXG4gICAgICAgIGIucm90YXRpb24gPSAwO1xuICAgICAgICB2YXIgVCA9IHooYS50ZXh0Q29udGVudC5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChPID0gcCArIFQgPiBlKSB7XG4gICAgICAgICAgZm9yICg7IGsgPD0gRjspIG4gPSBNYXRoLmNlaWwoKGsgKyBGKSAvIDIpLCBjICYmIChsID0geChjLCBuKSksIFQgPSB6KG4sIGwgJiYgbC5sZW5ndGggLSAxKSwgayA9PT0gRiA/IGsgPSBGICsgMSA6IFQgPiBlID8gRiA9IG4gLSAxIDogayA9IG47XG5cbiAgICAgICAgICAwID09PSBGID8gdyhcIlwiKSA6IGYgJiYgRiA9PT0gZi5sZW5ndGggLSAxIHx8IHcobCB8fCB4KGYgfHwgYywgbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgYyAmJiBjLnNwbGljZSgwLCBuKTtcbiAgICAgICAgYi5hY3R1YWxXaWR0aCA9IFQ7XG4gICAgICAgIGIucm90YXRpb24gPSBDO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH0sXG4gICAgICBlc2NhcGVzOiB7XG4gICAgICAgIFwiJlwiOiBcIiZhbXA7XCIsXG4gICAgICAgIFwiPFwiOiBcIiZsdDtcIixcbiAgICAgICAgXCI+XCI6IFwiJmd0O1wiLFxuICAgICAgICBcIidcIjogXCImIzM5O1wiLFxuICAgICAgICAnXCInOiBcIiZxdW90O1wiXG4gICAgICB9LFxuICAgICAgYnVpbGRUZXh0OiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYyA9IGIuZWxlbWVudCxcbiAgICAgICAgICAgIHAgPSB0aGlzLFxuICAgICAgICAgICAgZSA9IHAuZm9yRXhwb3J0LFxuICAgICAgICAgICAgbSA9IGYoYi50ZXh0U3RyLCBcIlwiKS50b1N0cmluZygpLFxuICAgICAgICAgICAgbCA9IC0xICE9PSBtLmluZGV4T2YoXCI8XCIpLFxuICAgICAgICAgICAgQyA9IGMuY2hpbGROb2RlcyxcbiAgICAgICAgICAgIGssXG4gICAgICAgICAgICB2ID0gQShjLCBcInhcIiksXG4gICAgICAgICAgICB3ID0gYi5zdHlsZXMsXG4gICAgICAgICAgICB6ID0gYi50ZXh0V2lkdGgsXG4gICAgICAgICAgICBPID0gdyAmJiB3LmxpbmVIZWlnaHQsXG4gICAgICAgICAgICBxID0gdyAmJiB3LnRleHRPdXRsaW5lLFxuICAgICAgICAgICAgQiA9IHcgJiYgXCJlbGxpcHNpc1wiID09PSB3LnRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgIGQgPSB3ICYmIFwibm93cmFwXCIgPT09IHcud2hpdGVTcGFjZSxcbiAgICAgICAgICAgIE4gPSB3ICYmIHcuZm9udFNpemUsXG4gICAgICAgICAgICBYLFxuICAgICAgICAgICAgaCA9IEMubGVuZ3RoO1xuICAgICAgICB3ID0geiAmJiAhYi5hZGRlZCAmJiB0aGlzLmJveDtcblxuICAgICAgICB2YXIgTCA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgdmFyIGY7XG4gICAgICAgICAgcC5zdHlsZWRNb2RlIHx8IChmID0gLyhweHxlbSkkLy50ZXN0KGIgJiYgYi5zdHlsZS5mb250U2l6ZSkgPyBiLnN0eWxlLmZvbnRTaXplIDogTiB8fCBwLnN0eWxlLmZvbnRTaXplIHx8IDEyKTtcbiAgICAgICAgICByZXR1cm4gTyA/IGEoTykgOiBwLmZvbnRNZXRyaWNzKGYsIGIuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikgPyBiIDogYykuaDtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIHQgPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIG4ocC5lc2NhcGVzLCBmdW5jdGlvbiAoZiwgYykge1xuICAgICAgICAgICAgYSAmJiAtMSAhPT0gYS5pbmRleE9mKGYpIHx8IChiID0gYi50b1N0cmluZygpLnJlcGxhY2UobmV3IFJlZ0V4cChmLCBcImdcIiksIGMpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIFUgPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIHZhciBmID0gYi5pbmRleE9mKFwiPFwiKTtcbiAgICAgICAgICBiID0gYi5zdWJzdHJpbmcoZiwgYi5pbmRleE9mKFwiPlwiKSAtIGYpO1xuICAgICAgICAgIGYgPSBiLmluZGV4T2YoYSArIFwiPVwiKTtcbiAgICAgICAgICBpZiAoLTEgIT09IGYgJiYgKGYgPSBmICsgYS5sZW5ndGggKyAxLCBhID0gYi5jaGFyQXQoZiksICdcIicgPT09IGEgfHwgXCInXCIgPT09IGEpKSByZXR1cm4gYiA9IGIuc3Vic3RyaW5nKGYgKyAxKSwgYi5zdWJzdHJpbmcoMCwgYi5pbmRleE9mKGEpKTtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIFAgPSAvPGJyLio/Pi9nO1xuXG4gICAgICAgIHZhciBnID0gW20sIEIsIGQsIE8sIHEsIE4sIHpdLmpvaW4oKTtcblxuICAgICAgICBpZiAoZyAhPT0gYi50ZXh0Q2FjaGUpIHtcbiAgICAgICAgICBmb3IgKGIudGV4dENhY2hlID0gZzsgaC0tOykgYy5yZW1vdmVDaGlsZChDW2hdKTtcblxuICAgICAgICAgIGwgfHwgcSB8fCBCIHx8IHogfHwgLTEgIT09IG0uaW5kZXhPZihcIiBcIikgJiYgKCFkIHx8IFAudGVzdChtKSkgPyAodyAmJiB3LmFwcGVuZENoaWxkKGMpLCBsID8gKG0gPSBwLnN0eWxlZE1vZGUgPyBtLnJlcGxhY2UoLzwoYnxzdHJvbmcpPi9nLCAnPHNwYW4gY2xhc3M9XCJoaWdoY2hhcnRzLXN0cm9uZ1wiPicpLnJlcGxhY2UoLzwoaXxlbSk+L2csICc8c3BhbiBjbGFzcz1cImhpZ2hjaGFydHMtZW1waGFzaXplZFwiPicpIDogbS5yZXBsYWNlKC88KGJ8c3Ryb25nKT4vZywgJzxzcGFuIHN0eWxlPVwiZm9udC13ZWlnaHQ6Ym9sZFwiPicpLnJlcGxhY2UoLzwoaXxlbSk+L2csICc8c3BhbiBzdHlsZT1cImZvbnQtc3R5bGU6aXRhbGljXCI+JyksIG0gPSBtLnJlcGxhY2UoLzxhL2csIFwiPHNwYW5cIikucmVwbGFjZSgvPFxcLyhifHN0cm9uZ3xpfGVtfGEpPi9nLCBcIjwvc3Bhbj5cIikuc3BsaXQoUCkpIDogbSA9IFttXSwgbSA9IG0uZmlsdGVyKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIiAhPT0gYjtcbiAgICAgICAgICB9KSwgbS5mb3JFYWNoKGZ1bmN0aW9uIChhLCBmKSB7XG4gICAgICAgICAgICB2YXIgbSA9IDAsXG4gICAgICAgICAgICAgICAgbCA9IDA7XG4gICAgICAgICAgICBhID0gYS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBcIlwiKS5yZXBsYWNlKC88c3Bhbi9nLCBcInx8fDxzcGFuXCIpLnJlcGxhY2UoLzxcXC9zcGFuPi9nLCBcIjwvc3Bhbj58fHxcIik7XG4gICAgICAgICAgICB2YXIgQyA9IGEuc3BsaXQoXCJ8fHxcIik7XG4gICAgICAgICAgICBDLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgaWYgKFwiXCIgIT09IGEgfHwgMSA9PT0gQy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBGID0gUS5jcmVhdGVFbGVtZW50TlMocC5TVkdfTlMsIFwidHNwYW5cIiksXG4gICAgICAgICAgICAgICAgICAgIHcsXG4gICAgICAgICAgICAgICAgICAgIE87XG4gICAgICAgICAgICAgICAgKHcgPSBVKGEsIFwiY2xhc3NcIikpICYmIEEoRiwgXCJjbGFzc1wiLCB3KTtcbiAgICAgICAgICAgICAgICBpZiAodyA9IFUoYSwgXCJzdHlsZVwiKSkgdyA9IHcucmVwbGFjZSgvKDt8IHxeKWNvbG9yKFsgOl0pLywgXCIkMWZpbGwkMlwiKSwgQShGLCBcInN0eWxlXCIsIHcpO1xuICAgICAgICAgICAgICAgIChPID0gVShhLCBcImhyZWZcIikpICYmICFlICYmIChBKEYsIFwib25jbGlja1wiLCAnbG9jYXRpb24uaHJlZj1cIicgKyBPICsgJ1wiJyksIEEoRiwgXCJjbGFzc1wiLCBcImhpZ2hjaGFydHMtYW5jaG9yXCIpLCBwLnN0eWxlZE1vZGUgfHwgSihGLCB7XG4gICAgICAgICAgICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGEgPSB0KGEucmVwbGFjZSgvPFthLXpBLVpcXC9dKC58XFxuKSo/Pi9nLCBcIlwiKSB8fCBcIiBcIik7XG5cbiAgICAgICAgICAgICAgICBpZiAoXCIgXCIgIT09IGEpIHtcbiAgICAgICAgICAgICAgICAgIEYuYXBwZW5kQ2hpbGQoUS5jcmVhdGVUZXh0Tm9kZShhKSk7XG4gICAgICAgICAgICAgICAgICBtID8gbi5keCA9IDAgOiBmICYmIG51bGwgIT09IHYgJiYgKG4ueCA9IHYpO1xuICAgICAgICAgICAgICAgICAgQShGLCBuKTtcbiAgICAgICAgICAgICAgICAgIGMuYXBwZW5kQ2hpbGQoRik7XG4gICAgICAgICAgICAgICAgICAhbSAmJiBYICYmICgheCAmJiBlICYmIEooRiwge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCJcbiAgICAgICAgICAgICAgICAgIH0pLCBBKEYsIFwiZHlcIiwgTChGKSkpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoeikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IGEucmVwbGFjZSgvKFteXFxeXSktL2csIFwiJDEtIFwiKS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgIG4gPSAhZCAmJiAoMSA8IEMubGVuZ3RoIHx8IGYgfHwgMSA8IHEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgTyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBUID0gTChGKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEIpIGsgPSBwLnRydW5jYXRlKGIsIEYsIGEsIHZvaWQgMCwgMCwgTWF0aC5tYXgoMCwgeiAtIHBhcnNlSW50KE4gfHwgMTIsIDEwKSksIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGIuc3Vic3RyaW5nKDAsIGEpICsgXCJcXHUyMDI2XCI7XG4gICAgICAgICAgICAgICAgICAgIH0pO2Vsc2UgaWYgKG4pIGZvciAoOyBxLmxlbmd0aDspIHEubGVuZ3RoICYmICFkICYmIDAgPCBPICYmIChGID0gUS5jcmVhdGVFbGVtZW50TlMoUiwgXCJ0c3BhblwiKSwgQShGLCB7XG4gICAgICAgICAgICAgICAgICAgICAgZHk6IFQsXG4gICAgICAgICAgICAgICAgICAgICAgeDogdlxuICAgICAgICAgICAgICAgICAgICB9KSwgdyAmJiBBKEYsIFwic3R5bGVcIiwgdyksIEYuYXBwZW5kQ2hpbGQoUS5jcmVhdGVUZXh0Tm9kZShxLmpvaW4oXCIgXCIpLnJlcGxhY2UoLy0gL2csIFwiLVwiKSkpLCBjLmFwcGVuZENoaWxkKEYpKSwgcC50cnVuY2F0ZShiLCBGLCBudWxsLCBxLCAwID09PSBPID8gbCA6IDAsIHosIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHEuc2xpY2UoMCwgYSkuam9pbihcIiBcIikucmVwbGFjZSgvLSAvZywgXCItXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KSwgbCA9IGIuYWN0dWFsV2lkdGgsIE8rKztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgbSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBYID0gWCB8fCBjLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgIH0pLCBCICYmIGsgJiYgYi5hdHRyKFwidGl0bGVcIiwgdChiLnRleHRTdHIsIFtcIiZsdDtcIiwgXCImZ3Q7XCJdKSksIHcgJiYgdy5yZW1vdmVDaGlsZChjKSwgcSAmJiBiLmFwcGx5VGV4dE91dGxpbmUgJiYgYi5hcHBseVRleHRPdXRsaW5lKHEpKSA6IGMuYXBwZW5kQ2hpbGQoUS5jcmVhdGVUZXh0Tm9kZSh0KG0pKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXRDb250cmFzdDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgYiA9IHUoYikucmdiYTtcbiAgICAgICAgYlswXSAqPSAxO1xuICAgICAgICBiWzFdICo9IDEuMjtcbiAgICAgICAgYlsyXSAqPSAuNTtcbiAgICAgICAgcmV0dXJuIDQ1OSA8IGJbMF0gKyBiWzFdICsgYlsyXSA/IFwiIzAwMDAwMFwiIDogXCIjRkZGRkZGXCI7XG4gICAgICB9LFxuICAgICAgYnV0dG9uOiBmdW5jdGlvbiAoYiwgYSwgZiwgYywgZSwgeCwgbCwgQywgbiwgdykge1xuICAgICAgICB2YXIgbSA9IHRoaXMubGFiZWwoYiwgYSwgZiwgbiwgbnVsbCwgbnVsbCwgdywgbnVsbCwgXCJidXR0b25cIiksXG4gICAgICAgICAgICBGID0gMCxcbiAgICAgICAgICAgIHYgPSB0aGlzLnN0eWxlZE1vZGU7XG4gICAgICAgIG0uYXR0cihrKHtcbiAgICAgICAgICBwYWRkaW5nOiA4LFxuICAgICAgICAgIHI6IDJcbiAgICAgICAgfSwgZSkpO1xuXG4gICAgICAgIGlmICghdikge1xuICAgICAgICAgIGUgPSBrKHtcbiAgICAgICAgICAgIGZpbGw6IFwiI2Y3ZjdmN1wiLFxuICAgICAgICAgICAgc3Ryb2tlOiBcIiNjY2NjY2NcIixcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDEsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBjb2xvcjogXCIjMzMzMzMzXCIsXG4gICAgICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBlKTtcbiAgICAgICAgICB2YXIgeiA9IGUuc3R5bGU7XG4gICAgICAgICAgZGVsZXRlIGUuc3R5bGU7XG4gICAgICAgICAgeCA9IGsoZSwge1xuICAgICAgICAgICAgZmlsbDogXCIjZTZlNmU2XCJcbiAgICAgICAgICB9LCB4KTtcbiAgICAgICAgICB2YXIgTyA9IHguc3R5bGU7XG4gICAgICAgICAgZGVsZXRlIHguc3R5bGU7XG4gICAgICAgICAgbCA9IGsoZSwge1xuICAgICAgICAgICAgZmlsbDogXCIjZTZlYmY1XCIsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBjb2xvcjogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgbCk7XG4gICAgICAgICAgdmFyIHEgPSBsLnN0eWxlO1xuICAgICAgICAgIGRlbGV0ZSBsLnN0eWxlO1xuICAgICAgICAgIEMgPSBrKGUsIHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIGNvbG9yOiBcIiNjY2NjY2NcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIEMpO1xuICAgICAgICAgIHZhciBSID0gQy5zdHlsZTtcbiAgICAgICAgICBkZWxldGUgQy5zdHlsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIEkobS5lbGVtZW50LCBwID8gXCJtb3VzZW92ZXJcIiA6IFwibW91c2VlbnRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgMyAhPT0gRiAmJiBtLnNldFN0YXRlKDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgSShtLmVsZW1lbnQsIHAgPyBcIm1vdXNlb3V0XCIgOiBcIm1vdXNlbGVhdmVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIDMgIT09IEYgJiYgbS5zZXRTdGF0ZShGKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgMSAhPT0gYiAmJiAobS5zdGF0ZSA9IEYgPSBiKTtcbiAgICAgICAgICBtLnJlbW92ZUNsYXNzKC9oaWdoY2hhcnRzLWJ1dHRvbi0obm9ybWFsfGhvdmVyfHByZXNzZWR8ZGlzYWJsZWQpLykuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWJ1dHRvbi1cIiArIFtcIm5vcm1hbFwiLCBcImhvdmVyXCIsIFwicHJlc3NlZFwiLCBcImRpc2FibGVkXCJdW2IgfHwgMF0pO1xuICAgICAgICAgIHYgfHwgbS5hdHRyKFtlLCB4LCBsLCBDXVtiIHx8IDBdKS5jc3MoW3osIE8sIHEsIFJdW2IgfHwgMF0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHYgfHwgbS5hdHRyKGUpLmNzcyhoKHtcbiAgICAgICAgICBjdXJzb3I6IFwiZGVmYXVsdFwiXG4gICAgICAgIH0sIHopKTtcbiAgICAgICAgcmV0dXJuIG0ub24oXCJjbGlja1wiLCBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIDMgIT09IEYgJiYgYy5jYWxsKG0sIGIpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBjcmlzcExpbmU6IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIGJbMV0gPT09IGJbNF0gJiYgKGJbMV0gPSBiWzRdID0gTWF0aC5yb3VuZChiWzFdKSAtIGEgJSAyIC8gMik7XG4gICAgICAgIGJbMl0gPT09IGJbNV0gJiYgKGJbMl0gPSBiWzVdID0gTWF0aC5yb3VuZChiWzJdKSArIGEgJSAyIC8gMik7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSxcbiAgICAgIHBhdGg6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5zdHlsZWRNb2RlID8ge30gOiB7XG4gICAgICAgICAgZmlsbDogXCJub25lXCJcbiAgICAgICAgfTtcbiAgICAgICAgcShiKSA/IGEuZCA9IGIgOiBlKGIpICYmIGgoYSwgYik7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIpLmF0dHIoYSk7XG4gICAgICB9LFxuICAgICAgY2lyY2xlOiBmdW5jdGlvbiAoYiwgYSwgZikge1xuICAgICAgICBiID0gZShiKSA/IGIgOiBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgYiA/IHt9IDoge1xuICAgICAgICAgIHg6IGIsXG4gICAgICAgICAgeTogYSxcbiAgICAgICAgICByOiBmXG4gICAgICAgIH07XG4gICAgICAgIGEgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIik7XG5cbiAgICAgICAgYS54U2V0dGVyID0gYS55U2V0dGVyID0gZnVuY3Rpb24gKGIsIGEsIGYpIHtcbiAgICAgICAgICBmLnNldEF0dHJpYnV0ZShcImNcIiArIGEsIGIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBhLmF0dHIoYik7XG4gICAgICB9LFxuICAgICAgYXJjOiBmdW5jdGlvbiAoYiwgYSwgZiwgYywgcCwgeCkge1xuICAgICAgICBlKGIpID8gKGMgPSBiLCBhID0gYy55LCBmID0gYy5yLCBiID0gYy54KSA6IGMgPSB7XG4gICAgICAgICAgaW5uZXJSOiBjLFxuICAgICAgICAgIHN0YXJ0OiBwLFxuICAgICAgICAgIGVuZDogeFxuICAgICAgICB9O1xuICAgICAgICBiID0gdGhpcy5zeW1ib2woXCJhcmNcIiwgYiwgYSwgZiwgZiwgYyk7XG4gICAgICAgIGIuciA9IGY7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSxcbiAgICAgIHJlY3Q6IGZ1bmN0aW9uIChiLCBhLCBmLCBjLCBwLCB4KSB7XG4gICAgICAgIHAgPSBlKGIpID8gYi5yIDogcDtcbiAgICAgICAgdmFyIG0gPSB0aGlzLmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIpO1xuICAgICAgICBiID0gZShiKSA/IGIgOiBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgYiA/IHt9IDoge1xuICAgICAgICAgIHg6IGIsXG4gICAgICAgICAgeTogYSxcbiAgICAgICAgICB3aWR0aDogTWF0aC5tYXgoZiwgMCksXG4gICAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChjLCAwKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0eWxlZE1vZGUgfHwgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiB4ICYmIChiLnN0cm9rZVdpZHRoID0geCwgYiA9IG0uY3Jpc3AoYikpLCBiLmZpbGwgPSBcIm5vbmVcIik7XG4gICAgICAgIHAgJiYgKGIuciA9IHApO1xuXG4gICAgICAgIG0uclNldHRlciA9IGZ1bmN0aW9uIChiLCBhLCBmKSB7XG4gICAgICAgICAgbS5yID0gYjtcbiAgICAgICAgICBBKGYsIHtcbiAgICAgICAgICAgIHJ4OiBiLFxuICAgICAgICAgICAgcnk6IGJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBtLnJHZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG0ucjtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbS5hdHRyKGIpO1xuICAgICAgfSxcbiAgICAgIHNldFNpemU6IGZ1bmN0aW9uIChiLCBhLCBjKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5hbGlnbmVkT2JqZWN0cyxcbiAgICAgICAgICAgIGUgPSBwLmxlbmd0aDtcbiAgICAgICAgdGhpcy53aWR0aCA9IGI7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gYTtcblxuICAgICAgICBmb3IgKHRoaXMuYm94V3JhcHBlci5hbmltYXRlKHtcbiAgICAgICAgICB3aWR0aDogYixcbiAgICAgICAgICBoZWlnaHQ6IGFcbiAgICAgICAgfSwge1xuICAgICAgICAgIHN0ZXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cih7XG4gICAgICAgICAgICAgIHZpZXdCb3g6IFwiMCAwIFwiICsgdGhpcy5hdHRyKFwid2lkdGhcIikgKyBcIiBcIiArIHRoaXMuYXR0cihcImhlaWdodFwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogZihjLCAhMCkgPyB2b2lkIDAgOiAwXG4gICAgICAgIH0pOyBlLS07KSBwW2VdLmFsaWduKCk7XG4gICAgICB9LFxuICAgICAgZzogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoXCJnXCIpO1xuICAgICAgICByZXR1cm4gYiA/IGEuYXR0cih7XG4gICAgICAgICAgXCJjbGFzc1wiOiBcImhpZ2hjaGFydHMtXCIgKyBiXG4gICAgICAgIH0pIDogYTtcbiAgICAgIH0sXG4gICAgICBpbWFnZTogZnVuY3Rpb24gKGIsIGEsIGYsIGMsIHAsIGUpIHtcbiAgICAgICAgdmFyIHggPSB7XG4gICAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJub25lXCJcbiAgICAgICAgfSxcbiAgICAgICAgICAgIG0gPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIGIuc2V0QXR0cmlidXRlTlMgPyBiLnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBcImhyZWZcIiwgYSkgOiBiLnNldEF0dHJpYnV0ZShcImhjLXN2Zy1ocmVmXCIsIGEpO1xuICAgICAgICB9LFxuICAgICAgICAgICAgbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgbShDLmVsZW1lbnQsIGIpO1xuICAgICAgICAgIGUuY2FsbChDLCBhKTtcbiAgICAgICAgfTtcblxuICAgICAgICAxIDwgYXJndW1lbnRzLmxlbmd0aCAmJiBoKHgsIHtcbiAgICAgICAgICB4OiBhLFxuICAgICAgICAgIHk6IGYsXG4gICAgICAgICAgd2lkdGg6IGMsXG4gICAgICAgICAgaGVpZ2h0OiBwXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgQyA9IHRoaXMuY3JlYXRlRWxlbWVudChcImltYWdlXCIpLmF0dHIoeCk7XG4gICAgICAgIGUgPyAobShDLmVsZW1lbnQsIFwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBQUFBQ0g1QkFFS0FBRUFMQUFBQUFBQkFBRUFBQUlDVEFFQU93PT1cIiksIHggPSBuZXcgWC5JbWFnZSgpLCBJKHgsIFwibG9hZFwiLCBsKSwgeC5zcmMgPSBiLCB4LmNvbXBsZXRlICYmIGwoe30pKSA6IG0oQy5lbGVtZW50LCBiKTtcbiAgICAgICAgcmV0dXJuIEM7XG4gICAgICB9LFxuICAgICAgc3ltYm9sOiBmdW5jdGlvbiAoYiwgYSwgYywgcCwgZSwgeCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMsXG4gICAgICAgICAgICBsID0gL151cmxcXCgoLio/KVxcKSQvLFxuICAgICAgICAgICAgQyA9IGwudGVzdChiKSxcbiAgICAgICAgICAgIGsgPSAhQyAmJiAodGhpcy5zeW1ib2xzW2JdID8gYiA6IFwiY2lyY2xlXCIpLFxuICAgICAgICAgICAgbiA9IGsgJiYgdGhpcy5zeW1ib2xzW2tdLFxuICAgICAgICAgICAgRiA9IHkoYSkgJiYgbiAmJiBuLmNhbGwodGhpcy5zeW1ib2xzLCBNYXRoLnJvdW5kKGEpLCBNYXRoLnJvdW5kKGMpLCBwLCBlLCB4KTtcblxuICAgICAgICBpZiAobikge1xuICAgICAgICAgIHZhciB3ID0gdGhpcy5wYXRoKEYpO1xuICAgICAgICAgIG0uc3R5bGVkTW9kZSB8fCB3LmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgICBoKHcsIHtcbiAgICAgICAgICAgIHN5bWJvbE5hbWU6IGssXG4gICAgICAgICAgICB4OiBhLFxuICAgICAgICAgICAgeTogYyxcbiAgICAgICAgICAgIHdpZHRoOiBwLFxuICAgICAgICAgICAgaGVpZ2h0OiBlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgeCAmJiBoKHcsIHgpO1xuICAgICAgICB9IGVsc2UgaWYgKEMpIHtcbiAgICAgICAgICB2YXIgdiA9IGIubWF0Y2gobClbMV07XG4gICAgICAgICAgdyA9IHRoaXMuaW1hZ2Uodik7XG4gICAgICAgICAgdy5pbWd3aWR0aCA9IGYoT1t2XSAmJiBPW3ZdLndpZHRoLCB4ICYmIHgud2lkdGgpO1xuICAgICAgICAgIHcuaW1naGVpZ2h0ID0gZihPW3ZdICYmIE9bdl0uaGVpZ2h0LCB4ICYmIHguaGVpZ2h0KTtcblxuICAgICAgICAgIHZhciB6ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdy5hdHRyKHtcbiAgICAgICAgICAgICAgd2lkdGg6IHcud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogdy5oZWlnaHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBbXCJ3aWR0aFwiLCBcImhlaWdodFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICB3W2IgKyBcIlNldHRlclwiXSA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgICAgIHZhciBmID0ge30sXG4gICAgICAgICAgICAgICAgICBjID0gdGhpc1tcImltZ1wiICsgYV0sXG4gICAgICAgICAgICAgICAgICBwID0gXCJ3aWR0aFwiID09PSBhID8gXCJ0cmFuc2xhdGVYXCIgOiBcInRyYW5zbGF0ZVlcIjtcbiAgICAgICAgICAgICAgdGhpc1thXSA9IGI7XG4gICAgICAgICAgICAgIHkoYykgJiYgKHggJiYgXCJ3aXRoaW5cIiA9PT0geC5iYWNrZ3JvdW5kU2l6ZSAmJiB0aGlzLndpZHRoICYmIHRoaXMuaGVpZ2h0ICYmIChjID0gTWF0aC5yb3VuZChjICogTWF0aC5taW4odGhpcy53aWR0aCAvIHRoaXMuaW1nd2lkdGgsIHRoaXMuaGVpZ2h0IC8gdGhpcy5pbWdoZWlnaHQpKSksIHRoaXMuZWxlbWVudCAmJiB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKGEsIGMpLCB0aGlzLmFsaWduQnlUcmFuc2xhdGUgfHwgKGZbcF0gPSAoKHRoaXNbYV0gfHwgMCkgLSBjKSAvIDIsIHRoaXMuYXR0cihmKSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB5KGEpICYmIHcuYXR0cih7XG4gICAgICAgICAgICB4OiBhLFxuICAgICAgICAgICAgeTogY1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHcuaXNJbWcgPSAhMDtcbiAgICAgICAgICB5KHcuaW1nd2lkdGgpICYmIHkody5pbWdoZWlnaHQpID8geigpIDogKHcuYXR0cih7XG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICAgIH0pLCBHKFwiaW1nXCIsIHtcbiAgICAgICAgICAgIG9ubG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgYiA9IEJbbS5jaGFydEluZGV4XTtcbiAgICAgICAgICAgICAgMCA9PT0gdGhpcy53aWR0aCAmJiAoSih0aGlzLCB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgICB0b3A6IFwiLTk5OWVtXCJcbiAgICAgICAgICAgICAgfSksIFEuYm9keS5hcHBlbmRDaGlsZCh0aGlzKSk7XG4gICAgICAgICAgICAgIE9bdl0gPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB3LmltZ3dpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgICAgdy5pbWdoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgICAgdy5lbGVtZW50ICYmIHooKTtcbiAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlICYmIHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgICAgICAgbS5pbWdDb3VudC0tO1xuICAgICAgICAgICAgICBpZiAoIW0uaW1nQ291bnQgJiYgYiAmJiAhYi5oYXNMb2FkZWQpIGIub25sb2FkKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3JjOiB2XG4gICAgICAgICAgfSksIHRoaXMuaW1nQ291bnQrKyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdztcbiAgICAgIH0sXG4gICAgICBzeW1ib2xzOiB7XG4gICAgICAgIGNpcmNsZTogZnVuY3Rpb24gKGIsIGEsIGYsIGMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hcmMoYiArIGYgLyAyLCBhICsgYyAvIDIsIGYgLyAyLCBjIC8gMiwge1xuICAgICAgICAgICAgc3RhcnQ6IC41ICogTWF0aC5QSSxcbiAgICAgICAgICAgIGVuZDogMi41ICogTWF0aC5QSSxcbiAgICAgICAgICAgIG9wZW46ICExXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNxdWFyZTogZnVuY3Rpb24gKGIsIGEsIGYsIGMpIHtcbiAgICAgICAgICByZXR1cm4gW1wiTVwiLCBiLCBhLCBcIkxcIiwgYiArIGYsIGEsIGIgKyBmLCBhICsgYywgYiwgYSArIGMsIFwiWlwiXTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJpYW5nbGU6IGZ1bmN0aW9uIChiLCBhLCBmLCBjKSB7XG4gICAgICAgICAgcmV0dXJuIFtcIk1cIiwgYiArIGYgLyAyLCBhLCBcIkxcIiwgYiArIGYsIGEgKyBjLCBiLCBhICsgYywgXCJaXCJdO1xuICAgICAgICB9LFxuICAgICAgICBcInRyaWFuZ2xlLWRvd25cIjogZnVuY3Rpb24gKGIsIGEsIGYsIGMpIHtcbiAgICAgICAgICByZXR1cm4gW1wiTVwiLCBiLCBhLCBcIkxcIiwgYiArIGYsIGEsIGIgKyBmIC8gMiwgYSArIGMsIFwiWlwiXTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlhbW9uZDogZnVuY3Rpb24gKGIsIGEsIGYsIGMpIHtcbiAgICAgICAgICByZXR1cm4gW1wiTVwiLCBiICsgZiAvIDIsIGEsIFwiTFwiLCBiICsgZiwgYSArIGMgLyAyLCBiICsgZiAvIDIsIGEgKyBjLCBiLCBhICsgYyAvIDIsIFwiWlwiXTtcbiAgICAgICAgfSxcbiAgICAgICAgYXJjOiBmdW5jdGlvbiAoYiwgYSwgYywgcCwgZSkge1xuICAgICAgICAgIHZhciB4ID0gZS5zdGFydCxcbiAgICAgICAgICAgICAgbSA9IGUuciB8fCBjLFxuICAgICAgICAgICAgICBsID0gZS5yIHx8IHAgfHwgYyxcbiAgICAgICAgICAgICAgQyA9IGUuZW5kIC0gLjAwMTtcbiAgICAgICAgICBjID0gZS5pbm5lclI7XG4gICAgICAgICAgcCA9IGYoZS5vcGVuLCAuMDAxID4gTWF0aC5hYnMoZS5lbmQgLSBlLnN0YXJ0IC0gMiAqIE1hdGguUEkpKTtcbiAgICAgICAgICB2YXIgayA9IE1hdGguY29zKHgpLFxuICAgICAgICAgICAgICBuID0gTWF0aC5zaW4oeCksXG4gICAgICAgICAgICAgIHcgPSBNYXRoLmNvcyhDKTtcbiAgICAgICAgICBDID0gTWF0aC5zaW4oQyk7XG4gICAgICAgICAgeCA9IGYoZS5sb25nQXJjLCAuMDAxID4gZS5lbmQgLSB4IC0gTWF0aC5QSSA/IDAgOiAxKTtcbiAgICAgICAgICBtID0gW1wiTVwiLCBiICsgbSAqIGssIGEgKyBsICogbiwgXCJBXCIsIG0sIGwsIDAsIHgsIGYoZS5jbG9ja3dpc2UsIDEpLCBiICsgbSAqIHcsIGEgKyBsICogQ107XG4gICAgICAgICAgeShjKSAmJiBtLnB1c2gocCA/IFwiTVwiIDogXCJMXCIsIGIgKyBjICogdywgYSArIGMgKiBDLCBcIkFcIiwgYywgYywgMCwgeCwgeShlLmNsb2Nrd2lzZSkgPyAxIC0gZS5jbG9ja3dpc2UgOiAwLCBiICsgYyAqIGssIGEgKyBjICogbik7XG4gICAgICAgICAgbS5wdXNoKHAgPyBcIlwiIDogXCJaXCIpO1xuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9LFxuICAgICAgICBjYWxsb3V0OiBmdW5jdGlvbiAoYiwgYSwgZiwgYywgcCkge1xuICAgICAgICAgIHZhciBlID0gTWF0aC5taW4ocCAmJiBwLnIgfHwgMCwgZiwgYyksXG4gICAgICAgICAgICAgIHggPSBlICsgNixcbiAgICAgICAgICAgICAgbCA9IHAgJiYgcC5hbmNob3JYO1xuICAgICAgICAgIHAgPSBwICYmIHAuYW5jaG9yWTtcbiAgICAgICAgICB2YXIgbSA9IFtcIk1cIiwgYiArIGUsIGEsIFwiTFwiLCBiICsgZiAtIGUsIGEsIFwiQ1wiLCBiICsgZiwgYSwgYiArIGYsIGEsIGIgKyBmLCBhICsgZSwgXCJMXCIsIGIgKyBmLCBhICsgYyAtIGUsIFwiQ1wiLCBiICsgZiwgYSArIGMsIGIgKyBmLCBhICsgYywgYiArIGYgLSBlLCBhICsgYywgXCJMXCIsIGIgKyBlLCBhICsgYywgXCJDXCIsIGIsIGEgKyBjLCBiLCBhICsgYywgYiwgYSArIGMgLSBlLCBcIkxcIiwgYiwgYSArIGUsIFwiQ1wiLCBiLCBhLCBiLCBhLCBiICsgZSwgYV07XG4gICAgICAgICAgbCAmJiBsID4gZiA/IHAgPiBhICsgeCAmJiBwIDwgYSArIGMgLSB4ID8gbS5zcGxpY2UoMTMsIDMsIFwiTFwiLCBiICsgZiwgcCAtIDYsIGIgKyBmICsgNiwgcCwgYiArIGYsIHAgKyA2LCBiICsgZiwgYSArIGMgLSBlKSA6IG0uc3BsaWNlKDEzLCAzLCBcIkxcIiwgYiArIGYsIGMgLyAyLCBsLCBwLCBiICsgZiwgYyAvIDIsIGIgKyBmLCBhICsgYyAtIGUpIDogbCAmJiAwID4gbCA/IHAgPiBhICsgeCAmJiBwIDwgYSArIGMgLSB4ID8gbS5zcGxpY2UoMzMsIDMsIFwiTFwiLCBiLCBwICsgNiwgYiAtIDYsIHAsIGIsIHAgLSA2LCBiLCBhICsgZSkgOiBtLnNwbGljZSgzMywgMywgXCJMXCIsIGIsIGMgLyAyLCBsLCBwLCBiLCBjIC8gMiwgYiwgYSArIGUpIDogcCAmJiBwID4gYyAmJiBsID4gYiArIHggJiYgbCA8IGIgKyBmIC0geCA/IG0uc3BsaWNlKDIzLCAzLCBcIkxcIiwgbCArIDYsIGEgKyBjLCBsLCBhICsgYyArIDYsIGwgLSA2LCBhICsgYywgYiArIGUsIGEgKyBjKSA6IHAgJiYgMCA+IHAgJiYgbCA+IGIgKyB4ICYmIGwgPCBiICsgZiAtIHggJiYgbS5zcGxpY2UoMywgMywgXCJMXCIsIGwgLSA2LCBhLCBsLCBhIC0gNiwgbCArIDYsIGEsIGYgLSBlLCBhKTtcbiAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNsaXBSZWN0OiBmdW5jdGlvbiAoYiwgYSwgZiwgYykge1xuICAgICAgICB2YXIgcCA9IHcoKSArIFwiLVwiLFxuICAgICAgICAgICAgZSA9IHRoaXMuY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIpLmF0dHIoe1xuICAgICAgICAgIGlkOiBwXG4gICAgICAgIH0pLmFkZCh0aGlzLmRlZnMpO1xuICAgICAgICBiID0gdGhpcy5yZWN0KGIsIGEsIGYsIGMsIDApLmFkZChlKTtcbiAgICAgICAgYi5pZCA9IHA7XG4gICAgICAgIGIuY2xpcFBhdGggPSBlO1xuICAgICAgICBiLmNvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9LFxuICAgICAgdGV4dDogZnVuY3Rpb24gKGIsIGEsIGYsIGMpIHtcbiAgICAgICAgdmFyIHAgPSB7fTtcbiAgICAgICAgaWYgKGMgJiYgKHRoaXMuYWxsb3dIVE1MIHx8ICF0aGlzLmZvckV4cG9ydCkpIHJldHVybiB0aGlzLmh0bWwoYiwgYSwgZik7XG4gICAgICAgIHAueCA9IE1hdGgucm91bmQoYSB8fCAwKTtcbiAgICAgICAgZiAmJiAocC55ID0gTWF0aC5yb3VuZChmKSk7XG4gICAgICAgIHkoYikgJiYgKHAudGV4dCA9IGIpO1xuICAgICAgICBiID0gdGhpcy5jcmVhdGVFbGVtZW50KFwidGV4dFwiKS5hdHRyKHApO1xuICAgICAgICBjIHx8IChiLnhTZXR0ZXIgPSBmdW5jdGlvbiAoYiwgYSwgZikge1xuICAgICAgICAgIHZhciBjID0gZi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRzcGFuXCIpLFxuICAgICAgICAgICAgICBwID0gZi5nZXRBdHRyaWJ1dGUoYSksXG4gICAgICAgICAgICAgIGU7XG5cbiAgICAgICAgICBmb3IgKGUgPSAwOyBlIDwgYy5sZW5ndGg7IGUrKykge1xuICAgICAgICAgICAgdmFyIHggPSBjW2VdO1xuICAgICAgICAgICAgeC5nZXRBdHRyaWJ1dGUoYSkgPT09IHAgJiYgeC5zZXRBdHRyaWJ1dGUoYSwgYik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZi5zZXRBdHRyaWJ1dGUoYSwgYik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0sXG4gICAgICBmb250TWV0cmljczogZnVuY3Rpb24gKGIsIGYpIHtcbiAgICAgICAgYiA9ICF0aGlzLnN0eWxlZE1vZGUgJiYgL3B4Ly50ZXN0KGIpIHx8ICFYLmdldENvbXB1dGVkU3R5bGUgPyBiIHx8IGYgJiYgZi5zdHlsZSAmJiBmLnN0eWxlLmZvbnRTaXplIHx8IHRoaXMuc3R5bGUgJiYgdGhpcy5zdHlsZS5mb250U2l6ZSA6IGYgJiYgVS5wcm90b3R5cGUuZ2V0U3R5bGUuY2FsbChmLCBcImZvbnQtc2l6ZVwiKTtcbiAgICAgICAgYiA9IC9weC8udGVzdChiKSA/IGEoYikgOiAxMjtcbiAgICAgICAgZiA9IDI0ID4gYiA/IGIgKyAzIDogTWF0aC5yb3VuZCgxLjIgKiBiKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBmLFxuICAgICAgICAgIGI6IE1hdGgucm91bmQoLjggKiBmKSxcbiAgICAgICAgICBmOiBiXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgcm90Q29ycjogZnVuY3Rpb24gKGIsIGEsIGYpIHtcbiAgICAgICAgdmFyIGMgPSBiO1xuICAgICAgICBhICYmIGYgJiYgKGMgPSBNYXRoLm1heChjICogTWF0aC5jb3MoYSAqIEwpLCA0KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogLWIgLyAzICogTWF0aC5zaW4oYSAqIEwpLFxuICAgICAgICAgIHk6IGNcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBsYWJlbDogZnVuY3Rpb24gKGIsIGEsIGYsIGMsIHAsIGUsIHgsIEMsIG4pIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLFxuICAgICAgICAgICAgdyA9IG0uc3R5bGVkTW9kZSxcbiAgICAgICAgICAgIHYgPSBtLmcoXCJidXR0b25cIiAhPT0gbiAmJiBcImxhYmVsXCIpLFxuICAgICAgICAgICAgRiA9IHYudGV4dCA9IG0udGV4dChcIlwiLCAwLCAwLCB4KS5hdHRyKHtcbiAgICAgICAgICB6SW5kZXg6IDFcbiAgICAgICAgfSksXG4gICAgICAgICAgICB6LFxuICAgICAgICAgICAgTyxcbiAgICAgICAgICAgIHEgPSAwLFxuICAgICAgICAgICAgUiA9IDMsXG4gICAgICAgICAgICBCID0gMCxcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBOLFxuICAgICAgICAgICAgWCxcbiAgICAgICAgICAgIFYsXG4gICAgICAgICAgICBMLFxuICAgICAgICAgICAgdCA9IHt9LFxuICAgICAgICAgICAgVCxcbiAgICAgICAgICAgIGcsXG4gICAgICAgICAgICBRID0gL151cmxcXCgoLio/KVxcKSQvLnRlc3QoYyksXG4gICAgICAgICAgICBIID0gdyB8fCBRLFxuICAgICAgICAgICAgSyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdyA/IHouc3Ryb2tlV2lkdGgoKSAlIDIgLyAyIDogKFQgPyBwYXJzZUludChULCAxMCkgOiAwKSAlIDIgLyAyO1xuICAgICAgICB9O1xuXG4gICAgICAgIG4gJiYgdi5hZGRDbGFzcyhcImhpZ2hjaGFydHMtXCIgKyBuKTtcblxuICAgICAgICB2YXIgYmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGIgPSBGLmVsZW1lbnQuc3R5bGUsXG4gICAgICAgICAgICAgIGEgPSB7fTtcbiAgICAgICAgICBPID0gKFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBkIHx8IFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBOIHx8IEwpICYmIHkoRi50ZXh0U3RyKSAmJiBGLmdldEJCb3goKTtcbiAgICAgICAgICB2LndpZHRoID0gKGQgfHwgTy53aWR0aCB8fCAwKSArIDIgKiBSICsgQjtcbiAgICAgICAgICB2LmhlaWdodCA9IChOIHx8IE8uaGVpZ2h0IHx8IDApICsgMiAqIFI7XG4gICAgICAgICAgZyA9IFIgKyBNYXRoLm1pbihtLmZvbnRNZXRyaWNzKGIgJiYgYi5mb250U2l6ZSwgRikuYiwgTyA/IE8uaGVpZ2h0IDogSW5maW5pdHkpO1xuICAgICAgICAgIEggJiYgKHogfHwgKHYuYm94ID0geiA9IG0uc3ltYm9sc1tjXSB8fCBRID8gbS5zeW1ib2woYykgOiBtLnJlY3QoKSwgei5hZGRDbGFzcygoXCJidXR0b25cIiA9PT0gbiA/IFwiXCIgOiBcImhpZ2hjaGFydHMtbGFiZWwtYm94XCIpICsgKG4gPyBcIiBoaWdoY2hhcnRzLVwiICsgbiArIFwiLWJveFwiIDogXCJcIikpLCB6LmFkZCh2KSwgYiA9IEsoKSwgYS54ID0gYiwgYS55ID0gKEMgPyAtZyA6IDApICsgYiksIGEud2lkdGggPSBNYXRoLnJvdW5kKHYud2lkdGgpLCBhLmhlaWdodCA9IE1hdGgucm91bmQodi5oZWlnaHQpLCB6LmF0dHIoaChhLCB0KSksIHQgPSB7fSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGIgPSBCICsgUjtcbiAgICAgICAgICB2YXIgYSA9IEMgPyAwIDogZztcbiAgICAgICAgICB5KGQpICYmIE8gJiYgKFwiY2VudGVyXCIgPT09IEwgfHwgXCJyaWdodFwiID09PSBMKSAmJiAoYiArPSB7XG4gICAgICAgICAgICBjZW50ZXI6IC41LFxuICAgICAgICAgICAgcmlnaHQ6IDFcbiAgICAgICAgICB9W0xdICogKGQgLSBPLndpZHRoKSk7XG4gICAgICAgICAgaWYgKGIgIT09IEYueCB8fCBhICE9PSBGLnkpIEYuYXR0cihcInhcIiwgYiksIEYuaGFzQm94V2lkdGhDaGFuZ2VkICYmIChPID0gRi5nZXRCQm94KCEwKSwgYmEoKSksIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBhICYmIEYuYXR0cihcInlcIiwgYSk7XG4gICAgICAgICAgRi54ID0gYjtcbiAgICAgICAgICBGLnkgPSBhO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBZID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICB6ID8gei5hdHRyKGIsIGEpIDogdFtiXSA9IGE7XG4gICAgICAgIH07XG5cbiAgICAgICAgdi5vbkFkZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBGLmFkZCh2KTtcbiAgICAgICAgICB2LmF0dHIoe1xuICAgICAgICAgICAgdGV4dDogYiB8fCAwID09PSBiID8gYiA6IFwiXCIsXG4gICAgICAgICAgICB4OiBhLFxuICAgICAgICAgICAgeTogZlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHogJiYgeShwKSAmJiB2LmF0dHIoe1xuICAgICAgICAgICAgYW5jaG9yWDogcCxcbiAgICAgICAgICAgIGFuY2hvclk6IGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2LndpZHRoU2V0dGVyID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBkID0gUChiKSA/IGIgOiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHYuaGVpZ2h0U2V0dGVyID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBOID0gYjtcbiAgICAgICAgfTtcblxuICAgICAgICB2W1widGV4dC1hbGlnblNldHRlclwiXSA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgTCA9IGI7XG4gICAgICAgIH07XG5cbiAgICAgICAgdi5wYWRkaW5nU2V0dGVyID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICB5KGIpICYmIGIgIT09IFIgJiYgKFIgPSB2LnBhZGRpbmcgPSBiLCB1KCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHYucGFkZGluZ0xlZnRTZXR0ZXIgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHkoYikgJiYgYiAhPT0gQiAmJiAoQiA9IGIsIHUoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdi5hbGlnblNldHRlciA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYiA9IHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICBjZW50ZXI6IC41LFxuICAgICAgICAgICAgcmlnaHQ6IDFcbiAgICAgICAgICB9W2JdO1xuICAgICAgICAgIGIgIT09IHEgJiYgKHEgPSBiLCBPICYmIHYuYXR0cih7XG4gICAgICAgICAgICB4OiBYXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHYudGV4dFNldHRlciA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGIgJiYgRi5hdHRyKHtcbiAgICAgICAgICAgIHRleHQ6IGJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBiYSgpO1xuICAgICAgICAgIHUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2W1wic3Ryb2tlLXdpZHRoU2V0dGVyXCJdID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBiICYmIChIID0gITApO1xuICAgICAgICAgIFQgPSB0aGlzW1wic3Ryb2tlLXdpZHRoXCJdID0gYjtcbiAgICAgICAgICBZKGEsIGIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHcgPyB2LnJTZXR0ZXIgPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIFkoYSwgYik7XG4gICAgICAgIH0gOiB2LnN0cm9rZVNldHRlciA9IHYuZmlsbFNldHRlciA9IHYuclNldHRlciA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgXCJyXCIgIT09IGEgJiYgKFwiZmlsbFwiID09PSBhICYmIGIgJiYgKEggPSAhMCksIHZbYV0gPSBiKTtcbiAgICAgICAgICBZKGEsIGIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHYuYW5jaG9yWFNldHRlciA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgcCA9IHYuYW5jaG9yWCA9IGI7XG4gICAgICAgICAgWShhLCBNYXRoLnJvdW5kKGIpIC0gSygpIC0gWCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdi5hbmNob3JZU2V0dGVyID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBlID0gdi5hbmNob3JZID0gYjtcbiAgICAgICAgICBZKGEsIGIgLSBWKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2LnhTZXR0ZXIgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHYueCA9IGI7XG4gICAgICAgICAgcSAmJiAoYiAtPSBxICogKChkIHx8IE8ud2lkdGgpICsgMiAqIFIpLCB2W1wiZm9yY2VBbmltYXRlOnhcIl0gPSAhMCk7XG4gICAgICAgICAgWCA9IE1hdGgucm91bmQoYik7XG4gICAgICAgICAgdi5hdHRyKFwidHJhbnNsYXRlWFwiLCBYKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2LnlTZXR0ZXIgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIFYgPSB2LnkgPSBNYXRoLnJvdW5kKGIpO1xuICAgICAgICAgIHYuYXR0cihcInRyYW5zbGF0ZVlcIiwgVik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIEQgPSB2LmNzcztcbiAgICAgICAgeCA9IHtcbiAgICAgICAgICBjc3M6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgICB2YXIgYSA9IHt9O1xuICAgICAgICAgICAgICBiID0gayhiKTtcbiAgICAgICAgICAgICAgdi50ZXh0UHJvcHMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBiW2ZdICYmIChhW2ZdID0gYltmXSwgZGVsZXRlIGJbZl0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgRi5jc3MoYSk7XG4gICAgICAgICAgICAgIFwid2lkdGhcIiBpbiBhICYmIGJhKCk7XG4gICAgICAgICAgICAgIFwiZm9udFNpemVcIiBpbiBhICYmIChiYSgpLCB1KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gRC5jYWxsKHYsIGIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0QkJveDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgd2lkdGg6IE8ud2lkdGggKyAyICogUixcbiAgICAgICAgICAgICAgaGVpZ2h0OiBPLmhlaWdodCArIDIgKiBSLFxuICAgICAgICAgICAgICB4OiBPLnggLSBSLFxuICAgICAgICAgICAgICB5OiBPLnkgLSBSXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbCh2LmVsZW1lbnQsIFwibW91c2VlbnRlclwiKTtcbiAgICAgICAgICAgIGwodi5lbGVtZW50LCBcIm1vdXNlbGVhdmVcIik7XG4gICAgICAgICAgICBGICYmIChGID0gRi5kZXN0cm95KCkpO1xuICAgICAgICAgICAgeiAmJiAoeiA9IHouZGVzdHJveSgpKTtcbiAgICAgICAgICAgIFUucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh2KTtcbiAgICAgICAgICAgIHYgPSBtID0gYmEgPSB1ID0gWSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3IHx8ICh4LnNoYWRvdyA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYiAmJiAoYmEoKSwgeiAmJiB6LnNoYWRvdyhiKSk7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaCh2LCB4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkLlJlbmRlcmVyID0gZztcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9IdG1sLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgdmFyIHIgPSBnLmF0dHIsXG4gICAgICAgIHUgPSBnLmNyZWF0ZUVsZW1lbnQsXG4gICAgICAgIEkgPSBnLmNzcyxcbiAgICAgICAgTSA9IGcuZGVmaW5lZCxcbiAgICAgICAgRSA9IGcuZXh0ZW5kLFxuICAgICAgICBBID0gZy5waWNrLFxuICAgICAgICBHID0gZy5wSW50LFxuICAgICAgICBKID0gZC5pc0ZpcmVmb3gsXG4gICAgICAgIHkgPSBkLmlzTVMsXG4gICAgICAgIHQgPSBkLmlzV2ViS2l0LFxuICAgICAgICBEID0gZC5TVkdFbGVtZW50O1xuICAgIGcgPSBkLlNWR1JlbmRlcmVyO1xuICAgIHZhciBoID0gZC53aW47XG4gICAgRShELnByb3RvdHlwZSwge1xuICAgICAgaHRtbENzczogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIHEgPSBcIlNQQU5cIiA9PT0gdGhpcy5lbGVtZW50LnRhZ05hbWUgJiYgZCAmJiBcIndpZHRoXCIgaW4gZCxcbiAgICAgICAgICAgIE4gPSBBKHEgJiYgZC53aWR0aCwgdm9pZCAwKTtcblxuICAgICAgICBpZiAocSkge1xuICAgICAgICAgIGRlbGV0ZSBkLndpZHRoO1xuICAgICAgICAgIHRoaXMudGV4dFdpZHRoID0gTjtcbiAgICAgICAgICB2YXIgZSA9ICEwO1xuICAgICAgICB9XG5cbiAgICAgICAgZCAmJiBcImVsbGlwc2lzXCIgPT09IGQudGV4dE92ZXJmbG93ICYmIChkLndoaXRlU3BhY2UgPSBcIm5vd3JhcFwiLCBkLm92ZXJmbG93ID0gXCJoaWRkZW5cIik7XG4gICAgICAgIHRoaXMuc3R5bGVzID0gRSh0aGlzLnN0eWxlcywgZCk7XG4gICAgICAgIEkodGhpcy5lbGVtZW50LCBkKTtcbiAgICAgICAgZSAmJiB0aGlzLmh0bWxVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgaHRtbEdldEJCb3g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogZC5vZmZzZXRMZWZ0LFxuICAgICAgICAgIHk6IGQub2Zmc2V0VG9wLFxuICAgICAgICAgIHdpZHRoOiBkLm9mZnNldFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogZC5vZmZzZXRIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBodG1sVXBkYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmFkZGVkKSB7XG4gICAgICAgICAgdmFyIGQgPSB0aGlzLnJlbmRlcmVyLFxuICAgICAgICAgICAgICBxID0gdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgICBoID0gdGhpcy50cmFuc2xhdGVYIHx8IDAsXG4gICAgICAgICAgICAgIGUgPSB0aGlzLnRyYW5zbGF0ZVkgfHwgMCxcbiAgICAgICAgICAgICAgYyA9IHRoaXMueCB8fCAwLFxuICAgICAgICAgICAgICBrID0gdGhpcy55IHx8IDAsXG4gICAgICAgICAgICAgIG4gPSB0aGlzLnRleHRBbGlnbiB8fCBcImxlZnRcIixcbiAgICAgICAgICAgICAgZiA9IHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICBjZW50ZXI6IC41LFxuICAgICAgICAgICAgcmlnaHQ6IDFcbiAgICAgICAgICB9W25dLFxuICAgICAgICAgICAgICBhID0gdGhpcy5zdHlsZXMsXG4gICAgICAgICAgICAgIGwgPSBhICYmIGEud2hpdGVTcGFjZTtcbiAgICAgICAgICBJKHEsIHtcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6IGgsXG4gICAgICAgICAgICBtYXJnaW5Ub3A6IGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAhZC5zdHlsZWRNb2RlICYmIHRoaXMuc2hhZG93cyAmJiB0aGlzLnNoYWRvd3MuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgSShhLCB7XG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQ6IGggKyAxLFxuICAgICAgICAgICAgICBtYXJnaW5Ub3A6IGUgKyAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmludmVydGVkICYmIFtdLmZvckVhY2guY2FsbChxLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBkLmludmVydENoaWxkKGEsIHEpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKFwiU1BBTlwiID09PSBxLnRhZ05hbWUpIHtcbiAgICAgICAgICAgIGEgPSB0aGlzLnJvdGF0aW9uO1xuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLnRleHRXaWR0aCAmJiBHKHRoaXMudGV4dFdpZHRoKSxcbiAgICAgICAgICAgICAgICB6ID0gW2EsIG4sIHEuaW5uZXJIVE1MLCB0aGlzLnRleHRXaWR0aCwgdGhpcy50ZXh0QWxpZ25dLmpvaW4oKSxcbiAgICAgICAgICAgICAgICB3O1xuICAgICAgICAgICAgKHcgPSB2ICE9PSB0aGlzLm9sZFRleHRXaWR0aCkgJiYgISh3ID0gdiA+IHRoaXMub2xkVGV4dFdpZHRoKSAmJiAoKHcgPSB0aGlzLnRleHRQeExlbmd0aCkgfHwgKEkocSwge1xuICAgICAgICAgICAgICB3aWR0aDogXCJcIixcbiAgICAgICAgICAgICAgd2hpdGVTcGFjZTogbCB8fCBcIm5vd3JhcFwiXG4gICAgICAgICAgICB9KSwgdyA9IHEub2Zmc2V0V2lkdGgpLCB3ID0gdyA+IHYpO1xuICAgICAgICAgICAgdyAmJiAoL1sgXFwtXS8udGVzdChxLnRleHRDb250ZW50IHx8IHEuaW5uZXJUZXh0KSB8fCBcImVsbGlwc2lzXCIgPT09IHEuc3R5bGUudGV4dE92ZXJmbG93KSA/IChJKHEsIHtcbiAgICAgICAgICAgICAgd2lkdGg6IHYgKyBcInB4XCIsXG4gICAgICAgICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgICAgICAgd2hpdGVTcGFjZTogbCB8fCBcIm5vcm1hbFwiXG4gICAgICAgICAgICB9KSwgdGhpcy5vbGRUZXh0V2lkdGggPSB2LCB0aGlzLmhhc0JveFdpZHRoQ2hhbmdlZCA9ICEwKSA6IHRoaXMuaGFzQm94V2lkdGhDaGFuZ2VkID0gITE7XG4gICAgICAgICAgICB6ICE9PSB0aGlzLmNUVCAmJiAobCA9IGQuZm9udE1ldHJpY3MocS5zdHlsZS5mb250U2l6ZSwgcSkuYiwgIU0oYSkgfHwgYSA9PT0gKHRoaXMub2xkUm90YXRpb24gfHwgMCkgJiYgbiA9PT0gdGhpcy5vbGRBbGlnbiB8fCB0aGlzLnNldFNwYW5Sb3RhdGlvbihhLCBmLCBsKSwgdGhpcy5nZXRTcGFuQ29ycmVjdGlvbighTShhKSAmJiB0aGlzLnRleHRQeExlbmd0aCB8fCBxLm9mZnNldFdpZHRoLCBsLCBmLCBhLCBuKSk7XG4gICAgICAgICAgICBJKHEsIHtcbiAgICAgICAgICAgICAgbGVmdDogYyArICh0aGlzLnhDb3JyIHx8IDApICsgXCJweFwiLFxuICAgICAgICAgICAgICB0b3A6IGsgKyAodGhpcy55Q29yciB8fCAwKSArIFwicHhcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNUVCA9IHo7XG4gICAgICAgICAgICB0aGlzLm9sZFJvdGF0aW9uID0gYTtcbiAgICAgICAgICAgIHRoaXMub2xkQWxpZ24gPSBuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHRoaXMuYWxpZ25PbkFkZCA9ICEwO1xuICAgICAgfSxcbiAgICAgIHNldFNwYW5Sb3RhdGlvbjogZnVuY3Rpb24gKGQsIHEsIGgpIHtcbiAgICAgICAgdmFyIGUgPSB7fSxcbiAgICAgICAgICAgIGMgPSB0aGlzLnJlbmRlcmVyLmdldFRyYW5zZm9ybUtleSgpO1xuICAgICAgICBlW2NdID0gZS50cmFuc2Zvcm0gPSBcInJvdGF0ZShcIiArIGQgKyBcImRlZylcIjtcbiAgICAgICAgZVtjICsgKEogPyBcIk9yaWdpblwiIDogXCItb3JpZ2luXCIpXSA9IGUudHJhbnNmb3JtT3JpZ2luID0gMTAwICogcSArIFwiJSBcIiArIGggKyBcInB4XCI7XG4gICAgICAgIEkodGhpcy5lbGVtZW50LCBlKTtcbiAgICAgIH0sXG4gICAgICBnZXRTcGFuQ29ycmVjdGlvbjogZnVuY3Rpb24gKGQsIHEsIGgpIHtcbiAgICAgICAgdGhpcy54Q29yciA9IC1kICogaDtcbiAgICAgICAgdGhpcy55Q29yciA9IC1xO1xuICAgICAgfVxuICAgIH0pO1xuICAgIEUoZy5wcm90b3R5cGUsIHtcbiAgICAgIGdldFRyYW5zZm9ybUtleTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geSAmJiAhL0VkZ2UvLnRlc3QoaC5uYXZpZ2F0b3IudXNlckFnZW50KSA/IFwiLW1zLXRyYW5zZm9ybVwiIDogdCA/IFwiLXdlYmtpdC10cmFuc2Zvcm1cIiA6IEogPyBcIk1velRyYW5zZm9ybVwiIDogaC5vcGVyYSA/IFwiLW8tdHJhbnNmb3JtXCIgOiBcIlwiO1xuICAgICAgfSxcbiAgICAgIGh0bWw6IGZ1bmN0aW9uIChkLCBxLCBoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5jcmVhdGVFbGVtZW50KFwic3BhblwiKSxcbiAgICAgICAgICAgIGMgPSBlLmVsZW1lbnQsXG4gICAgICAgICAgICBrID0gZS5yZW5kZXJlcixcbiAgICAgICAgICAgIG4gPSBrLmlzU1ZHLFxuICAgICAgICAgICAgZiA9IGZ1bmN0aW9uIChhLCBmKSB7XG4gICAgICAgICAgW1wib3BhY2l0eVwiLCBcInZpc2liaWxpdHlcIl0uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgYVtjICsgXCJTZXR0ZXJcIl0gPSBmdW5jdGlvbiAoZSwgbCwgaykge1xuICAgICAgICAgICAgICB2YXIgdiA9IGEuZGl2ID8gYS5kaXYuc3R5bGUgOiBmO1xuICAgICAgICAgICAgICBELnByb3RvdHlwZVtjICsgXCJTZXR0ZXJcIl0uY2FsbCh0aGlzLCBlLCBsLCBrKTtcbiAgICAgICAgICAgICAgdiAmJiAodltsXSA9IGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhLmFkZGVkU2V0dGVycyA9ICEwO1xuICAgICAgICB9O1xuXG4gICAgICAgIGUudGV4dFNldHRlciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYSAhPT0gYy5pbm5lckhUTUwgJiYgKGRlbGV0ZSB0aGlzLmJCb3gsIGRlbGV0ZSB0aGlzLm9sZFRleHRXaWR0aCk7XG4gICAgICAgICAgdGhpcy50ZXh0U3RyID0gYTtcbiAgICAgICAgICBjLmlubmVySFRNTCA9IEEoYSwgXCJcIik7XG4gICAgICAgICAgZS5kb1RyYW5zZm9ybSA9ICEwO1xuICAgICAgICB9O1xuXG4gICAgICAgIG4gJiYgZihlLCBlLmVsZW1lbnQuc3R5bGUpO1xuXG4gICAgICAgIGUueFNldHRlciA9IGUueVNldHRlciA9IGUuYWxpZ25TZXR0ZXIgPSBlLnJvdGF0aW9uU2V0dGVyID0gZnVuY3Rpb24gKGEsIGYpIHtcbiAgICAgICAgICBcImFsaWduXCIgPT09IGYgJiYgKGYgPSBcInRleHRBbGlnblwiKTtcbiAgICAgICAgICBlW2ZdID0gYTtcbiAgICAgICAgICBlLmRvVHJhbnNmb3JtID0gITA7XG4gICAgICAgIH07XG5cbiAgICAgICAgZS5hZnRlclNldHRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5kb1RyYW5zZm9ybSAmJiAodGhpcy5odG1sVXBkYXRlVHJhbnNmb3JtKCksIHRoaXMuZG9UcmFuc2Zvcm0gPSAhMSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZS5hdHRyKHtcbiAgICAgICAgICB0ZXh0OiBkLFxuICAgICAgICAgIHg6IE1hdGgucm91bmQocSksXG4gICAgICAgICAgeTogTWF0aC5yb3VuZChoKVxuICAgICAgICB9KS5jc3Moe1xuICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGsuc3R5bGVkTW9kZSB8fCBlLmNzcyh7XG4gICAgICAgICAgZm9udEZhbWlseTogdGhpcy5zdHlsZS5mb250RmFtaWx5LFxuICAgICAgICAgIGZvbnRTaXplOiB0aGlzLnN0eWxlLmZvbnRTaXplXG4gICAgICAgIH0pO1xuICAgICAgICBjLnN0eWxlLndoaXRlU3BhY2UgPSBcIm5vd3JhcFwiO1xuICAgICAgICBlLmNzcyA9IGUuaHRtbENzcztcbiAgICAgICAgbiAmJiAoZS5hZGQgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHZhciBsID0gay5ib3gucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgdiA9IFtdO1xuXG4gICAgICAgICAgaWYgKHRoaXMucGFyZW50R3JvdXAgPSBhKSB7XG4gICAgICAgICAgICB2YXIgbiA9IGEuZGl2O1xuXG4gICAgICAgICAgICBpZiAoIW4pIHtcbiAgICAgICAgICAgICAgZm9yICg7IGE7KSB2LnB1c2goYSksIGEgPSBhLnBhcmVudEdyb3VwO1xuXG4gICAgICAgICAgICAgIHYucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjKGYsIGMpIHtcbiAgICAgICAgICAgICAgICAgIGFbY10gPSBmO1xuICAgICAgICAgICAgICAgICAgXCJ0cmFuc2xhdGVYXCIgPT09IGMgPyB3LmxlZnQgPSBmICsgXCJweFwiIDogdy50b3AgPSBmICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgYS5kb1RyYW5zZm9ybSA9ICEwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBrID0gcihhLmVsZW1lbnQsIFwiY2xhc3NcIik7XG4gICAgICAgICAgICAgICAgbiA9IGEuZGl2ID0gYS5kaXYgfHwgdShcImRpdlwiLCBrID8ge1xuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBrXG4gICAgICAgICAgICAgICAgfSA6IHZvaWQgMCwge1xuICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IChhLnRyYW5zbGF0ZVggfHwgMCkgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgICB0b3A6IChhLnRyYW5zbGF0ZVkgfHwgMCkgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgICBkaXNwbGF5OiBhLmRpc3BsYXksXG4gICAgICAgICAgICAgICAgICBvcGFjaXR5OiBhLm9wYWNpdHksXG4gICAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBhLnN0eWxlcyAmJiBhLnN0eWxlcy5wb2ludGVyRXZlbnRzXG4gICAgICAgICAgICAgICAgfSwgbiB8fCBsKTtcbiAgICAgICAgICAgICAgICB2YXIgdyA9IG4uc3R5bGU7XG4gICAgICAgICAgICAgICAgRShhLCB7XG4gICAgICAgICAgICAgICAgICBjbGFzc1NldHRlcjogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGYpO1xuICAgICAgICAgICAgICAgICAgICAgIGEuY2xhc3NOYW1lID0gZjtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH0obiksXG4gICAgICAgICAgICAgICAgICBvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2WzBdLmRpdiAmJiBlLm9uLmFwcGx5KHtcbiAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB2WzBdLmRpdlxuICAgICAgICAgICAgICAgICAgICB9LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB0cmFuc2xhdGVYU2V0dGVyOiBjLFxuICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWVNldHRlcjogY1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGEuYWRkZWRTZXR0ZXJzIHx8IGYoYSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBuID0gbDtcblxuICAgICAgICAgIG4uYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgICAgZS5hZGRlZCA9ICEwO1xuICAgICAgICAgIGUuYWxpZ25PbkFkZCAmJiBlLmh0bWxVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL1RpY2suanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcpIHtcbiAgICB2YXIgciA9IGcuY2xhbXAsXG4gICAgICAgIHUgPSBnLmNvcnJlY3RGbG9hdCxcbiAgICAgICAgSSA9IGcuZGVmaW5lZCxcbiAgICAgICAgTSA9IGcuZGVzdHJveU9iamVjdFByb3BlcnRpZXMsXG4gICAgICAgIEUgPSBnLmV4dGVuZCxcbiAgICAgICAgQSA9IGcuaXNOdW1iZXIsXG4gICAgICAgIEcgPSBnLm1lcmdlLFxuICAgICAgICBKID0gZy5vYmplY3RFYWNoLFxuICAgICAgICB5ID0gZy5waWNrLFxuICAgICAgICB0ID0gZC5maXJlRXZlbnQsXG4gICAgICAgIEQgPSBkLmRlZzJyYWQ7XG5cbiAgICBnID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gaChkLCBxLCBoLCBlLCBjKSB7XG4gICAgICAgIHRoaXMuaXNOZXdMYWJlbCA9IHRoaXMuaXNOZXcgPSAhMDtcbiAgICAgICAgdGhpcy5heGlzID0gZDtcbiAgICAgICAgdGhpcy5wb3MgPSBxO1xuICAgICAgICB0aGlzLnR5cGUgPSBoIHx8IFwiXCI7XG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IGMgfHwge307XG4gICAgICAgIHRoaXMudGlja21hcmtPZmZzZXQgPSB0aGlzLnBhcmFtZXRlcnMudGlja21hcmtPZmZzZXQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMucGFyYW1ldGVycy5vcHRpb25zO1xuICAgICAgICBoIHx8IGUgfHwgdGhpcy5hZGRMYWJlbCgpO1xuICAgICAgfVxuXG4gICAgICBoLnByb3RvdHlwZS5hZGRMYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgICAgcSA9IGQuYXhpcyxcbiAgICAgICAgICAgIGggPSBxLm9wdGlvbnMsXG4gICAgICAgICAgICBlID0gcS5jaGFydCxcbiAgICAgICAgICAgIGMgPSBxLmNhdGVnb3JpZXMsXG4gICAgICAgICAgICBrID0gcS5uYW1lcyxcbiAgICAgICAgICAgIG4gPSBkLnBvcyxcbiAgICAgICAgICAgIGYgPSB5KGQub3B0aW9ucyAmJiBkLm9wdGlvbnMubGFiZWxzLCBoLmxhYmVscyksXG4gICAgICAgICAgICBhID0gcS50aWNrUG9zaXRpb25zLFxuICAgICAgICAgICAgbCA9IG4gPT09IGFbMF0sXG4gICAgICAgICAgICB2ID0gbiA9PT0gYVthLmxlbmd0aCAtIDFdO1xuICAgICAgICBrID0gdGhpcy5wYXJhbWV0ZXJzLmNhdGVnb3J5IHx8IChjID8geShjW25dLCBrW25dLCBuKSA6IG4pO1xuICAgICAgICB2YXIgeiA9IGQubGFiZWw7XG4gICAgICAgIGMgPSAoIWYuc3RlcCB8fCAxID09PSBmLnN0ZXApICYmIDEgPT09IHEudGlja0ludGVydmFsO1xuICAgICAgICBhID0gYS5pbmZvO1xuICAgICAgICB2YXIgdywgQjtcblxuICAgICAgICBpZiAocS5pc0RhdGV0aW1lQXhpcyAmJiBhKSB7XG4gICAgICAgICAgdmFyIEwgPSBlLnRpbWUucmVzb2x2ZURUTEZvcm1hdChoLmRhdGVUaW1lTGFiZWxGb3JtYXRzWyFoLmdyaWQgJiYgYS5oaWdoZXJSYW5rc1tuXSB8fCBhLnVuaXROYW1lXSk7XG4gICAgICAgICAgdmFyIHQgPSBMLm1haW47XG4gICAgICAgIH1cblxuICAgICAgICBkLmlzRmlyc3QgPSBsO1xuICAgICAgICBkLmlzTGFzdCA9IHY7XG4gICAgICAgIGQuZm9ybWF0Q3R4ID0ge1xuICAgICAgICAgIGF4aXM6IHEsXG4gICAgICAgICAgY2hhcnQ6IGUsXG4gICAgICAgICAgaXNGaXJzdDogbCxcbiAgICAgICAgICBpc0xhc3Q6IHYsXG4gICAgICAgICAgZGF0ZVRpbWVMYWJlbEZvcm1hdDogdCxcbiAgICAgICAgICB0aWNrUG9zaXRpb25JbmZvOiBhLFxuICAgICAgICAgIHZhbHVlOiBxLmlzTG9nID8gdShxLmxpbjJsb2coaykpIDogayxcbiAgICAgICAgICBwb3M6IG5cbiAgICAgICAgfTtcbiAgICAgICAgaCA9IHEubGFiZWxGb3JtYXR0ZXIuY2FsbChkLmZvcm1hdEN0eCwgdGhpcy5mb3JtYXRDdHgpO1xuICAgICAgICBpZiAoQiA9IEwgJiYgTC5saXN0KSBkLnNob3J0ZW5MYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKHcgPSAwOyB3IDwgQi5sZW5ndGg7IHcrKykgaWYgKHouYXR0cih7XG4gICAgICAgICAgICB0ZXh0OiBxLmxhYmVsRm9ybWF0dGVyLmNhbGwoRShkLmZvcm1hdEN0eCwge1xuICAgICAgICAgICAgICBkYXRlVGltZUxhYmVsRm9ybWF0OiBCW3ddXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICB9KSwgei5nZXRCQm94KCkud2lkdGggPCBxLmdldFNsb3RXaWR0aChkKSAtIDIgKiB5KGYucGFkZGluZywgNSkpIHJldHVybjtcblxuICAgICAgICAgIHouYXR0cih7XG4gICAgICAgICAgICB0ZXh0OiBcIlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGMgJiYgcS5fYWRkZWRQbG90TEIgJiYgcS5pc1hBeGlzICYmIGQubW92ZUxhYmVsKGgsIGYpO1xuICAgICAgICBJKHopIHx8IGQubW92ZWRMYWJlbCA/IHogJiYgei50ZXh0U3RyICE9PSBoICYmICFjICYmICghei50ZXh0V2lkdGggfHwgZi5zdHlsZSAmJiBmLnN0eWxlLndpZHRoIHx8IHouc3R5bGVzLndpZHRoIHx8IHouY3NzKHtcbiAgICAgICAgICB3aWR0aDogbnVsbFxuICAgICAgICB9KSwgei5hdHRyKHtcbiAgICAgICAgICB0ZXh0OiBoXG4gICAgICAgIH0pLCB6LnRleHRQeExlbmd0aCA9IHouZ2V0QkJveCgpLndpZHRoKSA6IChkLmxhYmVsID0geiA9IGQuY3JlYXRlTGFiZWwoe1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LCBoLCBmKSwgZC5yb3RhdGlvbiA9IDApO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUuY3JlYXRlTGFiZWwgPSBmdW5jdGlvbiAoZCwgcSwgaCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuYXhpcyxcbiAgICAgICAgICAgIGMgPSBlLmNoYXJ0O1xuICAgICAgICBpZiAoZCA9IEkocSkgJiYgaC5lbmFibGVkID8gYy5yZW5kZXJlci50ZXh0KHEsIGQueCwgZC55LCBoLnVzZUhUTUwpLmFkZChlLmxhYmVsR3JvdXApIDogbnVsbCkgYy5zdHlsZWRNb2RlIHx8IGQuY3NzKEcoaC5zdHlsZSkpLCBkLnRleHRQeExlbmd0aCA9IGQuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICByZXR1cm4gZDtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIE0odGhpcywgdGhpcy5heGlzKTtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKGQsIHEsIGgsIGUpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmF4aXMsXG4gICAgICAgICAgICBrID0gYy5jaGFydCxcbiAgICAgICAgICAgIG4gPSBlICYmIGsub2xkQ2hhcnRIZWlnaHQgfHwgay5jaGFydEhlaWdodDtcbiAgICAgICAgZCA9IHtcbiAgICAgICAgICB4OiBkID8gdShjLnRyYW5zbGF0ZShxICsgaCwgbnVsbCwgbnVsbCwgZSkgKyBjLnRyYW5zQikgOiBjLmxlZnQgKyBjLm9mZnNldCArIChjLm9wcG9zaXRlID8gKGUgJiYgay5vbGRDaGFydFdpZHRoIHx8IGsuY2hhcnRXaWR0aCkgLSBjLnJpZ2h0IC0gYy5sZWZ0IDogMCksXG4gICAgICAgICAgeTogZCA/IG4gLSBjLmJvdHRvbSArIGMub2Zmc2V0IC0gKGMub3Bwb3NpdGUgPyBjLmhlaWdodCA6IDApIDogdShuIC0gYy50cmFuc2xhdGUocSArIGgsIG51bGwsIG51bGwsIGUpIC0gYy50cmFuc0IpXG4gICAgICAgIH07XG4gICAgICAgIGQueSA9IHIoZC55LCAtMUU1LCAxRTUpO1xuICAgICAgICB0KHRoaXMsIFwiYWZ0ZXJHZXRQb3NpdGlvblwiLCB7XG4gICAgICAgICAgcG9zOiBkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZDtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLmdldExhYmVsUG9zaXRpb24gPSBmdW5jdGlvbiAoZCwgcSwgaCwgZSwgYywgaywgbiwgZikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuYXhpcyxcbiAgICAgICAgICAgIGwgPSBhLnRyYW5zQSxcbiAgICAgICAgICAgIHYgPSBhLmlzTGlua2VkICYmIGEubGlua2VkUGFyZW50ID8gYS5saW5rZWRQYXJlbnQucmV2ZXJzZWQgOiBhLnJldmVyc2VkLFxuICAgICAgICAgICAgeiA9IGEuc3RhZ2dlckxpbmVzLFxuICAgICAgICAgICAgdyA9IGEudGlja1JvdENvcnIgfHwge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LFxuICAgICAgICAgICAgQiA9IGMueSxcbiAgICAgICAgICAgIEwgPSBlIHx8IGEucmVzZXJ2ZVNwYWNlRGVmYXVsdCA/IDAgOiAtYS5sYWJlbE9mZnNldCAqIChcImNlbnRlclwiID09PSBhLmxhYmVsQWxpZ24gPyAuNSA6IDEpLFxuICAgICAgICAgICAgTiA9IHt9O1xuICAgICAgICBJKEIpIHx8IChCID0gMCA9PT0gYS5zaWRlID8gaC5yb3RhdGlvbiA/IC04IDogLWguZ2V0QkJveCgpLmhlaWdodCA6IDIgPT09IGEuc2lkZSA/IHcueSArIDggOiBNYXRoLmNvcyhoLnJvdGF0aW9uICogRCkgKiAody55IC0gaC5nZXRCQm94KCExLCAwKS5oZWlnaHQgLyAyKSk7XG4gICAgICAgIGQgPSBkICsgYy54ICsgTCArIHcueCAtIChrICYmIGUgPyBrICogbCAqICh2ID8gLTEgOiAxKSA6IDApO1xuICAgICAgICBxID0gcSArIEIgLSAoayAmJiAhZSA/IGsgKiBsICogKHYgPyAxIDogLTEpIDogMCk7XG4gICAgICAgIHogJiYgKGggPSBuIC8gKGYgfHwgMSkgJSB6LCBhLm9wcG9zaXRlICYmIChoID0geiAtIGggLSAxKSwgcSArPSBhLmxhYmVsT2Zmc2V0IC8geiAqIGgpO1xuICAgICAgICBOLnggPSBkO1xuICAgICAgICBOLnkgPSBNYXRoLnJvdW5kKHEpO1xuICAgICAgICB0KHRoaXMsIFwiYWZ0ZXJHZXRMYWJlbFBvc2l0aW9uXCIsIHtcbiAgICAgICAgICBwb3M6IE4sXG4gICAgICAgICAgdGlja21hcmtPZmZzZXQ6IGssXG4gICAgICAgICAgaW5kZXg6IG5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBOO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUuZ2V0TGFiZWxTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbCA/IHRoaXMubGFiZWwuZ2V0QkJveCgpW3RoaXMuYXhpcy5ob3JpeiA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCJdIDogMDtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLmdldE1hcmtQYXRoID0gZnVuY3Rpb24gKGQsIHEsIGgsIGUsIGMsIGspIHtcbiAgICAgICAgcmV0dXJuIGsuY3Jpc3BMaW5lKFtcIk1cIiwgZCwgcSwgXCJMXCIsIGQgKyAoYyA/IDAgOiAtaCksIHEgKyAoYyA/IGggOiAwKV0sIGUpO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUuaGFuZGxlT3ZlcmZsb3cgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgcSA9IHRoaXMuYXhpcyxcbiAgICAgICAgICAgIGggPSBxLm9wdGlvbnMubGFiZWxzLFxuICAgICAgICAgICAgZSA9IGQueCxcbiAgICAgICAgICAgIGMgPSBxLmNoYXJ0LmNoYXJ0V2lkdGgsXG4gICAgICAgICAgICBrID0gcS5jaGFydC5zcGFjaW5nLFxuICAgICAgICAgICAgbiA9IHkocS5sYWJlbExlZnQsIE1hdGgubWluKHEucG9zLCBrWzNdKSk7XG4gICAgICAgIGsgPSB5KHEubGFiZWxSaWdodCwgTWF0aC5tYXgocS5pc1JhZGlhbCA/IDAgOiBxLnBvcyArIHEubGVuLCBjIC0ga1sxXSkpO1xuICAgICAgICB2YXIgZiA9IHRoaXMubGFiZWwsXG4gICAgICAgICAgICBhID0gdGhpcy5yb3RhdGlvbixcbiAgICAgICAgICAgIGwgPSB7XG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICBjZW50ZXI6IC41LFxuICAgICAgICAgIHJpZ2h0OiAxXG4gICAgICAgIH1bcS5sYWJlbEFsaWduIHx8IGYuYXR0cihcImFsaWduXCIpXSxcbiAgICAgICAgICAgIHYgPSBmLmdldEJCb3goKS53aWR0aCxcbiAgICAgICAgICAgIHogPSBxLmdldFNsb3RXaWR0aCh0aGlzKSxcbiAgICAgICAgICAgIHcgPSB6LFxuICAgICAgICAgICAgQiA9IDEsXG4gICAgICAgICAgICBMLFxuICAgICAgICAgICAgdCA9IHt9O1xuICAgICAgICBpZiAoYSB8fCBcImp1c3RpZnlcIiAhPT0geShoLm92ZXJmbG93LCBcImp1c3RpZnlcIikpIDAgPiBhICYmIGUgLSBsICogdiA8IG4gPyBMID0gTWF0aC5yb3VuZChlIC8gTWF0aC5jb3MoYSAqIEQpIC0gbikgOiAwIDwgYSAmJiBlICsgbCAqIHYgPiBrICYmIChMID0gTWF0aC5yb3VuZCgoYyAtIGUpIC8gTWF0aC5jb3MoYSAqIEQpKSk7ZWxzZSBpZiAoYyA9IGUgKyAoMSAtIGwpICogdiwgZSAtIGwgKiB2IDwgbiA/IHcgPSBkLnggKyB3ICogKDEgLSBsKSAtIG4gOiBjID4gayAmJiAodyA9IGsgLSBkLnggKyB3ICogbCwgQiA9IC0xKSwgdyA9IE1hdGgubWluKHosIHcpLCB3IDwgeiAmJiBcImNlbnRlclwiID09PSBxLmxhYmVsQWxpZ24gJiYgKGQueCArPSBCICogKHogLSB3IC0gbCAqICh6IC0gTWF0aC5taW4odiwgdykpKSksIHYgPiB3IHx8IHEuYXV0b1JvdGF0aW9uICYmIChmLnN0eWxlcyB8fCB7fSkud2lkdGgpIEwgPSB3O1xuICAgICAgICBMICYmICh0aGlzLnNob3J0ZW5MYWJlbCA/IHRoaXMuc2hvcnRlbkxhYmVsKCkgOiAodC53aWR0aCA9IE1hdGguZmxvb3IoTCksIChoLnN0eWxlIHx8IHt9KS50ZXh0T3ZlcmZsb3cgfHwgKHQudGV4dE92ZXJmbG93ID0gXCJlbGxpcHNpc1wiKSwgZi5jc3ModCkpKTtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLm1vdmVMYWJlbCA9IGZ1bmN0aW9uIChkLCBxKSB7XG4gICAgICAgIHZhciBoID0gdGhpcyxcbiAgICAgICAgICAgIGUgPSBoLmxhYmVsLFxuICAgICAgICAgICAgYyA9ICExLFxuICAgICAgICAgICAgayA9IGguYXhpcyxcbiAgICAgICAgICAgIG4gPSBrLnJldmVyc2VkLFxuICAgICAgICAgICAgZiA9IGsuY2hhcnQuaW52ZXJ0ZWQ7XG4gICAgICAgIGUgJiYgZS50ZXh0U3RyID09PSBkID8gKGgubW92ZWRMYWJlbCA9IGUsIGMgPSAhMCwgZGVsZXRlIGgubGFiZWwpIDogSihrLnRpY2tzLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGMgfHwgYS5pc05ldyB8fCBhID09PSBoIHx8ICFhLmxhYmVsIHx8IGEubGFiZWwudGV4dFN0ciAhPT0gZCB8fCAoaC5tb3ZlZExhYmVsID0gYS5sYWJlbCwgYyA9ICEwLCBhLmxhYmVsUG9zID0gaC5tb3ZlZExhYmVsLnh5LCBkZWxldGUgYS5sYWJlbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghYyAmJiAoaC5sYWJlbFBvcyB8fCBlKSkge1xuICAgICAgICAgIHZhciBhID0gaC5sYWJlbFBvcyB8fCBlLnh5O1xuICAgICAgICAgIGUgPSBmID8gYS54IDogbiA/IDAgOiBrLndpZHRoICsgay5sZWZ0O1xuICAgICAgICAgIGsgPSBmID8gbiA/IGsud2lkdGggKyBrLmxlZnQgOiAwIDogYS55O1xuICAgICAgICAgIGgubW92ZWRMYWJlbCA9IGguY3JlYXRlTGFiZWwoe1xuICAgICAgICAgICAgeDogZSxcbiAgICAgICAgICAgIHk6IGtcbiAgICAgICAgICB9LCBkLCBxKTtcbiAgICAgICAgICBoLm1vdmVkTGFiZWwgJiYgaC5tb3ZlZExhYmVsLmF0dHIoe1xuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoaCwgcSwgdCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuYXhpcyxcbiAgICAgICAgICAgIGMgPSBlLmhvcml6LFxuICAgICAgICAgICAgayA9IHRoaXMucG9zLFxuICAgICAgICAgICAgbiA9IHkodGhpcy50aWNrbWFya09mZnNldCwgZS50aWNrbWFya09mZnNldCk7XG4gICAgICAgIGsgPSB0aGlzLmdldFBvc2l0aW9uKGMsIGssIG4sIHEpO1xuICAgICAgICBuID0gay54O1xuICAgICAgICB2YXIgZiA9IGsueTtcbiAgICAgICAgZSA9IGMgJiYgbiA9PT0gZS5wb3MgKyBlLmxlbiB8fCAhYyAmJiBmID09PSBlLnBvcyA/IC0xIDogMTtcbiAgICAgICAgdCA9IHkodCwgMSk7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSAhMDtcbiAgICAgICAgdGhpcy5yZW5kZXJHcmlkTGluZShxLCB0LCBlKTtcbiAgICAgICAgdGhpcy5yZW5kZXJNYXJrKGssIHQsIGUpO1xuICAgICAgICB0aGlzLnJlbmRlckxhYmVsKGssIHEsIHQsIGgpO1xuICAgICAgICB0aGlzLmlzTmV3ID0gITE7XG4gICAgICAgIGQuZmlyZUV2ZW50KHRoaXMsIFwiYWZ0ZXJSZW5kZXJcIik7XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5yZW5kZXJHcmlkTGluZSA9IGZ1bmN0aW9uIChkLCBxLCBoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5heGlzLFxuICAgICAgICAgICAgYyA9IGUub3B0aW9ucyxcbiAgICAgICAgICAgIGsgPSB0aGlzLmdyaWRMaW5lLFxuICAgICAgICAgICAgbiA9IHt9LFxuICAgICAgICAgICAgZiA9IHRoaXMucG9zLFxuICAgICAgICAgICAgYSA9IHRoaXMudHlwZSxcbiAgICAgICAgICAgIGwgPSB5KHRoaXMudGlja21hcmtPZmZzZXQsIGUudGlja21hcmtPZmZzZXQpLFxuICAgICAgICAgICAgdiA9IGUuY2hhcnQucmVuZGVyZXIsXG4gICAgICAgICAgICB6ID0gYSA/IGEgKyBcIkdyaWRcIiA6IFwiZ3JpZFwiLFxuICAgICAgICAgICAgdyA9IGNbeiArIFwiTGluZVdpZHRoXCJdLFxuICAgICAgICAgICAgQiA9IGNbeiArIFwiTGluZUNvbG9yXCJdO1xuICAgICAgICBjID0gY1t6ICsgXCJMaW5lRGFzaFN0eWxlXCJdO1xuICAgICAgICBrIHx8IChlLmNoYXJ0LnN0eWxlZE1vZGUgfHwgKG4uc3Ryb2tlID0gQiwgbltcInN0cm9rZS13aWR0aFwiXSA9IHcsIGMgJiYgKG4uZGFzaHN0eWxlID0gYykpLCBhIHx8IChuLnpJbmRleCA9IDEpLCBkICYmIChxID0gMCksIHRoaXMuZ3JpZExpbmUgPSBrID0gdi5wYXRoKCkuYXR0cihuKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtXCIgKyAoYSA/IGEgKyBcIi1cIiA6IFwiXCIpICsgXCJncmlkLWxpbmVcIikuYWRkKGUuZ3JpZEdyb3VwKSk7XG4gICAgICAgIGlmIChrICYmIChoID0gZS5nZXRQbG90TGluZVBhdGgoe1xuICAgICAgICAgIHZhbHVlOiBmICsgbCxcbiAgICAgICAgICBsaW5lV2lkdGg6IGsuc3Ryb2tlV2lkdGgoKSAqIGgsXG4gICAgICAgICAgZm9yY2U6IFwicGFzc1wiLFxuICAgICAgICAgIG9sZDogZFxuICAgICAgICB9KSkpIGtbZCB8fCB0aGlzLmlzTmV3ID8gXCJhdHRyXCIgOiBcImFuaW1hdGVcIl0oe1xuICAgICAgICAgIGQ6IGgsXG4gICAgICAgICAgb3BhY2l0eTogcVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLnJlbmRlck1hcmsgPSBmdW5jdGlvbiAoZCwgcSwgaCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuYXhpcyxcbiAgICAgICAgICAgIGMgPSBlLm9wdGlvbnMsXG4gICAgICAgICAgICBrID0gZS5jaGFydC5yZW5kZXJlcixcbiAgICAgICAgICAgIG4gPSB0aGlzLnR5cGUsXG4gICAgICAgICAgICBmID0gbiA/IG4gKyBcIlRpY2tcIiA6IFwidGlja1wiLFxuICAgICAgICAgICAgYSA9IGUudGlja1NpemUoZiksXG4gICAgICAgICAgICBsID0gdGhpcy5tYXJrLFxuICAgICAgICAgICAgdiA9ICFsLFxuICAgICAgICAgICAgeiA9IGQueDtcbiAgICAgICAgZCA9IGQueTtcbiAgICAgICAgdmFyIHcgPSB5KGNbZiArIFwiV2lkdGhcIl0sICFuICYmIGUuaXNYQXhpcyA/IDEgOiAwKTtcbiAgICAgICAgYyA9IGNbZiArIFwiQ29sb3JcIl07XG4gICAgICAgIGEgJiYgKGUub3Bwb3NpdGUgJiYgKGFbMF0gPSAtYVswXSksIHYgJiYgKHRoaXMubWFyayA9IGwgPSBrLnBhdGgoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtXCIgKyAobiA/IG4gKyBcIi1cIiA6IFwiXCIpICsgXCJ0aWNrXCIpLmFkZChlLmF4aXNHcm91cCksIGUuY2hhcnQuc3R5bGVkTW9kZSB8fCBsLmF0dHIoe1xuICAgICAgICAgIHN0cm9rZTogYyxcbiAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiB3XG4gICAgICAgIH0pKSwgbFt2ID8gXCJhdHRyXCIgOiBcImFuaW1hdGVcIl0oe1xuICAgICAgICAgIGQ6IHRoaXMuZ2V0TWFya1BhdGgoeiwgZCwgYVswXSwgbC5zdHJva2VXaWR0aCgpICogaCwgZS5ob3JpeiwgayksXG4gICAgICAgICAgb3BhY2l0eTogcVxuICAgICAgICB9KSk7XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5yZW5kZXJMYWJlbCA9IGZ1bmN0aW9uIChkLCBxLCBoLCBlKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5heGlzLFxuICAgICAgICAgICAgayA9IGMuaG9yaXosXG4gICAgICAgICAgICBuID0gYy5vcHRpb25zLFxuICAgICAgICAgICAgZiA9IHRoaXMubGFiZWwsXG4gICAgICAgICAgICBhID0gbi5sYWJlbHMsXG4gICAgICAgICAgICBsID0gYS5zdGVwO1xuICAgICAgICBjID0geSh0aGlzLnRpY2ttYXJrT2Zmc2V0LCBjLnRpY2ttYXJrT2Zmc2V0KTtcbiAgICAgICAgdmFyIHYgPSAhMCxcbiAgICAgICAgICAgIHogPSBkLng7XG4gICAgICAgIGQgPSBkLnk7XG4gICAgICAgIGYgJiYgQSh6KSAmJiAoZi54eSA9IGQgPSB0aGlzLmdldExhYmVsUG9zaXRpb24oeiwgZCwgZiwgaywgYSwgYywgZSwgbCksIHRoaXMuaXNGaXJzdCAmJiAhdGhpcy5pc0xhc3QgJiYgIXkobi5zaG93Rmlyc3RMYWJlbCwgMSkgfHwgdGhpcy5pc0xhc3QgJiYgIXRoaXMuaXNGaXJzdCAmJiAheShuLnNob3dMYXN0TGFiZWwsIDEpID8gdiA9ICExIDogIWsgfHwgYS5zdGVwIHx8IGEucm90YXRpb24gfHwgcSB8fCAwID09PSBoIHx8IHRoaXMuaGFuZGxlT3ZlcmZsb3coZCksIGwgJiYgZSAlIGwgJiYgKHYgPSAhMSksIHYgJiYgQShkLnkpID8gKGQub3BhY2l0eSA9IGgsIGZbdGhpcy5pc05ld0xhYmVsID8gXCJhdHRyXCIgOiBcImFuaW1hdGVcIl0oZCksIHRoaXMuaXNOZXdMYWJlbCA9ICExKSA6IChmLmF0dHIoXCJ5XCIsIC05OTk5KSwgdGhpcy5pc05ld0xhYmVsID0gITApKTtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLnJlcGxhY2VNb3ZlZExhYmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZCA9IHRoaXMubGFiZWwsXG4gICAgICAgICAgICBxID0gdGhpcy5heGlzLFxuICAgICAgICAgICAgaCA9IHEucmV2ZXJzZWQsXG4gICAgICAgICAgICBlID0gdGhpcy5heGlzLmNoYXJ0LmludmVydGVkO1xuXG4gICAgICAgIGlmIChkICYmICF0aGlzLmlzTmV3KSB7XG4gICAgICAgICAgdmFyIGMgPSBlID8gZC54eS54IDogaCA/IHEubGVmdCA6IHEud2lkdGggKyBxLmxlZnQ7XG4gICAgICAgICAgaCA9IGUgPyBoID8gcS53aWR0aCArIHEudG9wIDogcS50b3AgOiBkLnh5Lnk7XG4gICAgICAgICAgZC5hbmltYXRlKHtcbiAgICAgICAgICAgIHg6IGMsXG4gICAgICAgICAgICB5OiBoLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sIHZvaWQgMCwgZC5kZXN0cm95KTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5sYWJlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHEuaXNEaXJ0eSA9ICEwO1xuICAgICAgICB0aGlzLmxhYmVsID0gdGhpcy5tb3ZlZExhYmVsO1xuICAgICAgICBkZWxldGUgdGhpcy5tb3ZlZExhYmVsO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGg7XG4gICAgfSgpO1xuXG4gICAgZC5UaWNrID0gZztcbiAgICByZXR1cm4gZC5UaWNrO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL1RpbWUuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcpIHtcbiAgICB2YXIgciA9IGcuZGVmaW5lZCxcbiAgICAgICAgdSA9IGcuZXJyb3IsXG4gICAgICAgIEkgPSBnLmV4dGVuZCxcbiAgICAgICAgTSA9IGcuaXNPYmplY3QsXG4gICAgICAgIEUgPSBnLm1lcmdlLFxuICAgICAgICBBID0gZy5vYmplY3RFYWNoLFxuICAgICAgICBHID0gZy5wYWQsXG4gICAgICAgIEogPSBnLnBpY2ssXG4gICAgICAgIHkgPSBnLnNwbGF0LFxuICAgICAgICB0ID0gZy50aW1lVW5pdHMsXG4gICAgICAgIEQgPSBkLndpbjtcblxuICAgIGcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBoKGQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIHRoaXMudmFyaWFibGVUaW1lem9uZSA9IHRoaXMudXNlVVRDID0gITE7XG4gICAgICAgIHRoaXMuRGF0ZSA9IEQuRGF0ZTtcbiAgICAgICAgdGhpcy5nZXRUaW1lem9uZU9mZnNldCA9IHRoaXMudGltZXpvbmVPZmZzZXRGdW5jdGlvbigpO1xuICAgICAgICB0aGlzLnVwZGF0ZShkKTtcbiAgICAgIH1cblxuICAgICAgaC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGQsIHEpIHtcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGVUaW1lem9uZSB8fCB0aGlzLnRpbWV6b25lT2Zmc2V0KSB7XG4gICAgICAgICAgdmFyIGggPSBxLmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgZSA9IGggLSB0aGlzLmdldFRpbWV6b25lT2Zmc2V0KHEpO1xuICAgICAgICAgIHEuc2V0VGltZShlKTtcbiAgICAgICAgICBkID0gcVtcImdldFVUQ1wiICsgZF0oKTtcbiAgICAgICAgICBxLnNldFRpbWUoaCk7XG4gICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy51c2VVVEMgPyBxW1wiZ2V0VVRDXCIgKyBkXSgpIDogcVtcImdldFwiICsgZF0oKTtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChkLCBxLCBoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhcmlhYmxlVGltZXpvbmUgfHwgdGhpcy50aW1lem9uZU9mZnNldCkge1xuICAgICAgICAgIGlmIChcIk1pbGxpc2Vjb25kc1wiID09PSBkIHx8IFwiU2Vjb25kc1wiID09PSBkIHx8IFwiTWludXRlc1wiID09PSBkKSByZXR1cm4gcVtcInNldFVUQ1wiICsgZF0oaCk7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLmdldFRpbWV6b25lT2Zmc2V0KHEpO1xuICAgICAgICAgIGUgPSBxLmdldFRpbWUoKSAtIGU7XG4gICAgICAgICAgcS5zZXRUaW1lKGUpO1xuICAgICAgICAgIHFbXCJzZXRVVENcIiArIGRdKGgpO1xuICAgICAgICAgIGQgPSB0aGlzLmdldFRpbWV6b25lT2Zmc2V0KHEpO1xuICAgICAgICAgIGUgPSBxLmdldFRpbWUoKSArIGQ7XG4gICAgICAgICAgcmV0dXJuIHEuc2V0VGltZShlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnVzZVVUQyA/IHFbXCJzZXRVVENcIiArIGRdKGgpIDogcVtcInNldFwiICsgZF0oaCk7XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgcSA9IEooZCAmJiBkLnVzZVVUQywgITApO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBkID0gRSghMCwgdGhpcy5vcHRpb25zIHx8IHt9LCBkKTtcbiAgICAgICAgdGhpcy5EYXRlID0gZC5EYXRlIHx8IEQuRGF0ZSB8fCBEYXRlO1xuICAgICAgICB0aGlzLnRpbWV6b25lT2Zmc2V0ID0gKHRoaXMudXNlVVRDID0gcSkgJiYgZC50aW1lem9uZU9mZnNldDtcbiAgICAgICAgdGhpcy5nZXRUaW1lem9uZU9mZnNldCA9IHRoaXMudGltZXpvbmVPZmZzZXRGdW5jdGlvbigpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlVGltZXpvbmUgPSAhKHEgJiYgIWQuZ2V0VGltZXpvbmVPZmZzZXQgJiYgIWQudGltZXpvbmUpO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUubWFrZVRpbWUgPSBmdW5jdGlvbiAoaCwgcSwgdCwgZSwgYywgaykge1xuICAgICAgICBpZiAodGhpcy51c2VVVEMpIHtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMuRGF0ZS5VVEMuYXBwbHkoMCwgYXJndW1lbnRzKTtcbiAgICAgICAgICB2YXIgZiA9IHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQobik7XG4gICAgICAgICAgbiArPSBmO1xuICAgICAgICAgIHZhciBhID0gdGhpcy5nZXRUaW1lem9uZU9mZnNldChuKTtcbiAgICAgICAgICBmICE9PSBhID8gbiArPSBhIC0gZiA6IGYgLSAzNkU1ICE9PSB0aGlzLmdldFRpbWV6b25lT2Zmc2V0KG4gLSAzNkU1KSB8fCBkLmlzU2FmYXJpIHx8IChuIC09IDM2RTUpO1xuICAgICAgICB9IGVsc2UgbiA9IG5ldyB0aGlzLkRhdGUoaCwgcSwgSih0LCAxKSwgSihlLCAwKSwgSihjLCAwKSwgSihrLCAwKSkuZ2V0VGltZSgpO1xuXG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUudGltZXpvbmVPZmZzZXRGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgICAgcSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGggPSBELm1vbWVudDtcbiAgICAgICAgaWYgKCF0aGlzLnVzZVVUQykgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIDZFNCAqIG5ldyBEYXRlKGUudG9TdHJpbmcoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocS50aW1lem9uZSkge1xuICAgICAgICAgIGlmIChoKSByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiA2RTQgKiAtaC50eihlLCBxLnRpbWV6b25lKS51dGNPZmZzZXQoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHUoMjUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXNlVVRDICYmIHEuZ2V0VGltZXpvbmVPZmZzZXQgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiA2RTQgKiBxLmdldFRpbWV6b25lT2Zmc2V0KGUudmFsdWVPZigpKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gNkU0ICogKGQudGltZXpvbmVPZmZzZXQgfHwgMCk7XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5kYXRlRm9ybWF0ID0gZnVuY3Rpb24gKGgsIHEsIHQpIHtcbiAgICAgICAgdmFyIGU7XG4gICAgICAgIGlmICghcihxKSB8fCBpc05hTihxKSkgcmV0dXJuIChudWxsID09PSAoZSA9IGQuZGVmYXVsdE9wdGlvbnMubGFuZykgfHwgdm9pZCAwID09PSBlID8gdm9pZCAwIDogZS5pbnZhbGlkRGF0ZSkgfHwgXCJcIjtcbiAgICAgICAgaCA9IEooaCwgXCIlWS0lbS0lZCAlSDolTTolU1wiKTtcbiAgICAgICAgdmFyIGMgPSB0aGlzO1xuICAgICAgICBlID0gbmV3IHRoaXMuRGF0ZShxKTtcbiAgICAgICAgdmFyIGsgPSB0aGlzLmdldChcIkhvdXJzXCIsIGUpLFxuICAgICAgICAgICAgbiA9IHRoaXMuZ2V0KFwiRGF5XCIsIGUpLFxuICAgICAgICAgICAgZiA9IHRoaXMuZ2V0KFwiRGF0ZVwiLCBlKSxcbiAgICAgICAgICAgIGEgPSB0aGlzLmdldChcIk1vbnRoXCIsIGUpLFxuICAgICAgICAgICAgbCA9IHRoaXMuZ2V0KFwiRnVsbFllYXJcIiwgZSksXG4gICAgICAgICAgICB2ID0gZC5kZWZhdWx0T3B0aW9ucy5sYW5nLFxuICAgICAgICAgICAgeiA9IG51bGwgPT09IHYgfHwgdm9pZCAwID09PSB2ID8gdm9pZCAwIDogdi53ZWVrZGF5cyxcbiAgICAgICAgICAgIHcgPSBudWxsID09PSB2IHx8IHZvaWQgMCA9PT0gdiA/IHZvaWQgMCA6IHYuc2hvcnRXZWVrZGF5cztcbiAgICAgICAgZSA9IEkoe1xuICAgICAgICAgIGE6IHcgPyB3W25dIDogeltuXS5zdWJzdHIoMCwgMyksXG4gICAgICAgICAgQTogeltuXSxcbiAgICAgICAgICBkOiBHKGYpLFxuICAgICAgICAgIGU6IEcoZiwgMiwgXCIgXCIpLFxuICAgICAgICAgIHc6IG4sXG4gICAgICAgICAgYjogdi5zaG9ydE1vbnRoc1thXSxcbiAgICAgICAgICBCOiB2Lm1vbnRoc1thXSxcbiAgICAgICAgICBtOiBHKGEgKyAxKSxcbiAgICAgICAgICBvOiBhICsgMSxcbiAgICAgICAgICB5OiBsLnRvU3RyaW5nKCkuc3Vic3RyKDIsIDIpLFxuICAgICAgICAgIFk6IGwsXG4gICAgICAgICAgSDogRyhrKSxcbiAgICAgICAgICBrOiBrLFxuICAgICAgICAgIEk6IEcoayAlIDEyIHx8IDEyKSxcbiAgICAgICAgICBsOiBrICUgMTIgfHwgMTIsXG4gICAgICAgICAgTTogRyh0aGlzLmdldChcIk1pbnV0ZXNcIiwgZSkpLFxuICAgICAgICAgIHA6IDEyID4gayA/IFwiQU1cIiA6IFwiUE1cIixcbiAgICAgICAgICBQOiAxMiA+IGsgPyBcImFtXCIgOiBcInBtXCIsXG4gICAgICAgICAgUzogRyhlLmdldFNlY29uZHMoKSksXG4gICAgICAgICAgTDogRyhNYXRoLmZsb29yKHEgJSAxRTMpLCAzKVxuICAgICAgICB9LCBkLmRhdGVGb3JtYXRzKTtcbiAgICAgICAgQShlLCBmdW5jdGlvbiAoYSwgZikge1xuICAgICAgICAgIGZvciAoOyAtMSAhPT0gaC5pbmRleE9mKFwiJVwiICsgZik7KSBoID0gaC5yZXBsYWNlKFwiJVwiICsgZiwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYSA/IGEuY2FsbChjLCBxKSA6IGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHQgPyBoLnN1YnN0cigwLCAxKS50b1VwcGVyQ2FzZSgpICsgaC5zdWJzdHIoMSkgOiBoO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUucmVzb2x2ZURUTEZvcm1hdCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBNKGQsICEwKSA/IGQgOiAoZCA9IHkoZCksIHtcbiAgICAgICAgICBtYWluOiBkWzBdLFxuICAgICAgICAgIGZyb206IGRbMV0sXG4gICAgICAgICAgdG86IGRbMl1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5nZXRUaW1lVGlja3MgPSBmdW5jdGlvbiAoZCwgaCwgZywgZSkge1xuICAgICAgICB2YXIgYyA9IHRoaXMsXG4gICAgICAgICAgICBrID0gW10sXG4gICAgICAgICAgICBuID0ge307XG4gICAgICAgIHZhciBmID0gbmV3IGMuRGF0ZShoKTtcbiAgICAgICAgdmFyIGEgPSBkLnVuaXRSYW5nZSxcbiAgICAgICAgICAgIGwgPSBkLmNvdW50IHx8IDEsXG4gICAgICAgICAgICB2O1xuICAgICAgICBlID0gSihlLCAxKTtcblxuICAgICAgICBpZiAocihoKSkge1xuICAgICAgICAgIGMuc2V0KFwiTWlsbGlzZWNvbmRzXCIsIGYsIGEgPj0gdC5zZWNvbmQgPyAwIDogbCAqIE1hdGguZmxvb3IoYy5nZXQoXCJNaWxsaXNlY29uZHNcIiwgZikgLyBsKSk7XG4gICAgICAgICAgYSA+PSB0LnNlY29uZCAmJiBjLnNldChcIlNlY29uZHNcIiwgZiwgYSA+PSB0Lm1pbnV0ZSA/IDAgOiBsICogTWF0aC5mbG9vcihjLmdldChcIlNlY29uZHNcIiwgZikgLyBsKSk7XG4gICAgICAgICAgYSA+PSB0Lm1pbnV0ZSAmJiBjLnNldChcIk1pbnV0ZXNcIiwgZiwgYSA+PSB0LmhvdXIgPyAwIDogbCAqIE1hdGguZmxvb3IoYy5nZXQoXCJNaW51dGVzXCIsIGYpIC8gbCkpO1xuICAgICAgICAgIGEgPj0gdC5ob3VyICYmIGMuc2V0KFwiSG91cnNcIiwgZiwgYSA+PSB0LmRheSA/IDAgOiBsICogTWF0aC5mbG9vcihjLmdldChcIkhvdXJzXCIsIGYpIC8gbCkpO1xuICAgICAgICAgIGEgPj0gdC5kYXkgJiYgYy5zZXQoXCJEYXRlXCIsIGYsIGEgPj0gdC5tb250aCA/IDEgOiBNYXRoLm1heCgxLCBsICogTWF0aC5mbG9vcihjLmdldChcIkRhdGVcIiwgZikgLyBsKSkpO1xuXG4gICAgICAgICAgaWYgKGEgPj0gdC5tb250aCkge1xuICAgICAgICAgICAgYy5zZXQoXCJNb250aFwiLCBmLCBhID49IHQueWVhciA/IDAgOiBsICogTWF0aC5mbG9vcihjLmdldChcIk1vbnRoXCIsIGYpIC8gbCkpO1xuICAgICAgICAgICAgdmFyIHogPSBjLmdldChcIkZ1bGxZZWFyXCIsIGYpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGEgPj0gdC55ZWFyICYmIGMuc2V0KFwiRnVsbFllYXJcIiwgZiwgeiAtIHogJSBsKTtcbiAgICAgICAgICBhID09PSB0LndlZWsgJiYgKHogPSBjLmdldChcIkRheVwiLCBmKSwgYy5zZXQoXCJEYXRlXCIsIGYsIGMuZ2V0KFwiRGF0ZVwiLCBmKSAtIHogKyBlICsgKHogPCBlID8gLTcgOiAwKSkpO1xuICAgICAgICAgIHogPSBjLmdldChcIkZ1bGxZZWFyXCIsIGYpO1xuICAgICAgICAgIGUgPSBjLmdldChcIk1vbnRoXCIsIGYpO1xuICAgICAgICAgIHZhciB3ID0gYy5nZXQoXCJEYXRlXCIsIGYpLFxuICAgICAgICAgICAgICBxID0gYy5nZXQoXCJIb3Vyc1wiLCBmKTtcbiAgICAgICAgICBoID0gZi5nZXRUaW1lKCk7XG4gICAgICAgICAgYy52YXJpYWJsZVRpbWV6b25lICYmICh2ID0gZyAtIGggPiA0ICogdC5tb250aCB8fCBjLmdldFRpbWV6b25lT2Zmc2V0KGgpICE9PSBjLmdldFRpbWV6b25lT2Zmc2V0KGcpKTtcbiAgICAgICAgICBoID0gZi5nZXRUaW1lKCk7XG5cbiAgICAgICAgICBmb3IgKGYgPSAxOyBoIDwgZzspIGsucHVzaChoKSwgaCA9IGEgPT09IHQueWVhciA/IGMubWFrZVRpbWUoeiArIGYgKiBsLCAwKSA6IGEgPT09IHQubW9udGggPyBjLm1ha2VUaW1lKHosIGUgKyBmICogbCkgOiAhdiB8fCBhICE9PSB0LmRheSAmJiBhICE9PSB0LndlZWsgPyB2ICYmIGEgPT09IHQuaG91ciAmJiAxIDwgbCA/IGMubWFrZVRpbWUoeiwgZSwgdywgcSArIGYgKiBsKSA6IGggKyBhICogbCA6IGMubWFrZVRpbWUoeiwgZSwgdyArIGYgKiBsICogKGEgPT09IHQuZGF5ID8gMSA6IDcpKSwgZisrO1xuXG4gICAgICAgICAgay5wdXNoKGgpO1xuICAgICAgICAgIGEgPD0gdC5ob3VyICYmIDFFNCA+IGsubGVuZ3RoICYmIGsuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgMCA9PT0gYSAlIDE4RTUgJiYgXCIwMDAwMDAwMDBcIiA9PT0gYy5kYXRlRm9ybWF0KFwiJUglTSVTJUxcIiwgYSkgJiYgKG5bYV0gPSBcImRheVwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGsuaW5mbyA9IEkoZCwge1xuICAgICAgICAgIGhpZ2hlclJhbmtzOiBuLFxuICAgICAgICAgIHRvdGFsUmFuZ2U6IGEgKiBsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaztcbiAgICAgIH07XG5cbiAgICAgIGguZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIERhdGU6IHZvaWQgMCxcbiAgICAgICAgZ2V0VGltZXpvbmVPZmZzZXQ6IHZvaWQgMCxcbiAgICAgICAgdGltZXpvbmU6IHZvaWQgMCxcbiAgICAgICAgdGltZXpvbmVPZmZzZXQ6IDAsXG4gICAgICAgIHVzZVVUQzogITBcbiAgICAgIH07XG4gICAgICByZXR1cm4gaDtcbiAgICB9KCk7XG5cbiAgICBkLlRpbWUgPSBnO1xuICAgIHJldHVybiBkLlRpbWU7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvT3B0aW9ucy5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9UaW1lLmpzXCJdLCByW1wicGFydHMvQ29sb3IuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZywgciwgdSkge1xuICAgIHIgPSByLnBhcnNlO1xuICAgIHZhciBJID0gdS5tZXJnZTtcbiAgICBkLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgY29sb3JzOiBcIiM3Y2I1ZWMgIzQzNDM0OCAjOTBlZDdkICNmN2EzNWMgIzgwODVlOSAjZjE1YzgwICNlNGQzNTQgIzJiOTA4ZiAjZjQ1YjViICM5MWU4ZTFcIi5zcGxpdChcIiBcIiksXG4gICAgICBzeW1ib2xzOiBbXCJjaXJjbGVcIiwgXCJkaWFtb25kXCIsIFwic3F1YXJlXCIsIFwidHJpYW5nbGVcIiwgXCJ0cmlhbmdsZS1kb3duXCJdLFxuICAgICAgbGFuZzoge1xuICAgICAgICBsb2FkaW5nOiBcIkxvYWRpbmcuLi5cIixcbiAgICAgICAgbW9udGhzOiBcIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIiksXG4gICAgICAgIHNob3J0TW9udGhzOiBcIkphbiBGZWIgTWFyIEFwciBNYXkgSnVuIEp1bCBBdWcgU2VwIE9jdCBOb3YgRGVjXCIuc3BsaXQoXCIgXCIpLFxuICAgICAgICB3ZWVrZGF5czogXCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgZGVjaW1hbFBvaW50OiBcIi5cIixcbiAgICAgICAgbnVtZXJpY1N5bWJvbHM6IFwia01HVFBFXCIuc3BsaXQoXCJcIiksXG4gICAgICAgIHJlc2V0Wm9vbTogXCJSZXNldCB6b29tXCIsXG4gICAgICAgIHJlc2V0Wm9vbVRpdGxlOiBcIlJlc2V0IHpvb20gbGV2ZWwgMToxXCIsXG4gICAgICAgIHRob3VzYW5kc1NlcDogXCIgXCJcbiAgICAgIH0sXG4gICAgICBnbG9iYWw6IHt9LFxuICAgICAgdGltZTogZy5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIGNoYXJ0OiB7XG4gICAgICAgIHN0eWxlZE1vZGU6ICExLFxuICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgIGNvbG9yQ291bnQ6IDEwLFxuICAgICAgICBkZWZhdWx0U2VyaWVzVHlwZTogXCJsaW5lXCIsXG4gICAgICAgIGlnbm9yZUhpZGRlblNlcmllczogITAsXG4gICAgICAgIHNwYWNpbmc6IFsxMCwgMTAsIDE1LCAxMF0sXG4gICAgICAgIHJlc2V0Wm9vbUJ1dHRvbjoge1xuICAgICAgICAgIHRoZW1lOiB7XG4gICAgICAgICAgICB6SW5kZXg6IDZcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICBhbGlnbjogXCJyaWdodFwiLFxuICAgICAgICAgICAgeDogLTEwLFxuICAgICAgICAgICAgeTogMTBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdpZHRoOiBudWxsLFxuICAgICAgICBoZWlnaHQ6IG51bGwsXG4gICAgICAgIGJvcmRlckNvbG9yOiBcIiMzMzVjYWRcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmZmZmZmZcIixcbiAgICAgICAgcGxvdEJvcmRlckNvbG9yOiBcIiNjY2NjY2NcIlxuICAgICAgfSxcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIHRleHQ6IFwiQ2hhcnQgdGl0bGVcIixcbiAgICAgICAgYWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgIG1hcmdpbjogMTUsXG4gICAgICAgIHdpZHRoQWRqdXN0OiAtNDRcbiAgICAgIH0sXG4gICAgICBzdWJ0aXRsZToge1xuICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICBhbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgd2lkdGhBZGp1c3Q6IC00NFxuICAgICAgfSxcbiAgICAgIGNhcHRpb246IHtcbiAgICAgICAgbWFyZ2luOiAxNSxcbiAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgYWxpZ246IFwibGVmdFwiLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcImJvdHRvbVwiXG4gICAgICB9LFxuICAgICAgcGxvdE9wdGlvbnM6IHt9LFxuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICBjb2xvcjogXCIjMzMzMzMzXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBlbmFibGVkOiAhMCxcbiAgICAgICAgYWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgIGFsaWduQ29sdW1uczogITAsXG4gICAgICAgIGxheW91dDogXCJob3Jpem9udGFsXCIsXG4gICAgICAgIGxhYmVsRm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzk5OTk5OVwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgIG5hdmlnYXRpb246IHtcbiAgICAgICAgICBhY3RpdmVDb2xvcjogXCIjMDAzMzk5XCIsXG4gICAgICAgICAgaW5hY3RpdmVDb2xvcjogXCIjY2NjY2NjXCJcbiAgICAgICAgfSxcbiAgICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgICAgY29sb3I6IFwiIzMzMzMzM1wiLFxuICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgICAgICAgZm9udFNpemU6IFwiMTJweFwiLFxuICAgICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiLFxuICAgICAgICAgIHRleHRPdmVyZmxvdzogXCJlbGxpcHNpc1wiXG4gICAgICAgIH0sXG4gICAgICAgIGl0ZW1Ib3ZlclN0eWxlOiB7XG4gICAgICAgICAgY29sb3I6IFwiIzAwMDAwMFwiXG4gICAgICAgIH0sXG4gICAgICAgIGl0ZW1IaWRkZW5TdHlsZToge1xuICAgICAgICAgIGNvbG9yOiBcIiNjY2NjY2NcIlxuICAgICAgICB9LFxuICAgICAgICBzaGFkb3c6ICExLFxuICAgICAgICBpdGVtQ2hlY2tib3hTdHlsZToge1xuICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgd2lkdGg6IFwiMTNweFwiLFxuICAgICAgICAgIGhlaWdodDogXCIxM3B4XCJcbiAgICAgICAgfSxcbiAgICAgICAgc3F1YXJlU3ltYm9sOiAhMCxcbiAgICAgICAgc3ltYm9sUGFkZGluZzogNSxcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJib3R0b21cIixcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsb2FkaW5nOiB7XG4gICAgICAgIGxhYmVsU3R5bGU6IHtcbiAgICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIixcbiAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgIHRvcDogXCI0NSVcIlxuICAgICAgICB9LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmZmZmZmZcIixcbiAgICAgICAgICBvcGFjaXR5OiAuNSxcbiAgICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgZW5hYmxlZDogITAsXG4gICAgICAgIGFuaW1hdGlvbjogZC5zdmcsXG4gICAgICAgIGJvcmRlclJhZGl1czogMyxcbiAgICAgICAgZGF0ZVRpbWVMYWJlbEZvcm1hdHM6IHtcbiAgICAgICAgICBtaWxsaXNlY29uZDogXCIlQSwgJWIgJWUsICVIOiVNOiVTLiVMXCIsXG4gICAgICAgICAgc2Vjb25kOiBcIiVBLCAlYiAlZSwgJUg6JU06JVNcIixcbiAgICAgICAgICBtaW51dGU6IFwiJUEsICViICVlLCAlSDolTVwiLFxuICAgICAgICAgIGhvdXI6IFwiJUEsICViICVlLCAlSDolTVwiLFxuICAgICAgICAgIGRheTogXCIlQSwgJWIgJWUsICVZXCIsXG4gICAgICAgICAgd2VlazogXCJXZWVrIGZyb20gJUEsICViICVlLCAlWVwiLFxuICAgICAgICAgIG1vbnRoOiBcIiVCICVZXCIsXG4gICAgICAgICAgeWVhcjogXCIlWVwiXG4gICAgICAgIH0sXG4gICAgICAgIGZvb3RlckZvcm1hdDogXCJcIixcbiAgICAgICAgcGFkZGluZzogOCxcbiAgICAgICAgc25hcDogZC5pc1RvdWNoRGV2aWNlID8gMjUgOiAxMCxcbiAgICAgICAgaGVhZGVyRm9ybWF0OiAnPHNwYW4gc3R5bGU9XCJmb250LXNpemU6IDEwcHhcIj57cG9pbnQua2V5fTwvc3Bhbj48YnIvPicsXG4gICAgICAgIHBvaW50Rm9ybWF0OiAnPHNwYW4gc3R5bGU9XCJjb2xvcjp7cG9pbnQuY29sb3J9XCI+XFx1MjVjZjwvc3Bhbj4ge3Nlcmllcy5uYW1lfTogPGI+e3BvaW50Lnl9PC9iPjxici8+JyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiByKFwiI2Y3ZjdmN1wiKS5zZXRPcGFjaXR5KC44NSkuZ2V0KCksXG4gICAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgICBzaGFkb3c6ICEwLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGNvbG9yOiBcIiMzMzMzMzNcIixcbiAgICAgICAgICBjdXJzb3I6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgIGZvbnRTaXplOiBcIjEycHhcIixcbiAgICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVkaXRzOiB7XG4gICAgICAgIGVuYWJsZWQ6ICEwLFxuICAgICAgICBocmVmOiBcImh0dHBzOi8vd3d3LmhpZ2hjaGFydHMuY29tP2NyZWRpdHNcIixcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBhbGlnbjogXCJyaWdodFwiLFxuICAgICAgICAgIHg6IC0xMCxcbiAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcImJvdHRvbVwiLFxuICAgICAgICAgIHk6IC01XG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIixcbiAgICAgICAgICBjb2xvcjogXCIjOTk5OTk5XCIsXG4gICAgICAgICAgZm9udFNpemU6IFwiOXB4XCJcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dDogXCJIaWdoY2hhcnRzLmNvbVwiXG4gICAgICB9XG4gICAgfTtcblxuICAgIGQuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChnKSB7XG4gICAgICBkLmRlZmF1bHRPcHRpb25zID0gSSghMCwgZC5kZWZhdWx0T3B0aW9ucywgZyk7XG4gICAgICAoZy50aW1lIHx8IGcuZ2xvYmFsKSAmJiBkLnRpbWUudXBkYXRlKEkoZC5kZWZhdWx0T3B0aW9ucy5nbG9iYWwsIGQuZGVmYXVsdE9wdGlvbnMudGltZSwgZy5nbG9iYWwsIGcudGltZSkpO1xuICAgICAgcmV0dXJuIGQuZGVmYXVsdE9wdGlvbnM7XG4gICAgfTtcblxuICAgIGQuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkLmRlZmF1bHRPcHRpb25zO1xuICAgIH07XG5cbiAgICBkLmRlZmF1bHRQbG90T3B0aW9ucyA9IGQuZGVmYXVsdE9wdGlvbnMucGxvdE9wdGlvbnM7XG4gICAgZC50aW1lID0gbmV3IGcoSShkLmRlZmF1bHRPcHRpb25zLmdsb2JhbCwgZC5kZWZhdWx0T3B0aW9ucy50aW1lKSk7XG5cbiAgICBkLmRhdGVGb3JtYXQgPSBmdW5jdGlvbiAoZywgdSwgQSkge1xuICAgICAgcmV0dXJuIGQudGltZS5kYXRlRm9ybWF0KGcsIHUsIEEpO1xuICAgIH07XG5cbiAgICBcIlwiO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL0F4aXMuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvQ29sb3IuanNcIl0sIHJbXCJwYXJ0cy9UaWNrLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcsIHIsIHUpIHtcbiAgICB2YXIgSSA9IGcucGFyc2UsXG4gICAgICAgIE0gPSB1LmFkZEV2ZW50LFxuICAgICAgICBFID0gdS5hbmltT2JqZWN0LFxuICAgICAgICBBID0gdS5hcnJheU1heCxcbiAgICAgICAgRyA9IHUuYXJyYXlNaW4sXG4gICAgICAgIEogPSB1LmNsYW1wLFxuICAgICAgICB5ID0gdS5jb3JyZWN0RmxvYXQsXG4gICAgICAgIHQgPSB1LmRlZmluZWQsXG4gICAgICAgIEQgPSB1LmRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzLFxuICAgICAgICBoID0gdS5lcnJvcixcbiAgICAgICAgTiA9IHUuZXh0ZW5kLFxuICAgICAgICBxID0gdS5maXJlRXZlbnQsXG4gICAgICAgIFAgPSB1LmZvcm1hdCxcbiAgICAgICAgZSA9IHUuZ2V0TWFnbml0dWRlLFxuICAgICAgICBjID0gdS5pc0FycmF5LFxuICAgICAgICBrID0gdS5pc0Z1bmN0aW9uLFxuICAgICAgICBuID0gdS5pc051bWJlcixcbiAgICAgICAgZiA9IHUuaXNTdHJpbmcsXG4gICAgICAgIGEgPSB1Lm1lcmdlLFxuICAgICAgICBsID0gdS5ub3JtYWxpemVUaWNrSW50ZXJ2YWwsXG4gICAgICAgIHYgPSB1Lm9iamVjdEVhY2gsXG4gICAgICAgIHogPSB1LnBpY2ssXG4gICAgICAgIHcgPSB1LnJlbGF0aXZlTGVuZ3RoLFxuICAgICAgICBCID0gdS5yZW1vdmVFdmVudCxcbiAgICAgICAgTCA9IHUuc3BsYXQsXG4gICAgICAgIFEgPSB1LnN5bmNUaW1lb3V0LFxuICAgICAgICBIID0gZC5kZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgSyA9IGQuZGVnMnJhZDtcblxuICAgIGcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgTihnLnByb3RvdHlwZSwge1xuICAgICAgZGVmYXVsdE9wdGlvbnM6IHtcbiAgICAgICAgZGF0ZVRpbWVMYWJlbEZvcm1hdHM6IHtcbiAgICAgICAgICBtaWxsaXNlY29uZDoge1xuICAgICAgICAgICAgbWFpbjogXCIlSDolTTolUy4lTFwiLFxuICAgICAgICAgICAgcmFuZ2U6ICExXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZWNvbmQ6IHtcbiAgICAgICAgICAgIG1haW46IFwiJUg6JU06JVNcIixcbiAgICAgICAgICAgIHJhbmdlOiAhMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWludXRlOiB7XG4gICAgICAgICAgICBtYWluOiBcIiVIOiVNXCIsXG4gICAgICAgICAgICByYW5nZTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhvdXI6IHtcbiAgICAgICAgICAgIG1haW46IFwiJUg6JU1cIixcbiAgICAgICAgICAgIHJhbmdlOiAhMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGF5OiB7XG4gICAgICAgICAgICBtYWluOiBcIiVlLiAlYlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICB3ZWVrOiB7XG4gICAgICAgICAgICBtYWluOiBcIiVlLiAlYlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtb250aDoge1xuICAgICAgICAgICAgbWFpbjogXCIlYiAnJXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgeWVhcjoge1xuICAgICAgICAgICAgbWFpbjogXCIlWVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbmRPblRpY2s6ICExLFxuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICBlbmFibGVkOiAhMCxcbiAgICAgICAgICBpbmRlbnRhdGlvbjogMTAsXG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgY29sb3I6IFwiIzY2NjY2NlwiLFxuICAgICAgICAgICAgY3Vyc29yOiBcImRlZmF1bHRcIixcbiAgICAgICAgICAgIGZvbnRTaXplOiBcIjExcHhcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWF4UGFkZGluZzogLjAxLFxuICAgICAgICBtaW5vclRpY2tMZW5ndGg6IDIsXG4gICAgICAgIG1pbm9yVGlja1Bvc2l0aW9uOiBcIm91dHNpZGVcIixcbiAgICAgICAgbWluUGFkZGluZzogLjAxLFxuICAgICAgICBzaG93RW1wdHk6ICEwLFxuICAgICAgICBzdGFydE9mV2VlazogMSxcbiAgICAgICAgc3RhcnRPblRpY2s6ICExLFxuICAgICAgICB0aWNrTGVuZ3RoOiAxMCxcbiAgICAgICAgdGlja1BpeGVsSW50ZXJ2YWw6IDEwMCxcbiAgICAgICAgdGlja21hcmtQbGFjZW1lbnQ6IFwiYmV0d2VlblwiLFxuICAgICAgICB0aWNrUG9zaXRpb246IFwib3V0c2lkZVwiLFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgIGFsaWduOiBcIm1pZGRsZVwiLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBjb2xvcjogXCIjNjY2NjY2XCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IFwibGluZWFyXCIsXG4gICAgICAgIG1pbm9yR3JpZExpbmVDb2xvcjogXCIjZjJmMmYyXCIsXG4gICAgICAgIG1pbm9yR3JpZExpbmVXaWR0aDogMSxcbiAgICAgICAgbWlub3JUaWNrQ29sb3I6IFwiIzk5OTk5OVwiLFxuICAgICAgICBsaW5lQ29sb3I6IFwiI2NjZDZlYlwiLFxuICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgIGdyaWRMaW5lQ29sb3I6IFwiI2U2ZTZlNlwiLFxuICAgICAgICB0aWNrQ29sb3I6IFwiI2NjZDZlYlwiXG4gICAgICB9LFxuICAgICAgZGVmYXVsdFlBeGlzT3B0aW9uczoge1xuICAgICAgICBlbmRPblRpY2s6ICEwLFxuICAgICAgICBtYXhQYWRkaW5nOiAuMDUsXG4gICAgICAgIG1pblBhZGRpbmc6IC4wNSxcbiAgICAgICAgdGlja1BpeGVsSW50ZXJ2YWw6IDcyLFxuICAgICAgICBzaG93TGFzdExhYmVsOiAhMCxcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgeDogLThcbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnRPblRpY2s6ICEwLFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgIHJvdGF0aW9uOiAyNzAsXG4gICAgICAgICAgdGV4dDogXCJWYWx1ZXNcIlxuICAgICAgICB9LFxuICAgICAgICBzdGFja0xhYmVsczoge1xuICAgICAgICAgIGFsbG93T3ZlcmxhcDogITEsXG4gICAgICAgICAgZW5hYmxlZDogITEsXG4gICAgICAgICAgY3JvcDogITAsXG4gICAgICAgICAgb3ZlcmZsb3c6IFwianVzdGlmeVwiLFxuICAgICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmF4aXMuY2hhcnQubnVtYmVyRm9ybWF0dGVyO1xuICAgICAgICAgICAgcmV0dXJuIGEodGhpcy50b3RhbCwgLTEpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGNvbG9yOiBcIiMwMDAwMDBcIixcbiAgICAgICAgICAgIGZvbnRTaXplOiBcIjExcHhcIixcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiLFxuICAgICAgICAgICAgdGV4dE91dGxpbmU6IFwiMXB4IGNvbnRyYXN0XCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdyaWRMaW5lV2lkdGg6IDEsXG4gICAgICAgIGxpbmVXaWR0aDogMFxuICAgICAgfSxcbiAgICAgIGRlZmF1bHRMZWZ0QXhpc09wdGlvbnM6IHtcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgeDogLTE1XG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgcm90YXRpb246IDI3MFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVmYXVsdFJpZ2h0QXhpc09wdGlvbnM6IHtcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgeDogMTVcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICByb3RhdGlvbjogOTBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlZmF1bHRCb3R0b21BeGlzT3B0aW9uczoge1xuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICBhdXRvUm90YXRpb246IFstNDVdLFxuICAgICAgICAgIHg6IDBcbiAgICAgICAgfSxcbiAgICAgICAgbWFyZ2luOiAxNSxcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICByb3RhdGlvbjogMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVmYXVsdFRvcEF4aXNPcHRpb25zOiB7XG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgIGF1dG9Sb3RhdGlvbjogWy00NV0sXG4gICAgICAgICAgeDogMFxuICAgICAgICB9LFxuICAgICAgICBtYXJnaW46IDE1LFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgIHJvdGF0aW9uOiAwXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbml0OiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgZiA9IGIuaXNYLFxuICAgICAgICAgICAgYyA9IHRoaXM7XG4gICAgICAgIGMuY2hhcnQgPSBhO1xuICAgICAgICBjLmhvcml6ID0gYS5pbnZlcnRlZCAmJiAhYy5pc1pBeGlzID8gIWYgOiBmO1xuICAgICAgICBjLmlzWEF4aXMgPSBmO1xuICAgICAgICBjLmNvbGwgPSBjLmNvbGwgfHwgKGYgPyBcInhBeGlzXCIgOiBcInlBeGlzXCIpO1xuICAgICAgICBxKHRoaXMsIFwiaW5pdFwiLCB7XG4gICAgICAgICAgdXNlck9wdGlvbnM6IGJcbiAgICAgICAgfSk7XG4gICAgICAgIGMub3Bwb3NpdGUgPSBiLm9wcG9zaXRlO1xuICAgICAgICBjLnNpZGUgPSBiLnNpZGUgfHwgKGMuaG9yaXogPyBjLm9wcG9zaXRlID8gMCA6IDIgOiBjLm9wcG9zaXRlID8gMSA6IDMpO1xuICAgICAgICBjLnNldE9wdGlvbnMoYik7XG4gICAgICAgIHZhciBwID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgZSA9IHAudHlwZTtcbiAgICAgICAgYy5sYWJlbEZvcm1hdHRlciA9IHAubGFiZWxzLmZvcm1hdHRlciB8fCBjLmRlZmF1bHRMYWJlbEZvcm1hdHRlcjtcbiAgICAgICAgYy51c2VyT3B0aW9ucyA9IGI7XG4gICAgICAgIGMubWluUGl4ZWxQYWRkaW5nID0gMDtcbiAgICAgICAgYy5yZXZlcnNlZCA9IHAucmV2ZXJzZWQ7XG4gICAgICAgIGMudmlzaWJsZSA9ICExICE9PSBwLnZpc2libGU7XG4gICAgICAgIGMuem9vbUVuYWJsZWQgPSAhMSAhPT0gcC56b29tRW5hYmxlZDtcbiAgICAgICAgYy5oYXNOYW1lcyA9IFwiY2F0ZWdvcnlcIiA9PT0gZSB8fCAhMCA9PT0gcC5jYXRlZ29yaWVzO1xuICAgICAgICBjLmNhdGVnb3JpZXMgPSBwLmNhdGVnb3JpZXMgfHwgYy5oYXNOYW1lcztcbiAgICAgICAgYy5uYW1lcyB8fCAoYy5uYW1lcyA9IFtdLCBjLm5hbWVzLmtleXMgPSB7fSk7XG4gICAgICAgIGMucGxvdExpbmVzQW5kQmFuZHNHcm91cHMgPSB7fTtcbiAgICAgICAgYy5pc0xvZyA9IFwibG9nYXJpdGhtaWNcIiA9PT0gZTtcbiAgICAgICAgYy5pc0RhdGV0aW1lQXhpcyA9IFwiZGF0ZXRpbWVcIiA9PT0gZTtcbiAgICAgICAgYy5wb3NpdGl2ZVZhbHVlc09ubHkgPSBjLmlzTG9nICYmICFjLmFsbG93TmVnYXRpdmVMb2c7XG4gICAgICAgIGMuaXNMaW5rZWQgPSB0KHAubGlua2VkVG8pO1xuICAgICAgICBjLnRpY2tzID0ge307XG4gICAgICAgIGMubGFiZWxFZGdlID0gW107XG4gICAgICAgIGMubWlub3JUaWNrcyA9IHt9O1xuICAgICAgICBjLnBsb3RMaW5lc0FuZEJhbmRzID0gW107XG4gICAgICAgIGMuYWx0ZXJuYXRlQmFuZHMgPSB7fTtcbiAgICAgICAgYy5sZW4gPSAwO1xuICAgICAgICBjLm1pblJhbmdlID0gYy51c2VyTWluUmFuZ2UgPSBwLm1pblJhbmdlIHx8IHAubWF4Wm9vbTtcbiAgICAgICAgYy5yYW5nZSA9IHAucmFuZ2U7XG4gICAgICAgIGMub2Zmc2V0ID0gcC5vZmZzZXQgfHwgMDtcbiAgICAgICAgYy5zdGFja3MgPSB7fTtcbiAgICAgICAgYy5vbGRTdGFja3MgPSB7fTtcbiAgICAgICAgYy5zdGFja3NUb3VjaGVkID0gMDtcbiAgICAgICAgYy5tYXggPSBudWxsO1xuICAgICAgICBjLm1pbiA9IG51bGw7XG4gICAgICAgIGMuY3Jvc3NoYWlyID0geihwLmNyb3NzaGFpciwgTChhLm9wdGlvbnMudG9vbHRpcC5jcm9zc2hhaXJzKVtmID8gMCA6IDFdLCAhMSk7XG4gICAgICAgIGIgPSBjLm9wdGlvbnMuZXZlbnRzO1xuICAgICAgICAtMSA9PT0gYS5heGVzLmluZGV4T2YoYykgJiYgKGYgPyBhLmF4ZXMuc3BsaWNlKGEueEF4aXMubGVuZ3RoLCAwLCBjKSA6IGEuYXhlcy5wdXNoKGMpLCBhW2MuY29sbF0ucHVzaChjKSk7XG4gICAgICAgIGMuc2VyaWVzID0gYy5zZXJpZXMgfHwgW107XG4gICAgICAgIGEuaW52ZXJ0ZWQgJiYgIWMuaXNaQXhpcyAmJiBmICYmIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBjLnJldmVyc2VkICYmIChjLnJldmVyc2VkID0gITApO1xuICAgICAgICB2KGIsIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgayhiKSAmJiBNKGMsIGEsIGIpO1xuICAgICAgICB9KTtcbiAgICAgICAgYy5saW4ybG9nID0gcC5saW5lYXJUb0xvZ0NvbnZlcnRlciB8fCBjLmxpbjJsb2c7XG4gICAgICAgIGMuaXNMb2cgJiYgKGMudmFsMmxpbiA9IGMubG9nMmxpbiwgYy5saW4ydmFsID0gYy5saW4ybG9nKTtcbiAgICAgICAgcSh0aGlzLCBcImFmdGVySW5pdFwiKTtcbiAgICAgIH0sXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbiAoYykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBhKHRoaXMuZGVmYXVsdE9wdGlvbnMsIFwieUF4aXNcIiA9PT0gdGhpcy5jb2xsICYmIHRoaXMuZGVmYXVsdFlBeGlzT3B0aW9ucywgW3RoaXMuZGVmYXVsdFRvcEF4aXNPcHRpb25zLCB0aGlzLmRlZmF1bHRSaWdodEF4aXNPcHRpb25zLCB0aGlzLmRlZmF1bHRCb3R0b21BeGlzT3B0aW9ucywgdGhpcy5kZWZhdWx0TGVmdEF4aXNPcHRpb25zXVt0aGlzLnNpZGVdLCBhKEhbdGhpcy5jb2xsXSwgYykpO1xuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJTZXRPcHRpb25zXCIsIHtcbiAgICAgICAgICB1c2VyT3B0aW9uczogY1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0TGFiZWxGb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmF4aXMsXG4gICAgICAgICAgICBiID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIGMgPSBhLmNoYXJ0LnRpbWUsXG4gICAgICAgICAgICBmID0gYS5jYXRlZ29yaWVzLFxuICAgICAgICAgICAgZSA9IHRoaXMuZGF0ZVRpbWVMYWJlbEZvcm1hdCxcbiAgICAgICAgICAgIGwgPSBILmxhbmcsXG4gICAgICAgICAgICBrID0gbC5udW1lcmljU3ltYm9scztcbiAgICAgICAgbCA9IGwubnVtZXJpY1N5bWJvbE1hZ25pdHVkZSB8fCAxRTM7XG4gICAgICAgIHZhciB2ID0gayAmJiBrLmxlbmd0aCxcbiAgICAgICAgICAgIG0gPSBhLm9wdGlvbnMubGFiZWxzLmZvcm1hdDtcbiAgICAgICAgYSA9IGEuaXNMb2cgPyBNYXRoLmFicyhiKSA6IGEudGlja0ludGVydmFsO1xuICAgICAgICB2YXIgbiA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBkID0gbi5udW1iZXJGb3JtYXR0ZXI7XG4gICAgICAgIGlmIChtKSB2YXIgdyA9IFAobSwgdGhpcywgbik7ZWxzZSBpZiAoZikgdyA9IGI7ZWxzZSBpZiAoZSkgdyA9IGMuZGF0ZUZvcm1hdChlLCBiKTtlbHNlIGlmICh2ICYmIDFFMyA8PSBhKSBmb3IgKDsgdi0tICYmIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiB3OykgYyA9IE1hdGgucG93KGwsIHYgKyAxKSwgYSA+PSBjICYmIDAgPT09IDEwICogYiAlIGMgJiYgbnVsbCAhPT0ga1t2XSAmJiAwICE9PSBiICYmICh3ID0gZChiIC8gYywgLTEpICsga1t2XSk7XG4gICAgICAgIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiB3ICYmICh3ID0gMUU0IDw9IE1hdGguYWJzKGIpID8gZChiLCAtMSkgOiBkKGIsIC0xLCB2b2lkIDAsIFwiXCIpKTtcbiAgICAgICAgcmV0dXJuIHc7XG4gICAgICB9LFxuICAgICAgZ2V0U2VyaWVzRXh0cmVtZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgYiA9IGEuY2hhcnQsXG4gICAgICAgICAgICBjO1xuICAgICAgICBxKHRoaXMsIFwiZ2V0U2VyaWVzRXh0cmVtZXNcIiwgbnVsbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGEuaGFzVmlzaWJsZVNlcmllcyA9ICExO1xuICAgICAgICAgIGEuZGF0YU1pbiA9IGEuZGF0YU1heCA9IGEudGhyZXNob2xkID0gbnVsbDtcbiAgICAgICAgICBhLnNvZnRUaHJlc2hvbGQgPSAhYS5pc1hBeGlzO1xuICAgICAgICAgIGEuYnVpbGRTdGFja3MgJiYgYS5idWlsZFN0YWNrcygpO1xuICAgICAgICAgIGEuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIGlmIChmLnZpc2libGUgfHwgIWIub3B0aW9ucy5jaGFydC5pZ25vcmVIaWRkZW5TZXJpZXMpIHtcbiAgICAgICAgICAgICAgdmFyIGUgPSBmLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICBwID0gZS50aHJlc2hvbGQ7XG4gICAgICAgICAgICAgIGEuaGFzVmlzaWJsZVNlcmllcyA9ICEwO1xuICAgICAgICAgICAgICBhLnBvc2l0aXZlVmFsdWVzT25seSAmJiAwID49IHAgJiYgKHAgPSBudWxsKTtcblxuICAgICAgICAgICAgICBpZiAoYS5pc1hBeGlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgPSBmLnhEYXRhLCBlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgYyA9IGYuZ2V0WEV4dHJlbWVzKGUpO1xuICAgICAgICAgICAgICAgICAgdmFyIHggPSBjLm1pbjtcbiAgICAgICAgICAgICAgICAgIHZhciBsID0gYy5tYXg7XG4gICAgICAgICAgICAgICAgICBuKHgpIHx8IHggaW5zdGFuY2VvZiBEYXRlIHx8IChlID0gZS5maWx0ZXIobiksIGMgPSBmLmdldFhFeHRyZW1lcyhlKSwgeCA9IGMubWluLCBsID0gYy5tYXgpO1xuICAgICAgICAgICAgICAgICAgZS5sZW5ndGggJiYgKGEuZGF0YU1pbiA9IE1hdGgubWluKHooYS5kYXRhTWluLCB4KSwgeCksIGEuZGF0YU1heCA9IE1hdGgubWF4KHooYS5kYXRhTWF4LCBsKSwgbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmLmdldEV4dHJlbWVzKCksIGwgPSBmLmRhdGFNYXgsIHggPSBmLmRhdGFNaW4sIHQoeCkgJiYgdChsKSAmJiAoYS5kYXRhTWluID0gTWF0aC5taW4oeihhLmRhdGFNaW4sIHgpLCB4KSwgYS5kYXRhTWF4ID0gTWF0aC5tYXgoeihhLmRhdGFNYXgsIGwpLCBsKSksIHQocCkgJiYgKGEudGhyZXNob2xkID0gcCksICFlLnNvZnRUaHJlc2hvbGQgfHwgYS5wb3NpdGl2ZVZhbHVlc09ubHkpIGEuc29mdFRocmVzaG9sZCA9ICExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcSh0aGlzLCBcImFmdGVyR2V0U2VyaWVzRXh0cmVtZXNcIik7XG4gICAgICB9LFxuICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoYSwgYiwgYywgZiwgZSwgbCkge1xuICAgICAgICB2YXIgcCA9IHRoaXMubGlua2VkUGFyZW50IHx8IHRoaXMsXG4gICAgICAgICAgICB4ID0gMSxcbiAgICAgICAgICAgIG0gPSAwLFxuICAgICAgICAgICAgQyA9IGYgPyBwLm9sZFRyYW5zQSA6IHAudHJhbnNBO1xuICAgICAgICBmID0gZiA/IHAub2xkTWluIDogcC5taW47XG4gICAgICAgIHZhciBrID0gcC5taW5QaXhlbFBhZGRpbmc7XG4gICAgICAgIGUgPSAocC5pc09yZGluYWwgfHwgcC5pc0Jyb2tlbiB8fCBwLmlzTG9nICYmIGUpICYmIHAubGluMnZhbDtcbiAgICAgICAgQyB8fCAoQyA9IHAudHJhbnNBKTtcbiAgICAgICAgYyAmJiAoeCAqPSAtMSwgbSA9IHAubGVuKTtcbiAgICAgICAgcC5yZXZlcnNlZCAmJiAoeCAqPSAtMSwgbSAtPSB4ICogKHAuc2VjdG9yIHx8IHAubGVuKSk7XG4gICAgICAgIGIgPyAoYSA9IChhICogeCArIG0gLSBrKSAvIEMgKyBmLCBlICYmIChhID0gcC5saW4ydmFsKGEpKSkgOiAoZSAmJiAoYSA9IHAudmFsMmxpbihhKSksIGEgPSBuKGYpID8geCAqIChhIC0gZikgKiBDICsgbSArIHggKiBrICsgKG4obCkgPyBDICogbCA6IDApIDogdm9pZCAwKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9LFxuICAgICAgdG9QaXhlbHM6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZShhLCAhMSwgIXRoaXMuaG9yaXosIG51bGwsICEwKSArIChiID8gMCA6IHRoaXMucG9zKTtcbiAgICAgIH0sXG4gICAgICB0b1ZhbHVlOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGUoYSAtIChiID8gMCA6IHRoaXMucG9zKSwgITAsICF0aGlzLmhvcml6LCBudWxsLCAhMCk7XG4gICAgICB9LFxuICAgICAgZ2V0UGxvdExpbmVQYXRoOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgICAgICBjID0gYi5jaGFydCxcbiAgICAgICAgICAgIGYgPSBiLmxlZnQsXG4gICAgICAgICAgICBlID0gYi50b3AsXG4gICAgICAgICAgICBwID0gYS5vbGQsXG4gICAgICAgICAgICBsID0gYS52YWx1ZSxcbiAgICAgICAgICAgIGsgPSBhLnRyYW5zbGF0ZWRWYWx1ZSxcbiAgICAgICAgICAgIG0gPSBhLmxpbmVXaWR0aCxcbiAgICAgICAgICAgIHYgPSBhLmZvcmNlLFxuICAgICAgICAgICAgZCxcbiAgICAgICAgICAgIHcsXG4gICAgICAgICAgICBGLFxuICAgICAgICAgICAgaCxcbiAgICAgICAgICAgIEIgPSBwICYmIGMub2xkQ2hhcnRIZWlnaHQgfHwgYy5jaGFydEhlaWdodCxcbiAgICAgICAgICAgIEwgPSBwICYmIGMub2xkQ2hhcnRXaWR0aCB8fCBjLmNoYXJ0V2lkdGgsXG4gICAgICAgICAgICB0LFxuICAgICAgICAgICAgZyA9IGIudHJhbnNCLFxuICAgICAgICAgICAgSCA9IGZ1bmN0aW9uIChiLCBhLCBjKSB7XG4gICAgICAgICAgaWYgKFwicGFzc1wiICE9PSB2ICYmIGIgPCBhIHx8IGIgPiBjKSB2ID8gYiA9IEooYiwgYSwgYykgOiB0ID0gITA7XG4gICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH07XG5cbiAgICAgICAgYSA9IHtcbiAgICAgICAgICB2YWx1ZTogbCxcbiAgICAgICAgICBsaW5lV2lkdGg6IG0sXG4gICAgICAgICAgb2xkOiBwLFxuICAgICAgICAgIGZvcmNlOiB2LFxuICAgICAgICAgIGFjcm9zc1BhbmVzOiBhLmFjcm9zc1BhbmVzLFxuICAgICAgICAgIHRyYW5zbGF0ZWRWYWx1ZToga1xuICAgICAgICB9O1xuICAgICAgICBxKHRoaXMsIFwiZ2V0UGxvdExpbmVQYXRoXCIsIGEsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgayA9IHooaywgYi50cmFuc2xhdGUobCwgbnVsbCwgbnVsbCwgcCkpO1xuICAgICAgICAgIGsgPSBKKGssIC0xRTUsIDFFNSk7XG4gICAgICAgICAgZCA9IEYgPSBNYXRoLnJvdW5kKGsgKyBnKTtcbiAgICAgICAgICB3ID0gaCA9IE1hdGgucm91bmQoQiAtIGsgLSBnKTtcbiAgICAgICAgICBuKGspID8gYi5ob3JpeiA/ICh3ID0gZSwgaCA9IEIgLSBiLmJvdHRvbSwgZCA9IEYgPSBIKGQsIGYsIGYgKyBiLndpZHRoKSkgOiAoZCA9IGYsIEYgPSBMIC0gYi5yaWdodCwgdyA9IGggPSBIKHcsIGUsIGUgKyBiLmhlaWdodCkpIDogKHQgPSAhMCwgdiA9ICExKTtcbiAgICAgICAgICBhLnBhdGggPSB0ICYmICF2ID8gbnVsbCA6IGMucmVuZGVyZXIuY3Jpc3BMaW5lKFtcIk1cIiwgZCwgdywgXCJMXCIsIEYsIGhdLCBtIHx8IDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGEucGF0aDtcbiAgICAgIH0sXG4gICAgICBnZXRMaW5lYXJUaWNrUG9zaXRpb25zOiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICB2YXIgZiA9IHkoTWF0aC5mbG9vcihiIC8gYSkgKiBhKTtcbiAgICAgICAgYyA9IHkoTWF0aC5jZWlsKGMgLyBhKSAqIGEpO1xuICAgICAgICB2YXIgZSA9IFtdLFxuICAgICAgICAgICAgcDtcbiAgICAgICAgeShmICsgYSkgPT09IGYgJiYgKHAgPSAyMCk7XG4gICAgICAgIGlmICh0aGlzLnNpbmdsZSkgcmV0dXJuIFtiXTtcblxuICAgICAgICBmb3IgKGIgPSBmOyBiIDw9IGM7KSB7XG4gICAgICAgICAgZS5wdXNoKGIpO1xuICAgICAgICAgIGIgPSB5KGIgKyBhLCBwKTtcbiAgICAgICAgICBpZiAoYiA9PT0gbCkgYnJlYWs7XG4gICAgICAgICAgdmFyIGwgPSBiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9LFxuICAgICAgZ2V0TWlub3JUaWNrSW50ZXJ2YWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHJldHVybiAhMCA9PT0gYS5taW5vclRpY2tzID8geihhLm1pbm9yVGlja0ludGVydmFsLCBcImF1dG9cIikgOiAhMSA9PT0gYS5taW5vclRpY2tzID8gbnVsbCA6IGEubWlub3JUaWNrSW50ZXJ2YWw7XG4gICAgICB9LFxuICAgICAgZ2V0TWlub3JUaWNrUG9zaXRpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIGIgPSBhLm9wdGlvbnMsXG4gICAgICAgICAgICBjID0gYS50aWNrUG9zaXRpb25zLFxuICAgICAgICAgICAgZiA9IGEubWlub3JUaWNrSW50ZXJ2YWwsXG4gICAgICAgICAgICBlID0gW10sXG4gICAgICAgICAgICBsID0gYS5wb2ludFJhbmdlUGFkZGluZyB8fCAwLFxuICAgICAgICAgICAgayA9IGEubWluIC0gbDtcbiAgICAgICAgbCA9IGEubWF4ICsgbDtcbiAgICAgICAgdmFyIHYgPSBsIC0gaztcbiAgICAgICAgaWYgKHYgJiYgdiAvIGYgPCBhLmxlbiAvIDMpIGlmIChhLmlzTG9nKSB0aGlzLnBhZGRlZFRpY2tzLmZvckVhY2goZnVuY3Rpb24gKGIsIGMsIHApIHtcbiAgICAgICAgICBjICYmIGUucHVzaC5hcHBseShlLCBhLmdldExvZ1RpY2tQb3NpdGlvbnMoZiwgcFtjIC0gMV0sIHBbY10sICEwKSk7XG4gICAgICAgIH0pO2Vsc2UgaWYgKGEuaXNEYXRldGltZUF4aXMgJiYgXCJhdXRvXCIgPT09IHRoaXMuZ2V0TWlub3JUaWNrSW50ZXJ2YWwoKSkgZSA9IGUuY29uY2F0KGEuZ2V0VGltZVRpY2tzKGEubm9ybWFsaXplVGltZVRpY2tJbnRlcnZhbChmKSwgaywgbCwgYi5zdGFydE9mV2VlaykpO2Vsc2UgZm9yIChiID0gayArIChjWzBdIC0gaykgJSBmOyBiIDw9IGwgJiYgYiAhPT0gZVswXTsgYiArPSBmKSBlLnB1c2goYik7XG4gICAgICAgIDAgIT09IGUubGVuZ3RoICYmIGEudHJpbVRpY2tzKGUpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0sXG4gICAgICBhZGp1c3RGb3JNaW5SYW5nZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGIgPSB0aGlzLm1pbixcbiAgICAgICAgICAgIGMgPSB0aGlzLm1heCxcbiAgICAgICAgICAgIGYsXG4gICAgICAgICAgICBlLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGssXG4gICAgICAgICAgICB2O1xuICAgICAgICB0aGlzLmlzWEF4aXMgJiYgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHRoaXMubWluUmFuZ2UgJiYgIXRoaXMuaXNMb2cgJiYgKHQoYS5taW4pIHx8IHQoYS5tYXgpID8gdGhpcy5taW5SYW5nZSA9IG51bGwgOiAodGhpcy5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGsgPSBiLnhEYXRhO1xuXG4gICAgICAgICAgZm9yIChlID0gdiA9IGIueEluY3JlbWVudCA/IDEgOiBrLmxlbmd0aCAtIDE7IDAgPCBlOyBlLS0pIGlmIChsID0ga1tlXSAtIGtbZSAtIDFdLCBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgZiB8fCBsIDwgZikgZiA9IGw7XG4gICAgICAgIH0pLCB0aGlzLm1pblJhbmdlID0gTWF0aC5taW4oNSAqIGYsIHRoaXMuZGF0YU1heCAtIHRoaXMuZGF0YU1pbikpKTtcblxuICAgICAgICBpZiAoYyAtIGIgPCB0aGlzLm1pblJhbmdlKSB7XG4gICAgICAgICAgdmFyIG0gPSB0aGlzLmRhdGFNYXggLSB0aGlzLmRhdGFNaW4gPj0gdGhpcy5taW5SYW5nZTtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMubWluUmFuZ2U7XG4gICAgICAgICAgdmFyIGQgPSAobiAtIGMgKyBiKSAvIDI7XG4gICAgICAgICAgZCA9IFtiIC0gZCwgeihhLm1pbiwgYiAtIGQpXTtcbiAgICAgICAgICBtICYmIChkWzJdID0gdGhpcy5pc0xvZyA/IHRoaXMubG9nMmxpbih0aGlzLmRhdGFNaW4pIDogdGhpcy5kYXRhTWluKTtcbiAgICAgICAgICBiID0gQShkKTtcbiAgICAgICAgICBjID0gW2IgKyBuLCB6KGEubWF4LCBiICsgbildO1xuICAgICAgICAgIG0gJiYgKGNbMl0gPSB0aGlzLmlzTG9nID8gdGhpcy5sb2cybGluKHRoaXMuZGF0YU1heCkgOiB0aGlzLmRhdGFNYXgpO1xuICAgICAgICAgIGMgPSBHKGMpO1xuICAgICAgICAgIGMgLSBiIDwgbiAmJiAoZFswXSA9IGMgLSBuLCBkWzFdID0geihhLm1pbiwgYyAtIG4pLCBiID0gQShkKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1pbiA9IGI7XG4gICAgICAgIHRoaXMubWF4ID0gYztcbiAgICAgIH0sXG4gICAgICBnZXRDbG9zZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhO1xuICAgICAgICB0aGlzLmNhdGVnb3JpZXMgPyBhID0gMSA6IHRoaXMuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICB2YXIgYyA9IGIuY2xvc2VzdFBvaW50UmFuZ2UsXG4gICAgICAgICAgICAgIGYgPSBiLnZpc2libGUgfHwgIWIuY2hhcnQub3B0aW9ucy5jaGFydC5pZ25vcmVIaWRkZW5TZXJpZXM7XG4gICAgICAgICAgIWIubm9TaGFyZWRUb29sdGlwICYmIHQoYykgJiYgZiAmJiAoYSA9IHQoYSkgPyBNYXRoLm1pbihhLCBjKSA6IGMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9LFxuICAgICAgbmFtZVRvWDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGIgPSBjKHRoaXMuY2F0ZWdvcmllcyksXG4gICAgICAgICAgICBmID0gYiA/IHRoaXMuY2F0ZWdvcmllcyA6IHRoaXMubmFtZXMsXG4gICAgICAgICAgICBlID0gYS5vcHRpb25zLng7XG4gICAgICAgIGEuc2VyaWVzLnJlcXVpcmVTb3J0aW5nID0gITE7XG4gICAgICAgIHQoZSkgfHwgKGUgPSAhMSA9PT0gdGhpcy5vcHRpb25zLnVuaXF1ZU5hbWVzID8gYS5zZXJpZXMuYXV0b0luY3JlbWVudCgpIDogYiA/IGYuaW5kZXhPZihhLm5hbWUpIDogeihmLmtleXNbYS5uYW1lXSwgLTEpKTtcblxuICAgICAgICBpZiAoLTEgPT09IGUpIHtcbiAgICAgICAgICBpZiAoIWIpIHZhciBwID0gZi5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBwID0gZTtcblxuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgcCAmJiAodGhpcy5uYW1lc1twXSA9IGEubmFtZSwgdGhpcy5uYW1lcy5rZXlzW2EubmFtZV0gPSBwKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9LFxuICAgICAgdXBkYXRlTmFtZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgYiA9IHRoaXMubmFtZXM7XG4gICAgICAgIDAgPCBiLmxlbmd0aCAmJiAoT2JqZWN0LmtleXMoYi5rZXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgZGVsZXRlIGIua2V5c1thXTtcbiAgICAgICAgfSksIGIubGVuZ3RoID0gMCwgdGhpcy5taW5SYW5nZSA9IHRoaXMudXNlck1pblJhbmdlLCAodGhpcy5zZXJpZXMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBiLnhJbmNyZW1lbnQgPSBudWxsO1xuICAgICAgICAgIGlmICghYi5wb2ludHMgfHwgYi5pc0RpcnR5RGF0YSkgYS5tYXggPSBNYXRoLm1heChhLm1heCwgYi54RGF0YS5sZW5ndGggLSAxKSwgYi5wcm9jZXNzRGF0YSgpLCBiLmdlbmVyYXRlUG9pbnRzKCk7XG4gICAgICAgICAgYi5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGMsIGYpIHtcbiAgICAgICAgICAgIGlmIChjICYmIGMub3B0aW9ucyAmJiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYy5uYW1lKSB7XG4gICAgICAgICAgICAgIHZhciBlID0gYS5uYW1lVG9YKGMpO1xuICAgICAgICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZSAmJiBlICE9PSBjLnggJiYgKGMueCA9IGUsIGIueERhdGFbZl0gPSBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIHNldEF4aXNUcmFuc2xhdGlvbjogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICAgICAgYyA9IGIubWF4IC0gYi5taW4sXG4gICAgICAgICAgICBlID0gYi5heGlzUG9pbnRSYW5nZSB8fCAwLFxuICAgICAgICAgICAgcCA9IDAsXG4gICAgICAgICAgICBsID0gMCxcbiAgICAgICAgICAgIGsgPSBiLmxpbmtlZFBhcmVudCxcbiAgICAgICAgICAgIHYgPSAhIWIuY2F0ZWdvcmllcyxcbiAgICAgICAgICAgIG0gPSBiLnRyYW5zQSxcbiAgICAgICAgICAgIGQgPSBiLmlzWEF4aXM7XG5cbiAgICAgICAgaWYgKGQgfHwgdiB8fCBlKSB7XG4gICAgICAgICAgdmFyIG4gPSBiLmdldENsb3Nlc3QoKTtcbiAgICAgICAgICBrID8gKHAgPSBrLm1pblBvaW50T2Zmc2V0LCBsID0gay5wb2ludFJhbmdlUGFkZGluZykgOiBiLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHYgPyAxIDogZCA/IHooYS5vcHRpb25zLnBvaW50UmFuZ2UsIG4sIDApIDogYi5heGlzUG9pbnRSYW5nZSB8fCAwLFxuICAgICAgICAgICAgICAgIHggPSBhLm9wdGlvbnMucG9pbnRQbGFjZW1lbnQ7XG4gICAgICAgICAgICBlID0gTWF0aC5tYXgoZSwgYyk7XG4gICAgICAgICAgICBpZiAoIWIuc2luZ2xlIHx8IHYpIGEgPSBhLmlzKFwieHJhbmdlXCIpID8gIWQgOiBkLCBwID0gTWF0aC5tYXgocCwgYSAmJiBmKHgpID8gMCA6IGMgLyAyKSwgbCA9IE1hdGgubWF4KGwsIGEgJiYgXCJvblwiID09PSB4ID8gMCA6IGMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGsgPSBiLm9yZGluYWxTbG9wZSAmJiBuID8gYi5vcmRpbmFsU2xvcGUgLyBuIDogMTtcbiAgICAgICAgICBiLm1pblBvaW50T2Zmc2V0ID0gcCAqPSBrO1xuICAgICAgICAgIGIucG9pbnRSYW5nZVBhZGRpbmcgPSBsICo9IGs7XG4gICAgICAgICAgYi5wb2ludFJhbmdlID0gTWF0aC5taW4oZSwgYi5zaW5nbGUgJiYgdiA/IDEgOiBjKTtcbiAgICAgICAgICBkICYmIChiLmNsb3Nlc3RQb2ludFJhbmdlID0gbik7XG4gICAgICAgIH1cblxuICAgICAgICBhICYmIChiLm9sZFRyYW5zQSA9IG0pO1xuICAgICAgICBiLnRyYW5zbGF0aW9uU2xvcGUgPSBiLnRyYW5zQSA9IG0gPSBiLnN0YXRpY1NjYWxlIHx8IGIubGVuIC8gKGMgKyBsIHx8IDEpO1xuICAgICAgICBiLnRyYW5zQiA9IGIuaG9yaXogPyBiLmxlZnQgOiBiLmJvdHRvbTtcbiAgICAgICAgYi5taW5QaXhlbFBhZGRpbmcgPSBtICogcDtcbiAgICAgICAgcSh0aGlzLCBcImFmdGVyU2V0QXhpc1RyYW5zbGF0aW9uXCIpO1xuICAgICAgfSxcbiAgICAgIG1pbkZyb21SYW5nZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXggLSB0aGlzLnJhbmdlO1xuICAgICAgfSxcbiAgICAgIHNldFRpY2tJbnRlcnZhbDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICAgICAgYyA9IGIuY2hhcnQsXG4gICAgICAgICAgICBmID0gYi5vcHRpb25zLFxuICAgICAgICAgICAgcCA9IGIuaXNMb2csXG4gICAgICAgICAgICBrID0gYi5pc0RhdGV0aW1lQXhpcyxcbiAgICAgICAgICAgIHYgPSBiLmlzWEF4aXMsXG4gICAgICAgICAgICBkID0gYi5pc0xpbmtlZCxcbiAgICAgICAgICAgIG0gPSBmLm1heFBhZGRpbmcsXG4gICAgICAgICAgICB3ID0gZi5taW5QYWRkaW5nLFxuICAgICAgICAgICAgQiA9IGYudGlja0ludGVydmFsLFxuICAgICAgICAgICAgTCA9IGYudGlja1BpeGVsSW50ZXJ2YWwsXG4gICAgICAgICAgICBGID0gYi5jYXRlZ29yaWVzLFxuICAgICAgICAgICAgViA9IG4oYi50aHJlc2hvbGQpID8gYi50aHJlc2hvbGQgOiBudWxsLFxuICAgICAgICAgICAgZyA9IGIuc29mdFRocmVzaG9sZDtcbiAgICAgICAgayB8fCBGIHx8IGQgfHwgdGhpcy5nZXRUaWNrQW1vdW50KCk7XG4gICAgICAgIHZhciBIID0geihiLnVzZXJNaW4sIGYubWluKTtcbiAgICAgICAgdmFyIEsgPSB6KGIudXNlck1heCwgZi5tYXgpO1xuXG4gICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgYi5saW5rZWRQYXJlbnQgPSBjW2IuY29sbF1bZi5saW5rZWRUb107XG4gICAgICAgICAgdmFyIFEgPSBiLmxpbmtlZFBhcmVudC5nZXRFeHRyZW1lcygpO1xuICAgICAgICAgIGIubWluID0geihRLm1pbiwgUS5kYXRhTWluKTtcbiAgICAgICAgICBiLm1heCA9IHooUS5tYXgsIFEuZGF0YU1heCk7XG4gICAgICAgICAgZi50eXBlICE9PSBiLmxpbmtlZFBhcmVudC5vcHRpb25zLnR5cGUgJiYgaCgxMSwgMSwgYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFnICYmIHQoVikpIGlmIChiLmRhdGFNaW4gPj0gVikgUSA9IFYsIHcgPSAwO2Vsc2UgaWYgKGIuZGF0YU1heCA8PSBWKSB7XG4gICAgICAgICAgICB2YXIgdSA9IFY7XG4gICAgICAgICAgICBtID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYi5taW4gPSB6KEgsIFEsIGIuZGF0YU1pbik7XG4gICAgICAgICAgYi5tYXggPSB6KEssIHUsIGIuZGF0YU1heCk7XG4gICAgICAgIH1cblxuICAgICAgICBwICYmIChiLnBvc2l0aXZlVmFsdWVzT25seSAmJiAhYSAmJiAwID49IE1hdGgubWluKGIubWluLCB6KGIuZGF0YU1pbiwgYi5taW4pKSAmJiBoKDEwLCAxLCBjKSwgYi5taW4gPSB5KGIubG9nMmxpbihiLm1pbiksIDE2KSwgYi5tYXggPSB5KGIubG9nMmxpbihiLm1heCksIDE2KSk7XG4gICAgICAgIGIucmFuZ2UgJiYgdChiLm1heCkgJiYgKGIudXNlck1pbiA9IGIubWluID0gSCA9IE1hdGgubWF4KGIuZGF0YU1pbiwgYi5taW5Gcm9tUmFuZ2UoKSksIGIudXNlck1heCA9IEsgPSBiLm1heCwgYi5yYW5nZSA9IG51bGwpO1xuICAgICAgICBxKGIsIFwiZm91bmRFeHRyZW1lc1wiKTtcbiAgICAgICAgYi5iZWZvcmVQYWRkaW5nICYmIGIuYmVmb3JlUGFkZGluZygpO1xuICAgICAgICBiLmFkanVzdEZvck1pblJhbmdlKCk7XG4gICAgICAgICEoRiB8fCBiLmF4aXNQb2ludFJhbmdlIHx8IGIudXNlUGVyY2VudGFnZSB8fCBkKSAmJiB0KGIubWluKSAmJiB0KGIubWF4KSAmJiAoYyA9IGIubWF4IC0gYi5taW4pICYmICghdChIKSAmJiB3ICYmIChiLm1pbiAtPSBjICogdyksICF0KEspICYmIG0gJiYgKGIubWF4ICs9IGMgKiBtKSk7XG4gICAgICAgIG4oYi51c2VyTWluKSB8fCAobihmLnNvZnRNaW4pICYmIGYuc29mdE1pbiA8IGIubWluICYmIChiLm1pbiA9IEggPSBmLnNvZnRNaW4pLCBuKGYuZmxvb3IpICYmIChiLm1pbiA9IE1hdGgubWF4KGIubWluLCBmLmZsb29yKSkpO1xuICAgICAgICBuKGIudXNlck1heCkgfHwgKG4oZi5zb2Z0TWF4KSAmJiBmLnNvZnRNYXggPiBiLm1heCAmJiAoYi5tYXggPSBLID0gZi5zb2Z0TWF4KSwgbihmLmNlaWxpbmcpICYmIChiLm1heCA9IE1hdGgubWluKGIubWF4LCBmLmNlaWxpbmcpKSk7XG4gICAgICAgIGcgJiYgdChiLmRhdGFNaW4pICYmIChWID0gViB8fCAwLCAhdChIKSAmJiBiLm1pbiA8IFYgJiYgYi5kYXRhTWluID49IFYgPyBiLm1pbiA9IGIub3B0aW9ucy5taW5SYW5nZSA/IE1hdGgubWluKFYsIGIubWF4IC0gYi5taW5SYW5nZSkgOiBWIDogIXQoSykgJiYgYi5tYXggPiBWICYmIGIuZGF0YU1heCA8PSBWICYmIChiLm1heCA9IGIub3B0aW9ucy5taW5SYW5nZSA/IE1hdGgubWF4KFYsIGIubWluICsgYi5taW5SYW5nZSkgOiBWKSk7XG4gICAgICAgIGIudGlja0ludGVydmFsID0gYi5taW4gPT09IGIubWF4IHx8IFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBiLm1pbiB8fCBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgYi5tYXggPyAxIDogZCAmJiAhQiAmJiBMID09PSBiLmxpbmtlZFBhcmVudC5vcHRpb25zLnRpY2tQaXhlbEludGVydmFsID8gQiA9IGIubGlua2VkUGFyZW50LnRpY2tJbnRlcnZhbCA6IHooQiwgdGhpcy50aWNrQW1vdW50ID8gKGIubWF4IC0gYi5taW4pIC8gTWF0aC5tYXgodGhpcy50aWNrQW1vdW50IC0gMSwgMSkgOiB2b2lkIDAsIEYgPyAxIDogKGIubWF4IC0gYi5taW4pICogTCAvIE1hdGgubWF4KGIubGVuLCBMKSk7XG4gICAgICAgIHYgJiYgIWEgJiYgYi5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEucHJvY2Vzc0RhdGEoYi5taW4gIT09IGIub2xkTWluIHx8IGIubWF4ICE9PSBiLm9sZE1heCk7XG4gICAgICAgIH0pO1xuICAgICAgICBiLnNldEF4aXNUcmFuc2xhdGlvbighMCk7XG4gICAgICAgIGIuYmVmb3JlU2V0VGlja1Bvc2l0aW9ucyAmJiBiLmJlZm9yZVNldFRpY2tQb3NpdGlvbnMoKTtcbiAgICAgICAgYi5wb3N0UHJvY2Vzc1RpY2tJbnRlcnZhbCAmJiAoYi50aWNrSW50ZXJ2YWwgPSBiLnBvc3RQcm9jZXNzVGlja0ludGVydmFsKGIudGlja0ludGVydmFsKSk7XG4gICAgICAgIGIucG9pbnRSYW5nZSAmJiAhQiAmJiAoYi50aWNrSW50ZXJ2YWwgPSBNYXRoLm1heChiLnBvaW50UmFuZ2UsIGIudGlja0ludGVydmFsKSk7XG4gICAgICAgIGEgPSB6KGYubWluVGlja0ludGVydmFsLCBiLmlzRGF0ZXRpbWVBeGlzICYmIGIuY2xvc2VzdFBvaW50UmFuZ2UpO1xuICAgICAgICAhQiAmJiBiLnRpY2tJbnRlcnZhbCA8IGEgJiYgKGIudGlja0ludGVydmFsID0gYSk7XG4gICAgICAgIGsgfHwgcCB8fCBCIHx8IChiLnRpY2tJbnRlcnZhbCA9IGwoYi50aWNrSW50ZXJ2YWwsIG51bGwsIGUoYi50aWNrSW50ZXJ2YWwpLCB6KGYuYWxsb3dEZWNpbWFscywgISguNSA8IGIudGlja0ludGVydmFsICYmIDUgPiBiLnRpY2tJbnRlcnZhbCAmJiAxRTMgPCBiLm1heCAmJiA5OTk5ID4gYi5tYXgpKSwgISF0aGlzLnRpY2tBbW91bnQpKTtcbiAgICAgICAgdGhpcy50aWNrQW1vdW50IHx8IChiLnRpY2tJbnRlcnZhbCA9IGIudW5zcXVpc2goKSk7XG4gICAgICAgIHRoaXMuc2V0VGlja1Bvc2l0aW9ucygpO1xuICAgICAgfSxcbiAgICAgIHNldFRpY2tQb3NpdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBiID0gYS50aWNrUG9zaXRpb25zO1xuICAgICAgICB2YXIgYyA9IHRoaXMuZ2V0TWlub3JUaWNrSW50ZXJ2YWwoKTtcbiAgICAgICAgdmFyIGYgPSBhLnRpY2tQb3NpdGlvbmVyLFxuICAgICAgICAgICAgZSA9IGEuc3RhcnRPblRpY2ssXG4gICAgICAgICAgICBsID0gYS5lbmRPblRpY2s7XG4gICAgICAgIHRoaXMudGlja21hcmtPZmZzZXQgPSB0aGlzLmNhdGVnb3JpZXMgJiYgXCJiZXR3ZWVuXCIgPT09IGEudGlja21hcmtQbGFjZW1lbnQgJiYgMSA9PT0gdGhpcy50aWNrSW50ZXJ2YWwgPyAuNSA6IDA7XG4gICAgICAgIHRoaXMubWlub3JUaWNrSW50ZXJ2YWwgPSBcImF1dG9cIiA9PT0gYyAmJiB0aGlzLnRpY2tJbnRlcnZhbCA/IHRoaXMudGlja0ludGVydmFsIC8gNSA6IGM7XG4gICAgICAgIHRoaXMuc2luZ2xlID0gdGhpcy5taW4gPT09IHRoaXMubWF4ICYmIHQodGhpcy5taW4pICYmICF0aGlzLnRpY2tBbW91bnQgJiYgKHBhcnNlSW50KHRoaXMubWluLCAxMCkgPT09IHRoaXMubWluIHx8ICExICE9PSBhLmFsbG93RGVjaW1hbHMpO1xuICAgICAgICB0aGlzLnRpY2tQb3NpdGlvbnMgPSBjID0gYiAmJiBiLnNsaWNlKCk7XG4gICAgICAgICFjICYmICghdGhpcy5vcmRpbmFsUG9zaXRpb25zICYmICh0aGlzLm1heCAtIHRoaXMubWluKSAvIHRoaXMudGlja0ludGVydmFsID4gTWF0aC5tYXgoMiAqIHRoaXMubGVuLCAyMDApID8gKGMgPSBbdGhpcy5taW4sIHRoaXMubWF4XSwgaCgxOSwgITEsIHRoaXMuY2hhcnQpKSA6IGMgPSB0aGlzLmlzRGF0ZXRpbWVBeGlzID8gdGhpcy5nZXRUaW1lVGlja3ModGhpcy5ub3JtYWxpemVUaW1lVGlja0ludGVydmFsKHRoaXMudGlja0ludGVydmFsLCBhLnVuaXRzKSwgdGhpcy5taW4sIHRoaXMubWF4LCBhLnN0YXJ0T2ZXZWVrLCB0aGlzLm9yZGluYWxQb3NpdGlvbnMsIHRoaXMuY2xvc2VzdFBvaW50UmFuZ2UsICEwKSA6IHRoaXMuaXNMb2cgPyB0aGlzLmdldExvZ1RpY2tQb3NpdGlvbnModGhpcy50aWNrSW50ZXJ2YWwsIHRoaXMubWluLCB0aGlzLm1heCkgOiB0aGlzLmdldExpbmVhclRpY2tQb3NpdGlvbnModGhpcy50aWNrSW50ZXJ2YWwsIHRoaXMubWluLCB0aGlzLm1heCksIGMubGVuZ3RoID4gdGhpcy5sZW4gJiYgKGMgPSBbY1swXSwgYy5wb3AoKV0sIGNbMF0gPT09IGNbMV0gJiYgKGMubGVuZ3RoID0gMSkpLCB0aGlzLnRpY2tQb3NpdGlvbnMgPSBjLCBmICYmIChmID0gZi5hcHBseSh0aGlzLCBbdGhpcy5taW4sIHRoaXMubWF4XSkpKSAmJiAodGhpcy50aWNrUG9zaXRpb25zID0gYyA9IGYpO1xuICAgICAgICB0aGlzLnBhZGRlZFRpY2tzID0gYy5zbGljZSgwKTtcbiAgICAgICAgdGhpcy50cmltVGlja3MoYywgZSwgbCk7XG4gICAgICAgIHRoaXMuaXNMaW5rZWQgfHwgKHRoaXMuc2luZ2xlICYmIDIgPiBjLmxlbmd0aCAmJiAhdGhpcy5jYXRlZ29yaWVzICYmICF0aGlzLnNlcmllcy5zb21lKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgcmV0dXJuIGIuaXMoXCJoZWF0bWFwXCIpICYmIFwiYmV0d2VlblwiID09PSBiLm9wdGlvbnMucG9pbnRQbGFjZW1lbnQ7XG4gICAgICAgIH0pICYmICh0aGlzLm1pbiAtPSAuNSwgdGhpcy5tYXggKz0gLjUpLCBiIHx8IGYgfHwgdGhpcy5hZGp1c3RUaWNrQW1vdW50KCkpO1xuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJTZXRUaWNrUG9zaXRpb25zXCIpO1xuICAgICAgfSxcbiAgICAgIHRyaW1UaWNrczogZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgdmFyIGYgPSBhWzBdLFxuICAgICAgICAgICAgZSA9IGFbYS5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHAgPSAhdGhpcy5pc09yZGluYWwgJiYgdGhpcy5taW5Qb2ludE9mZnNldCB8fCAwO1xuICAgICAgICBxKHRoaXMsIFwidHJpbVRpY2tzXCIpO1xuXG4gICAgICAgIGlmICghdGhpcy5pc0xpbmtlZCkge1xuICAgICAgICAgIGlmIChiICYmIC1JbmZpbml0eSAhPT0gZikgdGhpcy5taW4gPSBmO2Vsc2UgZm9yICg7IHRoaXMubWluIC0gcCA+IGFbMF07KSBhLnNoaWZ0KCk7XG4gICAgICAgICAgaWYgKGMpIHRoaXMubWF4ID0gZTtlbHNlIGZvciAoOyB0aGlzLm1heCArIHAgPCBhW2EubGVuZ3RoIC0gMV07KSBhLnBvcCgpO1xuICAgICAgICAgIDAgPT09IGEubGVuZ3RoICYmIHQoZikgJiYgIXRoaXMub3B0aW9ucy50aWNrUG9zaXRpb25zICYmIGEucHVzaCgoZSArIGYpIC8gMik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhbGlnblRvT3RoZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0ge30sXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgITEgPT09IHRoaXMuY2hhcnQub3B0aW9ucy5jaGFydC5hbGlnblRpY2tzIHx8ICExID09PSBjLmFsaWduVGlja3MgfHwgITEgPT09IGMuc3RhcnRPblRpY2sgfHwgITEgPT09IGMuZW5kT25UaWNrIHx8IHRoaXMuaXNMb2cgfHwgdGhpcy5jaGFydFt0aGlzLmNvbGxdLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICB2YXIgZiA9IGMub3B0aW9ucztcbiAgICAgICAgICBmID0gW2MuaG9yaXogPyBmLmxlZnQgOiBmLnRvcCwgZi53aWR0aCwgZi5oZWlnaHQsIGYucGFuZV0uam9pbigpO1xuICAgICAgICAgIGMuc2VyaWVzLmxlbmd0aCAmJiAoYVtmXSA/IGIgPSAhMCA6IGFbZl0gPSAxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSxcbiAgICAgIGdldFRpY2tBbW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBiID0gYS50aWNrQW1vdW50LFxuICAgICAgICAgICAgYyA9IGEudGlja1BpeGVsSW50ZXJ2YWw7XG4gICAgICAgICF0KGEudGlja0ludGVydmFsKSAmJiB0aGlzLmxlbiA8IGMgJiYgIXRoaXMuaXNSYWRpYWwgJiYgIXRoaXMuaXNMb2cgJiYgYS5zdGFydE9uVGljayAmJiBhLmVuZE9uVGljayAmJiAoYiA9IDIpO1xuICAgICAgICAhYiAmJiB0aGlzLmFsaWduVG9PdGhlcnMoKSAmJiAoYiA9IE1hdGguY2VpbCh0aGlzLmxlbiAvIGMpICsgMSk7XG4gICAgICAgIDQgPiBiICYmICh0aGlzLmZpbmFsVGlja0FtdCA9IGIsIGIgPSA1KTtcbiAgICAgICAgdGhpcy50aWNrQW1vdW50ID0gYjtcbiAgICAgIH0sXG4gICAgICBhZGp1c3RUaWNrQW1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgYiA9IHRoaXMudGlja0ludGVydmFsLFxuICAgICAgICAgICAgYyA9IHRoaXMudGlja1Bvc2l0aW9ucyxcbiAgICAgICAgICAgIGYgPSB0aGlzLnRpY2tBbW91bnQsXG4gICAgICAgICAgICBlID0gdGhpcy5maW5hbFRpY2tBbXQsXG4gICAgICAgICAgICBsID0gYyAmJiBjLmxlbmd0aCxcbiAgICAgICAgICAgIGsgPSB6KHRoaXMudGhyZXNob2xkLCB0aGlzLnNvZnRUaHJlc2hvbGQgPyAwIDogbnVsbCksXG4gICAgICAgICAgICB2O1xuXG4gICAgICAgIGlmICh0aGlzLmhhc0RhdGEoKSkge1xuICAgICAgICAgIGlmIChsIDwgZikge1xuICAgICAgICAgICAgZm9yICh2ID0gdGhpcy5taW47IGMubGVuZ3RoIDwgZjspIGMubGVuZ3RoICUgMiB8fCB2ID09PSBrID8gYy5wdXNoKHkoY1tjLmxlbmd0aCAtIDFdICsgYikpIDogYy51bnNoaWZ0KHkoY1swXSAtIGIpKTtcblxuICAgICAgICAgICAgdGhpcy50cmFuc0EgKj0gKGwgLSAxKSAvIChmIC0gMSk7XG4gICAgICAgICAgICB0aGlzLm1pbiA9IGEuc3RhcnRPblRpY2sgPyBjWzBdIDogTWF0aC5taW4odGhpcy5taW4sIGNbMF0pO1xuICAgICAgICAgICAgdGhpcy5tYXggPSBhLmVuZE9uVGljayA/IGNbYy5sZW5ndGggLSAxXSA6IE1hdGgubWF4KHRoaXMubWF4LCBjW2MubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgIH0gZWxzZSBsID4gZiAmJiAodGhpcy50aWNrSW50ZXJ2YWwgKj0gMiwgdGhpcy5zZXRUaWNrUG9zaXRpb25zKCkpO1xuXG4gICAgICAgICAgaWYgKHQoZSkpIHtcbiAgICAgICAgICAgIGZvciAoYiA9IGEgPSBjLmxlbmd0aDsgYi0tOykgKDMgPT09IGUgJiYgMSA9PT0gYiAlIDIgfHwgMiA+PSBlICYmIDAgPCBiICYmIGIgPCBhIC0gMSkgJiYgYy5zcGxpY2UoYiwgMSk7XG5cbiAgICAgICAgICAgIHRoaXMuZmluYWxUaWNrQW10ID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldFNjYWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5zZXJpZXMuc29tZShmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHJldHVybiBiLmlzRGlydHlEYXRhIHx8IGIuaXNEaXJ0eSB8fCBiLnhBeGlzICYmIGIueEF4aXMuaXNEaXJ0eTtcbiAgICAgICAgfSksXG4gICAgICAgICAgICBiO1xuICAgICAgICB0aGlzLm9sZE1pbiA9IHRoaXMubWluO1xuICAgICAgICB0aGlzLm9sZE1heCA9IHRoaXMubWF4O1xuICAgICAgICB0aGlzLm9sZEF4aXNMZW5ndGggPSB0aGlzLmxlbjtcbiAgICAgICAgdGhpcy5zZXRBeGlzU2l6ZSgpO1xuICAgICAgICAoYiA9IHRoaXMubGVuICE9PSB0aGlzLm9sZEF4aXNMZW5ndGgpIHx8IGEgfHwgdGhpcy5pc0xpbmtlZCB8fCB0aGlzLmZvcmNlUmVkcmF3IHx8IHRoaXMudXNlck1pbiAhPT0gdGhpcy5vbGRVc2VyTWluIHx8IHRoaXMudXNlck1heCAhPT0gdGhpcy5vbGRVc2VyTWF4IHx8IHRoaXMuYWxpZ25Ub090aGVycygpID8gKHRoaXMucmVzZXRTdGFja3MgJiYgdGhpcy5yZXNldFN0YWNrcygpLCB0aGlzLmZvcmNlUmVkcmF3ID0gITEsIHRoaXMuZ2V0U2VyaWVzRXh0cmVtZXMoKSwgdGhpcy5zZXRUaWNrSW50ZXJ2YWwoKSwgdGhpcy5vbGRVc2VyTWluID0gdGhpcy51c2VyTWluLCB0aGlzLm9sZFVzZXJNYXggPSB0aGlzLnVzZXJNYXgsIHRoaXMuaXNEaXJ0eSB8fCAodGhpcy5pc0RpcnR5ID0gYiB8fCB0aGlzLm1pbiAhPT0gdGhpcy5vbGRNaW4gfHwgdGhpcy5tYXggIT09IHRoaXMub2xkTWF4KSkgOiB0aGlzLmNsZWFuU3RhY2tzICYmIHRoaXMuY2xlYW5TdGFja3MoKTtcbiAgICAgICAgcSh0aGlzLCBcImFmdGVyU2V0U2NhbGVcIik7XG4gICAgICB9LFxuICAgICAgc2V0RXh0cmVtZXM6IGZ1bmN0aW9uIChhLCBiLCBjLCBmLCBlKSB7XG4gICAgICAgIHZhciBwID0gdGhpcyxcbiAgICAgICAgICAgIGwgPSBwLmNoYXJ0O1xuICAgICAgICBjID0geihjLCAhMCk7XG4gICAgICAgIHAuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBkZWxldGUgYi5rZFRyZWU7XG4gICAgICAgIH0pO1xuICAgICAgICBlID0gTihlLCB7XG4gICAgICAgICAgbWluOiBhLFxuICAgICAgICAgIG1heDogYlxuICAgICAgICB9KTtcbiAgICAgICAgcShwLCBcInNldEV4dHJlbWVzXCIsIGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwLnVzZXJNaW4gPSBhO1xuICAgICAgICAgIHAudXNlck1heCA9IGI7XG4gICAgICAgICAgcC5ldmVudEFyZ3MgPSBlO1xuICAgICAgICAgIGMgJiYgbC5yZWRyYXcoZik7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHpvb206IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5kYXRhTWluLFxuICAgICAgICAgICAgZiA9IHRoaXMuZGF0YU1heCxcbiAgICAgICAgICAgIGUgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBwID0gTWF0aC5taW4oYywgeihlLm1pbiwgYykpLFxuICAgICAgICAgICAgbCA9IE1hdGgubWF4KGYsIHooZS5tYXgsIGYpKTtcbiAgICAgICAgYSA9IHtcbiAgICAgICAgICBuZXdNaW46IGEsXG4gICAgICAgICAgbmV3TWF4OiBiXG4gICAgICAgIH07XG4gICAgICAgIHEodGhpcywgXCJ6b29tXCIsIGEsIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgdmFyIGEgPSBiLm5ld01pbixcbiAgICAgICAgICAgICAgZSA9IGIubmV3TWF4O1xuICAgICAgICAgIGlmIChhICE9PSB0aGlzLm1pbiB8fCBlICE9PSB0aGlzLm1heCkgdGhpcy5hbGxvd1pvb21PdXRzaWRlIHx8ICh0KGMpICYmIChhIDwgcCAmJiAoYSA9IHApLCBhID4gbCAmJiAoYSA9IGwpKSwgdChmKSAmJiAoZSA8IHAgJiYgKGUgPSBwKSwgZSA+IGwgJiYgKGUgPSBsKSkpLCB0aGlzLmRpc3BsYXlCdG4gPSBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYSB8fCBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZSwgdGhpcy5zZXRFeHRyZW1lcyhhLCBlLCAhMSwgdm9pZCAwLCB7XG4gICAgICAgICAgICB0cmlnZ2VyOiBcInpvb21cIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGIuem9vbWVkID0gITA7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYS56b29tZWQ7XG4gICAgICB9LFxuICAgICAgc2V0QXhpc1NpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgYiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGMgPSBiLm9mZnNldHMgfHwgWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgZiA9IHRoaXMuaG9yaXosXG4gICAgICAgICAgICBlID0gdGhpcy53aWR0aCA9IE1hdGgucm91bmQodyh6KGIud2lkdGgsIGEucGxvdFdpZHRoIC0gY1szXSArIGNbMV0pLCBhLnBsb3RXaWR0aCkpLFxuICAgICAgICAgICAgbCA9IHRoaXMuaGVpZ2h0ID0gTWF0aC5yb3VuZCh3KHooYi5oZWlnaHQsIGEucGxvdEhlaWdodCAtIGNbMF0gKyBjWzJdKSwgYS5wbG90SGVpZ2h0KSksXG4gICAgICAgICAgICBrID0gdGhpcy50b3AgPSBNYXRoLnJvdW5kKHcoeihiLnRvcCwgYS5wbG90VG9wICsgY1swXSksIGEucGxvdEhlaWdodCwgYS5wbG90VG9wKSk7XG4gICAgICAgIGIgPSB0aGlzLmxlZnQgPSBNYXRoLnJvdW5kKHcoeihiLmxlZnQsIGEucGxvdExlZnQgKyBjWzNdKSwgYS5wbG90V2lkdGgsIGEucGxvdExlZnQpKTtcbiAgICAgICAgdGhpcy5ib3R0b20gPSBhLmNoYXJ0SGVpZ2h0IC0gbCAtIGs7XG4gICAgICAgIHRoaXMucmlnaHQgPSBhLmNoYXJ0V2lkdGggLSBlIC0gYjtcbiAgICAgICAgdGhpcy5sZW4gPSBNYXRoLm1heChmID8gZSA6IGwsIDApO1xuICAgICAgICB0aGlzLnBvcyA9IGYgPyBiIDogaztcbiAgICAgIH0sXG4gICAgICBnZXRFeHRyZW1lczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuaXNMb2c7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWluOiBhID8geSh0aGlzLmxpbjJsb2codGhpcy5taW4pKSA6IHRoaXMubWluLFxuICAgICAgICAgIG1heDogYSA/IHkodGhpcy5saW4ybG9nKHRoaXMubWF4KSkgOiB0aGlzLm1heCxcbiAgICAgICAgICBkYXRhTWluOiB0aGlzLmRhdGFNaW4sXG4gICAgICAgICAgZGF0YU1heDogdGhpcy5kYXRhTWF4LFxuICAgICAgICAgIHVzZXJNaW46IHRoaXMudXNlck1pbixcbiAgICAgICAgICB1c2VyTWF4OiB0aGlzLnVzZXJNYXhcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBnZXRUaHJlc2hvbGQ6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5pc0xvZyxcbiAgICAgICAgICAgIGMgPSBiID8gdGhpcy5saW4ybG9nKHRoaXMubWluKSA6IHRoaXMubWluO1xuICAgICAgICBiID0gYiA/IHRoaXMubGluMmxvZyh0aGlzLm1heCkgOiB0aGlzLm1heDtcbiAgICAgICAgbnVsbCA9PT0gYSB8fCAtSW5maW5pdHkgPT09IGEgPyBhID0gYyA6IEluZmluaXR5ID09PSBhID8gYSA9IGIgOiBjID4gYSA/IGEgPSBjIDogYiA8IGEgJiYgKGEgPSBiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlKGEsIDAsIDEsIDAsIDEpO1xuICAgICAgfSxcbiAgICAgIGF1dG9MYWJlbEFsaWduOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYiA9ICh6KGEsIDApIC0gOTAgKiB0aGlzLnNpZGUgKyA3MjApICUgMzYwO1xuICAgICAgICBhID0ge1xuICAgICAgICAgIGFsaWduOiBcImNlbnRlclwiXG4gICAgICAgIH07XG4gICAgICAgIHEodGhpcywgXCJhdXRvTGFiZWxBbGlnblwiLCBhLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIDE1IDwgYiAmJiAxNjUgPiBiID8gYS5hbGlnbiA9IFwicmlnaHRcIiA6IDE5NSA8IGIgJiYgMzQ1ID4gYiAmJiAoYS5hbGlnbiA9IFwibGVmdFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhLmFsaWduO1xuICAgICAgfSxcbiAgICAgIHRpY2tTaXplOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGMgPSBiW2EgKyBcIkxlbmd0aFwiXSxcbiAgICAgICAgICAgIGYgPSB6KGJbYSArIFwiV2lkdGhcIl0sIFwidGlja1wiID09PSBhICYmIHRoaXMuaXNYQXhpcyAmJiAhdGhpcy5jYXRlZ29yaWVzID8gMSA6IDApO1xuXG4gICAgICAgIGlmIChmICYmIGMpIHtcbiAgICAgICAgICBcImluc2lkZVwiID09PSBiW2EgKyBcIlBvc2l0aW9uXCJdICYmIChjID0gLWMpO1xuICAgICAgICAgIHZhciBlID0gW2MsIGZdO1xuICAgICAgICB9XG5cbiAgICAgICAgYSA9IHtcbiAgICAgICAgICB0aWNrU2l6ZTogZVxuICAgICAgICB9O1xuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJUaWNrU2l6ZVwiLCBhKTtcbiAgICAgICAgcmV0dXJuIGEudGlja1NpemU7XG4gICAgICB9LFxuICAgICAgbGFiZWxNZXRyaWNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy50aWNrUG9zaXRpb25zICYmIHRoaXMudGlja1Bvc2l0aW9uc1swXSB8fCAwO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFydC5yZW5kZXJlci5mb250TWV0cmljcyh0aGlzLm9wdGlvbnMubGFiZWxzLnN0eWxlICYmIHRoaXMub3B0aW9ucy5sYWJlbHMuc3R5bGUuZm9udFNpemUsIHRoaXMudGlja3NbYV0gJiYgdGhpcy50aWNrc1thXS5sYWJlbCk7XG4gICAgICB9LFxuICAgICAgdW5zcXVpc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9wdGlvbnMubGFiZWxzLFxuICAgICAgICAgICAgYiA9IHRoaXMuaG9yaXosXG4gICAgICAgICAgICBjID0gdGhpcy50aWNrSW50ZXJ2YWwsXG4gICAgICAgICAgICBmID0gYyxcbiAgICAgICAgICAgIGUgPSB0aGlzLmxlbiAvICgoKHRoaXMuY2F0ZWdvcmllcyA/IDEgOiAwKSArIHRoaXMubWF4IC0gdGhpcy5taW4pIC8gYyksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgayA9IGEucm90YXRpb24sXG4gICAgICAgICAgICB2ID0gdGhpcy5sYWJlbE1ldHJpY3MoKSxcbiAgICAgICAgICAgIG0sXG4gICAgICAgICAgICBkID0gTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIG4sXG4gICAgICAgICAgICB3ID0gdGhpcy5tYXggLSB0aGlzLm1pbixcbiAgICAgICAgICAgIEYgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHZhciBhID0gYiAvIChlIHx8IDEpO1xuICAgICAgICAgIGEgPSAxIDwgYSA/IE1hdGguY2VpbChhKSA6IDE7XG4gICAgICAgICAgYSAqIGMgPiB3ICYmIEluZmluaXR5ICE9PSBiICYmIEluZmluaXR5ICE9PSBlICYmIHcgJiYgKGEgPSBNYXRoLmNlaWwodyAvIGMpKTtcbiAgICAgICAgICByZXR1cm4geShhICogYyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYiA/IChuID0gIWEuc3RhZ2dlckxpbmVzICYmICFhLnN0ZXAgJiYgKHQoaykgPyBba10gOiBlIDwgeihhLmF1dG9Sb3RhdGlvbkxpbWl0LCA4MCkgJiYgYS5hdXRvUm90YXRpb24pKSAmJiBuLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBpZiAoYiA9PT0gayB8fCBiICYmIC05MCA8PSBiICYmIDkwID49IGIpIHtcbiAgICAgICAgICAgIG0gPSBGKE1hdGguYWJzKHYuaCAvIE1hdGguc2luKEsgKiBiKSkpO1xuICAgICAgICAgICAgdmFyIGEgPSBtICsgTWF0aC5hYnMoYiAvIDM2MCk7XG4gICAgICAgICAgICBhIDwgZCAmJiAoZCA9IGEsIGwgPSBiLCBmID0gbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSA6IGEuc3RlcCB8fCAoZiA9IEYodi5oKSk7XG4gICAgICAgIHRoaXMuYXV0b1JvdGF0aW9uID0gbjtcbiAgICAgICAgdGhpcy5sYWJlbFJvdGF0aW9uID0geihsLCBrKTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9LFxuICAgICAgZ2V0U2xvdFdpZHRoOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYiA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBjID0gdGhpcy5ob3JpeixcbiAgICAgICAgICAgIGYgPSB0aGlzLm9wdGlvbnMubGFiZWxzLFxuICAgICAgICAgICAgZSA9IE1hdGgubWF4KHRoaXMudGlja1Bvc2l0aW9ucy5sZW5ndGggLSAodGhpcy5jYXRlZ29yaWVzID8gMCA6IDEpLCAxKSxcbiAgICAgICAgICAgIGwgPSBiLm1hcmdpblszXTtcbiAgICAgICAgcmV0dXJuIGEgJiYgYS5zbG90V2lkdGggfHwgYyAmJiAyID4gKGYuc3RlcCB8fCAwKSAmJiAhZi5yb3RhdGlvbiAmJiAodGhpcy5zdGFnZ2VyTGluZXMgfHwgMSkgKiB0aGlzLmxlbiAvIGUgfHwgIWMgJiYgKGYuc3R5bGUgJiYgcGFyc2VJbnQoZi5zdHlsZS53aWR0aCwgMTApIHx8IGwgJiYgbCAtIGIuc3BhY2luZ1szXSB8fCAuMzMgKiBiLmNoYXJ0V2lkdGgpO1xuICAgICAgfSxcbiAgICAgIHJlbmRlclVuc3F1aXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGIgPSBhLnJlbmRlcmVyLFxuICAgICAgICAgICAgYyA9IHRoaXMudGlja1Bvc2l0aW9ucyxcbiAgICAgICAgICAgIGUgPSB0aGlzLnRpY2tzLFxuICAgICAgICAgICAgbCA9IHRoaXMub3B0aW9ucy5sYWJlbHMsXG4gICAgICAgICAgICBrID0gbCAmJiBsLnN0eWxlIHx8IHt9LFxuICAgICAgICAgICAgdiA9IHRoaXMuaG9yaXosXG4gICAgICAgICAgICBkID0gdGhpcy5nZXRTbG90V2lkdGgoKSxcbiAgICAgICAgICAgIG0gPSBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKGQgLSAyICogKGwucGFkZGluZyB8fCA1KSkpLFxuICAgICAgICAgICAgbiA9IHt9LFxuICAgICAgICAgICAgdyA9IHRoaXMubGFiZWxNZXRyaWNzKCksXG4gICAgICAgICAgICBoID0gbC5zdHlsZSAmJiBsLnN0eWxlLnRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgIEYgPSAwO1xuICAgICAgICBmKGwucm90YXRpb24pIHx8IChuLnJvdGF0aW9uID0gbC5yb3RhdGlvbiB8fCAwKTtcbiAgICAgICAgYy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYiA9IGVbYl07XG4gICAgICAgICAgYi5tb3ZlZExhYmVsICYmIGIucmVwbGFjZU1vdmVkTGFiZWwoKTtcbiAgICAgICAgICBiICYmIGIubGFiZWwgJiYgYi5sYWJlbC50ZXh0UHhMZW5ndGggPiBGICYmIChGID0gYi5sYWJlbC50ZXh0UHhMZW5ndGgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXhMYWJlbExlbmd0aCA9IEY7XG4gICAgICAgIGlmICh0aGlzLmF1dG9Sb3RhdGlvbikgRiA+IG0gJiYgRiA+IHcuaCA/IG4ucm90YXRpb24gPSB0aGlzLmxhYmVsUm90YXRpb24gOiB0aGlzLmxhYmVsUm90YXRpb24gPSAwO2Vsc2UgaWYgKGQpIHtcbiAgICAgICAgICB2YXIgeiA9IG07XG5cbiAgICAgICAgICBpZiAoIWgpIHtcbiAgICAgICAgICAgIHZhciBxID0gXCJjbGlwXCI7XG5cbiAgICAgICAgICAgIGZvciAobSA9IGMubGVuZ3RoOyAhdiAmJiBtLS07KSB7XG4gICAgICAgICAgICAgIHZhciBCID0gY1ttXTtcbiAgICAgICAgICAgICAgaWYgKEIgPSBlW0JdLmxhYmVsKSBCLnN0eWxlcyAmJiBcImVsbGlwc2lzXCIgPT09IEIuc3R5bGVzLnRleHRPdmVyZmxvdyA/IEIuY3NzKHtcbiAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6IFwiY2xpcFwiXG4gICAgICAgICAgICAgIH0pIDogQi50ZXh0UHhMZW5ndGggPiBkICYmIEIuY3NzKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogZCArIFwicHhcIlxuICAgICAgICAgICAgICB9KSwgQi5nZXRCQm94KCkuaGVpZ2h0ID4gdGhpcy5sZW4gLyBjLmxlbmd0aCAtICh3LmggLSB3LmYpICYmIChCLnNwZWNpZmljVGV4dE92ZXJmbG93ID0gXCJlbGxpcHNpc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbi5yb3RhdGlvbiAmJiAoeiA9IEYgPiAuNSAqIGEuY2hhcnRIZWlnaHQgPyAuMzMgKiBhLmNoYXJ0SGVpZ2h0IDogRiwgaCB8fCAocSA9IFwiZWxsaXBzaXNcIikpO1xuICAgICAgICBpZiAodGhpcy5sYWJlbEFsaWduID0gbC5hbGlnbiB8fCB0aGlzLmF1dG9MYWJlbEFsaWduKHRoaXMubGFiZWxSb3RhdGlvbikpIG4uYWxpZ24gPSB0aGlzLmxhYmVsQWxpZ247XG4gICAgICAgIGMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHZhciBhID0gKGIgPSBlW2JdKSAmJiBiLmxhYmVsLFxuICAgICAgICAgICAgICBjID0gay53aWR0aCxcbiAgICAgICAgICAgICAgZiA9IHt9O1xuICAgICAgICAgIGEgJiYgKGEuYXR0cihuKSwgYi5zaG9ydGVuTGFiZWwgPyBiLnNob3J0ZW5MYWJlbCgpIDogeiAmJiAhYyAmJiBcIm5vd3JhcFwiICE9PSBrLndoaXRlU3BhY2UgJiYgKHogPCBhLnRleHRQeExlbmd0aCB8fCBcIlNQQU5cIiA9PT0gYS5lbGVtZW50LnRhZ05hbWUpID8gKGYud2lkdGggPSB6LCBoIHx8IChmLnRleHRPdmVyZmxvdyA9IGEuc3BlY2lmaWNUZXh0T3ZlcmZsb3cgfHwgcSksIGEuY3NzKGYpKSA6IGEuc3R5bGVzICYmIGEuc3R5bGVzLndpZHRoICYmICFmLndpZHRoICYmICFjICYmIGEuY3NzKHtcbiAgICAgICAgICAgIHdpZHRoOiBudWxsXG4gICAgICAgICAgfSksIGRlbGV0ZSBhLnNwZWNpZmljVGV4dE92ZXJmbG93LCBiLnJvdGF0aW9uID0gbi5yb3RhdGlvbik7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLnRpY2tSb3RDb3JyID0gYi5yb3RDb3JyKHcuYiwgdGhpcy5sYWJlbFJvdGF0aW9uIHx8IDAsIDAgIT09IHRoaXMuc2lkZSk7XG4gICAgICB9LFxuICAgICAgaGFzRGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJpZXMuc29tZShmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHJldHVybiBhLmhhc0RhdGEoKTtcbiAgICAgICAgfSkgfHwgdGhpcy5vcHRpb25zLnNob3dFbXB0eSAmJiB0KHRoaXMubWluKSAmJiB0KHRoaXMubWF4KTtcbiAgICAgIH0sXG4gICAgICBhZGRUaXRsZTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmNoYXJ0LnJlbmRlcmVyLFxuICAgICAgICAgICAgZiA9IHRoaXMuaG9yaXosXG4gICAgICAgICAgICBlID0gdGhpcy5vcHBvc2l0ZSxcbiAgICAgICAgICAgIGwgPSB0aGlzLm9wdGlvbnMudGl0bGUsXG4gICAgICAgICAgICBwLFxuICAgICAgICAgICAgayA9IHRoaXMuY2hhcnQuc3R5bGVkTW9kZTtcbiAgICAgICAgdGhpcy5heGlzVGl0bGUgfHwgKChwID0gbC50ZXh0QWxpZ24pIHx8IChwID0gKGYgPyB7XG4gICAgICAgICAgbG93OiBcImxlZnRcIixcbiAgICAgICAgICBtaWRkbGU6IFwiY2VudGVyXCIsXG4gICAgICAgICAgaGlnaDogXCJyaWdodFwiXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgbG93OiBlID8gXCJyaWdodFwiIDogXCJsZWZ0XCIsXG4gICAgICAgICAgbWlkZGxlOiBcImNlbnRlclwiLFxuICAgICAgICAgIGhpZ2g6IGUgPyBcImxlZnRcIiA6IFwicmlnaHRcIlxuICAgICAgICB9KVtsLmFsaWduXSksIHRoaXMuYXhpc1RpdGxlID0gYi50ZXh0KGwudGV4dCwgMCwgMCwgbC51c2VIVE1MKS5hdHRyKHtcbiAgICAgICAgICB6SW5kZXg6IDcsXG4gICAgICAgICAgcm90YXRpb246IGwucm90YXRpb24gfHwgMCxcbiAgICAgICAgICBhbGlnbjogcFxuICAgICAgICB9KS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtYXhpcy10aXRsZVwiKSwgayB8fCB0aGlzLmF4aXNUaXRsZS5jc3MoYShsLnN0eWxlKSksIHRoaXMuYXhpc1RpdGxlLmFkZCh0aGlzLmF4aXNHcm91cCksIHRoaXMuYXhpc1RpdGxlLmlzTmV3ID0gITApO1xuICAgICAgICBrIHx8IGwuc3R5bGUud2lkdGggfHwgdGhpcy5pc1JhZGlhbCB8fCB0aGlzLmF4aXNUaXRsZS5jc3Moe1xuICAgICAgICAgIHdpZHRoOiB0aGlzLmxlblxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5heGlzVGl0bGVbYyA/IFwic2hvd1wiIDogXCJoaWRlXCJdKGMpO1xuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlVGljazogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLnRpY2tzO1xuICAgICAgICBiW2FdID8gYlthXS5hZGRMYWJlbCgpIDogYlthXSA9IG5ldyByKHRoaXMsIGEpO1xuICAgICAgfSxcbiAgICAgIGdldE9mZnNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICBiID0gYS5jaGFydCxcbiAgICAgICAgICAgIGMgPSBiLnJlbmRlcmVyLFxuICAgICAgICAgICAgZiA9IGEub3B0aW9ucyxcbiAgICAgICAgICAgIGUgPSBhLnRpY2tQb3NpdGlvbnMsXG4gICAgICAgICAgICBsID0gYS50aWNrcyxcbiAgICAgICAgICAgIGsgPSBhLmhvcml6LFxuICAgICAgICAgICAgZCA9IGEuc2lkZSxcbiAgICAgICAgICAgIG0gPSBiLmludmVydGVkICYmICFhLmlzWkF4aXMgPyBbMSwgMCwgMywgMl1bZF0gOiBkLFxuICAgICAgICAgICAgbixcbiAgICAgICAgICAgIHcgPSAwLFxuICAgICAgICAgICAgaCA9IDAsXG4gICAgICAgICAgICBGID0gZi50aXRsZSxcbiAgICAgICAgICAgIEIgPSBmLmxhYmVscyxcbiAgICAgICAgICAgIEwgPSAwLFxuICAgICAgICAgICAgZyA9IGIuYXhpc09mZnNldDtcbiAgICAgICAgYiA9IGIuY2xpcE9mZnNldDtcbiAgICAgICAgdmFyIEggPSBbLTEsIDEsIDEsIC0xXVtkXSxcbiAgICAgICAgICAgIEsgPSBmLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIFEgPSBhLmF4aXNQYXJlbnQ7XG4gICAgICAgIHZhciB5ID0gYS5oYXNEYXRhKCk7XG4gICAgICAgIGEuc2hvd0F4aXMgPSBuID0geSB8fCB6KGYuc2hvd0VtcHR5LCAhMCk7XG4gICAgICAgIGEuc3RhZ2dlckxpbmVzID0gYS5ob3JpeiAmJiBCLnN0YWdnZXJMaW5lcztcbiAgICAgICAgYS5heGlzR3JvdXAgfHwgKGEuZ3JpZEdyb3VwID0gYy5nKFwiZ3JpZFwiKS5hdHRyKHtcbiAgICAgICAgICB6SW5kZXg6IGYuZ3JpZFpJbmRleCB8fCAxXG4gICAgICAgIH0pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIiArIHRoaXMuY29sbC50b0xvd2VyQ2FzZSgpICsgXCItZ3JpZCBcIiArIChLIHx8IFwiXCIpKS5hZGQoUSksIGEuYXhpc0dyb3VwID0gYy5nKFwiYXhpc1wiKS5hdHRyKHtcbiAgICAgICAgICB6SW5kZXg6IGYuekluZGV4IHx8IDJcbiAgICAgICAgfSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLVwiICsgdGhpcy5jb2xsLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiArIChLIHx8IFwiXCIpKS5hZGQoUSksIGEubGFiZWxHcm91cCA9IGMuZyhcImF4aXMtbGFiZWxzXCIpLmF0dHIoe1xuICAgICAgICAgIHpJbmRleDogQi56SW5kZXggfHwgN1xuICAgICAgICB9KS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtXCIgKyBhLmNvbGwudG9Mb3dlckNhc2UoKSArIFwiLWxhYmVscyBcIiArIChLIHx8IFwiXCIpKS5hZGQoUSkpO1xuICAgICAgICB5IHx8IGEuaXNMaW5rZWQgPyAoZS5mb3JFYWNoKGZ1bmN0aW9uIChiLCBjKSB7XG4gICAgICAgICAgYS5nZW5lcmF0ZVRpY2soYiwgYyk7XG4gICAgICAgIH0pLCBhLnJlbmRlclVuc3F1aXNoKCksIGEucmVzZXJ2ZVNwYWNlRGVmYXVsdCA9IDAgPT09IGQgfHwgMiA9PT0gZCB8fCB7XG4gICAgICAgICAgMTogXCJsZWZ0XCIsXG4gICAgICAgICAgMzogXCJyaWdodFwiXG4gICAgICAgIH1bZF0gPT09IGEubGFiZWxBbGlnbiwgeihCLnJlc2VydmVTcGFjZSwgXCJjZW50ZXJcIiA9PT0gYS5sYWJlbEFsaWduID8gITAgOiBudWxsLCBhLnJlc2VydmVTcGFjZURlZmF1bHQpICYmIGUuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIEwgPSBNYXRoLm1heChsW2JdLmdldExhYmVsU2l6ZSgpLCBMKTtcbiAgICAgICAgfSksIGEuc3RhZ2dlckxpbmVzICYmIChMICo9IGEuc3RhZ2dlckxpbmVzKSwgYS5sYWJlbE9mZnNldCA9IEwgKiAoYS5vcHBvc2l0ZSA/IC0xIDogMSkpIDogdihsLCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIGIuZGVzdHJveSgpO1xuICAgICAgICAgIGRlbGV0ZSBsW2FdO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoRiAmJiBGLnRleHQgJiYgITEgIT09IEYuZW5hYmxlZCAmJiAoYS5hZGRUaXRsZShuKSwgbiAmJiAhMSAhPT0gRi5yZXNlcnZlU3BhY2UpKSB7XG4gICAgICAgICAgYS50aXRsZU9mZnNldCA9IHcgPSBhLmF4aXNUaXRsZS5nZXRCQm94KClbayA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCJdO1xuICAgICAgICAgIHZhciB1ID0gRi5vZmZzZXQ7XG4gICAgICAgICAgaCA9IHQodSkgPyAwIDogeihGLm1hcmdpbiwgayA/IDUgOiAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBhLnJlbmRlckxpbmUoKTtcbiAgICAgICAgYS5vZmZzZXQgPSBIICogeihmLm9mZnNldCwgZ1tkXSA/IGdbZF0gKyAoZi5tYXJnaW4gfHwgMCkgOiAwKTtcbiAgICAgICAgYS50aWNrUm90Q29yciA9IGEudGlja1JvdENvcnIgfHwge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICBjID0gMCA9PT0gZCA/IC1hLmxhYmVsTWV0cmljcygpLmggOiAyID09PSBkID8gYS50aWNrUm90Q29yci55IDogMDtcbiAgICAgICAgaCA9IE1hdGguYWJzKEwpICsgaDtcbiAgICAgICAgTCAmJiAoaCA9IGggLSBjICsgSCAqIChrID8geihCLnksIGEudGlja1JvdENvcnIueSArIDggKiBIKSA6IEIueCkpO1xuICAgICAgICBhLmF4aXNUaXRsZU1hcmdpbiA9IHoodSwgaCk7XG4gICAgICAgIGEuZ2V0TWF4TGFiZWxEaW1lbnNpb25zICYmIChhLm1heExhYmVsRGltZW5zaW9ucyA9IGEuZ2V0TWF4TGFiZWxEaW1lbnNpb25zKGwsIGUpKTtcbiAgICAgICAgayA9IHRoaXMudGlja1NpemUoXCJ0aWNrXCIpO1xuICAgICAgICBnW2RdID0gTWF0aC5tYXgoZ1tkXSwgYS5heGlzVGl0bGVNYXJnaW4gKyB3ICsgSCAqIGEub2Zmc2V0LCBoLCBlICYmIGUubGVuZ3RoICYmIGsgPyBrWzBdICsgSCAqIGEub2Zmc2V0IDogMCk7XG4gICAgICAgIGYgPSBmLm9mZnNldCA/IDAgOiAyICogTWF0aC5mbG9vcihhLmF4aXNMaW5lLnN0cm9rZVdpZHRoKCkgLyAyKTtcbiAgICAgICAgYlttXSA9IE1hdGgubWF4KGJbbV0sIGYpO1xuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJHZXRPZmZzZXRcIik7XG4gICAgICB9LFxuICAgICAgZ2V0TGluZVBhdGg6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGMgPSB0aGlzLm9wcG9zaXRlLFxuICAgICAgICAgICAgZiA9IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgZSA9IHRoaXMuaG9yaXosXG4gICAgICAgICAgICBsID0gdGhpcy5sZWZ0ICsgKGMgPyB0aGlzLndpZHRoIDogMCkgKyBmO1xuICAgICAgICBmID0gYi5jaGFydEhlaWdodCAtIHRoaXMuYm90dG9tIC0gKGMgPyB0aGlzLmhlaWdodCA6IDApICsgZjtcbiAgICAgICAgYyAmJiAoYSAqPSAtMSk7XG4gICAgICAgIHJldHVybiBiLnJlbmRlcmVyLmNyaXNwTGluZShbXCJNXCIsIGUgPyB0aGlzLmxlZnQgOiBsLCBlID8gZiA6IHRoaXMudG9wLCBcIkxcIiwgZSA/IGIuY2hhcnRXaWR0aCAtIHRoaXMucmlnaHQgOiBsLCBlID8gZiA6IGIuY2hhcnRIZWlnaHQgLSB0aGlzLmJvdHRvbV0sIGEpO1xuICAgICAgfSxcbiAgICAgIHJlbmRlckxpbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5heGlzTGluZSB8fCAodGhpcy5heGlzTGluZSA9IHRoaXMuY2hhcnQucmVuZGVyZXIucGF0aCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1heGlzLWxpbmVcIikuYWRkKHRoaXMuYXhpc0dyb3VwKSwgdGhpcy5jaGFydC5zdHlsZWRNb2RlIHx8IHRoaXMuYXhpc0xpbmUuYXR0cih7XG4gICAgICAgICAgc3Ryb2tlOiB0aGlzLm9wdGlvbnMubGluZUNvbG9yLFxuICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHRoaXMub3B0aW9ucy5saW5lV2lkdGgsXG4gICAgICAgICAgekluZGV4OiA3XG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICBnZXRUaXRsZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5ob3JpeixcbiAgICAgICAgICAgIGIgPSB0aGlzLmxlZnQsXG4gICAgICAgICAgICBjID0gdGhpcy50b3AsXG4gICAgICAgICAgICBmID0gdGhpcy5sZW4sXG4gICAgICAgICAgICBlID0gdGhpcy5vcHRpb25zLnRpdGxlLFxuICAgICAgICAgICAgbCA9IGEgPyBiIDogYyxcbiAgICAgICAgICAgIGsgPSB0aGlzLm9wcG9zaXRlLFxuICAgICAgICAgICAgZCA9IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgbSA9IGUueCB8fCAwLFxuICAgICAgICAgICAgdiA9IGUueSB8fCAwLFxuICAgICAgICAgICAgbiA9IHRoaXMuYXhpc1RpdGxlLFxuICAgICAgICAgICAgdyA9IHRoaXMuY2hhcnQucmVuZGVyZXIuZm9udE1ldHJpY3MoZS5zdHlsZSAmJiBlLnN0eWxlLmZvbnRTaXplLCBuKTtcbiAgICAgICAgbiA9IE1hdGgubWF4KG4uZ2V0QkJveChudWxsLCAwKS5oZWlnaHQgLSB3LmggLSAxLCAwKTtcbiAgICAgICAgZiA9IHtcbiAgICAgICAgICBsb3c6IGwgKyAoYSA/IDAgOiBmKSxcbiAgICAgICAgICBtaWRkbGU6IGwgKyBmIC8gMixcbiAgICAgICAgICBoaWdoOiBsICsgKGEgPyBmIDogMClcbiAgICAgICAgfVtlLmFsaWduXTtcbiAgICAgICAgYiA9IChhID8gYyArIHRoaXMuaGVpZ2h0IDogYikgKyAoYSA/IDEgOiAtMSkgKiAoayA/IC0xIDogMSkgKiB0aGlzLmF4aXNUaXRsZU1hcmdpbiArIFstbiwgbiwgdy5mLCAtbl1bdGhpcy5zaWRlXTtcbiAgICAgICAgYSA9IHtcbiAgICAgICAgICB4OiBhID8gZiArIG0gOiBiICsgKGsgPyB0aGlzLndpZHRoIDogMCkgKyBkICsgbSxcbiAgICAgICAgICB5OiBhID8gYiArIHYgLSAoayA/IHRoaXMuaGVpZ2h0IDogMCkgKyBkIDogZiArIHZcbiAgICAgICAgfTtcbiAgICAgICAgcSh0aGlzLCBcImFmdGVyR2V0VGl0bGVQb3NpdGlvblwiLCB7XG4gICAgICAgICAgdGl0bGVQb3NpdGlvbjogYVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9LFxuICAgICAgcmVuZGVyTWlub3JUaWNrOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYiA9IHRoaXMuY2hhcnQuaGFzUmVuZGVyZWQgJiYgbih0aGlzLm9sZE1pbiksXG4gICAgICAgICAgICBjID0gdGhpcy5taW5vclRpY2tzO1xuICAgICAgICBjW2FdIHx8IChjW2FdID0gbmV3IHIodGhpcywgYSwgXCJtaW5vclwiKSk7XG4gICAgICAgIGIgJiYgY1thXS5pc05ldyAmJiBjW2FdLnJlbmRlcihudWxsLCAhMCk7XG4gICAgICAgIGNbYV0ucmVuZGVyKG51bGwsICExLCAxKTtcbiAgICAgIH0sXG4gICAgICByZW5kZXJUaWNrOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgYyA9IHRoaXMuaXNMaW5rZWQsXG4gICAgICAgICAgICBmID0gdGhpcy50aWNrcyxcbiAgICAgICAgICAgIGUgPSB0aGlzLmNoYXJ0Lmhhc1JlbmRlcmVkICYmIG4odGhpcy5vbGRNaW4pO1xuICAgICAgICBpZiAoIWMgfHwgYSA+PSB0aGlzLm1pbiAmJiBhIDw9IHRoaXMubWF4KSBmW2FdIHx8IChmW2FdID0gbmV3IHIodGhpcywgYSkpLCBlICYmIGZbYV0uaXNOZXcgJiYgZlthXS5yZW5kZXIoYiwgITAsIC0xKSwgZlthXS5yZW5kZXIoYik7XG4gICAgICB9LFxuICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIGIgPSBhLmNoYXJ0LFxuICAgICAgICAgICAgYyA9IGEub3B0aW9ucyxcbiAgICAgICAgICAgIGYgPSBhLmlzTG9nLFxuICAgICAgICAgICAgZSA9IGEuaXNMaW5rZWQsXG4gICAgICAgICAgICBsID0gYS50aWNrUG9zaXRpb25zLFxuICAgICAgICAgICAgayA9IGEuYXhpc1RpdGxlLFxuICAgICAgICAgICAgdyA9IGEudGlja3MsXG4gICAgICAgICAgICBtID0gYS5taW5vclRpY2tzLFxuICAgICAgICAgICAgaCA9IGEuYWx0ZXJuYXRlQmFuZHMsXG4gICAgICAgICAgICB6ID0gYy5zdGFja0xhYmVscyxcbiAgICAgICAgICAgIEIgPSBjLmFsdGVybmF0ZUdyaWRDb2xvcixcbiAgICAgICAgICAgIEYgPSBhLnRpY2ttYXJrT2Zmc2V0LFxuICAgICAgICAgICAgTCA9IGEuYXhpc0xpbmUsXG4gICAgICAgICAgICB0ID0gYS5zaG93QXhpcyxcbiAgICAgICAgICAgIGcgPSBFKGIucmVuZGVyZXIuZ2xvYmFsQW5pbWF0aW9uKSxcbiAgICAgICAgICAgIEgsXG4gICAgICAgICAgICBLO1xuICAgICAgICBhLmxhYmVsRWRnZS5sZW5ndGggPSAwO1xuICAgICAgICBhLm92ZXJsYXAgPSAhMTtcbiAgICAgICAgW3csIG0sIGhdLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICB2KGIsIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICBiLmlzQWN0aXZlID0gITE7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYS5oYXNEYXRhKCkgfHwgZSkgYS5taW5vclRpY2tJbnRlcnZhbCAmJiAhYS5jYXRlZ29yaWVzICYmIGEuZ2V0TWlub3JUaWNrUG9zaXRpb25zKCkuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGEucmVuZGVyTWlub3JUaWNrKGIpO1xuICAgICAgICB9KSwgbC5sZW5ndGggJiYgKGwuZm9yRWFjaChmdW5jdGlvbiAoYiwgYykge1xuICAgICAgICAgIGEucmVuZGVyVGljayhiLCBjKTtcbiAgICAgICAgfSksIEYgJiYgKDAgPT09IGEubWluIHx8IGEuc2luZ2xlKSAmJiAod1stMV0gfHwgKHdbLTFdID0gbmV3IHIoYSwgLTEsIG51bGwsICEwKSksIHdbLTFdLnJlbmRlcigtMSkpKSwgQiAmJiBsLmZvckVhY2goZnVuY3Rpb24gKGMsIGUpIHtcbiAgICAgICAgICBLID0gXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGxbZSArIDFdID8gbFtlICsgMV0gKyBGIDogYS5tYXggLSBGO1xuICAgICAgICAgIDAgPT09IGUgJSAyICYmIGMgPCBhLm1heCAmJiBLIDw9IGEubWF4ICsgKGIucG9sYXIgPyAtRiA6IEYpICYmIChoW2NdIHx8IChoW2NdID0gbmV3IGQuUGxvdExpbmVPckJhbmQoYSkpLCBIID0gYyArIEYsIGhbY10ub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGZyb206IGYgPyBhLmxpbjJsb2coSCkgOiBILFxuICAgICAgICAgICAgdG86IGYgPyBhLmxpbjJsb2coSykgOiBLLFxuICAgICAgICAgICAgY29sb3I6IEJcbiAgICAgICAgICB9LCBoW2NdLnJlbmRlcigpLCBoW2NdLmlzQWN0aXZlID0gITApO1xuICAgICAgICB9KSwgYS5fYWRkZWRQbG90TEIgfHwgKChjLnBsb3RMaW5lcyB8fCBbXSkuY29uY2F0KGMucGxvdEJhbmRzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYS5hZGRQbG90QmFuZE9yTGluZShiKTtcbiAgICAgICAgfSksIGEuX2FkZGVkUGxvdExCID0gITApO1xuICAgICAgICBbdywgbSwgaF0uZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHZhciBjLFxuICAgICAgICAgICAgICBmID0gW10sXG4gICAgICAgICAgICAgIGUgPSBnLmR1cmF0aW9uO1xuICAgICAgICAgIHYoYSwgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICAgIGIuaXNBY3RpdmUgfHwgKGIucmVuZGVyKGEsICExLCAwKSwgYi5pc0FjdGl2ZSA9ICExLCBmLnB1c2goYSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFEoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yIChjID0gZi5sZW5ndGg7IGMtLTspIGFbZltjXV0gJiYgIWFbZltjXV0uaXNBY3RpdmUgJiYgKGFbZltjXV0uZGVzdHJveSgpLCBkZWxldGUgYVtmW2NdXSk7XG4gICAgICAgICAgfSwgYSAhPT0gaCAmJiBiLmhhc1JlbmRlcmVkICYmIGUgPyBlIDogMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBMICYmIChMW0wuaXNQbGFjZWQgPyBcImFuaW1hdGVcIiA6IFwiYXR0clwiXSh7XG4gICAgICAgICAgZDogdGhpcy5nZXRMaW5lUGF0aChMLnN0cm9rZVdpZHRoKCkpXG4gICAgICAgIH0pLCBMLmlzUGxhY2VkID0gITAsIExbdCA/IFwic2hvd1wiIDogXCJoaWRlXCJdKHQpKTtcbiAgICAgICAgayAmJiB0ICYmIChjID0gYS5nZXRUaXRsZVBvc2l0aW9uKCksIG4oYy55KSA/IChrW2suaXNOZXcgPyBcImF0dHJcIiA6IFwiYW5pbWF0ZVwiXShjKSwgay5pc05ldyA9ICExKSA6IChrLmF0dHIoXCJ5XCIsIC05OTk5KSwgay5pc05ldyA9ICEwKSk7XG4gICAgICAgIHogJiYgei5lbmFibGVkICYmIGEucmVuZGVyU3RhY2tUb3RhbHMoKTtcbiAgICAgICAgYS5pc0RpcnR5ID0gITE7XG4gICAgICAgIHEodGhpcywgXCJhZnRlclJlbmRlclwiKTtcbiAgICAgIH0sXG4gICAgICByZWRyYXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aXNpYmxlICYmICh0aGlzLnJlbmRlcigpLCB0aGlzLnBsb3RMaW5lc0FuZEJhbmRzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhLnJlbmRlcigpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhLmlzRGlydHkgPSAhMDtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAga2VlcFByb3BzOiBcImV4dEtleSBoY0V2ZW50cyBuYW1lcyBzZXJpZXMgdXNlck1heCB1c2VyTWluXCIuc3BsaXQoXCIgXCIpLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICAgICAgYyA9IGIuc3RhY2tzLFxuICAgICAgICAgICAgZiA9IGIucGxvdExpbmVzQW5kQmFuZHMsXG4gICAgICAgICAgICBlO1xuICAgICAgICBxKHRoaXMsIFwiZGVzdHJveVwiLCB7XG4gICAgICAgICAga2VlcEV2ZW50czogYVxuICAgICAgICB9KTtcbiAgICAgICAgYSB8fCBCKGIpO1xuICAgICAgICB2KGMsIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgRChiKTtcbiAgICAgICAgICBjW2FdID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIFtiLnRpY2tzLCBiLm1pbm9yVGlja3MsIGIuYWx0ZXJuYXRlQmFuZHNdLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBEKGIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGYpIGZvciAoYSA9IGYubGVuZ3RoOyBhLS07KSBmW2FdLmRlc3Ryb3koKTtcbiAgICAgICAgXCJzdGFja1RvdGFsR3JvdXAgYXhpc0xpbmUgYXhpc1RpdGxlIGF4aXNHcm91cCBncmlkR3JvdXAgbGFiZWxHcm91cCBjcm9zcyBzY3JvbGxiYXJcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGJbYV0gJiYgKGJbYV0gPSBiW2FdLmRlc3Ryb3koKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAoZSBpbiBiLnBsb3RMaW5lc0FuZEJhbmRzR3JvdXBzKSBiLnBsb3RMaW5lc0FuZEJhbmRzR3JvdXBzW2VdID0gYi5wbG90TGluZXNBbmRCYW5kc0dyb3Vwc1tlXS5kZXN0cm95KCk7XG5cbiAgICAgICAgdihiLCBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICAgIC0xID09PSBiLmtlZXBQcm9wcy5pbmRleE9mKGMpICYmIGRlbGV0ZSBiW2NdO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBkcmF3Q3Jvc3NoYWlyOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgYyA9IHRoaXMuY3Jvc3NoYWlyLFxuICAgICAgICAgICAgZiA9IHooYy5zbmFwLCAhMCksXG4gICAgICAgICAgICBlLFxuICAgICAgICAgICAgbCA9IHRoaXMuY3Jvc3MsXG4gICAgICAgICAgICBrID0gdGhpcy5jaGFydDtcbiAgICAgICAgcSh0aGlzLCBcImRyYXdDcm9zc2hhaXJcIiwge1xuICAgICAgICAgIGU6IGEsXG4gICAgICAgICAgcG9pbnQ6IGJcbiAgICAgICAgfSk7XG4gICAgICAgIGEgfHwgKGEgPSB0aGlzLmNyb3NzICYmIHRoaXMuY3Jvc3MuZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuY3Jvc3NoYWlyICYmICExICE9PSAodChiKSB8fCAhZikpIHtcbiAgICAgICAgICBmID8gdChiKSAmJiAoZSA9IHooXCJjb2xvckF4aXNcIiAhPT0gdGhpcy5jb2xsID8gYi5jcm9zc2hhaXJQb3MgOiBudWxsLCB0aGlzLmlzWEF4aXMgPyBiLnBsb3RYIDogdGhpcy5sZW4gLSBiLnBsb3RZKSkgOiBlID0gYSAmJiAodGhpcy5ob3JpeiA/IGEuY2hhcnRYIC0gdGhpcy5wb3MgOiB0aGlzLmxlbiAtIGEuY2hhcnRZICsgdGhpcy5wb3MpO1xuXG4gICAgICAgICAgaWYgKHQoZSkpIHtcbiAgICAgICAgICAgIHZhciBkID0ge1xuICAgICAgICAgICAgICB2YWx1ZTogYiAmJiAodGhpcy5pc1hBeGlzID8gYi54IDogeihiLnN0YWNrWSwgYi55KSksXG4gICAgICAgICAgICAgIHRyYW5zbGF0ZWRWYWx1ZTogZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGsucG9sYXIgJiYgTihkLCB7XG4gICAgICAgICAgICAgIGlzQ3Jvc3NoYWlyOiAhMCxcbiAgICAgICAgICAgICAgY2hhcnRYOiBhICYmIGEuY2hhcnRYLFxuICAgICAgICAgICAgICBjaGFydFk6IGEgJiYgYS5jaGFydFksXG4gICAgICAgICAgICAgIHBvaW50OiBiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGQgPSB0aGlzLmdldFBsb3RMaW5lUGF0aChkKSB8fCBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdChkKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlQ3Jvc3NoYWlyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZiA9IHRoaXMuY2F0ZWdvcmllcyAmJiAhdGhpcy5pc1JhZGlhbDtcbiAgICAgICAgICBsIHx8ICh0aGlzLmNyb3NzID0gbCA9IGsucmVuZGVyZXIucGF0aCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1jcm9zc2hhaXIgaGlnaGNoYXJ0cy1jcm9zc2hhaXItXCIgKyAoZiA/IFwiY2F0ZWdvcnkgXCIgOiBcInRoaW4gXCIpICsgYy5jbGFzc05hbWUpLmF0dHIoe1xuICAgICAgICAgICAgekluZGV4OiB6KGMuekluZGV4LCAyKVxuICAgICAgICAgIH0pLmFkZCgpLCBrLnN0eWxlZE1vZGUgfHwgKGwuYXR0cih7XG4gICAgICAgICAgICBzdHJva2U6IGMuY29sb3IgfHwgKGYgPyBJKFwiI2NjZDZlYlwiKS5zZXRPcGFjaXR5KC4yNSkuZ2V0KCkgOiBcIiNjY2NjY2NcIiksXG4gICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiB6KGMud2lkdGgsIDEpXG4gICAgICAgICAgfSkuY3NzKHtcbiAgICAgICAgICAgIFwicG9pbnRlci1ldmVudHNcIjogXCJub25lXCJcbiAgICAgICAgICB9KSwgYy5kYXNoU3R5bGUgJiYgbC5hdHRyKHtcbiAgICAgICAgICAgIGRhc2hzdHlsZTogYy5kYXNoU3R5bGVcbiAgICAgICAgICB9KSkpO1xuICAgICAgICAgIGwuc2hvdygpLmF0dHIoe1xuICAgICAgICAgICAgZDogZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGYgJiYgIWMud2lkdGggJiYgbC5hdHRyKHtcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHRoaXMudHJhbnNBXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5jcm9zcy5lID0gYTtcbiAgICAgICAgfSBlbHNlIHRoaXMuaGlkZUNyb3NzaGFpcigpO1xuXG4gICAgICAgIHEodGhpcywgXCJhZnRlckRyYXdDcm9zc2hhaXJcIiwge1xuICAgICAgICAgIGU6IGEsXG4gICAgICAgICAgcG9pbnQ6IGJcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgaGlkZUNyb3NzaGFpcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNyb3NzICYmIHRoaXMuY3Jvc3MuaGlkZSgpO1xuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJIaWRlQ3Jvc3NoYWlyXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkLkF4aXMgPSBnO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL0RhdGVUaW1lQXhpcy5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZykge1xuICAgIHZhciByID0gZy5nZXRNYWduaXR1ZGUsXG4gICAgICAgIHUgPSBnLm5vcm1hbGl6ZVRpY2tJbnRlcnZhbCxcbiAgICAgICAgSSA9IGcudGltZVVuaXRzO1xuICAgIGQgPSBkLkF4aXM7XG5cbiAgICBkLnByb3RvdHlwZS5nZXRUaW1lVGlja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFydC50aW1lLmdldFRpbWVUaWNrcy5hcHBseSh0aGlzLmNoYXJ0LnRpbWUsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGQucHJvdG90eXBlLm5vcm1hbGl6ZVRpbWVUaWNrSW50ZXJ2YWwgPSBmdW5jdGlvbiAoZCwgZykge1xuICAgICAgdmFyIEEgPSBnIHx8IFtbXCJtaWxsaXNlY29uZFwiLCBbMSwgMiwgNSwgMTAsIDIwLCAyNSwgNTAsIDEwMCwgMjAwLCA1MDBdXSwgW1wic2Vjb25kXCIsIFsxLCAyLCA1LCAxMCwgMTUsIDMwXV0sIFtcIm1pbnV0ZVwiLCBbMSwgMiwgNSwgMTAsIDE1LCAzMF1dLCBbXCJob3VyXCIsIFsxLCAyLCAzLCA0LCA2LCA4LCAxMl1dLCBbXCJkYXlcIiwgWzEsIDJdXSwgW1wid2Vla1wiLCBbMSwgMl1dLCBbXCJtb250aFwiLCBbMSwgMiwgMywgNCwgNl1dLCBbXCJ5ZWFyXCIsIG51bGxdXTtcbiAgICAgIGcgPSBBW0EubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgRyA9IElbZ1swXV0sXG4gICAgICAgICAgRSA9IGdbMV0sXG4gICAgICAgICAgeTtcblxuICAgICAgZm9yICh5ID0gMDsgeSA8IEEubGVuZ3RoICYmICEoZyA9IEFbeV0sIEcgPSBJW2dbMF1dLCBFID0gZ1sxXSwgQVt5ICsgMV0gJiYgZCA8PSAoRyAqIEVbRS5sZW5ndGggLSAxXSArIElbQVt5ICsgMV1bMF1dKSAvIDIpOyB5KyspO1xuXG4gICAgICBHID09PSBJLnllYXIgJiYgZCA8IDUgKiBHICYmIChFID0gWzEsIDIsIDVdKTtcbiAgICAgIGQgPSB1KGQgLyBHLCBFLCBcInllYXJcIiA9PT0gZ1swXSA/IE1hdGgubWF4KHIoZCAvIEcpLCAxKSA6IDEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdW5pdFJhbmdlOiBHLFxuICAgICAgICBjb3VudDogZCxcbiAgICAgICAgdW5pdE5hbWU6IGdbMF1cbiAgICAgIH07XG4gICAgfTtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9Mb2dhcml0aG1pY0F4aXMuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcpIHtcbiAgICB2YXIgciA9IGcuZ2V0TWFnbml0dWRlLFxuICAgICAgICB1ID0gZy5ub3JtYWxpemVUaWNrSW50ZXJ2YWwsXG4gICAgICAgIEkgPSBnLnBpY2s7XG4gICAgZCA9IGQuQXhpcztcblxuICAgIGQucHJvdG90eXBlLmdldExvZ1RpY2tQb3NpdGlvbnMgPSBmdW5jdGlvbiAoZCwgZywgQSwgRykge1xuICAgICAgdmFyIEUgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgeSA9IHRoaXMubGVuLFxuICAgICAgICAgIHQgPSBbXTtcbiAgICAgIEcgfHwgKHRoaXMuX21pbm9yQXV0b0ludGVydmFsID0gbnVsbCk7XG4gICAgICBpZiAoLjUgPD0gZCkgZCA9IE1hdGgucm91bmQoZCksIHQgPSB0aGlzLmdldExpbmVhclRpY2tQb3NpdGlvbnMoZCwgZywgQSk7ZWxzZSBpZiAoLjA4IDw9IGQpIHtcbiAgICAgICAgeSA9IE1hdGguZmxvb3IoZyk7XG4gICAgICAgIHZhciBELCBoO1xuXG4gICAgICAgIGZvciAoRSA9IC4zIDwgZCA/IFsxLCAyLCA0XSA6IC4xNSA8IGQgPyBbMSwgMiwgNCwgNiwgOF0gOiBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV07IHkgPCBBICsgMSAmJiAhaDsgeSsrKSB7XG4gICAgICAgICAgdmFyIE4gPSBFLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoRCA9IDA7IEQgPCBOICYmICFoOyBEKyspIHtcbiAgICAgICAgICAgIHZhciBxID0gdGhpcy5sb2cybGluKHRoaXMubGluMmxvZyh5KSAqIEVbRF0pO1xuICAgICAgICAgICAgcSA+IGcgJiYgKCFHIHx8IFAgPD0gQSkgJiYgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIFAgJiYgdC5wdXNoKFApO1xuICAgICAgICAgICAgUCA+IEEgJiYgKGggPSAhMCk7XG4gICAgICAgICAgICB2YXIgUCA9IHE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgZyA9IHRoaXMubGluMmxvZyhnKSwgQSA9IHRoaXMubGluMmxvZyhBKSwgZCA9IEcgPyB0aGlzLmdldE1pbm9yVGlja0ludGVydmFsKCkgOiBFLnRpY2tJbnRlcnZhbCwgZCA9IEkoXCJhdXRvXCIgPT09IGQgPyBudWxsIDogZCwgdGhpcy5fbWlub3JBdXRvSW50ZXJ2YWwsIEUudGlja1BpeGVsSW50ZXJ2YWwgLyAoRyA/IDUgOiAxKSAqIChBIC0gZykgLyAoKEcgPyB5IC8gdGhpcy50aWNrUG9zaXRpb25zLmxlbmd0aCA6IHkpIHx8IDEpKSwgZCA9IHUoZCwgbnVsbCwgcihkKSksIHQgPSB0aGlzLmdldExpbmVhclRpY2tQb3NpdGlvbnMoZCwgZywgQSkubWFwKHRoaXMubG9nMmxpbiksIEcgfHwgKHRoaXMuX21pbm9yQXV0b0ludGVydmFsID0gZCAvIDUpO1xuICAgICAgRyB8fCAodGhpcy50aWNrSW50ZXJ2YWwgPSBkKTtcbiAgICAgIHJldHVybiB0O1xuICAgIH07XG5cbiAgICBkLnByb3RvdHlwZS5sb2cybGluID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBNYXRoLmxvZyhkKSAvIE1hdGguTE4xMDtcbiAgICB9O1xuXG4gICAgZC5wcm90b3R5cGUubGluMmxvZyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3coMTAsIGQpO1xuICAgIH07XG4gIH0pO1xuICBTKHIsIFwicGFydHMvUGxvdExpbmVPckJhbmQuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvQXhpcy5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnLCByKSB7XG4gICAgdmFyIHUgPSByLmFycmF5TWF4LFxuICAgICAgICBJID0gci5hcnJheU1pbixcbiAgICAgICAgTSA9IHIuZGVmaW5lZCxcbiAgICAgICAgRSA9IHIuZGVzdHJveU9iamVjdFByb3BlcnRpZXMsXG4gICAgICAgIEEgPSByLmVyYXNlLFxuICAgICAgICBHID0gci5leHRlbmQsXG4gICAgICAgIEogPSByLm1lcmdlLFxuICAgICAgICB5ID0gci5vYmplY3RFYWNoLFxuICAgICAgICB0ID0gci5waWNrLFxuICAgICAgICBEID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gaChkLCBoKSB7XG4gICAgICAgIHRoaXMuYXhpcyA9IGQ7XG4gICAgICAgIGggJiYgKHRoaXMub3B0aW9ucyA9IGgsIHRoaXMuaWQgPSBoLmlkKTtcbiAgICAgIH1cblxuICAgICAgaC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkLmZpcmVFdmVudCh0aGlzLCBcInJlbmRlclwiKTtcbiAgICAgICAgdmFyIGggPSB0aGlzLFxuICAgICAgICAgICAgcSA9IGguYXhpcyxcbiAgICAgICAgICAgIGcgPSBxLmhvcml6LFxuICAgICAgICAgICAgZSA9IGgub3B0aW9ucyxcbiAgICAgICAgICAgIGMgPSBlLmxhYmVsLFxuICAgICAgICAgICAgayA9IGgubGFiZWwsXG4gICAgICAgICAgICBuID0gZS50byxcbiAgICAgICAgICAgIGYgPSBlLmZyb20sXG4gICAgICAgICAgICBhID0gZS52YWx1ZSxcbiAgICAgICAgICAgIGwgPSBNKGYpICYmIE0obiksXG4gICAgICAgICAgICB2ID0gTShhKSxcbiAgICAgICAgICAgIHogPSBoLnN2Z0VsZW0sXG4gICAgICAgICAgICB3ID0gIXosXG4gICAgICAgICAgICBCID0gW10sXG4gICAgICAgICAgICBMID0gZS5jb2xvcixcbiAgICAgICAgICAgIFEgPSB0KGUuekluZGV4LCAwKSxcbiAgICAgICAgICAgIEggPSBlLmV2ZW50cztcbiAgICAgICAgQiA9IHtcbiAgICAgICAgICBcImNsYXNzXCI6IFwiaGlnaGNoYXJ0cy1wbG90LVwiICsgKGwgPyBcImJhbmQgXCIgOiBcImxpbmUgXCIpICsgKGUuY2xhc3NOYW1lIHx8IFwiXCIpXG4gICAgICAgIH07XG4gICAgICAgIHZhciBLID0ge30sXG4gICAgICAgICAgICBwID0gcS5jaGFydC5yZW5kZXJlcixcbiAgICAgICAgICAgIGIgPSBsID8gXCJiYW5kc1wiIDogXCJsaW5lc1wiO1xuICAgICAgICBxLmlzTG9nICYmIChmID0gcS5sb2cybGluKGYpLCBuID0gcS5sb2cybGluKG4pLCBhID0gcS5sb2cybGluKGEpKTtcbiAgICAgICAgcS5jaGFydC5zdHlsZWRNb2RlIHx8ICh2ID8gKEIuc3Ryb2tlID0gTCB8fCBcIiM5OTk5OTlcIiwgQltcInN0cm9rZS13aWR0aFwiXSA9IHQoZS53aWR0aCwgMSksIGUuZGFzaFN0eWxlICYmIChCLmRhc2hzdHlsZSA9IGUuZGFzaFN0eWxlKSkgOiBsICYmIChCLmZpbGwgPSBMIHx8IFwiI2U2ZWJmNVwiLCBlLmJvcmRlcldpZHRoICYmIChCLnN0cm9rZSA9IGUuYm9yZGVyQ29sb3IsIEJbXCJzdHJva2Utd2lkdGhcIl0gPSBlLmJvcmRlcldpZHRoKSkpO1xuICAgICAgICBLLnpJbmRleCA9IFE7XG4gICAgICAgIGIgKz0gXCItXCIgKyBRO1xuICAgICAgICAoTCA9IHEucGxvdExpbmVzQW5kQmFuZHNHcm91cHNbYl0pIHx8IChxLnBsb3RMaW5lc0FuZEJhbmRzR3JvdXBzW2JdID0gTCA9IHAuZyhcInBsb3QtXCIgKyBiKS5hdHRyKEspLmFkZCgpKTtcbiAgICAgICAgdyAmJiAoaC5zdmdFbGVtID0geiA9IHAucGF0aCgpLmF0dHIoQikuYWRkKEwpKTtcbiAgICAgICAgaWYgKHYpIEIgPSBxLmdldFBsb3RMaW5lUGF0aCh7XG4gICAgICAgICAgdmFsdWU6IGEsXG4gICAgICAgICAgbGluZVdpZHRoOiB6LnN0cm9rZVdpZHRoKCksXG4gICAgICAgICAgYWNyb3NzUGFuZXM6IGUuYWNyb3NzUGFuZXNcbiAgICAgICAgfSk7ZWxzZSBpZiAobCkgQiA9IHEuZ2V0UGxvdEJhbmRQYXRoKGYsIG4sIGUpO2Vsc2UgcmV0dXJuO1xuICAgICAgICAodyB8fCAhei5kKSAmJiBCICYmIEIubGVuZ3RoID8gKHouYXR0cih7XG4gICAgICAgICAgZDogQlxuICAgICAgICB9KSwgSCAmJiB5KEgsIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgei5vbihhLCBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgSFthXS5hcHBseShoLCBbYl0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSkgOiB6ICYmIChCID8gKHouc2hvdyghMCksIHouYW5pbWF0ZSh7XG4gICAgICAgICAgZDogQlxuICAgICAgICB9KSkgOiB6LmQgJiYgKHouaGlkZSgpLCBrICYmIChoLmxhYmVsID0gayA9IGsuZGVzdHJveSgpKSkpO1xuICAgICAgICBjICYmIChNKGMudGV4dCkgfHwgTShjLmZvcm1hdHRlcikpICYmIEIgJiYgQi5sZW5ndGggJiYgMCA8IHEud2lkdGggJiYgMCA8IHEuaGVpZ2h0ICYmICFCLmlzRmxhdCA/IChjID0gSih7XG4gICAgICAgICAgYWxpZ246IGcgJiYgbCAmJiBcImNlbnRlclwiLFxuICAgICAgICAgIHg6IGcgPyAhbCAmJiA0IDogMTAsXG4gICAgICAgICAgdmVydGljYWxBbGlnbjogIWcgJiYgbCAmJiBcIm1pZGRsZVwiLFxuICAgICAgICAgIHk6IGcgPyBsID8gMTYgOiAxMCA6IGwgPyA2IDogLTQsXG4gICAgICAgICAgcm90YXRpb246IGcgJiYgIWwgJiYgOTBcbiAgICAgICAgfSwgYyksIHRoaXMucmVuZGVyTGFiZWwoYywgQiwgbCwgUSkpIDogayAmJiBrLmhpZGUoKTtcbiAgICAgICAgcmV0dXJuIGg7XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5yZW5kZXJMYWJlbCA9IGZ1bmN0aW9uIChkLCBoLCBnLCBlKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5sYWJlbCxcbiAgICAgICAgICAgIGsgPSB0aGlzLmF4aXMuY2hhcnQucmVuZGVyZXI7XG4gICAgICAgIGMgfHwgKGMgPSB7XG4gICAgICAgICAgYWxpZ246IGQudGV4dEFsaWduIHx8IGQuYWxpZ24sXG4gICAgICAgICAgcm90YXRpb246IGQucm90YXRpb24sXG4gICAgICAgICAgXCJjbGFzc1wiOiBcImhpZ2hjaGFydHMtcGxvdC1cIiArIChnID8gXCJiYW5kXCIgOiBcImxpbmVcIikgKyBcIi1sYWJlbCBcIiArIChkLmNsYXNzTmFtZSB8fCBcIlwiKVxuICAgICAgICB9LCBjLnpJbmRleCA9IGUsIGUgPSB0aGlzLmdldExhYmVsVGV4dChkKSwgdGhpcy5sYWJlbCA9IGMgPSBrLnRleHQoZSwgMCwgMCwgZC51c2VIVE1MKS5hdHRyKGMpLmFkZCgpLCB0aGlzLmF4aXMuY2hhcnQuc3R5bGVkTW9kZSB8fCBjLmNzcyhkLnN0eWxlKSk7XG4gICAgICAgIGsgPSBoLnhCb3VuZHMgfHwgW2hbMV0sIGhbNF0sIGcgPyBoWzZdIDogaFsxXV07XG4gICAgICAgIGggPSBoLnlCb3VuZHMgfHwgW2hbMl0sIGhbNV0sIGcgPyBoWzddIDogaFsyXV07XG4gICAgICAgIGcgPSBJKGspO1xuICAgICAgICBlID0gSShoKTtcbiAgICAgICAgYy5hbGlnbihkLCAhMSwge1xuICAgICAgICAgIHg6IGcsXG4gICAgICAgICAgeTogZSxcbiAgICAgICAgICB3aWR0aDogdShrKSAtIGcsXG4gICAgICAgICAgaGVpZ2h0OiB1KGgpIC0gZVxuICAgICAgICB9KTtcbiAgICAgICAgYy5zaG93KCEwKTtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLmdldExhYmVsVGV4dCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBNKGQuZm9ybWF0dGVyKSA/IGQuZm9ybWF0dGVyLmNhbGwodGhpcykgOiBkLnRleHQ7XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBBKHRoaXMuYXhpcy5wbG90TGluZXNBbmRCYW5kcywgdGhpcyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmF4aXM7XG4gICAgICAgIEUodGhpcyk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gaDtcbiAgICB9KCk7XG5cbiAgICBHKGcucHJvdG90eXBlLCB7XG4gICAgICBnZXRQbG90QmFuZFBhdGg6IGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgICAgIHZhciBoID0gdGhpcy5nZXRQbG90TGluZVBhdGgoe1xuICAgICAgICAgIHZhbHVlOiBnLFxuICAgICAgICAgIGZvcmNlOiAhMCxcbiAgICAgICAgICBhY3Jvc3NQYW5lczogdGhpcy5vcHRpb25zLmFjcm9zc1BhbmVzXG4gICAgICAgIH0pLFxuICAgICAgICAgICAgdCA9IHRoaXMuZ2V0UGxvdExpbmVQYXRoKHtcbiAgICAgICAgICB2YWx1ZTogZCxcbiAgICAgICAgICBmb3JjZTogITAsXG4gICAgICAgICAgYWNyb3NzUGFuZXM6IHRoaXMub3B0aW9ucy5hY3Jvc3NQYW5lc1xuICAgICAgICB9KSxcbiAgICAgICAgICAgIGUgPSBbXSxcbiAgICAgICAgICAgIGMgPSB0aGlzLmhvcml6LFxuICAgICAgICAgICAgayA9IDE7XG4gICAgICAgIGQgPSBkIDwgdGhpcy5taW4gJiYgZyA8IHRoaXMubWluIHx8IGQgPiB0aGlzLm1heCAmJiBnID4gdGhpcy5tYXg7XG5cbiAgICAgICAgaWYgKHQgJiYgaCkge1xuICAgICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHQudG9TdHJpbmcoKSA9PT0gaC50b1N0cmluZygpO1xuICAgICAgICAgICAgayA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChkID0gMDsgZCA8IHQubGVuZ3RoOyBkICs9IDYpIGMgJiYgaFtkICsgMV0gPT09IHRbZCArIDFdID8gKGhbZCArIDFdICs9IGssIGhbZCArIDRdICs9IGspIDogYyB8fCBoW2QgKyAyXSAhPT0gdFtkICsgMl0gfHwgKGhbZCArIDJdICs9IGssIGhbZCArIDVdICs9IGspLCBlLnB1c2goXCJNXCIsIHRbZCArIDFdLCB0W2QgKyAyXSwgXCJMXCIsIHRbZCArIDRdLCB0W2QgKyA1XSwgaFtkICsgNF0sIGhbZCArIDVdLCBoW2QgKyAxXSwgaFtkICsgMl0sIFwielwiKSwgZS5pc0ZsYXQgPSBuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9LFxuICAgICAgYWRkUGxvdEJhbmQ6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFBsb3RCYW5kT3JMaW5lKGQsIFwicGxvdEJhbmRzXCIpO1xuICAgICAgfSxcbiAgICAgIGFkZFBsb3RMaW5lOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRQbG90QmFuZE9yTGluZShkLCBcInBsb3RMaW5lc1wiKTtcbiAgICAgIH0sXG4gICAgICBhZGRQbG90QmFuZE9yTGluZTogZnVuY3Rpb24gKGQsIGcpIHtcbiAgICAgICAgdmFyIGggPSBuZXcgRCh0aGlzLCBkKS5yZW5kZXIoKSxcbiAgICAgICAgICAgIHQgPSB0aGlzLnVzZXJPcHRpb25zO1xuXG4gICAgICAgIGlmIChoKSB7XG4gICAgICAgICAgaWYgKGcpIHtcbiAgICAgICAgICAgIHZhciBlID0gdFtnXSB8fCBbXTtcbiAgICAgICAgICAgIGUucHVzaChkKTtcbiAgICAgICAgICAgIHRbZ10gPSBlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucGxvdExpbmVzQW5kQmFuZHMucHVzaChoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZVBsb3RCYW5kT3JMaW5lOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICBmb3IgKHZhciBoID0gdGhpcy5wbG90TGluZXNBbmRCYW5kcywgcSA9IHRoaXMub3B0aW9ucywgZyA9IHRoaXMudXNlck9wdGlvbnMsIGUgPSBoLmxlbmd0aDsgZS0tOykgaFtlXS5pZCA9PT0gZCAmJiBoW2VdLmRlc3Ryb3koKTtcblxuICAgICAgICBbcS5wbG90TGluZXMgfHwgW10sIGcucGxvdExpbmVzIHx8IFtdLCBxLnBsb3RCYW5kcyB8fCBbXSwgZy5wbG90QmFuZHMgfHwgW11dLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBmb3IgKGUgPSBjLmxlbmd0aDsgZS0tOykgY1tlXS5pZCA9PT0gZCAmJiBBKGMsIGNbZV0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVQbG90QmFuZDogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVQbG90QmFuZE9yTGluZShkKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVQbG90TGluZTogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVQbG90QmFuZE9yTGluZShkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkLlBsb3RMaW5lT3JCYW5kID0gRDtcbiAgICByZXR1cm4gZC5QbG90TGluZU9yQmFuZDtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9Ub29sdGlwLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgdmFyIHIgPSBnLmNsYW1wLFxuICAgICAgICB1ID0gZy5jc3MsXG4gICAgICAgIEkgPSBnLmRlZmluZWQsXG4gICAgICAgIE0gPSBnLmRpc2NhcmRFbGVtZW50LFxuICAgICAgICBFID0gZy5leHRlbmQsXG4gICAgICAgIEEgPSBnLmZvcm1hdCxcbiAgICAgICAgRyA9IGcuaXNOdW1iZXIsXG4gICAgICAgIEogPSBnLmlzU3RyaW5nLFxuICAgICAgICB5ID0gZy5tZXJnZSxcbiAgICAgICAgdCA9IGcucGljayxcbiAgICAgICAgRCA9IGcuc3BsYXQsXG4gICAgICAgIGggPSBnLnN5bmNUaW1lb3V0LFxuICAgICAgICBOID0gZy50aW1lVW5pdHM7XG4gICAgXCJcIjtcblxuICAgIHZhciBxID0gZC5kb2MsXG4gICAgICAgIFAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBlKGMsIGUpIHtcbiAgICAgICAgdGhpcy5jcm9zc2hhaXJzID0gW107XG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLmlzSGlkZGVuID0gITA7XG4gICAgICAgIHRoaXMuaXNTdGlja3kgPSAhMTtcbiAgICAgICAgdGhpcy5ub3cgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIHRoaXMub3V0c2lkZSA9ICExO1xuICAgICAgICB0aGlzLmNoYXJ0ID0gYztcbiAgICAgICAgdGhpcy5pbml0KGMsIGUpO1xuICAgICAgfVxuXG4gICAgICBlLnByb3RvdHlwZS5hcHBseUZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNoYXJ0O1xuICAgICAgICBjLnJlbmRlcmVyLmRlZmluaXRpb24oe1xuICAgICAgICAgIHRhZ05hbWU6IFwiZmlsdGVyXCIsXG4gICAgICAgICAgaWQ6IFwiZHJvcC1zaGFkb3ctXCIgKyBjLmluZGV4LFxuICAgICAgICAgIG9wYWNpdHk6IC41LFxuICAgICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgICAgdGFnTmFtZTogXCJmZUdhdXNzaWFuQmx1clwiLFxuICAgICAgICAgICAgXCJpblwiOiBcIlNvdXJjZUFscGhhXCIsXG4gICAgICAgICAgICBzdGREZXZpYXRpb246IDFcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB0YWdOYW1lOiBcImZlT2Zmc2V0XCIsXG4gICAgICAgICAgICBkeDogMSxcbiAgICAgICAgICAgIGR5OiAxXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgdGFnTmFtZTogXCJmZUNvbXBvbmVudFRyYW5zZmVyXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICAgICAgdGFnTmFtZTogXCJmZUZ1bmNBXCIsXG4gICAgICAgICAgICAgIHR5cGU6IFwibGluZWFyXCIsXG4gICAgICAgICAgICAgIHNsb3BlOiAuM1xuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB0YWdOYW1lOiBcImZlTWVyZ2VcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgICAgICB0YWdOYW1lOiBcImZlTWVyZ2VOb2RlXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgdGFnTmFtZTogXCJmZU1lcmdlTm9kZVwiLFxuICAgICAgICAgICAgICBcImluXCI6IFwiU291cmNlR3JhcGhpY1wiXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH1dXG4gICAgICAgIH0pO1xuICAgICAgICBjLnJlbmRlcmVyLmRlZmluaXRpb24oe1xuICAgICAgICAgIHRhZ05hbWU6IFwic3R5bGVcIixcbiAgICAgICAgICB0ZXh0Q29udGVudDogXCIuaGlnaGNoYXJ0cy10b29sdGlwLVwiICsgYy5pbmRleCArIFwie2ZpbHRlcjp1cmwoI2Ryb3Atc2hhZG93LVwiICsgYy5pbmRleCArIFwiKX1cIlxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLmJvZHlGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICB2YXIgZSA9IGMuc2VyaWVzLnRvb2x0aXBPcHRpb25zO1xuICAgICAgICAgIHJldHVybiAoZVsoYy5wb2ludC5mb3JtYXRQcmVmaXggfHwgXCJwb2ludFwiKSArIFwiRm9ybWF0dGVyXCJdIHx8IGMucG9pbnQudG9vbHRpcEZvcm1hdHRlcikuY2FsbChjLnBvaW50LCBlWyhjLnBvaW50LmZvcm1hdFByZWZpeCB8fCBcInBvaW50XCIpICsgXCJGb3JtYXRcIl0gfHwgXCJcIik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUuY2xlYW5TcGxpdCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHRoaXMuY2hhcnQuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgZCA9IGUgJiYgZS50dDtcbiAgICAgICAgICBkICYmICghZC5pc0FjdGl2ZSB8fCBjID8gZS50dCA9IGQuZGVzdHJveSgpIDogZC5pc0FjdGl2ZSA9ICExKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS5kZWZhdWx0Rm9ybWF0dGVyID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLnBvaW50cyB8fCBEKHRoaXMpO1xuICAgICAgICB2YXIgZCA9IFtjLnRvb2x0aXBGb290ZXJIZWFkZXJGb3JtYXR0ZXIoZVswXSldO1xuICAgICAgICBkID0gZC5jb25jYXQoYy5ib2R5Rm9ybWF0dGVyKGUpKTtcbiAgICAgICAgZC5wdXNoKGMudG9vbHRpcEZvb3RlckhlYWRlckZvcm1hdHRlcihlWzBdLCAhMCkpO1xuICAgICAgICByZXR1cm4gZDtcbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGFiZWwgJiYgKHRoaXMubGFiZWwgPSB0aGlzLmxhYmVsLmRlc3Ryb3koKSk7XG4gICAgICAgIHRoaXMuc3BsaXQgJiYgdGhpcy50dCAmJiAodGhpcy5jbGVhblNwbGl0KHRoaXMuY2hhcnQsICEwKSwgdGhpcy50dCA9IHRoaXMudHQuZGVzdHJveSgpKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciAmJiAodGhpcy5yZW5kZXJlciA9IHRoaXMucmVuZGVyZXIuZGVzdHJveSgpLCBNKHRoaXMuY29udGFpbmVyKSk7XG4gICAgICAgIGcuY2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVyKTtcbiAgICAgICAgZy5jbGVhclRpbWVvdXQodGhpcy50b29sdGlwVGltZW91dCk7XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS5nZXRBbmNob3IgPSBmdW5jdGlvbiAoYywgZSkge1xuICAgICAgICB2YXIgZCA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBmID0gZC5wb2ludGVyLFxuICAgICAgICAgICAgYSA9IGQuaW52ZXJ0ZWQsXG4gICAgICAgICAgICBsID0gZC5wbG90VG9wLFxuICAgICAgICAgICAgayA9IGQucGxvdExlZnQsXG4gICAgICAgICAgICBoID0gMCxcbiAgICAgICAgICAgIHcgPSAwLFxuICAgICAgICAgICAgQixcbiAgICAgICAgICAgIHE7XG4gICAgICAgIGMgPSBEKGMpO1xuICAgICAgICB0aGlzLmZvbGxvd1BvaW50ZXIgJiYgZSA/IChcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgZS5jaGFydFggJiYgKGUgPSBmLm5vcm1hbGl6ZShlKSksIGMgPSBbZS5jaGFydFggLSBrLCBlLmNoYXJ0WSAtIGxdKSA6IGNbMF0udG9vbHRpcFBvcyA/IGMgPSBjWzBdLnRvb2x0aXBQb3MgOiAoYy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgQiA9IGMuc2VyaWVzLnlBeGlzO1xuICAgICAgICAgIHEgPSBjLnNlcmllcy54QXhpcztcbiAgICAgICAgICBoICs9IGMucGxvdFggKyAoIWEgJiYgcSA/IHEubGVmdCAtIGsgOiAwKTtcbiAgICAgICAgICB3ICs9IChjLnBsb3RMb3cgPyAoYy5wbG90TG93ICsgYy5wbG90SGlnaCkgLyAyIDogYy5wbG90WSkgKyAoIWEgJiYgQiA/IEIudG9wIC0gbCA6IDApO1xuICAgICAgICB9KSwgaCAvPSBjLmxlbmd0aCwgdyAvPSBjLmxlbmd0aCwgYyA9IFthID8gZC5wbG90V2lkdGggLSB3IDogaCwgdGhpcy5zaGFyZWQgJiYgIWEgJiYgMSA8IGMubGVuZ3RoICYmIGUgPyBlLmNoYXJ0WSAtIGwgOiBhID8gZC5wbG90SGVpZ2h0IC0gaCA6IHddKTtcbiAgICAgICAgcmV0dXJuIGMubWFwKE1hdGgucm91bmQpO1xuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUuZ2V0RGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIChjLCBlLCBkLCBmKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jaGFydC50aW1lLFxuICAgICAgICAgICAgbCA9IGEuZGF0ZUZvcm1hdChcIiVtLSVkICVIOiVNOiVTLiVMXCIsIGUpLFxuICAgICAgICAgICAgayA9IHtcbiAgICAgICAgICBtaWxsaXNlY29uZDogMTUsXG4gICAgICAgICAgc2Vjb25kOiAxMixcbiAgICAgICAgICBtaW51dGU6IDksXG4gICAgICAgICAgaG91cjogNixcbiAgICAgICAgICBkYXk6IDNcbiAgICAgICAgfSxcbiAgICAgICAgICAgIG4gPSBcIm1pbGxpc2Vjb25kXCI7XG5cbiAgICAgICAgZm9yICh3IGluIE4pIHtcbiAgICAgICAgICBpZiAoYyA9PT0gTi53ZWVrICYmICthLmRhdGVGb3JtYXQoXCIld1wiLCBlKSA9PT0gZCAmJiBcIjAwOjAwOjAwLjAwMFwiID09PSBsLnN1YnN0cig2KSkge1xuICAgICAgICAgICAgdmFyIHcgPSBcIndlZWtcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChOW3ddID4gYykge1xuICAgICAgICAgICAgdyA9IG47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoa1t3XSAmJiBsLnN1YnN0cihrW3ddKSAhPT0gXCIwMS0wMSAwMDowMDowMC4wMDBcIi5zdWJzdHIoa1t3XSkpIGJyZWFrO1xuICAgICAgICAgIFwid2Vla1wiICE9PSB3ICYmIChuID0gdyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodykgdmFyIGggPSBhLnJlc29sdmVEVExGb3JtYXQoZlt3XSkubWFpbjtcbiAgICAgICAgcmV0dXJuIGg7XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS5nZXRMYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGMsXG4gICAgICAgICAgICBlID0gdGhpcyxcbiAgICAgICAgICAgIG4gPSB0aGlzLmNoYXJ0LnJlbmRlcmVyLFxuICAgICAgICAgICAgZiA9IHRoaXMuY2hhcnQuc3R5bGVkTW9kZSxcbiAgICAgICAgICAgIGEgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBsID0gXCJ0b29sdGlwXCIgKyAoSShhLmNsYXNzTmFtZSkgPyBcIiBcIiArIGEuY2xhc3NOYW1lIDogXCJcIiksXG4gICAgICAgICAgICB2ID0gKG51bGwgPT09IChjID0gYS5zdHlsZSkgfHwgdm9pZCAwID09PSBjID8gdm9pZCAwIDogYy5wb2ludGVyRXZlbnRzKSB8fCAoIXRoaXMuZm9sbG93UG9pbnRlciAmJiBhLnN0aWNrT25Db250YWN0ID8gXCJhdXRvXCIgOiBcIm5vbmVcIiksXG4gICAgICAgICAgICBoO1xuXG4gICAgICAgIGMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZS5pbkNvbnRhY3QgPSAhMDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYSA9IGUuY2hhcnQuaG92ZXJTZXJpZXM7XG4gICAgICAgICAgZS5pbkNvbnRhY3QgPSAhMTtcbiAgICAgICAgICBpZiAoYSAmJiBhLm9uTW91c2VPdXQpIGEub25Nb3VzZU91dCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghdGhpcy5sYWJlbCkge1xuICAgICAgICAgIHRoaXMub3V0c2lkZSAmJiAodGhpcy5jb250YWluZXIgPSBoID0gZC5kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgaC5jbGFzc05hbWUgPSBcImhpZ2hjaGFydHMtdG9vbHRpcC1jb250YWluZXJcIiwgdShoLCB7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgdG9wOiBcIjFweFwiLFxuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogdixcbiAgICAgICAgICAgIHpJbmRleDogM1xuICAgICAgICAgIH0pLCBkLmRvYy5ib2R5LmFwcGVuZENoaWxkKGgpLCB0aGlzLnJlbmRlcmVyID0gbiA9IG5ldyBkLlJlbmRlcmVyKGgsIDAsIDAsIHt9LCB2b2lkIDAsIHZvaWQgMCwgbi5zdHlsZWRNb2RlKSk7XG4gICAgICAgICAgdGhpcy5zcGxpdCA/IHRoaXMubGFiZWwgPSBuLmcobCkgOiAodGhpcy5sYWJlbCA9IG4ubGFiZWwoXCJcIiwgMCwgMCwgYS5zaGFwZSB8fCBcImNhbGxvdXRcIiwgbnVsbCwgbnVsbCwgYS51c2VIVE1MLCBudWxsLCBsKS5hdHRyKHtcbiAgICAgICAgICAgIHBhZGRpbmc6IGEucGFkZGluZyxcbiAgICAgICAgICAgIHI6IGEuYm9yZGVyUmFkaXVzXG4gICAgICAgICAgfSksIGYgfHwgdGhpcy5sYWJlbC5hdHRyKHtcbiAgICAgICAgICAgIGZpbGw6IGEuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogYS5ib3JkZXJXaWR0aFxuICAgICAgICAgIH0pLmNzcyhhLnN0eWxlKS5jc3Moe1xuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogdlxuICAgICAgICAgIH0pLnNoYWRvdyhhLnNoYWRvdykpO1xuICAgICAgICAgIGYgJiYgKHRoaXMuYXBwbHlGaWx0ZXIoKSwgdGhpcy5sYWJlbC5hZGRDbGFzcyhcImhpZ2hjaGFydHMtdG9vbHRpcC1cIiArIHRoaXMuY2hhcnQuaW5kZXgpKTtcblxuICAgICAgICAgIGlmIChlLm91dHNpZGUgJiYgIWUuc3BsaXQpIHtcbiAgICAgICAgICAgIHZhciBCID0ge1xuICAgICAgICAgICAgICB4OiB0aGlzLmxhYmVsLnhTZXR0ZXIsXG4gICAgICAgICAgICAgIHk6IHRoaXMubGFiZWwueVNldHRlclxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5sYWJlbC54U2V0dGVyID0gZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgICAgICAgQltjXS5jYWxsKHRoaXMubGFiZWwsIGUuZGlzdGFuY2UpO1xuICAgICAgICAgICAgICBoLnN0eWxlLmxlZnQgPSBhICsgXCJweFwiO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5sYWJlbC55U2V0dGVyID0gZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgICAgICAgQltjXS5jYWxsKHRoaXMubGFiZWwsIGUuZGlzdGFuY2UpO1xuICAgICAgICAgICAgICBoLnN0eWxlLnRvcCA9IGEgKyBcInB4XCI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubGFiZWwub24oXCJtb3VzZWVudGVyXCIsIGMpLm9uKFwibW91c2VsZWF2ZVwiLCB3KS5hdHRyKHtcbiAgICAgICAgICAgIHpJbmRleDogOFxuICAgICAgICAgIH0pLmFkZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWw7XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChjLCBlLCBkKSB7XG4gICAgICAgIHZhciBmID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGEgPSB0aGlzLmRpc3RhbmNlLFxuICAgICAgICAgICAgbCA9IHt9LFxuICAgICAgICAgICAgayA9IGYuaW52ZXJ0ZWQgJiYgZC5oIHx8IDAsXG4gICAgICAgICAgICBuLFxuICAgICAgICAgICAgdyA9IHRoaXMub3V0c2lkZSxcbiAgICAgICAgICAgIGggPSB3ID8gcS5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggLSAyICogYSA6IGYuY2hhcnRXaWR0aCxcbiAgICAgICAgICAgIGcgPSB3ID8gTWF0aC5tYXgocS5ib2R5LnNjcm9sbEhlaWdodCwgcS5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0LCBxLmJvZHkub2Zmc2V0SGVpZ2h0LCBxLmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQsIHEuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkgOiBmLmNoYXJ0SGVpZ2h0LFxuICAgICAgICAgICAgUSA9IGYucG9pbnRlci5nZXRDaGFydFBvc2l0aW9uKCksXG4gICAgICAgICAgICBIID0gZi5jb250YWluZXJTY2FsaW5nLFxuICAgICAgICAgICAgSyA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgcmV0dXJuIEggPyBiICogSC5zY2FsZVggOiBiO1xuICAgICAgICB9LFxuICAgICAgICAgICAgcCA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgcmV0dXJuIEggPyBiICogSC5zY2FsZVkgOiBiO1xuICAgICAgICB9LFxuICAgICAgICAgICAgYiA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgdmFyIGwgPSBcInhcIiA9PT0gYjtcbiAgICAgICAgICByZXR1cm4gW2IsIGwgPyBoIDogZywgbCA/IGMgOiBlXS5jb25jYXQodyA/IFtsID8gSyhjKSA6IHAoZSksIGwgPyBRLmxlZnQgLSBhICsgSyhkLnBsb3RYICsgZi5wbG90TGVmdCkgOiBRLnRvcCAtIGEgKyBwKGQucGxvdFkgKyBmLnBsb3RUb3ApLCAwLCBsID8gaCA6IGddIDogW2wgPyBjIDogZSwgbCA/IGQucGxvdFggKyBmLnBsb3RMZWZ0IDogZC5wbG90WSArIGYucGxvdFRvcCwgbCA/IGYucGxvdExlZnQgOiBmLnBsb3RUb3AsIGwgPyBmLnBsb3RMZWZ0ICsgZi5wbG90V2lkdGggOiBmLnBsb3RUb3AgKyBmLnBsb3RIZWlnaHRdKTtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIEMgPSBiKFwieVwiKSxcbiAgICAgICAgICAgIHggPSBiKFwieFwiKSxcbiAgICAgICAgICAgIFIgPSAhdGhpcy5mb2xsb3dQb2ludGVyICYmIHQoZC50dEJlbG93LCAhZi5pbnZlcnRlZCA9PT0gISFkLm5lZ2F0aXZlKSxcbiAgICAgICAgICAgIE8gPSBmdW5jdGlvbiAoYiwgYywgZiwgZSwgZCwgbSwgdikge1xuICAgICAgICAgIHZhciBuID0gXCJ5XCIgPT09IGIgPyBwKGEpIDogSyhhKSxcbiAgICAgICAgICAgICAgdyA9IChmIC0gZSkgLyAyLFxuICAgICAgICAgICAgICB4ID0gZSA8IGQgLSBhLFxuICAgICAgICAgICAgICBoID0gZCArIGEgKyBlIDwgYyxcbiAgICAgICAgICAgICAgRiA9IGQgLSBuIC0gZiArIHc7XG4gICAgICAgICAgZCA9IGQgKyBuIC0gdztcbiAgICAgICAgICBpZiAoUiAmJiBoKSBsW2JdID0gZDtlbHNlIGlmICghUiAmJiB4KSBsW2JdID0gRjtlbHNlIGlmICh4KSBsW2JdID0gTWF0aC5taW4odiAtIGUsIDAgPiBGIC0gayA/IEYgOiBGIC0gayk7ZWxzZSBpZiAoaCkgbFtiXSA9IE1hdGgubWF4KG0sIGQgKyBrICsgZiA+IGMgPyBkIDogZCArIGspO2Vsc2UgcmV0dXJuICExO1xuICAgICAgICB9LFxuICAgICAgICAgICAgeSA9IGZ1bmN0aW9uIChiLCBjLCBmLCBlLCBkKSB7XG4gICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgZCA8IGEgfHwgZCA+IGMgLSBhID8gayA9ICExIDogbFtiXSA9IGQgPCBmIC8gMiA/IDEgOiBkID4gYyAtIGUgLyAyID8gYyAtIGUgLSAyIDogZCAtIGYgLyAyO1xuICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICB9LFxuICAgICAgICAgICAgdSA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgdmFyIGEgPSBDO1xuICAgICAgICAgIEMgPSB4O1xuICAgICAgICAgIHggPSBhO1xuICAgICAgICAgIG4gPSBiO1xuICAgICAgICB9LFxuICAgICAgICAgICAgbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAhMSAhPT0gTy5hcHBseSgwLCBDKSA/ICExICE9PSB5LmFwcGx5KDAsIHgpIHx8IG4gfHwgKHUoITApLCBtKCkpIDogbiA/IGwueCA9IGwueSA9IDAgOiAodSghMCksIG0oKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgKGYuaW52ZXJ0ZWQgfHwgMSA8IHRoaXMubGVuKSAmJiB1KCk7XG4gICAgICAgIG0oKTtcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS5nZXRYRGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIChjLCBlLCBkKSB7XG4gICAgICAgIGUgPSBlLmRhdGVUaW1lTGFiZWxGb3JtYXRzO1xuICAgICAgICB2YXIgZiA9IGQgJiYgZC5jbG9zZXN0UG9pbnRSYW5nZTtcbiAgICAgICAgcmV0dXJuIChmID8gdGhpcy5nZXREYXRlRm9ybWF0KGYsIGMueCwgZC5vcHRpb25zLnN0YXJ0T2ZXZWVrLCBlKSA6IGUuZGF5KSB8fCBlLnllYXI7XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzO1xuICAgICAgICBnLmNsZWFyVGltZW91dCh0aGlzLmhpZGVUaW1lcik7XG4gICAgICAgIGMgPSB0KGMsIHRoaXMub3B0aW9ucy5oaWRlRGVsYXksIDUwMCk7XG4gICAgICAgIHRoaXMuaXNIaWRkZW4gfHwgKHRoaXMuaGlkZVRpbWVyID0gaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZS5nZXRMYWJlbCgpW2MgPyBcImZhZGVPdXRcIiA6IFwiaGlkZVwiXSgpO1xuICAgICAgICAgIGUuaXNIaWRkZW4gPSAhMDtcbiAgICAgICAgfSwgYykpO1xuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChjLCBlKSB7XG4gICAgICAgIHRoaXMuY2hhcnQgPSBjO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBlO1xuICAgICAgICB0aGlzLmNyb3NzaGFpcnMgPSBbXTtcbiAgICAgICAgdGhpcy5ub3cgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNIaWRkZW4gPSAhMDtcbiAgICAgICAgdGhpcy5zcGxpdCA9IGUuc3BsaXQgJiYgIWMuaW52ZXJ0ZWQgJiYgIWMucG9sYXI7XG4gICAgICAgIHRoaXMuc2hhcmVkID0gZS5zaGFyZWQgfHwgdGhpcy5zcGxpdDtcbiAgICAgICAgdGhpcy5vdXRzaWRlID0gdChlLm91dHNpZGUsICEoIWMuc2Nyb2xsYWJsZVBpeGVsc1ggJiYgIWMuc2Nyb2xsYWJsZVBpeGVsc1kpKTtcbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLmlzU3RpY2t5T25Db250YWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISh0aGlzLmZvbGxvd1BvaW50ZXIgfHwgIXRoaXMub3B0aW9ucy5zdGlja09uQ29udGFjdCB8fCAhdGhpcy5pbkNvbnRhY3QpO1xuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uIChjLCBlLCBkLCBmKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIGwgPSBhLm5vdyxcbiAgICAgICAgICAgIGsgPSAhMSAhPT0gYS5vcHRpb25zLmFuaW1hdGlvbiAmJiAhYS5pc0hpZGRlbiAmJiAoMSA8IE1hdGguYWJzKGMgLSBsLngpIHx8IDEgPCBNYXRoLmFicyhlIC0gbC55KSksXG4gICAgICAgICAgICBuID0gYS5mb2xsb3dQb2ludGVyIHx8IDEgPCBhLmxlbjtcbiAgICAgICAgRShsLCB7XG4gICAgICAgICAgeDogayA/ICgyICogbC54ICsgYykgLyAzIDogYyxcbiAgICAgICAgICB5OiBrID8gKGwueSArIGUpIC8gMiA6IGUsXG4gICAgICAgICAgYW5jaG9yWDogbiA/IHZvaWQgMCA6IGsgPyAoMiAqIGwuYW5jaG9yWCArIGQpIC8gMyA6IGQsXG4gICAgICAgICAgYW5jaG9yWTogbiA/IHZvaWQgMCA6IGsgPyAobC5hbmNob3JZICsgZikgLyAyIDogZlxuICAgICAgICB9KTtcbiAgICAgICAgYS5nZXRMYWJlbCgpLmF0dHIobCk7XG4gICAgICAgIGEuZHJhd1RyYWNrZXIoKTtcbiAgICAgICAgayAmJiAoZy5jbGVhclRpbWVvdXQodGhpcy50b29sdGlwVGltZW91dCksIHRoaXMudG9vbHRpcFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhICYmIGEubW92ZShjLCBlLCBkLCBmKTtcbiAgICAgICAgfSwgMzIpKTtcbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoYywgZSkge1xuICAgICAgICB2YXIgayA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBmID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgYSA9IGMsXG4gICAgICAgICAgICBsID0ge30sXG4gICAgICAgICAgICB2ID0gW10sXG4gICAgICAgICAgICBoID0gZi5mb3JtYXR0ZXIgfHwgdGhpcy5kZWZhdWx0Rm9ybWF0dGVyO1xuICAgICAgICBsID0gdGhpcy5zaGFyZWQ7XG4gICAgICAgIHZhciB3ID0gay5zdHlsZWRNb2RlO1xuXG4gICAgICAgIGlmIChmLmVuYWJsZWQpIHtcbiAgICAgICAgICBnLmNsZWFyVGltZW91dCh0aGlzLmhpZGVUaW1lcik7XG4gICAgICAgICAgdGhpcy5mb2xsb3dQb2ludGVyID0gRChhKVswXS5zZXJpZXMudG9vbHRpcE9wdGlvbnMuZm9sbG93UG9pbnRlcjtcbiAgICAgICAgICB2YXIgQiA9IHRoaXMuZ2V0QW5jaG9yKGEsIGUpO1xuICAgICAgICAgIGUgPSBCWzBdO1xuICAgICAgICAgIHZhciBxID0gQlsxXTtcbiAgICAgICAgICAhbCB8fCBhLnNlcmllcyAmJiBhLnNlcmllcy5ub1NoYXJlZFRvb2x0aXAgPyBsID0gYS5nZXRMYWJlbENvbmZpZygpIDogKGsucG9pbnRlci5hcHBseUluYWN0aXZlU3RhdGUoYSksIGEuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYS5zZXRTdGF0ZShcImhvdmVyXCIpO1xuICAgICAgICAgICAgdi5wdXNoKGEuZ2V0TGFiZWxDb25maWcoKSk7XG4gICAgICAgICAgfSksIGwgPSB7XG4gICAgICAgICAgICB4OiBhWzBdLmNhdGVnb3J5LFxuICAgICAgICAgICAgeTogYVswXS55XG4gICAgICAgICAgfSwgbC5wb2ludHMgPSB2LCBhID0gYVswXSk7XG4gICAgICAgICAgdGhpcy5sZW4gPSB2Lmxlbmd0aDtcbiAgICAgICAgICBrID0gaC5jYWxsKGwsIHRoaXMpO1xuICAgICAgICAgIGggPSBhLnNlcmllcztcbiAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gdChoLnRvb2x0aXBPcHRpb25zLmRpc3RhbmNlLCAxNik7XG4gICAgICAgICAgITEgPT09IGsgPyB0aGlzLmhpZGUoKSA6ICh0aGlzLnNwbGl0ID8gdGhpcy5yZW5kZXJTcGxpdChrLCBEKGMpKSA6IChjID0gdGhpcy5nZXRMYWJlbCgpLCBmLnN0eWxlLndpZHRoICYmICF3IHx8IGMuY3NzKHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLmNoYXJ0LnNwYWNpbmdCb3gud2lkdGhcbiAgICAgICAgICB9KSwgYy5hdHRyKHtcbiAgICAgICAgICAgIHRleHQ6IGsgJiYgay5qb2luID8gay5qb2luKFwiXCIpIDoga1xuICAgICAgICAgIH0pLCBjLnJlbW92ZUNsYXNzKC9oaWdoY2hhcnRzLWNvbG9yLVtcXGRdKy9nKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtY29sb3ItXCIgKyB0KGEuY29sb3JJbmRleCwgaC5jb2xvckluZGV4KSksIHcgfHwgYy5hdHRyKHtcbiAgICAgICAgICAgIHN0cm9rZTogZi5ib3JkZXJDb2xvciB8fCBhLmNvbG9yIHx8IGguY29sb3IgfHwgXCIjNjY2NjY2XCJcbiAgICAgICAgICB9KSwgdGhpcy51cGRhdGVQb3NpdGlvbih7XG4gICAgICAgICAgICBwbG90WDogZSxcbiAgICAgICAgICAgIHBsb3RZOiBxLFxuICAgICAgICAgICAgbmVnYXRpdmU6IGEubmVnYXRpdmUsXG4gICAgICAgICAgICB0dEJlbG93OiBhLnR0QmVsb3csXG4gICAgICAgICAgICBoOiBCWzJdIHx8IDBcbiAgICAgICAgICB9KSksIHRoaXMuaXNIaWRkZW4gJiYgdGhpcy5sYWJlbCAmJiB0aGlzLmxhYmVsLmF0dHIoe1xuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0pLnNob3coKSwgdGhpcy5pc0hpZGRlbiA9ICExKTtcbiAgICAgICAgICBkLmZpcmVFdmVudCh0aGlzLCBcInJlZnJlc2hcIik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLnJlbmRlclNwbGl0ID0gZnVuY3Rpb24gKGMsIGUpIHtcbiAgICAgICAgZnVuY3Rpb24gayhiLCBhLCBjLCBmLCBlKSB7XG4gICAgICAgICAgdm9pZCAwID09PSBlICYmIChlID0gITApO1xuICAgICAgICAgIGMgPyAoYSA9IHUgPyAwIDogQSwgYiA9IHIoYiAtIGYgLyAyLCBPLmxlZnQsIE8ucmlnaHQgLSBmKSkgOiAoYSAtPSBtLCBiID0gZSA/IGIgLSBmIC0gQyA6IGIgKyBDLCBiID0gcihiLCBlID8gYiA6IE8ubGVmdCwgTy5yaWdodCkpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBiLFxuICAgICAgICAgICAgeTogYVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZiA9IHRoaXMsXG4gICAgICAgICAgICBhID0gZi5jaGFydCxcbiAgICAgICAgICAgIGwgPSBmLmNoYXJ0LFxuICAgICAgICAgICAgdiA9IGwucGxvdEhlaWdodCxcbiAgICAgICAgICAgIGggPSBsLnBsb3RMZWZ0LFxuICAgICAgICAgICAgdyA9IGwucGxvdFRvcCxcbiAgICAgICAgICAgIEIgPSBsLnBvaW50ZXIsXG4gICAgICAgICAgICBxID0gbC5yZW5kZXJlcixcbiAgICAgICAgICAgIGcgPSBsLnNjcm9sbGFibGVQaXhlbHNZLFxuICAgICAgICAgICAgSCA9IHZvaWQgMCA9PT0gZyA/IDAgOiBnO1xuICAgICAgICBnID0gbC5zY3JvbGxpbmdDb250YWluZXI7XG4gICAgICAgIGcgPSB2b2lkIDAgPT09IGcgPyB7XG4gICAgICAgICAgc2Nyb2xsTGVmdDogMCxcbiAgICAgICAgICBzY3JvbGxUb3A6IDBcbiAgICAgICAgfSA6IGc7XG4gICAgICAgIHZhciBLID0gZy5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgcCA9IGcuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgYiA9IGwuc3R5bGVkTW9kZSxcbiAgICAgICAgICAgIEMgPSBmLmRpc3RhbmNlLFxuICAgICAgICAgICAgeCA9IGYub3B0aW9ucyxcbiAgICAgICAgICAgIFIgPSBmLm9wdGlvbnMucG9zaXRpb25lcixcbiAgICAgICAgICAgIE8gPSB7XG4gICAgICAgICAgbGVmdDogSyxcbiAgICAgICAgICByaWdodDogSyArIGwuY2hhcnRXaWR0aCxcbiAgICAgICAgICB0b3A6IHAsXG4gICAgICAgICAgYm90dG9tOiBwICsgbC5jaGFydEhlaWdodFxuICAgICAgICB9LFxuICAgICAgICAgICAgeSA9IGYuZ2V0TGFiZWwoKSxcbiAgICAgICAgICAgIHUgPSAhKCFhLnhBeGlzWzBdIHx8ICFhLnhBeGlzWzBdLm9wcG9zaXRlKSxcbiAgICAgICAgICAgIG0gPSB3ICsgcCxcbiAgICAgICAgICAgIEQgPSAwLFxuICAgICAgICAgICAgQSA9IHYgLSBIO1xuICAgICAgICBKKGMpICYmIChjID0gWyExLCBjXSk7XG4gICAgICAgIGMgPSBjLnNsaWNlKDAsIGUubGVuZ3RoICsgMSkucmVkdWNlKGZ1bmN0aW9uIChhLCBjLCBsKSB7XG4gICAgICAgICAgaWYgKCExICE9PSBjICYmIFwiXCIgIT09IGMpIHtcbiAgICAgICAgICAgIGwgPSBlW2wgLSAxXSB8fCB7XG4gICAgICAgICAgICAgIGlzSGVhZGVyOiAhMCxcbiAgICAgICAgICAgICAgcGxvdFg6IGVbMF0ucGxvdFgsXG4gICAgICAgICAgICAgIHBsb3RZOiB2LFxuICAgICAgICAgICAgICBzZXJpZXM6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGQgPSBsLmlzSGVhZGVyLFxuICAgICAgICAgICAgICAgIG4gPSBkID8gZiA6IGwuc2VyaWVzLFxuICAgICAgICAgICAgICAgIEYgPSBuLnR0LFxuICAgICAgICAgICAgICAgIHogPSBsLmlzSGVhZGVyO1xuICAgICAgICAgICAgdmFyIEIgPSBsLnNlcmllcztcbiAgICAgICAgICAgIHZhciBnID0gXCJoaWdoY2hhcnRzLWNvbG9yLVwiICsgdChsLmNvbG9ySW5kZXgsIEIuY29sb3JJbmRleCwgXCJub25lXCIpO1xuICAgICAgICAgICAgRiB8fCAoRiA9IHtcbiAgICAgICAgICAgICAgcGFkZGluZzogeC5wYWRkaW5nLFxuICAgICAgICAgICAgICByOiB4LmJvcmRlclJhZGl1c1xuICAgICAgICAgICAgfSwgYiB8fCAoRi5maWxsID0geC5iYWNrZ3JvdW5kQ29sb3IsIEZbXCJzdHJva2Utd2lkdGhcIl0gPSB4LmJvcmRlcldpZHRoKSwgRiA9IHEubGFiZWwoXCJcIiwgMCwgMCwgeFt6ID8gXCJoZWFkZXJTaGFwZVwiIDogXCJzaGFwZVwiXSB8fCBcImNhbGxvdXRcIiwgdm9pZCAwLCB2b2lkIDAsIHgudXNlSFRNTCkuYWRkQ2xhc3MoKHogPyBcImhpZ2hjaGFydHMtdG9vbHRpcC1oZWFkZXIgXCIgOiBcIlwiKSArIFwiaGlnaGNoYXJ0cy10b29sdGlwLWJveCBcIiArIGcpLmF0dHIoRikuYWRkKHkpKTtcbiAgICAgICAgICAgIEYuaXNBY3RpdmUgPSAhMDtcbiAgICAgICAgICAgIEYuYXR0cih7XG4gICAgICAgICAgICAgIHRleHQ6IGNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYiB8fCBGLmNzcyh4LnN0eWxlKS5zaGFkb3coeC5zaGFkb3cpLmF0dHIoe1xuICAgICAgICAgICAgICBzdHJva2U6IHguYm9yZGVyQ29sb3IgfHwgbC5jb2xvciB8fCBCLmNvbG9yIHx8IFwiIzMzMzMzM1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGMgPSBuLnR0ID0gRjtcbiAgICAgICAgICAgIHogPSBjLmdldEJCb3goKTtcbiAgICAgICAgICAgIG4gPSB6LndpZHRoICsgYy5zdHJva2VXaWR0aCgpO1xuICAgICAgICAgICAgZCAmJiAoRCA9IHouaGVpZ2h0LCBBICs9IEQsIHUgJiYgKG0gLT0gRCkpO1xuICAgICAgICAgICAgQiA9IGwucGxvdFg7XG4gICAgICAgICAgICBCID0gdm9pZCAwID09PSBCID8gMCA6IEI7XG4gICAgICAgICAgICBnID0gbC5wbG90WTtcbiAgICAgICAgICAgIGcgPSB2b2lkIDAgPT09IGcgPyAwIDogZztcbiAgICAgICAgICAgIHZhciBMID0gbC5zZXJpZXM7XG5cbiAgICAgICAgICAgIGlmIChsLmlzSGVhZGVyKSB7XG4gICAgICAgICAgICAgIEIgPSBoICsgQjtcbiAgICAgICAgICAgICAgdmFyIEsgPSB3ICsgdiAvIDI7XG4gICAgICAgICAgICB9IGVsc2UgRiA9IEwueEF4aXMsIEwgPSBMLnlBeGlzLCBCID0gRi5wb3MgKyByKEIsIC1DLCBGLmxlbiArIEMpLCBMLnBvcyArIGcgPj0gcCArIHcgJiYgTC5wb3MgKyBnIDw9IHAgKyB3ICsgdiAtIEggJiYgKEsgPSBMLnBvcyArIGcpO1xuXG4gICAgICAgICAgICBCID0gcihCLCBPLmxlZnQgLSBDLCBPLnJpZ2h0ICsgQyk7XG4gICAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgSyA/ICh6ID0gei5oZWlnaHQgKyAxLCBnID0gUiA/IFIuY2FsbChmLCBuLCB6LCBsKSA6IGsoQiwgSywgZCwgbiksIGEucHVzaCh7XG4gICAgICAgICAgICAgIGFsaWduOiBSID8gMCA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgYW5jaG9yWDogQixcbiAgICAgICAgICAgICAgYW5jaG9yWTogSyxcbiAgICAgICAgICAgICAgYm94V2lkdGg6IG4sXG4gICAgICAgICAgICAgIHBvaW50OiBsLFxuICAgICAgICAgICAgICByYW5rOiB0KGcucmFuaywgZCA/IDEgOiAwKSxcbiAgICAgICAgICAgICAgc2l6ZTogeixcbiAgICAgICAgICAgICAgdGFyZ2V0OiBnLnksXG4gICAgICAgICAgICAgIHR0OiBjLFxuICAgICAgICAgICAgICB4OiBnLnhcbiAgICAgICAgICAgIH0pKSA6IGMuaXNBY3RpdmUgPSAhMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICAhUiAmJiBjLnNvbWUoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICByZXR1cm4gYi54IDwgTy5sZWZ0O1xuICAgICAgICB9KSAmJiAoYyA9IGMubWFwKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgdmFyIGEgPSBrKGIuYW5jaG9yWCwgYi5hbmNob3JZLCBiLnBvaW50LmlzSGVhZGVyLCBiLmJveFdpZHRoLCAhMSk7XG4gICAgICAgICAgcmV0dXJuIEUoYiwge1xuICAgICAgICAgICAgdGFyZ2V0OiBhLnksXG4gICAgICAgICAgICB4OiBhLnhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuICAgICAgICBmLmNsZWFuU3BsaXQoKTtcbiAgICAgICAgZC5kaXN0cmlidXRlKGMsIEEpO1xuICAgICAgICBjLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICB2YXIgYSA9IGIucG9zO1xuICAgICAgICAgIGIudHQuYXR0cih7XG4gICAgICAgICAgICB2aXNpYmlsaXR5OiBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgYSA/IFwiaGlkZGVuXCIgOiBcImluaGVyaXRcIixcbiAgICAgICAgICAgIHg6IGIueCxcbiAgICAgICAgICAgIHk6IGEgKyBtLFxuICAgICAgICAgICAgYW5jaG9yWDogYi5hbmNob3JYLFxuICAgICAgICAgICAgYW5jaG9yWTogYi5hbmNob3JZXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjID0gZi5jb250YWluZXI7XG4gICAgICAgIGEgPSBmLnJlbmRlcmVyO1xuICAgICAgICBmLm91dHNpZGUgJiYgYyAmJiBhICYmIChsID0geS5nZXRCQm94KCksIGEuc2V0U2l6ZShsLndpZHRoICsgbC54LCBsLmhlaWdodCArIGwueSwgITEpLCBCID0gQi5nZXRDaGFydFBvc2l0aW9uKCksIGMuc3R5bGUubGVmdCA9IEIubGVmdCArIFwicHhcIiwgYy5zdHlsZS50b3AgPSBCLnRvcCArIFwicHhcIik7XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS5kcmF3VHJhY2tlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9sbG93UG9pbnRlciB8fCAhdGhpcy5vcHRpb25zLnN0aWNrT25Db250YWN0KSB0aGlzLnRyYWNrZXIgJiYgdGhpcy50cmFja2VyLmRlc3Ryb3koKTtlbHNlIHtcbiAgICAgICAgICB2YXIgYyA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICAgIGUgPSB0aGlzLmxhYmVsLFxuICAgICAgICAgICAgICBkID0gYy5ob3ZlclBvaW50O1xuXG4gICAgICAgICAgaWYgKGUgJiYgZCkge1xuICAgICAgICAgICAgdmFyIGYgPSB7XG4gICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkID0gdGhpcy5nZXRBbmNob3IoZCk7XG4gICAgICAgICAgICB2YXIgYSA9IGUuZ2V0QkJveCgpO1xuICAgICAgICAgICAgZFswXSArPSBjLnBsb3RMZWZ0IC0gZS50cmFuc2xhdGVYO1xuICAgICAgICAgICAgZFsxXSArPSBjLnBsb3RUb3AgLSBlLnRyYW5zbGF0ZVk7XG4gICAgICAgICAgICBmLnggPSBNYXRoLm1pbigwLCBkWzBdKTtcbiAgICAgICAgICAgIGYueSA9IE1hdGgubWluKDAsIGRbMV0pO1xuICAgICAgICAgICAgZi53aWR0aCA9IDAgPiBkWzBdID8gTWF0aC5tYXgoTWF0aC5hYnMoZFswXSksIGEud2lkdGggLSBkWzBdKSA6IE1hdGgubWF4KE1hdGguYWJzKGRbMF0pLCBhLndpZHRoKTtcbiAgICAgICAgICAgIGYuaGVpZ2h0ID0gMCA+IGRbMV0gPyBNYXRoLm1heChNYXRoLmFicyhkWzFdKSwgYS5oZWlnaHQgLSBNYXRoLmFicyhkWzFdKSkgOiBNYXRoLm1heChNYXRoLmFicyhkWzFdKSwgYS5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy50cmFja2VyID8gdGhpcy50cmFja2VyLmF0dHIoZikgOiAodGhpcy50cmFja2VyID0gZS5yZW5kZXJlci5yZWN0KGYpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy10cmFja2VyXCIpLmFkZChlKSwgYy5zdHlsZWRNb2RlIHx8IHRoaXMudHJhY2tlci5hdHRyKHtcbiAgICAgICAgICAgICAgZmlsbDogXCJyZ2JhKDAsMCwwLDApXCJcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLnN0eWxlZE1vZGVGb3JtYXQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYy5yZXBsYWNlKCdzdHlsZT1cImZvbnQtc2l6ZTogMTBweFwiJywgJ2NsYXNzPVwiaGlnaGNoYXJ0cy1oZWFkZXJcIicpLnJlcGxhY2UoL3N0eWxlPVwiY29sb3I6eyhwb2ludHxzZXJpZXMpXFwuY29sb3J9XCIvZywgJ2NsYXNzPVwiaGlnaGNoYXJ0cy1jb2xvci17JDEuY29sb3JJbmRleH1cIicpO1xuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUudG9vbHRpcEZvb3RlckhlYWRlckZvcm1hdHRlciA9IGZ1bmN0aW9uIChjLCBlKSB7XG4gICAgICAgIHZhciBrID0gZSA/IFwiZm9vdGVyXCIgOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgZiA9IGMuc2VyaWVzLFxuICAgICAgICAgICAgYSA9IGYudG9vbHRpcE9wdGlvbnMsXG4gICAgICAgICAgICBsID0gYS54RGF0ZUZvcm1hdCxcbiAgICAgICAgICAgIHYgPSBmLnhBeGlzLFxuICAgICAgICAgICAgaCA9IHYgJiYgXCJkYXRldGltZVwiID09PSB2Lm9wdGlvbnMudHlwZSAmJiBHKGMua2V5KSxcbiAgICAgICAgICAgIHcgPSBhW2sgKyBcIkZvcm1hdFwiXTtcbiAgICAgICAgZSA9IHtcbiAgICAgICAgICBpc0Zvb3RlcjogZSxcbiAgICAgICAgICBsYWJlbENvbmZpZzogY1xuICAgICAgICB9O1xuICAgICAgICBkLmZpcmVFdmVudCh0aGlzLCBcImhlYWRlckZvcm1hdHRlclwiLCBlLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGggJiYgIWwgJiYgKGwgPSB0aGlzLmdldFhEYXRlRm9ybWF0KGMsIGEsIHYpKTtcbiAgICAgICAgICBoICYmIGwgJiYgKGMucG9pbnQgJiYgYy5wb2ludC50b29sdGlwRGF0ZUtleXMgfHwgW1wia2V5XCJdKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICB3ID0gdy5yZXBsYWNlKFwie3BvaW50LlwiICsgYSArIFwifVwiLCBcIntwb2ludC5cIiArIGEgKyBcIjpcIiArIGwgKyBcIn1cIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZi5jaGFydC5zdHlsZWRNb2RlICYmICh3ID0gdGhpcy5zdHlsZWRNb2RlRm9ybWF0KHcpKTtcbiAgICAgICAgICBlLnRleHQgPSBBKHcsIHtcbiAgICAgICAgICAgIHBvaW50OiBjLFxuICAgICAgICAgICAgc2VyaWVzOiBmXG4gICAgICAgICAgfSwgdGhpcy5jaGFydCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZS50ZXh0O1xuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHkoITAsIHRoaXMuY2hhcnQub3B0aW9ucy50b29sdGlwLnVzZXJPcHRpb25zLCBjKTtcbiAgICAgICAgdGhpcy5pbml0KHRoaXMuY2hhcnQsIHkoITAsIHRoaXMub3B0aW9ucywgYykpO1xuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUudXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgZSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBkID0gZS5wb2ludGVyLFxuICAgICAgICAgICAgZiA9IHRoaXMuZ2V0TGFiZWwoKSxcbiAgICAgICAgICAgIGEgPSBjLnBsb3RYICsgZS5wbG90TGVmdCxcbiAgICAgICAgICAgIGwgPSBjLnBsb3RZICsgZS5wbG90VG9wO1xuICAgICAgICBkID0gZC5nZXRDaGFydFBvc2l0aW9uKCk7XG4gICAgICAgIGMgPSAodGhpcy5vcHRpb25zLnBvc2l0aW9uZXIgfHwgdGhpcy5nZXRQb3NpdGlvbikuY2FsbCh0aGlzLCBmLndpZHRoLCBmLmhlaWdodCwgYyk7XG5cbiAgICAgICAgaWYgKHRoaXMub3V0c2lkZSkge1xuICAgICAgICAgIHZhciB2ID0gKHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwKSArIDIgKiB0aGlzLmRpc3RhbmNlO1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZShmLndpZHRoICsgdiwgZi5oZWlnaHQgKyB2LCAhMSk7XG4gICAgICAgICAgaWYgKGUgPSBlLmNvbnRhaW5lclNjYWxpbmcpIHUodGhpcy5jb250YWluZXIsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZShcIiArIGUuc2NhbGVYICsgXCIsIFwiICsgZS5zY2FsZVkgKyBcIilcIlxuICAgICAgICAgIH0pLCBhICo9IGUuc2NhbGVYLCBsICo9IGUuc2NhbGVZO1xuICAgICAgICAgIGEgKz0gZC5sZWZ0IC0gYy54O1xuICAgICAgICAgIGwgKz0gZC50b3AgLSBjLnk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vdmUoTWF0aC5yb3VuZChjLngpLCBNYXRoLnJvdW5kKGMueSB8fCAwKSwgYSwgbCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZTtcbiAgICB9KCk7XG5cbiAgICBkLlRvb2x0aXAgPSBQO1xuICAgIHJldHVybiBkLlRvb2x0aXA7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvUG9pbnRlci5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl0sIHJbXCJwYXJ0cy9Ub29sdGlwLmpzXCJdLCByW1wicGFydHMvQ29sb3IuanNcIl1dLCBmdW5jdGlvbiAoZCwgZywgciwgdSkge1xuICAgIHZhciBJID0gZy5hZGRFdmVudCxcbiAgICAgICAgTSA9IGcuYXR0cixcbiAgICAgICAgRSA9IGcuY3NzLFxuICAgICAgICBBID0gZy5kZWZpbmVkLFxuICAgICAgICBHID0gZy5leHRlbmQsXG4gICAgICAgIEogPSBnLmZpbmQsXG4gICAgICAgIHkgPSBnLmZpcmVFdmVudCxcbiAgICAgICAgdCA9IGcuaXNOdW1iZXIsXG4gICAgICAgIEQgPSBnLmlzT2JqZWN0LFxuICAgICAgICBoID0gZy5vYmplY3RFYWNoLFxuICAgICAgICBOID0gZy5vZmZzZXQsXG4gICAgICAgIHEgPSBnLnBpY2ssXG4gICAgICAgIFAgPSBnLnNwbGF0LFxuICAgICAgICBlID0gdS5wYXJzZSxcbiAgICAgICAgYyA9IGQuY2hhcnRzLFxuICAgICAgICBrID0gZC5ub29wO1xuXG4gICAgZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIG4oYywgYSkge1xuICAgICAgICB0aGlzLmxhc3RWYWxpZFRvdWNoID0ge307XG4gICAgICAgIHRoaXMucGluY2hEb3duID0gW107XG4gICAgICAgIHRoaXMucnVuQ2hhcnRDbGljayA9ICExO1xuICAgICAgICB0aGlzLmNoYXJ0ID0gYztcbiAgICAgICAgdGhpcy5oYXNEcmFnZ2VkID0gITE7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGE7XG5cbiAgICAgICAgdGhpcy51bmJpbmRDb250YWluZXJNb3VzZUxlYXZlID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgdGhpcy5pbml0KGMsIGEpO1xuICAgICAgfVxuXG4gICAgICBuLnByb3RvdHlwZS5hcHBseUluYWN0aXZlU3RhdGUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgYSA9IFtdLFxuICAgICAgICAgICAgZjtcbiAgICAgICAgKGMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBmID0gYy5zZXJpZXM7XG4gICAgICAgICAgYS5wdXNoKGYpO1xuICAgICAgICAgIGYubGlua2VkUGFyZW50ICYmIGEucHVzaChmLmxpbmtlZFBhcmVudCk7XG4gICAgICAgICAgZi5saW5rZWRTZXJpZXMgJiYgKGEgPSBhLmNvbmNhdChmLmxpbmtlZFNlcmllcykpO1xuICAgICAgICAgIGYubmF2aWdhdG9yU2VyaWVzICYmIGEucHVzaChmLm5hdmlnYXRvclNlcmllcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNoYXJ0LnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgLTEgPT09IGEuaW5kZXhPZihjKSA/IGMuc2V0U3RhdGUoXCJpbmFjdGl2ZVwiLCAhMCkgOiBjLm9wdGlvbnMuaW5hY3RpdmVPdGhlclBvaW50cyAmJiBjLnNldEFsbFBvaW50c1RvU3RhdGUoXCJpbmFjdGl2ZVwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYyA9IHRoaXM7XG4gICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBjLnVuRG9jTW91c2VNb3ZlICYmIGMudW5Eb2NNb3VzZU1vdmUoKTtcbiAgICAgICAgdGhpcy51bmJpbmRDb250YWluZXJNb3VzZUxlYXZlKCk7XG4gICAgICAgIGQuY2hhcnRDb3VudCB8fCAoZC51bmJpbmREb2N1bWVudE1vdXNlVXAgJiYgKGQudW5iaW5kRG9jdW1lbnRNb3VzZVVwID0gZC51bmJpbmREb2N1bWVudE1vdXNlVXAoKSksIGQudW5iaW5kRG9jdW1lbnRUb3VjaEVuZCAmJiAoZC51bmJpbmREb2N1bWVudFRvdWNoRW5kID0gZC51bmJpbmREb2N1bWVudFRvdWNoRW5kKCkpKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChjLnRvb2x0aXBUaW1lb3V0KTtcbiAgICAgICAgaChjLCBmdW5jdGlvbiAoYSwgZikge1xuICAgICAgICAgIGNbZl0gPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLmRyYWcgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBmID0gYS5vcHRpb25zLmNoYXJ0LFxuICAgICAgICAgICAgZCA9IGMuY2hhcnRYLFxuICAgICAgICAgICAgayA9IGMuY2hhcnRZLFxuICAgICAgICAgICAgdyA9IHRoaXMuem9vbUhvcixcbiAgICAgICAgICAgIG4gPSB0aGlzLnpvb21WZXJ0LFxuICAgICAgICAgICAgaCA9IGEucGxvdExlZnQsXG4gICAgICAgICAgICBxID0gYS5wbG90VG9wLFxuICAgICAgICAgICAgZyA9IGEucGxvdFdpZHRoLFxuICAgICAgICAgICAgdCA9IGEucGxvdEhlaWdodCxcbiAgICAgICAgICAgIHAgPSB0aGlzLnNlbGVjdGlvbk1hcmtlcixcbiAgICAgICAgICAgIGIgPSB0aGlzLm1vdXNlRG93blggfHwgMCxcbiAgICAgICAgICAgIEMgPSB0aGlzLm1vdXNlRG93blkgfHwgMCxcbiAgICAgICAgICAgIHggPSBEKGYucGFubmluZykgPyBmLnBhbm5pbmcgJiYgZi5wYW5uaW5nLmVuYWJsZWQgOiBmLnBhbm5pbmcsXG4gICAgICAgICAgICB5ID0gZi5wYW5LZXkgJiYgY1tmLnBhbktleSArIFwiS2V5XCJdO1xuICAgICAgICBpZiAoIXAgfHwgIXAudG91Y2gpIGlmIChkIDwgaCA/IGQgPSBoIDogZCA+IGggKyBnICYmIChkID0gaCArIGcpLCBrIDwgcSA/IGsgPSBxIDogayA+IHEgKyB0ICYmIChrID0gcSArIHQpLCB0aGlzLmhhc0RyYWdnZWQgPSBNYXRoLnNxcnQoTWF0aC5wb3coYiAtIGQsIDIpICsgTWF0aC5wb3coQyAtIGssIDIpKSwgMTAgPCB0aGlzLmhhc0RyYWdnZWQpIHtcbiAgICAgICAgICB2YXIgTyA9IGEuaXNJbnNpZGVQbG90KGIgLSBoLCBDIC0gcSk7XG4gICAgICAgICAgYS5oYXNDYXJ0ZXNpYW5TZXJpZXMgJiYgKHRoaXMuem9vbVggfHwgdGhpcy56b29tWSkgJiYgTyAmJiAheSAmJiAhcCAmJiAodGhpcy5zZWxlY3Rpb25NYXJrZXIgPSBwID0gYS5yZW5kZXJlci5yZWN0KGgsIHEsIHcgPyAxIDogZywgbiA/IDEgOiB0LCAwKS5hdHRyKHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJoaWdoY2hhcnRzLXNlbGVjdGlvbi1tYXJrZXJcIixcbiAgICAgICAgICAgIHpJbmRleDogN1xuICAgICAgICAgIH0pLmFkZCgpLCBhLnN0eWxlZE1vZGUgfHwgcC5hdHRyKHtcbiAgICAgICAgICAgIGZpbGw6IGYuc2VsZWN0aW9uTWFya2VyRmlsbCB8fCBlKFwiIzMzNWNhZFwiKS5zZXRPcGFjaXR5KC4yNSkuZ2V0KClcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcCAmJiB3ICYmIChkIC09IGIsIHAuYXR0cih7XG4gICAgICAgICAgICB3aWR0aDogTWF0aC5hYnMoZCksXG4gICAgICAgICAgICB4OiAoMCA8IGQgPyAwIDogZCkgKyBiXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHAgJiYgbiAmJiAoZCA9IGsgLSBDLCBwLmF0dHIoe1xuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLmFicyhkKSxcbiAgICAgICAgICAgIHk6ICgwIDwgZCA/IDAgOiBkKSArIENcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgTyAmJiAhcCAmJiB4ICYmIGEucGFuKGMsIGYucGFubmluZyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLmRyYWdTdGFydCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jaGFydDtcbiAgICAgICAgYS5tb3VzZUlzRG93biA9IGMudHlwZTtcbiAgICAgICAgYS5jYW5jZWxDbGljayA9ICExO1xuICAgICAgICBhLm1vdXNlRG93blggPSB0aGlzLm1vdXNlRG93blggPSBjLmNoYXJ0WDtcbiAgICAgICAgYS5tb3VzZURvd25ZID0gdGhpcy5tb3VzZURvd25ZID0gYy5jaGFydFk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5kcm9wID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgZiA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBlID0gdGhpcy5oYXNQaW5jaGVkO1xuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1hcmtlcikge1xuICAgICAgICAgIHZhciBkID0ge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogYyxcbiAgICAgICAgICAgIHhBeGlzOiBbXSxcbiAgICAgICAgICAgIHlBeGlzOiBbXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGsgPSB0aGlzLnNlbGVjdGlvbk1hcmtlcixcbiAgICAgICAgICAgICAgbiA9IGsuYXR0ciA/IGsuYXR0cihcInhcIikgOiBrLngsXG4gICAgICAgICAgICAgIGggPSBrLmF0dHIgPyBrLmF0dHIoXCJ5XCIpIDogay55LFxuICAgICAgICAgICAgICBxID0gay5hdHRyID8gay5hdHRyKFwid2lkdGhcIikgOiBrLndpZHRoLFxuICAgICAgICAgICAgICBnID0gay5hdHRyID8gay5hdHRyKFwiaGVpZ2h0XCIpIDogay5oZWlnaHQsXG4gICAgICAgICAgICAgIEs7XG4gICAgICAgICAgaWYgKHRoaXMuaGFzRHJhZ2dlZCB8fCBlKSBmLmF4ZXMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgaWYgKGYuem9vbUVuYWJsZWQgJiYgQShmLm1pbikgJiYgKGUgfHwgYVt7XG4gICAgICAgICAgICAgIHhBeGlzOiBcInpvb21YXCIsXG4gICAgICAgICAgICAgIHlBeGlzOiBcInpvb21ZXCJcbiAgICAgICAgICAgIH1bZi5jb2xsXV0pKSB7XG4gICAgICAgICAgICAgIHZhciBiID0gZi5ob3JpeixcbiAgICAgICAgICAgICAgICAgIGwgPSBcInRvdWNoZW5kXCIgPT09IGMudHlwZSA/IGYubWluUGl4ZWxQYWRkaW5nIDogMCxcbiAgICAgICAgICAgICAgICAgIGsgPSBmLnRvVmFsdWUoKGIgPyBuIDogaCkgKyBsKTtcbiAgICAgICAgICAgICAgYiA9IGYudG9WYWx1ZSgoYiA/IG4gKyBxIDogaCArIGcpIC0gbCk7XG4gICAgICAgICAgICAgIGRbZi5jb2xsXS5wdXNoKHtcbiAgICAgICAgICAgICAgICBheGlzOiBmLFxuICAgICAgICAgICAgICAgIG1pbjogTWF0aC5taW4oaywgYiksXG4gICAgICAgICAgICAgICAgbWF4OiBNYXRoLm1heChrLCBiKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgSyA9ICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBLICYmIHkoZiwgXCJzZWxlY3Rpb25cIiwgZCwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGYuem9vbShHKGEsIGUgPyB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvbjogITFcbiAgICAgICAgICAgIH0gOiBudWxsKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdChmLmluZGV4KSAmJiAodGhpcy5zZWxlY3Rpb25NYXJrZXIgPSB0aGlzLnNlbGVjdGlvbk1hcmtlci5kZXN0cm95KCkpO1xuICAgICAgICAgIGUgJiYgdGhpcy5zY2FsZUdyb3VwcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZiAmJiB0KGYuaW5kZXgpICYmIChFKGYuY29udGFpbmVyLCB7XG4gICAgICAgICAgY3Vyc29yOiBmLl9jdXJzb3JcbiAgICAgICAgfSksIGYuY2FuY2VsQ2xpY2sgPSAxMCA8IHRoaXMuaGFzRHJhZ2dlZCwgZi5tb3VzZUlzRG93biA9IHRoaXMuaGFzRHJhZ2dlZCA9IHRoaXMuaGFzUGluY2hlZCA9ICExLCB0aGlzLnBpbmNoRG93biA9IFtdKTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLmZpbmROZWFyZXN0S0RQb2ludCA9IGZ1bmN0aW9uIChjLCBhLCBlKSB7XG4gICAgICAgIHZhciBmID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGQgPSBmLmhvdmVyUG9pbnQ7XG4gICAgICAgIGYgPSBmLnRvb2x0aXA7XG4gICAgICAgIGlmIChkICYmIGYgJiYgZi5pc1N0aWNreU9uQ29udGFjdCgpKSByZXR1cm4gZDtcbiAgICAgICAgdmFyIGw7XG4gICAgICAgIGMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHZhciBmID0gIShjLm5vU2hhcmVkVG9vbHRpcCAmJiBhKSAmJiAwID4gYy5vcHRpb25zLmZpbmROZWFyZXN0UG9pbnRCeS5pbmRleE9mKFwieVwiKTtcbiAgICAgICAgICBjID0gYy5zZWFyY2hQb2ludChlLCBmKTtcblxuICAgICAgICAgIGlmICgoZiA9IEQoYywgITApKSAmJiAhKGYgPSAhRChsLCAhMCkpKSB7XG4gICAgICAgICAgICBmID0gbC5kaXN0WCAtIGMuZGlzdFg7XG4gICAgICAgICAgICB2YXIgZCA9IGwuZGlzdCAtIGMuZGlzdCxcbiAgICAgICAgICAgICAgICBrID0gKGMuc2VyaWVzLmdyb3VwICYmIGMuc2VyaWVzLmdyb3VwLnpJbmRleCkgLSAobC5zZXJpZXMuZ3JvdXAgJiYgbC5zZXJpZXMuZ3JvdXAuekluZGV4KTtcbiAgICAgICAgICAgIGYgPSAwIDwgKDAgIT09IGYgJiYgYSA/IGYgOiAwICE9PSBkID8gZCA6IDAgIT09IGsgPyBrIDogbC5zZXJpZXMuaW5kZXggPiBjLnNlcmllcy5pbmRleCA/IC0xIDogMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZiAmJiAobCA9IGMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5nZXRDaGFydENvb3JkaW5hdGVzRnJvbVBvaW50ID0gZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgdmFyIGYgPSBjLnNlcmllcyxcbiAgICAgICAgICAgIGUgPSBmLnhBeGlzO1xuICAgICAgICBmID0gZi55QXhpcztcbiAgICAgICAgdmFyIGQgPSBxKGMuY2xpZW50WCwgYy5wbG90WCksXG4gICAgICAgICAgICBrID0gYy5zaGFwZUFyZ3M7XG4gICAgICAgIGlmIChlICYmIGYpIHJldHVybiBhID8ge1xuICAgICAgICAgIGNoYXJ0WDogZS5sZW4gKyBlLnBvcyAtIGQsXG4gICAgICAgICAgY2hhcnRZOiBmLmxlbiArIGYucG9zIC0gYy5wbG90WVxuICAgICAgICB9IDoge1xuICAgICAgICAgIGNoYXJ0WDogZCArIGUucG9zLFxuICAgICAgICAgIGNoYXJ0WTogYy5wbG90WSArIGYucG9zXG4gICAgICAgIH07XG4gICAgICAgIGlmIChrICYmIGsueCAmJiBrLnkpIHJldHVybiB7XG4gICAgICAgICAgY2hhcnRYOiBrLngsXG4gICAgICAgICAgY2hhcnRZOiBrLnlcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLmdldENoYXJ0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYXJ0UG9zaXRpb24gfHwgKHRoaXMuY2hhcnRQb3NpdGlvbiA9IE4odGhpcy5jaGFydC5jb250YWluZXIpKTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGEgPSB7XG4gICAgICAgICAgeEF4aXM6IFtdLFxuICAgICAgICAgIHlBeGlzOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoYXJ0LmF4ZXMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgIGFbZi5pc1hBeGlzID8gXCJ4QXhpc1wiIDogXCJ5QXhpc1wiXS5wdXNoKHtcbiAgICAgICAgICAgIGF4aXM6IGYsXG4gICAgICAgICAgICB2YWx1ZTogZi50b1ZhbHVlKGNbZi5ob3JpeiA/IFwiY2hhcnRYXCIgOiBcImNoYXJ0WVwiXSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUuZ2V0SG92ZXJEYXRhID0gZnVuY3Rpb24gKGMsIGEsIGUsIGQsIGssIG4pIHtcbiAgICAgICAgdmFyIGYsXG4gICAgICAgICAgICBsID0gW107XG4gICAgICAgIGQgPSAhKCFkIHx8ICFjKTtcbiAgICAgICAgdmFyIHYgPSBhICYmICFhLnN0aWNreVRyYWNraW5nLFxuICAgICAgICAgICAgaCA9IHtcbiAgICAgICAgICBjaGFydFg6IG4gPyBuLmNoYXJ0WCA6IHZvaWQgMCxcbiAgICAgICAgICBjaGFydFk6IG4gPyBuLmNoYXJ0WSA6IHZvaWQgMCxcbiAgICAgICAgICBzaGFyZWQ6IGtcbiAgICAgICAgfTtcbiAgICAgICAgeSh0aGlzLCBcImJlZm9yZUdldEhvdmVyRGF0YVwiLCBoKTtcbiAgICAgICAgdiA9IHYgPyBbYV0gOiBlLmZpbHRlcihmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHJldHVybiBoLmZpbHRlciA/IGguZmlsdGVyKGEpIDogYS52aXNpYmxlICYmICEoIWsgJiYgYS5kaXJlY3RUb3VjaCkgJiYgcShhLm9wdGlvbnMuZW5hYmxlTW91c2VUcmFja2luZywgITApICYmIGEuc3RpY2t5VHJhY2tpbmc7XG4gICAgICAgIH0pO1xuICAgICAgICBhID0gKGYgPSBkIHx8ICFuID8gYyA6IHRoaXMuZmluZE5lYXJlc3RLRFBvaW50KHYsIGssIG4pKSAmJiBmLnNlcmllcztcbiAgICAgICAgZiAmJiAoayAmJiAhYS5ub1NoYXJlZFRvb2x0aXAgPyAodiA9IGUuZmlsdGVyKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgcmV0dXJuIGguZmlsdGVyID8gaC5maWx0ZXIoYSkgOiBhLnZpc2libGUgJiYgISghayAmJiBhLmRpcmVjdFRvdWNoKSAmJiBxKGEub3B0aW9ucy5lbmFibGVNb3VzZVRyYWNraW5nLCAhMCkgJiYgIWEubm9TaGFyZWRUb29sdGlwO1xuICAgICAgICB9KSwgdi5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgdmFyIGMgPSBKKGEucG9pbnRzLCBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgcmV0dXJuIGIueCA9PT0gZi54ICYmICFiLmlzTnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBEKGMpICYmIChhLmNoYXJ0LmlzQm9vc3RpbmcgJiYgKGMgPSBhLmdldFBvaW50KGMpKSwgbC5wdXNoKGMpKTtcbiAgICAgICAgfSkpIDogbC5wdXNoKGYpKTtcbiAgICAgICAgaCA9IHtcbiAgICAgICAgICBob3ZlclBvaW50OiBmXG4gICAgICAgIH07XG4gICAgICAgIHkodGhpcywgXCJhZnRlckdldEhvdmVyRGF0YVwiLCBoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBob3ZlclBvaW50OiBoLmhvdmVyUG9pbnQsXG4gICAgICAgICAgaG92ZXJTZXJpZXM6IGEsXG4gICAgICAgICAgaG92ZXJQb2ludHM6IGxcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLmdldFBvaW50RnJvbUV2ZW50ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgYyA9IGMudGFyZ2V0O1xuXG4gICAgICAgIGZvciAodmFyIGE7IGMgJiYgIWE7KSBhID0gYy5wb2ludCwgYyA9IGMucGFyZW50Tm9kZTtcblxuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLm9uVHJhY2tlck1vdXNlT3V0ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNoYXJ0LmhvdmVyU2VyaWVzO1xuICAgICAgICBjID0gYy5yZWxhdGVkVGFyZ2V0IHx8IGMudG9FbGVtZW50O1xuICAgICAgICB0aGlzLmlzRGlyZWN0VG91Y2ggPSAhMTtcbiAgICAgICAgaWYgKCEoIWEgfHwgIWMgfHwgYS5zdGlja3lUcmFja2luZyB8fCB0aGlzLmluQ2xhc3MoYywgXCJoaWdoY2hhcnRzLXRvb2x0aXBcIikgfHwgdGhpcy5pbkNsYXNzKGMsIFwiaGlnaGNoYXJ0cy1zZXJpZXMtXCIgKyBhLmluZGV4KSAmJiB0aGlzLmluQ2xhc3MoYywgXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikpKSBhLm9uTW91c2VPdXQoKTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLmluQ2xhc3MgPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICBmb3IgKHZhciBmOyBjOykge1xuICAgICAgICAgIGlmIChmID0gTShjLCBcImNsYXNzXCIpKSB7XG4gICAgICAgICAgICBpZiAoLTEgIT09IGYuaW5kZXhPZihhKSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgaWYgKC0xICE9PSBmLmluZGV4T2YoXCJoaWdoY2hhcnRzLWNvbnRhaW5lclwiKSkgcmV0dXJuICExO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGMgPSBjLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBhO1xuICAgICAgICB0aGlzLmNoYXJ0ID0gYztcbiAgICAgICAgdGhpcy5ydW5DaGFydENsaWNrID0gYS5jaGFydC5ldmVudHMgJiYgISFhLmNoYXJ0LmV2ZW50cy5jbGljaztcbiAgICAgICAgdGhpcy5waW5jaERvd24gPSBbXTtcbiAgICAgICAgdGhpcy5sYXN0VmFsaWRUb3VjaCA9IHt9O1xuICAgICAgICByICYmIChjLnRvb2x0aXAgPSBuZXcgcihjLCBhLnRvb2x0aXApLCB0aGlzLmZvbGxvd1RvdWNoTW92ZSA9IHEoYS50b29sdGlwLmZvbGxvd1RvdWNoTW92ZSwgITApKTtcbiAgICAgICAgdGhpcy5zZXRET01FdmVudHMoKTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIHZhciBmID0gYy50b3VjaGVzLFxuICAgICAgICAgICAgZSA9IGYgPyBmLmxlbmd0aCA/IGYuaXRlbSgwKSA6IGYuY2hhbmdlZFRvdWNoZXNbMF0gOiBjO1xuICAgICAgICBhIHx8IChhID0gdGhpcy5nZXRDaGFydFBvc2l0aW9uKCkpO1xuICAgICAgICBmID0gZS5wYWdlWCAtIGEubGVmdDtcbiAgICAgICAgYSA9IGUucGFnZVkgLSBhLnRvcDtcbiAgICAgICAgaWYgKGUgPSB0aGlzLmNoYXJ0LmNvbnRhaW5lclNjYWxpbmcpIGYgLz0gZS5zY2FsZVgsIGEgLz0gZS5zY2FsZVk7XG4gICAgICAgIHJldHVybiBHKGMsIHtcbiAgICAgICAgICBjaGFydFg6IE1hdGgucm91bmQoZiksXG4gICAgICAgICAgY2hhcnRZOiBNYXRoLnJvdW5kKGEpXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUub25Db250YWluZXJDbGljayA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGYgPSBhLmhvdmVyUG9pbnQsXG4gICAgICAgICAgICBlID0gYS5wbG90TGVmdCxcbiAgICAgICAgICAgIGQgPSBhLnBsb3RUb3A7XG4gICAgICAgIGMgPSB0aGlzLm5vcm1hbGl6ZShjKTtcbiAgICAgICAgYS5jYW5jZWxDbGljayB8fCAoZiAmJiB0aGlzLmluQ2xhc3MoYy50YXJnZXQsIFwiaGlnaGNoYXJ0cy10cmFja2VyXCIpID8gKHkoZi5zZXJpZXMsIFwiY2xpY2tcIiwgRyhjLCB7XG4gICAgICAgICAgcG9pbnQ6IGZcbiAgICAgICAgfSkpLCBhLmhvdmVyUG9pbnQgJiYgZi5maXJlUG9pbnRFdmVudChcImNsaWNrXCIsIGMpKSA6IChHKGMsIHRoaXMuZ2V0Q29vcmRpbmF0ZXMoYykpLCBhLmlzSW5zaWRlUGxvdChjLmNoYXJ0WCAtIGUsIGMuY2hhcnRZIC0gZCkgJiYgeShhLCBcImNsaWNrXCIsIGMpKSk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5vbkNvbnRhaW5lck1vdXNlRG93biA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGMgPSB0aGlzLm5vcm1hbGl6ZShjKTtcbiAgICAgICAgMiAhPT0gYy5idXR0b24gJiYgKHRoaXMuem9vbU9wdGlvbihjKSwgYy5wcmV2ZW50RGVmYXVsdCAmJiBjLnByZXZlbnREZWZhdWx0KCksIHRoaXMuZHJhZ1N0YXJ0KGMpKTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLm9uQ29udGFpbmVyTW91c2VMZWF2ZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHZhciBhID0gY1tkLmhvdmVyQ2hhcnRJbmRleF07XG4gICAgICAgIGEgJiYgKGYucmVsYXRlZFRhcmdldCB8fCBmLnRvRWxlbWVudCkgJiYgKGEucG9pbnRlci5yZXNldCgpLCBhLnBvaW50ZXIuY2hhcnRQb3NpdGlvbiA9IHZvaWQgMCk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5vbkNvbnRhaW5lck1vdXNlTW92ZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jaGFydDtcbiAgICAgICAgQShkLmhvdmVyQ2hhcnRJbmRleCkgJiYgY1tkLmhvdmVyQ2hhcnRJbmRleF0gJiYgY1tkLmhvdmVyQ2hhcnRJbmRleF0ubW91c2VJc0Rvd24gfHwgKGQuaG92ZXJDaGFydEluZGV4ID0gYS5pbmRleCk7XG4gICAgICAgIGYgPSB0aGlzLm5vcm1hbGl6ZShmKTtcbiAgICAgICAgZi5wcmV2ZW50RGVmYXVsdCB8fCAoZi5yZXR1cm5WYWx1ZSA9ICExKTtcbiAgICAgICAgXCJtb3VzZWRvd25cIiA9PT0gYS5tb3VzZUlzRG93biAmJiB0aGlzLmRyYWcoZik7XG4gICAgICAgIGEub3Blbk1lbnUgfHwgIXRoaXMuaW5DbGFzcyhmLnRhcmdldCwgXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikgJiYgIWEuaXNJbnNpZGVQbG90KGYuY2hhcnRYIC0gYS5wbG90TGVmdCwgZi5jaGFydFkgLSBhLnBsb3RUb3ApIHx8IHRoaXMucnVuUG9pbnRBY3Rpb25zKGYpO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUub25Eb2N1bWVudFRvdWNoRW5kID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgY1tkLmhvdmVyQ2hhcnRJbmRleF0gJiYgY1tkLmhvdmVyQ2hhcnRJbmRleF0ucG9pbnRlci5kcm9wKGYpO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUub25Db250YWluZXJUb3VjaE1vdmUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB0aGlzLnRvdWNoKGMpO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUub25Db250YWluZXJUb3VjaFN0YXJ0ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdGhpcy56b29tT3B0aW9uKGMpO1xuICAgICAgICB0aGlzLnRvdWNoKGMsICEwKTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLm9uRG9jdW1lbnRNb3VzZU1vdmUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBmID0gdGhpcy5jaGFydFBvc2l0aW9uLFxuICAgICAgICAgICAgZSA9IGEudG9vbHRpcDtcbiAgICAgICAgYyA9IHRoaXMubm9ybWFsaXplKGMsIGYpO1xuICAgICAgICAhZiB8fCBlICYmIGUuaXNTdGlja3lPbkNvbnRhY3QoKSB8fCBhLmlzSW5zaWRlUGxvdChjLmNoYXJ0WCAtIGEucGxvdExlZnQsIGMuY2hhcnRZIC0gYS5wbG90VG9wKSB8fCB0aGlzLmluQ2xhc3MoYy50YXJnZXQsIFwiaGlnaGNoYXJ0cy10cmFja2VyXCIpIHx8IHRoaXMucmVzZXQoKTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLm9uRG9jdW1lbnRNb3VzZVVwID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgY1tkLmhvdmVyQ2hhcnRJbmRleF0gJiYgY1tkLmhvdmVyQ2hhcnRJbmRleF0ucG9pbnRlci5kcm9wKGYpO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUucGluY2ggPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICBmID0gYS5jaGFydCxcbiAgICAgICAgICAgIGUgPSBhLnBpbmNoRG93bixcbiAgICAgICAgICAgIGQgPSBjLnRvdWNoZXMgfHwgW10sXG4gICAgICAgICAgICBuID0gZC5sZW5ndGgsXG4gICAgICAgICAgICBoID0gYS5sYXN0VmFsaWRUb3VjaCxcbiAgICAgICAgICAgIGcgPSBhLmhhc1pvb20sXG4gICAgICAgICAgICB0ID0gYS5zZWxlY3Rpb25NYXJrZXIsXG4gICAgICAgICAgICBIID0ge30sXG4gICAgICAgICAgICBLID0gMSA9PT0gbiAmJiAoYS5pbkNsYXNzKGMudGFyZ2V0LCBcImhpZ2hjaGFydHMtdHJhY2tlclwiKSAmJiBmLnJ1blRyYWNrZXJDbGljayB8fCBhLnJ1bkNoYXJ0Q2xpY2spLFxuICAgICAgICAgICAgcCA9IHt9O1xuICAgICAgICAxIDwgbiAmJiAoYS5pbml0aWF0ZWQgPSAhMCk7XG4gICAgICAgIGcgJiYgYS5pbml0aWF0ZWQgJiYgIUsgJiYgYy5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBbXS5tYXAuY2FsbChkLCBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHJldHVybiBhLm5vcm1hbGl6ZShiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFwidG91Y2hzdGFydFwiID09PSBjLnR5cGUgPyAoW10uZm9yRWFjaC5jYWxsKGQsIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgZVthXSA9IHtcbiAgICAgICAgICAgIGNoYXJ0WDogYi5jaGFydFgsXG4gICAgICAgICAgICBjaGFydFk6IGIuY2hhcnRZXG4gICAgICAgICAgfTtcbiAgICAgICAgfSksIGgueCA9IFtlWzBdLmNoYXJ0WCwgZVsxXSAmJiBlWzFdLmNoYXJ0WF0sIGgueSA9IFtlWzBdLmNoYXJ0WSwgZVsxXSAmJiBlWzFdLmNoYXJ0WV0sIGYuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgaWYgKGIuem9vbUVuYWJsZWQpIHtcbiAgICAgICAgICAgIHZhciBhID0gZi5ib3VuZHNbYi5ob3JpeiA/IFwiaFwiIDogXCJ2XCJdLFxuICAgICAgICAgICAgICAgIGMgPSBiLm1pblBpeGVsUGFkZGluZyxcbiAgICAgICAgICAgICAgICBlID0gYi50b1BpeGVscyhNYXRoLm1pbihxKGIub3B0aW9ucy5taW4sIGIuZGF0YU1pbiksIGIuZGF0YU1pbikpLFxuICAgICAgICAgICAgICAgIGQgPSBiLnRvUGl4ZWxzKE1hdGgubWF4KHEoYi5vcHRpb25zLm1heCwgYi5kYXRhTWF4KSwgYi5kYXRhTWF4KSksXG4gICAgICAgICAgICAgICAgbCA9IE1hdGgubWF4KGUsIGQpO1xuICAgICAgICAgICAgYS5taW4gPSBNYXRoLm1pbihiLnBvcywgTWF0aC5taW4oZSwgZCkgLSBjKTtcbiAgICAgICAgICAgIGEubWF4ID0gTWF0aC5tYXgoYi5wb3MgKyBiLmxlbiwgbCArIGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksIGEucmVzID0gITApIDogYS5mb2xsb3dUb3VjaE1vdmUgJiYgMSA9PT0gbiA/IHRoaXMucnVuUG9pbnRBY3Rpb25zKGEubm9ybWFsaXplKGMpKSA6IGUubGVuZ3RoICYmICh0IHx8IChhLnNlbGVjdGlvbk1hcmtlciA9IHQgPSBHKHtcbiAgICAgICAgICBkZXN0cm95OiBrLFxuICAgICAgICAgIHRvdWNoOiAhMFxuICAgICAgICB9LCBmLnBsb3RCb3gpKSwgYS5waW5jaFRyYW5zbGF0ZShlLCBkLCBILCB0LCBwLCBoKSwgYS5oYXNQaW5jaGVkID0gZywgYS5zY2FsZUdyb3VwcyhILCBwKSwgYS5yZXMgJiYgKGEucmVzID0gITEsIHRoaXMucmVzZXQoITEsIDApKSk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5waW5jaFRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChjLCBhLCBlLCBkLCBrLCBuKSB7XG4gICAgICAgIHRoaXMuem9vbUhvciAmJiB0aGlzLnBpbmNoVHJhbnNsYXRlRGlyZWN0aW9uKCEwLCBjLCBhLCBlLCBkLCBrLCBuKTtcbiAgICAgICAgdGhpcy56b29tVmVydCAmJiB0aGlzLnBpbmNoVHJhbnNsYXRlRGlyZWN0aW9uKCExLCBjLCBhLCBlLCBkLCBrLCBuKTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLnBpbmNoVHJhbnNsYXRlRGlyZWN0aW9uID0gZnVuY3Rpb24gKGMsIGEsIGUsIGQsIGssIG4sIGgsIHEpIHtcbiAgICAgICAgdmFyIGYgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgbCA9IGMgPyBcInhcIiA6IFwieVwiLFxuICAgICAgICAgICAgdiA9IGMgPyBcIlhcIiA6IFwiWVwiLFxuICAgICAgICAgICAgcCA9IFwiY2hhcnRcIiArIHYsXG4gICAgICAgICAgICBiID0gYyA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCIsXG4gICAgICAgICAgICB3ID0gZltcInBsb3RcIiArIChjID8gXCJMZWZ0XCIgOiBcIlRvcFwiKV0sXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgQixcbiAgICAgICAgICAgIGcgPSBxIHx8IDEsXG4gICAgICAgICAgICB6ID0gZi5pbnZlcnRlZCxcbiAgICAgICAgICAgIHQgPSBmLmJvdW5kc1tjID8gXCJoXCIgOiBcInZcIl0sXG4gICAgICAgICAgICBtID0gMSA9PT0gYS5sZW5ndGgsXG4gICAgICAgICAgICBMID0gYVswXVtwXSxcbiAgICAgICAgICAgIHkgPSBlWzBdW3BdLFxuICAgICAgICAgICAgdSA9ICFtICYmIGFbMV1bcF0sXG4gICAgICAgICAgICBGID0gIW0gJiYgZVsxXVtwXTtcblxuICAgICAgICBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBGICYmIDIwIDwgTWF0aC5hYnMoTCAtIHUpICYmIChnID0gcSB8fCBNYXRoLmFicyh5IC0gRikgLyBNYXRoLmFicyhMIC0gdSkpO1xuICAgICAgICAgIEIgPSAodyAtIHkpIC8gZyArIEw7XG4gICAgICAgICAgeCA9IGZbXCJwbG90XCIgKyAoYyA/IFwiV2lkdGhcIiA6IFwiSGVpZ2h0XCIpXSAvIGc7XG4gICAgICAgIH07XG5cbiAgICAgICAgZSgpO1xuICAgICAgICBhID0gQjtcblxuICAgICAgICBpZiAoYSA8IHQubWluKSB7XG4gICAgICAgICAgYSA9IHQubWluO1xuICAgICAgICAgIHZhciBWID0gITA7XG4gICAgICAgIH0gZWxzZSBhICsgeCA+IHQubWF4ICYmIChhID0gdC5tYXggLSB4LCBWID0gITApO1xuXG4gICAgICAgIFYgPyAoeSAtPSAuOCAqICh5IC0gaFtsXVswXSksIFwibnVtYmVyXCIgPT09IHR5cGVvZiBGICYmIChGIC09IC44ICogKEYgLSBoW2xdWzFdKSksIGUoKSkgOiBoW2xdID0gW3ksIEZdO1xuICAgICAgICB6IHx8IChuW2xdID0gQiAtIHcsIG5bYl0gPSB4KTtcbiAgICAgICAgbiA9IHogPyAxIC8gZyA6IGc7XG4gICAgICAgIGtbYl0gPSB4O1xuICAgICAgICBrW2xdID0gYTtcbiAgICAgICAgZFt6ID8gYyA/IFwic2NhbGVZXCIgOiBcInNjYWxlWFwiIDogXCJzY2FsZVwiICsgdl0gPSBnO1xuICAgICAgICBkW1widHJhbnNsYXRlXCIgKyB2XSA9IG4gKiB3ICsgKHkgLSBuICogTCk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIHZhciBmID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGUgPSBmLmhvdmVyU2VyaWVzLFxuICAgICAgICAgICAgZCA9IGYuaG92ZXJQb2ludCxcbiAgICAgICAgICAgIGsgPSBmLmhvdmVyUG9pbnRzLFxuICAgICAgICAgICAgbiA9IGYudG9vbHRpcCxcbiAgICAgICAgICAgIGggPSBuICYmIG4uc2hhcmVkID8gayA6IGQ7XG4gICAgICAgIGMgJiYgaCAmJiBQKGgpLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhLnNlcmllcy5pc0NhcnRlc2lhbiAmJiBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgYS5wbG90WCAmJiAoYyA9ICExKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjKSBuICYmIGggJiYgUChoKS5sZW5ndGggJiYgKG4ucmVmcmVzaChoKSwgbi5zaGFyZWQgJiYgayA/IGsuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEuc2V0U3RhdGUoYS5zdGF0ZSwgITApO1xuICAgICAgICAgIGEuc2VyaWVzLmlzQ2FydGVzaWFuICYmIChhLnNlcmllcy54QXhpcy5jcm9zc2hhaXIgJiYgYS5zZXJpZXMueEF4aXMuZHJhd0Nyb3NzaGFpcihudWxsLCBhKSwgYS5zZXJpZXMueUF4aXMuY3Jvc3NoYWlyICYmIGEuc2VyaWVzLnlBeGlzLmRyYXdDcm9zc2hhaXIobnVsbCwgYSkpO1xuICAgICAgICB9KSA6IGQgJiYgKGQuc2V0U3RhdGUoZC5zdGF0ZSwgITApLCBmLmF4ZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEuY3Jvc3NoYWlyICYmIGQuc2VyaWVzW2EuY29sbF0gPT09IGEgJiYgYS5kcmF3Q3Jvc3NoYWlyKG51bGwsIGQpO1xuICAgICAgICB9KSkpO2Vsc2Uge1xuICAgICAgICAgIGlmIChkKSBkLm9uTW91c2VPdXQoKTtcbiAgICAgICAgICBrICYmIGsuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYS5zZXRTdGF0ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChlKSBlLm9uTW91c2VPdXQoKTtcbiAgICAgICAgICBuICYmIG4uaGlkZShhKTtcbiAgICAgICAgICB0aGlzLnVuRG9jTW91c2VNb3ZlICYmICh0aGlzLnVuRG9jTW91c2VNb3ZlID0gdGhpcy51bkRvY01vdXNlTW92ZSgpKTtcbiAgICAgICAgICBmLmF4ZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYS5oaWRlQ3Jvc3NoYWlyKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5ob3ZlclggPSBmLmhvdmVyUG9pbnRzID0gZi5ob3ZlclBvaW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUucnVuUG9pbnRBY3Rpb25zID0gZnVuY3Rpb24gKGYsIGEpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgayA9IGUudG9vbHRpcCAmJiBlLnRvb2x0aXAub3B0aW9ucy5lbmFibGVkID8gZS50b29sdGlwIDogdm9pZCAwLFxuICAgICAgICAgICAgbiA9IGsgPyBrLnNoYXJlZCA6ICExLFxuICAgICAgICAgICAgaCA9IGEgfHwgZS5ob3ZlclBvaW50LFxuICAgICAgICAgICAgZyA9IGggJiYgaC5zZXJpZXMgfHwgZS5ob3ZlclNlcmllcztcbiAgICAgICAgZyA9IHRoaXMuZ2V0SG92ZXJEYXRhKGgsIGcsIGUuc2VyaWVzLCAoIWYgfHwgXCJ0b3VjaG1vdmVcIiAhPT0gZi50eXBlKSAmJiAoISFhIHx8IGcgJiYgZy5kaXJlY3RUb3VjaCAmJiB0aGlzLmlzRGlyZWN0VG91Y2gpLCBuLCBmKTtcbiAgICAgICAgaCA9IGcuaG92ZXJQb2ludDtcbiAgICAgICAgdmFyIHQgPSBnLmhvdmVyUG9pbnRzO1xuICAgICAgICBhID0gKGcgPSBnLmhvdmVyU2VyaWVzKSAmJiBnLnRvb2x0aXBPcHRpb25zLmZvbGxvd1BvaW50ZXI7XG4gICAgICAgIG4gPSBuICYmIGcgJiYgIWcubm9TaGFyZWRUb29sdGlwO1xuXG4gICAgICAgIGlmIChoICYmIChoICE9PSBlLmhvdmVyUG9pbnQgfHwgayAmJiBrLmlzSGlkZGVuKSkge1xuICAgICAgICAgIChlLmhvdmVyUG9pbnRzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAtMSA9PT0gdC5pbmRleE9mKGEpICYmIGEuc2V0U3RhdGUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoZS5ob3ZlclNlcmllcyAhPT0gZykgZy5vbk1vdXNlT3ZlcigpO1xuICAgICAgICAgIHRoaXMuYXBwbHlJbmFjdGl2ZVN0YXRlKHQpO1xuICAgICAgICAgICh0IHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBhLnNldFN0YXRlKFwiaG92ZXJcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZS5ob3ZlclBvaW50ICYmIGUuaG92ZXJQb2ludC5maXJlUG9pbnRFdmVudChcIm1vdXNlT3V0XCIpO1xuICAgICAgICAgIGlmICghaC5zZXJpZXMpIHJldHVybjtcbiAgICAgICAgICBoLmZpcmVQb2ludEV2ZW50KFwibW91c2VPdmVyXCIpO1xuICAgICAgICAgIGUuaG92ZXJQb2ludHMgPSB0O1xuICAgICAgICAgIGUuaG92ZXJQb2ludCA9IGg7XG4gICAgICAgICAgayAmJiBrLnJlZnJlc2gobiA/IHQgOiBoLCBmKTtcbiAgICAgICAgfSBlbHNlIGEgJiYgayAmJiAhay5pc0hpZGRlbiAmJiAoaCA9IGsuZ2V0QW5jaG9yKFt7fV0sIGYpLCBrLnVwZGF0ZVBvc2l0aW9uKHtcbiAgICAgICAgICBwbG90WDogaFswXSxcbiAgICAgICAgICBwbG90WTogaFsxXVxuICAgICAgICB9KSk7XG5cbiAgICAgICAgdGhpcy51bkRvY01vdXNlTW92ZSB8fCAodGhpcy51bkRvY01vdXNlTW92ZSA9IEkoZS5jb250YWluZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICB2YXIgZiA9IGNbZC5ob3ZlckNoYXJ0SW5kZXhdO1xuICAgICAgICAgIGlmIChmKSBmLnBvaW50ZXIub25Eb2N1bWVudE1vdXNlTW92ZShhKTtcbiAgICAgICAgfSkpO1xuICAgICAgICBlLmF4ZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHZhciBjID0gcShhLmNyb3NzaGFpci5zbmFwLCAhMCksXG4gICAgICAgICAgICAgIGUgPSBjID8gSih0LCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIGMuc2VyaWVzW2EuY29sbF0gPT09IGE7XG4gICAgICAgICAgfSkgOiB2b2lkIDA7XG4gICAgICAgICAgZSB8fCAhYyA/IGEuZHJhd0Nyb3NzaGFpcihmLCBlKSA6IGEuaGlkZUNyb3NzaGFpcigpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLnNjYWxlR3JvdXBzID0gZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgdmFyIGYgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZTtcbiAgICAgICAgZi5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGUgPSBjIHx8IGQuZ2V0UGxvdEJveCgpO1xuICAgICAgICAgIGQueEF4aXMgJiYgZC54QXhpcy56b29tRW5hYmxlZCAmJiBkLmdyb3VwICYmIChkLmdyb3VwLmF0dHIoZSksIGQubWFya2VyR3JvdXAgJiYgKGQubWFya2VyR3JvdXAuYXR0cihlKSwgZC5tYXJrZXJHcm91cC5jbGlwKGEgPyBmLmNsaXBSZWN0IDogbnVsbCkpLCBkLmRhdGFMYWJlbHNHcm91cCAmJiBkLmRhdGFMYWJlbHNHcm91cC5hdHRyKGUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGYuY2xpcFJlY3QuYXR0cihhIHx8IGYuY2xpcEJveCk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5zZXRET01FdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjID0gdGhpcyxcbiAgICAgICAgICAgIGEgPSBjLmNoYXJ0LmNvbnRhaW5lcixcbiAgICAgICAgICAgIGUgPSBhLm93bmVyRG9jdW1lbnQ7XG5cbiAgICAgICAgYS5vbm1vdXNlZG93biA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYy5vbkNvbnRhaW5lck1vdXNlRG93bihhKTtcbiAgICAgICAgfTtcblxuICAgICAgICBhLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBjLm9uQ29udGFpbmVyTW91c2VNb3ZlKGEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGEub25jbGljayA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYy5vbkNvbnRhaW5lckNsaWNrKGEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudW5iaW5kQ29udGFpbmVyTW91c2VMZWF2ZSA9IEkoYSwgXCJtb3VzZWxlYXZlXCIsIGMub25Db250YWluZXJNb3VzZUxlYXZlKTtcbiAgICAgICAgZC51bmJpbmREb2N1bWVudE1vdXNlVXAgfHwgKGQudW5iaW5kRG9jdW1lbnRNb3VzZVVwID0gSShlLCBcIm1vdXNldXBcIiwgYy5vbkRvY3VtZW50TW91c2VVcCkpO1xuICAgICAgICBkLmhhc1RvdWNoICYmIChJKGEsIFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGMub25Db250YWluZXJUb3VjaFN0YXJ0KGEpO1xuICAgICAgICB9KSwgSShhLCBcInRvdWNobW92ZVwiLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGMub25Db250YWluZXJUb3VjaE1vdmUoYSk7XG4gICAgICAgIH0pLCBkLnVuYmluZERvY3VtZW50VG91Y2hFbmQgfHwgKGQudW5iaW5kRG9jdW1lbnRUb3VjaEVuZCA9IEkoZSwgXCJ0b3VjaGVuZFwiLCBjLm9uRG9jdW1lbnRUb3VjaEVuZCkpKTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLnRvdWNoID0gZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgdmFyIGYgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZTtcbiAgICAgICAgaWYgKGYuaW5kZXggIT09IGQuaG92ZXJDaGFydEluZGV4KSB0aGlzLm9uQ29udGFpbmVyTW91c2VMZWF2ZSh7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogITBcbiAgICAgICAgfSk7XG4gICAgICAgIGQuaG92ZXJDaGFydEluZGV4ID0gZi5pbmRleDtcbiAgICAgICAgaWYgKDEgPT09IGMudG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoYyA9IHRoaXMubm9ybWFsaXplKGMpLCAoZSA9IGYuaXNJbnNpZGVQbG90KGMuY2hhcnRYIC0gZi5wbG90TGVmdCwgYy5jaGFydFkgLSBmLnBsb3RUb3ApKSAmJiAhZi5vcGVuTWVudSkge1xuICAgICAgICAgICAgYSAmJiB0aGlzLnJ1blBvaW50QWN0aW9ucyhjKTtcblxuICAgICAgICAgICAgaWYgKFwidG91Y2htb3ZlXCIgPT09IGMudHlwZSkge1xuICAgICAgICAgICAgICBhID0gdGhpcy5waW5jaERvd247XG4gICAgICAgICAgICAgIHZhciBrID0gYVswXSA/IDQgPD0gTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0uY2hhcnRYIC0gYy5jaGFydFgsIDIpICsgTWF0aC5wb3coYVswXS5jaGFydFkgLSBjLmNoYXJ0WSwgMikpIDogITE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHEoaywgITApICYmIHRoaXMucGluY2goYyk7XG4gICAgICAgICAgfSBlbHNlIGEgJiYgdGhpcy5yZXNldCgpO1xuICAgICAgICB9IGVsc2UgMiA9PT0gYy50b3VjaGVzLmxlbmd0aCAmJiB0aGlzLnBpbmNoKGMpO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUuem9vbU9wdGlvbiA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGYgPSBhLm9wdGlvbnMuY2hhcnQsXG4gICAgICAgICAgICBlID0gZi56b29tVHlwZSB8fCBcIlwiO1xuICAgICAgICBhID0gYS5pbnZlcnRlZDtcbiAgICAgICAgL3RvdWNoLy50ZXN0KGMudHlwZSkgJiYgKGUgPSBxKGYucGluY2hUeXBlLCBlKSk7XG4gICAgICAgIHRoaXMuem9vbVggPSBjID0gL3gvLnRlc3QoZSk7XG4gICAgICAgIHRoaXMuem9vbVkgPSBlID0gL3kvLnRlc3QoZSk7XG4gICAgICAgIHRoaXMuem9vbUhvciA9IGMgJiYgIWEgfHwgZSAmJiBhO1xuICAgICAgICB0aGlzLnpvb21WZXJ0ID0gZSAmJiAhYSB8fCBjICYmIGE7XG4gICAgICAgIHRoaXMuaGFzWm9vbSA9IGMgfHwgZTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBuO1xuICAgIH0oKTtcblxuICAgIGQuUG9pbnRlciA9IGc7XG4gICAgcmV0dXJuIGQuUG9pbnRlcjtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9NU1BvaW50ZXIuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvUG9pbnRlci5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnLCByKSB7XG4gICAgZnVuY3Rpb24gdSgpIHtcbiAgICAgIHZhciBkID0gW107XG5cbiAgICAgIGQuaXRlbSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2RdO1xuICAgICAgfTtcblxuICAgICAgRyhoLCBmdW5jdGlvbiAoaCkge1xuICAgICAgICBkLnB1c2goe1xuICAgICAgICAgIHBhZ2VYOiBoLnBhZ2VYLFxuICAgICAgICAgIHBhZ2VZOiBoLnBhZ2VZLFxuICAgICAgICAgIHRhcmdldDogaC50YXJnZXRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEkoaCwgZywgZSwgYykge1xuICAgICAgXCJ0b3VjaFwiICE9PSBoLnBvaW50ZXJUeXBlICYmIGgucG9pbnRlclR5cGUgIT09IGguTVNQT0lOVEVSX1RZUEVfVE9VQ0ggfHwgIXlbZC5ob3ZlckNoYXJ0SW5kZXhdIHx8IChjKGgpLCBjID0geVtkLmhvdmVyQ2hhcnRJbmRleF0ucG9pbnRlciwgY1tnXSh7XG4gICAgICAgIHR5cGU6IGUsXG4gICAgICAgIHRhcmdldDogaC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogRCxcbiAgICAgICAgdG91Y2hlczogdSgpXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgdmFyIE0gPSB0aGlzICYmIHRoaXMuX19leHRlbmRzIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkID0gZnVuY3Rpb24gKGgsIGUpIHtcbiAgICAgICAgZCA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgICAgICAgX19wcm90b19fOiBbXVxuICAgICAgICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGMsIGUpIHtcbiAgICAgICAgICBjLl9fcHJvdG9fXyA9IGU7XG4gICAgICAgIH0gfHwgZnVuY3Rpb24gKGMsIGUpIHtcbiAgICAgICAgICBmb3IgKHZhciBkIGluIGUpIGUuaGFzT3duUHJvcGVydHkoZCkgJiYgKGNbZF0gPSBlW2RdKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZChoLCBlKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoaCwgZSkge1xuICAgICAgICBmdW5jdGlvbiBjKCkge1xuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBoO1xuICAgICAgICB9XG5cbiAgICAgICAgZChoLCBlKTtcbiAgICAgICAgaC5wcm90b3R5cGUgPSBudWxsID09PSBlID8gT2JqZWN0LmNyZWF0ZShlKSA6IChjLnByb3RvdHlwZSA9IGUucHJvdG90eXBlLCBuZXcgYygpKTtcbiAgICAgIH07XG4gICAgfSgpLFxuICAgICAgICBFID0gci5hZGRFdmVudCxcbiAgICAgICAgQSA9IHIuY3NzLFxuICAgICAgICBHID0gci5vYmplY3RFYWNoLFxuICAgICAgICBKID0gci5yZW1vdmVFdmVudCxcbiAgICAgICAgeSA9IGQuY2hhcnRzLFxuICAgICAgICB0ID0gZC5kb2MsXG4gICAgICAgIEQgPSBkLm5vb3AsXG4gICAgICAgIGggPSB7fSxcbiAgICAgICAgTiA9ICEhZC53aW4uUG9pbnRlckV2ZW50O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgICBmdW5jdGlvbiBnKCkge1xuICAgICAgICByZXR1cm4gbnVsbCAhPT0gZCAmJiBkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgIH1cblxuICAgICAgTShnLCBkKTtcblxuICAgICAgZy5wcm90b3R5cGUuYmF0Y2hNU0V2ZW50cyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUodGhpcy5jaGFydC5jb250YWluZXIsIE4gPyBcInBvaW50ZXJkb3duXCIgOiBcIk1TUG9pbnRlckRvd25cIiwgdGhpcy5vbkNvbnRhaW5lclBvaW50ZXJEb3duKTtcbiAgICAgICAgZSh0aGlzLmNoYXJ0LmNvbnRhaW5lciwgTiA/IFwicG9pbnRlcm1vdmVcIiA6IFwiTVNQb2ludGVyTW92ZVwiLCB0aGlzLm9uQ29udGFpbmVyUG9pbnRlck1vdmUpO1xuICAgICAgICBlKHQsIE4gPyBcInBvaW50ZXJ1cFwiIDogXCJNU1BvaW50ZXJVcFwiLCB0aGlzLm9uRG9jdW1lbnRQb2ludGVyVXApO1xuICAgICAgfTtcblxuICAgICAgZy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5iYXRjaE1TRXZlbnRzKEopO1xuICAgICAgICBkLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICB9O1xuXG4gICAgICBnLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGUsIGMpIHtcbiAgICAgICAgZC5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGUsIGMpO1xuICAgICAgICB0aGlzLmhhc1pvb20gJiYgQShlLmNvbnRhaW5lciwge1xuICAgICAgICAgIFwiLW1zLXRvdWNoLWFjdGlvblwiOiBcIm5vbmVcIixcbiAgICAgICAgICBcInRvdWNoLWFjdGlvblwiOiBcIm5vbmVcIlxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGcucHJvdG90eXBlLm9uQ29udGFpbmVyUG9pbnRlckRvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBJKGUsIFwib25Db250YWluZXJUb3VjaFN0YXJ0XCIsIFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGhbYy5wb2ludGVySWRdID0ge1xuICAgICAgICAgICAgcGFnZVg6IGMucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogYy5wYWdlWSxcbiAgICAgICAgICAgIHRhcmdldDogYy5jdXJyZW50VGFyZ2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBnLnByb3RvdHlwZS5vbkNvbnRhaW5lclBvaW50ZXJNb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgSShlLCBcIm9uQ29udGFpbmVyVG91Y2hNb3ZlXCIsIFwidG91Y2htb3ZlXCIsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgaFtjLnBvaW50ZXJJZF0gPSB7XG4gICAgICAgICAgICBwYWdlWDogYy5wYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZOiBjLnBhZ2VZXG4gICAgICAgICAgfTtcbiAgICAgICAgICBoW2MucG9pbnRlcklkXS50YXJnZXQgfHwgKGhbYy5wb2ludGVySWRdLnRhcmdldCA9IGMuY3VycmVudFRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZy5wcm90b3R5cGUub25Eb2N1bWVudFBvaW50ZXJVcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIEkoZSwgXCJvbkRvY3VtZW50VG91Y2hFbmRcIiwgXCJ0b3VjaGVuZFwiLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGRlbGV0ZSBoW2MucG9pbnRlcklkXTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBnLnByb3RvdHlwZS5zZXRET01FdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGQucHJvdG90eXBlLnNldERPTUV2ZW50cy5jYWxsKHRoaXMpO1xuICAgICAgICAodGhpcy5oYXNab29tIHx8IHRoaXMuZm9sbG93VG91Y2hNb3ZlKSAmJiB0aGlzLmJhdGNoTVNFdmVudHMoRSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZztcbiAgICB9KGcpO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL0xlZ2VuZC5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZykge1xuICAgIHZhciByID0gZy5hZGRFdmVudCxcbiAgICAgICAgdSA9IGcuY3NzLFxuICAgICAgICBJID0gZy5kZWZpbmVkLFxuICAgICAgICBNID0gZy5kaXNjYXJkRWxlbWVudCxcbiAgICAgICAgRSA9IGcuZmluZCxcbiAgICAgICAgQSA9IGcuZmlyZUV2ZW50LFxuICAgICAgICBHID0gZy5mb3JtYXQsXG4gICAgICAgIEogPSBnLmlzTnVtYmVyLFxuICAgICAgICB5ID0gZy5tZXJnZSxcbiAgICAgICAgdCA9IGcucGljayxcbiAgICAgICAgRCA9IGcucmVsYXRpdmVMZW5ndGgsXG4gICAgICAgIGggPSBnLnNldEFuaW1hdGlvbixcbiAgICAgICAgTiA9IGcuc3RhYmxlU29ydCxcbiAgICAgICAgcSA9IGcuc3luY1RpbWVvdXQ7XG4gICAgZyA9IGcud3JhcDtcblxuICAgIHZhciBQID0gZC5pc0ZpcmVmb3gsXG4gICAgICAgIGUgPSBkLm1hcmdpbk5hbWVzLFxuICAgICAgICBjID0gZC53aW4sXG4gICAgICAgIGsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBjKGMsIGEpIHtcbiAgICAgICAgdGhpcy5hbGxJdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbnRlbnRHcm91cCA9IHRoaXMuYm94ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmRpc3BsYXkgPSAhMTtcbiAgICAgICAgdGhpcy5ncm91cCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5vZmZzZXRXaWR0aCA9IHRoaXMubWF4TGVnZW5kV2lkdGggPSB0aGlzLm1heEl0ZW1XaWR0aCA9IHRoaXMubGVnZW5kV2lkdGggPSB0aGlzLmxlZ2VuZEhlaWdodCA9IHRoaXMubGFzdExpbmVIZWlnaHQgPSB0aGlzLmxhc3RJdGVtWSA9IHRoaXMuaXRlbVkgPSB0aGlzLml0ZW1YID0gdGhpcy5pdGVtTWFyZ2luVG9wID0gdGhpcy5pdGVtTWFyZ2luQm90dG9tID0gdGhpcy5pdGVtSGVpZ2h0ID0gdGhpcy5pbml0aWFsSXRlbVkgPSAwO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gMDtcbiAgICAgICAgdGhpcy5wYWdlcyA9IFtdO1xuICAgICAgICB0aGlzLnByb3hpbWF0ZSA9ICExO1xuICAgICAgICB0aGlzLnNjcm9sbEdyb3VwID0gdm9pZCAwO1xuICAgICAgICB0aGlzLndpZHRoT3B0aW9uID0gdGhpcy50b3RhbEl0ZW1XaWR0aCA9IHRoaXMudGl0bGVIZWlnaHQgPSB0aGlzLnN5bWJvbFdpZHRoID0gdGhpcy5zeW1ib2xIZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLmNoYXJ0ID0gYztcbiAgICAgICAgdGhpcy5pbml0KGMsIGEpO1xuICAgICAgfVxuXG4gICAgICBjLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgdGhpcy5jaGFydCA9IGM7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhhKTtcbiAgICAgICAgYS5lbmFibGVkICYmICh0aGlzLnJlbmRlcigpLCByKHRoaXMuY2hhcnQsIFwiZW5kUmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLmxlZ2VuZC5wb3NpdGlvbkNoZWNrYm94ZXMoKTtcbiAgICAgICAgfSksIHRoaXMucHJveGltYXRlID8gdGhpcy51bmNoYXJ0cmVuZGVyID0gcih0aGlzLmNoYXJ0LCBcInJlbmRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5sZWdlbmQucHJveGltYXRlUG9zaXRpb25zKCk7XG4gICAgICAgICAgdGhpcy5sZWdlbmQucG9zaXRpb25JdGVtcygpO1xuICAgICAgICB9KSA6IHRoaXMudW5jaGFydHJlbmRlciAmJiB0aGlzLnVuY2hhcnRyZW5kZXIoKSk7XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGEgPSB0KGMucGFkZGluZywgOCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGM7XG4gICAgICAgIHRoaXMuY2hhcnQuc3R5bGVkTW9kZSB8fCAodGhpcy5pdGVtU3R5bGUgPSBjLml0ZW1TdHlsZSwgdGhpcy5pdGVtSGlkZGVuU3R5bGUgPSB5KHRoaXMuaXRlbVN0eWxlLCBjLml0ZW1IaWRkZW5TdHlsZSkpO1xuICAgICAgICB0aGlzLml0ZW1NYXJnaW5Ub3AgPSBjLml0ZW1NYXJnaW5Ub3AgfHwgMDtcbiAgICAgICAgdGhpcy5pdGVtTWFyZ2luQm90dG9tID0gYy5pdGVtTWFyZ2luQm90dG9tIHx8IDA7XG4gICAgICAgIHRoaXMucGFkZGluZyA9IGE7XG4gICAgICAgIHRoaXMuaW5pdGlhbEl0ZW1ZID0gYSAtIDU7XG4gICAgICAgIHRoaXMuc3ltYm9sV2lkdGggPSB0KGMuc3ltYm9sV2lkdGgsIDE2KTtcbiAgICAgICAgdGhpcy5wYWdlcyA9IFtdO1xuICAgICAgICB0aGlzLnByb3hpbWF0ZSA9IFwicHJveGltYXRlXCIgPT09IGMubGF5b3V0ICYmICF0aGlzLmNoYXJ0LmludmVydGVkO1xuICAgICAgICB0aGlzLmJhc2VsaW5lID0gdm9pZCAwO1xuICAgICAgfTtcblxuICAgICAgYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgdmFyIGYgPSB0aGlzLmNoYXJ0O1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMoeSghMCwgdGhpcy5vcHRpb25zLCBjKSk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICBmLmlzRGlydHlMZWdlbmQgPSBmLmlzRGlydHlCb3ggPSAhMDtcbiAgICAgICAgdChhLCAhMCkgJiYgZi5yZWRyYXcoKTtcbiAgICAgICAgQSh0aGlzLCBcImFmdGVyVXBkYXRlXCIpO1xuICAgICAgfTtcblxuICAgICAgYy5wcm90b3R5cGUuY29sb3JpemVJdGVtID0gZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgYy5sZWdlbmRHcm91cFthID8gXCJyZW1vdmVDbGFzc1wiIDogXCJhZGRDbGFzc1wiXShcImhpZ2hjaGFydHMtbGVnZW5kLWl0ZW0taGlkZGVuXCIpO1xuXG4gICAgICAgIGlmICghdGhpcy5jaGFydC5zdHlsZWRNb2RlKSB7XG4gICAgICAgICAgdmFyIGYgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAgIGUgPSBjLmxlZ2VuZEl0ZW0sXG4gICAgICAgICAgICAgIGQgPSBjLmxlZ2VuZExpbmUsXG4gICAgICAgICAgICAgIGsgPSBjLmxlZ2VuZFN5bWJvbCxcbiAgICAgICAgICAgICAgaCA9IHRoaXMuaXRlbUhpZGRlblN0eWxlLmNvbG9yO1xuICAgICAgICAgIGYgPSBhID8gZi5pdGVtU3R5bGUuY29sb3IgOiBoO1xuICAgICAgICAgIHZhciBuID0gYSA/IGMuY29sb3IgfHwgaCA6IGgsXG4gICAgICAgICAgICAgIGcgPSBjLm9wdGlvbnMgJiYgYy5vcHRpb25zLm1hcmtlcixcbiAgICAgICAgICAgICAgcSA9IHtcbiAgICAgICAgICAgIGZpbGw6IG5cbiAgICAgICAgICB9O1xuICAgICAgICAgIGUgJiYgZS5jc3Moe1xuICAgICAgICAgICAgZmlsbDogZixcbiAgICAgICAgICAgIGNvbG9yOiBmXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZCAmJiBkLmF0dHIoe1xuICAgICAgICAgICAgc3Ryb2tlOiBuXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgayAmJiAoZyAmJiBrLmlzTWFya2VyICYmIChxID0gYy5wb2ludEF0dHJpYnMoKSwgYSB8fCAocS5zdHJva2UgPSBxLmZpbGwgPSBoKSksIGsuYXR0cihxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBBKHRoaXMsIFwiYWZ0ZXJDb2xvcml6ZUl0ZW1cIiwge1xuICAgICAgICAgIGl0ZW06IGMsXG4gICAgICAgICAgdmlzaWJsZTogYVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGMucHJvdG90eXBlLnBvc2l0aW9uSXRlbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWxsSXRlbXMuZm9yRWFjaCh0aGlzLnBvc2l0aW9uSXRlbSwgdGhpcyk7XG4gICAgICAgIHRoaXMuY2hhcnQuaXNSZXNpemluZyB8fCB0aGlzLnBvc2l0aW9uQ2hlY2tib3hlcygpO1xuICAgICAgfTtcblxuICAgICAgYy5wcm90b3R5cGUucG9zaXRpb25JdGVtID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBmID0gYS5zeW1ib2xQYWRkaW5nO1xuICAgICAgICBhID0gIWEucnRsO1xuICAgICAgICB2YXIgZSA9IGMuX2xlZ2VuZEl0ZW1Qb3MsXG4gICAgICAgICAgICBkID0gZVswXTtcbiAgICAgICAgZSA9IGVbMV07XG4gICAgICAgIHZhciBrID0gYy5jaGVja2JveDtcbiAgICAgICAgaWYgKChjID0gYy5sZWdlbmRHcm91cCkgJiYgYy5lbGVtZW50KSBjW0koYy50cmFuc2xhdGVZKSA/IFwiYW5pbWF0ZVwiIDogXCJhdHRyXCJdKHtcbiAgICAgICAgICB0cmFuc2xhdGVYOiBhID8gZCA6IHRoaXMubGVnZW5kV2lkdGggLSBkIC0gMiAqIGYgLSA0LFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IGVcbiAgICAgICAgfSk7XG4gICAgICAgIGsgJiYgKGsueCA9IGQsIGsueSA9IGUpO1xuICAgICAgfTtcblxuICAgICAgYy5wcm90b3R5cGUuZGVzdHJveUl0ZW0gPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgYSA9IGMuY2hlY2tib3g7XG4gICAgICAgIFtcImxlZ2VuZEl0ZW1cIiwgXCJsZWdlbmRMaW5lXCIsIFwibGVnZW5kU3ltYm9sXCIsIFwibGVnZW5kR3JvdXBcIl0uZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGNbYV0gJiYgKGNbYV0gPSBjW2FdLmRlc3Ryb3koKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhICYmIE0oYy5jaGVja2JveCk7XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBjKGEpIHtcbiAgICAgICAgICB0aGlzW2FdICYmICh0aGlzW2FdID0gdGhpc1thXS5kZXN0cm95KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nZXRBbGxJdGVtcygpLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBbXCJsZWdlbmRJdGVtXCIsIFwibGVnZW5kR3JvdXBcIl0uZm9yRWFjaChjLCBhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFwiY2xpcFJlY3QgdXAgZG93biBwYWdlciBuYXYgYm94IHRpdGxlIGdyb3VwXCIuc3BsaXQoXCIgXCIpLmZvckVhY2goYywgdGhpcyk7XG4gICAgICAgIHRoaXMuZGlzcGxheSA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZS5wb3NpdGlvbkNoZWNrYm94ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLmFsaWduQXR0cixcbiAgICAgICAgICAgIGEgPSB0aGlzLmNsaXBIZWlnaHQgfHwgdGhpcy5sZWdlbmRIZWlnaHQsXG4gICAgICAgICAgICBlID0gdGhpcy50aXRsZUhlaWdodDtcblxuICAgICAgICBpZiAoYykge1xuICAgICAgICAgIHZhciBkID0gYy50cmFuc2xhdGVZO1xuICAgICAgICAgIHRoaXMuYWxsSXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgdmFyIGsgPSBmLmNoZWNrYm94O1xuXG4gICAgICAgICAgICBpZiAoaykge1xuICAgICAgICAgICAgICB2YXIgbCA9IGQgKyBlICsgay55ICsgKHRoaXMuc2Nyb2xsT2Zmc2V0IHx8IDApICsgMztcbiAgICAgICAgICAgICAgdShrLCB7XG4gICAgICAgICAgICAgICAgbGVmdDogYy50cmFuc2xhdGVYICsgZi5jaGVja2JveE9mZnNldCArIGsueCAtIDIwICsgXCJweFwiLFxuICAgICAgICAgICAgICAgIHRvcDogbCArIFwicHhcIixcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiB0aGlzLnByb3hpbWF0ZSB8fCBsID4gZCAtIDYgJiYgbCA8IGQgKyBhIC0gNiA/IFwiXCIgOiBcIm5vbmVcIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgYy5wcm90b3R5cGUucmVuZGVyVGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgYSA9IHRoaXMucGFkZGluZyxcbiAgICAgICAgICAgIGUgPSBjLnRpdGxlLFxuICAgICAgICAgICAgZCA9IDA7XG4gICAgICAgIGUudGV4dCAmJiAodGhpcy50aXRsZSB8fCAodGhpcy50aXRsZSA9IHRoaXMuY2hhcnQucmVuZGVyZXIubGFiZWwoZS50ZXh0LCBhIC0gMywgYSAtIDQsIG51bGwsIG51bGwsIG51bGwsIGMudXNlSFRNTCwgbnVsbCwgXCJsZWdlbmQtdGl0bGVcIikuYXR0cih7XG4gICAgICAgICAgekluZGV4OiAxXG4gICAgICAgIH0pLCB0aGlzLmNoYXJ0LnN0eWxlZE1vZGUgfHwgdGhpcy50aXRsZS5jc3MoZS5zdHlsZSksIHRoaXMudGl0bGUuYWRkKHRoaXMuZ3JvdXApKSwgZS53aWR0aCB8fCB0aGlzLnRpdGxlLmNzcyh7XG4gICAgICAgICAgd2lkdGg6IHRoaXMubWF4TGVnZW5kV2lkdGggKyBcInB4XCJcbiAgICAgICAgfSksIGMgPSB0aGlzLnRpdGxlLmdldEJCb3goKSwgZCA9IGMuaGVpZ2h0LCB0aGlzLm9mZnNldFdpZHRoID0gYy53aWR0aCwgdGhpcy5jb250ZW50R3JvdXAuYXR0cih7XG4gICAgICAgICAgdHJhbnNsYXRlWTogZFxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMudGl0bGVIZWlnaHQgPSBkO1xuICAgICAgfTtcblxuICAgICAgYy5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjLmxlZ2VuZEl0ZW0uYXR0cih7XG4gICAgICAgICAgdGV4dDogYS5sYWJlbEZvcm1hdCA/IEcoYS5sYWJlbEZvcm1hdCwgYywgdGhpcy5jaGFydCkgOiBhLmxhYmVsRm9ybWF0dGVyLmNhbGwoYylcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZS5yZW5kZXJJdGVtID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZSA9IGEucmVuZGVyZXIsXG4gICAgICAgICAgICBmID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgZCA9IHRoaXMuc3ltYm9sV2lkdGgsXG4gICAgICAgICAgICBrID0gZi5zeW1ib2xQYWRkaW5nLFxuICAgICAgICAgICAgaCA9IHRoaXMuaXRlbVN0eWxlLFxuICAgICAgICAgICAgbiA9IHRoaXMuaXRlbUhpZGRlblN0eWxlLFxuICAgICAgICAgICAgZyA9IFwiaG9yaXpvbnRhbFwiID09PSBmLmxheW91dCA/IHQoZi5pdGVtRGlzdGFuY2UsIDIwKSA6IDAsXG4gICAgICAgICAgICBxID0gIWYucnRsLFxuICAgICAgICAgICAgSyA9IGMubGVnZW5kSXRlbSxcbiAgICAgICAgICAgIHAgPSAhYy5zZXJpZXMsXG4gICAgICAgICAgICBiID0gIXAgJiYgYy5zZXJpZXMuZHJhd0xlZ2VuZFN5bWJvbCA/IGMuc2VyaWVzIDogYyxcbiAgICAgICAgICAgIEMgPSBiLm9wdGlvbnM7XG4gICAgICAgIEMgPSB0aGlzLmNyZWF0ZUNoZWNrYm94Rm9ySXRlbSAmJiBDICYmIEMuc2hvd0NoZWNrYm94O1xuICAgICAgICBnID0gZCArIGsgKyBnICsgKEMgPyAyMCA6IDApO1xuICAgICAgICB2YXIgeCA9IGYudXNlSFRNTCxcbiAgICAgICAgICAgIFIgPSBjLm9wdGlvbnMuY2xhc3NOYW1lO1xuICAgICAgICBLIHx8IChjLmxlZ2VuZEdyb3VwID0gZS5nKFwibGVnZW5kLWl0ZW1cIikuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLVwiICsgYi50eXBlICsgXCItc2VyaWVzIGhpZ2hjaGFydHMtY29sb3ItXCIgKyBjLmNvbG9ySW5kZXggKyAoUiA/IFwiIFwiICsgUiA6IFwiXCIpICsgKHAgPyBcIiBoaWdoY2hhcnRzLXNlcmllcy1cIiArIGMuaW5kZXggOiBcIlwiKSkuYXR0cih7XG4gICAgICAgICAgekluZGV4OiAxXG4gICAgICAgIH0pLmFkZCh0aGlzLnNjcm9sbEdyb3VwKSwgYy5sZWdlbmRJdGVtID0gSyA9IGUudGV4dChcIlwiLCBxID8gZCArIGsgOiAtaywgdGhpcy5iYXNlbGluZSB8fCAwLCB4KSwgYS5zdHlsZWRNb2RlIHx8IEsuY3NzKHkoYy52aXNpYmxlID8gaCA6IG4pKSwgSy5hdHRyKHtcbiAgICAgICAgICBhbGlnbjogcSA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICAgICAgICAgIHpJbmRleDogMlxuICAgICAgICB9KS5hZGQoYy5sZWdlbmRHcm91cCksIHRoaXMuYmFzZWxpbmUgfHwgKHRoaXMuZm9udE1ldHJpY3MgPSBlLmZvbnRNZXRyaWNzKGEuc3R5bGVkTW9kZSA/IDEyIDogaC5mb250U2l6ZSwgSyksIHRoaXMuYmFzZWxpbmUgPSB0aGlzLmZvbnRNZXRyaWNzLmYgKyAzICsgdGhpcy5pdGVtTWFyZ2luVG9wLCBLLmF0dHIoXCJ5XCIsIHRoaXMuYmFzZWxpbmUpKSwgdGhpcy5zeW1ib2xIZWlnaHQgPSBmLnN5bWJvbEhlaWdodCB8fCB0aGlzLmZvbnRNZXRyaWNzLmYsIGIuZHJhd0xlZ2VuZFN5bWJvbCh0aGlzLCBjKSwgdGhpcy5zZXRJdGVtRXZlbnRzICYmIHRoaXMuc2V0SXRlbUV2ZW50cyhjLCBLLCB4KSk7XG4gICAgICAgIEMgJiYgIWMuY2hlY2tib3ggJiYgdGhpcy5jcmVhdGVDaGVja2JveEZvckl0ZW0gJiYgdGhpcy5jcmVhdGVDaGVja2JveEZvckl0ZW0oYyk7XG4gICAgICAgIHRoaXMuY29sb3JpemVJdGVtKGMsIGMudmlzaWJsZSk7XG4gICAgICAgICFhLnN0eWxlZE1vZGUgJiYgaC53aWR0aCB8fCBLLmNzcyh7XG4gICAgICAgICAgd2lkdGg6IChmLml0ZW1XaWR0aCB8fCB0aGlzLndpZHRoT3B0aW9uIHx8IGEuc3BhY2luZ0JveC53aWR0aCkgLSBnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFRleHQoYyk7XG4gICAgICAgIGEgPSBLLmdldEJCb3goKTtcbiAgICAgICAgYy5pdGVtV2lkdGggPSBjLmNoZWNrYm94T2Zmc2V0ID0gZi5pdGVtV2lkdGggfHwgYy5sZWdlbmRJdGVtV2lkdGggfHwgYS53aWR0aCArIGc7XG4gICAgICAgIHRoaXMubWF4SXRlbVdpZHRoID0gTWF0aC5tYXgodGhpcy5tYXhJdGVtV2lkdGgsIGMuaXRlbVdpZHRoKTtcbiAgICAgICAgdGhpcy50b3RhbEl0ZW1XaWR0aCArPSBjLml0ZW1XaWR0aDtcbiAgICAgICAgdGhpcy5pdGVtSGVpZ2h0ID0gYy5pdGVtSGVpZ2h0ID0gTWF0aC5yb3VuZChjLmxlZ2VuZEl0ZW1IZWlnaHQgfHwgYS5oZWlnaHQgfHwgdGhpcy5zeW1ib2xIZWlnaHQpO1xuICAgICAgfTtcblxuICAgICAgYy5wcm90b3R5cGUubGF5b3V0SXRlbSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgZSA9IHRoaXMucGFkZGluZyxcbiAgICAgICAgICAgIGYgPSBcImhvcml6b250YWxcIiA9PT0gYS5sYXlvdXQsXG4gICAgICAgICAgICBkID0gYy5pdGVtSGVpZ2h0LFxuICAgICAgICAgICAgayA9IHRoaXMuaXRlbU1hcmdpbkJvdHRvbSxcbiAgICAgICAgICAgIGggPSB0aGlzLml0ZW1NYXJnaW5Ub3AsXG4gICAgICAgICAgICBuID0gZiA/IHQoYS5pdGVtRGlzdGFuY2UsIDIwKSA6IDAsXG4gICAgICAgICAgICBnID0gdGhpcy5tYXhMZWdlbmRXaWR0aDtcbiAgICAgICAgYSA9IGEuYWxpZ25Db2x1bW5zICYmIHRoaXMudG90YWxJdGVtV2lkdGggPiBnID8gdGhpcy5tYXhJdGVtV2lkdGggOiBjLml0ZW1XaWR0aDtcbiAgICAgICAgZiAmJiB0aGlzLml0ZW1YIC0gZSArIGEgPiBnICYmICh0aGlzLml0ZW1YID0gZSwgdGhpcy5sYXN0TGluZUhlaWdodCAmJiAodGhpcy5pdGVtWSArPSBoICsgdGhpcy5sYXN0TGluZUhlaWdodCArIGspLCB0aGlzLmxhc3RMaW5lSGVpZ2h0ID0gMCk7XG4gICAgICAgIHRoaXMubGFzdEl0ZW1ZID0gaCArIHRoaXMuaXRlbVkgKyBrO1xuICAgICAgICB0aGlzLmxhc3RMaW5lSGVpZ2h0ID0gTWF0aC5tYXgoZCwgdGhpcy5sYXN0TGluZUhlaWdodCk7XG4gICAgICAgIGMuX2xlZ2VuZEl0ZW1Qb3MgPSBbdGhpcy5pdGVtWCwgdGhpcy5pdGVtWV07XG4gICAgICAgIGYgPyB0aGlzLml0ZW1YICs9IGEgOiAodGhpcy5pdGVtWSArPSBoICsgZCArIGssIHRoaXMubGFzdExpbmVIZWlnaHQgPSBkKTtcbiAgICAgICAgdGhpcy5vZmZzZXRXaWR0aCA9IHRoaXMud2lkdGhPcHRpb24gfHwgTWF0aC5tYXgoKGYgPyB0aGlzLml0ZW1YIC0gZSAtIChjLmNoZWNrYm94ID8gMCA6IG4pIDogYSkgKyBlLCB0aGlzLm9mZnNldFdpZHRoKTtcbiAgICAgIH07XG5cbiAgICAgIGMucHJvdG90eXBlLmdldEFsbEl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYyA9IFtdO1xuICAgICAgICB0aGlzLmNoYXJ0LnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgdmFyIGUgPSBhICYmIGEub3B0aW9ucztcbiAgICAgICAgICBhICYmIHQoZS5zaG93SW5MZWdlbmQsIEkoZS5saW5rZWRUbykgPyAhMSA6IHZvaWQgMCwgITApICYmIChjID0gYy5jb25jYXQoYS5sZWdlbmRJdGVtcyB8fCAoXCJwb2ludFwiID09PSBlLmxlZ2VuZFR5cGUgPyBhLmRhdGEgOiBhKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgQSh0aGlzLCBcImFmdGVyR2V0QWxsSXRlbXNcIiwge1xuICAgICAgICAgIGFsbEl0ZW1zOiBjXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH07XG5cbiAgICAgIGMucHJvdG90eXBlLmdldEFsaWdubWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3hpbWF0ZSA/IGMuYWxpZ24uY2hhckF0KDApICsgXCJ0dlwiIDogYy5mbG9hdGluZyA/IFwiXCIgOiBjLmFsaWduLmNoYXJBdCgwKSArIGMudmVydGljYWxBbGlnbi5jaGFyQXQoMCkgKyBjLmxheW91dC5jaGFyQXQoMCk7XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZS5hZGp1c3RNYXJnaW5zID0gZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgdmFyIGYgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGsgPSB0aGlzLmdldEFsaWdubWVudCgpO1xuICAgICAgICBrICYmIFsvKGx0aHxjdHxydGgpLywgLyhydHZ8cm18cmJ2KS8sIC8ocmJofGNifGxiaCkvLCAvKGxidnxsbXxsdHYpL10uZm9yRWFjaChmdW5jdGlvbiAobCwgaCkge1xuICAgICAgICAgIGwudGVzdChrKSAmJiAhSShjW2hdKSAmJiAoZltlW2hdXSA9IE1hdGgubWF4KGZbZVtoXV0sIGYubGVnZW5kWyhoICsgMSkgJSAyID8gXCJsZWdlbmRIZWlnaHRcIiA6IFwibGVnZW5kV2lkdGhcIl0gKyBbMSwgLTEsIC0xLCAxXVtoXSAqIGRbaCAlIDIgPyBcInhcIiA6IFwieVwiXSArIHQoZC5tYXJnaW4sIDEyKSArIGFbaF0gKyAoZi50aXRsZU9mZnNldFtoXSB8fCAwKSkpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGMucHJvdG90eXBlLnByb3hpbWF0ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgYSA9IFtdLFxuICAgICAgICAgICAgZSA9IFwibGVmdFwiID09PSB0aGlzLm9wdGlvbnMuYWxpZ247XG4gICAgICAgIHRoaXMuYWxsSXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgIHZhciBkID0gZTtcblxuICAgICAgICAgIGlmIChmLnlBeGlzICYmIGYucG9pbnRzKSB7XG4gICAgICAgICAgICBmLnhBeGlzLm9wdGlvbnMucmV2ZXJzZWQgJiYgKGQgPSAhZCk7XG4gICAgICAgICAgICB2YXIgayA9IEUoZCA/IGYucG9pbnRzIDogZi5wb2ludHMuc2xpY2UoMCkucmV2ZXJzZSgpLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICByZXR1cm4gSihhLnBsb3RZKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZCA9IHRoaXMuaXRlbU1hcmdpblRvcCArIGYubGVnZW5kSXRlbS5nZXRCQm94KCkuaGVpZ2h0ICsgdGhpcy5pdGVtTWFyZ2luQm90dG9tO1xuICAgICAgICAgICAgdmFyIGwgPSBmLnlBeGlzLnRvcCAtIGMucGxvdFRvcDtcbiAgICAgICAgICAgIGYudmlzaWJsZSA/IChrID0gayA/IGsucGxvdFkgOiBmLnlBeGlzLmhlaWdodCwgayArPSBsIC0gLjMgKiBkKSA6IGsgPSBsICsgZi55QXhpcy5oZWlnaHQ7XG4gICAgICAgICAgICBhLnB1c2goe1xuICAgICAgICAgICAgICB0YXJnZXQ6IGssXG4gICAgICAgICAgICAgIHNpemU6IGQsXG4gICAgICAgICAgICAgIGl0ZW06IGZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGQuZGlzdHJpYnV0ZShhLCBjLnBsb3RIZWlnaHQpO1xuICAgICAgICBhLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhLml0ZW0uX2xlZ2VuZEl0ZW1Qb3NbMV0gPSBjLnBsb3RUb3AgLSBjLnNwYWNpbmdbMF0gKyBhLnBvcztcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGEgPSBjLnJlbmRlcmVyLFxuICAgICAgICAgICAgZSA9IHRoaXMuZ3JvdXAsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgayA9IHRoaXMuYm94LFxuICAgICAgICAgICAgaCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIG4gPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgIHRoaXMuaXRlbVggPSBuO1xuICAgICAgICB0aGlzLml0ZW1ZID0gdGhpcy5pbml0aWFsSXRlbVk7XG4gICAgICAgIHRoaXMubGFzdEl0ZW1ZID0gdGhpcy5vZmZzZXRXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMud2lkdGhPcHRpb24gPSBEKGgud2lkdGgsIGMuc3BhY2luZ0JveC53aWR0aCAtIG4pO1xuICAgICAgICB2YXIgZyA9IGMuc3BhY2luZ0JveC53aWR0aCAtIDIgKiBuIC0gaC54O1xuICAgICAgICAtMSA8IFtcInJtXCIsIFwibG1cIl0uaW5kZXhPZih0aGlzLmdldEFsaWdubWVudCgpLnN1YnN0cmluZygwLCAyKSkgJiYgKGcgLz0gMik7XG4gICAgICAgIHRoaXMubWF4TGVnZW5kV2lkdGggPSB0aGlzLndpZHRoT3B0aW9uIHx8IGc7XG4gICAgICAgIGUgfHwgKHRoaXMuZ3JvdXAgPSBlID0gYS5nKFwibGVnZW5kXCIpLmF0dHIoe1xuICAgICAgICAgIHpJbmRleDogN1xuICAgICAgICB9KS5hZGQoKSwgdGhpcy5jb250ZW50R3JvdXAgPSBhLmcoKS5hdHRyKHtcbiAgICAgICAgICB6SW5kZXg6IDFcbiAgICAgICAgfSkuYWRkKGUpLCB0aGlzLnNjcm9sbEdyb3VwID0gYS5nKCkuYWRkKHRoaXMuY29udGVudEdyb3VwKSk7XG4gICAgICAgIHRoaXMucmVuZGVyVGl0bGUoKTtcbiAgICAgICAgZyA9IHRoaXMuZ2V0QWxsSXRlbXMoKTtcbiAgICAgICAgTihnLCBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICAgIHJldHVybiAoYS5vcHRpb25zICYmIGEub3B0aW9ucy5sZWdlbmRJbmRleCB8fCAwKSAtIChjLm9wdGlvbnMgJiYgYy5vcHRpb25zLmxlZ2VuZEluZGV4IHx8IDApO1xuICAgICAgICB9KTtcbiAgICAgICAgaC5yZXZlcnNlZCAmJiBnLnJldmVyc2UoKTtcbiAgICAgICAgdGhpcy5hbGxJdGVtcyA9IGc7XG4gICAgICAgIHRoaXMuZGlzcGxheSA9IGQgPSAhIWcubGVuZ3RoO1xuICAgICAgICB0aGlzLml0ZW1IZWlnaHQgPSB0aGlzLnRvdGFsSXRlbVdpZHRoID0gdGhpcy5tYXhJdGVtV2lkdGggPSB0aGlzLmxhc3RMaW5lSGVpZ2h0ID0gMDtcbiAgICAgICAgZy5mb3JFYWNoKHRoaXMucmVuZGVySXRlbSwgdGhpcyk7XG4gICAgICAgIGcuZm9yRWFjaCh0aGlzLmxheW91dEl0ZW0sIHRoaXMpO1xuICAgICAgICBnID0gKHRoaXMud2lkdGhPcHRpb24gfHwgdGhpcy5vZmZzZXRXaWR0aCkgKyBuO1xuICAgICAgICB2YXIgcSA9IHRoaXMubGFzdEl0ZW1ZICsgdGhpcy5sYXN0TGluZUhlaWdodCArIHRoaXMudGl0bGVIZWlnaHQ7XG4gICAgICAgIHEgPSB0aGlzLmhhbmRsZU92ZXJmbG93KHEpO1xuICAgICAgICBxICs9IG47XG4gICAgICAgIGsgfHwgKHRoaXMuYm94ID0gayA9IGEucmVjdCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1sZWdlbmQtYm94XCIpLmF0dHIoe1xuICAgICAgICAgIHI6IGguYm9yZGVyUmFkaXVzXG4gICAgICAgIH0pLmFkZChlKSwgay5pc05ldyA9ICEwKTtcbiAgICAgICAgYy5zdHlsZWRNb2RlIHx8IGsuYXR0cih7XG4gICAgICAgICAgc3Ryb2tlOiBoLmJvcmRlckNvbG9yLFxuICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IGguYm9yZGVyV2lkdGggfHwgMCxcbiAgICAgICAgICBmaWxsOiBoLmJhY2tncm91bmRDb2xvciB8fCBcIm5vbmVcIlxuICAgICAgICB9KS5zaGFkb3coaC5zaGFkb3cpO1xuICAgICAgICAwIDwgZyAmJiAwIDwgcSAmJiAoa1trLmlzTmV3ID8gXCJhdHRyXCIgOiBcImFuaW1hdGVcIl0oay5jcmlzcC5jYWxsKHt9LCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHdpZHRoOiBnLFxuICAgICAgICAgIGhlaWdodDogcVxuICAgICAgICB9LCBrLnN0cm9rZVdpZHRoKCkpKSwgay5pc05ldyA9ICExKTtcbiAgICAgICAga1tkID8gXCJzaG93XCIgOiBcImhpZGVcIl0oKTtcbiAgICAgICAgYy5zdHlsZWRNb2RlICYmIFwibm9uZVwiID09PSBlLmdldFN0eWxlKFwiZGlzcGxheVwiKSAmJiAoZyA9IHEgPSAwKTtcbiAgICAgICAgdGhpcy5sZWdlbmRXaWR0aCA9IGc7XG4gICAgICAgIHRoaXMubGVnZW5kSGVpZ2h0ID0gcTtcbiAgICAgICAgZCAmJiAoYSA9IGMuc3BhY2luZ0JveCwgayA9IGEueSwgLyhsdGh8Y3R8cnRoKS8udGVzdCh0aGlzLmdldEFsaWdubWVudCgpKSAmJiAwIDwgYy50aXRsZU9mZnNldFswXSA/IGsgKz0gYy50aXRsZU9mZnNldFswXSA6IC8obGJofGNifHJiaCkvLnRlc3QodGhpcy5nZXRBbGlnbm1lbnQoKSkgJiYgMCA8IGMudGl0bGVPZmZzZXRbMl0gJiYgKGsgLT0gYy50aXRsZU9mZnNldFsyXSksIGsgIT09IGEueSAmJiAoYSA9IHkoYSwge1xuICAgICAgICAgIHk6IGtcbiAgICAgICAgfSkpLCBlLmFsaWduKHkoaCwge1xuICAgICAgICAgIHdpZHRoOiBnLFxuICAgICAgICAgIGhlaWdodDogcSxcbiAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiB0aGlzLnByb3hpbWF0ZSA/IFwidG9wXCIgOiBoLnZlcnRpY2FsQWxpZ25cbiAgICAgICAgfSksICEwLCBhKSk7XG4gICAgICAgIHRoaXMucHJveGltYXRlIHx8IHRoaXMucG9zaXRpb25JdGVtcygpO1xuICAgICAgICBBKHRoaXMsIFwiYWZ0ZXJSZW5kZXJcIik7XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZS5oYW5kbGVPdmVyZmxvdyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIGUgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZiA9IGUucmVuZGVyZXIsXG4gICAgICAgICAgICBkID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgayA9IGQueSxcbiAgICAgICAgICAgIGggPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgIGsgPSBlLnNwYWNpbmdCb3guaGVpZ2h0ICsgKFwidG9wXCIgPT09IGQudmVydGljYWxBbGlnbiA/IC1rIDogaykgLSBoO1xuXG4gICAgICAgIHZhciBuID0gZC5tYXhIZWlnaHQsXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgcSA9IHRoaXMuY2xpcFJlY3QsXG4gICAgICAgICAgICB5ID0gZC5uYXZpZ2F0aW9uLFxuICAgICAgICAgICAgcCA9IHQoeS5hbmltYXRpb24sICEwKSxcbiAgICAgICAgICAgIGIgPSB5LmFycm93U2l6ZSB8fCAxMixcbiAgICAgICAgICAgIEMgPSB0aGlzLm5hdixcbiAgICAgICAgICAgIHggPSB0aGlzLnBhZ2VzLFxuICAgICAgICAgICAgUixcbiAgICAgICAgICAgIE8gPSB0aGlzLmFsbEl0ZW1zLFxuICAgICAgICAgICAgdSA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGIgPyBxLmF0dHIoe1xuICAgICAgICAgICAgaGVpZ2h0OiBiXG4gICAgICAgICAgfSkgOiBxICYmIChhLmNsaXBSZWN0ID0gcS5kZXN0cm95KCksIGEuY29udGVudEdyb3VwLmNsaXAoKSk7XG4gICAgICAgICAgYS5jb250ZW50R3JvdXAuZGl2ICYmIChhLmNvbnRlbnRHcm91cC5kaXYuc3R5bGUuY2xpcCA9IGIgPyBcInJlY3QoXCIgKyBoICsgXCJweCw5OTk5cHgsXCIgKyAoaCArIGIpICsgXCJweCwwKVwiIDogXCJhdXRvXCIpO1xuICAgICAgICB9LFxuICAgICAgICAgICAgRCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgYVtjXSA9IGYuY2lyY2xlKDAsIDAsIDEuMyAqIGIpLnRyYW5zbGF0ZShiIC8gMiwgYiAvIDIpLmFkZChDKTtcbiAgICAgICAgICBlLnN0eWxlZE1vZGUgfHwgYVtjXS5hdHRyKFwiZmlsbFwiLCBcInJnYmEoMCwwLDAsMC4wMDAxKVwiKTtcbiAgICAgICAgICByZXR1cm4gYVtjXTtcbiAgICAgICAgfTtcblxuICAgICAgICBcImhvcml6b250YWxcIiAhPT0gZC5sYXlvdXQgfHwgXCJtaWRkbGVcIiA9PT0gZC52ZXJ0aWNhbEFsaWduIHx8IGQuZmxvYXRpbmcgfHwgKGsgLz0gMik7XG4gICAgICAgIG4gJiYgKGsgPSBNYXRoLm1pbihrLCBuKSk7XG4gICAgICAgIHgubGVuZ3RoID0gMDtcbiAgICAgICAgYyA+IGsgJiYgITEgIT09IHkuZW5hYmxlZCA/ICh0aGlzLmNsaXBIZWlnaHQgPSBnID0gTWF0aC5tYXgoayAtIDIwIC0gdGhpcy50aXRsZUhlaWdodCAtIGgsIDApLCB0aGlzLmN1cnJlbnRQYWdlID0gdCh0aGlzLmN1cnJlbnRQYWdlLCAxKSwgdGhpcy5mdWxsSGVpZ2h0ID0gYywgTy5mb3JFYWNoKGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgdmFyIGMgPSBiLl9sZWdlbmRJdGVtUG9zWzFdLFxuICAgICAgICAgICAgICBlID0gTWF0aC5yb3VuZChiLmxlZ2VuZEl0ZW0uZ2V0QkJveCgpLmhlaWdodCksXG4gICAgICAgICAgICAgIGYgPSB4Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWYgfHwgYyAtIHhbZiAtIDFdID4gZyAmJiAoUiB8fCBjKSAhPT0geFtmIC0gMV0pIHgucHVzaChSIHx8IGMpLCBmKys7XG4gICAgICAgICAgYi5wYWdlSXggPSBmIC0gMTtcbiAgICAgICAgICBSICYmIChPW2EgLSAxXS5wYWdlSXggPSBmIC0gMSk7XG4gICAgICAgICAgYSA9PT0gTy5sZW5ndGggLSAxICYmIGMgKyBlIC0geFtmIC0gMV0gPiBnICYmIGMgIT09IFIgJiYgKHgucHVzaChjKSwgYi5wYWdlSXggPSBmKTtcbiAgICAgICAgICBjICE9PSBSICYmIChSID0gYyk7XG4gICAgICAgIH0pLCBxIHx8IChxID0gYS5jbGlwUmVjdCA9IGYuY2xpcFJlY3QoMCwgaCwgOTk5OSwgMCksIGEuY29udGVudEdyb3VwLmNsaXAocSkpLCB1KGcpLCBDIHx8ICh0aGlzLm5hdiA9IEMgPSBmLmcoKS5hdHRyKHtcbiAgICAgICAgICB6SW5kZXg6IDFcbiAgICAgICAgfSkuYWRkKHRoaXMuZ3JvdXApLCB0aGlzLnVwID0gZi5zeW1ib2woXCJ0cmlhbmdsZVwiLCAwLCAwLCBiLCBiKS5hZGQoQyksIEQoXCJ1cFRyYWNrZXJcIikub24oXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYS5zY3JvbGwoLTEsIHApO1xuICAgICAgICB9KSwgdGhpcy5wYWdlciA9IGYudGV4dChcIlwiLCAxNSwgMTApLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1sZWdlbmQtbmF2aWdhdGlvblwiKSwgZS5zdHlsZWRNb2RlIHx8IHRoaXMucGFnZXIuY3NzKHkuc3R5bGUpLCB0aGlzLnBhZ2VyLmFkZChDKSwgdGhpcy5kb3duID0gZi5zeW1ib2woXCJ0cmlhbmdsZS1kb3duXCIsIDAsIDAsIGIsIGIpLmFkZChDKSwgRChcImRvd25UcmFja2VyXCIpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGEuc2Nyb2xsKDEsIHApO1xuICAgICAgICB9KSksIGEuc2Nyb2xsKDApLCBjID0gaykgOiBDICYmICh1KCksIHRoaXMubmF2ID0gQy5kZXN0cm95KCksIHRoaXMuc2Nyb2xsR3JvdXAuYXR0cih7XG4gICAgICAgICAgdHJhbnNsYXRlWTogMVxuICAgICAgICB9KSwgdGhpcy5jbGlwSGVpZ2h0ID0gMCk7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfTtcblxuICAgICAgYy5wcm90b3R5cGUuc2Nyb2xsID0gZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgICAgZiA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBrID0gdGhpcy5wYWdlcyxcbiAgICAgICAgICAgIG4gPSBrLmxlbmd0aCxcbiAgICAgICAgICAgIGcgPSB0aGlzLmN1cnJlbnRQYWdlICsgYztcbiAgICAgICAgYyA9IHRoaXMuY2xpcEhlaWdodDtcbiAgICAgICAgdmFyIHkgPSB0aGlzLm9wdGlvbnMubmF2aWdhdGlvbixcbiAgICAgICAgICAgIHUgPSB0aGlzLnBhZ2VyLFxuICAgICAgICAgICAgSCA9IHRoaXMucGFkZGluZztcbiAgICAgICAgZyA+IG4gJiYgKGcgPSBuKTtcbiAgICAgICAgMCA8IGcgJiYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBhICYmIGgoYSwgZiksIHRoaXMubmF2LmF0dHIoe1xuICAgICAgICAgIHRyYW5zbGF0ZVg6IEgsXG4gICAgICAgICAgdHJhbnNsYXRlWTogYyArIHRoaXMucGFkZGluZyArIDcgKyB0aGlzLnRpdGxlSGVpZ2h0LFxuICAgICAgICAgIHZpc2liaWxpdHk6IFwidmlzaWJsZVwiXG4gICAgICAgIH0pLCBbdGhpcy51cCwgdGhpcy51cFRyYWNrZXJdLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhLmF0dHIoe1xuICAgICAgICAgICAgXCJjbGFzc1wiOiAxID09PSBnID8gXCJoaWdoY2hhcnRzLWxlZ2VuZC1uYXYtaW5hY3RpdmVcIiA6IFwiaGlnaGNoYXJ0cy1sZWdlbmQtbmF2LWFjdGl2ZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLCB1LmF0dHIoe1xuICAgICAgICAgIHRleHQ6IGcgKyBcIi9cIiArIG5cbiAgICAgICAgfSksIFt0aGlzLmRvd24sIHRoaXMuZG93blRyYWNrZXJdLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhLmF0dHIoe1xuICAgICAgICAgICAgeDogMTggKyB0aGlzLnBhZ2VyLmdldEJCb3goKS53aWR0aCxcbiAgICAgICAgICAgIFwiY2xhc3NcIjogZyA9PT0gbiA/IFwiaGlnaGNoYXJ0cy1sZWdlbmQtbmF2LWluYWN0aXZlXCIgOiBcImhpZ2hjaGFydHMtbGVnZW5kLW5hdi1hY3RpdmVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aGlzKSwgZi5zdHlsZWRNb2RlIHx8ICh0aGlzLnVwLmF0dHIoe1xuICAgICAgICAgIGZpbGw6IDEgPT09IGcgPyB5LmluYWN0aXZlQ29sb3IgOiB5LmFjdGl2ZUNvbG9yXG4gICAgICAgIH0pLCB0aGlzLnVwVHJhY2tlci5jc3Moe1xuICAgICAgICAgIGN1cnNvcjogMSA9PT0gZyA/IFwiZGVmYXVsdFwiIDogXCJwb2ludGVyXCJcbiAgICAgICAgfSksIHRoaXMuZG93bi5hdHRyKHtcbiAgICAgICAgICBmaWxsOiBnID09PSBuID8geS5pbmFjdGl2ZUNvbG9yIDogeS5hY3RpdmVDb2xvclxuICAgICAgICB9KSwgdGhpcy5kb3duVHJhY2tlci5jc3Moe1xuICAgICAgICAgIGN1cnNvcjogZyA9PT0gbiA/IFwiZGVmYXVsdFwiIDogXCJwb2ludGVyXCJcbiAgICAgICAgfSkpLCB0aGlzLnNjcm9sbE9mZnNldCA9IC1rW2cgLSAxXSArIHRoaXMuaW5pdGlhbEl0ZW1ZLCB0aGlzLnNjcm9sbEdyb3VwLmFuaW1hdGUoe1xuICAgICAgICAgIHRyYW5zbGF0ZVk6IHRoaXMuc2Nyb2xsT2Zmc2V0XG4gICAgICAgIH0pLCB0aGlzLmN1cnJlbnRQYWdlID0gZywgdGhpcy5wb3NpdGlvbkNoZWNrYm94ZXMoKSwgYSA9IGQuYW5pbU9iamVjdCh0KGEsIGYucmVuZGVyZXIuZ2xvYmFsQW5pbWF0aW9uLCAhMCkpLCBxKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBBKGUsIFwiYWZ0ZXJTY3JvbGxcIiwge1xuICAgICAgICAgICAgY3VycmVudFBhZ2U6IGdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgYS5kdXJhdGlvbiB8fCAwKSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gYztcbiAgICB9KCk7XG5cbiAgICAoL1RyaWRlbnRcXC83XFwuMC8udGVzdChjLm5hdmlnYXRvciAmJiBjLm5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFApICYmIGcoay5wcm90b3R5cGUsIFwicG9zaXRpb25JdGVtXCIsIGZ1bmN0aW9uIChjLCBlKSB7XG4gICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZS5fbGVnZW5kSXRlbVBvcyAmJiBjLmNhbGwoYSwgZSk7XG4gICAgICB9O1xuXG4gICAgICBmKCk7XG4gICAgICBhLmJ1YmJsZUxlZ2VuZCB8fCBzZXRUaW1lb3V0KGYpO1xuICAgIH0pO1xuICAgIGQuTGVnZW5kID0gaztcbiAgICByZXR1cm4gZC5MZWdlbmQ7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvQ2hhcnQuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvTGVnZW5kLmpzXCJdLCByW1wicGFydHMvTVNQb2ludGVyLmpzXCJdLCByW1wicGFydHMvUG9pbnRlci5qc1wiXSwgcltcInBhcnRzL1RpbWUuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZywgciwgdSwgSSwgTSkge1xuICAgIHZhciBFID0gTS5hZGRFdmVudCxcbiAgICAgICAgQSA9IE0uYW5pbWF0ZSxcbiAgICAgICAgRyA9IE0uYW5pbU9iamVjdCxcbiAgICAgICAgSiA9IE0uYXR0cixcbiAgICAgICAgeSA9IE0uY3JlYXRlRWxlbWVudCxcbiAgICAgICAgdCA9IE0uY3NzLFxuICAgICAgICBEID0gTS5kZWZpbmVkLFxuICAgICAgICBoID0gTS5kaXNjYXJkRWxlbWVudCxcbiAgICAgICAgTiA9IE0uZXJhc2UsXG4gICAgICAgIHEgPSBNLmVycm9yLFxuICAgICAgICBQID0gTS5leHRlbmQsXG4gICAgICAgIGUgPSBNLmZpbmQsXG4gICAgICAgIGMgPSBNLmZpcmVFdmVudCxcbiAgICAgICAgayA9IE0uZ2V0U3R5bGUsXG4gICAgICAgIG4gPSBNLmlzQXJyYXksXG4gICAgICAgIGYgPSBNLmlzRnVuY3Rpb24sXG4gICAgICAgIGEgPSBNLmlzTnVtYmVyLFxuICAgICAgICBsID0gTS5pc09iamVjdCxcbiAgICAgICAgdiA9IE0uaXNTdHJpbmcsXG4gICAgICAgIHogPSBNLm1lcmdlLFxuICAgICAgICB3ID0gTS5udW1iZXJGb3JtYXQsXG4gICAgICAgIEIgPSBNLm9iamVjdEVhY2gsXG4gICAgICAgIEwgPSBNLnBpY2ssXG4gICAgICAgIFEgPSBNLnBJbnQsXG4gICAgICAgIEggPSBNLnJlbGF0aXZlTGVuZ3RoLFxuICAgICAgICBLID0gTS5yZW1vdmVFdmVudCxcbiAgICAgICAgcCA9IE0uc2V0QW5pbWF0aW9uLFxuICAgICAgICBiID0gTS5zcGxhdCxcbiAgICAgICAgQyA9IE0uc3luY1RpbWVvdXQsXG4gICAgICAgIHggPSBNLnVuaXF1ZUtleSxcbiAgICAgICAgUiA9IGQuZG9jLFxuICAgICAgICBPID0gZC5BeGlzLFxuICAgICAgICBYID0gZC5kZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgVSA9IGQuY2hhcnRzLFxuICAgICAgICBtID0gZC5tYXJnaW5OYW1lcyxcbiAgICAgICAgVCA9IGQuc2VyaWVzVHlwZXMsXG4gICAgICAgIFogPSBkLndpbixcbiAgICAgICAgY2EgPSBkLkNoYXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5nZXRBcmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGQuY2hhcnQgPSBmdW5jdGlvbiAoYiwgYSwgYykge1xuICAgICAgcmV0dXJuIG5ldyBjYShiLCBhLCBjKTtcbiAgICB9O1xuXG4gICAgUChjYS5wcm90b3R5cGUsIHtcbiAgICAgIGNhbGxiYWNrczogW10sXG4gICAgICBnZXRBcmdzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBpZiAodihiWzBdKSB8fCBiWzBdLm5vZGVOYW1lKSB0aGlzLnJlbmRlclRvID0gYi5zaGlmdCgpO1xuICAgICAgICB0aGlzLmluaXQoYlswXSwgYlsxXSk7XG4gICAgICB9LFxuICAgICAgaW5pdDogZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgdmFyIGUsXG4gICAgICAgICAgICBrID0gYi5zZXJpZXMsXG4gICAgICAgICAgICBoID0gYi5wbG90T3B0aW9ucyB8fCB7fTtcbiAgICAgICAgYyh0aGlzLCBcImluaXRcIiwge1xuICAgICAgICAgIGFyZ3M6IGFyZ3VtZW50c1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYi5zZXJpZXMgPSBudWxsO1xuICAgICAgICAgIGUgPSB6KFgsIGIpO1xuICAgICAgICAgIEIoZS5wbG90T3B0aW9ucywgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICAgIGwoYikgJiYgKGIudG9vbHRpcCA9IGhbYV0gJiYgeihoW2FdLnRvb2x0aXApIHx8IHZvaWQgMCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZS50b29sdGlwLnVzZXJPcHRpb25zID0gYi5jaGFydCAmJiBiLmNoYXJ0LmZvckV4cG9ydCAmJiBiLnRvb2x0aXAudXNlck9wdGlvbnMgfHwgYi50b29sdGlwO1xuICAgICAgICAgIGUuc2VyaWVzID0gYi5zZXJpZXMgPSBrO1xuICAgICAgICAgIHRoaXMudXNlck9wdGlvbnMgPSBiO1xuICAgICAgICAgIHZhciBtID0gZS5jaGFydCxcbiAgICAgICAgICAgICAgbiA9IG0uZXZlbnRzO1xuICAgICAgICAgIHRoaXMubWFyZ2luID0gW107XG4gICAgICAgICAgdGhpcy5zcGFjaW5nID0gW107XG4gICAgICAgICAgdGhpcy5ib3VuZHMgPSB7XG4gICAgICAgICAgICBoOiB7fSxcbiAgICAgICAgICAgIHY6IHt9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmxhYmVsQ29sbGVjdG9ycyA9IFtdO1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBhO1xuICAgICAgICAgIHRoaXMuaXNSZXNpemluZyA9IDA7XG4gICAgICAgICAgdGhpcy5vcHRpb25zID0gZTtcbiAgICAgICAgICB0aGlzLmF4ZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLnNlcmllcyA9IFtdO1xuICAgICAgICAgIHRoaXMudGltZSA9IGIudGltZSAmJiBPYmplY3Qua2V5cyhiLnRpbWUpLmxlbmd0aCA/IG5ldyBJKGIudGltZSkgOiBkLnRpbWU7XG4gICAgICAgICAgdGhpcy5udW1iZXJGb3JtYXR0ZXIgPSBtLm51bWJlckZvcm1hdHRlciB8fCB3O1xuICAgICAgICAgIHRoaXMuc3R5bGVkTW9kZSA9IG0uc3R5bGVkTW9kZTtcbiAgICAgICAgICB0aGlzLmhhc0NhcnRlc2lhblNlcmllcyA9IG0uc2hvd0F4ZXM7XG4gICAgICAgICAgdmFyIHAgPSB0aGlzO1xuICAgICAgICAgIHAuaW5kZXggPSBVLmxlbmd0aDtcbiAgICAgICAgICBVLnB1c2gocCk7XG4gICAgICAgICAgZC5jaGFydENvdW50Kys7XG4gICAgICAgICAgbiAmJiBCKG4sIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgICBmKGIpICYmIEUocCwgYSwgYik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcC54QXhpcyA9IFtdO1xuICAgICAgICAgIHAueUF4aXMgPSBbXTtcbiAgICAgICAgICBwLnBvaW50Q291bnQgPSBwLmNvbG9yQ291bnRlciA9IHAuc3ltYm9sQ291bnRlciA9IDA7XG4gICAgICAgICAgYyhwLCBcImFmdGVySW5pdFwiKTtcbiAgICAgICAgICBwLmZpcnN0UmVuZGVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGluaXRTZXJpZXM6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5vcHRpb25zLmNoYXJ0O1xuICAgICAgICBhID0gYi50eXBlIHx8IGEudHlwZSB8fCBhLmRlZmF1bHRTZXJpZXNUeXBlO1xuICAgICAgICB2YXIgYyA9IFRbYV07XG4gICAgICAgIGMgfHwgcSgxNywgITAsIHRoaXMsIHtcbiAgICAgICAgICBtaXNzaW5nTW9kdWxlRm9yOiBhXG4gICAgICAgIH0pO1xuICAgICAgICBhID0gbmV3IGMoKTtcbiAgICAgICAgYS5pbml0KHRoaXMsIGIpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sXG4gICAgICBzZXRTZXJpZXNEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZ2V0U2VyaWVzT3JkZXJCeUxpbmtzKCkuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGIucG9pbnRzIHx8IGIuZGF0YSB8fCAhYi5lbmFibGVkRGF0YVNvcnRpbmcgfHwgYi5zZXREYXRhKGIub3B0aW9ucy5kYXRhLCAhMSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdldFNlcmllc09yZGVyQnlMaW5rczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJpZXMuY29uY2F0KCkuc29ydChmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIHJldHVybiBiLmxpbmtlZFNlcmllcy5sZW5ndGggfHwgYS5saW5rZWRTZXJpZXMubGVuZ3RoID8gYS5saW5rZWRTZXJpZXMubGVuZ3RoIC0gYi5saW5rZWRTZXJpZXMubGVuZ3RoIDogMDtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb3JkZXJTZXJpZXM6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5zZXJpZXM7XG5cbiAgICAgICAgZm9yIChiID0gYiB8fCAwOyBiIDwgYS5sZW5ndGg7IGIrKykgYVtiXSAmJiAoYVtiXS5pbmRleCA9IGIsIGFbYl0ubmFtZSA9IGFbYl0uZ2V0TmFtZSgpKTtcbiAgICAgIH0sXG4gICAgICBpc0luc2lkZVBsb3Q6IGZ1bmN0aW9uIChiLCBhLCBlKSB7XG4gICAgICAgIHZhciBmID0gZSA/IGEgOiBiO1xuICAgICAgICBiID0gZSA/IGIgOiBhO1xuICAgICAgICBmID0ge1xuICAgICAgICAgIHg6IGYsXG4gICAgICAgICAgeTogYixcbiAgICAgICAgICBpc0luc2lkZVBsb3Q6IDAgPD0gZiAmJiBmIDw9IHRoaXMucGxvdFdpZHRoICYmIDAgPD0gYiAmJiBiIDw9IHRoaXMucGxvdEhlaWdodFxuICAgICAgICB9O1xuICAgICAgICBjKHRoaXMsIFwiYWZ0ZXJJc0luc2lkZVBsb3RcIiwgZik7XG4gICAgICAgIHJldHVybiBmLmlzSW5zaWRlUGxvdDtcbiAgICAgIH0sXG4gICAgICByZWRyYXc6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIGModGhpcywgXCJiZWZvcmVSZWRyYXdcIik7XG4gICAgICAgIHZhciBhID0gdGhpcy5heGVzLFxuICAgICAgICAgICAgZSA9IHRoaXMuc2VyaWVzLFxuICAgICAgICAgICAgZiA9IHRoaXMucG9pbnRlcixcbiAgICAgICAgICAgIGQgPSB0aGlzLmxlZ2VuZCxcbiAgICAgICAgICAgIGsgPSB0aGlzLnVzZXJPcHRpb25zLmxlZ2VuZCxcbiAgICAgICAgICAgIGwgPSB0aGlzLmlzRGlydHlMZWdlbmQsXG4gICAgICAgICAgICBoID0gdGhpcy5oYXNDYXJ0ZXNpYW5TZXJpZXMsXG4gICAgICAgICAgICBtID0gdGhpcy5pc0RpcnR5Qm94LFxuICAgICAgICAgICAgbiA9IHRoaXMucmVuZGVyZXIsXG4gICAgICAgICAgICB4ID0gbi5pc0hpZGRlbigpLFxuICAgICAgICAgICAgZyA9IFtdO1xuICAgICAgICB0aGlzLnNldFJlc3BvbnNpdmUgJiYgdGhpcy5zZXRSZXNwb25zaXZlKCExKTtcbiAgICAgICAgcCh0aGlzLmhhc1JlbmRlcmVkID8gYiA6ICExLCB0aGlzKTtcbiAgICAgICAgeCAmJiB0aGlzLnRlbXBvcmFyeURpc3BsYXkoKTtcbiAgICAgICAgdGhpcy5sYXlPdXRUaXRsZXMoKTtcblxuICAgICAgICBmb3IgKGIgPSBlLmxlbmd0aDsgYi0tOykge1xuICAgICAgICAgIHZhciB3ID0gZVtiXTtcblxuICAgICAgICAgIGlmICh3Lm9wdGlvbnMuc3RhY2tpbmcpIHtcbiAgICAgICAgICAgIHZhciBDID0gITA7XG5cbiAgICAgICAgICAgIGlmICh3LmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgdmFyIHYgPSAhMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHYpIGZvciAoYiA9IGUubGVuZ3RoOyBiLS07KSB3ID0gZVtiXSwgdy5vcHRpb25zLnN0YWNraW5nICYmICh3LmlzRGlydHkgPSAhMCk7XG4gICAgICAgIGUuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGIuaXNEaXJ0eSAmJiAoXCJwb2ludFwiID09PSBiLm9wdGlvbnMubGVnZW5kVHlwZSA/IChiLnVwZGF0ZVRvdGFscyAmJiBiLnVwZGF0ZVRvdGFscygpLCBsID0gITApIDogayAmJiAoay5sYWJlbEZvcm1hdHRlciB8fCBrLmxhYmVsRm9ybWF0KSAmJiAobCA9ICEwKSk7XG4gICAgICAgICAgYi5pc0RpcnR5RGF0YSAmJiBjKGIsIFwidXBkYXRlZERhdGFcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBsICYmIGQgJiYgZC5vcHRpb25zLmVuYWJsZWQgJiYgKGQucmVuZGVyKCksIHRoaXMuaXNEaXJ0eUxlZ2VuZCA9ICExKTtcbiAgICAgICAgQyAmJiB0aGlzLmdldFN0YWNrcygpO1xuICAgICAgICBoICYmIGEuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGIudXBkYXRlTmFtZXMoKTtcbiAgICAgICAgICBiLnNldFNjYWxlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdldE1hcmdpbnMoKTtcbiAgICAgICAgaCAmJiAoYS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYi5pc0RpcnR5ICYmIChtID0gITApO1xuICAgICAgICB9KSwgYS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgdmFyIGEgPSBiLm1pbiArIFwiLFwiICsgYi5tYXg7XG4gICAgICAgICAgYi5leHRLZXkgIT09IGEgJiYgKGIuZXh0S2V5ID0gYSwgZy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGMoYiwgXCJhZnRlclNldEV4dHJlbWVzXCIsIFAoYi5ldmVudEFyZ3MsIGIuZ2V0RXh0cmVtZXMoKSkpO1xuICAgICAgICAgICAgZGVsZXRlIGIuZXZlbnRBcmdzO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICAobSB8fCBDKSAmJiBiLnJlZHJhdygpO1xuICAgICAgICB9KSk7XG4gICAgICAgIG0gJiYgdGhpcy5kcmF3Q2hhcnRCb3goKTtcbiAgICAgICAgYyh0aGlzLCBcInByZWRyYXdcIik7XG4gICAgICAgIGUuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIChtIHx8IGIuaXNEaXJ0eSkgJiYgYi52aXNpYmxlICYmIGIucmVkcmF3KCk7XG4gICAgICAgICAgYi5pc0RpcnR5RGF0YSA9ICExO1xuICAgICAgICB9KTtcbiAgICAgICAgZiAmJiBmLnJlc2V0KCEwKTtcbiAgICAgICAgbi5kcmF3KCk7XG4gICAgICAgIGModGhpcywgXCJyZWRyYXdcIik7XG4gICAgICAgIGModGhpcywgXCJyZW5kZXJcIik7XG4gICAgICAgIHggJiYgdGhpcy50ZW1wb3JhcnlEaXNwbGF5KCEwKTtcbiAgICAgICAgZy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYi5jYWxsKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdldDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgZnVuY3Rpb24gYShhKSB7XG4gICAgICAgICAgcmV0dXJuIGEuaWQgPT09IGIgfHwgYS5vcHRpb25zICYmIGEub3B0aW9ucy5pZCA9PT0gYjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0gdGhpcy5zZXJpZXMsXG4gICAgICAgICAgICBmO1xuICAgICAgICB2YXIgZCA9IGUodGhpcy5heGVzLCBhKSB8fCBlKHRoaXMuc2VyaWVzLCBhKTtcblxuICAgICAgICBmb3IgKGYgPSAwOyAhZCAmJiBmIDwgYy5sZW5ndGg7IGYrKykgZCA9IGUoY1tmXS5wb2ludHMgfHwgW10sIGEpO1xuXG4gICAgICAgIHJldHVybiBkO1xuICAgICAgfSxcbiAgICAgIGdldEF4ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgZSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGYgPSBlLnhBeGlzID0gYihlLnhBeGlzIHx8IHt9KTtcbiAgICAgICAgZSA9IGUueUF4aXMgPSBiKGUueUF4aXMgfHwge30pO1xuICAgICAgICBjKHRoaXMsIFwiZ2V0QXhlc1wiKTtcbiAgICAgICAgZi5mb3JFYWNoKGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgYi5pbmRleCA9IGE7XG4gICAgICAgICAgYi5pc1ggPSAhMDtcbiAgICAgICAgfSk7XG4gICAgICAgIGUuZm9yRWFjaChmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIGIuaW5kZXggPSBhO1xuICAgICAgICB9KTtcbiAgICAgICAgZi5jb25jYXQoZSkuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIG5ldyBPKGEsIGIpO1xuICAgICAgICB9KTtcbiAgICAgICAgYyh0aGlzLCBcImFmdGVyR2V0QXhlc1wiKTtcbiAgICAgIH0sXG4gICAgICBnZXRTZWxlY3RlZFBvaW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IFtdO1xuICAgICAgICB0aGlzLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYiA9IGIuY29uY2F0KGEuZ2V0UG9pbnRzQ29sbGVjdGlvbigpLmZpbHRlcihmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgcmV0dXJuIEwoYi5zZWxlY3RlZFN0YWdpbmcsIGIuc2VsZWN0ZWQpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSxcbiAgICAgIGdldFNlbGVjdGVkU2VyaWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcmllcy5maWx0ZXIoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICByZXR1cm4gYi5zZWxlY3RlZDtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc2V0VGl0bGU6IGZ1bmN0aW9uIChiLCBhLCBjKSB7XG4gICAgICAgIHRoaXMuYXBwbHlEZXNjcmlwdGlvbihcInRpdGxlXCIsIGIpO1xuICAgICAgICB0aGlzLmFwcGx5RGVzY3JpcHRpb24oXCJzdWJ0aXRsZVwiLCBhKTtcbiAgICAgICAgdGhpcy5hcHBseURlc2NyaXB0aW9uKFwiY2FwdGlvblwiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLmxheU91dFRpdGxlcyhjKTtcbiAgICAgIH0sXG4gICAgICBhcHBseURlc2NyaXB0aW9uOiBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICB2YXIgYyA9IHRoaXMsXG4gICAgICAgICAgICBlID0gXCJ0aXRsZVwiID09PSBiID8ge1xuICAgICAgICAgIGNvbG9yOiBcIiMzMzMzMzNcIixcbiAgICAgICAgICBmb250U2l6ZTogdGhpcy5vcHRpb25zLmlzU3RvY2sgPyBcIjE2cHhcIiA6IFwiMThweFwiXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgY29sb3I6IFwiIzY2NjY2NlwiXG4gICAgICAgIH07XG4gICAgICAgIGUgPSB0aGlzLm9wdGlvbnNbYl0gPSB6KCF0aGlzLnN0eWxlZE1vZGUgJiYge1xuICAgICAgICAgIHN0eWxlOiBlXG4gICAgICAgIH0sIHRoaXMub3B0aW9uc1tiXSwgYSk7XG4gICAgICAgIHZhciBmID0gdGhpc1tiXTtcbiAgICAgICAgZiAmJiBhICYmICh0aGlzW2JdID0gZiA9IGYuZGVzdHJveSgpKTtcbiAgICAgICAgZSAmJiAhZiAmJiAoZiA9IHRoaXMucmVuZGVyZXIudGV4dChlLnRleHQsIDAsIDAsIGUudXNlSFRNTCkuYXR0cih7XG4gICAgICAgICAgYWxpZ246IGUuYWxpZ24sXG4gICAgICAgICAgXCJjbGFzc1wiOiBcImhpZ2hjaGFydHMtXCIgKyBiLFxuICAgICAgICAgIHpJbmRleDogZS56SW5kZXggfHwgNFxuICAgICAgICB9KS5hZGQoKSwgZi51cGRhdGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGNbe1xuICAgICAgICAgICAgdGl0bGU6IFwic2V0VGl0bGVcIixcbiAgICAgICAgICAgIHN1YnRpdGxlOiBcInNldFN1YnRpdGxlXCIsXG4gICAgICAgICAgICBjYXB0aW9uOiBcInNldENhcHRpb25cIlxuICAgICAgICAgIH1bYl1dKGEpO1xuICAgICAgICB9LCB0aGlzLnN0eWxlZE1vZGUgfHwgZi5jc3MoZS5zdHlsZSksIHRoaXNbYl0gPSBmKTtcbiAgICAgIH0sXG4gICAgICBsYXlPdXRUaXRsZXM6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gWzAsIDAsIDBdLFxuICAgICAgICAgICAgZSA9IHRoaXMucmVuZGVyZXIsXG4gICAgICAgICAgICBmID0gdGhpcy5zcGFjaW5nQm94O1xuICAgICAgICBbXCJ0aXRsZVwiLCBcInN1YnRpdGxlXCIsIFwiY2FwdGlvblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgdmFyIGMgPSB0aGlzW2JdLFxuICAgICAgICAgICAgICBkID0gdGhpcy5vcHRpb25zW2JdLFxuICAgICAgICAgICAgICBrID0gZC52ZXJ0aWNhbEFsaWduIHx8IFwidG9wXCI7XG4gICAgICAgICAgYiA9IFwidGl0bGVcIiA9PT0gYiA/IC0zIDogXCJ0b3BcIiA9PT0gayA/IGFbMF0gKyAyIDogMDtcblxuICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3R5bGVkTW9kZSkgdmFyIGwgPSBkLnN0eWxlLmZvbnRTaXplO1xuICAgICAgICAgICAgbCA9IGUuZm9udE1ldHJpY3MobCwgYykuYjtcbiAgICAgICAgICAgIGMuY3NzKHtcbiAgICAgICAgICAgICAgd2lkdGg6IChkLndpZHRoIHx8IGYud2lkdGggKyAoZC53aWR0aEFkanVzdCB8fCAwKSkgKyBcInB4XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGggPSBNYXRoLnJvdW5kKGMuZ2V0QkJveChkLnVzZUhUTUwpLmhlaWdodCk7XG4gICAgICAgICAgICBjLmFsaWduKFAoe1xuICAgICAgICAgICAgICB5OiBcImJvdHRvbVwiID09PSBrID8gbCA6IGIgKyBsLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGhcbiAgICAgICAgICAgIH0sIGQpLCAhMSwgXCJzcGFjaW5nQm94XCIpO1xuICAgICAgICAgICAgZC5mbG9hdGluZyB8fCAoXCJ0b3BcIiA9PT0gayA/IGFbMF0gPSBNYXRoLmNlaWwoYVswXSArIGgpIDogXCJib3R0b21cIiA9PT0gayAmJiAoYVsyXSA9IE1hdGguY2VpbChhWzJdICsgaCkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBhWzBdICYmIFwidG9wXCIgPT09ICh0aGlzLm9wdGlvbnMudGl0bGUudmVydGljYWxBbGlnbiB8fCBcInRvcFwiKSAmJiAoYVswXSArPSB0aGlzLm9wdGlvbnMudGl0bGUubWFyZ2luKTtcbiAgICAgICAgYVsyXSAmJiBcImJvdHRvbVwiID09PSB0aGlzLm9wdGlvbnMuY2FwdGlvbi52ZXJ0aWNhbEFsaWduICYmIChhWzJdICs9IHRoaXMub3B0aW9ucy5jYXB0aW9uLm1hcmdpbik7XG4gICAgICAgIHZhciBkID0gIXRoaXMudGl0bGVPZmZzZXQgfHwgdGhpcy50aXRsZU9mZnNldC5qb2luKFwiLFwiKSAhPT0gYS5qb2luKFwiLFwiKTtcbiAgICAgICAgdGhpcy50aXRsZU9mZnNldCA9IGE7XG4gICAgICAgIGModGhpcywgXCJhZnRlckxheU91dFRpdGxlc1wiKTtcbiAgICAgICAgIXRoaXMuaXNEaXJ0eUJveCAmJiBkICYmICh0aGlzLmlzRGlydHlCb3ggPSB0aGlzLmlzRGlydHlMZWdlbmQgPSBkLCB0aGlzLmhhc1JlbmRlcmVkICYmIEwoYiwgITApICYmIHRoaXMuaXNEaXJ0eUJveCAmJiB0aGlzLnJlZHJhdygpKTtcbiAgICAgIH0sXG4gICAgICBnZXRDaGFydFNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLm9wdGlvbnMuY2hhcnQsXG4gICAgICAgICAgICBhID0gYi53aWR0aDtcbiAgICAgICAgYiA9IGIuaGVpZ2h0O1xuICAgICAgICB2YXIgYyA9IHRoaXMucmVuZGVyVG87XG4gICAgICAgIEQoYSkgfHwgKHRoaXMuY29udGFpbmVyV2lkdGggPSBrKGMsIFwid2lkdGhcIikpO1xuICAgICAgICBEKGIpIHx8ICh0aGlzLmNvbnRhaW5lckhlaWdodCA9IGsoYywgXCJoZWlnaHRcIikpO1xuICAgICAgICB0aGlzLmNoYXJ0V2lkdGggPSBNYXRoLm1heCgwLCBhIHx8IHRoaXMuY29udGFpbmVyV2lkdGggfHwgNjAwKTtcbiAgICAgICAgdGhpcy5jaGFydEhlaWdodCA9IE1hdGgubWF4KDAsIEgoYiwgdGhpcy5jaGFydFdpZHRoKSB8fCAoMSA8IHRoaXMuY29udGFpbmVySGVpZ2h0ID8gdGhpcy5jb250YWluZXJIZWlnaHQgOiA0MDApKTtcbiAgICAgIH0sXG4gICAgICB0ZW1wb3JhcnlEaXNwbGF5OiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXMucmVuZGVyVG87XG4gICAgICAgIGlmIChiKSBmb3IgKDsgYSAmJiBhLnN0eWxlOykgYS5oY09yaWdTdHlsZSAmJiAodChhLCBhLmhjT3JpZ1N0eWxlKSwgZGVsZXRlIGEuaGNPcmlnU3R5bGUpLCBhLmhjT3JpZ0RldGFjaGVkICYmIChSLmJvZHkucmVtb3ZlQ2hpbGQoYSksIGEuaGNPcmlnRGV0YWNoZWQgPSAhMSksIGEgPSBhLnBhcmVudE5vZGU7ZWxzZSBmb3IgKDsgYSAmJiBhLnN0eWxlOykge1xuICAgICAgICAgIFIuYm9keS5jb250YWlucyhhKSB8fCBhLnBhcmVudE5vZGUgfHwgKGEuaGNPcmlnRGV0YWNoZWQgPSAhMCwgUi5ib2R5LmFwcGVuZENoaWxkKGEpKTtcbiAgICAgICAgICBpZiAoXCJub25lXCIgPT09IGsoYSwgXCJkaXNwbGF5XCIsICExKSB8fCBhLmhjT3JpY0RldGFjaGVkKSBhLmhjT3JpZ1N0eWxlID0ge1xuICAgICAgICAgICAgZGlzcGxheTogYS5zdHlsZS5kaXNwbGF5LFxuICAgICAgICAgICAgaGVpZ2h0OiBhLnN0eWxlLmhlaWdodCxcbiAgICAgICAgICAgIG92ZXJmbG93OiBhLnN0eWxlLm92ZXJmbG93XG4gICAgICAgICAgfSwgYiA9IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiXG4gICAgICAgICAgfSwgYSAhPT0gdGhpcy5yZW5kZXJUbyAmJiAoYi5oZWlnaHQgPSAwKSwgdChhLCBiKSwgYS5vZmZzZXRXaWR0aCB8fCBhLnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLCBcImJsb2NrXCIsIFwiaW1wb3J0YW50XCIpO1xuICAgICAgICAgIGEgPSBhLnBhcmVudE5vZGU7XG4gICAgICAgICAgaWYgKGEgPT09IFIuYm9keSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXRDbGFzc05hbWU6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiaGlnaGNoYXJ0cy1jb250YWluZXIgXCIgKyAoYiB8fCBcIlwiKTtcbiAgICAgIH0sXG4gICAgICBnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBlID0gYi5jaGFydDtcbiAgICAgICAgdmFyIGYgPSB0aGlzLnJlbmRlclRvO1xuICAgICAgICB2YXIgayA9IHgoKSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBoO1xuICAgICAgICBmIHx8ICh0aGlzLnJlbmRlclRvID0gZiA9IGUucmVuZGVyVG8pO1xuICAgICAgICB2KGYpICYmICh0aGlzLnJlbmRlclRvID0gZiA9IFIuZ2V0RWxlbWVudEJ5SWQoZikpO1xuICAgICAgICBmIHx8IHEoMTMsICEwLCB0aGlzKTtcbiAgICAgICAgdmFyIG0gPSBRKEooZiwgXCJkYXRhLWhpZ2hjaGFydHMtY2hhcnRcIikpO1xuICAgICAgICBhKG0pICYmIFVbbV0gJiYgVVttXS5oYXNSZW5kZXJlZCAmJiBVW21dLmRlc3Ryb3koKTtcbiAgICAgICAgSihmLCBcImRhdGEtaGlnaGNoYXJ0cy1jaGFydFwiLCB0aGlzLmluZGV4KTtcbiAgICAgICAgZi5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICBlLnNraXBDbG9uZSB8fCBmLm9mZnNldFdpZHRoIHx8IHRoaXMudGVtcG9yYXJ5RGlzcGxheSgpO1xuICAgICAgICB0aGlzLmdldENoYXJ0U2l6ZSgpO1xuICAgICAgICBtID0gdGhpcy5jaGFydFdpZHRoO1xuICAgICAgICB2YXIgbiA9IHRoaXMuY2hhcnRIZWlnaHQ7XG4gICAgICAgIHQoZiwge1xuICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0eWxlZE1vZGUgfHwgKGwgPSBQKHtcbiAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgICAgIHdpZHRoOiBtICsgXCJweFwiLFxuICAgICAgICAgIGhlaWdodDogbiArIFwicHhcIixcbiAgICAgICAgICB0ZXh0QWxpZ246IFwibGVmdFwiLFxuICAgICAgICAgIGxpbmVIZWlnaHQ6IFwibm9ybWFsXCIsXG4gICAgICAgICAgekluZGV4OiAwLFxuICAgICAgICAgIFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCI6IFwicmdiYSgwLDAsMCwwKVwiXG4gICAgICAgIH0sIGUuc3R5bGUpKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBmID0geShcImRpdlwiLCB7XG4gICAgICAgICAgaWQ6IGtcbiAgICAgICAgfSwgbCwgZik7XG4gICAgICAgIHRoaXMuX2N1cnNvciA9IGYuc3R5bGUuY3Vyc29yO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IChkW2UucmVuZGVyZXJdIHx8IGQuUmVuZGVyZXIpKGYsIG0sIG4sIG51bGwsIGUuZm9yRXhwb3J0LCBiLmV4cG9ydGluZyAmJiBiLmV4cG9ydGluZy5hbGxvd0hUTUwsIHRoaXMuc3R5bGVkTW9kZSk7XG4gICAgICAgIHAodm9pZCAwLCB0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRDbGFzc05hbWUoZS5jbGFzc05hbWUpO1xuICAgICAgICBpZiAodGhpcy5zdHlsZWRNb2RlKSBmb3IgKGggaW4gYi5kZWZzKSB0aGlzLnJlbmRlcmVyLmRlZmluaXRpb24oYi5kZWZzW2hdKTtlbHNlIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZS5zdHlsZSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuY2hhcnRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIGModGhpcywgXCJhZnRlckdldENvbnRhaW5lclwiKTtcbiAgICAgIH0sXG4gICAgICBnZXRNYXJnaW5zOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuc3BhY2luZyxcbiAgICAgICAgICAgIGUgPSB0aGlzLm1hcmdpbixcbiAgICAgICAgICAgIGYgPSB0aGlzLnRpdGxlT2Zmc2V0O1xuICAgICAgICB0aGlzLnJlc2V0TWFyZ2lucygpO1xuICAgICAgICBmWzBdICYmICFEKGVbMF0pICYmICh0aGlzLnBsb3RUb3AgPSBNYXRoLm1heCh0aGlzLnBsb3RUb3AsIGZbMF0gKyBhWzBdKSk7XG4gICAgICAgIGZbMl0gJiYgIUQoZVsyXSkgJiYgKHRoaXMubWFyZ2luQm90dG9tID0gTWF0aC5tYXgodGhpcy5tYXJnaW5Cb3R0b20sIGZbMl0gKyBhWzJdKSk7XG4gICAgICAgIHRoaXMubGVnZW5kICYmIHRoaXMubGVnZW5kLmRpc3BsYXkgJiYgdGhpcy5sZWdlbmQuYWRqdXN0TWFyZ2lucyhlLCBhKTtcbiAgICAgICAgYyh0aGlzLCBcImdldE1hcmdpbnNcIik7XG4gICAgICAgIGIgfHwgdGhpcy5nZXRBeGlzTWFyZ2lucygpO1xuICAgICAgfSxcbiAgICAgIGdldEF4aXNNYXJnaW5zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcyxcbiAgICAgICAgICAgIGEgPSBiLmF4aXNPZmZzZXQgPSBbMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICBjID0gYi5jb2xvckF4aXMsXG4gICAgICAgICAgICBlID0gYi5tYXJnaW4sXG4gICAgICAgICAgICBmID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBiLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIGIudmlzaWJsZSAmJiBiLmdldE9mZnNldCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGIuaGFzQ2FydGVzaWFuU2VyaWVzID8gZihiLmF4ZXMpIDogYyAmJiBjLmxlbmd0aCAmJiBmKGMpO1xuICAgICAgICBtLmZvckVhY2goZnVuY3Rpb24gKGMsIGYpIHtcbiAgICAgICAgICBEKGVbZl0pIHx8IChiW2NdICs9IGFbZl0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYi5zZXRDaGFydFNpemUoKTtcbiAgICAgIH0sXG4gICAgICByZWZsb3c6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIGMgPSBhLm9wdGlvbnMuY2hhcnQsXG4gICAgICAgICAgICBlID0gYS5yZW5kZXJUbyxcbiAgICAgICAgICAgIGYgPSBEKGMud2lkdGgpICYmIEQoYy5oZWlnaHQpLFxuICAgICAgICAgICAgZCA9IGMud2lkdGggfHwgayhlLCBcIndpZHRoXCIpO1xuICAgICAgICBjID0gYy5oZWlnaHQgfHwgayhlLCBcImhlaWdodFwiKTtcbiAgICAgICAgZSA9IGIgPyBiLnRhcmdldCA6IFo7XG5cbiAgICAgICAgaWYgKCFmICYmICFhLmlzUHJpbnRpbmcgJiYgZCAmJiBjICYmIChlID09PSBaIHx8IGUgPT09IFIpKSB7XG4gICAgICAgICAgaWYgKGQgIT09IGEuY29udGFpbmVyV2lkdGggfHwgYyAhPT0gYS5jb250YWluZXJIZWlnaHQpIE0uY2xlYXJUaW1lb3V0KGEucmVmbG93VGltZW91dCksIGEucmVmbG93VGltZW91dCA9IEMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYS5jb250YWluZXIgJiYgYS5zZXRTaXplKHZvaWQgMCwgdm9pZCAwLCAhMSk7XG4gICAgICAgICAgfSwgYiA/IDEwMCA6IDApO1xuICAgICAgICAgIGEuY29udGFpbmVyV2lkdGggPSBkO1xuICAgICAgICAgIGEuY29udGFpbmVySGVpZ2h0ID0gYztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldFJlZmxvdzogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICAhMSA9PT0gYiB8fCB0aGlzLnVuYmluZFJlZmxvdyA/ICExID09PSBiICYmIHRoaXMudW5iaW5kUmVmbG93ICYmICh0aGlzLnVuYmluZFJlZmxvdyA9IHRoaXMudW5iaW5kUmVmbG93KCkpIDogKHRoaXMudW5iaW5kUmVmbG93ID0gRShaLCBcInJlc2l6ZVwiLCBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGEub3B0aW9ucyAmJiBhLnJlZmxvdyhiKTtcbiAgICAgICAgfSksIEUodGhpcywgXCJkZXN0cm95XCIsIHRoaXMudW5iaW5kUmVmbG93KSk7XG4gICAgICB9LFxuICAgICAgc2V0U2l6ZTogZnVuY3Rpb24gKGIsIGEsIGUpIHtcbiAgICAgICAgdmFyIGYgPSB0aGlzLFxuICAgICAgICAgICAgZCA9IGYucmVuZGVyZXI7XG4gICAgICAgIGYuaXNSZXNpemluZyArPSAxO1xuICAgICAgICBwKGUsIGYpO1xuICAgICAgICBlID0gZC5nbG9iYWxBbmltYXRpb247XG4gICAgICAgIGYub2xkQ2hhcnRIZWlnaHQgPSBmLmNoYXJ0SGVpZ2h0O1xuICAgICAgICBmLm9sZENoYXJ0V2lkdGggPSBmLmNoYXJ0V2lkdGg7XG4gICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBiICYmIChmLm9wdGlvbnMuY2hhcnQud2lkdGggPSBiKTtcbiAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGEgJiYgKGYub3B0aW9ucy5jaGFydC5oZWlnaHQgPSBhKTtcbiAgICAgICAgZi5nZXRDaGFydFNpemUoKTtcbiAgICAgICAgZi5zdHlsZWRNb2RlIHx8IChlID8gQSA6IHQpKGYuY29udGFpbmVyLCB7XG4gICAgICAgICAgd2lkdGg6IGYuY2hhcnRXaWR0aCArIFwicHhcIixcbiAgICAgICAgICBoZWlnaHQ6IGYuY2hhcnRIZWlnaHQgKyBcInB4XCJcbiAgICAgICAgfSwgZSk7XG4gICAgICAgIGYuc2V0Q2hhcnRTaXplKCEwKTtcbiAgICAgICAgZC5zZXRTaXplKGYuY2hhcnRXaWR0aCwgZi5jaGFydEhlaWdodCwgZSk7XG4gICAgICAgIGYuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYi5pc0RpcnR5ID0gITA7XG4gICAgICAgICAgYi5zZXRTY2FsZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgZi5pc0RpcnR5TGVnZW5kID0gITA7XG4gICAgICAgIGYuaXNEaXJ0eUJveCA9ICEwO1xuICAgICAgICBmLmxheU91dFRpdGxlcygpO1xuICAgICAgICBmLmdldE1hcmdpbnMoKTtcbiAgICAgICAgZi5yZWRyYXcoZSk7XG4gICAgICAgIGYub2xkQ2hhcnRIZWlnaHQgPSBudWxsO1xuICAgICAgICBjKGYsIFwicmVzaXplXCIpO1xuICAgICAgICBDKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmICYmIGMoZiwgXCJlbmRSZXNpemVcIiwgbnVsbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLS1mLmlzUmVzaXppbmc7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIEcoZSkuZHVyYXRpb24gfHwgMCk7XG4gICAgICB9LFxuICAgICAgc2V0Q2hhcnRTaXplOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuaW52ZXJ0ZWQsXG4gICAgICAgICAgICBlID0gdGhpcy5yZW5kZXJlcixcbiAgICAgICAgICAgIGYgPSB0aGlzLmNoYXJ0V2lkdGgsXG4gICAgICAgICAgICBkID0gdGhpcy5jaGFydEhlaWdodCxcbiAgICAgICAgICAgIGsgPSB0aGlzLm9wdGlvbnMuY2hhcnQsXG4gICAgICAgICAgICBsID0gdGhpcy5zcGFjaW5nLFxuICAgICAgICAgICAgaCA9IHRoaXMuY2xpcE9mZnNldCxcbiAgICAgICAgICAgIG0sXG4gICAgICAgICAgICBuLFxuICAgICAgICAgICAgcCxcbiAgICAgICAgICAgIHg7XG4gICAgICAgIHRoaXMucGxvdExlZnQgPSBtID0gTWF0aC5yb3VuZCh0aGlzLnBsb3RMZWZ0KTtcbiAgICAgICAgdGhpcy5wbG90VG9wID0gbiA9IE1hdGgucm91bmQodGhpcy5wbG90VG9wKTtcbiAgICAgICAgdGhpcy5wbG90V2lkdGggPSBwID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZChmIC0gbSAtIHRoaXMubWFyZ2luUmlnaHQpKTtcbiAgICAgICAgdGhpcy5wbG90SGVpZ2h0ID0geCA9IE1hdGgubWF4KDAsIE1hdGgucm91bmQoZCAtIG4gLSB0aGlzLm1hcmdpbkJvdHRvbSkpO1xuICAgICAgICB0aGlzLnBsb3RTaXplWCA9IGEgPyB4IDogcDtcbiAgICAgICAgdGhpcy5wbG90U2l6ZVkgPSBhID8gcCA6IHg7XG4gICAgICAgIHRoaXMucGxvdEJvcmRlcldpZHRoID0gay5wbG90Qm9yZGVyV2lkdGggfHwgMDtcbiAgICAgICAgdGhpcy5zcGFjaW5nQm94ID0gZS5zcGFjaW5nQm94ID0ge1xuICAgICAgICAgIHg6IGxbM10sXG4gICAgICAgICAgeTogbFswXSxcbiAgICAgICAgICB3aWR0aDogZiAtIGxbM10gLSBsWzFdLFxuICAgICAgICAgIGhlaWdodDogZCAtIGxbMF0gLSBsWzJdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGxvdEJveCA9IGUucGxvdEJveCA9IHtcbiAgICAgICAgICB4OiBtLFxuICAgICAgICAgIHk6IG4sXG4gICAgICAgICAgd2lkdGg6IHAsXG4gICAgICAgICAgaGVpZ2h0OiB4XG4gICAgICAgIH07XG4gICAgICAgIGYgPSAyICogTWF0aC5mbG9vcih0aGlzLnBsb3RCb3JkZXJXaWR0aCAvIDIpO1xuICAgICAgICBhID0gTWF0aC5jZWlsKE1hdGgubWF4KGYsIGhbM10pIC8gMik7XG4gICAgICAgIGUgPSBNYXRoLmNlaWwoTWF0aC5tYXgoZiwgaFswXSkgLyAyKTtcbiAgICAgICAgdGhpcy5jbGlwQm94ID0ge1xuICAgICAgICAgIHg6IGEsXG4gICAgICAgICAgeTogZSxcbiAgICAgICAgICB3aWR0aDogTWF0aC5mbG9vcih0aGlzLnBsb3RTaXplWCAtIE1hdGgubWF4KGYsIGhbMV0pIC8gMiAtIGEpLFxuICAgICAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgTWF0aC5mbG9vcih0aGlzLnBsb3RTaXplWSAtIE1hdGgubWF4KGYsIGhbMl0pIC8gMiAtIGUpKVxuICAgICAgICB9O1xuICAgICAgICBiIHx8IHRoaXMuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYi5zZXRBeGlzU2l6ZSgpO1xuICAgICAgICAgIGIuc2V0QXhpc1RyYW5zbGF0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjKHRoaXMsIFwiYWZ0ZXJTZXRDaGFydFNpemVcIiwge1xuICAgICAgICAgIHNraXBBeGVzOiBiXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHJlc2V0TWFyZ2luczogZnVuY3Rpb24gKCkge1xuICAgICAgICBjKHRoaXMsIFwicmVzZXRNYXJnaW5zXCIpO1xuICAgICAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgICAgICBhID0gYi5vcHRpb25zLmNoYXJ0O1xuICAgICAgICBbXCJtYXJnaW5cIiwgXCJzcGFjaW5nXCJdLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICB2YXIgZSA9IGFbY10sXG4gICAgICAgICAgICAgIGYgPSBsKGUpID8gZSA6IFtlLCBlLCBlLCBlXTtcbiAgICAgICAgICBbXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIl0uZm9yRWFjaChmdW5jdGlvbiAoZSwgZCkge1xuICAgICAgICAgICAgYltjXVtkXSA9IEwoYVtjICsgZV0sIGZbZF0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgICAgYlthXSA9IEwoYi5tYXJnaW5bY10sIGIuc3BhY2luZ1tjXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBiLmF4aXNPZmZzZXQgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIGIuY2xpcE9mZnNldCA9IFswLCAwLCAwLCAwXTtcbiAgICAgIH0sXG4gICAgICBkcmF3Q2hhcnRCb3g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLm9wdGlvbnMuY2hhcnQsXG4gICAgICAgICAgICBhID0gdGhpcy5yZW5kZXJlcixcbiAgICAgICAgICAgIGUgPSB0aGlzLmNoYXJ0V2lkdGgsXG4gICAgICAgICAgICBmID0gdGhpcy5jaGFydEhlaWdodCxcbiAgICAgICAgICAgIGQgPSB0aGlzLmNoYXJ0QmFja2dyb3VuZCxcbiAgICAgICAgICAgIGsgPSB0aGlzLnBsb3RCYWNrZ3JvdW5kLFxuICAgICAgICAgICAgbCA9IHRoaXMucGxvdEJvcmRlcixcbiAgICAgICAgICAgIGggPSB0aGlzLnN0eWxlZE1vZGUsXG4gICAgICAgICAgICBtID0gdGhpcy5wbG90QkdJbWFnZSxcbiAgICAgICAgICAgIG4gPSBiLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIHAgPSBiLnBsb3RCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICB4ID0gYi5wbG90QmFja2dyb3VuZEltYWdlLFxuICAgICAgICAgICAgZyxcbiAgICAgICAgICAgIHcgPSB0aGlzLnBsb3RMZWZ0LFxuICAgICAgICAgICAgQyA9IHRoaXMucGxvdFRvcCxcbiAgICAgICAgICAgIHYgPSB0aGlzLnBsb3RXaWR0aCxcbiAgICAgICAgICAgIHEgPSB0aGlzLnBsb3RIZWlnaHQsXG4gICAgICAgICAgICB0ID0gdGhpcy5wbG90Qm94LFxuICAgICAgICAgICAgQiA9IHRoaXMuY2xpcFJlY3QsXG4gICAgICAgICAgICB6ID0gdGhpcy5jbGlwQm94LFxuICAgICAgICAgICAgTyA9IFwiYW5pbWF0ZVwiO1xuICAgICAgICBkIHx8ICh0aGlzLmNoYXJ0QmFja2dyb3VuZCA9IGQgPSBhLnJlY3QoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtYmFja2dyb3VuZFwiKS5hZGQoKSwgTyA9IFwiYXR0clwiKTtcbiAgICAgICAgaWYgKGgpIHZhciB5ID0gZyA9IGQuc3Ryb2tlV2lkdGgoKTtlbHNlIHtcbiAgICAgICAgICB5ID0gYi5ib3JkZXJXaWR0aCB8fCAwO1xuICAgICAgICAgIGcgPSB5ICsgKGIuc2hhZG93ID8gOCA6IDApO1xuICAgICAgICAgIG4gPSB7XG4gICAgICAgICAgICBmaWxsOiBuIHx8IFwibm9uZVwiXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoeSB8fCBkW1wic3Ryb2tlLXdpZHRoXCJdKSBuLnN0cm9rZSA9IGIuYm9yZGVyQ29sb3IsIG5bXCJzdHJva2Utd2lkdGhcIl0gPSB5O1xuICAgICAgICAgIGQuYXR0cihuKS5zaGFkb3coYi5zaGFkb3cpO1xuICAgICAgICB9XG4gICAgICAgIGRbT10oe1xuICAgICAgICAgIHg6IGcgLyAyLFxuICAgICAgICAgIHk6IGcgLyAyLFxuICAgICAgICAgIHdpZHRoOiBlIC0gZyAtIHkgJSAyLFxuICAgICAgICAgIGhlaWdodDogZiAtIGcgLSB5ICUgMixcbiAgICAgICAgICByOiBiLmJvcmRlclJhZGl1c1xuICAgICAgICB9KTtcbiAgICAgICAgTyA9IFwiYW5pbWF0ZVwiO1xuICAgICAgICBrIHx8IChPID0gXCJhdHRyXCIsIHRoaXMucGxvdEJhY2tncm91bmQgPSBrID0gYS5yZWN0KCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXBsb3QtYmFja2dyb3VuZFwiKS5hZGQoKSk7XG4gICAgICAgIGtbT10odCk7XG4gICAgICAgIGggfHwgKGsuYXR0cih7XG4gICAgICAgICAgZmlsbDogcCB8fCBcIm5vbmVcIlxuICAgICAgICB9KS5zaGFkb3coYi5wbG90U2hhZG93KSwgeCAmJiAobSA/ICh4ICE9PSBtLmF0dHIoXCJocmVmXCIpICYmIG0uYXR0cihcImhyZWZcIiwgeCksIG0uYW5pbWF0ZSh0KSkgOiB0aGlzLnBsb3RCR0ltYWdlID0gYS5pbWFnZSh4LCB3LCBDLCB2LCBxKS5hZGQoKSkpO1xuICAgICAgICBCID8gQi5hbmltYXRlKHtcbiAgICAgICAgICB3aWR0aDogei53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHouaGVpZ2h0XG4gICAgICAgIH0pIDogdGhpcy5jbGlwUmVjdCA9IGEuY2xpcFJlY3Qoeik7XG4gICAgICAgIE8gPSBcImFuaW1hdGVcIjtcbiAgICAgICAgbCB8fCAoTyA9IFwiYXR0clwiLCB0aGlzLnBsb3RCb3JkZXIgPSBsID0gYS5yZWN0KCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXBsb3QtYm9yZGVyXCIpLmF0dHIoe1xuICAgICAgICAgIHpJbmRleDogMVxuICAgICAgICB9KS5hZGQoKSk7XG4gICAgICAgIGggfHwgbC5hdHRyKHtcbiAgICAgICAgICBzdHJva2U6IGIucGxvdEJvcmRlckNvbG9yLFxuICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IGIucGxvdEJvcmRlcldpZHRoIHx8IDAsXG4gICAgICAgICAgZmlsbDogXCJub25lXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGxbT10obC5jcmlzcCh7XG4gICAgICAgICAgeDogdyxcbiAgICAgICAgICB5OiBDLFxuICAgICAgICAgIHdpZHRoOiB2LFxuICAgICAgICAgIGhlaWdodDogcVxuICAgICAgICB9LCAtbC5zdHJva2VXaWR0aCgpKSk7XG4gICAgICAgIHRoaXMuaXNEaXJ0eUJveCA9ICExO1xuICAgICAgICBjKHRoaXMsIFwiYWZ0ZXJEcmF3Q2hhcnRCb3hcIik7XG4gICAgICB9LFxuICAgICAgcHJvcEZyb21TZXJpZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICAgICAgYSA9IGIub3B0aW9ucy5jaGFydCxcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBlID0gYi5vcHRpb25zLnNlcmllcyxcbiAgICAgICAgICAgIGYsXG4gICAgICAgICAgICBkO1xuICAgICAgICBbXCJpbnZlcnRlZFwiLCBcImFuZ3VsYXJcIiwgXCJwb2xhclwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgYyA9IFRbYS50eXBlIHx8IGEuZGVmYXVsdFNlcmllc1R5cGVdO1xuICAgICAgICAgIGQgPSBhW2tdIHx8IGMgJiYgYy5wcm90b3R5cGVba107XG5cbiAgICAgICAgICBmb3IgKGYgPSBlICYmIGUubGVuZ3RoOyAhZCAmJiBmLS07KSAoYyA9IFRbZVtmXS50eXBlXSkgJiYgYy5wcm90b3R5cGVba10gJiYgKGQgPSAhMCk7XG5cbiAgICAgICAgICBiW2tdID0gZDtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgbGlua1NlcmllczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgICAgICBhID0gYi5zZXJpZXM7XG4gICAgICAgIGEuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGIubGlua2VkU2VyaWVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH0pO1xuICAgICAgICBhLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICB2YXIgYyA9IGEub3B0aW9ucy5saW5rZWRUbztcbiAgICAgICAgICB2KGMpICYmIChjID0gXCI6cHJldmlvdXNcIiA9PT0gYyA/IGIuc2VyaWVzW2EuaW5kZXggLSAxXSA6IGIuZ2V0KGMpKSAmJiBjLmxpbmtlZFBhcmVudCAhPT0gYSAmJiAoYy5saW5rZWRTZXJpZXMucHVzaChhKSwgYS5saW5rZWRQYXJlbnQgPSBjLCBjLmVuYWJsZWREYXRhU29ydGluZyAmJiBhLnNldERhdGFTb3J0aW5nT3B0aW9ucygpLCBhLnZpc2libGUgPSBMKGEub3B0aW9ucy52aXNpYmxlLCBjLm9wdGlvbnMudmlzaWJsZSwgYS52aXNpYmxlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjKHRoaXMsIFwiYWZ0ZXJMaW5rU2VyaWVzXCIpO1xuICAgICAgfSxcbiAgICAgIHJlbmRlclNlcmllczogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYi50cmFuc2xhdGUoKTtcbiAgICAgICAgICBiLnJlbmRlcigpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICByZW5kZXJMYWJlbHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICAgICAgYSA9IGIub3B0aW9ucy5sYWJlbHM7XG4gICAgICAgIGEuaXRlbXMgJiYgYS5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgdmFyIGUgPSBQKGEuc3R5bGUsIGMuc3R5bGUpLFxuICAgICAgICAgICAgICBmID0gUShlLmxlZnQpICsgYi5wbG90TGVmdCxcbiAgICAgICAgICAgICAgZCA9IFEoZS50b3ApICsgYi5wbG90VG9wICsgMTI7XG4gICAgICAgICAgZGVsZXRlIGUubGVmdDtcbiAgICAgICAgICBkZWxldGUgZS50b3A7XG4gICAgICAgICAgYi5yZW5kZXJlci50ZXh0KGMuaHRtbCwgZiwgZCkuYXR0cih7XG4gICAgICAgICAgICB6SW5kZXg6IDJcbiAgICAgICAgICB9KS5jc3MoZSkuYWRkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMuYXhlcyxcbiAgICAgICAgICAgIGEgPSB0aGlzLmNvbG9yQXhpcyxcbiAgICAgICAgICAgIGMgPSB0aGlzLnJlbmRlcmVyLFxuICAgICAgICAgICAgZSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGYgPSAwLFxuICAgICAgICAgICAgZCA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYi5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICBiLnZpc2libGUgJiYgYi5yZW5kZXIoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNldFRpdGxlKCk7XG4gICAgICAgIHRoaXMubGVnZW5kID0gbmV3IGcodGhpcywgZS5sZWdlbmQpO1xuICAgICAgICB0aGlzLmdldFN0YWNrcyAmJiB0aGlzLmdldFN0YWNrcygpO1xuICAgICAgICB0aGlzLmdldE1hcmdpbnMoITApO1xuICAgICAgICB0aGlzLnNldENoYXJ0U2l6ZSgpO1xuICAgICAgICBlID0gdGhpcy5wbG90V2lkdGg7XG4gICAgICAgIGIuc29tZShmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGlmIChiLmhvcml6ICYmIGIudmlzaWJsZSAmJiBiLm9wdGlvbnMubGFiZWxzLmVuYWJsZWQgJiYgYi5zZXJpZXMubGVuZ3RoKSByZXR1cm4gZiA9IDIxLCAhMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBrID0gdGhpcy5wbG90SGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5wbG90SGVpZ2h0IC0gZiwgMCk7XG4gICAgICAgIGIuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGIuc2V0U2NhbGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ2V0QXhpc01hcmdpbnMoKTtcbiAgICAgICAgdmFyIGwgPSAxLjEgPCBlIC8gdGhpcy5wbG90V2lkdGg7XG4gICAgICAgIHZhciBoID0gMS4wNSA8IGsgLyB0aGlzLnBsb3RIZWlnaHQ7XG4gICAgICAgIGlmIChsIHx8IGgpIGIuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIChiLmhvcml6ICYmIGwgfHwgIWIuaG9yaXogJiYgaCkgJiYgYi5zZXRUaWNrSW50ZXJ2YWwoITApO1xuICAgICAgICB9KSwgdGhpcy5nZXRNYXJnaW5zKCk7XG4gICAgICAgIHRoaXMuZHJhd0NoYXJ0Qm94KCk7XG4gICAgICAgIHRoaXMuaGFzQ2FydGVzaWFuU2VyaWVzID8gZChiKSA6IGEgJiYgYS5sZW5ndGggJiYgZChhKTtcbiAgICAgICAgdGhpcy5zZXJpZXNHcm91cCB8fCAodGhpcy5zZXJpZXNHcm91cCA9IGMuZyhcInNlcmllcy1ncm91cFwiKS5hdHRyKHtcbiAgICAgICAgICB6SW5kZXg6IDNcbiAgICAgICAgfSkuYWRkKCkpO1xuICAgICAgICB0aGlzLnJlbmRlclNlcmllcygpO1xuICAgICAgICB0aGlzLnJlbmRlckxhYmVscygpO1xuICAgICAgICB0aGlzLmFkZENyZWRpdHMoKTtcbiAgICAgICAgdGhpcy5zZXRSZXNwb25zaXZlICYmIHRoaXMuc2V0UmVzcG9uc2l2ZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbnRhaW5lclNjYWxpbmcoKTtcbiAgICAgICAgdGhpcy5oYXNSZW5kZXJlZCA9ICEwO1xuICAgICAgfSxcbiAgICAgIGFkZENyZWRpdHM6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgYiA9IHooITAsIHRoaXMub3B0aW9ucy5jcmVkaXRzLCBiKTtcbiAgICAgICAgYi5lbmFibGVkICYmICF0aGlzLmNyZWRpdHMgJiYgKHRoaXMuY3JlZGl0cyA9IHRoaXMucmVuZGVyZXIudGV4dChiLnRleHQgKyAodGhpcy5tYXBDcmVkaXRzIHx8IFwiXCIpLCAwLCAwKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtY3JlZGl0c1wiKS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBiLmhyZWYgJiYgKFoubG9jYXRpb24uaHJlZiA9IGIuaHJlZik7XG4gICAgICAgIH0pLmF0dHIoe1xuICAgICAgICAgIGFsaWduOiBiLnBvc2l0aW9uLmFsaWduLFxuICAgICAgICAgIHpJbmRleDogOFxuICAgICAgICB9KSwgYS5zdHlsZWRNb2RlIHx8IHRoaXMuY3JlZGl0cy5jc3MoYi5zdHlsZSksIHRoaXMuY3JlZGl0cy5hZGQoKS5hbGlnbihiLnBvc2l0aW9uKSwgdGhpcy5jcmVkaXRzLnVwZGF0ZSA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYS5jcmVkaXRzID0gYS5jcmVkaXRzLmRlc3Ryb3koKTtcbiAgICAgICAgICBhLmFkZENyZWRpdHMoYik7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZUNvbnRhaW5lclNjYWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmNvbnRhaW5lcjtcblxuICAgICAgICBpZiAoYi5vZmZzZXRXaWR0aCAmJiBiLm9mZnNldEhlaWdodCAmJiBiLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xuICAgICAgICAgIHZhciBhID0gYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgYyA9IGEud2lkdGggLyBiLm9mZnNldFdpZHRoO1xuICAgICAgICAgIGIgPSBhLmhlaWdodCAvIGIub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIDEgIT09IGMgfHwgMSAhPT0gYiA/IHRoaXMuY29udGFpbmVyU2NhbGluZyA9IHtcbiAgICAgICAgICAgIHNjYWxlWDogYyxcbiAgICAgICAgICAgIHNjYWxlWTogYlxuICAgICAgICAgIH0gOiBkZWxldGUgdGhpcy5jb250YWluZXJTY2FsaW5nO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgICAgICBhID0gYi5heGVzLFxuICAgICAgICAgICAgZSA9IGIuc2VyaWVzLFxuICAgICAgICAgICAgZiA9IGIuY29udGFpbmVyLFxuICAgICAgICAgICAgayxcbiAgICAgICAgICAgIGwgPSBmICYmIGYucGFyZW50Tm9kZTtcbiAgICAgICAgYyhiLCBcImRlc3Ryb3lcIik7XG4gICAgICAgIGIucmVuZGVyZXIuZm9yRXhwb3J0ID8gTihVLCBiKSA6IFVbYi5pbmRleF0gPSB2b2lkIDA7XG4gICAgICAgIGQuY2hhcnRDb3VudC0tO1xuICAgICAgICBiLnJlbmRlclRvLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtaGlnaGNoYXJ0cy1jaGFydFwiKTtcbiAgICAgICAgSyhiKTtcblxuICAgICAgICBmb3IgKGsgPSBhLmxlbmd0aDsgay0tOykgYVtrXSA9IGFba10uZGVzdHJveSgpO1xuXG4gICAgICAgIHRoaXMuc2Nyb2xsZXIgJiYgdGhpcy5zY3JvbGxlci5kZXN0cm95ICYmIHRoaXMuc2Nyb2xsZXIuZGVzdHJveSgpO1xuXG4gICAgICAgIGZvciAoayA9IGUubGVuZ3RoOyBrLS07KSBlW2tdID0gZVtrXS5kZXN0cm95KCk7XG5cbiAgICAgICAgXCJ0aXRsZSBzdWJ0aXRsZSBjaGFydEJhY2tncm91bmQgcGxvdEJhY2tncm91bmQgcGxvdEJHSW1hZ2UgcGxvdEJvcmRlciBzZXJpZXNHcm91cCBjbGlwUmVjdCBjcmVkaXRzIHBvaW50ZXIgcmFuZ2VTZWxlY3RvciBsZWdlbmQgcmVzZXRab29tQnV0dG9uIHRvb2x0aXAgcmVuZGVyZXJcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHZhciBjID0gYlthXTtcbiAgICAgICAgICBjICYmIGMuZGVzdHJveSAmJiAoYlthXSA9IGMuZGVzdHJveSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGYgJiYgKGYuaW5uZXJIVE1MID0gXCJcIiwgSyhmKSwgbCAmJiBoKGYpKTtcbiAgICAgICAgQihiLCBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICAgIGRlbGV0ZSBiW2NdO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmaXJzdFJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgICAgICBhID0gYi5vcHRpb25zO1xuXG4gICAgICAgIGlmICghYi5pc1JlYWR5VG9SZW5kZXIgfHwgYi5pc1JlYWR5VG9SZW5kZXIoKSkge1xuICAgICAgICAgIGIuZ2V0Q29udGFpbmVyKCk7XG4gICAgICAgICAgYi5yZXNldE1hcmdpbnMoKTtcbiAgICAgICAgICBiLnNldENoYXJ0U2l6ZSgpO1xuICAgICAgICAgIGIucHJvcEZyb21TZXJpZXMoKTtcbiAgICAgICAgICBiLmdldEF4ZXMoKTtcbiAgICAgICAgICAobihhLnNlcmllcykgPyBhLnNlcmllcyA6IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBiLmluaXRTZXJpZXMoYSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYi5saW5rU2VyaWVzKCk7XG4gICAgICAgICAgYi5zZXRTZXJpZXNEYXRhKCk7XG4gICAgICAgICAgYyhiLCBcImJlZm9yZVJlbmRlclwiKTtcbiAgICAgICAgICB1ICYmIChiLnBvaW50ZXIgPSBkLmhhc1RvdWNoIHx8ICFaLlBvaW50ZXJFdmVudCAmJiAhWi5NU1BvaW50ZXJFdmVudCA/IG5ldyB1KGIsIGEpIDogbmV3IHIoYiwgYSkpO1xuICAgICAgICAgIGIucmVuZGVyKCk7XG4gICAgICAgICAgaWYgKCFiLnJlbmRlcmVyLmltZ0NvdW50ICYmICFiLmhhc0xvYWRlZCkgYi5vbmxvYWQoKTtcbiAgICAgICAgICBiLnRlbXBvcmFyeURpc3BsYXkoITApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25sb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmNvbmNhdChbdGhpcy5jYWxsYmFja10pLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBiICYmIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiB0aGlzLmluZGV4ICYmIGIuYXBwbHkodGhpcywgW3RoaXNdKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGModGhpcywgXCJsb2FkXCIpO1xuICAgICAgICBjKHRoaXMsIFwicmVuZGVyXCIpO1xuICAgICAgICBEKHRoaXMuaW5kZXgpICYmIHRoaXMuc2V0UmVmbG93KHRoaXMub3B0aW9ucy5jaGFydC5yZWZsb3cpO1xuICAgICAgICB0aGlzLmhhc0xvYWRlZCA9ICEwO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL1Njcm9sbGFibGVQbG90QXJlYS5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZykge1xuICAgIHZhciByID0gZy5hZGRFdmVudCxcbiAgICAgICAgdSA9IGcuY3JlYXRlRWxlbWVudCxcbiAgICAgICAgSSA9IGcucGljayxcbiAgICAgICAgTSA9IGcuc3RvcDtcbiAgICBnID0gZC5DaGFydDtcbiAgICBcIlwiO1xuICAgIHIoZywgXCJhZnRlclNldENoYXJ0U2l6ZVwiLCBmdW5jdGlvbiAoZykge1xuICAgICAgdmFyIHUgPSB0aGlzLm9wdGlvbnMuY2hhcnQuc2Nyb2xsYWJsZVBsb3RBcmVhLFxuICAgICAgICAgIHIgPSB1ICYmIHUubWluV2lkdGg7XG4gICAgICB1ID0gdSAmJiB1Lm1pbkhlaWdodDtcblxuICAgICAgaWYgKCF0aGlzLnJlbmRlcmVyLmZvckV4cG9ydCkge1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgIGlmICh0aGlzLnNjcm9sbGFibGVQaXhlbHNYID0gciA9IE1hdGgubWF4KDAsIHIgLSB0aGlzLmNoYXJ0V2lkdGgpKSB7XG4gICAgICAgICAgICB0aGlzLnBsb3RXaWR0aCArPSByO1xuICAgICAgICAgICAgdGhpcy5pbnZlcnRlZCA/ICh0aGlzLmNsaXBCb3guaGVpZ2h0ICs9IHIsIHRoaXMucGxvdEJveC5oZWlnaHQgKz0gcikgOiAodGhpcy5jbGlwQm94LndpZHRoICs9IHIsIHRoaXMucGxvdEJveC53aWR0aCArPSByKTtcbiAgICAgICAgICAgIHZhciBFID0ge1xuICAgICAgICAgICAgICAxOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJyaWdodFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgdSAmJiAodGhpcy5zY3JvbGxhYmxlUGl4ZWxzWSA9IHIgPSBNYXRoLm1heCgwLCB1IC0gdGhpcy5jaGFydEhlaWdodCkpICYmICh0aGlzLnBsb3RIZWlnaHQgKz0gciwgdGhpcy5pbnZlcnRlZCA/ICh0aGlzLmNsaXBCb3gud2lkdGggKz0gciwgdGhpcy5wbG90Qm94LndpZHRoICs9IHIpIDogKHRoaXMuY2xpcEJveC5oZWlnaHQgKz0gciwgdGhpcy5wbG90Qm94LmhlaWdodCArPSByKSwgRSA9IHtcbiAgICAgICAgICAyOiB7XG4gICAgICAgICAgICBuYW1lOiBcImJvdHRvbVwiLFxuICAgICAgICAgICAgdmFsdWU6IHJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIEUgJiYgIWcuc2tpcEF4ZXMgJiYgdGhpcy5heGVzLmZvckVhY2goZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgICBFW2cuc2lkZV0gPyBnLmdldFBsb3RMaW5lUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0ID0gRVtnLnNpZGVdLm5hbWUsXG4gICAgICAgICAgICAgICAgeSA9IHRoaXNbdF07XG4gICAgICAgICAgICB0aGlzW3RdID0geSAtIEVbZy5zaWRlXS52YWx1ZTtcbiAgICAgICAgICAgIHZhciBoID0gZC5BeGlzLnByb3RvdHlwZS5nZXRQbG90TGluZVBhdGguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXNbdF0gPSB5O1xuICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgICAgfSA6IChnLnNldEF4aXNTaXplKCksIGcuc2V0QXhpc1RyYW5zbGF0aW9uKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByKGcsIFwicmVuZGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1ggfHwgdGhpcy5zY3JvbGxhYmxlUGl4ZWxzWSA/ICh0aGlzLnNldFVwU2Nyb2xsaW5nICYmIHRoaXMuc2V0VXBTY3JvbGxpbmcoKSwgdGhpcy5hcHBseUZpeGVkKCkpIDogdGhpcy5maXhlZERpdiAmJiB0aGlzLmFwcGx5Rml4ZWQoKTtcbiAgICB9KTtcblxuICAgIGcucHJvdG90eXBlLnNldFVwU2Nyb2xsaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgIGcgPSB7XG4gICAgICAgIFdlYmtpdE92ZXJmbG93U2Nyb2xsaW5nOiBcInRvdWNoXCIsXG4gICAgICAgIG92ZXJmbG93WDogXCJoaWRkZW5cIixcbiAgICAgICAgb3ZlcmZsb3dZOiBcImhpZGRlblwiXG4gICAgICB9O1xuICAgICAgdGhpcy5zY3JvbGxhYmxlUGl4ZWxzWCAmJiAoZy5vdmVyZmxvd1ggPSBcImF1dG9cIik7XG4gICAgICB0aGlzLnNjcm9sbGFibGVQaXhlbHNZICYmIChnLm92ZXJmbG93WSA9IFwiYXV0b1wiKTtcbiAgICAgIHRoaXMuc2Nyb2xsaW5nQ29udGFpbmVyID0gdShcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJoaWdoY2hhcnRzLXNjcm9sbGluZ1wiXG4gICAgICB9LCBnLCB0aGlzLnJlbmRlclRvKTtcbiAgICAgIHIodGhpcy5zY3JvbGxpbmdDb250YWluZXIsIFwic2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZC5wb2ludGVyICYmIGRlbGV0ZSBkLnBvaW50ZXIuY2hhcnRQb3NpdGlvbjtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5pbm5lckNvbnRhaW5lciA9IHUoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwiaGlnaGNoYXJ0cy1pbm5lci1jb250YWluZXJcIlxuICAgICAgfSwgbnVsbCwgdGhpcy5zY3JvbGxpbmdDb250YWluZXIpO1xuICAgICAgdGhpcy5pbm5lckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICB0aGlzLnNldFVwU2Nyb2xsaW5nID0gbnVsbDtcbiAgICB9O1xuXG4gICAgZy5wcm90b3R5cGUubW92ZUZpeGVkRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZCA9IHRoaXMuY29udGFpbmVyLFxuICAgICAgICAgIGcgPSB0aGlzLmZpeGVkUmVuZGVyZXIsXG4gICAgICAgICAgdSA9IFwiLmhpZ2hjaGFydHMtY29udGV4dGJ1dHRvbiAuaGlnaGNoYXJ0cy1jcmVkaXRzIC5oaWdoY2hhcnRzLWxlZ2VuZCAuaGlnaGNoYXJ0cy1sZWdlbmQtY2hlY2tib3ggLmhpZ2hjaGFydHMtbmF2aWdhdG9yLXNlcmllcyAuaGlnaGNoYXJ0cy1uYXZpZ2F0b3IteGF4aXMgLmhpZ2hjaGFydHMtbmF2aWdhdG9yLXlheGlzIC5oaWdoY2hhcnRzLW5hdmlnYXRvciAuaGlnaGNoYXJ0cy1yZXNldC16b29tIC5oaWdoY2hhcnRzLXNjcm9sbGJhciAuaGlnaGNoYXJ0cy1zdWJ0aXRsZSAuaGlnaGNoYXJ0cy10aXRsZVwiLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgICByO1xuICAgICAgdGhpcy5zY3JvbGxhYmxlUGl4ZWxzWCAmJiAhdGhpcy5pbnZlcnRlZCA/IHIgPSBcIi5oaWdoY2hhcnRzLXlheGlzXCIgOiB0aGlzLnNjcm9sbGFibGVQaXhlbHNYICYmIHRoaXMuaW52ZXJ0ZWQgPyByID0gXCIuaGlnaGNoYXJ0cy14YXhpc1wiIDogdGhpcy5zY3JvbGxhYmxlUGl4ZWxzWSAmJiAhdGhpcy5pbnZlcnRlZCA/IHIgPSBcIi5oaWdoY2hhcnRzLXhheGlzXCIgOiB0aGlzLnNjcm9sbGFibGVQaXhlbHNZICYmIHRoaXMuaW52ZXJ0ZWQgJiYgKHIgPSBcIi5oaWdoY2hhcnRzLXlheGlzXCIpO1xuICAgICAgdS5wdXNoKHIsIHIgKyBcIi1sYWJlbHNcIik7XG4gICAgICB1LmZvckVhY2goZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgW10uZm9yRWFjaC5jYWxsKGQucXVlcnlTZWxlY3RvckFsbCh5KSwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAoZC5uYW1lc3BhY2VVUkkgPT09IGcuU1ZHX05TID8gZy5ib3ggOiBnLmJveC5wYXJlbnROb2RlKS5hcHBlbmRDaGlsZChkKTtcbiAgICAgICAgICBkLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZy5wcm90b3R5cGUuYXBwbHlGaXhlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBnLFxuICAgICAgICAgIEEgPSAhdGhpcy5maXhlZERpdixcbiAgICAgICAgICBHID0gdGhpcy5vcHRpb25zLmNoYXJ0LnNjcm9sbGFibGVQbG90QXJlYTtcbiAgICAgIEEgPyAodGhpcy5maXhlZERpdiA9IHUoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwiaGlnaGNoYXJ0cy1maXhlZFwiXG4gICAgICB9LCB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICAgICAgekluZGV4OiAyXG4gICAgICB9LCBudWxsLCAhMCksIHRoaXMucmVuZGVyVG8uaW5zZXJ0QmVmb3JlKHRoaXMuZml4ZWREaXYsIHRoaXMucmVuZGVyVG8uZmlyc3RDaGlsZCksIHRoaXMucmVuZGVyVG8uc3R5bGUub3ZlcmZsb3cgPSBcInZpc2libGVcIiwgdGhpcy5maXhlZFJlbmRlcmVyID0gZyA9IG5ldyBkLlJlbmRlcmVyKHRoaXMuZml4ZWREaXYsIHRoaXMuY2hhcnRXaWR0aCwgdGhpcy5jaGFydEhlaWdodCksIHRoaXMuc2Nyb2xsYWJsZU1hc2sgPSBnLnBhdGgoKS5hdHRyKHtcbiAgICAgICAgZmlsbDogdGhpcy5vcHRpb25zLmNoYXJ0LmJhY2tncm91bmRDb2xvciB8fCBcIiNmZmZcIixcbiAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjogSShHLm9wYWNpdHksIC44NSksXG4gICAgICAgIHpJbmRleDogLTFcbiAgICAgIH0pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1zY3JvbGxhYmxlLW1hc2tcIikuYWRkKCksIHRoaXMubW92ZUZpeGVkRWxlbWVudHMoKSwgcih0aGlzLCBcImFmdGVyU2hvd1Jlc2V0Wm9vbVwiLCB0aGlzLm1vdmVGaXhlZEVsZW1lbnRzKSwgcih0aGlzLCBcImFmdGVyTGF5T3V0VGl0bGVzXCIsIHRoaXMubW92ZUZpeGVkRWxlbWVudHMpKSA6IHRoaXMuZml4ZWRSZW5kZXJlci5zZXRTaXplKHRoaXMuY2hhcnRXaWR0aCwgdGhpcy5jaGFydEhlaWdodCk7XG4gICAgICBnID0gdGhpcy5jaGFydFdpZHRoICsgKHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1ggfHwgMCk7XG4gICAgICB2YXIgSiA9IHRoaXMuY2hhcnRIZWlnaHQgKyAodGhpcy5zY3JvbGxhYmxlUGl4ZWxzWSB8fCAwKTtcbiAgICAgIE0odGhpcy5jb250YWluZXIpO1xuICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUud2lkdGggPSBnICsgXCJweFwiO1xuICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gSiArIFwicHhcIjtcbiAgICAgIHRoaXMucmVuZGVyZXIuYm94V3JhcHBlci5hdHRyKHtcbiAgICAgICAgd2lkdGg6IGcsXG4gICAgICAgIGhlaWdodDogSixcbiAgICAgICAgdmlld0JveDogWzAsIDAsIGcsIEpdLmpvaW4oXCIgXCIpXG4gICAgICB9KTtcbiAgICAgIHRoaXMuY2hhcnRCYWNrZ3JvdW5kLmF0dHIoe1xuICAgICAgICB3aWR0aDogZyxcbiAgICAgICAgaGVpZ2h0OiBKXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1kgJiYgKHRoaXMuc2Nyb2xsaW5nQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHRoaXMuY2hhcnRIZWlnaHQgKyBcInB4XCIpO1xuICAgICAgQSAmJiAoRy5zY3JvbGxQb3NpdGlvblggJiYgKHRoaXMuc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbGFibGVQaXhlbHNYICogRy5zY3JvbGxQb3NpdGlvblgpLCBHLnNjcm9sbFBvc2l0aW9uWSAmJiAodGhpcy5zY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxhYmxlUGl4ZWxzWSAqIEcuc2Nyb2xsUG9zaXRpb25ZKSk7XG4gICAgICBKID0gdGhpcy5heGlzT2Zmc2V0O1xuICAgICAgQSA9IHRoaXMucGxvdFRvcCAtIEpbMF0gLSAxO1xuICAgICAgRyA9IHRoaXMucGxvdExlZnQgLSBKWzNdIC0gMTtcbiAgICAgIGcgPSB0aGlzLnBsb3RUb3AgKyB0aGlzLnBsb3RIZWlnaHQgKyBKWzJdICsgMTtcbiAgICAgIEogPSB0aGlzLnBsb3RMZWZ0ICsgdGhpcy5wbG90V2lkdGggKyBKWzFdICsgMTtcbiAgICAgIHZhciB5ID0gdGhpcy5wbG90TGVmdCArIHRoaXMucGxvdFdpZHRoIC0gKHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1ggfHwgMCksXG4gICAgICAgICAgdCA9IHRoaXMucGxvdFRvcCArIHRoaXMucGxvdEhlaWdodCAtICh0aGlzLnNjcm9sbGFibGVQaXhlbHNZIHx8IDApO1xuICAgICAgQSA9IHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1ggPyBbXCJNXCIsIDAsIEEsIFwiTFwiLCB0aGlzLnBsb3RMZWZ0IC0gMSwgQSwgXCJMXCIsIHRoaXMucGxvdExlZnQgLSAxLCBnLCBcIkxcIiwgMCwgZywgXCJaXCIsIFwiTVwiLCB5LCBBLCBcIkxcIiwgdGhpcy5jaGFydFdpZHRoLCBBLCBcIkxcIiwgdGhpcy5jaGFydFdpZHRoLCBnLCBcIkxcIiwgeSwgZywgXCJaXCJdIDogdGhpcy5zY3JvbGxhYmxlUGl4ZWxzWSA/IFtcIk1cIiwgRywgMCwgXCJMXCIsIEcsIHRoaXMucGxvdFRvcCAtIDEsIFwiTFwiLCBKLCB0aGlzLnBsb3RUb3AgLSAxLCBcIkxcIiwgSiwgMCwgXCJaXCIsIFwiTVwiLCBHLCB0LCBcIkxcIiwgRywgdGhpcy5jaGFydEhlaWdodCwgXCJMXCIsIEosIHRoaXMuY2hhcnRIZWlnaHQsIFwiTFwiLCBKLCB0LCBcIlpcIl0gOiBbXCJNXCIsIDAsIDBdO1xuICAgICAgXCJhZGp1c3RIZWlnaHRcIiAhPT0gdGhpcy5yZWRyYXdUcmlnZ2VyICYmIHRoaXMuc2Nyb2xsYWJsZU1hc2suYXR0cih7XG4gICAgICAgIGQ6IEFcbiAgICAgIH0pO1xuICAgIH07XG4gIH0pO1xuICBTKHIsIFwibWl4aW5zL2xlZ2VuZC1zeW1ib2wuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcpIHtcbiAgICB2YXIgciA9IGcubWVyZ2UsXG4gICAgICAgIHUgPSBnLnBpY2s7XG4gICAgZC5MZWdlbmRTeW1ib2xNaXhpbiA9IHtcbiAgICAgIGRyYXdSZWN0YW5nbGU6IGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgICAgIHZhciByID0gZC5zeW1ib2xIZWlnaHQsXG4gICAgICAgICAgICBBID0gZC5vcHRpb25zLnNxdWFyZVN5bWJvbDtcbiAgICAgICAgZy5sZWdlbmRTeW1ib2wgPSB0aGlzLmNoYXJ0LnJlbmRlcmVyLnJlY3QoQSA/IChkLnN5bWJvbFdpZHRoIC0gcikgLyAyIDogMCwgZC5iYXNlbGluZSAtIHIgKyAxLCBBID8gciA6IGQuc3ltYm9sV2lkdGgsIHIsIHUoZC5vcHRpb25zLnN5bWJvbFJhZGl1cywgciAvIDIpKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtcG9pbnRcIikuYXR0cih7XG4gICAgICAgICAgekluZGV4OiAzXG4gICAgICAgIH0pLmFkZChnLmxlZ2VuZEdyb3VwKTtcbiAgICAgIH0sXG4gICAgICBkcmF3TGluZU1hcmtlcjogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIGcgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBFID0gZy5tYXJrZXIsXG4gICAgICAgICAgICBBID0gZC5zeW1ib2xXaWR0aCxcbiAgICAgICAgICAgIEcgPSBkLnN5bWJvbEhlaWdodCxcbiAgICAgICAgICAgIEogPSBHIC8gMixcbiAgICAgICAgICAgIHkgPSB0aGlzLmNoYXJ0LnJlbmRlcmVyLFxuICAgICAgICAgICAgdCA9IHRoaXMubGVnZW5kR3JvdXA7XG4gICAgICAgIGQgPSBkLmJhc2VsaW5lIC0gTWF0aC5yb3VuZCguMyAqIGQuZm9udE1ldHJpY3MuYik7XG4gICAgICAgIHZhciBEID0ge307XG4gICAgICAgIHRoaXMuY2hhcnQuc3R5bGVkTW9kZSB8fCAoRCA9IHtcbiAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBnLmxpbmVXaWR0aCB8fCAwXG4gICAgICAgIH0sIGcuZGFzaFN0eWxlICYmIChELmRhc2hzdHlsZSA9IGcuZGFzaFN0eWxlKSk7XG4gICAgICAgIHRoaXMubGVnZW5kTGluZSA9IHkucGF0aChbXCJNXCIsIDAsIGQsIFwiTFwiLCBBLCBkXSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWdyYXBoXCIpLmF0dHIoRCkuYWRkKHQpO1xuICAgICAgICBFICYmICExICE9PSBFLmVuYWJsZWQgJiYgQSAmJiAoZyA9IE1hdGgubWluKHUoRS5yYWRpdXMsIEopLCBKKSwgMCA9PT0gdGhpcy5zeW1ib2wuaW5kZXhPZihcInVybFwiKSAmJiAoRSA9IHIoRSwge1xuICAgICAgICAgIHdpZHRoOiBHLFxuICAgICAgICAgIGhlaWdodDogR1xuICAgICAgICB9KSwgZyA9IDApLCB0aGlzLmxlZ2VuZFN5bWJvbCA9IEUgPSB5LnN5bWJvbCh0aGlzLnN5bWJvbCwgQSAvIDIgLSBnLCBkIC0gZywgMiAqIGcsIDIgKiBnLCBFKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtcG9pbnRcIikuYWRkKHQpLCBFLmlzTWFya2VyID0gITApO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGQuTGVnZW5kU3ltYm9sTWl4aW47XG4gIH0pO1xuICBTKHIsIFwicGFydHMvUG9pbnQuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcpIHtcbiAgICBcIlwiO1xuXG4gICAgdmFyIHIgPSBnLmFuaW1PYmplY3QsXG4gICAgICAgIHUgPSBnLmRlZmluZWQsXG4gICAgICAgIEkgPSBnLmVyYXNlLFxuICAgICAgICBNID0gZy5leHRlbmQsXG4gICAgICAgIEUgPSBnLmZvcm1hdCxcbiAgICAgICAgQSA9IGcuZ2V0TmVzdGVkUHJvcGVydHksXG4gICAgICAgIEcgPSBnLmlzQXJyYXksXG4gICAgICAgIEogPSBnLmlzTnVtYmVyLFxuICAgICAgICB5ID0gZy5pc09iamVjdCxcbiAgICAgICAgdCA9IGcuc3luY1RpbWVvdXQsXG4gICAgICAgIEQgPSBnLnBpY2ssXG4gICAgICAgIGggPSBnLnJlbW92ZUV2ZW50LFxuICAgICAgICBOID0gZy51bmlxdWVLZXksXG4gICAgICAgIHEgPSBkLmZpcmVFdmVudDtcblxuICAgIGcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBkKCkge1xuICAgICAgICB0aGlzLmNvbG9ySW5kZXggPSB0aGlzLmNhdGVnb3J5ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLmZvcm1hdFByZWZpeCA9IFwicG9pbnRcIjtcbiAgICAgICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5pc051bGwgPSAhMTtcbiAgICAgICAgdGhpcy5wZXJjZW50YWdlID0gdGhpcy5vcHRpb25zID0gdGhpcy5uYW1lID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gITE7XG4gICAgICAgIHRoaXMudG90YWwgPSB0aGlzLnNlcmllcyA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gITA7XG4gICAgICAgIHRoaXMueCA9IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgZC5wcm90b3R5cGUuYW5pbWF0ZUJlZm9yZURlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgICAgIGMgPSB7XG4gICAgICAgICAgeDogZS5zdGFydFhQb3MsXG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LFxuICAgICAgICAgICAgZCxcbiAgICAgICAgICAgIGggPSBlLmdldEdyYXBoaWNhbFByb3BzKCk7XG4gICAgICAgIGguc2luZ3VsYXIuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgIGQgPSBcImRhdGFMYWJlbFwiID09PSBmO1xuICAgICAgICAgIGVbZl0gPSBlW2ZdLmFuaW1hdGUoZCA/IHtcbiAgICAgICAgICAgIHg6IGVbZl0uc3RhcnRYUG9zLFxuICAgICAgICAgICAgeTogZVtmXS5zdGFydFlQb3MsXG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSA6IGMpO1xuICAgICAgICB9KTtcbiAgICAgICAgaC5wbHVyYWwuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGVbY10uZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYS5lbGVtZW50ICYmIGEuYW5pbWF0ZShNKHtcbiAgICAgICAgICAgICAgeDogZS5zdGFydFhQb3NcbiAgICAgICAgICAgIH0sIGEuc3RhcnRZUG9zID8ge1xuICAgICAgICAgICAgICB4OiBhLnN0YXJ0WFBvcyxcbiAgICAgICAgICAgICAgeTogYS5zdGFydFlQb3NcbiAgICAgICAgICAgIH0gOiB7fSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLmFwcGx5T3B0aW9ucyA9IGZ1bmN0aW9uIChlLCBjKSB7XG4gICAgICAgIHZhciBrID0gdGhpcy5zZXJpZXMsXG4gICAgICAgICAgICBoID0gay5vcHRpb25zLnBvaW50VmFsS2V5IHx8IGsucG9pbnRWYWxLZXk7XG4gICAgICAgIGUgPSBkLnByb3RvdHlwZS5vcHRpb25zVG9PYmplY3QuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgTSh0aGlzLCBlKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5vcHRpb25zID8gTSh0aGlzLm9wdGlvbnMsIGUpIDogZTtcbiAgICAgICAgZS5ncm91cCAmJiBkZWxldGUgdGhpcy5ncm91cDtcbiAgICAgICAgZS5kYXRhTGFiZWxzICYmIGRlbGV0ZSB0aGlzLmRhdGFMYWJlbHM7XG4gICAgICAgIGggJiYgKHRoaXMueSA9IGQucHJvdG90eXBlLmdldE5lc3RlZFByb3BlcnR5LmNhbGwodGhpcywgaCkpO1xuICAgICAgICB0aGlzLmZvcm1hdFByZWZpeCA9ICh0aGlzLmlzTnVsbCA9IEQodGhpcy5pc1ZhbGlkICYmICF0aGlzLmlzVmFsaWQoKSwgbnVsbCA9PT0gdGhpcy54IHx8ICFKKHRoaXMueSkpKSA/IFwibnVsbFwiIDogXCJwb2ludFwiO1xuICAgICAgICB0aGlzLnNlbGVjdGVkICYmICh0aGlzLnN0YXRlID0gXCJzZWxlY3RcIik7XG4gICAgICAgIFwibmFtZVwiIGluIHRoaXMgJiYgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGMgJiYgay54QXhpcyAmJiBrLnhBeGlzLmhhc05hbWVzICYmICh0aGlzLnggPSBrLnhBeGlzLm5hbWVUb1godGhpcykpO1xuICAgICAgICBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgdGhpcy54ICYmIGsgJiYgKHRoaXMueCA9IFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBjID8gay5hdXRvSW5jcmVtZW50KHRoaXMpIDogYyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgICAgICBpZiAoYy5ncmFwaGljIHx8IGMuZGF0YUxhYmVsIHx8IGMuZGF0YUxhYmVscykgaChjKSwgYy5kZXN0cm95RWxlbWVudHMoKTtcblxuICAgICAgICAgIGZvciAobCBpbiBjKSBjW2xdID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0gdGhpcyxcbiAgICAgICAgICAgIGQgPSBjLnNlcmllcyxcbiAgICAgICAgICAgIG4gPSBkLmNoYXJ0O1xuICAgICAgICBkID0gZC5vcHRpb25zLmRhdGFTb3J0aW5nO1xuICAgICAgICB2YXIgZiA9IG4uaG92ZXJQb2ludHMsXG4gICAgICAgICAgICBhID0gcihjLnNlcmllcy5jaGFydC5yZW5kZXJlci5nbG9iYWxBbmltYXRpb24pLFxuICAgICAgICAgICAgbDtcbiAgICAgICAgYy5sZWdlbmRJdGVtICYmIG4ubGVnZW5kLmRlc3Ryb3lJdGVtKGMpO1xuICAgICAgICBmICYmIChjLnNldFN0YXRlKCksIEkoZiwgYyksIGYubGVuZ3RoIHx8IChuLmhvdmVyUG9pbnRzID0gbnVsbCkpO1xuICAgICAgICBpZiAoYyA9PT0gbi5ob3ZlclBvaW50KSBjLm9uTW91c2VPdXQoKTtcbiAgICAgICAgZCAmJiBkLmVuYWJsZWQgPyAodGhpcy5hbmltYXRlQmVmb3JlRGVzdHJveSgpLCB0KGUsIGEuZHVyYXRpb24pKSA6IGUoKTtcbiAgICAgICAgbi5wb2ludENvdW50LS07XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS5kZXN0cm95RWxlbWVudHMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgYyA9IHRoaXM7XG4gICAgICAgIGUgPSBjLmdldEdyYXBoaWNhbFByb3BzKGUpO1xuICAgICAgICBlLnNpbmd1bGFyLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBjW2VdID0gY1tlXS5kZXN0cm95KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlLnBsdXJhbC5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgY1tlXS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBjLmVsZW1lbnQgJiYgYy5kZXN0cm95KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVsZXRlIGNbZV07XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUuZmlyZVBvaW50RXZlbnQgPSBmdW5jdGlvbiAoZSwgYywgZCkge1xuICAgICAgICB2YXIgayA9IHRoaXMsXG4gICAgICAgICAgICBmID0gdGhpcy5zZXJpZXMub3B0aW9ucztcbiAgICAgICAgKGYucG9pbnQuZXZlbnRzW2VdIHx8IGsub3B0aW9ucyAmJiBrLm9wdGlvbnMuZXZlbnRzICYmIGsub3B0aW9ucy5ldmVudHNbZV0pICYmIGsuaW1wb3J0RXZlbnRzKCk7XG4gICAgICAgIFwiY2xpY2tcIiA9PT0gZSAmJiBmLmFsbG93UG9pbnRTZWxlY3QgJiYgKGQgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGsuc2VsZWN0ICYmIGsuc2VsZWN0KG51bGwsIGEuY3RybEtleSB8fCBhLm1ldGFLZXkgfHwgYS5zaGlmdEtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBxKGssIGUsIGMsIGQpO1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJoaWdoY2hhcnRzLXBvaW50XCIgKyAodGhpcy5zZWxlY3RlZCA/IFwiIGhpZ2hjaGFydHMtcG9pbnQtc2VsZWN0XCIgOiBcIlwiKSArICh0aGlzLm5lZ2F0aXZlID8gXCIgaGlnaGNoYXJ0cy1uZWdhdGl2ZVwiIDogXCJcIikgKyAodGhpcy5pc051bGwgPyBcIiBoaWdoY2hhcnRzLW51bGwtcG9pbnRcIiA6IFwiXCIpICsgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiB0aGlzLmNvbG9ySW5kZXggPyBcIiBoaWdoY2hhcnRzLWNvbG9yLVwiICsgdGhpcy5jb2xvckluZGV4IDogXCJcIikgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSA/IFwiIFwiICsgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSA6IFwiXCIpICsgKHRoaXMuem9uZSAmJiB0aGlzLnpvbmUuY2xhc3NOYW1lID8gXCIgXCIgKyB0aGlzLnpvbmUuY2xhc3NOYW1lLnJlcGxhY2UoXCJoaWdoY2hhcnRzLW5lZ2F0aXZlXCIsIFwiXCIpIDogXCJcIik7XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS5nZXRHcmFwaGljYWxQcm9wcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBjID0gdGhpcyxcbiAgICAgICAgICAgIGQgPSBbXSxcbiAgICAgICAgICAgIGgsXG4gICAgICAgICAgICBmID0ge1xuICAgICAgICAgIHNpbmd1bGFyOiBbXSxcbiAgICAgICAgICBwbHVyYWw6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGUgPSBlIHx8IHtcbiAgICAgICAgICBncmFwaGljOiAxLFxuICAgICAgICAgIGRhdGFMYWJlbDogMVxuICAgICAgICB9O1xuICAgICAgICBlLmdyYXBoaWMgJiYgZC5wdXNoKFwiZ3JhcGhpY1wiLCBcInNoYWRvd0dyb3VwXCIpO1xuICAgICAgICBlLmRhdGFMYWJlbCAmJiBkLnB1c2goXCJkYXRhTGFiZWxcIiwgXCJkYXRhTGFiZWxVcHBlclwiLCBcImNvbm5lY3RvclwiKTtcblxuICAgICAgICBmb3IgKGggPSBkLmxlbmd0aDsgaC0tOykge1xuICAgICAgICAgIHZhciBhID0gZFtoXTtcbiAgICAgICAgICBjW2FdICYmIGYuc2luZ3VsYXIucHVzaChhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFtcImRhdGFMYWJlbFwiLCBcImNvbm5lY3RvclwiXS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgdmFyIGQgPSBhICsgXCJzXCI7XG4gICAgICAgICAgZVthXSAmJiBjW2RdICYmIGYucGx1cmFsLnB1c2goZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLmdldExhYmVsQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHRoaXMuY2F0ZWdvcnksXG4gICAgICAgICAgeTogdGhpcy55LFxuICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICAgIGNvbG9ySW5kZXg6IHRoaXMuY29sb3JJbmRleCxcbiAgICAgICAgICBrZXk6IHRoaXMubmFtZSB8fCB0aGlzLmNhdGVnb3J5LFxuICAgICAgICAgIHNlcmllczogdGhpcy5zZXJpZXMsXG4gICAgICAgICAgcG9pbnQ6IHRoaXMsXG4gICAgICAgICAgcGVyY2VudGFnZTogdGhpcy5wZXJjZW50YWdlLFxuICAgICAgICAgIHRvdGFsOiB0aGlzLnRvdGFsIHx8IHRoaXMuc3RhY2tUb3RhbFxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUuZ2V0TmVzdGVkUHJvcGVydHkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZSkgcmV0dXJuIDAgPT09IGUuaW5kZXhPZihcImN1c3RvbS5cIikgPyBBKGUsIHRoaXMub3B0aW9ucykgOiB0aGlzW2VdO1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUuZ2V0Wm9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLnNlcmllcyxcbiAgICAgICAgICAgIGMgPSBlLnpvbmVzO1xuICAgICAgICBlID0gZS56b25lQXhpcyB8fCBcInlcIjtcbiAgICAgICAgdmFyIGQgPSAwLFxuICAgICAgICAgICAgaDtcblxuICAgICAgICBmb3IgKGggPSBjW2RdOyB0aGlzW2VdID49IGgudmFsdWU7KSBoID0gY1srK2RdO1xuXG4gICAgICAgIHRoaXMubm9uWm9uZWRDb2xvciB8fCAodGhpcy5ub25ab25lZENvbG9yID0gdGhpcy5jb2xvcik7XG4gICAgICAgIHRoaXMuY29sb3IgPSBoICYmIGguY29sb3IgJiYgIXRoaXMub3B0aW9ucy5jb2xvciA/IGguY29sb3IgOiB0aGlzLm5vblpvbmVkQ29sb3I7XG4gICAgICAgIHJldHVybiBoO1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUuaGFzTmV3U2hhcGVUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZ3JhcGhpYyAmJiAodGhpcy5ncmFwaGljLnN5bWJvbE5hbWUgfHwgdGhpcy5ncmFwaGljLmVsZW1lbnQubm9kZU5hbWUpKSAhPT0gdGhpcy5zaGFwZVR5cGU7XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGUsIGMsIGQpIHtcbiAgICAgICAgdGhpcy5zZXJpZXMgPSBlO1xuICAgICAgICB0aGlzLmFwcGx5T3B0aW9ucyhjLCBkKTtcbiAgICAgICAgdGhpcy5pZCA9IHUodGhpcy5pZCkgPyB0aGlzLmlkIDogTigpO1xuICAgICAgICB0aGlzLnJlc29sdmVDb2xvcigpO1xuICAgICAgICBlLmNoYXJ0LnBvaW50Q291bnQrKztcbiAgICAgICAgcSh0aGlzLCBcImFmdGVySW5pdFwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS5vcHRpb25zVG9PYmplY3QgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgYyA9IHt9LFxuICAgICAgICAgICAgayA9IHRoaXMuc2VyaWVzLFxuICAgICAgICAgICAgaCA9IGsub3B0aW9ucy5rZXlzLFxuICAgICAgICAgICAgZiA9IGggfHwgay5wb2ludEFycmF5TWFwIHx8IFtcInlcIl0sXG4gICAgICAgICAgICBhID0gZi5sZW5ndGgsXG4gICAgICAgICAgICBsID0gMCxcbiAgICAgICAgICAgIGcgPSAwO1xuICAgICAgICBpZiAoSihlKSB8fCBudWxsID09PSBlKSBjW2ZbMF1dID0gZTtlbHNlIGlmIChHKGUpKSBmb3IgKCFoICYmIGUubGVuZ3RoID4gYSAmJiAoayA9IHR5cGVvZiBlWzBdLCBcInN0cmluZ1wiID09PSBrID8gYy5uYW1lID0gZVswXSA6IFwibnVtYmVyXCIgPT09IGsgJiYgKGMueCA9IGVbMF0pLCBsKyspOyBnIDwgYTspIGggJiYgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGVbbF0gfHwgKDAgPCBmW2ddLmluZGV4T2YoXCIuXCIpID8gZC5wcm90b3R5cGUuc2V0TmVzdGVkUHJvcGVydHkoYywgZVtsXSwgZltnXSkgOiBjW2ZbZ11dID0gZVtsXSksIGwrKywgZysrO2Vsc2UgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGUgJiYgKGMgPSBlLCBlLmRhdGFMYWJlbHMgJiYgKGsuX2hhc1BvaW50TGFiZWxzID0gITApLCBlLm1hcmtlciAmJiAoay5faGFzUG9pbnRNYXJrZXJzID0gITApKTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS5yZXNvbHZlQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5zZXJpZXM7XG4gICAgICAgIHZhciBjID0gZS5jaGFydC5vcHRpb25zLmNoYXJ0LmNvbG9yQ291bnQ7XG4gICAgICAgIHZhciBkID0gZS5jaGFydC5zdHlsZWRNb2RlO1xuICAgICAgICBkIHx8IHRoaXMub3B0aW9ucy5jb2xvciB8fCAodGhpcy5jb2xvciA9IGUuY29sb3IpO1xuICAgICAgICBlLm9wdGlvbnMuY29sb3JCeVBvaW50ID8gKGQgfHwgKGMgPSBlLm9wdGlvbnMuY29sb3JzIHx8IGUuY2hhcnQub3B0aW9ucy5jb2xvcnMsIHRoaXMuY29sb3IgPSB0aGlzLmNvbG9yIHx8IGNbZS5jb2xvckNvdW50ZXJdLCBjID0gYy5sZW5ndGgpLCBkID0gZS5jb2xvckNvdW50ZXIsIGUuY29sb3JDb3VudGVyKyssIGUuY29sb3JDb3VudGVyID09PSBjICYmIChlLmNvbG9yQ291bnRlciA9IDApKSA6IGQgPSBlLmNvbG9ySW5kZXg7XG4gICAgICAgIHRoaXMuY29sb3JJbmRleCA9IEQodGhpcy5jb2xvckluZGV4LCBkKTtcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLnNldE5lc3RlZFByb3BlcnR5ID0gZnVuY3Rpb24gKGUsIGMsIGQpIHtcbiAgICAgICAgZC5zcGxpdChcIi5cIikucmVkdWNlKGZ1bmN0aW9uIChlLCBmLCBhLCBkKSB7XG4gICAgICAgICAgZVtmXSA9IGQubGVuZ3RoIC0gMSA9PT0gYSA/IGMgOiB5KGVbZl0sICEwKSA/IGVbZl0gOiB7fTtcbiAgICAgICAgICByZXR1cm4gZVtmXTtcbiAgICAgICAgfSwgZSk7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUudG9vbHRpcEZvcm1hdHRlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5zZXJpZXMsXG4gICAgICAgICAgICBkID0gYy50b29sdGlwT3B0aW9ucyxcbiAgICAgICAgICAgIGggPSBEKGQudmFsdWVEZWNpbWFscywgXCJcIiksXG4gICAgICAgICAgICBmID0gZC52YWx1ZVByZWZpeCB8fCBcIlwiLFxuICAgICAgICAgICAgYSA9IGQudmFsdWVTdWZmaXggfHwgXCJcIjtcbiAgICAgICAgYy5jaGFydC5zdHlsZWRNb2RlICYmIChlID0gYy5jaGFydC50b29sdGlwLnN0eWxlZE1vZGVGb3JtYXQoZSkpO1xuICAgICAgICAoYy5wb2ludEFycmF5TWFwIHx8IFtcInlcIl0pLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBjID0gXCJ7cG9pbnQuXCIgKyBjO1xuICAgICAgICAgIGlmIChmIHx8IGEpIGUgPSBlLnJlcGxhY2UoUmVnRXhwKGMgKyBcIn1cIiwgXCJnXCIpLCBmICsgYyArIFwifVwiICsgYSk7XG4gICAgICAgICAgZSA9IGUucmVwbGFjZShSZWdFeHAoYyArIFwifVwiLCBcImdcIiksIGMgKyBcIjosLlwiICsgaCArIFwiZn1cIik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gRShlLCB7XG4gICAgICAgICAgcG9pbnQ6IHRoaXMsXG4gICAgICAgICAgc2VyaWVzOiB0aGlzLnNlcmllc1xuICAgICAgICB9LCBjLmNoYXJ0KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBkO1xuICAgIH0oKTtcblxuICAgIGQuUG9pbnQgPSBnO1xuICAgIHJldHVybiBkLlBvaW50O1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL1Nlcmllcy5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJtaXhpbnMvbGVnZW5kLXN5bWJvbC5qc1wiXSwgcltcInBhcnRzL1BvaW50LmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcsIHIsIHUpIHtcbiAgICBcIlwiO1xuXG4gICAgdmFyIEkgPSB1LmFkZEV2ZW50LFxuICAgICAgICBNID0gdS5hbmltT2JqZWN0LFxuICAgICAgICBFID0gdS5hcnJheU1heCxcbiAgICAgICAgQSA9IHUuYXJyYXlNaW4sXG4gICAgICAgIEcgPSB1LmNsYW1wLFxuICAgICAgICBKID0gdS5jb3JyZWN0RmxvYXQsXG4gICAgICAgIHkgPSB1LmRlZmluZWQsXG4gICAgICAgIHQgPSB1LmVyYXNlLFxuICAgICAgICBEID0gdS5lcnJvcixcbiAgICAgICAgaCA9IHUuZXh0ZW5kLFxuICAgICAgICBOID0gdS5maW5kLFxuICAgICAgICBxID0gdS5maXJlRXZlbnQsXG4gICAgICAgIFAgPSB1LmdldE5lc3RlZFByb3BlcnR5LFxuICAgICAgICBlID0gdS5pc0FycmF5LFxuICAgICAgICBjID0gdS5pc0Z1bmN0aW9uLFxuICAgICAgICBrID0gdS5pc051bWJlcixcbiAgICAgICAgbiA9IHUuaXNTdHJpbmcsXG4gICAgICAgIGYgPSB1Lm1lcmdlLFxuICAgICAgICBhID0gdS5vYmplY3RFYWNoLFxuICAgICAgICBsID0gdS5waWNrLFxuICAgICAgICB2ID0gdS5yZW1vdmVFdmVudCxcbiAgICAgICAgeiA9IHUuc2VyaWVzVHlwZSxcbiAgICAgICAgdyA9IHUuc3BsYXQsXG4gICAgICAgIEIgPSB1LnN5bmNUaW1lb3V0LFxuICAgICAgICBMID0gZC5kZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgUSA9IGQuZGVmYXVsdFBsb3RPcHRpb25zLFxuICAgICAgICBIID0gZC5zZXJpZXNUeXBlcyxcbiAgICAgICAgSyA9IGQuU1ZHRWxlbWVudCxcbiAgICAgICAgcCA9IGQud2luO1xuICAgIGQuU2VyaWVzID0geihcImxpbmVcIiwgbnVsbCwge1xuICAgICAgbGluZVdpZHRoOiAyLFxuICAgICAgYWxsb3dQb2ludFNlbGVjdDogITEsXG4gICAgICBzaG93Q2hlY2tib3g6ICExLFxuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIGR1cmF0aW9uOiAxRTNcbiAgICAgIH0sXG4gICAgICBldmVudHM6IHt9LFxuICAgICAgbWFya2VyOiB7XG4gICAgICAgIGVuYWJsZWRUaHJlc2hvbGQ6IDIsXG4gICAgICAgIGxpbmVDb2xvcjogXCIjZmZmZmZmXCIsXG4gICAgICAgIGxpbmVXaWR0aDogMCxcbiAgICAgICAgcmFkaXVzOiA0LFxuICAgICAgICBzdGF0ZXM6IHtcbiAgICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgIGFuaW1hdGlvbjogITBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICAgICAgZHVyYXRpb246IDUwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5hYmxlZDogITAsXG4gICAgICAgICAgICByYWRpdXNQbHVzOiAyLFxuICAgICAgICAgICAgbGluZVdpZHRoUGx1czogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICBmaWxsQ29sb3I6IFwiI2NjY2NjY1wiLFxuICAgICAgICAgICAgbGluZUNvbG9yOiBcIiMwMDAwMDBcIixcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBvaW50OiB7XG4gICAgICAgIGV2ZW50czoge31cbiAgICAgIH0sXG4gICAgICBkYXRhTGFiZWxzOiB7XG4gICAgICAgIGFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYiA9IHRoaXMuc2VyaWVzLmNoYXJ0Lm51bWJlckZvcm1hdHRlcjtcbiAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIiAhPT0gdHlwZW9mIHRoaXMueSA/IFwiXCIgOiBiKHRoaXMueSwgLTEpO1xuICAgICAgICB9LFxuICAgICAgICBwYWRkaW5nOiA1LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGZvbnRTaXplOiBcIjExcHhcIixcbiAgICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIixcbiAgICAgICAgICBjb2xvcjogXCJjb250cmFzdFwiLFxuICAgICAgICAgIHRleHRPdXRsaW5lOiBcIjFweCBjb250cmFzdFwiXG4gICAgICAgIH0sXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwiYm90dG9tXCIsXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICBjcm9wVGhyZXNob2xkOiAzMDAsXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgcG9pbnRSYW5nZTogMCxcbiAgICAgIHNvZnRUaHJlc2hvbGQ6ICEwLFxuICAgICAgc3RhdGVzOiB7XG4gICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgIGFuaW1hdGlvbjogITBcbiAgICAgICAgfSxcbiAgICAgICAgaG92ZXI6IHtcbiAgICAgICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiA1MFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbGluZVdpZHRoUGx1czogMSxcbiAgICAgICAgICBtYXJrZXI6IHt9LFxuICAgICAgICAgIGhhbG86IHtcbiAgICAgICAgICAgIHNpemU6IDEwLFxuICAgICAgICAgICAgb3BhY2l0eTogLjI1XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbmFjdGl2ZToge1xuICAgICAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgICAgZHVyYXRpb246IDUwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcGFjaXR5OiAuMlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3RpY2t5VHJhY2tpbmc6ICEwLFxuICAgICAgdHVyYm9UaHJlc2hvbGQ6IDFFMyxcbiAgICAgIGZpbmROZWFyZXN0UG9pbnRCeTogXCJ4XCJcbiAgICB9LCB7XG4gICAgICBheGlzVHlwZXM6IFtcInhBeGlzXCIsIFwieUF4aXNcIl0sXG4gICAgICBjb2xsOiBcInNlcmllc1wiLFxuICAgICAgY29sb3JDb3VudGVyOiAwLFxuICAgICAgY3JvcFNob3VsZGVyOiAxLFxuICAgICAgZGlyZWN0VG91Y2g6ICExLFxuICAgICAgZXZlbnRzVG9VbmJpbmQ6IFtdLFxuICAgICAgaXNDYXJ0ZXNpYW46ICEwLFxuICAgICAgcGFyYWxsZWxBcnJheXM6IFtcInhcIiwgXCJ5XCJdLFxuICAgICAgcG9pbnRDbGFzczogcixcbiAgICAgIHJlcXVpcmVTb3J0aW5nOiAhMCxcbiAgICAgIHNvcnRlZDogITAsXG4gICAgICBpbml0OiBmdW5jdGlvbiAoYiwgZSkge1xuICAgICAgICBxKHRoaXMsIFwiaW5pdFwiLCB7XG4gICAgICAgICAgb3B0aW9uczogZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGYgPSB0aGlzLFxuICAgICAgICAgICAgZCA9IGIuc2VyaWVzLFxuICAgICAgICAgICAgaztcbiAgICAgICAgdGhpcy5ldmVudE9wdGlvbnMgPSB0aGlzLmV2ZW50T3B0aW9ucyB8fCB7fTtcbiAgICAgICAgZi5jaGFydCA9IGI7XG4gICAgICAgIGYub3B0aW9ucyA9IGUgPSBmLnNldE9wdGlvbnMoZSk7XG4gICAgICAgIGYubGlua2VkU2VyaWVzID0gW107XG4gICAgICAgIGYuYmluZEF4ZXMoKTtcbiAgICAgICAgaChmLCB7XG4gICAgICAgICAgbmFtZTogZS5uYW1lLFxuICAgICAgICAgIHN0YXRlOiBcIlwiLFxuICAgICAgICAgIHZpc2libGU6ICExICE9PSBlLnZpc2libGUsXG4gICAgICAgICAgc2VsZWN0ZWQ6ICEwID09PSBlLnNlbGVjdGVkXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcCA9IGUuZXZlbnRzO1xuICAgICAgICBhKHAsIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgYyhiKSAmJiBmLmV2ZW50T3B0aW9uc1thXSAhPT0gYiAmJiAoYyhmLmV2ZW50T3B0aW9uc1thXSkgJiYgdihmLCBhLCBmLmV2ZW50T3B0aW9uc1thXSksIGYuZXZlbnRPcHRpb25zW2FdID0gYiwgSShmLCBhLCBiKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocCAmJiBwLmNsaWNrIHx8IGUucG9pbnQgJiYgZS5wb2ludC5ldmVudHMgJiYgZS5wb2ludC5ldmVudHMuY2xpY2sgfHwgZS5hbGxvd1BvaW50U2VsZWN0KSBiLnJ1blRyYWNrZXJDbGljayA9ICEwO1xuICAgICAgICBmLmdldENvbG9yKCk7XG4gICAgICAgIGYuZ2V0U3ltYm9sKCk7XG4gICAgICAgIGYucGFyYWxsZWxBcnJheXMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGZbYiArIFwiRGF0YVwiXSB8fCAoZltiICsgXCJEYXRhXCJdID0gW10pO1xuICAgICAgICB9KTtcbiAgICAgICAgZi5pc0NhcnRlc2lhbiAmJiAoYi5oYXNDYXJ0ZXNpYW5TZXJpZXMgPSAhMCk7XG4gICAgICAgIGQubGVuZ3RoICYmIChrID0gZFtkLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgZi5faSA9IGwoayAmJiBrLl9pLCAtMSkgKyAxO1xuICAgICAgICBiLm9yZGVyU2VyaWVzKHRoaXMuaW5zZXJ0KGQpKTtcbiAgICAgICAgZS5kYXRhU29ydGluZyAmJiBlLmRhdGFTb3J0aW5nLmVuYWJsZWQgPyBmLnNldERhdGFTb3J0aW5nT3B0aW9ucygpIDogZi5wb2ludHMgfHwgZi5kYXRhIHx8IGYuc2V0RGF0YShlLmRhdGEsICExKTtcbiAgICAgICAgcSh0aGlzLCBcImFmdGVySW5pdFwiKTtcbiAgICAgIH0sXG4gICAgICBpczogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIEhbYl0gJiYgdGhpcyBpbnN0YW5jZW9mIEhbYl07XG4gICAgICB9LFxuICAgICAgaW5zZXJ0OiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXMub3B0aW9ucy5pbmRleCxcbiAgICAgICAgICAgIGM7XG5cbiAgICAgICAgaWYgKGsoYSkpIHtcbiAgICAgICAgICBmb3IgKGMgPSBiLmxlbmd0aDsgYy0tOykgaWYgKGEgPj0gbChiW2NdLm9wdGlvbnMuaW5kZXgsIGJbY10uX2kpKSB7XG4gICAgICAgICAgICBiLnNwbGljZShjICsgMSwgMCwgdGhpcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAtMSA9PT0gYyAmJiBiLnVuc2hpZnQodGhpcyk7XG4gICAgICAgICAgYyArPSAxO1xuICAgICAgICB9IGVsc2UgYi5wdXNoKHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBsKGMsIGIubGVuZ3RoIC0gMSk7XG4gICAgICB9LFxuICAgICAgYmluZEF4ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICAgICAgYSA9IGIub3B0aW9ucyxcbiAgICAgICAgICAgIGMgPSBiLmNoYXJ0LFxuICAgICAgICAgICAgZTtcbiAgICAgICAgcSh0aGlzLCBcImJpbmRBeGVzXCIsIG51bGwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAoYi5heGlzVHlwZXMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIGNbZl0uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICBlID0gYy5vcHRpb25zO1xuICAgICAgICAgICAgICBpZiAoYVtmXSA9PT0gZS5pbmRleCB8fCBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYVtmXSAmJiBhW2ZdID09PSBlLmlkIHx8IFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBhW2ZdICYmIDAgPT09IGUuaW5kZXgpIGIuaW5zZXJ0KGMuc2VyaWVzKSwgYltmXSA9IGMsIGMuaXNEaXJ0eSA9ICEwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBiW2ZdIHx8IGIub3B0aW9uYWxBeGlzID09PSBmIHx8IEQoMTgsICEwLCBjKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHEodGhpcywgXCJhZnRlckJpbmRBeGVzXCIpO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZVBhcmFsbGVsQXJyYXlzOiBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICB2YXIgYyA9IGIuc2VyaWVzLFxuICAgICAgICAgICAgZSA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGYgPSBrKGEpID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgZiA9IFwieVwiID09PSBlICYmIGMudG9ZRGF0YSA/IGMudG9ZRGF0YShiKSA6IGJbZV07XG4gICAgICAgICAgY1tlICsgXCJEYXRhXCJdW2FdID0gZjtcbiAgICAgICAgfSA6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlW2FdLmFwcGx5KGNbYiArIFwiRGF0YVwiXSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZSwgMikpO1xuICAgICAgICB9O1xuICAgICAgICBjLnBhcmFsbGVsQXJyYXlzLmZvckVhY2goZik7XG4gICAgICB9LFxuICAgICAgaGFzRGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlICYmIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiB0aGlzLmRhdGFNYXggJiYgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHRoaXMuZGF0YU1pbiB8fCB0aGlzLnZpc2libGUgJiYgdGhpcy55RGF0YSAmJiAwIDwgdGhpcy55RGF0YS5sZW5ndGg7XG4gICAgICB9LFxuICAgICAgYXV0b0luY3JlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGEgPSB0aGlzLnhJbmNyZW1lbnQsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgZSA9IGIucG9pbnRJbnRlcnZhbFVuaXQsXG4gICAgICAgICAgICBmID0gdGhpcy5jaGFydC50aW1lO1xuICAgICAgICBhID0gbChhLCBiLnBvaW50U3RhcnQsIDApO1xuICAgICAgICB0aGlzLnBvaW50SW50ZXJ2YWwgPSBjID0gbCh0aGlzLnBvaW50SW50ZXJ2YWwsIGIucG9pbnRJbnRlcnZhbCwgMSk7XG4gICAgICAgIGUgJiYgKGIgPSBuZXcgZi5EYXRlKGEpLCBcImRheVwiID09PSBlID8gZi5zZXQoXCJEYXRlXCIsIGIsIGYuZ2V0KFwiRGF0ZVwiLCBiKSArIGMpIDogXCJtb250aFwiID09PSBlID8gZi5zZXQoXCJNb250aFwiLCBiLCBmLmdldChcIk1vbnRoXCIsIGIpICsgYykgOiBcInllYXJcIiA9PT0gZSAmJiBmLnNldChcIkZ1bGxZZWFyXCIsIGIsIGYuZ2V0KFwiRnVsbFllYXJcIiwgYikgKyBjKSwgYyA9IGIuZ2V0VGltZSgpIC0gYSk7XG4gICAgICAgIHRoaXMueEluY3JlbWVudCA9IGEgKyBjO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sXG4gICAgICBzZXREYXRhU29ydGluZ09wdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGgodGhpcywge1xuICAgICAgICAgIHJlcXVpcmVTb3J0aW5nOiAhMSxcbiAgICAgICAgICBzb3J0ZWQ6ICExLFxuICAgICAgICAgIGVuYWJsZWREYXRhU29ydGluZzogITAsXG4gICAgICAgICAgYWxsb3dERzogITFcbiAgICAgICAgfSk7XG4gICAgICAgIHkoYi5wb2ludFJhbmdlKSB8fCAoYi5wb2ludFJhbmdlID0gMSk7XG4gICAgICB9LFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgYyA9IGEub3B0aW9ucyxcbiAgICAgICAgICAgIGUgPSBjLnBsb3RPcHRpb25zLFxuICAgICAgICAgICAgZCA9IGEudXNlck9wdGlvbnMgfHwge307XG4gICAgICAgIGIgPSBmKGIpO1xuICAgICAgICBhID0gYS5zdHlsZWRNb2RlO1xuICAgICAgICB2YXIgayA9IHtcbiAgICAgICAgICBwbG90T3B0aW9uczogZSxcbiAgICAgICAgICB1c2VyT3B0aW9uczogYlxuICAgICAgICB9O1xuICAgICAgICBxKHRoaXMsIFwic2V0T3B0aW9uc1wiLCBrKTtcbiAgICAgICAgdmFyIGggPSBrLnBsb3RPcHRpb25zW3RoaXMudHlwZV0sXG4gICAgICAgICAgICBtID0gZC5wbG90T3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy51c2VyT3B0aW9ucyA9IGsudXNlck9wdGlvbnM7XG4gICAgICAgIGQgPSBmKGgsIGUuc2VyaWVzLCBkLnBsb3RPcHRpb25zICYmIGQucGxvdE9wdGlvbnNbdGhpcy50eXBlXSwgYik7XG4gICAgICAgIHRoaXMudG9vbHRpcE9wdGlvbnMgPSBmKEwudG9vbHRpcCwgTC5wbG90T3B0aW9ucy5zZXJpZXMgJiYgTC5wbG90T3B0aW9ucy5zZXJpZXMudG9vbHRpcCwgTC5wbG90T3B0aW9uc1t0aGlzLnR5cGVdLnRvb2x0aXAsIGMudG9vbHRpcC51c2VyT3B0aW9ucywgZS5zZXJpZXMgJiYgZS5zZXJpZXMudG9vbHRpcCwgZVt0aGlzLnR5cGVdLnRvb2x0aXAsIGIudG9vbHRpcCk7XG4gICAgICAgIHRoaXMuc3RpY2t5VHJhY2tpbmcgPSBsKGIuc3RpY2t5VHJhY2tpbmcsIG1bdGhpcy50eXBlXSAmJiBtW3RoaXMudHlwZV0uc3RpY2t5VHJhY2tpbmcsIG0uc2VyaWVzICYmIG0uc2VyaWVzLnN0aWNreVRyYWNraW5nLCB0aGlzLnRvb2x0aXBPcHRpb25zLnNoYXJlZCAmJiAhdGhpcy5ub1NoYXJlZFRvb2x0aXAgPyAhMCA6IGQuc3RpY2t5VHJhY2tpbmcpO1xuICAgICAgICBudWxsID09PSBoLm1hcmtlciAmJiBkZWxldGUgZC5tYXJrZXI7XG4gICAgICAgIHRoaXMuem9uZUF4aXMgPSBkLnpvbmVBeGlzO1xuICAgICAgICBjID0gdGhpcy56b25lcyA9IChkLnpvbmVzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICAhZC5uZWdhdGl2ZUNvbG9yICYmICFkLm5lZ2F0aXZlRmlsbENvbG9yIHx8IGQuem9uZXMgfHwgKGUgPSB7XG4gICAgICAgICAgdmFsdWU6IGRbdGhpcy56b25lQXhpcyArIFwiVGhyZXNob2xkXCJdIHx8IGQudGhyZXNob2xkIHx8IDAsXG4gICAgICAgICAgY2xhc3NOYW1lOiBcImhpZ2hjaGFydHMtbmVnYXRpdmVcIlxuICAgICAgICB9LCBhIHx8IChlLmNvbG9yID0gZC5uZWdhdGl2ZUNvbG9yLCBlLmZpbGxDb2xvciA9IGQubmVnYXRpdmVGaWxsQ29sb3IpLCBjLnB1c2goZSkpO1xuICAgICAgICBjLmxlbmd0aCAmJiB5KGNbYy5sZW5ndGggLSAxXS52YWx1ZSkgJiYgYy5wdXNoKGEgPyB7fSA6IHtcbiAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICBmaWxsQ29sb3I6IHRoaXMuZmlsbENvbG9yXG4gICAgICAgIH0pO1xuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJTZXRPcHRpb25zXCIsIHtcbiAgICAgICAgICBvcHRpb25zOiBkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZDtcbiAgICAgIH0sXG4gICAgICBnZXROYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsKHRoaXMub3B0aW9ucy5uYW1lLCBcIlNlcmllcyBcIiArICh0aGlzLmluZGV4ICsgMSkpO1xuICAgICAgfSxcbiAgICAgIGdldEN5Y2xpYzogZnVuY3Rpb24gKGIsIGEsIGMpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZiA9IHRoaXMudXNlck9wdGlvbnMsXG4gICAgICAgICAgICBkID0gYiArIFwiSW5kZXhcIixcbiAgICAgICAgICAgIGsgPSBiICsgXCJDb3VudGVyXCIsXG4gICAgICAgICAgICBoID0gYyA/IGMubGVuZ3RoIDogbChlLm9wdGlvbnMuY2hhcnRbYiArIFwiQ291bnRcIl0sIGVbYiArIFwiQ291bnRcIl0pO1xuXG4gICAgICAgIGlmICghYSkge1xuICAgICAgICAgIHZhciBwID0gbChmW2RdLCBmW1wiX1wiICsgZF0pO1xuICAgICAgICAgIHkocCkgfHwgKGUuc2VyaWVzLmxlbmd0aCB8fCAoZVtrXSA9IDApLCBmW1wiX1wiICsgZF0gPSBwID0gZVtrXSAlIGgsIGVba10gKz0gMSk7XG4gICAgICAgICAgYyAmJiAoYSA9IGNbcF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHAgJiYgKHRoaXNbZF0gPSBwKTtcbiAgICAgICAgdGhpc1tiXSA9IGE7XG4gICAgICB9LFxuICAgICAgZ2V0Q29sb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaGFydC5zdHlsZWRNb2RlID8gdGhpcy5nZXRDeWNsaWMoXCJjb2xvclwiKSA6IHRoaXMub3B0aW9ucy5jb2xvckJ5UG9pbnQgPyB0aGlzLm9wdGlvbnMuY29sb3IgPSBudWxsIDogdGhpcy5nZXRDeWNsaWMoXCJjb2xvclwiLCB0aGlzLm9wdGlvbnMuY29sb3IgfHwgUVt0aGlzLnR5cGVdLmNvbG9yLCB0aGlzLmNoYXJ0Lm9wdGlvbnMuY29sb3JzKTtcbiAgICAgIH0sXG4gICAgICBnZXRQb2ludHNDb2xsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5oYXNHcm91cGVkRGF0YSA/IHRoaXMucG9pbnRzIDogdGhpcy5kYXRhKSB8fCBbXTtcbiAgICAgIH0sXG4gICAgICBnZXRTeW1ib2w6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5nZXRDeWNsaWMoXCJzeW1ib2xcIiwgdGhpcy5vcHRpb25zLm1hcmtlci5zeW1ib2wsIHRoaXMuY2hhcnQub3B0aW9ucy5zeW1ib2xzKTtcbiAgICAgIH0sXG4gICAgICBmaW5kUG9pbnRJbmRleDogZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgdmFyIGMgPSBiLmlkLFxuICAgICAgICAgICAgZSA9IGIueCxcbiAgICAgICAgICAgIGYgPSB0aGlzLnBvaW50cyxcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBoID0gdGhpcy5vcHRpb25zLmRhdGFTb3J0aW5nO1xuICAgICAgICBpZiAoYykgdmFyIGwgPSB0aGlzLmNoYXJ0LmdldChjKTtlbHNlIGlmICh0aGlzLmxpbmtlZFBhcmVudCB8fCB0aGlzLmVuYWJsZWREYXRhU29ydGluZykge1xuICAgICAgICAgIHZhciBwID0gaCAmJiBoLm1hdGNoQnlOYW1lID8gXCJuYW1lXCIgOiBcImluZGV4XCI7XG4gICAgICAgICAgbCA9IE4oZiwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiAhYS50b3VjaGVkICYmIGFbcF0gPT09IGJbcF07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFsKSByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobCkge1xuICAgICAgICAgIHZhciBuID0gbCAmJiBsLmluZGV4O1xuICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBuICYmIChkID0gITApO1xuICAgICAgICB9XG5cbiAgICAgICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIG4gJiYgayhlKSAmJiAobiA9IHRoaXMueERhdGEuaW5kZXhPZihlLCBhKSk7XG4gICAgICAgIC0xICE9PSBuICYmIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBuICYmIHRoaXMuY3JvcHBlZCAmJiAobiA9IG4gPj0gdGhpcy5jcm9wU3RhcnQgPyBuIC0gdGhpcy5jcm9wU3RhcnQgOiBuKTtcbiAgICAgICAgIWQgJiYgZltuXSAmJiBmW25dLnRvdWNoZWQgJiYgKG4gPSB2b2lkIDApO1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH0sXG4gICAgICBkcmF3TGVnZW5kU3ltYm9sOiBnLmRyYXdMaW5lTWFya2VyLFxuICAgICAgdXBkYXRlRGF0YTogZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBlID0gYy5kYXRhU29ydGluZyxcbiAgICAgICAgICAgIGYgPSB0aGlzLnBvaW50cyxcbiAgICAgICAgICAgIGQgPSBbXSxcbiAgICAgICAgICAgIGgsXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgbixcbiAgICAgICAgICAgIHAgPSB0aGlzLnJlcXVpcmVTb3J0aW5nLFxuICAgICAgICAgICAgZyA9IGIubGVuZ3RoID09PSBmLmxlbmd0aCxcbiAgICAgICAgICAgIHcgPSAhMDtcbiAgICAgICAgdGhpcy54SW5jcmVtZW50ID0gbnVsbDtcbiAgICAgICAgYi5mb3JFYWNoKGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgdmFyIGwgPSB5KGIpICYmIHRoaXMucG9pbnRDbGFzcy5wcm90b3R5cGUub3B0aW9uc1RvT2JqZWN0LmNhbGwoe1xuICAgICAgICAgICAgc2VyaWVzOiB0aGlzXG4gICAgICAgICAgfSwgYikgfHwge307XG4gICAgICAgICAgdmFyIG0gPSBsLng7XG5cbiAgICAgICAgICBpZiAobC5pZCB8fCBrKG0pKSB7XG4gICAgICAgICAgICBpZiAobSA9IHRoaXMuZmluZFBvaW50SW5kZXgobCwgbiksIC0xID09PSBtIHx8IFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBtID8gZC5wdXNoKGIpIDogZlttXSAmJiBiICE9PSBjLmRhdGFbbV0gPyAoZlttXS51cGRhdGUoYiwgITEsIG51bGwsICExKSwgZlttXS50b3VjaGVkID0gITAsIHAgJiYgKG4gPSBtICsgMSkpIDogZlttXSAmJiAoZlttXS50b3VjaGVkID0gITApLCAhZyB8fCBhICE9PSBtIHx8IGUgJiYgZS5lbmFibGVkIHx8IHRoaXMuaGFzRGVyaXZlZERhdGEpIGggPSAhMDtcbiAgICAgICAgICB9IGVsc2UgZC5wdXNoKGIpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgaWYgKGgpIGZvciAoYiA9IGYubGVuZ3RoOyBiLS07KSAobCA9IGZbYl0pICYmICFsLnRvdWNoZWQgJiYgbC5yZW1vdmUgJiYgbC5yZW1vdmUoITEsIGEpO2Vsc2UgIWcgfHwgZSAmJiBlLmVuYWJsZWQgPyB3ID0gITEgOiAoYi5mb3JFYWNoKGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgZlthXS51cGRhdGUgJiYgYiAhPT0gZlthXS55ICYmIGZbYV0udXBkYXRlKGIsICExLCBudWxsLCAhMSk7XG4gICAgICAgIH0pLCBkLmxlbmd0aCA9IDApO1xuICAgICAgICBmLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBiICYmIChiLnRvdWNoZWQgPSAhMSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXcpIHJldHVybiAhMTtcbiAgICAgICAgZC5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgdGhpcy5hZGRQb2ludChiLCAhMSwgbnVsbCwgbnVsbCwgITEpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgbnVsbCA9PT0gdGhpcy54SW5jcmVtZW50ICYmIHRoaXMueERhdGEgJiYgdGhpcy54RGF0YS5sZW5ndGggJiYgKHRoaXMueEluY3JlbWVudCA9IEUodGhpcy54RGF0YSksIHRoaXMuYXV0b0luY3JlbWVudCgpKTtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfSxcbiAgICAgIHNldERhdGE6IGZ1bmN0aW9uIChiLCBhLCBjLCBmKSB7XG4gICAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICAgIGggPSBkLnBvaW50cyxcbiAgICAgICAgICAgIHAgPSBoICYmIGgubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICBtLFxuICAgICAgICAgICAgZyA9IGQub3B0aW9ucyxcbiAgICAgICAgICAgIHcgPSBkLmNoYXJ0LFxuICAgICAgICAgICAgeCA9IGcuZGF0YVNvcnRpbmcsXG4gICAgICAgICAgICBxID0gbnVsbCxcbiAgICAgICAgICAgIHYgPSBkLnhBeGlzO1xuICAgICAgICBxID0gZy50dXJib1RocmVzaG9sZDtcbiAgICAgICAgdmFyIEMgPSB0aGlzLnhEYXRhLFxuICAgICAgICAgICAgdCA9IHRoaXMueURhdGEsXG4gICAgICAgICAgICBCID0gKG0gPSBkLnBvaW50QXJyYXlNYXApICYmIG0ubGVuZ3RoLFxuICAgICAgICAgICAgeiA9IGcua2V5cyxcbiAgICAgICAgICAgIHkgPSAwLFxuICAgICAgICAgICAgTCA9IDEsXG4gICAgICAgICAgICB1O1xuICAgICAgICBiID0gYiB8fCBbXTtcbiAgICAgICAgbSA9IGIubGVuZ3RoO1xuICAgICAgICBhID0gbChhLCAhMCk7XG4gICAgICAgIHggJiYgeC5lbmFibGVkICYmIChiID0gdGhpcy5zb3J0RGF0YShiKSk7XG4gICAgICAgICExICE9PSBmICYmIG0gJiYgcCAmJiAhZC5jcm9wcGVkICYmICFkLmhhc0dyb3VwZWREYXRhICYmIGQudmlzaWJsZSAmJiAhZC5pc1Nlcmllc0Jvb3N0aW5nICYmICh1ID0gdGhpcy51cGRhdGVEYXRhKGIsIGMpKTtcblxuICAgICAgICBpZiAoIXUpIHtcbiAgICAgICAgICBkLnhJbmNyZW1lbnQgPSBudWxsO1xuICAgICAgICAgIGQuY29sb3JDb3VudGVyID0gMDtcbiAgICAgICAgICB0aGlzLnBhcmFsbGVsQXJyYXlzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIGRbYiArIFwiRGF0YVwiXS5sZW5ndGggPSAwO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChxICYmIG0gPiBxKSB7XG4gICAgICAgICAgICBpZiAocSA9IGQuZ2V0Rmlyc3RWYWxpZFBvaW50KGIpLCBrKHEpKSBmb3IgKGMgPSAwOyBjIDwgbTsgYysrKSBDW2NdID0gdGhpcy5hdXRvSW5jcmVtZW50KCksIHRbY10gPSBiW2NdO2Vsc2UgaWYgKGUocSkpIHtcbiAgICAgICAgICAgICAgaWYgKEIpIGZvciAoYyA9IDA7IGMgPCBtOyBjKyspIGYgPSBiW2NdLCBDW2NdID0gZlswXSwgdFtjXSA9IGYuc2xpY2UoMSwgQiArIDEpO2Vsc2UgZm9yICh6ICYmICh5ID0gei5pbmRleE9mKFwieFwiKSwgTCA9IHouaW5kZXhPZihcInlcIiksIHkgPSAwIDw9IHkgPyB5IDogMCwgTCA9IDAgPD0gTCA/IEwgOiAxKSwgYyA9IDA7IGMgPCBtOyBjKyspIGYgPSBiW2NdLCBDW2NdID0gZlt5XSwgdFtjXSA9IGZbTF07XG4gICAgICAgICAgICB9IGVsc2UgRCgxMiwgITEsIHcpO1xuICAgICAgICAgIH0gZWxzZSBmb3IgKGMgPSAwOyBjIDwgbTsgYysrKSBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYltjXSAmJiAoZiA9IHtcbiAgICAgICAgICAgIHNlcmllczogZFxuICAgICAgICAgIH0sIGQucG9pbnRDbGFzcy5wcm90b3R5cGUuYXBwbHlPcHRpb25zLmFwcGx5KGYsIFtiW2NdXSksIGQudXBkYXRlUGFyYWxsZWxBcnJheXMoZiwgYykpO1xuICAgICAgICAgIHQgJiYgbih0WzBdKSAmJiBEKDE0LCAhMCwgdyk7XG4gICAgICAgICAgZC5kYXRhID0gW107XG4gICAgICAgICAgZC5vcHRpb25zLmRhdGEgPSBkLnVzZXJPcHRpb25zLmRhdGEgPSBiO1xuXG4gICAgICAgICAgZm9yIChjID0gcDsgYy0tOykgaFtjXSAmJiBoW2NdLmRlc3Ryb3kgJiYgaFtjXS5kZXN0cm95KCk7XG5cbiAgICAgICAgICB2ICYmICh2Lm1pblJhbmdlID0gdi51c2VyTWluUmFuZ2UpO1xuICAgICAgICAgIGQuaXNEaXJ0eSA9IHcuaXNEaXJ0eUJveCA9ICEwO1xuICAgICAgICAgIGQuaXNEaXJ0eURhdGEgPSAhIWg7XG4gICAgICAgICAgYyA9ICExO1xuICAgICAgICB9XG5cbiAgICAgICAgXCJwb2ludFwiID09PSBnLmxlZ2VuZFR5cGUgJiYgKHRoaXMucHJvY2Vzc0RhdGEoKSwgdGhpcy5nZW5lcmF0ZVBvaW50cygpKTtcbiAgICAgICAgYSAmJiB3LnJlZHJhdyhjKTtcbiAgICAgIH0sXG4gICAgICBzb3J0RGF0YTogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgYyA9IGEub3B0aW9ucy5kYXRhU29ydGluZy5zb3J0S2V5IHx8IFwieVwiLFxuICAgICAgICAgICAgZSA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgcmV0dXJuIHkoYSkgJiYgYi5wb2ludENsYXNzLnByb3RvdHlwZS5vcHRpb25zVG9PYmplY3QuY2FsbCh7XG4gICAgICAgICAgICBzZXJpZXM6IGJcbiAgICAgICAgICB9LCBhKSB8fCB7fTtcbiAgICAgICAgfTtcblxuICAgICAgICBiLmZvckVhY2goZnVuY3Rpb24gKGMsIGYpIHtcbiAgICAgICAgICBiW2ZdID0gZShhLCBjKTtcbiAgICAgICAgICBiW2ZdLmluZGV4ID0gZjtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGIuY29uY2F0KCkuc29ydChmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIGIgPSBQKGMsIGIpO1xuICAgICAgICAgIGEgPSBQKGMsIGEpO1xuICAgICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIGIueCA9IGE7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBhLmxpbmtlZFNlcmllcyAmJiBhLmxpbmtlZFNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgdmFyIGMgPSBhLm9wdGlvbnMsXG4gICAgICAgICAgICAgIGYgPSBjLmRhdGE7XG4gICAgICAgICAgYy5kYXRhU29ydGluZyAmJiBjLmRhdGFTb3J0aW5nLmVuYWJsZWQgfHwgIWYgfHwgKGYuZm9yRWFjaChmdW5jdGlvbiAoYywgZCkge1xuICAgICAgICAgICAgZltkXSA9IGUoYSwgYyk7XG4gICAgICAgICAgICBiW2RdICYmIChmW2RdLnggPSBiW2RdLngsIGZbZF0uaW5kZXggPSBkKTtcbiAgICAgICAgICB9KSwgYS5zZXREYXRhKGYsICExKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0sXG4gICAgICBwcm9jZXNzRGF0YTogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLnhEYXRhLFxuICAgICAgICAgICAgYyA9IHRoaXMueURhdGEsXG4gICAgICAgICAgICBlID0gYS5sZW5ndGg7XG4gICAgICAgIHZhciBmID0gMDtcbiAgICAgICAgdmFyIGQgPSB0aGlzLnhBeGlzLFxuICAgICAgICAgICAgayA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIGggPSBrLmNyb3BUaHJlc2hvbGQ7XG4gICAgICAgIHZhciBsID0gdGhpcy5nZXRFeHRyZW1lc0Zyb21BbGwgfHwgay5nZXRFeHRyZW1lc0Zyb21BbGwsXG4gICAgICAgICAgICBwID0gdGhpcy5pc0NhcnRlc2lhbjtcbiAgICAgICAgayA9IGQgJiYgZC52YWwybGluO1xuICAgICAgICB2YXIgbiA9IGQgJiYgZC5pc0xvZyxcbiAgICAgICAgICAgIGcgPSB0aGlzLnJlcXVpcmVTb3J0aW5nO1xuICAgICAgICBpZiAocCAmJiAhdGhpcy5pc0RpcnR5ICYmICFkLmlzRGlydHkgJiYgIXRoaXMueUF4aXMuaXNEaXJ0eSAmJiAhYikgcmV0dXJuICExO1xuXG4gICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgYiA9IGQuZ2V0RXh0cmVtZXMoKTtcbiAgICAgICAgICB2YXIgdyA9IGIubWluO1xuICAgICAgICAgIHZhciBxID0gYi5tYXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocCAmJiB0aGlzLnNvcnRlZCAmJiAhbCAmJiAoIWggfHwgZSA+IGggfHwgdGhpcy5mb3JjZUNyb3ApKSBpZiAoYVtlIC0gMV0gPCB3IHx8IGFbMF0gPiBxKSBhID0gW10sIGMgPSBbXTtlbHNlIGlmICh0aGlzLnlEYXRhICYmIChhWzBdIDwgdyB8fCBhW2UgLSAxXSA+IHEpKSB7XG4gICAgICAgICAgZiA9IHRoaXMuY3JvcERhdGEodGhpcy54RGF0YSwgdGhpcy55RGF0YSwgdywgcSk7XG4gICAgICAgICAgYSA9IGYueERhdGE7XG4gICAgICAgICAgYyA9IGYueURhdGE7XG4gICAgICAgICAgZiA9IGYuc3RhcnQ7XG4gICAgICAgICAgdmFyIHYgPSAhMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaCA9IGEubGVuZ3RoIHx8IDE7IC0taDspIGlmIChlID0gbiA/IGsoYVtoXSkgLSBrKGFbaCAtIDFdKSA6IGFbaF0gLSBhW2ggLSAxXSwgMCA8IGUgJiYgKFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiB0IHx8IGUgPCB0KSkgdmFyIHQgPSBlO2Vsc2UgMCA+IGUgJiYgZyAmJiAoRCgxNSwgITEsIHRoaXMuY2hhcnQpLCBnID0gITEpO1xuXG4gICAgICAgIHRoaXMuY3JvcHBlZCA9IHY7XG4gICAgICAgIHRoaXMuY3JvcFN0YXJ0ID0gZjtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWRYRGF0YSA9IGE7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkWURhdGEgPSBjO1xuICAgICAgICB0aGlzLmNsb3Nlc3RQb2ludFJhbmdlID0gdGhpcy5iYXNlUG9pbnRSYW5nZSA9IHQ7XG4gICAgICB9LFxuICAgICAgY3JvcERhdGE6IGZ1bmN0aW9uIChiLCBhLCBjLCBlLCBmKSB7XG4gICAgICAgIHZhciBkID0gYi5sZW5ndGgsXG4gICAgICAgICAgICBrID0gMCxcbiAgICAgICAgICAgIGggPSBkLFxuICAgICAgICAgICAgcDtcbiAgICAgICAgZiA9IGwoZiwgdGhpcy5jcm9wU2hvdWxkZXIpO1xuXG4gICAgICAgIGZvciAocCA9IDA7IHAgPCBkOyBwKyspIGlmIChiW3BdID49IGMpIHtcbiAgICAgICAgICBrID0gTWF0aC5tYXgoMCwgcCAtIGYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjID0gcDsgYyA8IGQ7IGMrKykgaWYgKGJbY10gPiBlKSB7XG4gICAgICAgICAgaCA9IGMgKyBmO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4RGF0YTogYi5zbGljZShrLCBoKSxcbiAgICAgICAgICB5RGF0YTogYS5zbGljZShrLCBoKSxcbiAgICAgICAgICBzdGFydDogayxcbiAgICAgICAgICBlbmQ6IGhcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBnZW5lcmF0ZVBvaW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGEgPSBiLmRhdGEsXG4gICAgICAgICAgICBjID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgZSxcbiAgICAgICAgICAgIGYgPSB0aGlzLnByb2Nlc3NlZFhEYXRhLFxuICAgICAgICAgICAgZCA9IHRoaXMucHJvY2Vzc2VkWURhdGEsXG4gICAgICAgICAgICBrID0gdGhpcy5wb2ludENsYXNzLFxuICAgICAgICAgICAgbCA9IGYubGVuZ3RoLFxuICAgICAgICAgICAgcCA9IHRoaXMuY3JvcFN0YXJ0IHx8IDAsXG4gICAgICAgICAgICBuID0gdGhpcy5oYXNHcm91cGVkRGF0YTtcbiAgICAgICAgYiA9IGIua2V5cztcbiAgICAgICAgdmFyIGcgPSBbXSxcbiAgICAgICAgICAgIHY7XG4gICAgICAgIGMgfHwgbiB8fCAoYyA9IFtdLCBjLmxlbmd0aCA9IGEubGVuZ3RoLCBjID0gdGhpcy5kYXRhID0gYyk7XG4gICAgICAgIGIgJiYgbiAmJiAodGhpcy5vcHRpb25zLmtleXMgPSAhMSk7XG5cbiAgICAgICAgZm9yICh2ID0gMDsgdiA8IGw7IHYrKykge1xuICAgICAgICAgIHZhciB0ID0gcCArIHY7XG5cbiAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgdmFyIEIgPSBuZXcgaygpLmluaXQodGhpcywgW2Zbdl1dLmNvbmNhdCh3KGRbdl0pKSk7XG4gICAgICAgICAgICBCLmRhdGFHcm91cCA9IHRoaXMuZ3JvdXBNYXBbdl07XG4gICAgICAgICAgICBCLmRhdGFHcm91cC5vcHRpb25zICYmIChCLm9wdGlvbnMgPSBCLmRhdGFHcm91cC5vcHRpb25zLCBoKEIsIEIuZGF0YUdyb3VwLm9wdGlvbnMpLCBkZWxldGUgQi5kYXRhTGFiZWxzKTtcbiAgICAgICAgICB9IGVsc2UgKEIgPSBjW3RdKSB8fCBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgYVt0XSB8fCAoY1t0XSA9IEIgPSBuZXcgaygpLmluaXQodGhpcywgYVt0XSwgZlt2XSkpO1xuXG4gICAgICAgICAgQiAmJiAoQi5pbmRleCA9IHQsIGdbdl0gPSBCKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3B0aW9ucy5rZXlzID0gYjtcbiAgICAgICAgaWYgKGMgJiYgKGwgIT09IChlID0gYy5sZW5ndGgpIHx8IG4pKSBmb3IgKHYgPSAwOyB2IDwgZTsgdisrKSB2ICE9PSBwIHx8IG4gfHwgKHYgKz0gbCksIGNbdl0gJiYgKGNbdl0uZGVzdHJveUVsZW1lbnRzKCksIGNbdl0ucGxvdFggPSB2b2lkIDApO1xuICAgICAgICB0aGlzLmRhdGEgPSBjO1xuICAgICAgICB0aGlzLnBvaW50cyA9IGc7XG4gICAgICAgIHEodGhpcywgXCJhZnRlckdlbmVyYXRlUG9pbnRzXCIpO1xuICAgICAgfSxcbiAgICAgIGdldFhFeHRyZW1lczogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtaW46IEEoYiksXG4gICAgICAgICAgbWF4OiBFKGIpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZ2V0RXh0cmVtZXM6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy54QXhpcyxcbiAgICAgICAgICAgIGMgPSB0aGlzLnlBeGlzLFxuICAgICAgICAgICAgZiA9IHRoaXMucHJvY2Vzc2VkWERhdGEgfHwgdGhpcy54RGF0YSxcbiAgICAgICAgICAgIGQgPSBbXSxcbiAgICAgICAgICAgIGggPSAwLFxuICAgICAgICAgICAgbCA9IDA7XG4gICAgICAgIHZhciBtID0gMDtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnJlcXVpcmVTb3J0aW5nID8gdGhpcy5jcm9wU2hvdWxkZXIgOiAwLFxuICAgICAgICAgICAgbiA9IGMgPyBjLnBvc2l0aXZlVmFsdWVzT25seSA6ICExLFxuICAgICAgICAgICAgZztcbiAgICAgICAgYiA9IGIgfHwgdGhpcy5zdGFja2VkWURhdGEgfHwgdGhpcy5wcm9jZXNzZWRZRGF0YSB8fCBbXTtcbiAgICAgICAgYyA9IGIubGVuZ3RoO1xuICAgICAgICBhICYmIChtID0gYS5nZXRFeHRyZW1lcygpLCBsID0gbS5taW4sIG0gPSBtLm1heCk7XG5cbiAgICAgICAgZm9yIChnID0gMDsgZyA8IGM7IGcrKykge1xuICAgICAgICAgIHZhciB3ID0gZltnXTtcbiAgICAgICAgICB2YXIgdiA9IGJbZ107XG4gICAgICAgICAgdmFyIHQgPSAoayh2KSB8fCBlKHYpKSAmJiAodi5sZW5ndGggfHwgMCA8IHYgfHwgIW4pO1xuICAgICAgICAgIHcgPSB0aGlzLmdldEV4dHJlbWVzRnJvbUFsbCB8fCB0aGlzLm9wdGlvbnMuZ2V0RXh0cmVtZXNGcm9tQWxsIHx8IHRoaXMuY3JvcHBlZCB8fCAhYSB8fCAoZltnICsgcF0gfHwgdykgPj0gbCAmJiAoZltnIC0gcF0gfHwgdykgPD0gbTtcbiAgICAgICAgICBpZiAodCAmJiB3KSBpZiAodCA9IHYubGVuZ3RoKSBmb3IgKDsgdC0tOykgayh2W3RdKSAmJiAoZFtoKytdID0gdlt0XSk7ZWxzZSBkW2grK10gPSB2O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kYXRhTWluID0gQShkKTtcbiAgICAgICAgdGhpcy5kYXRhTWF4ID0gRShkKTtcbiAgICAgICAgcSh0aGlzLCBcImFmdGVyR2V0RXh0cmVtZXNcIik7XG4gICAgICB9LFxuICAgICAgZ2V0Rmlyc3RWYWxpZFBvaW50OiBmdW5jdGlvbiAoYikge1xuICAgICAgICBmb3IgKHZhciBhID0gbnVsbCwgYyA9IGIubGVuZ3RoLCBlID0gMDsgbnVsbCA9PT0gYSAmJiBlIDwgYzspIGEgPSBiW2VdLCBlKys7XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9LFxuICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkWERhdGEgfHwgdGhpcy5wcm9jZXNzRGF0YSgpO1xuICAgICAgICB0aGlzLmdlbmVyYXRlUG9pbnRzKCk7XG4gICAgICAgIHZhciBiID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgYSA9IGIuc3RhY2tpbmcsXG4gICAgICAgICAgICBjID0gdGhpcy54QXhpcyxcbiAgICAgICAgICAgIGYgPSBjLmNhdGVnb3JpZXMsXG4gICAgICAgICAgICBkID0gdGhpcy5lbmFibGVkRGF0YVNvcnRpbmcsXG4gICAgICAgICAgICBoID0gdGhpcy55QXhpcyxcbiAgICAgICAgICAgIHAgPSB0aGlzLnBvaW50cyxcbiAgICAgICAgICAgIG0gPSBwLmxlbmd0aCxcbiAgICAgICAgICAgIG4gPSAhIXRoaXMubW9kaWZ5VmFsdWUsXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgdyA9IHRoaXMucG9pbnRQbGFjZW1lbnRUb1hWYWx1ZSgpLFxuICAgICAgICAgICAgdiA9ICEhdyxcbiAgICAgICAgICAgIHQgPSBiLnRocmVzaG9sZCxcbiAgICAgICAgICAgIEIgPSBiLnN0YXJ0RnJvbVRocmVzaG9sZCA/IHQgOiAwLFxuICAgICAgICAgICAgeixcbiAgICAgICAgICAgIEwgPSB0aGlzLnpvbmVBeGlzIHx8IFwieVwiLFxuICAgICAgICAgICAgdSA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgZm9yIChnID0gMDsgZyA8IG07IGcrKykge1xuICAgICAgICAgIHZhciBLID0gcFtnXSxcbiAgICAgICAgICAgICAgciA9IEsueCxcbiAgICAgICAgICAgICAgSCA9IEsueSxcbiAgICAgICAgICAgICAgRCA9IEsubG93LFxuICAgICAgICAgICAgICBBID0gYSAmJiBoLnN0YWNrc1sodGhpcy5uZWdTdGFja3MgJiYgSCA8IChCID8gMCA6IHQpID8gXCItXCIgOiBcIlwiKSArIHRoaXMuc3RhY2tLZXldO1xuICAgICAgICAgIGgucG9zaXRpdmVWYWx1ZXNPbmx5ICYmIG51bGwgIT09IEggJiYgMCA+PSBIICYmIChLLmlzTnVsbCA9ICEwKTtcbiAgICAgICAgICBLLnBsb3RYID0geiA9IEooRyhjLnRyYW5zbGF0ZShyLCAwLCAwLCAwLCAxLCB3LCBcImZsYWdzXCIgPT09IHRoaXMudHlwZSksIC0xRTUsIDFFNSkpO1xuXG4gICAgICAgICAgaWYgKGEgJiYgdGhpcy52aXNpYmxlICYmIEEgJiYgQVtyXSkge1xuICAgICAgICAgICAgdmFyIE4gPSB0aGlzLmdldFN0YWNrSW5kaWNhdG9yKE4sIHIsIHRoaXMuaW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAoIUsuaXNOdWxsKSB7XG4gICAgICAgICAgICAgIHZhciBRID0gQVtyXTtcbiAgICAgICAgICAgICAgdmFyIEUgPSBRLnBvaW50c1tOLmtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZShFKSAmJiAoRCA9IEVbMF0sIEggPSBFWzFdLCBEID09PSBCICYmIE4ua2V5ID09PSBBW3JdLmJhc2UgJiYgKEQgPSBsKGsodCkgJiYgdCwgaC5taW4pKSwgaC5wb3NpdGl2ZVZhbHVlc09ubHkgJiYgMCA+PSBEICYmIChEID0gbnVsbCksIEsudG90YWwgPSBLLnN0YWNrVG90YWwgPSBRLnRvdGFsLCBLLnBlcmNlbnRhZ2UgPSBRLnRvdGFsICYmIEsueSAvIFEudG90YWwgKiAxMDAsIEsuc3RhY2tZID0gSCwgdGhpcy5pcnJlZ3VsYXJXaWR0aHMgfHwgUS5zZXRPZmZzZXQodGhpcy5wb2ludFhPZmZzZXQgfHwgMCwgdGhpcy5iYXJXIHx8IDApKTtcbiAgICAgICAgICBLLnlCb3R0b20gPSB5KEQpID8gRyhoLnRyYW5zbGF0ZShELCAwLCAxLCAwLCAxKSwgLTFFNSwgMUU1KSA6IG51bGw7XG4gICAgICAgICAgbiAmJiAoSCA9IHRoaXMubW9kaWZ5VmFsdWUoSCwgSykpO1xuICAgICAgICAgIEsucGxvdFkgPSBcIm51bWJlclwiID09PSB0eXBlb2YgSCAmJiBJbmZpbml0eSAhPT0gSCA/IEcoaC50cmFuc2xhdGUoSCwgMCwgMSwgMCwgMSksIC0xRTUsIDFFNSkgOiB2b2lkIDA7XG4gICAgICAgICAgSy5pc0luc2lkZSA9IHRoaXMuaXNQb2ludEluc2lkZShLKTtcbiAgICAgICAgICBLLmNsaWVudFggPSB2ID8gSihjLnRyYW5zbGF0ZShyLCAwLCAwLCAwLCAxLCB3KSkgOiB6O1xuICAgICAgICAgIEsubmVnYXRpdmUgPSBLW0xdIDwgKGJbTCArIFwiVGhyZXNob2xkXCJdIHx8IHQgfHwgMCk7XG4gICAgICAgICAgSy5jYXRlZ29yeSA9IGYgJiYgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGZbSy54XSA/IGZbSy54XSA6IEsueDtcblxuICAgICAgICAgIGlmICghSy5pc051bGwgJiYgITEgIT09IEsudmlzaWJsZSkge1xuICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIFAgJiYgKHUgPSBNYXRoLm1pbih1LCBNYXRoLmFicyh6IC0gUCkpKTtcbiAgICAgICAgICAgIHZhciBQID0gejtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBLLnpvbmUgPSB0aGlzLnpvbmVzLmxlbmd0aCAmJiBLLmdldFpvbmUoKTtcbiAgICAgICAgICAhSy5ncmFwaGljICYmIHRoaXMuZ3JvdXAgJiYgZCAmJiAoSy5pc05ldyA9ICEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xvc2VzdFBvaW50UmFuZ2VQeCA9IHU7XG4gICAgICAgIHEodGhpcywgXCJhZnRlclRyYW5zbGF0ZVwiKTtcbiAgICAgIH0sXG4gICAgICBnZXRWYWxpZFBvaW50czogZnVuY3Rpb24gKGIsIGEsIGMpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmNoYXJ0O1xuICAgICAgICByZXR1cm4gKGIgfHwgdGhpcy5wb2ludHMgfHwgW10pLmZpbHRlcihmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHJldHVybiBhICYmICFlLmlzSW5zaWRlUGxvdChiLnBsb3RYLCBiLnBsb3RZLCBlLmludmVydGVkKSA/ICExIDogITEgIT09IGIudmlzaWJsZSAmJiAoYyB8fCAhYi5pc051bGwpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZXRDbGlwQm94OiBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICB2YXIgYyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGUgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZiA9IGUuaW52ZXJ0ZWQsXG4gICAgICAgICAgICBkID0gdGhpcy54QXhpcyxcbiAgICAgICAgICAgIGsgPSBkICYmIHRoaXMueUF4aXM7XG4gICAgICAgIGIgJiYgITEgPT09IGMuY2xpcCAmJiBrID8gYiA9IGYgPyB7XG4gICAgICAgICAgeTogLWUuY2hhcnRXaWR0aCArIGsubGVuICsgay5wb3MsXG4gICAgICAgICAgaGVpZ2h0OiBlLmNoYXJ0V2lkdGgsXG4gICAgICAgICAgd2lkdGg6IGUuY2hhcnRIZWlnaHQsXG4gICAgICAgICAgeDogLWUuY2hhcnRIZWlnaHQgKyBkLmxlbiArIGQucG9zXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgeTogLWsucG9zLFxuICAgICAgICAgIGhlaWdodDogZS5jaGFydEhlaWdodCxcbiAgICAgICAgICB3aWR0aDogZS5jaGFydFdpZHRoLFxuICAgICAgICAgIHg6IC1kLnBvc1xuICAgICAgICB9IDogKGIgPSB0aGlzLmNsaXBCb3ggfHwgZS5jbGlwQm94LCBhICYmIChiLndpZHRoID0gZS5wbG90U2l6ZVgsIGIueCA9IDApKTtcbiAgICAgICAgcmV0dXJuIGEgPyB7XG4gICAgICAgICAgd2lkdGg6IGIud2lkdGgsXG4gICAgICAgICAgeDogYi54XG4gICAgICAgIH0gOiBiO1xuICAgICAgfSxcbiAgICAgIHNldENsaXA6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBlID0gYS5yZW5kZXJlcixcbiAgICAgICAgICAgIGYgPSBhLmludmVydGVkLFxuICAgICAgICAgICAgZCA9IHRoaXMuY2xpcEJveCxcbiAgICAgICAgICAgIGsgPSB0aGlzLmdldENsaXBCb3goYiksXG4gICAgICAgICAgICBoID0gdGhpcy5zaGFyZWRDbGlwS2V5IHx8IFtcIl9zaGFyZWRDbGlwXCIsIGIgJiYgYi5kdXJhdGlvbiwgYiAmJiBiLmVhc2luZywgay5oZWlnaHQsIGMueEF4aXMsIGMueUF4aXNdLmpvaW4oKSxcbiAgICAgICAgICAgIGwgPSBhW2hdLFxuICAgICAgICAgICAgcCA9IGFbaCArIFwibVwiXTtcbiAgICAgICAgYiAmJiAoay53aWR0aCA9IDAsIGYgJiYgKGsueCA9IGEucGxvdEhlaWdodCArICghMSAhPT0gYy5jbGlwID8gMCA6IGEucGxvdFRvcCkpKTtcbiAgICAgICAgbCA/IGEuaGFzTG9hZGVkIHx8IGwuYXR0cihrKSA6IChiICYmIChhW2ggKyBcIm1cIl0gPSBwID0gZS5jbGlwUmVjdChmID8gYS5wbG90U2l6ZVggKyA5OSA6IC05OSwgZiA/IC1hLnBsb3RMZWZ0IDogLWEucGxvdFRvcCwgOTksIGYgPyBhLmNoYXJ0V2lkdGggOiBhLmNoYXJ0SGVpZ2h0KSksIGFbaF0gPSBsID0gZS5jbGlwUmVjdChrKSwgbC5jb3VudCA9IHtcbiAgICAgICAgICBsZW5ndGg6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIGIgJiYgIWwuY291bnRbdGhpcy5pbmRleF0gJiYgKGwuY291bnRbdGhpcy5pbmRleF0gPSAhMCwgbC5jb3VudC5sZW5ndGggKz0gMSk7XG4gICAgICAgIGlmICghMSAhPT0gYy5jbGlwIHx8IGIpIHRoaXMuZ3JvdXAuY2xpcChiIHx8IGQgPyBsIDogYS5jbGlwUmVjdCksIHRoaXMubWFya2VyR3JvdXAuY2xpcChwKSwgdGhpcy5zaGFyZWRDbGlwS2V5ID0gaDtcbiAgICAgICAgYiB8fCAobC5jb3VudFt0aGlzLmluZGV4XSAmJiAoZGVsZXRlIGwuY291bnRbdGhpcy5pbmRleF0sIC0tbC5jb3VudC5sZW5ndGgpLCAwID09PSBsLmNvdW50Lmxlbmd0aCAmJiBoICYmIGFbaF0gJiYgKGQgfHwgKGFbaF0gPSBhW2hdLmRlc3Ryb3koKSksIGFbaCArIFwibVwiXSAmJiAoYVtoICsgXCJtXCJdID0gYVtoICsgXCJtXCJdLmRlc3Ryb3koKSkpKTtcbiAgICAgIH0sXG4gICAgICBhbmltYXRlOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBjID0gTSh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKTtcbiAgICAgICAgaWYgKCFhLmhhc1JlbmRlcmVkKSBpZiAoYikgdGhpcy5zZXRDbGlwKGMpO2Vsc2Uge1xuICAgICAgICAgIHZhciBlID0gdGhpcy5zaGFyZWRDbGlwS2V5O1xuICAgICAgICAgIGIgPSBhW2VdO1xuICAgICAgICAgIHZhciBmID0gdGhpcy5nZXRDbGlwQm94KGMsICEwKTtcbiAgICAgICAgICBiICYmIGIuYW5pbWF0ZShmLCBjKTtcbiAgICAgICAgICBhW2UgKyBcIm1cIl0gJiYgYVtlICsgXCJtXCJdLmFuaW1hdGUoe1xuICAgICAgICAgICAgd2lkdGg6IGYud2lkdGggKyA5OSxcbiAgICAgICAgICAgIHg6IGYueCAtIChhLmludmVydGVkID8gMCA6IDk5KVxuICAgICAgICAgIH0sIGMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWZ0ZXJBbmltYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0Q2xpcCgpO1xuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJBbmltYXRlXCIpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkQW5pbWF0aW5nID0gITA7XG4gICAgICB9LFxuICAgICAgZHJhd1BvaW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMucG9pbnRzLFxuICAgICAgICAgICAgYSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgZSxcbiAgICAgICAgICAgIGYgPSB0aGlzLm9wdGlvbnMubWFya2VyLFxuICAgICAgICAgICAgZCA9IHRoaXNbdGhpcy5zcGVjaWFsR3JvdXBdIHx8IHRoaXMubWFya2VyR3JvdXAsXG4gICAgICAgICAgICBrID0gdGhpcy54QXhpcyxcbiAgICAgICAgICAgIGggPSBsKGYuZW5hYmxlZCwgIWsgfHwgay5pc1JhZGlhbCA/ICEwIDogbnVsbCwgdGhpcy5jbG9zZXN0UG9pbnRSYW5nZVB4ID49IGYuZW5hYmxlZFRocmVzaG9sZCAqIGYucmFkaXVzKTtcbiAgICAgICAgaWYgKCExICE9PSBmLmVuYWJsZWQgfHwgdGhpcy5faGFzUG9pbnRNYXJrZXJzKSBmb3IgKGMgPSAwOyBjIDwgYi5sZW5ndGg7IGMrKykge1xuICAgICAgICAgIHZhciBwID0gYltjXTtcbiAgICAgICAgICB2YXIgbiA9IChlID0gcC5ncmFwaGljKSA/IFwiYW5pbWF0ZVwiIDogXCJhdHRyXCI7XG4gICAgICAgICAgdmFyIGcgPSBwLm1hcmtlciB8fCB7fTtcbiAgICAgICAgICB2YXIgdyA9ICEhcC5tYXJrZXI7XG5cbiAgICAgICAgICBpZiAoKGggJiYgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGcuZW5hYmxlZCB8fCBnLmVuYWJsZWQpICYmICFwLmlzTnVsbCAmJiAhMSAhPT0gcC52aXNpYmxlKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGwoZy5zeW1ib2wsIHRoaXMuc3ltYm9sKTtcbiAgICAgICAgICAgIHZhciBxID0gdGhpcy5tYXJrZXJBdHRyaWJzKHAsIHAuc2VsZWN0ZWQgJiYgXCJzZWxlY3RcIik7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZWREYXRhU29ydGluZyAmJiAocC5zdGFydFhQb3MgPSBrLnJldmVyc2VkID8gLXEud2lkdGggOiBrLndpZHRoKTtcbiAgICAgICAgICAgIHZhciB0ID0gITEgIT09IHAuaXNJbnNpZGU7XG4gICAgICAgICAgICBlID8gZVt0ID8gXCJzaG93XCIgOiBcImhpZGVcIl0odCkuYW5pbWF0ZShxKSA6IHQgJiYgKDAgPCBxLndpZHRoIHx8IHAuaGFzSW1hZ2UpICYmIChwLmdyYXBoaWMgPSBlID0gYS5yZW5kZXJlci5zeW1ib2wodiwgcS54LCBxLnksIHEud2lkdGgsIHEuaGVpZ2h0LCB3ID8gZyA6IGYpLmFkZChkKSwgdGhpcy5lbmFibGVkRGF0YVNvcnRpbmcgJiYgYS5oYXNSZW5kZXJlZCAmJiAoZS5hdHRyKHtcbiAgICAgICAgICAgICAgeDogcC5zdGFydFhQb3NcbiAgICAgICAgICAgIH0pLCBuID0gXCJhbmltYXRlXCIpKTtcbiAgICAgICAgICAgIGUgJiYgXCJhbmltYXRlXCIgPT09IG4gJiYgZVt0ID8gXCJzaG93XCIgOiBcImhpZGVcIl0odCkuYW5pbWF0ZShxKTtcbiAgICAgICAgICAgIGlmIChlICYmICFhLnN0eWxlZE1vZGUpIGVbbl0odGhpcy5wb2ludEF0dHJpYnMocCwgcC5zZWxlY3RlZCAmJiBcInNlbGVjdFwiKSk7XG4gICAgICAgICAgICBlICYmIGUuYWRkQ2xhc3MocC5nZXRDbGFzc05hbWUoKSwgITApO1xuICAgICAgICAgIH0gZWxzZSBlICYmIChwLmdyYXBoaWMgPSBlLmRlc3Ryb3koKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtYXJrZXJBdHRyaWJzOiBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICB2YXIgYyA9IHRoaXMub3B0aW9ucy5tYXJrZXIsXG4gICAgICAgICAgICBlID0gYi5tYXJrZXIgfHwge30sXG4gICAgICAgICAgICBmID0gZS5zeW1ib2wgfHwgYy5zeW1ib2wsXG4gICAgICAgICAgICBkID0gbChlLnJhZGl1cywgYy5yYWRpdXMpO1xuICAgICAgICBhICYmIChjID0gYy5zdGF0ZXNbYV0sIGEgPSBlLnN0YXRlcyAmJiBlLnN0YXRlc1thXSwgZCA9IGwoYSAmJiBhLnJhZGl1cywgYyAmJiBjLnJhZGl1cywgZCArIChjICYmIGMucmFkaXVzUGx1cyB8fCAwKSkpO1xuICAgICAgICBiLmhhc0ltYWdlID0gZiAmJiAwID09PSBmLmluZGV4T2YoXCJ1cmxcIik7XG4gICAgICAgIGIuaGFzSW1hZ2UgJiYgKGQgPSAwKTtcbiAgICAgICAgYiA9IHtcbiAgICAgICAgICB4OiBNYXRoLmZsb29yKGIucGxvdFgpIC0gZCxcbiAgICAgICAgICB5OiBiLnBsb3RZIC0gZFxuICAgICAgICB9O1xuICAgICAgICBkICYmIChiLndpZHRoID0gYi5oZWlnaHQgPSAyICogZCk7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSxcbiAgICAgIHBvaW50QXR0cmliczogZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLm9wdGlvbnMubWFya2VyLFxuICAgICAgICAgICAgZSA9IGIgJiYgYi5vcHRpb25zLFxuICAgICAgICAgICAgZiA9IGUgJiYgZS5tYXJrZXIgfHwge30sXG4gICAgICAgICAgICBkID0gdGhpcy5jb2xvcixcbiAgICAgICAgICAgIGsgPSBlICYmIGUuY29sb3IsXG4gICAgICAgICAgICBoID0gYiAmJiBiLmNvbG9yO1xuICAgICAgICBlID0gbChmLmxpbmVXaWR0aCwgYy5saW5lV2lkdGgpO1xuICAgICAgICB2YXIgcCA9IGIgJiYgYi56b25lICYmIGIuem9uZS5jb2xvcjtcbiAgICAgICAgYiA9IDE7XG4gICAgICAgIGQgPSBrIHx8IHAgfHwgaCB8fCBkO1xuICAgICAgICBrID0gZi5maWxsQ29sb3IgfHwgYy5maWxsQ29sb3IgfHwgZDtcbiAgICAgICAgZCA9IGYubGluZUNvbG9yIHx8IGMubGluZUNvbG9yIHx8IGQ7XG4gICAgICAgIGEgPSBhIHx8IFwibm9ybWFsXCI7XG4gICAgICAgIGMgPSBjLnN0YXRlc1thXTtcbiAgICAgICAgYSA9IGYuc3RhdGVzICYmIGYuc3RhdGVzW2FdIHx8IHt9O1xuICAgICAgICBlID0gbChhLmxpbmVXaWR0aCwgYy5saW5lV2lkdGgsIGUgKyBsKGEubGluZVdpZHRoUGx1cywgYy5saW5lV2lkdGhQbHVzLCAwKSk7XG4gICAgICAgIGsgPSBhLmZpbGxDb2xvciB8fCBjLmZpbGxDb2xvciB8fCBrO1xuICAgICAgICBkID0gYS5saW5lQ29sb3IgfHwgYy5saW5lQ29sb3IgfHwgZDtcbiAgICAgICAgYiA9IGwoYS5vcGFjaXR5LCBjLm9wYWNpdHksIGIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0cm9rZTogZCxcbiAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBlLFxuICAgICAgICAgIGZpbGw6IGssXG4gICAgICAgICAgb3BhY2l0eTogYlxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBjID0gdGhpcyxcbiAgICAgICAgICAgIGUgPSBjLmNoYXJ0LFxuICAgICAgICAgICAgZiA9IC9BcHBsZVdlYktpdFxcLzUzMy8udGVzdChwLm5hdmlnYXRvci51c2VyQWdlbnQpLFxuICAgICAgICAgICAgZCxcbiAgICAgICAgICAgIGssXG4gICAgICAgICAgICBoID0gYy5kYXRhIHx8IFtdLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIG47XG4gICAgICAgIHEoYywgXCJkZXN0cm95XCIpO1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50cyhiKTtcbiAgICAgICAgKGMuYXhpc1R5cGVzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgKG4gPSBjW2JdKSAmJiBuLnNlcmllcyAmJiAodChuLnNlcmllcywgYyksIG4uaXNEaXJ0eSA9IG4uZm9yY2VSZWRyYXcgPSAhMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjLmxlZ2VuZEl0ZW0gJiYgYy5jaGFydC5sZWdlbmQuZGVzdHJveUl0ZW0oYyk7XG5cbiAgICAgICAgZm9yIChrID0gaC5sZW5ndGg7IGstLTspIChsID0gaFtrXSkgJiYgbC5kZXN0cm95ICYmIGwuZGVzdHJveSgpO1xuXG4gICAgICAgIGMucG9pbnRzID0gbnVsbDtcbiAgICAgICAgdS5jbGVhclRpbWVvdXQoYy5hbmltYXRpb25UaW1lb3V0KTtcbiAgICAgICAgYShjLCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIGIgaW5zdGFuY2VvZiBLICYmICFiLnN1cnZpdmUgJiYgKGQgPSBmICYmIFwiZ3JvdXBcIiA9PT0gYSA/IFwiaGlkZVwiIDogXCJkZXN0cm95XCIsIGJbZF0oKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlLmhvdmVyU2VyaWVzID09PSBjICYmIChlLmhvdmVyU2VyaWVzID0gbnVsbCk7XG4gICAgICAgIHQoZS5zZXJpZXMsIGMpO1xuICAgICAgICBlLm9yZGVyU2VyaWVzKCk7XG4gICAgICAgIGEoYywgZnVuY3Rpb24gKGEsIGUpIHtcbiAgICAgICAgICBiICYmIFwiaGNFdmVudHNcIiA9PT0gZSB8fCBkZWxldGUgY1tlXTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZ2V0R3JhcGhQYXRoOiBmdW5jdGlvbiAoYiwgYSwgYykge1xuICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgICBmID0gZS5vcHRpb25zLFxuICAgICAgICAgICAgZCA9IGYuc3RlcCxcbiAgICAgICAgICAgIGssXG4gICAgICAgICAgICBoID0gW10sXG4gICAgICAgICAgICBsID0gW10sXG4gICAgICAgICAgICBwO1xuICAgICAgICBiID0gYiB8fCBlLnBvaW50cztcbiAgICAgICAgKGsgPSBiLnJldmVyc2VkKSAmJiBiLnJldmVyc2UoKTtcbiAgICAgICAgKGQgPSB7XG4gICAgICAgICAgcmlnaHQ6IDEsXG4gICAgICAgICAgY2VudGVyOiAyXG4gICAgICAgIH1bZF0gfHwgZCAmJiAzKSAmJiBrICYmIChkID0gNCAtIGQpO1xuICAgICAgICBiID0gdGhpcy5nZXRWYWxpZFBvaW50cyhiLCAhMSwgIShmLmNvbm5lY3ROdWxscyAmJiAhYSAmJiAhYykpO1xuICAgICAgICBiLmZvckVhY2goZnVuY3Rpb24gKGssIG4pIHtcbiAgICAgICAgICB2YXIgbSA9IGsucGxvdFgsXG4gICAgICAgICAgICAgIGcgPSBrLnBsb3RZLFxuICAgICAgICAgICAgICB3ID0gYltuIC0gMV07XG4gICAgICAgICAgKGsubGVmdENsaWZmIHx8IHcgJiYgdy5yaWdodENsaWZmKSAmJiAhYyAmJiAocCA9ICEwKTtcbiAgICAgICAgICBrLmlzTnVsbCAmJiAheShhKSAmJiAwIDwgbiA/IHAgPSAhZi5jb25uZWN0TnVsbHMgOiBrLmlzTnVsbCAmJiAhYSA/IHAgPSAhMCA6ICgwID09PSBuIHx8IHAgPyBuID0gW1wiTVwiLCBrLnBsb3RYLCBrLnBsb3RZXSA6IGUuZ2V0UG9pbnRTcGxpbmUgPyBuID0gZS5nZXRQb2ludFNwbGluZShiLCBrLCBuKSA6IGQgPyAobiA9IDEgPT09IGQgPyBbXCJMXCIsIHcucGxvdFgsIGddIDogMiA9PT0gZCA/IFtcIkxcIiwgKHcucGxvdFggKyBtKSAvIDIsIHcucGxvdFksIFwiTFwiLCAody5wbG90WCArIG0pIC8gMiwgZ10gOiBbXCJMXCIsIG0sIHcucGxvdFldLCBuLnB1c2goXCJMXCIsIG0sIGcpKSA6IG4gPSBbXCJMXCIsIG0sIGddLCBsLnB1c2goay54KSwgZCAmJiAobC5wdXNoKGsueCksIDIgPT09IGQgJiYgbC5wdXNoKGsueCkpLCBoLnB1c2guYXBwbHkoaCwgbiksIHAgPSAhMSk7XG4gICAgICAgIH0pO1xuICAgICAgICBoLnhNYXAgPSBsO1xuICAgICAgICByZXR1cm4gZS5ncmFwaFBhdGggPSBoO1xuICAgICAgfSxcbiAgICAgIGRyYXdHcmFwaDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgICAgICBhID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgYyA9ICh0aGlzLmdhcHBlZFBhdGggfHwgdGhpcy5nZXRHcmFwaFBhdGgpLmNhbGwodGhpcyksXG4gICAgICAgICAgICBlID0gdGhpcy5jaGFydC5zdHlsZWRNb2RlLFxuICAgICAgICAgICAgZiA9IFtbXCJncmFwaFwiLCBcImhpZ2hjaGFydHMtZ3JhcGhcIl1dO1xuICAgICAgICBlIHx8IGZbMF0ucHVzaChhLmxpbmVDb2xvciB8fCB0aGlzLmNvbG9yIHx8IFwiI2NjY2NjY1wiLCBhLmRhc2hTdHlsZSk7XG4gICAgICAgIGYgPSBiLmdldFpvbmVzR3JhcGhzKGYpO1xuICAgICAgICBmLmZvckVhY2goZnVuY3Rpb24gKGYsIGQpIHtcbiAgICAgICAgICB2YXIgayA9IGZbMF0sXG4gICAgICAgICAgICAgIGggPSBiW2tdLFxuICAgICAgICAgICAgICBsID0gaCA/IFwiYW5pbWF0ZVwiIDogXCJhdHRyXCI7XG4gICAgICAgICAgaCA/IChoLmVuZFggPSBiLnByZXZlbnRHcmFwaEFuaW1hdGlvbiA/IG51bGwgOiBjLnhNYXAsIGguYW5pbWF0ZSh7XG4gICAgICAgICAgICBkOiBjXG4gICAgICAgICAgfSkpIDogYy5sZW5ndGggJiYgKGJba10gPSBoID0gYi5jaGFydC5yZW5kZXJlci5wYXRoKGMpLmFkZENsYXNzKGZbMV0pLmF0dHIoe1xuICAgICAgICAgICAgekluZGV4OiAxXG4gICAgICAgICAgfSkuYWRkKGIuZ3JvdXApKTtcbiAgICAgICAgICBoICYmICFlICYmIChrID0ge1xuICAgICAgICAgICAgc3Ryb2tlOiBmWzJdLFxuICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogYS5saW5lV2lkdGgsXG4gICAgICAgICAgICBmaWxsOiBiLmZpbGxHcmFwaCAmJiBiLmNvbG9yIHx8IFwibm9uZVwiXG4gICAgICAgICAgfSwgZlszXSA/IGsuZGFzaHN0eWxlID0gZlszXSA6IFwic3F1YXJlXCIgIT09IGEubGluZWNhcCAmJiAoa1tcInN0cm9rZS1saW5lY2FwXCJdID0ga1tcInN0cm9rZS1saW5lam9pblwiXSA9IFwicm91bmRcIiksIGhbbF0oaykuc2hhZG93KDIgPiBkICYmIGEuc2hhZG93KSk7XG4gICAgICAgICAgaCAmJiAoaC5zdGFydFggPSBjLnhNYXAsIGguaXNBcmVhID0gYy5pc0FyZWEpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZXRab25lc0dyYXBoczogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdGhpcy56b25lcy5mb3JFYWNoKGZ1bmN0aW9uIChiLCBjKSB7XG4gICAgICAgICAgYyA9IFtcInpvbmUtZ3JhcGgtXCIgKyBjLCBcImhpZ2hjaGFydHMtZ3JhcGggaGlnaGNoYXJ0cy16b25lLWdyYXBoLVwiICsgYyArIFwiIFwiICsgKGIuY2xhc3NOYW1lIHx8IFwiXCIpXTtcbiAgICAgICAgICB0aGlzLmNoYXJ0LnN0eWxlZE1vZGUgfHwgYy5wdXNoKGIuY29sb3IgfHwgdGhpcy5jb2xvciwgYi5kYXNoU3R5bGUgfHwgdGhpcy5vcHRpb25zLmRhc2hTdHlsZSk7XG4gICAgICAgICAgYS5wdXNoKGMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9LFxuICAgICAgYXBwbHlab25lczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICBjID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGUgPSBjLnJlbmRlcmVyLFxuICAgICAgICAgICAgZiA9IHRoaXMuem9uZXMsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgayxcbiAgICAgICAgICAgIGggPSB0aGlzLmNsaXBzIHx8IFtdLFxuICAgICAgICAgICAgcCxcbiAgICAgICAgICAgIG4gPSB0aGlzLmdyYXBoLFxuICAgICAgICAgICAgZyA9IHRoaXMuYXJlYSxcbiAgICAgICAgICAgIHcgPSBNYXRoLm1heChjLmNoYXJ0V2lkdGgsIGMuY2hhcnRIZWlnaHQpLFxuICAgICAgICAgICAgdiA9IHRoaXNbKHRoaXMuem9uZUF4aXMgfHwgXCJ5XCIpICsgXCJBeGlzXCJdLFxuICAgICAgICAgICAgcSA9IGMuaW52ZXJ0ZWQsXG4gICAgICAgICAgICB0LFxuICAgICAgICAgICAgQixcbiAgICAgICAgICAgIHosXG4gICAgICAgICAgICB5ID0gITE7XG5cbiAgICAgICAgaWYgKGYubGVuZ3RoICYmIChuIHx8IGcpICYmIHYgJiYgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHYubWluKSB7XG4gICAgICAgICAgdmFyIEsgPSB2LnJldmVyc2VkO1xuICAgICAgICAgIHZhciBMID0gdi5ob3JpejtcbiAgICAgICAgICBuICYmICF0aGlzLnNob3dMaW5lICYmIG4uaGlkZSgpO1xuICAgICAgICAgIGcgJiYgZy5oaWRlKCk7XG4gICAgICAgICAgdmFyIHUgPSB2LmdldEV4dHJlbWVzKCk7XG4gICAgICAgICAgZi5mb3JFYWNoKGZ1bmN0aW9uIChiLCBmKSB7XG4gICAgICAgICAgICBkID0gSyA/IEwgPyBjLnBsb3RXaWR0aCA6IDAgOiBMID8gMCA6IHYudG9QaXhlbHModS5taW4pIHx8IDA7XG4gICAgICAgICAgICBkID0gRyhsKGssIGQpLCAwLCB3KTtcbiAgICAgICAgICAgIGsgPSBHKE1hdGgucm91bmQodi50b1BpeGVscyhsKGIudmFsdWUsIHUubWF4KSwgITApIHx8IDApLCAwLCB3KTtcbiAgICAgICAgICAgIHkgJiYgKGQgPSBrID0gdi50b1BpeGVscyh1Lm1heCkpO1xuICAgICAgICAgICAgdCA9IE1hdGguYWJzKGQgLSBrKTtcbiAgICAgICAgICAgIEIgPSBNYXRoLm1pbihkLCBrKTtcbiAgICAgICAgICAgIHogPSBNYXRoLm1heChkLCBrKTtcbiAgICAgICAgICAgIHYuaXNYQXhpcyA/IChwID0ge1xuICAgICAgICAgICAgICB4OiBxID8geiA6IEIsXG4gICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgIHdpZHRoOiB0LFxuICAgICAgICAgICAgICBoZWlnaHQ6IHdcbiAgICAgICAgICAgIH0sIEwgfHwgKHAueCA9IGMucGxvdEhlaWdodCAtIHAueCkpIDogKHAgPSB7XG4gICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgIHk6IHEgPyB6IDogQixcbiAgICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICAgIGhlaWdodDogdFxuICAgICAgICAgICAgfSwgTCAmJiAocC55ID0gYy5wbG90V2lkdGggLSBwLnkpKTtcbiAgICAgICAgICAgIHEgJiYgZS5pc1ZNTCAmJiAocCA9IHYuaXNYQXhpcyA/IHtcbiAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgeTogSyA/IEIgOiB6LFxuICAgICAgICAgICAgICBoZWlnaHQ6IHAud2lkdGgsXG4gICAgICAgICAgICAgIHdpZHRoOiBjLmNoYXJ0V2lkdGhcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIHg6IHAueSAtIGMucGxvdExlZnQgLSBjLnNwYWNpbmdCb3gueCxcbiAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgd2lkdGg6IHAuaGVpZ2h0LFxuICAgICAgICAgICAgICBoZWlnaHQ6IGMuY2hhcnRIZWlnaHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaFtmXSA/IGhbZl0uYW5pbWF0ZShwKSA6IGhbZl0gPSBlLmNsaXBSZWN0KHApO1xuICAgICAgICAgICAgbiAmJiBhW1wiem9uZS1ncmFwaC1cIiArIGZdLmNsaXAoaFtmXSk7XG4gICAgICAgICAgICBnICYmIGFbXCJ6b25lLWFyZWEtXCIgKyBmXS5jbGlwKGhbZl0pO1xuICAgICAgICAgICAgeSA9IGIudmFsdWUgPiB1Lm1heDtcbiAgICAgICAgICAgIGEucmVzZXRab25lcyAmJiAwID09PSBrICYmIChrID0gdm9pZCAwKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmNsaXBzID0gaDtcbiAgICAgICAgfSBlbHNlIGEudmlzaWJsZSAmJiAobiAmJiBuLnNob3coITApLCBnICYmIGcuc2hvdyghMCkpO1xuICAgICAgfSxcbiAgICAgIGludmVydEdyb3VwczogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgZnVuY3Rpb24gYigpIHtcbiAgICAgICAgICBbXCJncm91cFwiLCBcIm1hcmtlckdyb3VwXCJdLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIGNbYl0gJiYgKGUucmVuZGVyZXIuaXNWTUwgJiYgY1tiXS5hdHRyKHtcbiAgICAgICAgICAgICAgd2lkdGg6IGMueUF4aXMubGVuLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGMueEF4aXMubGVuXG4gICAgICAgICAgICB9KSwgY1tiXS53aWR0aCA9IGMueUF4aXMubGVuLCBjW2JdLmhlaWdodCA9IGMueEF4aXMubGVuLCBjW2JdLmludmVydChjLmlzUmFkaWFsU2VyaWVzID8gITEgOiBhKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHRoaXMsXG4gICAgICAgICAgICBlID0gYy5jaGFydDtcbiAgICAgICAgYy54QXhpcyAmJiAoYy5ldmVudHNUb1VuYmluZC5wdXNoKEkoZSwgXCJyZXNpemVcIiwgYikpLCBiKCksIGMuaW52ZXJ0R3JvdXBzID0gYik7XG4gICAgICB9LFxuICAgICAgcGxvdEdyb3VwOiBmdW5jdGlvbiAoYSwgYywgZSwgZiwgZCkge1xuICAgICAgICB2YXIgYiA9IHRoaXNbYV0sXG4gICAgICAgICAgICBrID0gIWI7XG4gICAgICAgIGsgJiYgKHRoaXNbYV0gPSBiID0gdGhpcy5jaGFydC5yZW5kZXJlci5nKCkuYXR0cih7XG4gICAgICAgICAgekluZGV4OiBmIHx8IC4xXG4gICAgICAgIH0pLmFkZChkKSk7XG4gICAgICAgIGIuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLVwiICsgYyArIFwiIGhpZ2hjaGFydHMtc2VyaWVzLVwiICsgdGhpcy5pbmRleCArIFwiIGhpZ2hjaGFydHMtXCIgKyB0aGlzLnR5cGUgKyBcIi1zZXJpZXMgXCIgKyAoeSh0aGlzLmNvbG9ySW5kZXgpID8gXCJoaWdoY2hhcnRzLWNvbG9yLVwiICsgdGhpcy5jb2xvckluZGV4ICsgXCIgXCIgOiBcIlwiKSArICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lIHx8IFwiXCIpICsgKGIuaGFzQ2xhc3MoXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikgPyBcIiBoaWdoY2hhcnRzLXRyYWNrZXJcIiA6IFwiXCIpLCAhMCk7XG4gICAgICAgIGIuYXR0cih7XG4gICAgICAgICAgdmlzaWJpbGl0eTogZVxuICAgICAgICB9KVtrID8gXCJhdHRyXCIgOiBcImFuaW1hdGVcIl0odGhpcy5nZXRQbG90Qm94KCkpO1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0sXG4gICAgICBnZXRQbG90Qm94OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGMgPSB0aGlzLnhBeGlzLFxuICAgICAgICAgICAgZSA9IHRoaXMueUF4aXM7XG4gICAgICAgIGEuaW52ZXJ0ZWQgJiYgKGMgPSBlLCBlID0gdGhpcy54QXhpcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHJhbnNsYXRlWDogYyA/IGMubGVmdCA6IGEucGxvdExlZnQsXG4gICAgICAgICAgdHJhbnNsYXRlWTogZSA/IGUudG9wIDogYS5wbG90VG9wLFxuICAgICAgICAgIHNjYWxlWDogMSxcbiAgICAgICAgICBzY2FsZVk6IDFcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVFdmVudHM6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGEgPyB0aGlzLmV2ZW50c1RvVW5iaW5kLmxlbmd0aCAmJiAodGhpcy5ldmVudHNUb1VuYmluZC5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYSgpO1xuICAgICAgICB9KSwgdGhpcy5ldmVudHNUb1VuYmluZC5sZW5ndGggPSAwKSA6IHYodGhpcyk7XG4gICAgICB9LFxuICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIGMgPSBhLmNoYXJ0LFxuICAgICAgICAgICAgZSA9IGEub3B0aW9ucyxcbiAgICAgICAgICAgIGYgPSAhYS5maW5pc2hlZEFuaW1hdGluZyAmJiBjLnJlbmRlcmVyLmlzU1ZHICYmIE0oZS5hbmltYXRpb24pLmR1cmF0aW9uLFxuICAgICAgICAgICAgZCA9IGEudmlzaWJsZSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIixcbiAgICAgICAgICAgIGsgPSBlLnpJbmRleCxcbiAgICAgICAgICAgIGggPSBhLmhhc1JlbmRlcmVkLFxuICAgICAgICAgICAgbCA9IGMuc2VyaWVzR3JvdXAsXG4gICAgICAgICAgICBwID0gYy5pbnZlcnRlZDtcbiAgICAgICAgcSh0aGlzLCBcInJlbmRlclwiKTtcbiAgICAgICAgdmFyIG4gPSBhLnBsb3RHcm91cChcImdyb3VwXCIsIFwic2VyaWVzXCIsIGQsIGssIGwpO1xuICAgICAgICBhLm1hcmtlckdyb3VwID0gYS5wbG90R3JvdXAoXCJtYXJrZXJHcm91cFwiLCBcIm1hcmtlcnNcIiwgZCwgaywgbCk7XG4gICAgICAgIGYgJiYgYS5hbmltYXRlICYmIGEuYW5pbWF0ZSghMCk7XG4gICAgICAgIG4uaW52ZXJ0ZWQgPSBhLmlzQ2FydGVzaWFuIHx8IGEuaW52ZXJ0YWJsZSA/IHAgOiAhMTtcbiAgICAgICAgYS5kcmF3R3JhcGggJiYgKGEuZHJhd0dyYXBoKCksIGEuYXBwbHlab25lcygpKTtcbiAgICAgICAgYS52aXNpYmxlICYmIGEuZHJhd1BvaW50cygpO1xuICAgICAgICBhLmRyYXdEYXRhTGFiZWxzICYmIGEuZHJhd0RhdGFMYWJlbHMoKTtcbiAgICAgICAgYS5yZWRyYXdQb2ludHMgJiYgYS5yZWRyYXdQb2ludHMoKTtcbiAgICAgICAgYS5kcmF3VHJhY2tlciAmJiAhMSAhPT0gYS5vcHRpb25zLmVuYWJsZU1vdXNlVHJhY2tpbmcgJiYgYS5kcmF3VHJhY2tlcigpO1xuICAgICAgICBhLmludmVydEdyb3VwcyhwKTtcbiAgICAgICAgITEgPT09IGUuY2xpcCB8fCBhLnNoYXJlZENsaXBLZXkgfHwgaCB8fCBuLmNsaXAoYy5jbGlwUmVjdCk7XG4gICAgICAgIGYgJiYgYS5hbmltYXRlICYmIGEuYW5pbWF0ZSgpO1xuICAgICAgICBoIHx8IChhLmFuaW1hdGlvblRpbWVvdXQgPSBCKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhLmFmdGVyQW5pbWF0ZSgpO1xuICAgICAgICB9LCBmIHx8IDApKTtcbiAgICAgICAgYS5pc0RpcnR5ID0gITE7XG4gICAgICAgIGEuaGFzUmVuZGVyZWQgPSAhMDtcbiAgICAgICAgcShhLCBcImFmdGVyUmVuZGVyXCIpO1xuICAgICAgfSxcbiAgICAgIHJlZHJhdzogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBjID0gdGhpcy5pc0RpcnR5IHx8IHRoaXMuaXNEaXJ0eURhdGEsXG4gICAgICAgICAgICBlID0gdGhpcy5ncm91cCxcbiAgICAgICAgICAgIGYgPSB0aGlzLnhBeGlzLFxuICAgICAgICAgICAgZCA9IHRoaXMueUF4aXM7XG4gICAgICAgIGUgJiYgKGEuaW52ZXJ0ZWQgJiYgZS5hdHRyKHtcbiAgICAgICAgICB3aWR0aDogYS5wbG90V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBhLnBsb3RIZWlnaHRcbiAgICAgICAgfSksIGUuYW5pbWF0ZSh7XG4gICAgICAgICAgdHJhbnNsYXRlWDogbChmICYmIGYubGVmdCwgYS5wbG90TGVmdCksXG4gICAgICAgICAgdHJhbnNsYXRlWTogbChkICYmIGQudG9wLCBhLnBsb3RUb3ApXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy50cmFuc2xhdGUoKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgYyAmJiBkZWxldGUgdGhpcy5rZFRyZWU7XG4gICAgICB9LFxuICAgICAga2RBeGlzQXJyYXk6IFtcImNsaWVudFhcIiwgXCJwbG90WVwiXSxcbiAgICAgIHNlYXJjaFBvaW50OiBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICB2YXIgYiA9IHRoaXMueEF4aXMsXG4gICAgICAgICAgICBlID0gdGhpcy55QXhpcyxcbiAgICAgICAgICAgIGYgPSB0aGlzLmNoYXJ0LmludmVydGVkO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hLRFRyZWUoe1xuICAgICAgICAgIGNsaWVudFg6IGYgPyBiLmxlbiAtIGEuY2hhcnRZICsgYi5wb3MgOiBhLmNoYXJ0WCAtIGIucG9zLFxuICAgICAgICAgIHBsb3RZOiBmID8gZS5sZW4gLSBhLmNoYXJ0WCArIGUucG9zIDogYS5jaGFydFkgLSBlLnBvc1xuICAgICAgICB9LCBjLCBhKTtcbiAgICAgIH0sXG4gICAgICBidWlsZEtEVHJlZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgZnVuY3Rpb24gYihhLCBlLCBmKSB7XG4gICAgICAgICAgdmFyIGQ7XG5cbiAgICAgICAgICBpZiAoZCA9IGEgJiYgYS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBrID0gYy5rZEF4aXNBcnJheVtlICUgZl07XG4gICAgICAgICAgICBhLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFba10gLSBiW2tdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkID0gTWF0aC5mbG9vcihkIC8gMik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBwb2ludDogYVtkXSxcbiAgICAgICAgICAgICAgbGVmdDogYihhLnNsaWNlKDAsIGQpLCBlICsgMSwgZiksXG4gICAgICAgICAgICAgIHJpZ2h0OiBiKGEuc2xpY2UoZCArIDEpLCBlICsgMSwgZilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5idWlsZGluZ0tkVHJlZSA9ICEwO1xuICAgICAgICB2YXIgYyA9IHRoaXMsXG4gICAgICAgICAgICBlID0gLTEgPCBjLm9wdGlvbnMuZmluZE5lYXJlc3RQb2ludEJ5LmluZGV4T2YoXCJ5XCIpID8gMiA6IDE7XG4gICAgICAgIGRlbGV0ZSBjLmtkVHJlZTtcbiAgICAgICAgQihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYy5rZFRyZWUgPSBiKGMuZ2V0VmFsaWRQb2ludHMobnVsbCwgIWMuZGlyZWN0VG91Y2gpLCBlLCBlKTtcbiAgICAgICAgICBjLmJ1aWxkaW5nS2RUcmVlID0gITE7XG4gICAgICAgIH0sIGMub3B0aW9ucy5rZE5vdyB8fCBhICYmIFwidG91Y2hzdGFydFwiID09PSBhLnR5cGUgPyAwIDogMSk7XG4gICAgICB9LFxuICAgICAgc2VhcmNoS0RUcmVlOiBmdW5jdGlvbiAoYSwgYywgZSkge1xuICAgICAgICBmdW5jdGlvbiBiKGEsIGMsIGUsIGwpIHtcbiAgICAgICAgICB2YXIgcCA9IGMucG9pbnQsXG4gICAgICAgICAgICAgIG4gPSBmLmtkQXhpc0FycmF5W2UgJSBsXSxcbiAgICAgICAgICAgICAgZyA9IHA7XG4gICAgICAgICAgdmFyIG0gPSB5KGFbZF0pICYmIHkocFtkXSkgPyBNYXRoLnBvdyhhW2RdIC0gcFtkXSwgMikgOiBudWxsO1xuICAgICAgICAgIHZhciB3ID0geShhW2tdKSAmJiB5KHBba10pID8gTWF0aC5wb3coYVtrXSAtIHBba10sIDIpIDogbnVsbDtcbiAgICAgICAgICB3ID0gKG0gfHwgMCkgKyAodyB8fCAwKTtcbiAgICAgICAgICBwLmRpc3QgPSB5KHcpID8gTWF0aC5zcXJ0KHcpIDogTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICBwLmRpc3RYID0geShtKSA/IE1hdGguc3FydChtKSA6IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgbiA9IGFbbl0gLSBwW25dO1xuICAgICAgICAgIHcgPSAwID4gbiA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xuICAgICAgICAgIG0gPSAwID4gbiA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xuICAgICAgICAgIGNbd10gJiYgKHcgPSBiKGEsIGNbd10sIGUgKyAxLCBsKSwgZyA9IHdbaF0gPCBnW2hdID8gdyA6IHApO1xuICAgICAgICAgIGNbbV0gJiYgTWF0aC5zcXJ0KG4gKiBuKSA8IGdbaF0gJiYgKGEgPSBiKGEsIGNbbV0sIGUgKyAxLCBsKSwgZyA9IGFbaF0gPCBnW2hdID8gYSA6IGcpO1xuICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGYgPSB0aGlzLFxuICAgICAgICAgICAgZCA9IHRoaXMua2RBeGlzQXJyYXlbMF0sXG4gICAgICAgICAgICBrID0gdGhpcy5rZEF4aXNBcnJheVsxXSxcbiAgICAgICAgICAgIGggPSBjID8gXCJkaXN0WFwiIDogXCJkaXN0XCI7XG4gICAgICAgIGMgPSAtMSA8IGYub3B0aW9ucy5maW5kTmVhcmVzdFBvaW50QnkuaW5kZXhPZihcInlcIikgPyAyIDogMTtcbiAgICAgICAgdGhpcy5rZFRyZWUgfHwgdGhpcy5idWlsZGluZ0tkVHJlZSB8fCB0aGlzLmJ1aWxkS0RUcmVlKGUpO1xuICAgICAgICBpZiAodGhpcy5rZFRyZWUpIHJldHVybiBiKGEsIHRoaXMua2RUcmVlLCBjLCBjKTtcbiAgICAgIH0sXG4gICAgICBwb2ludFBsYWNlbWVudFRvWFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgYyA9IGEucG9pbnRSYW5nZSxcbiAgICAgICAgICAgIGUgPSB0aGlzLnhBeGlzO1xuICAgICAgICBhID0gYS5wb2ludFBsYWNlbWVudDtcbiAgICAgICAgXCJiZXR3ZWVuXCIgPT09IGEgJiYgKGEgPSBlLnJldmVyc2VkID8gLS41IDogLjUpO1xuICAgICAgICByZXR1cm4gayhhKSA/IGEgKiBsKGMsIGUucG9pbnRSYW5nZSkgOiAwO1xuICAgICAgfSxcbiAgICAgIGlzUG9pbnRJbnNpZGU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYS5wbG90WSAmJiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYS5wbG90WCAmJiAwIDw9IGEucGxvdFkgJiYgYS5wbG90WSA8PSB0aGlzLnlBeGlzLmxlbiAmJiAwIDw9IGEucGxvdFggJiYgYS5wbG90WCA8PSB0aGlzLnhBeGlzLmxlbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcIlwiO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL1N0YWNraW5nLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgdmFyIHIgPSBnLmNvcnJlY3RGbG9hdCxcbiAgICAgICAgdSA9IGcuZGVmaW5lZCxcbiAgICAgICAgSSA9IGcuZGVzdHJveU9iamVjdFByb3BlcnRpZXMsXG4gICAgICAgIE0gPSBnLmZvcm1hdCxcbiAgICAgICAgRSA9IGcub2JqZWN0RWFjaCxcbiAgICAgICAgQSA9IGcucGljaztcbiAgICBnID0gZC5BeGlzO1xuICAgIHZhciBHID0gZC5DaGFydCxcbiAgICAgICAgSiA9IGQuU2VyaWVzO1xuXG4gICAgZC5TdGFja0l0ZW0gPSBmdW5jdGlvbiAoZCwgZywgdSwgaCwgcikge1xuICAgICAgdmFyIHEgPSBkLmNoYXJ0LmludmVydGVkO1xuICAgICAgdGhpcy5heGlzID0gZDtcbiAgICAgIHRoaXMuaXNOZWdhdGl2ZSA9IHU7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBnID0gZyB8fCB7fTtcbiAgICAgIHRoaXMueCA9IGg7XG4gICAgICB0aGlzLnRvdGFsID0gbnVsbDtcbiAgICAgIHRoaXMucG9pbnRzID0ge307XG4gICAgICB0aGlzLnN0YWNrID0gcjtcbiAgICAgIHRoaXMucmlnaHRDbGlmZiA9IHRoaXMubGVmdENsaWZmID0gMDtcbiAgICAgIHRoaXMuYWxpZ25PcHRpb25zID0ge1xuICAgICAgICBhbGlnbjogZy5hbGlnbiB8fCAocSA/IHUgPyBcImxlZnRcIiA6IFwicmlnaHRcIiA6IFwiY2VudGVyXCIpLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBnLnZlcnRpY2FsQWxpZ24gfHwgKHEgPyBcIm1pZGRsZVwiIDogdSA/IFwiYm90dG9tXCIgOiBcInRvcFwiKSxcbiAgICAgICAgeTogZy55LFxuICAgICAgICB4OiBnLnhcbiAgICAgIH07XG4gICAgICB0aGlzLnRleHRBbGlnbiA9IGcudGV4dEFsaWduIHx8IChxID8gdSA/IFwicmlnaHRcIiA6IFwibGVmdFwiIDogXCJjZW50ZXJcIik7XG4gICAgfTtcblxuICAgIGQuU3RhY2tJdGVtLnByb3RvdHlwZSA9IHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgSSh0aGlzLCB0aGlzLmF4aXMpO1xuICAgICAgfSxcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIGcgPSB0aGlzLmF4aXMuY2hhcnQsXG4gICAgICAgICAgICB5ID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgaCA9IHkuZm9ybWF0O1xuICAgICAgICBoID0gaCA/IE0oaCwgdGhpcywgZykgOiB5LmZvcm1hdHRlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmxhYmVsID8gdGhpcy5sYWJlbC5hdHRyKHtcbiAgICAgICAgICB0ZXh0OiBoLFxuICAgICAgICAgIHZpc2liaWxpdHk6IFwiaGlkZGVuXCJcbiAgICAgICAgfSkgOiAodGhpcy5sYWJlbCA9IGcucmVuZGVyZXIubGFiZWwoaCwgbnVsbCwgbnVsbCwgeS5zaGFwZSwgbnVsbCwgbnVsbCwgeS51c2VIVE1MLCAhMSwgXCJzdGFjay1sYWJlbHNcIiksIGggPSB7XG4gICAgICAgICAgdGV4dDogaCxcbiAgICAgICAgICByb3RhdGlvbjogeS5yb3RhdGlvbixcbiAgICAgICAgICBwYWRkaW5nOiBBKHkucGFkZGluZywgNSksXG4gICAgICAgICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIlxuICAgICAgICB9LCB0aGlzLmxhYmVsLmF0dHIoaCksIGcuc3R5bGVkTW9kZSB8fCB0aGlzLmxhYmVsLmNzcyh5LnN0eWxlKSwgdGhpcy5sYWJlbC5hZGRlZCB8fCB0aGlzLmxhYmVsLmFkZChkKSk7XG4gICAgICAgIHRoaXMubGFiZWwubGFiZWxyYW5rID0gZy5wbG90SGVpZ2h0O1xuICAgICAgfSxcbiAgICAgIHNldE9mZnNldDogZnVuY3Rpb24gKGQsIGcsIHIsIGgsIE4pIHtcbiAgICAgICAgdmFyIHEgPSB0aGlzLmF4aXMsXG4gICAgICAgICAgICB0ID0gcS5jaGFydDtcbiAgICAgICAgaCA9IHEudHJhbnNsYXRlKHEudXNlUGVyY2VudGFnZSA/IDEwMCA6IGggPyBoIDogdGhpcy50b3RhbCwgMCwgMCwgMCwgMSk7XG4gICAgICAgIHIgPSBxLnRyYW5zbGF0ZShyID8gciA6IDApO1xuICAgICAgICByID0gdShoKSAmJiBNYXRoLmFicyhoIC0gcik7XG4gICAgICAgIGQgPSBBKE4sIHQueEF4aXNbMF0udHJhbnNsYXRlKHRoaXMueCkpICsgZDtcbiAgICAgICAgcSA9IHUoaCkgJiYgdGhpcy5nZXRTdGFja0JveCh0LCB0aGlzLCBkLCBoLCBnLCByLCBxKTtcbiAgICAgICAgZyA9IHRoaXMubGFiZWw7XG4gICAgICAgIHIgPSB0aGlzLmlzTmVnYXRpdmU7XG4gICAgICAgIGQgPSBcImp1c3RpZnlcIiA9PT0gQSh0aGlzLm9wdGlvbnMub3ZlcmZsb3csIFwianVzdGlmeVwiKTtcbiAgICAgICAgdmFyIGUgPSB0aGlzLnRleHRBbGlnbjtcbiAgICAgICAgZyAmJiBxICYmIChOID0gZy5nZXRCQm94KCksIGggPSBnLnBhZGRpbmcsIGUgPSBcImxlZnRcIiA9PT0gZSA/IHQuaW52ZXJ0ZWQgPyAtaCA6IGggOiBcInJpZ2h0XCIgPT09IGUgPyBOLndpZHRoIDogdC5pbnZlcnRlZCAmJiBcImNlbnRlclwiID09PSBlID8gTi53aWR0aCAvIDIgOiB0LmludmVydGVkID8gciA/IE4ud2lkdGggKyBoIDogLWggOiBOLndpZHRoIC8gMiwgciA9IHQuaW52ZXJ0ZWQgPyBOLmhlaWdodCAvIDIgOiByID8gLWggOiBOLmhlaWdodCwgdGhpcy5hbGlnbk9wdGlvbnMueCA9IEEodGhpcy5vcHRpb25zLngsIDApLCB0aGlzLmFsaWduT3B0aW9ucy55ID0gQSh0aGlzLm9wdGlvbnMueSwgMCksIHEueCAtPSBlLCBxLnkgLT0gciwgZy5hbGlnbih0aGlzLmFsaWduT3B0aW9ucywgbnVsbCwgcSksIHQuaXNJbnNpZGVQbG90KGcuYWxpZ25BdHRyLnggKyBlIC0gdGhpcy5hbGlnbk9wdGlvbnMueCwgZy5hbGlnbkF0dHIueSArIHIgLSB0aGlzLmFsaWduT3B0aW9ucy55KSA/IGcuc2hvdygpIDogKGcuYWxpZ25BdHRyLnkgPSAtOTk5OSwgZCA9ICExKSwgZCAmJiBKLnByb3RvdHlwZS5qdXN0aWZ5RGF0YUxhYmVsLmNhbGwodGhpcy5heGlzLCBnLCB0aGlzLmFsaWduT3B0aW9ucywgZy5hbGlnbkF0dHIsIE4sIHEpLCBnLmF0dHIoe1xuICAgICAgICAgIHg6IGcuYWxpZ25BdHRyLngsXG4gICAgICAgICAgeTogZy5hbGlnbkF0dHIueVxuICAgICAgICB9KSwgQSghZCAmJiB0aGlzLm9wdGlvbnMuY3JvcCwgITApICYmICgodCA9IHQuaXNJbnNpZGVQbG90KGcueCAtIGggKyBnLndpZHRoLCBnLnkpICYmIHQuaXNJbnNpZGVQbG90KGcueCArIGgsIGcueSkpIHx8IGcuaGlkZSgpKSk7XG4gICAgICB9LFxuICAgICAgZ2V0U3RhY2tCb3g6IGZ1bmN0aW9uIChkLCBnLCByLCBoLCB1LCBxLCBBKSB7XG4gICAgICAgIHZhciBlID0gZy5heGlzLnJldmVyc2VkLFxuICAgICAgICAgICAgYyA9IGQuaW52ZXJ0ZWQ7XG4gICAgICAgIGQgPSBBLmhlaWdodCArIEEucG9zIC0gKGMgPyBkLnBsb3RMZWZ0IDogZC5wbG90VG9wKTtcbiAgICAgICAgZyA9IGcuaXNOZWdhdGl2ZSAmJiAhZSB8fCAhZy5pc05lZ2F0aXZlICYmIGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogYyA/IGcgPyBoIDogaCAtIHEgOiByLFxuICAgICAgICAgIHk6IGMgPyBkIC0gciAtIHUgOiBnID8gZCAtIGggLSBxIDogZCAtIGgsXG4gICAgICAgICAgd2lkdGg6IGMgPyBxIDogdSxcbiAgICAgICAgICBoZWlnaHQ6IGMgPyB1IDogcVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBHLnByb3RvdHlwZS5nZXRTdGFja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgZyA9IGQuaW52ZXJ0ZWQ7XG4gICAgICBkLnlBeGlzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgZC5zdGFja3MgJiYgZC5oYXNWaXNpYmxlU2VyaWVzICYmIChkLm9sZFN0YWNrcyA9IGQuc3RhY2tzKTtcbiAgICAgIH0pO1xuICAgICAgZC5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgaCA9IHQueEF4aXMgJiYgdC54QXhpcy5vcHRpb25zIHx8IHt9O1xuICAgICAgICAhdC5vcHRpb25zLnN0YWNraW5nIHx8ICEwICE9PSB0LnZpc2libGUgJiYgITEgIT09IGQub3B0aW9ucy5jaGFydC5pZ25vcmVIaWRkZW5TZXJpZXMgfHwgKHQuc3RhY2tLZXkgPSBbdC50eXBlLCBBKHQub3B0aW9ucy5zdGFjaywgXCJcIiksIGcgPyBoLnRvcCA6IGgubGVmdCwgZyA/IGguaGVpZ2h0IDogaC53aWR0aF0uam9pbigpKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBnLnByb3RvdHlwZS5idWlsZFN0YWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBnID0gdGhpcy5zZXJpZXMsXG4gICAgICAgICAgdCA9IEEodGhpcy5vcHRpb25zLnJldmVyc2VkU3RhY2tzLCAhMCksXG4gICAgICAgICAgciA9IGcubGVuZ3RoLFxuICAgICAgICAgIGg7XG5cbiAgICAgIGlmICghdGhpcy5pc1hBeGlzKSB7XG4gICAgICAgIHRoaXMudXNlUGVyY2VudGFnZSA9ICExO1xuXG4gICAgICAgIGZvciAoaCA9IHI7IGgtLTspIHtcbiAgICAgICAgICB2YXIgdSA9IGdbdCA/IGggOiByIC0gaCAtIDFdO1xuICAgICAgICAgIHUuc2V0U3RhY2tlZFBvaW50cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChoID0gMDsgaCA8IHI7IGgrKykgZ1toXS5tb2RpZnlTdGFja3MoKTtcblxuICAgICAgICBkLmZpcmVFdmVudCh0aGlzLCBcImFmdGVyQnVpbGRTdGFja3NcIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGcucHJvdG90eXBlLnJlbmRlclN0YWNrVG90YWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGQgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgIGcgPSBkLnJlbmRlcmVyLFxuICAgICAgICAgIHIgPSB0aGlzLnN0YWNrcyxcbiAgICAgICAgICBoID0gdGhpcy5zdGFja1RvdGFsR3JvdXA7XG4gICAgICBoIHx8ICh0aGlzLnN0YWNrVG90YWxHcm91cCA9IGggPSBnLmcoXCJzdGFjay1sYWJlbHNcIikuYXR0cih7XG4gICAgICAgIHZpc2liaWxpdHk6IFwidmlzaWJsZVwiLFxuICAgICAgICB6SW5kZXg6IDZcbiAgICAgIH0pLmFkZCgpKTtcbiAgICAgIGgudHJhbnNsYXRlKGQucGxvdExlZnQsIGQucGxvdFRvcCk7XG4gICAgICBFKHIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIEUoZCwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBkLnJlbmRlcihoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZy5wcm90b3R5cGUucmVzZXRTdGFja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgZyA9IGQuc3RhY2tzO1xuICAgICAgZC5pc1hBeGlzIHx8IEUoZywgZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgRShnLCBmdW5jdGlvbiAoaCwgdCkge1xuICAgICAgICAgIGgudG91Y2hlZCA8IGQuc3RhY2tzVG91Y2hlZCA/IChoLmRlc3Ryb3koKSwgZGVsZXRlIGdbdF0pIDogKGgudG90YWwgPSBudWxsLCBoLmN1bXVsYXRpdmUgPSBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZy5wcm90b3R5cGUuY2xlYW5TdGFja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuaXNYQXhpcykge1xuICAgICAgICBpZiAodGhpcy5vbGRTdGFja3MpIHZhciBkID0gdGhpcy5zdGFja3MgPSB0aGlzLm9sZFN0YWNrcztcbiAgICAgICAgRShkLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIEUoZCwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGQuY3VtdWxhdGl2ZSA9IGQudG90YWw7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBKLnByb3RvdHlwZS5zZXRTdGFja2VkUG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFja2luZyAmJiAoITAgPT09IHRoaXMudmlzaWJsZSB8fCAhMSA9PT0gdGhpcy5jaGFydC5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcykpIHtcbiAgICAgICAgdmFyIGcgPSB0aGlzLnByb2Nlc3NlZFhEYXRhLFxuICAgICAgICAgICAgdCA9IHRoaXMucHJvY2Vzc2VkWURhdGEsXG4gICAgICAgICAgICBEID0gW10sXG4gICAgICAgICAgICBoID0gdC5sZW5ndGgsXG4gICAgICAgICAgICBOID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgcSA9IE4udGhyZXNob2xkLFxuICAgICAgICAgICAgRyA9IEEoTi5zdGFydEZyb21UaHJlc2hvbGQgJiYgcSwgMCksXG4gICAgICAgICAgICBlID0gTi5zdGFjaztcbiAgICAgICAgTiA9IE4uc3RhY2tpbmc7XG4gICAgICAgIHZhciBjID0gdGhpcy5zdGFja0tleSxcbiAgICAgICAgICAgIGsgPSBcIi1cIiArIGMsXG4gICAgICAgICAgICBuID0gdGhpcy5uZWdTdGFja3MsXG4gICAgICAgICAgICBmID0gdGhpcy55QXhpcyxcbiAgICAgICAgICAgIGEgPSBmLnN0YWNrcyxcbiAgICAgICAgICAgIGwgPSBmLm9sZFN0YWNrcyxcbiAgICAgICAgICAgIHYsXG4gICAgICAgICAgICB6O1xuICAgICAgICBmLnN0YWNrc1RvdWNoZWQgKz0gMTtcblxuICAgICAgICBmb3IgKHogPSAwOyB6IDwgaDsgeisrKSB7XG4gICAgICAgICAgdmFyIHcgPSBnW3pdO1xuICAgICAgICAgIHZhciBCID0gdFt6XTtcbiAgICAgICAgICB2YXIgTCA9IHRoaXMuZ2V0U3RhY2tJbmRpY2F0b3IoTCwgdywgdGhpcy5pbmRleCk7XG4gICAgICAgICAgdmFyIFEgPSBMLmtleTtcbiAgICAgICAgICB2YXIgSCA9ICh2ID0gbiAmJiBCIDwgKEcgPyAwIDogcSkpID8gayA6IGM7XG4gICAgICAgICAgYVtIXSB8fCAoYVtIXSA9IHt9KTtcbiAgICAgICAgICBhW0hdW3ddIHx8IChsW0hdICYmIGxbSF1bd10gPyAoYVtIXVt3XSA9IGxbSF1bd10sIGFbSF1bd10udG90YWwgPSBudWxsKSA6IGFbSF1bd10gPSBuZXcgZC5TdGFja0l0ZW0oZiwgZi5vcHRpb25zLnN0YWNrTGFiZWxzLCB2LCB3LCBlKSk7XG4gICAgICAgICAgSCA9IGFbSF1bd107XG4gICAgICAgICAgbnVsbCAhPT0gQiA/IChILnBvaW50c1tRXSA9IEgucG9pbnRzW3RoaXMuaW5kZXhdID0gW0EoSC5jdW11bGF0aXZlLCBHKV0sIHUoSC5jdW11bGF0aXZlKSB8fCAoSC5iYXNlID0gUSksIEgudG91Y2hlZCA9IGYuc3RhY2tzVG91Y2hlZCwgMCA8IEwuaW5kZXggJiYgITEgPT09IHRoaXMuc2luZ2xlU3RhY2tzICYmIChILnBvaW50c1tRXVswXSA9IEgucG9pbnRzW3RoaXMuaW5kZXggKyBcIixcIiArIHcgKyBcIiwwXCJdWzBdKSkgOiBILnBvaW50c1tRXSA9IEgucG9pbnRzW3RoaXMuaW5kZXhdID0gbnVsbDtcbiAgICAgICAgICBcInBlcmNlbnRcIiA9PT0gTiA/ICh2ID0gdiA/IGMgOiBrLCBuICYmIGFbdl0gJiYgYVt2XVt3XSA/ICh2ID0gYVt2XVt3XSwgSC50b3RhbCA9IHYudG90YWwgPSBNYXRoLm1heCh2LnRvdGFsLCBILnRvdGFsKSArIE1hdGguYWJzKEIpIHx8IDApIDogSC50b3RhbCA9IHIoSC50b3RhbCArIChNYXRoLmFicyhCKSB8fCAwKSkpIDogSC50b3RhbCA9IHIoSC50b3RhbCArIChCIHx8IDApKTtcbiAgICAgICAgICBILmN1bXVsYXRpdmUgPSBBKEguY3VtdWxhdGl2ZSwgRykgKyAoQiB8fCAwKTtcbiAgICAgICAgICBudWxsICE9PSBCICYmIChILnBvaW50c1tRXS5wdXNoKEguY3VtdWxhdGl2ZSksIERbel0gPSBILmN1bXVsYXRpdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgXCJwZXJjZW50XCIgPT09IE4gJiYgKGYudXNlUGVyY2VudGFnZSA9ICEwKTtcbiAgICAgICAgdGhpcy5zdGFja2VkWURhdGEgPSBEO1xuICAgICAgICBmLm9sZFN0YWNrcyA9IHt9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBKLnByb3RvdHlwZS5tb2RpZnlTdGFja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgZyA9IGQuc3RhY2tLZXksXG4gICAgICAgICAgciA9IGQueUF4aXMuc3RhY2tzLFxuICAgICAgICAgIGggPSBkLnByb2Nlc3NlZFhEYXRhLFxuICAgICAgICAgIHUsXG4gICAgICAgICAgcSA9IGQub3B0aW9ucy5zdGFja2luZztcbiAgICAgIGRbcSArIFwiU3RhY2tlclwiXSAmJiBbZywgXCItXCIgKyBnXS5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIGZvciAodmFyIGUgPSBoLmxlbmd0aCwgYywgazsgZS0tOykgaWYgKGMgPSBoW2VdLCB1ID0gZC5nZXRTdGFja0luZGljYXRvcih1LCBjLCBkLmluZGV4LCBnKSwgayA9IChjID0gcltnXSAmJiByW2ddW2NdKSAmJiBjLnBvaW50c1t1LmtleV0pIGRbcSArIFwiU3RhY2tlclwiXShrLCBjLCBlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBKLnByb3RvdHlwZS5wZXJjZW50U3RhY2tlciA9IGZ1bmN0aW9uIChkLCBnLCB1KSB7XG4gICAgICBnID0gZy50b3RhbCA/IDEwMCAvIGcudG90YWwgOiAwO1xuICAgICAgZFswXSA9IHIoZFswXSAqIGcpO1xuICAgICAgZFsxXSA9IHIoZFsxXSAqIGcpO1xuICAgICAgdGhpcy5zdGFja2VkWURhdGFbdV0gPSBkWzFdO1xuICAgIH07XG5cbiAgICBKLnByb3RvdHlwZS5nZXRTdGFja0luZGljYXRvciA9IGZ1bmN0aW9uIChkLCBnLCByLCBoKSB7XG4gICAgICAhdShkKSB8fCBkLnggIT09IGcgfHwgaCAmJiBkLmtleSAhPT0gaCA/IGQgPSB7XG4gICAgICAgIHg6IGcsXG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBrZXk6IGhcbiAgICAgIH0gOiBkLmluZGV4Kys7XG4gICAgICBkLmtleSA9IFtyLCBnLCBkLmluZGV4XS5qb2luKCk7XG4gICAgICByZXR1cm4gZDtcbiAgICB9O1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL0R5bmFtaWNzLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1BvaW50LmpzXCJdLCByW1wicGFydHMvVGltZS5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnLCByLCB1KSB7XG4gICAgdmFyIEkgPSB1LmFkZEV2ZW50LFxuICAgICAgICBNID0gdS5hbmltYXRlLFxuICAgICAgICBFID0gdS5jcmVhdGVFbGVtZW50LFxuICAgICAgICBBID0gdS5jc3MsXG4gICAgICAgIEcgPSB1LmRlZmluZWQsXG4gICAgICAgIEogPSB1LmVyYXNlLFxuICAgICAgICB5ID0gdS5lcnJvcixcbiAgICAgICAgdCA9IHUuZXh0ZW5kLFxuICAgICAgICBEID0gdS5maXJlRXZlbnQsXG4gICAgICAgIGggPSB1LmlzQXJyYXksXG4gICAgICAgIE4gPSB1LmlzTnVtYmVyLFxuICAgICAgICBxID0gdS5pc09iamVjdCxcbiAgICAgICAgUCA9IHUuaXNTdHJpbmcsXG4gICAgICAgIGUgPSB1Lm1lcmdlLFxuICAgICAgICBjID0gdS5vYmplY3RFYWNoLFxuICAgICAgICBrID0gdS5waWNrLFxuICAgICAgICBuID0gdS5yZWxhdGl2ZUxlbmd0aCxcbiAgICAgICAgZiA9IHUuc2V0QW5pbWF0aW9uLFxuICAgICAgICBhID0gdS5zcGxhdCxcbiAgICAgICAgbCA9IGQuQXhpcztcbiAgICB1ID0gZC5DaGFydDtcbiAgICB2YXIgdiA9IGQuU2VyaWVzLFxuICAgICAgICB6ID0gZC5zZXJpZXNUeXBlcztcblxuICAgIGQuY2xlYW5SZWN1cnNpdmVseSA9IGZ1bmN0aW9uIChhLCBlKSB7XG4gICAgICB2YXIgZiA9IHt9O1xuICAgICAgYyhhLCBmdW5jdGlvbiAoYywgaykge1xuICAgICAgICBpZiAocShhW2tdLCAhMCkgJiYgIWEubm9kZVR5cGUgJiYgZVtrXSkgYyA9IGQuY2xlYW5SZWN1cnNpdmVseShhW2tdLCBlW2tdKSwgT2JqZWN0LmtleXMoYykubGVuZ3RoICYmIChmW2tdID0gYyk7ZWxzZSBpZiAocShhW2tdKSB8fCBhW2tdICE9PSBlW2tdKSBmW2tdID0gYVtrXTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGY7XG4gICAgfTtcblxuICAgIHQodS5wcm90b3R5cGUsIHtcbiAgICAgIGFkZFNlcmllczogZnVuY3Rpb24gKGEsIGMsIGUpIHtcbiAgICAgICAgdmFyIGYsXG4gICAgICAgICAgICBkID0gdGhpcztcbiAgICAgICAgYSAmJiAoYyA9IGsoYywgITApLCBEKGQsIFwiYWRkU2VyaWVzXCIsIHtcbiAgICAgICAgICBvcHRpb25zOiBhXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmID0gZC5pbml0U2VyaWVzKGEpO1xuICAgICAgICAgIGQuaXNEaXJ0eUxlZ2VuZCA9ICEwO1xuICAgICAgICAgIGQubGlua1NlcmllcygpO1xuICAgICAgICAgIGYuZW5hYmxlZERhdGFTb3J0aW5nICYmIGYuc2V0RGF0YShhLmRhdGEsICExKTtcbiAgICAgICAgICBEKGQsIFwiYWZ0ZXJBZGRTZXJpZXNcIiwge1xuICAgICAgICAgICAgc2VyaWVzOiBmXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYyAmJiBkLnJlZHJhdyhlKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH0sXG4gICAgICBhZGRBeGlzOiBmdW5jdGlvbiAoYSwgYywgZSwgZikge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVBeGlzKGMgPyBcInhBeGlzXCIgOiBcInlBeGlzXCIsIHtcbiAgICAgICAgICBheGlzOiBhLFxuICAgICAgICAgIHJlZHJhdzogZSxcbiAgICAgICAgICBhbmltYXRpb246IGZcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgYWRkQ29sb3JBeGlzOiBmdW5jdGlvbiAoYSwgYywgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVBeGlzKFwiY29sb3JBeGlzXCIsIHtcbiAgICAgICAgICBheGlzOiBhLFxuICAgICAgICAgIHJlZHJhdzogYyxcbiAgICAgICAgICBhbmltYXRpb246IGVcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgY3JlYXRlQXhpczogZnVuY3Rpb24gKGMsIGYpIHtcbiAgICAgICAgdmFyIGggPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBnID0gXCJjb2xvckF4aXNcIiA9PT0gYyxcbiAgICAgICAgICAgIG4gPSBmLnJlZHJhdyxcbiAgICAgICAgICAgIHcgPSBmLmFuaW1hdGlvbjtcbiAgICAgICAgZiA9IGUoZi5heGlzLCB7XG4gICAgICAgICAgaW5kZXg6IHRoaXNbY10ubGVuZ3RoLFxuICAgICAgICAgIGlzWDogXCJ4QXhpc1wiID09PSBjXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcCA9IGcgPyBuZXcgZC5Db2xvckF4aXModGhpcywgZikgOiBuZXcgbCh0aGlzLCBmKTtcbiAgICAgICAgaFtjXSA9IGEoaFtjXSB8fCB7fSk7XG4gICAgICAgIGhbY10ucHVzaChmKTtcbiAgICAgICAgZyAmJiAodGhpcy5pc0RpcnR5TGVnZW5kID0gITAsIHRoaXMuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYS5zZXJpZXMgPSBbXTtcbiAgICAgICAgfSksIHRoaXMuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhLmJpbmRBeGVzKCk7XG4gICAgICAgICAgYS5pc0RpcnR5RGF0YSA9ICEwO1xuICAgICAgICB9KSk7XG4gICAgICAgIGsobiwgITApICYmIHRoaXMucmVkcmF3KHcpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH0sXG4gICAgICBzaG93TG9hZGluZzogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLFxuICAgICAgICAgICAgZSA9IGMub3B0aW9ucyxcbiAgICAgICAgICAgIGYgPSBjLmxvYWRpbmdEaXYsXG4gICAgICAgICAgICBkID0gZS5sb2FkaW5nLFxuICAgICAgICAgICAgaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmICYmIEEoZiwge1xuICAgICAgICAgICAgbGVmdDogYy5wbG90TGVmdCArIFwicHhcIixcbiAgICAgICAgICAgIHRvcDogYy5wbG90VG9wICsgXCJweFwiLFxuICAgICAgICAgICAgd2lkdGg6IGMucGxvdFdpZHRoICsgXCJweFwiLFxuICAgICAgICAgICAgaGVpZ2h0OiBjLnBsb3RIZWlnaHQgKyBcInB4XCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmIHx8IChjLmxvYWRpbmdEaXYgPSBmID0gRShcImRpdlwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImhpZ2hjaGFydHMtbG9hZGluZyBoaWdoY2hhcnRzLWxvYWRpbmctaGlkZGVuXCJcbiAgICAgICAgfSwgbnVsbCwgYy5jb250YWluZXIpLCBjLmxvYWRpbmdTcGFuID0gRShcInNwYW5cIiwge1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJoaWdoY2hhcnRzLWxvYWRpbmctaW5uZXJcIlxuICAgICAgICB9LCBudWxsLCBmKSwgSShjLCBcInJlZHJhd1wiLCBoKSk7XG4gICAgICAgIGYuY2xhc3NOYW1lID0gXCJoaWdoY2hhcnRzLWxvYWRpbmdcIjtcbiAgICAgICAgYy5sb2FkaW5nU3Bhbi5pbm5lckhUTUwgPSBrKGEsIGUubGFuZy5sb2FkaW5nLCBcIlwiKTtcbiAgICAgICAgYy5zdHlsZWRNb2RlIHx8IChBKGYsIHQoZC5zdHlsZSwge1xuICAgICAgICAgIHpJbmRleDogMTBcbiAgICAgICAgfSkpLCBBKGMubG9hZGluZ1NwYW4sIGQubGFiZWxTdHlsZSksIGMubG9hZGluZ1Nob3duIHx8IChBKGYsIHtcbiAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgIGRpc3BsYXk6IFwiXCJcbiAgICAgICAgfSksIE0oZiwge1xuICAgICAgICAgIG9wYWNpdHk6IGQuc3R5bGUub3BhY2l0eSB8fCAuNVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IGQuc2hvd0R1cmF0aW9uIHx8IDBcbiAgICAgICAgfSkpKTtcbiAgICAgICAgYy5sb2FkaW5nU2hvd24gPSAhMDtcbiAgICAgICAgaCgpO1xuICAgICAgfSxcbiAgICAgIGhpZGVMb2FkaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgYyA9IHRoaXMubG9hZGluZ0RpdjtcbiAgICAgICAgYyAmJiAoYy5jbGFzc05hbWUgPSBcImhpZ2hjaGFydHMtbG9hZGluZyBoaWdoY2hhcnRzLWxvYWRpbmctaGlkZGVuXCIsIHRoaXMuc3R5bGVkTW9kZSB8fCBNKGMsIHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogYS5sb2FkaW5nLmhpZGVEdXJhdGlvbiB8fCAxMDAsXG4gICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIEEoYywge1xuICAgICAgICAgICAgICBkaXNwbGF5OiBcIm5vbmVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMubG9hZGluZ1Nob3duID0gITE7XG4gICAgICB9LFxuICAgICAgcHJvcHNSZXF1aXJlRGlydHlCb3g6IFwiYmFja2dyb3VuZENvbG9yIGJvcmRlckNvbG9yIGJvcmRlcldpZHRoIGJvcmRlclJhZGl1cyBwbG90QmFja2dyb3VuZENvbG9yIHBsb3RCYWNrZ3JvdW5kSW1hZ2UgcGxvdEJvcmRlckNvbG9yIHBsb3RCb3JkZXJXaWR0aCBwbG90U2hhZG93IHNoYWRvd1wiLnNwbGl0KFwiIFwiKSxcbiAgICAgIHByb3BzUmVxdWlyZVJlZmxvdzogXCJtYXJnaW4gbWFyZ2luVG9wIG1hcmdpblJpZ2h0IG1hcmdpbkJvdHRvbSBtYXJnaW5MZWZ0IHNwYWNpbmcgc3BhY2luZ1RvcCBzcGFjaW5nUmlnaHQgc3BhY2luZ0JvdHRvbSBzcGFjaW5nTGVmdFwiLnNwbGl0KFwiIFwiKSxcbiAgICAgIHByb3BzUmVxdWlyZVVwZGF0ZVNlcmllczogXCJjaGFydC5pbnZlcnRlZCBjaGFydC5wb2xhciBjaGFydC5pZ25vcmVIaWRkZW5TZXJpZXMgY2hhcnQudHlwZSBjb2xvcnMgcGxvdE9wdGlvbnMgdGltZSB0b29sdGlwXCIuc3BsaXQoXCIgXCIpLFxuICAgICAgY29sbGVjdGlvbnNXaXRoVXBkYXRlOiBbXCJ4QXhpc1wiLCBcInlBeGlzXCIsIFwiekF4aXNcIiwgXCJzZXJpZXNcIl0sXG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIChmLCBoLCBsLCBnKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcyxcbiAgICAgICAgICAgIHcgPSB7XG4gICAgICAgICAgY3JlZGl0czogXCJhZGRDcmVkaXRzXCIsXG4gICAgICAgICAgdGl0bGU6IFwic2V0VGl0bGVcIixcbiAgICAgICAgICBzdWJ0aXRsZTogXCJzZXRTdWJ0aXRsZVwiLFxuICAgICAgICAgIGNhcHRpb246IFwic2V0Q2FwdGlvblwiXG4gICAgICAgIH0sXG4gICAgICAgICAgICBwLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIHEsXG4gICAgICAgICAgICB0ID0gZi5pc1Jlc3BvbnNpdmVPcHRpb25zLFxuICAgICAgICAgICAgeiA9IFtdO1xuICAgICAgICBEKHYsIFwidXBkYXRlXCIsIHtcbiAgICAgICAgICBvcHRpb25zOiBmXG4gICAgICAgIH0pO1xuICAgICAgICB0IHx8IHYuc2V0UmVzcG9uc2l2ZSghMSwgITApO1xuICAgICAgICBmID0gZC5jbGVhblJlY3Vyc2l2ZWx5KGYsIHYub3B0aW9ucyk7XG4gICAgICAgIGUoITAsIHYudXNlck9wdGlvbnMsIGYpO1xuXG4gICAgICAgIGlmIChwID0gZi5jaGFydCkge1xuICAgICAgICAgIGUoITAsIHYub3B0aW9ucy5jaGFydCwgcCk7XG4gICAgICAgICAgXCJjbGFzc05hbWVcIiBpbiBwICYmIHYuc2V0Q2xhc3NOYW1lKHAuY2xhc3NOYW1lKTtcbiAgICAgICAgICBcInJlZmxvd1wiIGluIHAgJiYgdi5zZXRSZWZsb3cocC5yZWZsb3cpO1xuXG4gICAgICAgICAgaWYgKFwiaW52ZXJ0ZWRcIiBpbiBwIHx8IFwicG9sYXJcIiBpbiBwIHx8IFwidHlwZVwiIGluIHApIHtcbiAgICAgICAgICAgIHYucHJvcEZyb21TZXJpZXMoKTtcbiAgICAgICAgICAgIHZhciBCID0gITA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgXCJhbGlnblRpY2tzXCIgaW4gcCAmJiAoQiA9ICEwKTtcbiAgICAgICAgICBjKHAsIGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgICAgICAtMSAhPT0gdi5wcm9wc1JlcXVpcmVVcGRhdGVTZXJpZXMuaW5kZXhPZihcImNoYXJ0LlwiICsgYykgJiYgKGIgPSAhMCk7XG4gICAgICAgICAgICAtMSAhPT0gdi5wcm9wc1JlcXVpcmVEaXJ0eUJveC5pbmRleE9mKGMpICYmICh2LmlzRGlydHlCb3ggPSAhMCk7XG4gICAgICAgICAgICB0IHx8IC0xID09PSB2LnByb3BzUmVxdWlyZVJlZmxvdy5pbmRleE9mKGMpIHx8IChxID0gITApO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgICF2LnN0eWxlZE1vZGUgJiYgXCJzdHlsZVwiIGluIHAgJiYgdi5yZW5kZXJlci5zZXRTdHlsZShwLnN0eWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgICF2LnN0eWxlZE1vZGUgJiYgZi5jb2xvcnMgJiYgKHRoaXMub3B0aW9ucy5jb2xvcnMgPSBmLmNvbG9ycyk7XG4gICAgICAgIGYucGxvdE9wdGlvbnMgJiYgZSghMCwgdGhpcy5vcHRpb25zLnBsb3RPcHRpb25zLCBmLnBsb3RPcHRpb25zKTtcbiAgICAgICAgZi50aW1lICYmIHRoaXMudGltZSA9PT0gZC50aW1lICYmICh0aGlzLnRpbWUgPSBuZXcgcihmLnRpbWUpKTtcbiAgICAgICAgYyhmLCBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICAgIGlmICh2W2NdICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZbY10udXBkYXRlKSB2W2NdLnVwZGF0ZShhLCAhMSk7ZWxzZSBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygdlt3W2NdXSkgdlt3W2NdXShhKTtcbiAgICAgICAgICBcImNoYXJ0XCIgIT09IGMgJiYgLTEgIT09IHYucHJvcHNSZXF1aXJlVXBkYXRlU2VyaWVzLmluZGV4T2YoYykgJiYgKGIgPSAhMCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25zV2l0aFVwZGF0ZS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgaWYgKGZbYl0pIHtcbiAgICAgICAgICAgIGlmIChcInNlcmllc1wiID09PSBiKSB7XG4gICAgICAgICAgICAgIHZhciBjID0gW107XG4gICAgICAgICAgICAgIHZbYl0uZm9yRWFjaChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIGEub3B0aW9ucy5pc0ludGVybmFsIHx8IGMucHVzaChrKGEub3B0aW9ucy5pbmRleCwgYikpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYShmW2JdKS5mb3JFYWNoKGZ1bmN0aW9uIChhLCBlKSB7XG4gICAgICAgICAgICAgIChlID0gRyhhLmlkKSAmJiB2LmdldChhLmlkKSB8fCB2W2JdW2MgPyBjW2VdIDogZV0pICYmIGUuY29sbCA9PT0gYiAmJiAoZS51cGRhdGUoYSwgITEpLCBsICYmIChlLnRvdWNoZWQgPSAhMCkpO1xuICAgICAgICAgICAgICAhZSAmJiBsICYmIHYuY29sbGVjdGlvbnNXaXRoSW5pdFtiXSAmJiAodi5jb2xsZWN0aW9uc1dpdGhJbml0W2JdWzBdLmFwcGx5KHYsIFthXS5jb25jYXQodi5jb2xsZWN0aW9uc1dpdGhJbml0W2JdWzFdIHx8IFtdKS5jb25jYXQoWyExXSkpLnRvdWNoZWQgPSAhMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGwgJiYgdltiXS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgIGEudG91Y2hlZCB8fCBhLm9wdGlvbnMuaXNJbnRlcm5hbCA/IGRlbGV0ZSBhLnRvdWNoZWQgOiB6LnB1c2goYSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB6LmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhLnJlbW92ZSAmJiBhLnJlbW92ZSghMSk7XG4gICAgICAgIH0pO1xuICAgICAgICBCICYmIHYuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYS51cGRhdGUoe30sICExKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGIgJiYgdi5nZXRTZXJpZXNPcmRlckJ5TGlua3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYS5jaGFydCAmJiBhLnVwZGF0ZSh7fSwgITEpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgZi5sb2FkaW5nICYmIGUoITAsIHYub3B0aW9ucy5sb2FkaW5nLCBmLmxvYWRpbmcpO1xuICAgICAgICBCID0gcCAmJiBwLndpZHRoO1xuICAgICAgICBwID0gcCAmJiBwLmhlaWdodDtcbiAgICAgICAgUChwKSAmJiAocCA9IG4ocCwgQiB8fCB2LmNoYXJ0V2lkdGgpKTtcbiAgICAgICAgcSB8fCBOKEIpICYmIEIgIT09IHYuY2hhcnRXaWR0aCB8fCBOKHApICYmIHAgIT09IHYuY2hhcnRIZWlnaHQgPyB2LnNldFNpemUoQiwgcCwgZykgOiBrKGgsICEwKSAmJiB2LnJlZHJhdyhnKTtcbiAgICAgICAgRCh2LCBcImFmdGVyVXBkYXRlXCIsIHtcbiAgICAgICAgICBvcHRpb25zOiBmLFxuICAgICAgICAgIHJlZHJhdzogaCxcbiAgICAgICAgICBhbmltYXRpb246IGdcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc2V0U3VidGl0bGU6IGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgIHRoaXMuYXBwbHlEZXNjcmlwdGlvbihcInN1YnRpdGxlXCIsIGEpO1xuICAgICAgICB0aGlzLmxheU91dFRpdGxlcyhjKTtcbiAgICAgIH0sXG4gICAgICBzZXRDYXB0aW9uOiBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICB0aGlzLmFwcGx5RGVzY3JpcHRpb24oXCJjYXB0aW9uXCIsIGEpO1xuICAgICAgICB0aGlzLmxheU91dFRpdGxlcyhjKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1LnByb3RvdHlwZS5jb2xsZWN0aW9uc1dpdGhJbml0ID0ge1xuICAgICAgeEF4aXM6IFt1LnByb3RvdHlwZS5hZGRBeGlzLCBbITBdXSxcbiAgICAgIHlBeGlzOiBbdS5wcm90b3R5cGUuYWRkQXhpcywgWyExXV0sXG4gICAgICBzZXJpZXM6IFt1LnByb3RvdHlwZS5hZGRTZXJpZXNdXG4gICAgfTtcbiAgICB0KGcucHJvdG90eXBlLCB7XG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIChhLCBjLCBlLCBmKSB7XG4gICAgICAgIGZ1bmN0aW9uIGQoKSB7XG4gICAgICAgICAgaC5hcHBseU9wdGlvbnMoYSk7XG4gICAgICAgICAgdmFyIGYgPSBiICYmIGguaGFzRHVtbXlHcmFwaGljO1xuICAgICAgICAgIGYgPSBudWxsID09PSBoLnkgPyAhZiA6IGY7XG4gICAgICAgICAgYiAmJiBmICYmIChoLmdyYXBoaWMgPSBiLmRlc3Ryb3koKSwgZGVsZXRlIGguaGFzRHVtbXlHcmFwaGljKTtcbiAgICAgICAgICBxKGEsICEwKSAmJiAoYiAmJiBiLmVsZW1lbnQgJiYgYSAmJiBhLm1hcmtlciAmJiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYS5tYXJrZXIuc3ltYm9sICYmIChoLmdyYXBoaWMgPSBiLmRlc3Ryb3koKSksIGEgJiYgYS5kYXRhTGFiZWxzICYmIGguZGF0YUxhYmVsICYmIChoLmRhdGFMYWJlbCA9IGguZGF0YUxhYmVsLmRlc3Ryb3koKSksIGguY29ubmVjdG9yICYmIChoLmNvbm5lY3RvciA9IGguY29ubmVjdG9yLmRlc3Ryb3koKSkpO1xuICAgICAgICAgIGcgPSBoLmluZGV4O1xuICAgICAgICAgIGwudXBkYXRlUGFyYWxsZWxBcnJheXMoaCwgZyk7XG4gICAgICAgICAgdi5kYXRhW2ddID0gcSh2LmRhdGFbZ10sICEwKSB8fCBxKGEsICEwKSA/IGgub3B0aW9ucyA6IGsoYSwgdi5kYXRhW2ddKTtcbiAgICAgICAgICBsLmlzRGlydHkgPSBsLmlzRGlydHlEYXRhID0gITA7XG4gICAgICAgICAgIWwuZml4ZWRCb3ggJiYgbC5oYXNDYXJ0ZXNpYW5TZXJpZXMgJiYgKG4uaXNEaXJ0eUJveCA9ICEwKTtcbiAgICAgICAgICBcInBvaW50XCIgPT09IHYubGVnZW5kVHlwZSAmJiAobi5pc0RpcnR5TGVnZW5kID0gITApO1xuICAgICAgICAgIGMgJiYgbi5yZWRyYXcoZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaCA9IHRoaXMsXG4gICAgICAgICAgICBsID0gaC5zZXJpZXMsXG4gICAgICAgICAgICBiID0gaC5ncmFwaGljLFxuICAgICAgICAgICAgZyxcbiAgICAgICAgICAgIG4gPSBsLmNoYXJ0LFxuICAgICAgICAgICAgdiA9IGwub3B0aW9ucztcbiAgICAgICAgYyA9IGsoYywgITApO1xuICAgICAgICAhMSA9PT0gZiA/IGQoKSA6IGguZmlyZVBvaW50RXZlbnQoXCJ1cGRhdGVcIiwge1xuICAgICAgICAgIG9wdGlvbnM6IGFcbiAgICAgICAgfSwgZCk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICB0aGlzLnNlcmllcy5yZW1vdmVQb2ludCh0aGlzLnNlcmllcy5kYXRhLmluZGV4T2YodGhpcyksIGEsIGMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHQodi5wcm90b3R5cGUsIHtcbiAgICAgIGFkZFBvaW50OiBmdW5jdGlvbiAoYSwgYywgZSwgZiwgZCkge1xuICAgICAgICB2YXIgaCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGwgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICBiID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGcgPSB0aGlzLnhBeGlzO1xuICAgICAgICBnID0gZyAmJiBnLmhhc05hbWVzICYmIGcubmFtZXM7XG4gICAgICAgIHZhciBuID0gaC5kYXRhLFxuICAgICAgICAgICAgdiA9IHRoaXMueERhdGEsXG4gICAgICAgICAgICBxO1xuICAgICAgICBjID0gayhjLCAhMCk7XG4gICAgICAgIHZhciB3ID0ge1xuICAgICAgICAgIHNlcmllczogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBvaW50Q2xhc3MucHJvdG90eXBlLmFwcGx5T3B0aW9ucy5hcHBseSh3LCBbYV0pO1xuICAgICAgICB2YXIgdCA9IHcueDtcbiAgICAgICAgdmFyIG0gPSB2Lmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMucmVxdWlyZVNvcnRpbmcgJiYgdCA8IHZbbSAtIDFdKSBmb3IgKHEgPSAhMDsgbSAmJiB2W20gLSAxXSA+IHQ7KSBtLS07XG4gICAgICAgIHRoaXMudXBkYXRlUGFyYWxsZWxBcnJheXModywgXCJzcGxpY2VcIiwgbSwgMCwgMCk7XG4gICAgICAgIHRoaXMudXBkYXRlUGFyYWxsZWxBcnJheXModywgbSk7XG4gICAgICAgIGcgJiYgdy5uYW1lICYmIChnW3RdID0gdy5uYW1lKTtcbiAgICAgICAgbi5zcGxpY2UobSwgMCwgYSk7XG4gICAgICAgIHEgJiYgKHRoaXMuZGF0YS5zcGxpY2UobSwgMCwgbnVsbCksIHRoaXMucHJvY2Vzc0RhdGEoKSk7XG4gICAgICAgIFwicG9pbnRcIiA9PT0gaC5sZWdlbmRUeXBlICYmIHRoaXMuZ2VuZXJhdGVQb2ludHMoKTtcbiAgICAgICAgZSAmJiAobFswXSAmJiBsWzBdLnJlbW92ZSA/IGxbMF0ucmVtb3ZlKCExKSA6IChsLnNoaWZ0KCksIHRoaXMudXBkYXRlUGFyYWxsZWxBcnJheXModywgXCJzaGlmdFwiKSwgbi5zaGlmdCgpKSk7XG4gICAgICAgICExICE9PSBkICYmIEQodGhpcywgXCJhZGRQb2ludFwiLCB7XG4gICAgICAgICAgcG9pbnQ6IHdcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaXNEaXJ0eURhdGEgPSB0aGlzLmlzRGlydHkgPSAhMDtcbiAgICAgICAgYyAmJiBiLnJlZHJhdyhmKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVQb2ludDogZnVuY3Rpb24gKGEsIGMsIGUpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgICAgaCA9IGQuZGF0YSxcbiAgICAgICAgICAgIGwgPSBoW2FdLFxuICAgICAgICAgICAgZyA9IGQucG9pbnRzLFxuICAgICAgICAgICAgYiA9IGQuY2hhcnQsXG4gICAgICAgICAgICBuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGcgJiYgZy5sZW5ndGggPT09IGgubGVuZ3RoICYmIGcuc3BsaWNlKGEsIDEpO1xuICAgICAgICAgIGguc3BsaWNlKGEsIDEpO1xuICAgICAgICAgIGQub3B0aW9ucy5kYXRhLnNwbGljZShhLCAxKTtcbiAgICAgICAgICBkLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKGwgfHwge1xuICAgICAgICAgICAgc2VyaWVzOiBkXG4gICAgICAgICAgfSwgXCJzcGxpY2VcIiwgYSwgMSk7XG4gICAgICAgICAgbCAmJiBsLmRlc3Ryb3koKTtcbiAgICAgICAgICBkLmlzRGlydHkgPSAhMDtcbiAgICAgICAgICBkLmlzRGlydHlEYXRhID0gITA7XG4gICAgICAgICAgYyAmJiBiLnJlZHJhdygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGYoZSwgYik7XG4gICAgICAgIGMgPSBrKGMsICEwKTtcbiAgICAgICAgbCA/IGwuZmlyZVBvaW50RXZlbnQoXCJyZW1vdmVcIiwgbnVsbCwgbikgOiBuKCk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoYSwgYywgZSwgZikge1xuICAgICAgICBmdW5jdGlvbiBkKCkge1xuICAgICAgICAgIGguZGVzdHJveShmKTtcbiAgICAgICAgICBoLnJlbW92ZSA9IG51bGw7XG4gICAgICAgICAgbC5pc0RpcnR5TGVnZW5kID0gbC5pc0RpcnR5Qm94ID0gITA7XG4gICAgICAgICAgbC5saW5rU2VyaWVzKCk7XG4gICAgICAgICAgayhhLCAhMCkgJiYgbC5yZWRyYXcoYyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaCA9IHRoaXMsXG4gICAgICAgICAgICBsID0gaC5jaGFydDtcbiAgICAgICAgITEgIT09IGUgPyBEKGgsIFwicmVtb3ZlXCIsIG51bGwsIGQpIDogZCgpO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgYSA9IGQuY2xlYW5SZWN1cnNpdmVseShhLCB0aGlzLnVzZXJPcHRpb25zKTtcbiAgICAgICAgRCh0aGlzLCBcInVwZGF0ZVwiLCB7XG4gICAgICAgICAgb3B0aW9uczogYVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGYgPSB0aGlzLFxuICAgICAgICAgICAgaCA9IGYuY2hhcnQsXG4gICAgICAgICAgICBsID0gZi51c2VyT3B0aW9ucyxcbiAgICAgICAgICAgIGcgPSBmLmluaXRpYWxUeXBlIHx8IGYudHlwZSxcbiAgICAgICAgICAgIG4gPSBhLnR5cGUgfHwgbC50eXBlIHx8IGgub3B0aW9ucy5jaGFydC50eXBlLFxuICAgICAgICAgICAgYiA9ICEodGhpcy5oYXNEZXJpdmVkRGF0YSB8fCBhLmRhdGFHcm91cGluZyB8fCBuICYmIG4gIT09IHRoaXMudHlwZSB8fCBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYS5wb2ludFN0YXJ0IHx8IGEucG9pbnRJbnRlcnZhbCB8fCBhLnBvaW50SW50ZXJ2YWxVbml0IHx8IGEua2V5cyksXG4gICAgICAgICAgICB2ID0geltnXS5wcm90b3R5cGUsXG4gICAgICAgICAgICBxLFxuICAgICAgICAgICAgdyA9IFtcImdyb3VwXCIsIFwibWFya2VyR3JvdXBcIiwgXCJkYXRhTGFiZWxzR3JvdXBcIiwgXCJ0cmFuc2Zvcm1Hcm91cFwiXSxcbiAgICAgICAgICAgIHIgPSBbXCJldmVudE9wdGlvbnNcIiwgXCJuYXZpZ2F0b3JTZXJpZXNcIiwgXCJiYXNlU2VyaWVzXCJdLFxuICAgICAgICAgICAgQiA9IGYuZmluaXNoZWRBbmltYXRpbmcgJiYge1xuICAgICAgICAgIGFuaW1hdGlvbjogITFcbiAgICAgICAgfSxcbiAgICAgICAgICAgIHUgPSB7fTtcbiAgICAgICAgYiAmJiAoci5wdXNoKFwiZGF0YVwiLCBcImlzRGlydHlEYXRhXCIsIFwicG9pbnRzXCIsIFwicHJvY2Vzc2VkWERhdGFcIiwgXCJwcm9jZXNzZWRZRGF0YVwiLCBcInhJbmNyZW1lbnRcIiwgXCJfaGFzUG9pbnRNYXJrZXJzXCIsIFwiX2hhc1BvaW50TGFiZWxzXCIsIFwibWFwTWFwXCIsIFwibWFwRGF0YVwiLCBcIm1pbllcIiwgXCJtYXhZXCIsIFwibWluWFwiLCBcIm1heFhcIiksICExICE9PSBhLnZpc2libGUgJiYgci5wdXNoKFwiYXJlYVwiLCBcImdyYXBoXCIpLCBmLnBhcmFsbGVsQXJyYXlzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICByLnB1c2goYSArIFwiRGF0YVwiKTtcbiAgICAgICAgfSksIGEuZGF0YSAmJiAoYS5kYXRhU29ydGluZyAmJiB0KGYub3B0aW9ucy5kYXRhU29ydGluZywgYS5kYXRhU29ydGluZyksIHRoaXMuc2V0RGF0YShhLmRhdGEsICExKSkpO1xuICAgICAgICBhID0gZShsLCBCLCB7XG4gICAgICAgICAgaW5kZXg6IFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBsLmluZGV4ID8gZi5pbmRleCA6IGwuaW5kZXgsXG4gICAgICAgICAgcG9pbnRTdGFydDogayhsLnBvaW50U3RhcnQsIGYueERhdGFbMF0pXG4gICAgICAgIH0sICFiICYmIHtcbiAgICAgICAgICBkYXRhOiBmLm9wdGlvbnMuZGF0YVxuICAgICAgICB9LCBhKTtcbiAgICAgICAgYiAmJiBhLmRhdGEgJiYgKGEuZGF0YSA9IGYub3B0aW9ucy5kYXRhKTtcbiAgICAgICAgciA9IHcuY29uY2F0KHIpO1xuICAgICAgICByLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICByW2FdID0gZlthXTtcbiAgICAgICAgICBkZWxldGUgZlthXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGYucmVtb3ZlKCExLCBudWxsLCAhMSwgITApO1xuXG4gICAgICAgIGZvciAocSBpbiB2KSBmW3FdID0gdm9pZCAwO1xuXG4gICAgICAgIHpbbiB8fCBnXSA/IHQoZiwgeltuIHx8IGddLnByb3RvdHlwZSkgOiB5KDE3LCAhMCwgaCwge1xuICAgICAgICAgIG1pc3NpbmdNb2R1bGVGb3I6IG4gfHwgZ1xuICAgICAgICB9KTtcbiAgICAgICAgci5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgZlthXSA9IHJbYV07XG4gICAgICAgIH0pO1xuICAgICAgICBmLmluaXQoaCwgYSk7XG5cbiAgICAgICAgaWYgKGIgJiYgdGhpcy5wb2ludHMpIHtcbiAgICAgICAgICB2YXIgbSA9IGYub3B0aW9ucztcbiAgICAgICAgICAhMSA9PT0gbS52aXNpYmxlID8gKHUuZ3JhcGhpYyA9IDEsIHUuZGF0YUxhYmVsID0gMSkgOiBmLl9oYXNQb2ludExhYmVscyB8fCAobiA9IG0ubWFya2VyLCB2ID0gbS5kYXRhTGFiZWxzLCBuICYmICghMSA9PT0gbi5lbmFibGVkIHx8IFwic3ltYm9sXCIgaW4gbikgJiYgKHUuZ3JhcGhpYyA9IDEpLCB2ICYmICExID09PSB2LmVuYWJsZWQgJiYgKHUuZGF0YUxhYmVsID0gMSkpO1xuICAgICAgICAgIHRoaXMucG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGEgJiYgYS5zZXJpZXMgJiYgKGEucmVzb2x2ZUNvbG9yKCksIE9iamVjdC5rZXlzKHUpLmxlbmd0aCAmJiBhLmRlc3Ryb3lFbGVtZW50cyh1KSwgITEgPT09IG0uc2hvd0luTGVnZW5kICYmIGEubGVnZW5kSXRlbSAmJiBoLmxlZ2VuZC5kZXN0cm95SXRlbShhKSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBhLnpJbmRleCAhPT0gbC56SW5kZXggJiYgdy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgZltiXSAmJiBmW2JdLmF0dHIoe1xuICAgICAgICAgICAgekluZGV4OiBhLnpJbmRleFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZi5pbml0aWFsVHlwZSA9IGc7XG4gICAgICAgIGgubGlua1NlcmllcygpO1xuICAgICAgICBEKHRoaXMsIFwiYWZ0ZXJVcGRhdGVcIik7XG4gICAgICAgIGsoYywgITApICYmIGgucmVkcmF3KGIgPyB2b2lkIDAgOiAhMSk7XG4gICAgICB9LFxuICAgICAgc2V0TmFtZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5vcHRpb25zLm5hbWUgPSB0aGlzLnVzZXJPcHRpb25zLm5hbWUgPSBhO1xuICAgICAgICB0aGlzLmNoYXJ0LmlzRGlydHlMZWdlbmQgPSAhMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0KGwucHJvdG90eXBlLCB7XG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIChhLCBmKSB7XG4gICAgICAgIHZhciBkID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGggPSBhICYmIGEuZXZlbnRzIHx8IHt9O1xuICAgICAgICBhID0gZSh0aGlzLnVzZXJPcHRpb25zLCBhKTtcbiAgICAgICAgZC5vcHRpb25zW3RoaXMuY29sbF0uaW5kZXhPZiAmJiAoZC5vcHRpb25zW3RoaXMuY29sbF1bZC5vcHRpb25zW3RoaXMuY29sbF0uaW5kZXhPZih0aGlzLnVzZXJPcHRpb25zKV0gPSBhKTtcbiAgICAgICAgYyhkLm9wdGlvbnNbdGhpcy5jb2xsXS5ldmVudHMsIGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGhbY10gJiYgKGhbY10gPSB2b2lkIDApO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCEwKTtcbiAgICAgICAgdGhpcy5pbml0KGQsIHQoYSwge1xuICAgICAgICAgIGV2ZW50czogaFxuICAgICAgICB9KSk7XG4gICAgICAgIGQuaXNEaXJ0eUJveCA9ICEwO1xuICAgICAgICBrKGYsICEwKSAmJiBkLnJlZHJhdygpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IHRoaXMuY2hhcnQsIGUgPSB0aGlzLmNvbGwsIGYgPSB0aGlzLnNlcmllcywgZCA9IGYubGVuZ3RoOyBkLS07KSBmW2RdICYmIGZbZF0ucmVtb3ZlKCExKTtcblxuICAgICAgICBKKGMuYXhlcywgdGhpcyk7XG4gICAgICAgIEooY1tlXSwgdGhpcyk7XG4gICAgICAgIGgoYy5vcHRpb25zW2VdKSA/IGMub3B0aW9uc1tlXS5zcGxpY2UodGhpcy5vcHRpb25zLmluZGV4LCAxKSA6IGRlbGV0ZSBjLm9wdGlvbnNbZV07XG4gICAgICAgIGNbZV0uZm9yRWFjaChmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICAgIGEub3B0aW9ucy5pbmRleCA9IGEudXNlck9wdGlvbnMuaW5kZXggPSBjO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIGMuaXNEaXJ0eUJveCA9ICEwO1xuICAgICAgICBrKGEsICEwKSAmJiBjLnJlZHJhdygpO1xuICAgICAgfSxcbiAgICAgIHNldFRpdGxlOiBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgdGl0bGU6IGFcbiAgICAgICAgfSwgYyk7XG4gICAgICB9LFxuICAgICAgc2V0Q2F0ZWdvcmllczogZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgIGNhdGVnb3JpZXM6IGFcbiAgICAgICAgfSwgYyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvQXJlYVNlcmllcy5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9Db2xvci5qc1wiXSwgcltcIm1peGlucy9sZWdlbmQtc3ltYm9sLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcsIHIsIHUpIHtcbiAgICB2YXIgSSA9IGcucGFyc2UsXG4gICAgICAgIE0gPSB1Lm9iamVjdEVhY2gsXG4gICAgICAgIEUgPSB1LnBpY2s7XG4gICAgZyA9IHUuc2VyaWVzVHlwZTtcbiAgICB2YXIgQSA9IGQuU2VyaWVzO1xuICAgIGcoXCJhcmVhXCIsIFwibGluZVwiLCB7XG4gICAgICBzb2Z0VGhyZXNob2xkOiAhMSxcbiAgICAgIHRocmVzaG9sZDogMFxuICAgIH0sIHtcbiAgICAgIHNpbmdsZVN0YWNrczogITEsXG4gICAgICBnZXRTdGFja1BvaW50czogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIGcgPSBbXSxcbiAgICAgICAgICAgIHIgPSBbXSxcbiAgICAgICAgICAgIHQgPSB0aGlzLnhBeGlzLFxuICAgICAgICAgICAgdSA9IHRoaXMueUF4aXMsXG4gICAgICAgICAgICBoID0gdS5zdGFja3NbdGhpcy5zdGFja0tleV0sXG4gICAgICAgICAgICBBID0ge30sXG4gICAgICAgICAgICBxID0gdGhpcy5pbmRleCxcbiAgICAgICAgICAgIEcgPSB1LnNlcmllcyxcbiAgICAgICAgICAgIGUgPSBHLmxlbmd0aCxcbiAgICAgICAgICAgIGMgPSBFKHUub3B0aW9ucy5yZXZlcnNlZFN0YWNrcywgITApID8gMSA6IC0xLFxuICAgICAgICAgICAgaztcbiAgICAgICAgZCA9IGQgfHwgdGhpcy5wb2ludHM7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFja2luZykge1xuICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBkLmxlbmd0aDsgaysrKSBkW2tdLmxlZnROdWxsID0gZFtrXS5yaWdodE51bGwgPSB2b2lkIDAsIEFbZFtrXS54XSA9IGRba107XG5cbiAgICAgICAgICBNKGgsIGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgICAgICBudWxsICE9PSBjLnRvdGFsICYmIHIucHVzaChhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByLnNvcnQoZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgICAgIHJldHVybiBjIC0gYTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgbiA9IEcubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gYy52aXNpYmxlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHIuZm9yRWFjaChmdW5jdGlvbiAoZiwgYSkge1xuICAgICAgICAgICAgdmFyIGQgPSAwLFxuICAgICAgICAgICAgICAgIHYsXG4gICAgICAgICAgICAgICAgejtcbiAgICAgICAgICAgIGlmIChBW2ZdICYmICFBW2ZdLmlzTnVsbCkgZy5wdXNoKEFbZl0pLCBbLTEsIDFdLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgdmFyIGwgPSAxID09PSBkID8gXCJyaWdodE51bGxcIiA6IFwibGVmdE51bGxcIixcbiAgICAgICAgICAgICAgICAgIGcgPSAwLFxuICAgICAgICAgICAgICAgICAgdyA9IGhbclthICsgZF1dO1xuICAgICAgICAgICAgICBpZiAodykgZm9yIChrID0gcTsgMCA8PSBrICYmIGsgPCBlOykgdiA9IHcucG9pbnRzW2tdLCB2IHx8IChrID09PSBxID8gQVtmXVtsXSA9ICEwIDogbltrXSAmJiAoeiA9IGhbZl0ucG9pbnRzW2tdKSAmJiAoZyAtPSB6WzFdIC0gelswXSkpLCBrICs9IGM7XG4gICAgICAgICAgICAgIEFbZl1bMSA9PT0gZCA/IFwicmlnaHRDbGlmZlwiIDogXCJsZWZ0Q2xpZmZcIl0gPSBnO1xuICAgICAgICAgICAgfSk7ZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAoayA9IHE7IDAgPD0gayAmJiBrIDwgZTspIHtcbiAgICAgICAgICAgICAgICBpZiAodiA9IGhbZl0ucG9pbnRzW2tdKSB7XG4gICAgICAgICAgICAgICAgICBkID0gdlsxXTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGsgKz0gYztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGQgPSB1LnRyYW5zbGF0ZShkLCAwLCAxLCAwLCAxKTtcbiAgICAgICAgICAgICAgZy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpc051bGw6ICEwLFxuICAgICAgICAgICAgICAgIHBsb3RYOiB0LnRyYW5zbGF0ZShmLCAwLCAwLCAwLCAxKSxcbiAgICAgICAgICAgICAgICB4OiBmLFxuICAgICAgICAgICAgICAgIHBsb3RZOiBkLFxuICAgICAgICAgICAgICAgIHlCb3R0b206IGRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZztcbiAgICAgIH0sXG4gICAgICBnZXRHcmFwaFBhdGg6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBnID0gQS5wcm90b3R5cGUuZ2V0R3JhcGhQYXRoLFxuICAgICAgICAgICAgciA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIHQgPSByLnN0YWNraW5nLFxuICAgICAgICAgICAgdSA9IHRoaXMueUF4aXMsXG4gICAgICAgICAgICBoLFxuICAgICAgICAgICAgTiA9IFtdLFxuICAgICAgICAgICAgcSA9IFtdLFxuICAgICAgICAgICAgRyA9IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICBlID0gdS5zdGFja3NbdGhpcy5zdGFja0tleV0sXG4gICAgICAgICAgICBjID0gci50aHJlc2hvbGQsXG4gICAgICAgICAgICBrID0gTWF0aC5yb3VuZCh1LmdldFRocmVzaG9sZChyLnRocmVzaG9sZCkpO1xuICAgICAgICByID0gRShyLmNvbm5lY3ROdWxscywgXCJwZXJjZW50XCIgPT09IHQpO1xuXG4gICAgICAgIHZhciBuID0gZnVuY3Rpb24gKGYsIGgsIGwpIHtcbiAgICAgICAgICB2YXIgZyA9IGRbZl07XG4gICAgICAgICAgZiA9IHQgJiYgZVtnLnhdLnBvaW50c1tHXTtcbiAgICAgICAgICB2YXIgbiA9IGdbbCArIFwiTnVsbFwiXSB8fCAwO1xuICAgICAgICAgIGwgPSBnW2wgKyBcIkNsaWZmXCJdIHx8IDA7XG4gICAgICAgICAgZyA9ICEwO1xuXG4gICAgICAgICAgaWYgKGwgfHwgbikge1xuICAgICAgICAgICAgdmFyIHYgPSAobiA/IGZbMF0gOiBmWzFdKSArIGw7XG4gICAgICAgICAgICB2YXIgdyA9IGZbMF0gKyBsO1xuICAgICAgICAgICAgZyA9ICEhbjtcbiAgICAgICAgICB9IGVsc2UgIXQgJiYgZFtoXSAmJiBkW2hdLmlzTnVsbCAmJiAodiA9IHcgPSBjKTtcblxuICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiB2ICYmIChxLnB1c2goe1xuICAgICAgICAgICAgcGxvdFg6IGEsXG4gICAgICAgICAgICBwbG90WTogbnVsbCA9PT0gdiA/IGsgOiB1LmdldFRocmVzaG9sZCh2KSxcbiAgICAgICAgICAgIGlzTnVsbDogZyxcbiAgICAgICAgICAgIGlzQ2xpZmY6ICEwXG4gICAgICAgICAgfSksIE4ucHVzaCh7XG4gICAgICAgICAgICBwbG90WDogYSxcbiAgICAgICAgICAgIHBsb3RZOiBudWxsID09PSB3ID8gayA6IHUuZ2V0VGhyZXNob2xkKHcpLFxuICAgICAgICAgICAgZG9DdXJ2ZTogITFcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZCA9IGQgfHwgdGhpcy5wb2ludHM7XG4gICAgICAgIHQgJiYgKGQgPSB0aGlzLmdldFN0YWNrUG9pbnRzKGQpKTtcblxuICAgICAgICBmb3IgKGggPSAwOyBoIDwgZC5sZW5ndGg7IGgrKykge1xuICAgICAgICAgIHQgfHwgKGRbaF0ubGVmdENsaWZmID0gZFtoXS5yaWdodENsaWZmID0gZFtoXS5sZWZ0TnVsbCA9IGRbaF0ucmlnaHROdWxsID0gdm9pZCAwKTtcbiAgICAgICAgICB2YXIgZiA9IGRbaF0uaXNOdWxsO1xuICAgICAgICAgIHZhciBhID0gRShkW2hdLnJlY3RQbG90WCwgZFtoXS5wbG90WCk7XG4gICAgICAgICAgdmFyIGwgPSBFKGRbaF0ueUJvdHRvbSwgayk7XG4gICAgICAgICAgaWYgKCFmIHx8IHIpIHIgfHwgbihoLCBoIC0gMSwgXCJsZWZ0XCIpLCBmICYmICF0ICYmIHIgfHwgKHEucHVzaChkW2hdKSwgTi5wdXNoKHtcbiAgICAgICAgICAgIHg6IGgsXG4gICAgICAgICAgICBwbG90WDogYSxcbiAgICAgICAgICAgIHBsb3RZOiBsXG4gICAgICAgICAgfSkpLCByIHx8IG4oaCwgaCArIDEsIFwicmlnaHRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBoID0gZy5jYWxsKHRoaXMsIHEsICEwLCAhMCk7XG4gICAgICAgIE4ucmV2ZXJzZWQgPSAhMDtcbiAgICAgICAgZiA9IGcuY2FsbCh0aGlzLCBOLCAhMCwgITApO1xuICAgICAgICBmLmxlbmd0aCAmJiAoZlswXSA9IFwiTFwiKTtcbiAgICAgICAgZiA9IGguY29uY2F0KGYpO1xuICAgICAgICBnID0gZy5jYWxsKHRoaXMsIHEsICExLCByKTtcbiAgICAgICAgZi54TWFwID0gaC54TWFwO1xuICAgICAgICB0aGlzLmFyZWFQYXRoID0gZjtcbiAgICAgICAgcmV0dXJuIGc7XG4gICAgICB9LFxuICAgICAgZHJhd0dyYXBoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYXJlYVBhdGggPSBbXTtcbiAgICAgICAgQS5wcm90b3R5cGUuZHJhd0dyYXBoLmFwcGx5KHRoaXMpO1xuICAgICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgICBnID0gdGhpcy5hcmVhUGF0aCxcbiAgICAgICAgICAgIHIgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICB0ID0gW1tcImFyZWFcIiwgXCJoaWdoY2hhcnRzLWFyZWFcIiwgdGhpcy5jb2xvciwgci5maWxsQ29sb3JdXTtcbiAgICAgICAgdGhpcy56b25lcy5mb3JFYWNoKGZ1bmN0aW9uIChnLCBoKSB7XG4gICAgICAgICAgdC5wdXNoKFtcInpvbmUtYXJlYS1cIiArIGgsIFwiaGlnaGNoYXJ0cy1hcmVhIGhpZ2hjaGFydHMtem9uZS1hcmVhLVwiICsgaCArIFwiIFwiICsgZy5jbGFzc05hbWUsIGcuY29sb3IgfHwgZC5jb2xvciwgZy5maWxsQ29sb3IgfHwgci5maWxsQ29sb3JdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHQuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBoID0gdFswXSxcbiAgICAgICAgICAgICAgdSA9IGRbaF0sXG4gICAgICAgICAgICAgIHEgPSB1ID8gXCJhbmltYXRlXCIgOiBcImF0dHJcIixcbiAgICAgICAgICAgICAgeSA9IHt9O1xuICAgICAgICAgIHUgPyAodS5lbmRYID0gZC5wcmV2ZW50R3JhcGhBbmltYXRpb24gPyBudWxsIDogZy54TWFwLCB1LmFuaW1hdGUoe1xuICAgICAgICAgICAgZDogZ1xuICAgICAgICAgIH0pKSA6ICh5LnpJbmRleCA9IDAsIHUgPSBkW2hdID0gZC5jaGFydC5yZW5kZXJlci5wYXRoKGcpLmFkZENsYXNzKHRbMV0pLmFkZChkLmdyb3VwKSwgdS5pc0FyZWEgPSAhMCk7XG4gICAgICAgICAgZC5jaGFydC5zdHlsZWRNb2RlIHx8ICh5LmZpbGwgPSBFKHRbM10sIEkodFsyXSkuc2V0T3BhY2l0eShFKHIuZmlsbE9wYWNpdHksIC43NSkpLmdldCgpKSk7XG4gICAgICAgICAgdVtxXSh5KTtcbiAgICAgICAgICB1LnN0YXJ0WCA9IGcueE1hcDtcbiAgICAgICAgICB1LnNoaWZ0VW5pdCA9IHIuc3RlcCA/IDIgOiAxO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBkcmF3TGVnZW5kU3ltYm9sOiByLmRyYXdSZWN0YW5nbGVcbiAgICB9KTtcbiAgICBcIlwiO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL1NwbGluZVNlcmllcy5qc1wiLCBbcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkKSB7XG4gICAgdmFyIGcgPSBkLnBpY2s7XG4gICAgZCA9IGQuc2VyaWVzVHlwZTtcbiAgICBkKFwic3BsaW5lXCIsIFwibGluZVwiLCB7fSwge1xuICAgICAgZ2V0UG9pbnRTcGxpbmU6IGZ1bmN0aW9uIChkLCByLCBJKSB7XG4gICAgICAgIHZhciB1ID0gci5wbG90WCxcbiAgICAgICAgICAgIEUgPSByLnBsb3RZLFxuICAgICAgICAgICAgQSA9IGRbSSAtIDFdO1xuICAgICAgICBJID0gZFtJICsgMV07XG5cbiAgICAgICAgaWYgKEEgJiYgIUEuaXNOdWxsICYmICExICE9PSBBLmRvQ3VydmUgJiYgIXIuaXNDbGlmZiAmJiBJICYmICFJLmlzTnVsbCAmJiAhMSAhPT0gSS5kb0N1cnZlICYmICFyLmlzQ2xpZmYpIHtcbiAgICAgICAgICBkID0gQS5wbG90WTtcbiAgICAgICAgICB2YXIgRyA9IEkucGxvdFg7XG4gICAgICAgICAgSSA9IEkucGxvdFk7XG4gICAgICAgICAgdmFyIEogPSAwO1xuICAgICAgICAgIHZhciB5ID0gKDEuNSAqIHUgKyBBLnBsb3RYKSAvIDIuNTtcbiAgICAgICAgICB2YXIgdCA9ICgxLjUgKiBFICsgZCkgLyAyLjU7XG4gICAgICAgICAgRyA9ICgxLjUgKiB1ICsgRykgLyAyLjU7XG4gICAgICAgICAgdmFyIEQgPSAoMS41ICogRSArIEkpIC8gMi41O1xuICAgICAgICAgIEcgIT09IHkgJiYgKEogPSAoRCAtIHQpICogKEcgLSB1KSAvIChHIC0geSkgKyBFIC0gRCk7XG4gICAgICAgICAgdCArPSBKO1xuICAgICAgICAgIEQgKz0gSjtcbiAgICAgICAgICB0ID4gZCAmJiB0ID4gRSA/ICh0ID0gTWF0aC5tYXgoZCwgRSksIEQgPSAyICogRSAtIHQpIDogdCA8IGQgJiYgdCA8IEUgJiYgKHQgPSBNYXRoLm1pbihkLCBFKSwgRCA9IDIgKiBFIC0gdCk7XG4gICAgICAgICAgRCA+IEkgJiYgRCA+IEUgPyAoRCA9IE1hdGgubWF4KEksIEUpLCB0ID0gMiAqIEUgLSBEKSA6IEQgPCBJICYmIEQgPCBFICYmIChEID0gTWF0aC5taW4oSSwgRSksIHQgPSAyICogRSAtIEQpO1xuICAgICAgICAgIHIucmlnaHRDb250WCA9IEc7XG4gICAgICAgICAgci5yaWdodENvbnRZID0gRDtcbiAgICAgICAgfVxuXG4gICAgICAgIHIgPSBbXCJDXCIsIGcoQS5yaWdodENvbnRYLCBBLnBsb3RYKSwgZyhBLnJpZ2h0Q29udFksIEEucGxvdFkpLCBnKHksIHUpLCBnKHQsIEUpLCB1LCBFXTtcbiAgICAgICAgQS5yaWdodENvbnRYID0gQS5yaWdodENvbnRZID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXCJcIjtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9BcmVhU3BsaW5lU2VyaWVzLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcIm1peGlucy9sZWdlbmQtc3ltYm9sLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcsIHIpIHtcbiAgICByID0gci5zZXJpZXNUeXBlO1xuICAgIHZhciB1ID0gZC5zZXJpZXNUeXBlcy5hcmVhLnByb3RvdHlwZTtcbiAgICByKFwiYXJlYXNwbGluZVwiLCBcInNwbGluZVwiLCBkLmRlZmF1bHRQbG90T3B0aW9ucy5hcmVhLCB7XG4gICAgICBnZXRTdGFja1BvaW50czogdS5nZXRTdGFja1BvaW50cyxcbiAgICAgIGdldEdyYXBoUGF0aDogdS5nZXRHcmFwaFBhdGgsXG4gICAgICBkcmF3R3JhcGg6IHUuZHJhd0dyYXBoLFxuICAgICAgZHJhd0xlZ2VuZFN5bWJvbDogZy5kcmF3UmVjdGFuZ2xlXG4gICAgfSk7XG4gICAgXCJcIjtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9Db2x1bW5TZXJpZXMuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvQ29sb3IuanNcIl0sIHJbXCJtaXhpbnMvbGVnZW5kLXN5bWJvbC5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnLCByLCB1KSB7XG4gICAgXCJcIjtcblxuICAgIHZhciBJID0gZy5wYXJzZSxcbiAgICAgICAgTSA9IHUuYW5pbU9iamVjdCxcbiAgICAgICAgRSA9IHUuY2xhbXAsXG4gICAgICAgIEEgPSB1LmRlZmluZWQsXG4gICAgICAgIEcgPSB1LmV4dGVuZCxcbiAgICAgICAgSiA9IHUuaXNOdW1iZXIsXG4gICAgICAgIHkgPSB1Lm1lcmdlLFxuICAgICAgICB0ID0gdS5waWNrO1xuICAgIGcgPSB1LnNlcmllc1R5cGU7XG4gICAgdmFyIEQgPSBkLlNlcmllcztcbiAgICBnKFwiY29sdW1uXCIsIFwibGluZVwiLCB7XG4gICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICBjcmlzcDogITAsXG4gICAgICBncm91cFBhZGRpbmc6IC4yLFxuICAgICAgbWFya2VyOiBudWxsLFxuICAgICAgcG9pbnRQYWRkaW5nOiAuMSxcbiAgICAgIG1pblBvaW50TGVuZ3RoOiAwLFxuICAgICAgY3JvcFRocmVzaG9sZDogNTAsXG4gICAgICBwb2ludFJhbmdlOiBudWxsLFxuICAgICAgc3RhdGVzOiB7XG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgaGFsbzogITEsXG4gICAgICAgICAgYnJpZ2h0bmVzczogLjFcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgY29sb3I6IFwiI2NjY2NjY1wiLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiMwMDAwMDBcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICBhbGlnbjogbnVsbCxcbiAgICAgICAgdmVydGljYWxBbGlnbjogbnVsbCxcbiAgICAgICAgeTogbnVsbFxuICAgICAgfSxcbiAgICAgIHNvZnRUaHJlc2hvbGQ6ICExLFxuICAgICAgc3RhcnRGcm9tVGhyZXNob2xkOiAhMCxcbiAgICAgIHN0aWNreVRyYWNraW5nOiAhMSxcbiAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgZGlzdGFuY2U6IDZcbiAgICAgIH0sXG4gICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICBib3JkZXJDb2xvcjogXCIjZmZmZmZmXCJcbiAgICB9LCB7XG4gICAgICBjcm9wU2hvdWxkZXI6IDAsXG4gICAgICBkaXJlY3RUb3VjaDogITAsXG4gICAgICB0cmFja2VyR3JvdXBzOiBbXCJncm91cFwiLCBcImRhdGFMYWJlbHNHcm91cFwiXSxcbiAgICAgIG5lZ1N0YWNrczogITAsXG4gICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIEQucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgICAgZyA9IGQuY2hhcnQ7XG4gICAgICAgIGcuaGFzUmVuZGVyZWQgJiYgZy5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoaCkge1xuICAgICAgICAgIGgudHlwZSA9PT0gZC50eXBlICYmIChoLmlzRGlydHkgPSAhMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdldENvbHVtbk1ldHJpY3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgICAgZyA9IGQub3B0aW9ucyxcbiAgICAgICAgICAgIHEgPSBkLnhBeGlzLFxuICAgICAgICAgICAgciA9IGQueUF4aXMsXG4gICAgICAgICAgICBlID0gcS5vcHRpb25zLnJldmVyc2VkU3RhY2tzO1xuICAgICAgICBlID0gcS5yZXZlcnNlZCAmJiAhZSB8fCAhcS5yZXZlcnNlZCAmJiBlO1xuICAgICAgICB2YXIgYyxcbiAgICAgICAgICAgIGsgPSB7fSxcbiAgICAgICAgICAgIG4gPSAwO1xuICAgICAgICAhMSA9PT0gZy5ncm91cGluZyA/IG4gPSAxIDogZC5jaGFydC5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHZhciBlID0gYS55QXhpcyxcbiAgICAgICAgICAgICAgZiA9IGEub3B0aW9ucztcblxuICAgICAgICAgIGlmIChhLnR5cGUgPT09IGQudHlwZSAmJiAoYS52aXNpYmxlIHx8ICFkLmNoYXJ0Lm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzKSAmJiByLmxlbiA9PT0gZS5sZW4gJiYgci5wb3MgPT09IGUucG9zKSB7XG4gICAgICAgICAgICBpZiAoZi5zdGFja2luZykge1xuICAgICAgICAgICAgICBjID0gYS5zdGFja0tleTtcbiAgICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGtbY10gJiYgKGtbY10gPSBuKyspO1xuICAgICAgICAgICAgICB2YXIgaCA9IGtbY107XG4gICAgICAgICAgICB9IGVsc2UgITEgIT09IGYuZ3JvdXBpbmcgJiYgKGggPSBuKyspO1xuXG4gICAgICAgICAgICBhLmNvbHVtbkluZGV4ID0gaDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZiA9IE1hdGgubWluKE1hdGguYWJzKHEudHJhbnNBKSAqIChxLm9yZGluYWxTbG9wZSB8fCBnLnBvaW50UmFuZ2UgfHwgcS5jbG9zZXN0UG9pbnRSYW5nZSB8fCBxLnRpY2tJbnRlcnZhbCB8fCAxKSwgcS5sZW4pLFxuICAgICAgICAgICAgYSA9IGYgKiBnLmdyb3VwUGFkZGluZyxcbiAgICAgICAgICAgIGwgPSAoZiAtIDIgKiBhKSAvIChuIHx8IDEpO1xuICAgICAgICBnID0gTWF0aC5taW4oZy5tYXhQb2ludFdpZHRoIHx8IHEubGVuLCB0KGcucG9pbnRXaWR0aCwgbCAqICgxIC0gMiAqIGcucG9pbnRQYWRkaW5nKSkpO1xuICAgICAgICBkLmNvbHVtbk1ldHJpY3MgPSB7XG4gICAgICAgICAgd2lkdGg6IGcsXG4gICAgICAgICAgb2Zmc2V0OiAobCAtIGcpIC8gMiArIChhICsgKChkLmNvbHVtbkluZGV4IHx8IDApICsgKGUgPyAxIDogMCkpICogbCAtIGYgLyAyKSAqIChlID8gLTEgOiAxKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZC5jb2x1bW5NZXRyaWNzO1xuICAgICAgfSxcbiAgICAgIGNyaXNwQ29sOiBmdW5jdGlvbiAoZCwgZywgcSwgdCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBjID0gdGhpcy5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgIGsgPSAtKGMgJSAyID8gLjUgOiAwKTtcbiAgICAgICAgYyA9IGMgJSAyID8gLjUgOiAxO1xuICAgICAgICBlLmludmVydGVkICYmIGUucmVuZGVyZXIuaXNWTUwgJiYgKGMgKz0gMSk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5jcmlzcCAmJiAocSA9IE1hdGgucm91bmQoZCArIHEpICsgaywgZCA9IE1hdGgucm91bmQoZCkgKyBrLCBxIC09IGQpO1xuICAgICAgICB0ID0gTWF0aC5yb3VuZChnICsgdCkgKyBjO1xuICAgICAgICBrID0gLjUgPj0gTWF0aC5hYnMoZykgJiYgLjUgPCB0O1xuICAgICAgICBnID0gTWF0aC5yb3VuZChnKSArIGM7XG4gICAgICAgIHQgLT0gZztcbiAgICAgICAgayAmJiB0ICYmICgtLWcsIHQgKz0gMSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogZCxcbiAgICAgICAgICB5OiBnLFxuICAgICAgICAgIHdpZHRoOiBxLFxuICAgICAgICAgIGhlaWdodDogdFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgICBnID0gZC5jaGFydCxcbiAgICAgICAgICAgIHEgPSBkLm9wdGlvbnMsXG4gICAgICAgICAgICByID0gZC5kZW5zZSA9IDIgPiBkLmNsb3Nlc3RQb2ludFJhbmdlICogZC54QXhpcy50cmFuc0E7XG4gICAgICAgIHIgPSBkLmJvcmRlcldpZHRoID0gdChxLmJvcmRlcldpZHRoLCByID8gMCA6IDEpO1xuICAgICAgICB2YXIgZSA9IGQueEF4aXMsXG4gICAgICAgICAgICBjID0gZC55QXhpcyxcbiAgICAgICAgICAgIGsgPSBxLnRocmVzaG9sZCxcbiAgICAgICAgICAgIG4gPSBkLnRyYW5zbGF0ZWRUaHJlc2hvbGQgPSBjLmdldFRocmVzaG9sZChrKSxcbiAgICAgICAgICAgIGYgPSB0KHEubWluUG9pbnRMZW5ndGgsIDUpLFxuICAgICAgICAgICAgYSA9IGQuZ2V0Q29sdW1uTWV0cmljcygpLFxuICAgICAgICAgICAgbCA9IGEud2lkdGgsXG4gICAgICAgICAgICB2ID0gZC5iYXJXID0gTWF0aC5tYXgobCwgMSArIDIgKiByKSxcbiAgICAgICAgICAgIHogPSBkLnBvaW50WE9mZnNldCA9IGEub2Zmc2V0LFxuICAgICAgICAgICAgdyA9IGQuZGF0YU1pbixcbiAgICAgICAgICAgIHUgPSBkLmRhdGFNYXg7XG4gICAgICAgIGcuaW52ZXJ0ZWQgJiYgKG4gLT0gLjUpO1xuICAgICAgICBxLnBvaW50UGFkZGluZyAmJiAodiA9IE1hdGguY2VpbCh2KSk7XG4gICAgICAgIEQucHJvdG90eXBlLnRyYW5zbGF0ZS5hcHBseShkKTtcbiAgICAgICAgZC5wb2ludHMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHZhciBoID0gdChhLnlCb3R0b20sIG4pLFxuICAgICAgICAgICAgICBxID0gOTk5ICsgTWF0aC5hYnMoaCksXG4gICAgICAgICAgICAgIHIgPSBsLFxuICAgICAgICAgICAgICBwID0gYS5wbG90WDtcbiAgICAgICAgICBxID0gRShhLnBsb3RZLCAtcSwgYy5sZW4gKyBxKTtcbiAgICAgICAgICB2YXIgYiA9IGEucGxvdFggKyB6LFxuICAgICAgICAgICAgICBCID0gdixcbiAgICAgICAgICAgICAgeCA9IE1hdGgubWluKHEsIGgpLFxuICAgICAgICAgICAgICB5ID0gTWF0aC5tYXgocSwgaCkgLSB4O1xuXG4gICAgICAgICAgaWYgKGYgJiYgTWF0aC5hYnMoeSkgPCBmKSB7XG4gICAgICAgICAgICB5ID0gZjtcbiAgICAgICAgICAgIHZhciBMID0gIWMucmV2ZXJzZWQgJiYgIWEubmVnYXRpdmUgfHwgYy5yZXZlcnNlZCAmJiBhLm5lZ2F0aXZlO1xuICAgICAgICAgICAgYS55ID09PSBrICYmIGQuZGF0YU1heCA8PSBrICYmIGMubWluIDwgayAmJiB3ICE9PSB1ICYmIChMID0gIUwpO1xuICAgICAgICAgICAgeCA9IE1hdGguYWJzKHggLSBuKSA+IGYgPyBoIC0gZiA6IG4gLSAoTCA/IGYgOiAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBBKGEub3B0aW9ucy5wb2ludFdpZHRoKSAmJiAociA9IEIgPSBNYXRoLmNlaWwoYS5vcHRpb25zLnBvaW50V2lkdGgpLCBiIC09IE1hdGgucm91bmQoKHIgLSBsKSAvIDIpKTtcbiAgICAgICAgICBhLmJhclggPSBiO1xuICAgICAgICAgIGEucG9pbnRXaWR0aCA9IHI7XG4gICAgICAgICAgYS50b29sdGlwUG9zID0gZy5pbnZlcnRlZCA/IFtjLmxlbiArIGMucG9zIC0gZy5wbG90TGVmdCAtIHEsIGUubGVuICsgZS5wb3MgLSBnLnBsb3RUb3AgLSAocCB8fCAwKSAtIHogLSBCIC8gMiwgeV0gOiBbYiArIEIgLyAyLCBxICsgYy5wb3MgLSBnLnBsb3RUb3AsIHldO1xuICAgICAgICAgIGEuc2hhcGVUeXBlID0gZC5wb2ludENsYXNzLnByb3RvdHlwZS5zaGFwZVR5cGUgfHwgXCJyZWN0XCI7XG4gICAgICAgICAgYS5zaGFwZUFyZ3MgPSBkLmNyaXNwQ29sLmFwcGx5KGQsIGEuaXNOdWxsID8gW2IsIG4sIEIsIDBdIDogW2IsIHgsIEIsIHldKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZ2V0U3ltYm9sOiBkLm5vb3AsXG4gICAgICBkcmF3TGVnZW5kU3ltYm9sOiByLmRyYXdSZWN0YW5nbGUsXG4gICAgICBkcmF3R3JhcGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ncm91cFt0aGlzLmRlbnNlID8gXCJhZGRDbGFzc1wiIDogXCJyZW1vdmVDbGFzc1wiXShcImhpZ2hjaGFydHMtZGVuc2UtZGF0YVwiKTtcbiAgICAgIH0sXG4gICAgICBwb2ludEF0dHJpYnM6IGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgICAgIHZhciBoID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgciA9IHRoaXMucG9pbnRBdHRyVG9PcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgZSA9IHIuc3Ryb2tlIHx8IFwiYm9yZGVyQ29sb3JcIjtcbiAgICAgICAgdmFyIGMgPSByW1wic3Ryb2tlLXdpZHRoXCJdIHx8IFwiYm9yZGVyV2lkdGhcIixcbiAgICAgICAgICAgIGsgPSBkICYmIGQuY29sb3IgfHwgdGhpcy5jb2xvcixcbiAgICAgICAgICAgIG4gPSBkICYmIGRbZV0gfHwgaFtlXSB8fCB0aGlzLmNvbG9yIHx8IGssXG4gICAgICAgICAgICBmID0gZCAmJiBkW2NdIHx8IGhbY10gfHwgdGhpc1tjXSB8fCAwO1xuICAgICAgICByID0gZCAmJiBkLm9wdGlvbnMuZGFzaFN0eWxlIHx8IGguZGFzaFN0eWxlO1xuICAgICAgICB2YXIgYSA9IHQoZCAmJiBkLm9wYWNpdHksIGgub3BhY2l0eSwgMSk7XG5cbiAgICAgICAgaWYgKGQgJiYgdGhpcy56b25lcy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbCA9IGQuZ2V0Wm9uZSgpO1xuICAgICAgICAgIGsgPSBkLm9wdGlvbnMuY29sb3IgfHwgbCAmJiAobC5jb2xvciB8fCBkLm5vblpvbmVkQ29sb3IpIHx8IHRoaXMuY29sb3I7XG4gICAgICAgICAgbCAmJiAobiA9IGwuYm9yZGVyQ29sb3IgfHwgbiwgciA9IGwuZGFzaFN0eWxlIHx8IHIsIGYgPSBsLmJvcmRlcldpZHRoIHx8IGYpO1xuICAgICAgICB9XG5cbiAgICAgICAgZyAmJiBkICYmIChkID0geShoLnN0YXRlc1tnXSwgZC5vcHRpb25zLnN0YXRlcyAmJiBkLm9wdGlvbnMuc3RhdGVzW2ddIHx8IHt9KSwgZyA9IGQuYnJpZ2h0bmVzcywgayA9IGQuY29sb3IgfHwgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGcgJiYgSShrKS5icmlnaHRlbihkLmJyaWdodG5lc3MpLmdldCgpIHx8IGssIG4gPSBkW2VdIHx8IG4sIGYgPSBkW2NdIHx8IGYsIHIgPSBkLmRhc2hTdHlsZSB8fCByLCBhID0gdChkLm9wYWNpdHksIGEpKTtcbiAgICAgICAgZSA9IHtcbiAgICAgICAgICBmaWxsOiBrLFxuICAgICAgICAgIHN0cm9rZTogbixcbiAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBmLFxuICAgICAgICAgIG9wYWNpdHk6IGFcbiAgICAgICAgfTtcbiAgICAgICAgciAmJiAoZS5kYXNoc3R5bGUgPSByKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9LFxuICAgICAgZHJhd1BvaW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgICBnID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIHEgPSBkLm9wdGlvbnMsXG4gICAgICAgICAgICB0ID0gZy5yZW5kZXJlcixcbiAgICAgICAgICAgIGUgPSBxLmFuaW1hdGlvbkxpbWl0IHx8IDI1MCxcbiAgICAgICAgICAgIGM7XG4gICAgICAgIGQucG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICB2YXIgaCA9IGsuZ3JhcGhpYyxcbiAgICAgICAgICAgICAgZiA9ICEhaCxcbiAgICAgICAgICAgICAgYSA9IGggJiYgZy5wb2ludENvdW50IDwgZSA/IFwiYW5pbWF0ZVwiIDogXCJhdHRyXCI7XG5cbiAgICAgICAgICBpZiAoSihrLnBsb3RZKSAmJiBudWxsICE9PSBrLnkpIHtcbiAgICAgICAgICAgIGMgPSBrLnNoYXBlQXJncztcbiAgICAgICAgICAgIGggJiYgay5oYXNOZXdTaGFwZVR5cGUoKSAmJiAoaCA9IGguZGVzdHJveSgpKTtcbiAgICAgICAgICAgIGQuZW5hYmxlZERhdGFTb3J0aW5nICYmIChrLnN0YXJ0WFBvcyA9IGQueEF4aXMucmV2ZXJzZWQgPyAtKGMgPyBjLndpZHRoIDogMCkgOiBkLnhBeGlzLndpZHRoKTtcbiAgICAgICAgICAgIGggfHwgKGsuZ3JhcGhpYyA9IGggPSB0W2suc2hhcGVUeXBlXShjKS5hZGQoay5ncm91cCB8fCBkLmdyb3VwKSkgJiYgZC5lbmFibGVkRGF0YVNvcnRpbmcgJiYgZy5oYXNSZW5kZXJlZCAmJiBnLnBvaW50Q291bnQgPCBlICYmIChoLmF0dHIoe1xuICAgICAgICAgICAgICB4OiBrLnN0YXJ0WFBvc1xuICAgICAgICAgICAgfSksIGYgPSAhMCwgYSA9IFwiYW5pbWF0ZVwiKTtcbiAgICAgICAgICAgIGlmIChoICYmIGYpIGhbYV0oeShjKSk7XG4gICAgICAgICAgICBpZiAocS5ib3JkZXJSYWRpdXMpIGhbYV0oe1xuICAgICAgICAgICAgICByOiBxLmJvcmRlclJhZGl1c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBnLnN0eWxlZE1vZGUgfHwgaFthXShkLnBvaW50QXR0cmlicyhrLCBrLnNlbGVjdGVkICYmIFwic2VsZWN0XCIpKS5zaGFkb3coITEgIT09IGsuYWxsb3dTaGFkb3cgJiYgcS5zaGFkb3csIG51bGwsIHEuc3RhY2tpbmcgJiYgIXEuYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgICAgIGguYWRkQ2xhc3Moay5nZXRDbGFzc05hbWUoKSwgITApO1xuICAgICAgICAgIH0gZWxzZSBoICYmIChrLmdyYXBoaWMgPSBoLmRlc3Ryb3koKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBoID0gdGhpcyxcbiAgICAgICAgICAgIGcgPSB0aGlzLnlBeGlzLFxuICAgICAgICAgICAgdCA9IGgub3B0aW9ucyxcbiAgICAgICAgICAgIGUgPSB0aGlzLmNoYXJ0LmludmVydGVkLFxuICAgICAgICAgICAgYyA9IHt9LFxuICAgICAgICAgICAgayA9IGUgPyBcInRyYW5zbGF0ZVhcIiA6IFwidHJhbnNsYXRlWVwiO1xuICAgICAgICBpZiAoZCkgYy5zY2FsZVkgPSAuMDAxLCBkID0gRShnLnRvUGl4ZWxzKHQudGhyZXNob2xkKSwgZy5wb3MsIGcucG9zICsgZy5sZW4pLCBlID8gYy50cmFuc2xhdGVYID0gZCAtIGcubGVuIDogYy50cmFuc2xhdGVZID0gZCwgaC5jbGlwQm94ICYmIGguc2V0Q2xpcCgpLCBoLmdyb3VwLmF0dHIoYyk7ZWxzZSB7XG4gICAgICAgICAgdmFyIG4gPSBoLmdyb3VwLmF0dHIoayk7XG4gICAgICAgICAgaC5ncm91cC5hbmltYXRlKHtcbiAgICAgICAgICAgIHNjYWxlWTogMVxuICAgICAgICAgIH0sIEcoTShoLm9wdGlvbnMuYW5pbWF0aW9uKSwge1xuICAgICAgICAgICAgc3RlcDogZnVuY3Rpb24gKGUsIGEpIHtcbiAgICAgICAgICAgICAgaC5ncm91cCAmJiAoY1trXSA9IG4gKyBhLnBvcyAqIChnLnBvcyAtIG4pLCBoLmdyb3VwLmF0dHIoYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgICBnID0gZC5jaGFydDtcbiAgICAgICAgZy5oYXNSZW5kZXJlZCAmJiBnLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgaC50eXBlID09PSBkLnR5cGUgJiYgKGguaXNEaXJ0eSA9ICEwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIEQucHJvdG90eXBlLnJlbW92ZS5hcHBseShkLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFwiXCI7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvQmFyU2VyaWVzLmpzXCIsIFtyW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQpIHtcbiAgICBkID0gZC5zZXJpZXNUeXBlO1xuICAgIGQoXCJiYXJcIiwgXCJjb2x1bW5cIiwgbnVsbCwge1xuICAgICAgaW52ZXJ0ZWQ6ICEwXG4gICAgfSk7XG4gICAgXCJcIjtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9TY2F0dGVyU2VyaWVzLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgdmFyIHIgPSBnLmFkZEV2ZW50O1xuICAgIGcgPSBnLnNlcmllc1R5cGU7XG4gICAgdmFyIHUgPSBkLlNlcmllcztcbiAgICBnKFwic2NhdHRlclwiLCBcImxpbmVcIiwge1xuICAgICAgbGluZVdpZHRoOiAwLFxuICAgICAgZmluZE5lYXJlc3RQb2ludEJ5OiBcInh5XCIsXG4gICAgICBqaXR0ZXI6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSxcbiAgICAgIG1hcmtlcjoge1xuICAgICAgICBlbmFibGVkOiAhMFxuICAgICAgfSxcbiAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgaGVhZGVyRm9ybWF0OiAnPHNwYW4gc3R5bGU9XCJjb2xvcjp7cG9pbnQuY29sb3J9XCI+XFx1MjVjZjwvc3Bhbj4gPHNwYW4gc3R5bGU9XCJmb250LXNpemU6IDEwcHhcIj4ge3Nlcmllcy5uYW1lfTwvc3Bhbj48YnIvPicsXG4gICAgICAgIHBvaW50Rm9ybWF0OiBcIng6IDxiPntwb2ludC54fTwvYj48YnIvPnk6IDxiPntwb2ludC55fTwvYj48YnIvPlwiXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc29ydGVkOiAhMSxcbiAgICAgIHJlcXVpcmVTb3J0aW5nOiAhMSxcbiAgICAgIG5vU2hhcmVkVG9vbHRpcDogITAsXG4gICAgICB0cmFja2VyR3JvdXBzOiBbXCJncm91cFwiLCBcIm1hcmtlckdyb3VwXCIsIFwiZGF0YUxhYmVsc0dyb3VwXCJdLFxuICAgICAgdGFrZU9yZGluYWxQb3NpdGlvbjogITEsXG4gICAgICBkcmF3R3JhcGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxpbmVXaWR0aCAmJiB1LnByb3RvdHlwZS5kcmF3R3JhcGguY2FsbCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBhcHBseUppdHRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgICBnID0gdGhpcy5vcHRpb25zLmppdHRlcixcbiAgICAgICAgICAgIHIgPSB0aGlzLnBvaW50cy5sZW5ndGg7XG4gICAgICAgIGcgJiYgdGhpcy5wb2ludHMuZm9yRWFjaChmdW5jdGlvbiAodSwgRSkge1xuICAgICAgICAgIFtcInhcIiwgXCJ5XCJdLmZvckVhY2goZnVuY3Rpb24gKEEsIHkpIHtcbiAgICAgICAgICAgIHZhciB0ID0gXCJwbG90XCIgKyBBLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIGlmIChnW0FdICYmICF1LmlzTnVsbCkge1xuICAgICAgICAgICAgICB2YXIgRCA9IGRbQSArIFwiQXhpc1wiXTtcbiAgICAgICAgICAgICAgdmFyIGggPSBnW0FdICogRC50cmFuc0E7XG5cbiAgICAgICAgICAgICAgaWYgKEQgJiYgIUQuaXNMb2cpIHtcbiAgICAgICAgICAgICAgICB2YXIgRyA9IE1hdGgubWF4KDAsIHVbdF0gLSBoKTtcbiAgICAgICAgICAgICAgICBEID0gTWF0aC5taW4oRC5sZW4sIHVbdF0gKyBoKTtcbiAgICAgICAgICAgICAgICB5ID0gMUU0ICogTWF0aC5zaW4oRSArIHkgKiByKTtcbiAgICAgICAgICAgICAgICB1W3RdID0gRyArIChEIC0gRykgKiAoeSAtIE1hdGguZmxvb3IoeSkpO1xuICAgICAgICAgICAgICAgIFwieFwiID09PSBBICYmICh1LmNsaWVudFggPSB1LnBsb3RYKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByKHUsIFwiYWZ0ZXJUcmFuc2xhdGVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5hcHBseUppdHRlciAmJiB0aGlzLmFwcGx5Sml0dGVyKCk7XG4gICAgfSk7XG4gICAgXCJcIjtcbiAgfSk7XG4gIFMociwgXCJtaXhpbnMvY2VudGVyZWQtc2VyaWVzLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgdmFyIHIgPSBnLmlzTnVtYmVyLFxuICAgICAgICB1ID0gZy5waWNrLFxuICAgICAgICBJID0gZy5yZWxhdGl2ZUxlbmd0aCxcbiAgICAgICAgTSA9IGQuZGVnMnJhZDtcbiAgICBkLkNlbnRlcmVkU2VyaWVzTWl4aW4gPSB7XG4gICAgICBnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBnID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIHIgPSAyICogKGQuc2xpY2VkT2Zmc2V0IHx8IDApLFxuICAgICAgICAgICAgSiA9IGcucGxvdFdpZHRoIC0gMiAqIHIsXG4gICAgICAgICAgICB5ID0gZy5wbG90SGVpZ2h0IC0gMiAqIHIsXG4gICAgICAgICAgICB0ID0gZC5jZW50ZXIsXG4gICAgICAgICAgICBEID0gTWF0aC5taW4oSiwgeSksXG4gICAgICAgICAgICBoID0gZC5zaXplLFxuICAgICAgICAgICAgTiA9IGQuaW5uZXJTaXplIHx8IDA7XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBoICYmIChoID0gcGFyc2VGbG9hdChoKSk7XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBOICYmIChOID0gcGFyc2VGbG9hdChOKSk7XG4gICAgICAgIGQgPSBbdSh0WzBdLCBcIjUwJVwiKSwgdSh0WzFdLCBcIjUwJVwiKSwgdShoICYmIDAgPiBoID8gdm9pZCAwIDogZC5zaXplLCBcIjEwMCVcIiksIHUoTiAmJiAwID4gTiA/IHZvaWQgMCA6IGQuaW5uZXJTaXplIHx8IDAsIFwiMCVcIildO1xuICAgICAgICBnLmFuZ3VsYXIgJiYgKGRbM10gPSAwKTtcblxuICAgICAgICBmb3IgKHQgPSAwOyA0ID4gdDsgKyt0KSBoID0gZFt0XSwgZyA9IDIgPiB0IHx8IDIgPT09IHQgJiYgLyUkLy50ZXN0KGgpLCBkW3RdID0gSShoLCBbSiwgeSwgRCwgZFsyXV1bdF0pICsgKGcgPyByIDogMCk7XG5cbiAgICAgICAgZFszXSA+IGRbMl0gJiYgKGRbM10gPSBkWzJdKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9LFxuICAgICAgZ2V0U3RhcnRBbmRFbmRSYWRpYW5zOiBmdW5jdGlvbiAoZCwgZykge1xuICAgICAgICBkID0gcihkKSA/IGQgOiAwO1xuICAgICAgICBnID0gcihnKSAmJiBnID4gZCAmJiAzNjAgPiBnIC0gZCA/IGcgOiBkICsgMzYwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXJ0OiBNICogKGQgKyAtOTApLFxuICAgICAgICAgIGVuZDogTSAqIChnICsgLTkwKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICBTKHIsIFwicGFydHMvUGllU2VyaWVzLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcIm1peGlucy9sZWdlbmQtc3ltYm9sLmpzXCJdLCByW1wicGFydHMvUG9pbnQuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZywgciwgdSkge1xuICAgIHZhciBJID0gdS5hZGRFdmVudCxcbiAgICAgICAgTSA9IHUuY2xhbXAsXG4gICAgICAgIEUgPSB1LmRlZmluZWQsXG4gICAgICAgIEEgPSB1LmZpcmVFdmVudCxcbiAgICAgICAgRyA9IHUuaXNOdW1iZXIsXG4gICAgICAgIEogPSB1Lm1lcmdlLFxuICAgICAgICB5ID0gdS5waWNrLFxuICAgICAgICB0ID0gdS5yZWxhdGl2ZUxlbmd0aCxcbiAgICAgICAgRCA9IHUuc2VyaWVzVHlwZSxcbiAgICAgICAgaCA9IHUuc2V0QW5pbWF0aW9uO1xuICAgIHUgPSBkLkNlbnRlcmVkU2VyaWVzTWl4aW47XG4gICAgdmFyIE4gPSB1LmdldFN0YXJ0QW5kRW5kUmFkaWFucyxcbiAgICAgICAgcSA9IGQubm9vcCxcbiAgICAgICAgUCA9IGQuU2VyaWVzO1xuICAgIEQoXCJwaWVcIiwgXCJsaW5lXCIsIHtcbiAgICAgIGNlbnRlcjogW251bGwsIG51bGxdLFxuICAgICAgY2xpcDogITEsXG4gICAgICBjb2xvckJ5UG9pbnQ6ICEwLFxuICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICBhbGxvd092ZXJsYXA6ICEwLFxuICAgICAgICBjb25uZWN0b3JQYWRkaW5nOiA1LFxuICAgICAgICBjb25uZWN0b3JTaGFwZTogXCJmaXhlZE9mZnNldFwiLFxuICAgICAgICBjcm9va0Rpc3RhbmNlOiBcIjcwJVwiLFxuICAgICAgICBkaXN0YW5jZTogMzAsXG4gICAgICAgIGVuYWJsZWQ6ICEwLFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wb2ludC5pc051bGwgPyB2b2lkIDAgOiB0aGlzLnBvaW50Lm5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNvZnRDb25uZWN0b3I6ICEwLFxuICAgICAgICB4OiAwXG4gICAgICB9LFxuICAgICAgZmlsbENvbG9yOiB2b2lkIDAsXG4gICAgICBpZ25vcmVIaWRkZW5Qb2ludDogITAsXG4gICAgICBpbmFjdGl2ZU90aGVyUG9pbnRzOiAhMCxcbiAgICAgIGxlZ2VuZFR5cGU6IFwicG9pbnRcIixcbiAgICAgIG1hcmtlcjogbnVsbCxcbiAgICAgIHNpemU6IG51bGwsXG4gICAgICBzaG93SW5MZWdlbmQ6ICExLFxuICAgICAgc2xpY2VkT2Zmc2V0OiAxMCxcbiAgICAgIHN0aWNreVRyYWNraW5nOiAhMSxcbiAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgZm9sbG93UG9pbnRlcjogITBcbiAgICAgIH0sXG4gICAgICBib3JkZXJDb2xvcjogXCIjZmZmZmZmXCIsXG4gICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgIGxpbmVXaWR0aDogdm9pZCAwLFxuICAgICAgc3RhdGVzOiB7XG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgYnJpZ2h0bmVzczogLjFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGlzQ2FydGVzaWFuOiAhMSxcbiAgICAgIHJlcXVpcmVTb3J0aW5nOiAhMSxcbiAgICAgIGRpcmVjdFRvdWNoOiAhMCxcbiAgICAgIG5vU2hhcmVkVG9vbHRpcDogITAsXG4gICAgICB0cmFja2VyR3JvdXBzOiBbXCJncm91cFwiLCBcImRhdGFMYWJlbHNHcm91cFwiXSxcbiAgICAgIGF4aXNUeXBlczogW10sXG4gICAgICBwb2ludEF0dHJpYnM6IGQuc2VyaWVzVHlwZXMuY29sdW1uLnByb3RvdHlwZS5wb2ludEF0dHJpYnMsXG4gICAgICBhbmltYXRlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgYyA9IHRoaXMsXG4gICAgICAgICAgICBkID0gYy5wb2ludHMsXG4gICAgICAgICAgICBnID0gYy5zdGFydEFuZ2xlUmFkO1xuICAgICAgICBlIHx8IGQuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBhID0gZS5ncmFwaGljLFxuICAgICAgICAgICAgICBmID0gZS5zaGFwZUFyZ3M7XG4gICAgICAgICAgYSAmJiBmICYmIChhLmF0dHIoe1xuICAgICAgICAgICAgcjogeShlLnN0YXJ0UiwgYy5jZW50ZXIgJiYgYy5jZW50ZXJbM10gLyAyKSxcbiAgICAgICAgICAgIHN0YXJ0OiBnLFxuICAgICAgICAgICAgZW5kOiBnXG4gICAgICAgICAgfSksIGEuYW5pbWF0ZSh7XG4gICAgICAgICAgICByOiBmLnIsXG4gICAgICAgICAgICBzdGFydDogZi5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZi5lbmRcbiAgICAgICAgICB9LCBjLm9wdGlvbnMuYW5pbWF0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGhhc0RhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5wcm9jZXNzZWRYRGF0YS5sZW5ndGg7XG4gICAgICB9LFxuICAgICAgdXBkYXRlVG90YWxzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlLFxuICAgICAgICAgICAgYyA9IDAsXG4gICAgICAgICAgICBkID0gdGhpcy5wb2ludHMsXG4gICAgICAgICAgICBnID0gZC5sZW5ndGgsXG4gICAgICAgICAgICBmID0gdGhpcy5vcHRpb25zLmlnbm9yZUhpZGRlblBvaW50O1xuXG4gICAgICAgIGZvciAoZSA9IDA7IGUgPCBnOyBlKyspIHtcbiAgICAgICAgICB2YXIgYSA9IGRbZV07XG4gICAgICAgICAgYyArPSBmICYmICFhLnZpc2libGUgPyAwIDogYS5pc051bGwgPyAwIDogYS55O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50b3RhbCA9IGM7XG5cbiAgICAgICAgZm9yIChlID0gMDsgZSA8IGc7IGUrKykgYSA9IGRbZV0sIGEucGVyY2VudGFnZSA9IDAgPCBjICYmIChhLnZpc2libGUgfHwgIWYpID8gYS55IC8gYyAqIDEwMCA6IDAsIGEudG90YWwgPSBjO1xuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFAucHJvdG90eXBlLmdlbmVyYXRlUG9pbnRzLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlVG90YWxzKCk7XG4gICAgICB9LFxuICAgICAgZ2V0WDogZnVuY3Rpb24gKGUsIGMsIGQpIHtcbiAgICAgICAgdmFyIGsgPSB0aGlzLmNlbnRlcixcbiAgICAgICAgICAgIGYgPSB0aGlzLnJhZGlpID8gdGhpcy5yYWRpaVtkLmluZGV4XSA6IGtbMl0gLyAyO1xuICAgICAgICBlID0gTWF0aC5hc2luKE0oKGUgLSBrWzFdKSAvIChmICsgZC5sYWJlbERpc3RhbmNlKSwgLTEsIDEpKTtcbiAgICAgICAgcmV0dXJuIGtbMF0gKyAoYyA/IC0xIDogMSkgKiBNYXRoLmNvcyhlKSAqIChmICsgZC5sYWJlbERpc3RhbmNlKSArICgwIDwgZC5sYWJlbERpc3RhbmNlID8gKGMgPyAtMSA6IDEpICogdGhpcy5vcHRpb25zLmRhdGFMYWJlbHMucGFkZGluZyA6IDApO1xuICAgICAgfSxcbiAgICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZVBvaW50cygpO1xuICAgICAgICB2YXIgYyA9IDAsXG4gICAgICAgICAgICBkID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgZyA9IGQuc2xpY2VkT2Zmc2V0LFxuICAgICAgICAgICAgZiA9IGcgKyAoZC5ib3JkZXJXaWR0aCB8fCAwKSxcbiAgICAgICAgICAgIGEgPSBOKGQuc3RhcnRBbmdsZSwgZC5lbmRBbmdsZSksXG4gICAgICAgICAgICBoID0gdGhpcy5zdGFydEFuZ2xlUmFkID0gYS5zdGFydDtcbiAgICAgICAgYSA9ICh0aGlzLmVuZEFuZ2xlUmFkID0gYS5lbmQpIC0gaDtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnBvaW50cyxcbiAgICAgICAgICAgIHEgPSBkLmRhdGFMYWJlbHMuZGlzdGFuY2U7XG4gICAgICAgIGQgPSBkLmlnbm9yZUhpZGRlblBvaW50O1xuICAgICAgICB2YXIgdyxcbiAgICAgICAgICAgIHIgPSB2Lmxlbmd0aDtcbiAgICAgICAgZSB8fCAodGhpcy5jZW50ZXIgPSBlID0gdGhpcy5nZXRDZW50ZXIoKSk7XG5cbiAgICAgICAgZm9yICh3ID0gMDsgdyA8IHI7IHcrKykge1xuICAgICAgICAgIHZhciB1ID0gdlt3XTtcbiAgICAgICAgICB2YXIgRCA9IGggKyBjICogYTtcbiAgICAgICAgICBpZiAoIWQgfHwgdS52aXNpYmxlKSBjICs9IHUucGVyY2VudGFnZSAvIDEwMDtcbiAgICAgICAgICB2YXIgSCA9IGggKyBjICogYTtcbiAgICAgICAgICB1LnNoYXBlVHlwZSA9IFwiYXJjXCI7XG4gICAgICAgICAgdS5zaGFwZUFyZ3MgPSB7XG4gICAgICAgICAgICB4OiBlWzBdLFxuICAgICAgICAgICAgeTogZVsxXSxcbiAgICAgICAgICAgIHI6IGVbMl0gLyAyLFxuICAgICAgICAgICAgaW5uZXJSOiBlWzNdIC8gMixcbiAgICAgICAgICAgIHN0YXJ0OiBNYXRoLnJvdW5kKDFFMyAqIEQpIC8gMUUzLFxuICAgICAgICAgICAgZW5kOiBNYXRoLnJvdW5kKDFFMyAqIEgpIC8gMUUzXG4gICAgICAgICAgfTtcbiAgICAgICAgICB1LmxhYmVsRGlzdGFuY2UgPSB5KHUub3B0aW9ucy5kYXRhTGFiZWxzICYmIHUub3B0aW9ucy5kYXRhTGFiZWxzLmRpc3RhbmNlLCBxKTtcbiAgICAgICAgICB1LmxhYmVsRGlzdGFuY2UgPSB0KHUubGFiZWxEaXN0YW5jZSwgdS5zaGFwZUFyZ3Mucik7XG4gICAgICAgICAgdGhpcy5tYXhMYWJlbERpc3RhbmNlID0gTWF0aC5tYXgodGhpcy5tYXhMYWJlbERpc3RhbmNlIHx8IDAsIHUubGFiZWxEaXN0YW5jZSk7XG4gICAgICAgICAgSCA9IChIICsgRCkgLyAyO1xuICAgICAgICAgIEggPiAxLjUgKiBNYXRoLlBJID8gSCAtPSAyICogTWF0aC5QSSA6IEggPCAtTWF0aC5QSSAvIDIgJiYgKEggKz0gMiAqIE1hdGguUEkpO1xuICAgICAgICAgIHUuc2xpY2VkVHJhbnNsYXRpb24gPSB7XG4gICAgICAgICAgICB0cmFuc2xhdGVYOiBNYXRoLnJvdW5kKE1hdGguY29zKEgpICogZyksXG4gICAgICAgICAgICB0cmFuc2xhdGVZOiBNYXRoLnJvdW5kKE1hdGguc2luKEgpICogZylcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBLID0gTWF0aC5jb3MoSCkgKiBlWzJdIC8gMjtcbiAgICAgICAgICB2YXIgcCA9IE1hdGguc2luKEgpICogZVsyXSAvIDI7XG4gICAgICAgICAgdS50b29sdGlwUG9zID0gW2VbMF0gKyAuNyAqIEssIGVbMV0gKyAuNyAqIHBdO1xuICAgICAgICAgIHUuaGFsZiA9IEggPCAtTWF0aC5QSSAvIDIgfHwgSCA+IE1hdGguUEkgLyAyID8gMSA6IDA7XG4gICAgICAgICAgdS5hbmdsZSA9IEg7XG4gICAgICAgICAgRCA9IE1hdGgubWluKGYsIHUubGFiZWxEaXN0YW5jZSAvIDUpO1xuICAgICAgICAgIHUubGFiZWxQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIG5hdHVyYWw6IHtcbiAgICAgICAgICAgICAgeDogZVswXSArIEsgKyBNYXRoLmNvcyhIKSAqIHUubGFiZWxEaXN0YW5jZSxcbiAgICAgICAgICAgICAgeTogZVsxXSArIHAgKyBNYXRoLnNpbihIKSAqIHUubGFiZWxEaXN0YW5jZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmluYWxcIjoge30sXG4gICAgICAgICAgICBhbGlnbm1lbnQ6IDAgPiB1LmxhYmVsRGlzdGFuY2UgPyBcImNlbnRlclwiIDogdS5oYWxmID8gXCJyaWdodFwiIDogXCJsZWZ0XCIsXG4gICAgICAgICAgICBjb25uZWN0b3JQb3NpdGlvbjoge1xuICAgICAgICAgICAgICBicmVha0F0OiB7XG4gICAgICAgICAgICAgICAgeDogZVswXSArIEsgKyBNYXRoLmNvcyhIKSAqIEQsXG4gICAgICAgICAgICAgICAgeTogZVsxXSArIHAgKyBNYXRoLnNpbihIKSAqIERcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdG91Y2hpbmdTbGljZUF0OiB7XG4gICAgICAgICAgICAgICAgeDogZVswXSArIEssXG4gICAgICAgICAgICAgICAgeTogZVsxXSArIHBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBBKHRoaXMsIFwiYWZ0ZXJUcmFuc2xhdGVcIik7XG4gICAgICB9LFxuICAgICAgZHJhd0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgIGlmICgwID09PSB0aGlzLnRvdGFsKSB7XG4gICAgICAgICAgdmFyIGMgPSB0aGlzLmNlbnRlclswXTtcbiAgICAgICAgICB2YXIgZCA9IHRoaXMuY2VudGVyWzFdO1xuICAgICAgICAgIHRoaXMuZ3JhcGggfHwgKHRoaXMuZ3JhcGggPSB0aGlzLmNoYXJ0LnJlbmRlcmVyLmNpcmNsZShjLCBkLCAwKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtZ3JhcGhcIikuYWRkKHRoaXMuZ3JvdXApKTtcbiAgICAgICAgICB0aGlzLmdyYXBoLmFuaW1hdGUoe1xuICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgIGN4OiBjLFxuICAgICAgICAgICAgY3k6IGQsXG4gICAgICAgICAgICByOiB0aGlzLmNlbnRlclsyXSAvIDIsXG4gICAgICAgICAgICBmaWxsOiBlLmZpbGxDb2xvciB8fCBcIm5vbmVcIixcbiAgICAgICAgICAgIHN0cm9rZTogZS5jb2xvciB8fCBcIiNjY2NjY2NcIlxuICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy5hbmltYXRpb24pO1xuICAgICAgICB9IGVsc2UgdGhpcy5ncmFwaCAmJiAodGhpcy5ncmFwaCA9IHRoaXMuZ3JhcGguZGVzdHJveSgpKTtcbiAgICAgIH0sXG4gICAgICByZWRyYXdQb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgICAgYyA9IGUuY2hhcnQsXG4gICAgICAgICAgICBkID0gYy5yZW5kZXJlcixcbiAgICAgICAgICAgIGcsXG4gICAgICAgICAgICBmLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGgsXG4gICAgICAgICAgICB2ID0gZS5vcHRpb25zLnNoYWRvdztcbiAgICAgICAgdGhpcy5kcmF3RW1wdHkoKTtcbiAgICAgICAgIXYgfHwgZS5zaGFkb3dHcm91cCB8fCBjLnN0eWxlZE1vZGUgfHwgKGUuc2hhZG93R3JvdXAgPSBkLmcoXCJzaGFkb3dcIikuYXR0cih7XG4gICAgICAgICAgekluZGV4OiAtMVxuICAgICAgICB9KS5hZGQoZS5ncm91cCkpO1xuICAgICAgICBlLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgdmFyIGwgPSB7fTtcbiAgICAgICAgICBmID0gay5ncmFwaGljO1xuXG4gICAgICAgICAgaWYgKCFrLmlzTnVsbCAmJiBmKSB7XG4gICAgICAgICAgICBoID0gay5zaGFwZUFyZ3M7XG4gICAgICAgICAgICBnID0gay5nZXRUcmFuc2xhdGUoKTtcblxuICAgICAgICAgICAgaWYgKCFjLnN0eWxlZE1vZGUpIHtcbiAgICAgICAgICAgICAgdmFyIG4gPSBrLnNoYWRvd0dyb3VwO1xuICAgICAgICAgICAgICB2ICYmICFuICYmIChuID0gay5zaGFkb3dHcm91cCA9IGQuZyhcInNoYWRvd1wiKS5hZGQoZS5zaGFkb3dHcm91cCkpO1xuICAgICAgICAgICAgICBuICYmIG4uYXR0cihnKTtcbiAgICAgICAgICAgICAgYSA9IGUucG9pbnRBdHRyaWJzKGssIGsuc2VsZWN0ZWQgJiYgXCJzZWxlY3RcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGsuZGVsYXllZFJlbmRlcmluZyA/IChmLnNldFJhZGlhbFJlZmVyZW5jZShlLmNlbnRlcikuYXR0cihoKS5hdHRyKGcpLCBjLnN0eWxlZE1vZGUgfHwgZi5hdHRyKGEpLmF0dHIoe1xuICAgICAgICAgICAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInJvdW5kXCJcbiAgICAgICAgICAgIH0pLnNoYWRvdyh2LCBuKSwgay5kZWxheWVkUmVuZGVyaW5nID0gITEpIDogKGYuc2V0UmFkaWFsUmVmZXJlbmNlKGUuY2VudGVyKSwgYy5zdHlsZWRNb2RlIHx8IEooITAsIGwsIGEpLCBKKCEwLCBsLCBoLCBnKSwgZi5hbmltYXRlKGwpKTtcbiAgICAgICAgICAgIGYuYXR0cih7XG4gICAgICAgICAgICAgIHZpc2liaWxpdHk6IGsudmlzaWJsZSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmLmFkZENsYXNzKGsuZ2V0Q2xhc3NOYW1lKCkpO1xuICAgICAgICAgIH0gZWxzZSBmICYmIChrLmdyYXBoaWMgPSBmLmRlc3Ryb3koKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGRyYXdQb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmNoYXJ0LnJlbmRlcmVyO1xuICAgICAgICB0aGlzLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgYy5ncmFwaGljICYmIGMuaGFzTmV3U2hhcGVUeXBlKCkgJiYgKGMuZ3JhcGhpYyA9IGMuZ3JhcGhpYy5kZXN0cm95KCkpO1xuICAgICAgICAgIGMuZ3JhcGhpYyB8fCAoYy5ncmFwaGljID0gZVtjLnNoYXBlVHlwZV0oYy5zaGFwZUFyZ3MpLmFkZChjLnNlcmllcy5ncm91cCksIGMuZGVsYXllZFJlbmRlcmluZyA9ICEwKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc2VhcmNoUG9pbnQ6IHEsXG4gICAgICBzb3J0QnlBbmdsZTogZnVuY3Rpb24gKGUsIGMpIHtcbiAgICAgICAgZS5zb3J0KGZ1bmN0aW9uIChlLCBkKSB7XG4gICAgICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBlLmFuZ2xlICYmIChkLmFuZ2xlIC0gZS5hbmdsZSkgKiBjO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBkcmF3TGVnZW5kU3ltYm9sOiBnLmRyYXdSZWN0YW5nbGUsXG4gICAgICBnZXRDZW50ZXI6IHUuZ2V0Q2VudGVyLFxuICAgICAgZ2V0U3ltYm9sOiBxLFxuICAgICAgZHJhd0dyYXBoOiBudWxsXG4gICAgfSwge1xuICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICByLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgZS5uYW1lID0geShlLm5hbWUsIFwiU2xpY2VcIik7XG5cbiAgICAgICAgdmFyIGMgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGUuc2xpY2UoXCJzZWxlY3RcIiA9PT0gYy50eXBlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBJKGUsIFwic2VsZWN0XCIsIGMpO1xuICAgICAgICBJKGUsIFwidW5zZWxlY3RcIiwgYyk7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfSxcbiAgICAgIGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEcodGhpcy55KSAmJiAwIDw9IHRoaXMueTtcbiAgICAgIH0sXG4gICAgICBzZXRWaXNpYmxlOiBmdW5jdGlvbiAoZSwgYykge1xuICAgICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgICBnID0gZC5zZXJpZXMsXG4gICAgICAgICAgICBmID0gZy5jaGFydCxcbiAgICAgICAgICAgIGEgPSBnLm9wdGlvbnMuaWdub3JlSGlkZGVuUG9pbnQ7XG4gICAgICAgIGMgPSB5KGMsIGEpO1xuICAgICAgICBlICE9PSBkLnZpc2libGUgJiYgKGQudmlzaWJsZSA9IGQub3B0aW9ucy52aXNpYmxlID0gZSA9IFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBlID8gIWQudmlzaWJsZSA6IGUsIGcub3B0aW9ucy5kYXRhW2cuZGF0YS5pbmRleE9mKGQpXSA9IGQub3B0aW9ucywgW1wiZ3JhcGhpY1wiLCBcImRhdGFMYWJlbFwiLCBcImNvbm5lY3RvclwiLCBcInNoYWRvd0dyb3VwXCJdLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBpZiAoZFthXSkgZFthXVtlID8gXCJzaG93XCIgOiBcImhpZGVcIl0oITApO1xuICAgICAgICB9KSwgZC5sZWdlbmRJdGVtICYmIGYubGVnZW5kLmNvbG9yaXplSXRlbShkLCBlKSwgZSB8fCBcImhvdmVyXCIgIT09IGQuc3RhdGUgfHwgZC5zZXRTdGF0ZShcIlwiKSwgYSAmJiAoZy5pc0RpcnR5ID0gITApLCBjICYmIGYucmVkcmF3KCkpO1xuICAgICAgfSxcbiAgICAgIHNsaWNlOiBmdW5jdGlvbiAoZSwgYywgZCkge1xuICAgICAgICB2YXIgZyA9IHRoaXMuc2VyaWVzO1xuICAgICAgICBoKGQsIGcuY2hhcnQpO1xuICAgICAgICB5KGMsICEwKTtcbiAgICAgICAgdGhpcy5zbGljZWQgPSB0aGlzLm9wdGlvbnMuc2xpY2VkID0gRShlKSA/IGUgOiAhdGhpcy5zbGljZWQ7XG4gICAgICAgIGcub3B0aW9ucy5kYXRhW2cuZGF0YS5pbmRleE9mKHRoaXMpXSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdGhpcy5ncmFwaGljLmFuaW1hdGUodGhpcy5nZXRUcmFuc2xhdGUoKSk7XG4gICAgICAgIHRoaXMuc2hhZG93R3JvdXAgJiYgdGhpcy5zaGFkb3dHcm91cC5hbmltYXRlKHRoaXMuZ2V0VHJhbnNsYXRlKCkpO1xuICAgICAgfSxcbiAgICAgIGdldFRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbGljZWQgPyB0aGlzLnNsaWNlZFRyYW5zbGF0aW9uIDoge1xuICAgICAgICAgIHRyYW5zbGF0ZVg6IDAsXG4gICAgICAgICAgdHJhbnNsYXRlWTogMFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGhhbG9QYXRoOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgYyA9IHRoaXMuc2hhcGVBcmdzO1xuICAgICAgICByZXR1cm4gdGhpcy5zbGljZWQgfHwgIXRoaXMudmlzaWJsZSA/IFtdIDogdGhpcy5zZXJpZXMuY2hhcnQucmVuZGVyZXIuc3ltYm9scy5hcmMoYy54LCBjLnksIGMuciArIGUsIGMuciArIGUsIHtcbiAgICAgICAgICBpbm5lclI6IGMuciAtIDEsXG4gICAgICAgICAgc3RhcnQ6IGMuc3RhcnQsXG4gICAgICAgICAgZW5kOiBjLmVuZFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBjb25uZWN0b3JTaGFwZXM6IHtcbiAgICAgICAgZml4ZWRPZmZzZXQ6IGZ1bmN0aW9uIChlLCBjLCBkKSB7XG4gICAgICAgICAgdmFyIGcgPSBjLmJyZWFrQXQ7XG4gICAgICAgICAgYyA9IGMudG91Y2hpbmdTbGljZUF0O1xuICAgICAgICAgIHJldHVybiBbXCJNXCIsIGUueCwgZS55XS5jb25jYXQoZC5zb2Z0Q29ubmVjdG9yID8gW1wiQ1wiLCBlLnggKyAoXCJsZWZ0XCIgPT09IGUuYWxpZ25tZW50ID8gLTUgOiA1KSwgZS55LCAyICogZy54IC0gYy54LCAyICogZy55IC0gYy55LCBnLngsIGcueV0gOiBbXCJMXCIsIGcueCwgZy55XSkuY29uY2F0KFtcIkxcIiwgYy54LCBjLnldKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RyYWlnaHQ6IGZ1bmN0aW9uIChlLCBjKSB7XG4gICAgICAgICAgYyA9IGMudG91Y2hpbmdTbGljZUF0O1xuICAgICAgICAgIHJldHVybiBbXCJNXCIsIGUueCwgZS55LCBcIkxcIiwgYy54LCBjLnldO1xuICAgICAgICB9LFxuICAgICAgICBjcm9va2VkTGluZTogZnVuY3Rpb24gKGUsIGMsIGQpIHtcbiAgICAgICAgICBjID0gYy50b3VjaGluZ1NsaWNlQXQ7XG4gICAgICAgICAgdmFyIGcgPSB0aGlzLnNlcmllcyxcbiAgICAgICAgICAgICAgZiA9IGcuY2VudGVyWzBdLFxuICAgICAgICAgICAgICBhID0gZy5jaGFydC5wbG90V2lkdGgsXG4gICAgICAgICAgICAgIGsgPSBnLmNoYXJ0LnBsb3RMZWZ0O1xuICAgICAgICAgIGcgPSBlLmFsaWdubWVudDtcbiAgICAgICAgICB2YXIgaCA9IHRoaXMuc2hhcGVBcmdzLnI7XG4gICAgICAgICAgZCA9IHQoZC5jcm9va0Rpc3RhbmNlLCAxKTtcbiAgICAgICAgICBkID0gXCJsZWZ0XCIgPT09IGcgPyBmICsgaCArIChhICsgayAtIGYgLSBoKSAqICgxIC0gZCkgOiBrICsgKGYgLSBoKSAqIGQ7XG4gICAgICAgICAgZiA9IFtcIkxcIiwgZCwgZS55XTtcbiAgICAgICAgICBpZiAoXCJsZWZ0XCIgPT09IGcgPyBkID4gZS54IHx8IGQgPCBjLnggOiBkIDwgZS54IHx8IGQgPiBjLngpIGYgPSBbXTtcbiAgICAgICAgICByZXR1cm4gW1wiTVwiLCBlLngsIGUueV0uY29uY2F0KGYpLmNvbmNhdChbXCJMXCIsIGMueCwgYy55XSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXRDb25uZWN0b3JQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5sYWJlbFBvc2l0aW9uLFxuICAgICAgICAgICAgYyA9IHRoaXMuc2VyaWVzLm9wdGlvbnMuZGF0YUxhYmVscyxcbiAgICAgICAgICAgIGQgPSBjLmNvbm5lY3RvclNoYXBlLFxuICAgICAgICAgICAgZyA9IHRoaXMuY29ubmVjdG9yU2hhcGVzO1xuICAgICAgICBnW2RdICYmIChkID0gZ1tkXSk7XG4gICAgICAgIHJldHVybiBkLmNhbGwodGhpcywge1xuICAgICAgICAgIHg6IGUuZmluYWwueCxcbiAgICAgICAgICB5OiBlLmZpbmFsLnksXG4gICAgICAgICAgYWxpZ25tZW50OiBlLmFsaWdubWVudFxuICAgICAgICB9LCBlLmNvbm5lY3RvclBvc2l0aW9uLCBjKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcIlwiO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL0RhdGFMYWJlbHMuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcpIHtcbiAgICB2YXIgciA9IGcuYW5pbU9iamVjdCxcbiAgICAgICAgdSA9IGcuYXJyYXlNYXgsXG4gICAgICAgIEkgPSBnLmNsYW1wLFxuICAgICAgICBNID0gZy5kZWZpbmVkLFxuICAgICAgICBFID0gZy5leHRlbmQsXG4gICAgICAgIEEgPSBnLmZvcm1hdCxcbiAgICAgICAgRyA9IGcuaXNBcnJheSxcbiAgICAgICAgSiA9IGcubWVyZ2UsXG4gICAgICAgIHkgPSBnLm9iamVjdEVhY2gsXG4gICAgICAgIHQgPSBnLnBpY2ssXG4gICAgICAgIEQgPSBnLnJlbGF0aXZlTGVuZ3RoLFxuICAgICAgICBoID0gZy5zcGxhdCxcbiAgICAgICAgTiA9IGcuc3RhYmxlU29ydDtcbiAgICBnID0gZC5ub29wO1xuICAgIHZhciBxID0gZC5TZXJpZXMsXG4gICAgICAgIFAgPSBkLnNlcmllc1R5cGVzO1xuXG4gICAgZC5kaXN0cmlidXRlID0gZnVuY3Rpb24gKGUsIGMsIGcpIHtcbiAgICAgIGZ1bmN0aW9uIGgoYSwgYykge1xuICAgICAgICByZXR1cm4gYS50YXJnZXQgLSBjLnRhcmdldDtcbiAgICAgIH1cblxuICAgICAgdmFyIGYsXG4gICAgICAgICAgYSA9ICEwLFxuICAgICAgICAgIGsgPSBlLFxuICAgICAgICAgIHYgPSBbXTtcbiAgICAgIHZhciBxID0gMDtcbiAgICAgIHZhciB3ID0gay5yZWR1Y2VkTGVuIHx8IGM7XG5cbiAgICAgIGZvciAoZiA9IGUubGVuZ3RoOyBmLS07KSBxICs9IGVbZl0uc2l6ZTtcblxuICAgICAgaWYgKHEgPiB3KSB7XG4gICAgICAgIE4oZSwgZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgICByZXR1cm4gKGMucmFuayB8fCAwKSAtIChhLnJhbmsgfHwgMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAocSA9IGYgPSAwOyBxIDw9IHc7KSBxICs9IGVbZl0uc2l6ZSwgZisrO1xuXG4gICAgICAgIHYgPSBlLnNwbGljZShmIC0gMSwgZS5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBOKGUsIGgpO1xuXG4gICAgICBmb3IgKGUgPSBlLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNpemU6IGEuc2l6ZSxcbiAgICAgICAgICB0YXJnZXRzOiBbYS50YXJnZXRdLFxuICAgICAgICAgIGFsaWduOiB0KGEuYWxpZ24sIC41KVxuICAgICAgICB9O1xuICAgICAgfSk7IGE7KSB7XG4gICAgICAgIGZvciAoZiA9IGUubGVuZ3RoOyBmLS07KSBhID0gZVtmXSwgcSA9IChNYXRoLm1pbi5hcHBseSgwLCBhLnRhcmdldHMpICsgTWF0aC5tYXguYXBwbHkoMCwgYS50YXJnZXRzKSkgLyAyLCBhLnBvcyA9IEkocSAtIGEuc2l6ZSAqIGEuYWxpZ24sIDAsIGMgLSBhLnNpemUpO1xuXG4gICAgICAgIGYgPSBlLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGEgPSAhMTsgZi0tOykgMCA8IGYgJiYgZVtmIC0gMV0ucG9zICsgZVtmIC0gMV0uc2l6ZSA+IGVbZl0ucG9zICYmIChlW2YgLSAxXS5zaXplICs9IGVbZl0uc2l6ZSwgZVtmIC0gMV0udGFyZ2V0cyA9IGVbZiAtIDFdLnRhcmdldHMuY29uY2F0KGVbZl0udGFyZ2V0cyksIGVbZiAtIDFdLmFsaWduID0gLjUsIGVbZiAtIDFdLnBvcyArIGVbZiAtIDFdLnNpemUgPiBjICYmIChlW2YgLSAxXS5wb3MgPSBjIC0gZVtmIC0gMV0uc2l6ZSksIGUuc3BsaWNlKGYsIDEpLCBhID0gITApO1xuICAgICAgfVxuXG4gICAgICBrLnB1c2guYXBwbHkoaywgdik7XG4gICAgICBmID0gMDtcbiAgICAgIGUuc29tZShmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgZSA9IDA7XG4gICAgICAgIGlmIChhLnRhcmdldHMuc29tZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAga1tmXS5wb3MgPSBhLnBvcyArIGU7XG4gICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBnICYmIE1hdGguYWJzKGtbZl0ucG9zIC0ga1tmXS50YXJnZXQpID4gZykgcmV0dXJuIGsuc2xpY2UoMCwgZiArIDEpLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBhLnBvcztcbiAgICAgICAgICB9KSwgay5yZWR1Y2VkTGVuID0gKGsucmVkdWNlZExlbiB8fCBjKSAtIC4xICogYywgay5yZWR1Y2VkTGVuID4gLjEgKiBjICYmIGQuZGlzdHJpYnV0ZShrLCBjLCBnKSwgITA7XG4gICAgICAgICAgZSArPSBrW2ZdLnNpemU7XG4gICAgICAgICAgZisrO1xuICAgICAgICB9KSkgcmV0dXJuICEwO1xuICAgICAgfSk7XG4gICAgICBOKGssIGgpO1xuICAgIH07XG5cbiAgICBxLnByb3RvdHlwZS5kcmF3RGF0YUxhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIGUoYSwgYykge1xuICAgICAgICB2YXIgYiA9IGMuZmlsdGVyO1xuICAgICAgICByZXR1cm4gYiA/IChjID0gYi5vcGVyYXRvciwgYSA9IGFbYi5wcm9wZXJ0eV0sIGIgPSBiLnZhbHVlLCBcIj5cIiA9PT0gYyAmJiBhID4gYiB8fCBcIjxcIiA9PT0gYyAmJiBhIDwgYiB8fCBcIj49XCIgPT09IGMgJiYgYSA+PSBiIHx8IFwiPD1cIiA9PT0gYyAmJiBhIDw9IGIgfHwgXCI9PVwiID09PSBjICYmIGEgPT0gYiB8fCBcIj09PVwiID09PSBjICYmIGEgPT09IGIgPyAhMCA6ICExKSA6ICEwO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjKGEsIGMpIHtcbiAgICAgICAgdmFyIGIgPSBbXSxcbiAgICAgICAgICAgIGU7XG4gICAgICAgIGlmIChHKGEpICYmICFHKGMpKSBiID0gYS5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICByZXR1cm4gSihhLCBjKTtcbiAgICAgICAgfSk7ZWxzZSBpZiAoRyhjKSAmJiAhRyhhKSkgYiA9IGMubWFwKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgcmV0dXJuIEooYSwgYik7XG4gICAgICAgIH0pO2Vsc2UgaWYgKEcoYSkgfHwgRyhjKSkgZm9yIChlID0gTWF0aC5tYXgoYS5sZW5ndGgsIGMubGVuZ3RoKTsgZS0tOykgYltlXSA9IEooYVtlXSwgY1tlXSk7ZWxzZSBiID0gSihhLCBjKTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG5cbiAgICAgIHZhciBnID0gdGhpcyxcbiAgICAgICAgICBuID0gZy5jaGFydCxcbiAgICAgICAgICBmID0gZy5vcHRpb25zLFxuICAgICAgICAgIGEgPSBmLmRhdGFMYWJlbHMsXG4gICAgICAgICAgbCA9IGcucG9pbnRzLFxuICAgICAgICAgIHYsXG4gICAgICAgICAgcSA9IGcuaGFzUmVuZGVyZWQgfHwgMCxcbiAgICAgICAgICB3ID0gcihmLmFuaW1hdGlvbikuZHVyYXRpb24sXG4gICAgICAgICAgdSA9IE1hdGgubWluKHcsIDIwMCksXG4gICAgICAgICAgTCA9ICFuLnJlbmRlcmVyLmZvckV4cG9ydCAmJiB0KGEuZGVmZXIsIDAgPCB1KSxcbiAgICAgICAgICBEID0gbi5yZW5kZXJlcjtcbiAgICAgIGEgPSBjKGMobi5vcHRpb25zLnBsb3RPcHRpb25zICYmIG4ub3B0aW9ucy5wbG90T3B0aW9ucy5zZXJpZXMgJiYgbi5vcHRpb25zLnBsb3RPcHRpb25zLnNlcmllcy5kYXRhTGFiZWxzLCBuLm9wdGlvbnMucGxvdE9wdGlvbnMgJiYgbi5vcHRpb25zLnBsb3RPcHRpb25zW2cudHlwZV0gJiYgbi5vcHRpb25zLnBsb3RPcHRpb25zW2cudHlwZV0uZGF0YUxhYmVscyksIGEpO1xuICAgICAgZC5maXJlRXZlbnQodGhpcywgXCJkcmF3RGF0YUxhYmVsc1wiKTtcblxuICAgICAgaWYgKEcoYSkgfHwgYS5lbmFibGVkIHx8IGcuX2hhc1BvaW50TGFiZWxzKSB7XG4gICAgICAgIHZhciBIID0gZy5wbG90R3JvdXAoXCJkYXRhTGFiZWxzR3JvdXBcIiwgXCJkYXRhLWxhYmVsc1wiLCBMICYmICFxID8gXCJoaWRkZW5cIiA6IFwiaW5oZXJpdFwiLCBhLnpJbmRleCB8fCA2KTtcbiAgICAgICAgTCAmJiAoSC5hdHRyKHtcbiAgICAgICAgICBvcGFjaXR5OiArcVxuICAgICAgICB9KSwgcSB8fCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYSA9IGcuZGF0YUxhYmVsc0dyb3VwO1xuICAgICAgICAgIGEgJiYgKGcudmlzaWJsZSAmJiBILnNob3coITApLCBhW2YuYW5pbWF0aW9uID8gXCJhbmltYXRlXCIgOiBcImF0dHJcIl0oe1xuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiB1XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LCB3IC0gdSkpO1xuICAgICAgICBsLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICB2ID0gaChjKGEsIGQuZGxPcHRpb25zIHx8IGQub3B0aW9ucyAmJiBkLm9wdGlvbnMuZGF0YUxhYmVscykpO1xuICAgICAgICAgIHYuZm9yRWFjaChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgdmFyIGMgPSBhLmVuYWJsZWQgJiYgKCFkLmlzTnVsbCB8fCBkLmRhdGFMYWJlbE9uTnVsbCkgJiYgZShkLCBhKSxcbiAgICAgICAgICAgICAgICBoID0gZC5kYXRhTGFiZWxzID8gZC5kYXRhTGFiZWxzW2JdIDogZC5kYXRhTGFiZWwsXG4gICAgICAgICAgICAgICAgayA9IGQuY29ubmVjdG9ycyA/IGQuY29ubmVjdG9yc1tiXSA6IGQuY29ubmVjdG9yLFxuICAgICAgICAgICAgICAgIGwgPSB0KGEuZGlzdGFuY2UsIGQubGFiZWxEaXN0YW5jZSksXG4gICAgICAgICAgICAgICAgcCA9ICFoO1xuXG4gICAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgICB2YXIgdiA9IGQuZ2V0TGFiZWxDb25maWcoKTtcbiAgICAgICAgICAgICAgdmFyIG0gPSB0KGFbZC5mb3JtYXRQcmVmaXggKyBcIkZvcm1hdFwiXSwgYS5mb3JtYXQpO1xuICAgICAgICAgICAgICB2ID0gTShtKSA/IEEobSwgdiwgbikgOiAoYVtkLmZvcm1hdFByZWZpeCArIFwiRm9ybWF0dGVyXCJdIHx8IGEuZm9ybWF0dGVyKS5jYWxsKHYsIGEpO1xuICAgICAgICAgICAgICBtID0gYS5zdHlsZTtcbiAgICAgICAgICAgICAgdmFyIHEgPSBhLnJvdGF0aW9uO1xuICAgICAgICAgICAgICBuLnN0eWxlZE1vZGUgfHwgKG0uY29sb3IgPSB0KGEuY29sb3IsIG0uY29sb3IsIGcuY29sb3IsIFwiIzAwMDAwMFwiKSwgXCJjb250cmFzdFwiID09PSBtLmNvbG9yID8gKGQuY29udHJhc3RDb2xvciA9IEQuZ2V0Q29udHJhc3QoZC5jb2xvciB8fCBnLmNvbG9yKSwgbS5jb2xvciA9ICFNKGwpICYmIGEuaW5zaWRlIHx8IDAgPiBsIHx8IGYuc3RhY2tpbmcgPyBkLmNvbnRyYXN0Q29sb3IgOiBcIiMwMDAwMDBcIikgOiBkZWxldGUgZC5jb250cmFzdENvbG9yLCBmLmN1cnNvciAmJiAobS5jdXJzb3IgPSBmLmN1cnNvcikpO1xuICAgICAgICAgICAgICB2YXIgdyA9IHtcbiAgICAgICAgICAgICAgICByOiBhLmJvcmRlclJhZGl1cyB8fCAwLFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBxLFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IGEucGFkZGluZyxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IDFcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgbi5zdHlsZWRNb2RlIHx8ICh3LmZpbGwgPSBhLmJhY2tncm91bmRDb2xvciwgdy5zdHJva2UgPSBhLmJvcmRlckNvbG9yLCB3W1wic3Ryb2tlLXdpZHRoXCJdID0gYS5ib3JkZXJXaWR0aCk7XG4gICAgICAgICAgICAgIHkodywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgYSAmJiBkZWxldGUgd1tiXTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICFoIHx8IGMgJiYgTSh2KSA/IGMgJiYgTSh2KSAmJiAoaCA/IHcudGV4dCA9IHYgOiAoZC5kYXRhTGFiZWxzID0gZC5kYXRhTGFiZWxzIHx8IFtdLCBoID0gZC5kYXRhTGFiZWxzW2JdID0gcSA/IEQudGV4dCh2LCAwLCAtOTk5OSwgYS51c2VIVE1MKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtZGF0YS1sYWJlbFwiKSA6IEQubGFiZWwodiwgMCwgLTk5OTksIGEuc2hhcGUsIG51bGwsIG51bGwsIGEudXNlSFRNTCwgbnVsbCwgXCJkYXRhLWxhYmVsXCIpLCBiIHx8IChkLmRhdGFMYWJlbCA9IGgpLCBoLmFkZENsYXNzKFwiIGhpZ2hjaGFydHMtZGF0YS1sYWJlbC1jb2xvci1cIiArIGQuY29sb3JJbmRleCArIFwiIFwiICsgKGEuY2xhc3NOYW1lIHx8IFwiXCIpICsgKGEudXNlSFRNTCA/IFwiIGhpZ2hjaGFydHMtdHJhY2tlclwiIDogXCJcIikpKSwgaC5vcHRpb25zID0gYSwgaC5hdHRyKHcpLCBuLnN0eWxlZE1vZGUgfHwgaC5jc3MobSkuc2hhZG93KGEuc2hhZG93KSwgaC5hZGRlZCB8fCBoLmFkZChIKSwgYS50ZXh0UGF0aCAmJiAhYS51c2VIVE1MICYmIChoLnNldFRleHRQYXRoKGQuZ2V0RGF0YUxhYmVsUGF0aCAmJiBkLmdldERhdGFMYWJlbFBhdGgoaCkgfHwgZC5ncmFwaGljLCBhLnRleHRQYXRoKSwgZC5kYXRhTGFiZWxQYXRoICYmICFhLnRleHRQYXRoLmVuYWJsZWQgJiYgKGQuZGF0YUxhYmVsUGF0aCA9IGQuZGF0YUxhYmVsUGF0aC5kZXN0cm95KCkpKSwgZy5hbGlnbkRhdGFMYWJlbChkLCBoLCBhLCBudWxsLCBwKSkgOiAoZC5kYXRhTGFiZWwgPSBkLmRhdGFMYWJlbCAmJiBkLmRhdGFMYWJlbC5kZXN0cm95KCksIGQuZGF0YUxhYmVscyAmJiAoMSA9PT0gZC5kYXRhTGFiZWxzLmxlbmd0aCA/IGRlbGV0ZSBkLmRhdGFMYWJlbHMgOiBkZWxldGUgZC5kYXRhTGFiZWxzW2JdKSwgYiB8fCBkZWxldGUgZC5kYXRhTGFiZWwsIGsgJiYgKGQuY29ubmVjdG9yID0gZC5jb25uZWN0b3IuZGVzdHJveSgpLCBkLmNvbm5lY3RvcnMgJiYgKDEgPT09IGQuY29ubmVjdG9ycy5sZW5ndGggPyBkZWxldGUgZC5jb25uZWN0b3JzIDogZGVsZXRlIGQuY29ubmVjdG9yc1tiXSkpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGQuZmlyZUV2ZW50KHRoaXMsIFwiYWZ0ZXJEcmF3RGF0YUxhYmVsc1wiKTtcbiAgICB9O1xuXG4gICAgcS5wcm90b3R5cGUuYWxpZ25EYXRhTGFiZWwgPSBmdW5jdGlvbiAoZCwgYywgZywgaCwgZikge1xuICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgIGUgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgIGsgPSB0aGlzLmlzQ2FydGVzaWFuICYmIGUuaW52ZXJ0ZWQsXG4gICAgICAgICAgbiA9IHRoaXMuZW5hYmxlZERhdGFTb3J0aW5nLFxuICAgICAgICAgIHEgPSB0KGQuZGxCb3ggJiYgZC5kbEJveC5jZW50ZXJYLCBkLnBsb3RYLCAtOTk5OSksXG4gICAgICAgICAgciA9IHQoZC5wbG90WSwgLTk5OTkpLFxuICAgICAgICAgIHUgPSBjLmdldEJCb3goKSxcbiAgICAgICAgICB5ID0gZy5yb3RhdGlvbixcbiAgICAgICAgICBBID0gZy5hbGlnbixcbiAgICAgICAgICBLID0gZS5pc0luc2lkZVBsb3QocSwgTWF0aC5yb3VuZChyKSwgayksXG4gICAgICAgICAgcCA9IFwianVzdGlmeVwiID09PSB0KGcub3ZlcmZsb3csIG4gPyBcIm5vbmVcIiA6IFwianVzdGlmeVwiKSxcbiAgICAgICAgICBiID0gdGhpcy52aXNpYmxlICYmICExICE9PSBkLnZpc2libGUgJiYgKGQuc2VyaWVzLmZvcmNlREwgfHwgbiAmJiAhcCB8fCBLIHx8IGcuaW5zaWRlICYmIGggJiYgZS5pc0luc2lkZVBsb3QocSwgayA/IGgueCArIDEgOiBoLnkgKyBoLmhlaWdodCAtIDEsIGspKTtcblxuICAgICAgdmFyIEMgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICBuICYmIGEueEF4aXMgJiYgIXAgJiYgYS5zZXREYXRhTGFiZWxTdGFydFBvcyhkLCBjLCBmLCBLLCBiKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChiKSB7XG4gICAgICAgIHZhciB4ID0gZS5yZW5kZXJlci5mb250TWV0cmljcyhlLnN0eWxlZE1vZGUgPyB2b2lkIDAgOiBnLnN0eWxlLmZvbnRTaXplLCBjKS5iO1xuICAgICAgICBoID0gRSh7XG4gICAgICAgICAgeDogayA/IHRoaXMueUF4aXMubGVuIC0gciA6IHEsXG4gICAgICAgICAgeTogTWF0aC5yb3VuZChrID8gdGhpcy54QXhpcy5sZW4gLSBxIDogciksXG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH0sIGgpO1xuICAgICAgICBFKGcsIHtcbiAgICAgICAgICB3aWR0aDogdS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHUuaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICB5ID8gKHAgPSAhMSwgcSA9IGUucmVuZGVyZXIucm90Q29ycih4LCB5KSwgcSA9IHtcbiAgICAgICAgICB4OiBoLnggKyBnLnggKyBoLndpZHRoIC8gMiArIHEueCxcbiAgICAgICAgICB5OiBoLnkgKyBnLnkgKyB7XG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICBtaWRkbGU6IC41LFxuICAgICAgICAgICAgYm90dG9tOiAxXG4gICAgICAgICAgfVtnLnZlcnRpY2FsQWxpZ25dICogaC5oZWlnaHRcbiAgICAgICAgfSwgQyhxKSwgY1tmID8gXCJhdHRyXCIgOiBcImFuaW1hdGVcIl0ocSkuYXR0cih7XG4gICAgICAgICAgYWxpZ246IEFcbiAgICAgICAgfSksIEMgPSAoeSArIDcyMCkgJSAzNjAsIEMgPSAxODAgPCBDICYmIDM2MCA+IEMsIFwibGVmdFwiID09PSBBID8gcS55IC09IEMgPyB1LmhlaWdodCA6IDAgOiBcImNlbnRlclwiID09PSBBID8gKHEueCAtPSB1LndpZHRoIC8gMiwgcS55IC09IHUuaGVpZ2h0IC8gMikgOiBcInJpZ2h0XCIgPT09IEEgJiYgKHEueCAtPSB1LndpZHRoLCBxLnkgLT0gQyA/IDAgOiB1LmhlaWdodCksIGMucGxhY2VkID0gITAsIGMuYWxpZ25BdHRyID0gcSkgOiAoQyhoKSwgYy5hbGlnbihnLCBudWxsLCBoKSwgcSA9IGMuYWxpZ25BdHRyKTtcbiAgICAgICAgcCAmJiAwIDw9IGguaGVpZ2h0ID8gdGhpcy5qdXN0aWZ5RGF0YUxhYmVsKGMsIGcsIHEsIHUsIGgsIGYpIDogdChnLmNyb3AsICEwKSAmJiAoYiA9IGUuaXNJbnNpZGVQbG90KHEueCwgcS55KSAmJiBlLmlzSW5zaWRlUGxvdChxLnggKyB1LndpZHRoLCBxLnkgKyB1LmhlaWdodCkpO1xuICAgICAgICBpZiAoZy5zaGFwZSAmJiAheSkgY1tmID8gXCJhdHRyXCIgOiBcImFuaW1hdGVcIl0oe1xuICAgICAgICAgIGFuY2hvclg6IGsgPyBlLnBsb3RXaWR0aCAtIGQucGxvdFkgOiBkLnBsb3RYLFxuICAgICAgICAgIGFuY2hvclk6IGsgPyBlLnBsb3RIZWlnaHQgLSBkLnBsb3RYIDogZC5wbG90WVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZiAmJiBuICYmIChjLnBsYWNlZCA9ICExKTtcbiAgICAgIGIgfHwgbiAmJiAhcCB8fCAoYy5oaWRlKCEwKSwgYy5wbGFjZWQgPSAhMSk7XG4gICAgfTtcblxuICAgIHEucHJvdG90eXBlLnNldERhdGFMYWJlbFN0YXJ0UG9zID0gZnVuY3Rpb24gKGQsIGMsIGcsIGgsIGYpIHtcbiAgICAgIHZhciBhID0gdGhpcy5jaGFydCxcbiAgICAgICAgICBlID0gYS5pbnZlcnRlZCxcbiAgICAgICAgICBrID0gdGhpcy54QXhpcyxcbiAgICAgICAgICBuID0gay5yZXZlcnNlZCxcbiAgICAgICAgICBxID0gZSA/IGMuaGVpZ2h0IC8gMiA6IGMud2lkdGggLyAyO1xuICAgICAgZCA9IChkID0gZC5wb2ludFdpZHRoKSA/IGQgLyAyIDogMDtcbiAgICAgIGsgPSBlID8gZi54IDogbiA/IC1xIC0gZCA6IGsud2lkdGggLSBxICsgZDtcbiAgICAgIGYgPSBlID8gbiA/IHRoaXMueUF4aXMuaGVpZ2h0IC0gcSArIGQgOiAtcSAtIGQgOiBmLnk7XG4gICAgICBjLnN0YXJ0WFBvcyA9IGs7XG4gICAgICBjLnN0YXJ0WVBvcyA9IGY7XG4gICAgICBoID8gXCJoaWRkZW5cIiA9PT0gYy52aXNpYmlsaXR5ICYmIChjLnNob3coKSwgYy5hdHRyKHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSkuYW5pbWF0ZSh7XG4gICAgICAgIG9wYWNpdHk6IDFcbiAgICAgIH0pKSA6IGMuYXR0cih7XG4gICAgICAgIG9wYWNpdHk6IDFcbiAgICAgIH0pLmFuaW1hdGUoe1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9LCB2b2lkIDAsIGMuaGlkZSk7XG4gICAgICBhLmhhc1JlbmRlcmVkICYmIChnICYmIGMuYXR0cih7XG4gICAgICAgIHg6IGMuc3RhcnRYUG9zLFxuICAgICAgICB5OiBjLnN0YXJ0WVBvc1xuICAgICAgfSksIGMucGxhY2VkID0gITApO1xuICAgIH07XG5cbiAgICBxLnByb3RvdHlwZS5qdXN0aWZ5RGF0YUxhYmVsID0gZnVuY3Rpb24gKGQsIGMsIGcsIGgsIGYsIGEpIHtcbiAgICAgIHZhciBlID0gdGhpcy5jaGFydCxcbiAgICAgICAgICBrID0gYy5hbGlnbixcbiAgICAgICAgICBuID0gYy52ZXJ0aWNhbEFsaWduLFxuICAgICAgICAgIHEgPSBkLmJveCA/IDAgOiBkLnBhZGRpbmcgfHwgMDtcbiAgICAgIHZhciByID0gZy54ICsgcTtcblxuICAgICAgaWYgKDAgPiByKSB7XG4gICAgICAgIFwicmlnaHRcIiA9PT0gayA/IChjLmFsaWduID0gXCJsZWZ0XCIsIGMuaW5zaWRlID0gITApIDogYy54ID0gLXI7XG4gICAgICAgIHZhciB0ID0gITA7XG4gICAgICB9XG5cbiAgICAgIHIgPSBnLnggKyBoLndpZHRoIC0gcTtcbiAgICAgIHIgPiBlLnBsb3RXaWR0aCAmJiAoXCJsZWZ0XCIgPT09IGsgPyAoYy5hbGlnbiA9IFwicmlnaHRcIiwgYy5pbnNpZGUgPSAhMCkgOiBjLnggPSBlLnBsb3RXaWR0aCAtIHIsIHQgPSAhMCk7XG4gICAgICByID0gZy55ICsgcTtcbiAgICAgIDAgPiByICYmIChcImJvdHRvbVwiID09PSBuID8gKGMudmVydGljYWxBbGlnbiA9IFwidG9wXCIsIGMuaW5zaWRlID0gITApIDogYy55ID0gLXIsIHQgPSAhMCk7XG4gICAgICByID0gZy55ICsgaC5oZWlnaHQgLSBxO1xuICAgICAgciA+IGUucGxvdEhlaWdodCAmJiAoXCJ0b3BcIiA9PT0gbiA/IChjLnZlcnRpY2FsQWxpZ24gPSBcImJvdHRvbVwiLCBjLmluc2lkZSA9ICEwKSA6IGMueSA9IGUucGxvdEhlaWdodCAtIHIsIHQgPSAhMCk7XG4gICAgICB0ICYmIChkLnBsYWNlZCA9ICFhLCBkLmFsaWduKGMsIG51bGwsIGYpKTtcbiAgICAgIHJldHVybiB0O1xuICAgIH07XG5cbiAgICBQLnBpZSAmJiAoUC5waWUucHJvdG90eXBlLmRhdGFMYWJlbFBvc2l0aW9uZXJzID0ge1xuICAgICAgcmFkaWFsRGlzdHJpYnV0aW9uWTogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQudG9wICsgZC5kaXN0cmlidXRlQm94LnBvcztcbiAgICAgIH0sXG4gICAgICByYWRpYWxEaXN0cmlidXRpb25YOiBmdW5jdGlvbiAoZCwgYywgZywgaCkge1xuICAgICAgICByZXR1cm4gZC5nZXRYKGcgPCBjLnRvcCArIDIgfHwgZyA+IGMuYm90dG9tIC0gMiA/IGggOiBnLCBjLmhhbGYsIGMpO1xuICAgICAgfSxcbiAgICAgIGp1c3RpZnk6IGZ1bmN0aW9uIChkLCBjLCBnKSB7XG4gICAgICAgIHJldHVybiBnWzBdICsgKGQuaGFsZiA/IC0xIDogMSkgKiAoYyArIGQubGFiZWxEaXN0YW5jZSk7XG4gICAgICB9LFxuICAgICAgYWxpZ25Ub1Bsb3RFZGdlczogZnVuY3Rpb24gKGQsIGMsIGcsIGgpIHtcbiAgICAgICAgZCA9IGQuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICByZXR1cm4gYyA/IGQgKyBoIDogZyAtIGQgLSBoO1xuICAgICAgfSxcbiAgICAgIGFsaWduVG9Db25uZWN0b3JzOiBmdW5jdGlvbiAoZCwgYywgZywgaCkge1xuICAgICAgICB2YXIgZSA9IDAsXG4gICAgICAgICAgICBhO1xuICAgICAgICBkLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBhID0gYy5kYXRhTGFiZWwuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgICAgIGEgPiBlICYmIChlID0gYSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYyA/IGUgKyBoIDogZyAtIGUgLSBoO1xuICAgICAgfVxuICAgIH0sIFAucGllLnByb3RvdHlwZS5kcmF3RGF0YUxhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgICBjID0gZS5kYXRhLFxuICAgICAgICAgIGcsXG4gICAgICAgICAgaCA9IGUuY2hhcnQsXG4gICAgICAgICAgZiA9IGUub3B0aW9ucy5kYXRhTGFiZWxzIHx8IHt9LFxuICAgICAgICAgIGEgPSBmLmNvbm5lY3RvclBhZGRpbmcsXG4gICAgICAgICAgbCxcbiAgICAgICAgICB2ID0gaC5wbG90V2lkdGgsXG4gICAgICAgICAgciA9IGgucGxvdEhlaWdodCxcbiAgICAgICAgICB3ID0gaC5wbG90TGVmdCxcbiAgICAgICAgICB5ID0gTWF0aC5yb3VuZChoLmNoYXJ0V2lkdGggLyAzKSxcbiAgICAgICAgICBBLFxuICAgICAgICAgIEQgPSBlLmNlbnRlcixcbiAgICAgICAgICBIID0gRFsyXSAvIDIsXG4gICAgICAgICAgSyA9IERbMV0sXG4gICAgICAgICAgcCxcbiAgICAgICAgICBiLFxuICAgICAgICAgIEMsXG4gICAgICAgICAgeCxcbiAgICAgICAgICBHID0gW1tdLCBbXV0sXG4gICAgICAgICAgRSxcbiAgICAgICAgICBOLFxuICAgICAgICAgIEksXG4gICAgICAgICAgbSxcbiAgICAgICAgICBQID0gWzAsIDAsIDAsIDBdLFxuICAgICAgICAgIFMgPSBlLmRhdGFMYWJlbFBvc2l0aW9uZXJzLFxuICAgICAgICAgIFc7XG4gICAgICBlLnZpc2libGUgJiYgKGYuZW5hYmxlZCB8fCBlLl9oYXNQb2ludExhYmVscykgJiYgKGMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICBhLmRhdGFMYWJlbCAmJiBhLnZpc2libGUgJiYgYS5kYXRhTGFiZWwuc2hvcnRlbmVkICYmIChhLmRhdGFMYWJlbC5hdHRyKHtcbiAgICAgICAgICB3aWR0aDogXCJhdXRvXCJcbiAgICAgICAgfSkuY3NzKHtcbiAgICAgICAgICB3aWR0aDogXCJhdXRvXCIsXG4gICAgICAgICAgdGV4dE92ZXJmbG93OiBcImNsaXBcIlxuICAgICAgICB9KSwgYS5kYXRhTGFiZWwuc2hvcnRlbmVkID0gITEpO1xuICAgICAgfSksIHEucHJvdG90eXBlLmRyYXdEYXRhTGFiZWxzLmFwcGx5KGUpLCBjLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgYS5kYXRhTGFiZWwgJiYgKGEudmlzaWJsZSA/IChHW2EuaGFsZl0ucHVzaChhKSwgYS5kYXRhTGFiZWwuX3BvcyA9IG51bGwsICFNKGYuc3R5bGUud2lkdGgpICYmICFNKGEub3B0aW9ucy5kYXRhTGFiZWxzICYmIGEub3B0aW9ucy5kYXRhTGFiZWxzLnN0eWxlICYmIGEub3B0aW9ucy5kYXRhTGFiZWxzLnN0eWxlLndpZHRoKSAmJiBhLmRhdGFMYWJlbC5nZXRCQm94KCkud2lkdGggPiB5ICYmIChhLmRhdGFMYWJlbC5jc3Moe1xuICAgICAgICAgIHdpZHRoOiAuNyAqIHlcbiAgICAgICAgfSksIGEuZGF0YUxhYmVsLnNob3J0ZW5lZCA9ICEwKSkgOiAoYS5kYXRhTGFiZWwgPSBhLmRhdGFMYWJlbC5kZXN0cm95KCksIGEuZGF0YUxhYmVscyAmJiAxID09PSBhLmRhdGFMYWJlbHMubGVuZ3RoICYmIGRlbGV0ZSBhLmRhdGFMYWJlbHMpKTtcbiAgICAgIH0pLCBHLmZvckVhY2goZnVuY3Rpb24gKGMsIGspIHtcbiAgICAgICAgdmFyIGwgPSBjLmxlbmd0aCxcbiAgICAgICAgICAgIG4gPSBbXSxcbiAgICAgICAgICAgIHE7XG5cbiAgICAgICAgaWYgKGwpIHtcbiAgICAgICAgICBlLnNvcnRCeUFuZ2xlKGMsIGsgLSAuNSk7XG5cbiAgICAgICAgICBpZiAoMCA8IGUubWF4TGFiZWxEaXN0YW5jZSkge1xuICAgICAgICAgICAgdmFyIHUgPSBNYXRoLm1heCgwLCBLIC0gSCAtIGUubWF4TGFiZWxEaXN0YW5jZSk7XG4gICAgICAgICAgICB2YXIgeiA9IE1hdGgubWluKEsgKyBIICsgZS5tYXhMYWJlbERpc3RhbmNlLCBoLnBsb3RIZWlnaHQpO1xuICAgICAgICAgICAgYy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgIDAgPCBhLmxhYmVsRGlzdGFuY2UgJiYgYS5kYXRhTGFiZWwgJiYgKGEudG9wID0gTWF0aC5tYXgoMCwgSyAtIEggLSBhLmxhYmVsRGlzdGFuY2UpLCBhLmJvdHRvbSA9IE1hdGgubWluKEsgKyBIICsgYS5sYWJlbERpc3RhbmNlLCBoLnBsb3RIZWlnaHQpLCBxID0gYS5kYXRhTGFiZWwuZ2V0QkJveCgpLmhlaWdodCB8fCAyMSwgYS5kaXN0cmlidXRlQm94ID0ge1xuICAgICAgICAgICAgICAgIHRhcmdldDogYS5sYWJlbFBvc2l0aW9uLm5hdHVyYWwueSAtIGEudG9wICsgcSAvIDIsXG4gICAgICAgICAgICAgICAgc2l6ZTogcSxcbiAgICAgICAgICAgICAgICByYW5rOiBhLnlcbiAgICAgICAgICAgICAgfSwgbi5wdXNoKGEuZGlzdHJpYnV0ZUJveCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1ID0geiArIHEgLSB1O1xuICAgICAgICAgICAgZC5kaXN0cmlidXRlKG4sIHUsIHUgLyA1KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKG0gPSAwOyBtIDwgbDsgbSsrKSB7XG4gICAgICAgICAgICBnID0gY1ttXTtcbiAgICAgICAgICAgIEMgPSBnLmxhYmVsUG9zaXRpb247XG4gICAgICAgICAgICBwID0gZy5kYXRhTGFiZWw7XG4gICAgICAgICAgICBJID0gITEgPT09IGcudmlzaWJsZSA/IFwiaGlkZGVuXCIgOiBcImluaGVyaXRcIjtcbiAgICAgICAgICAgIE4gPSB1ID0gQy5uYXR1cmFsLnk7XG4gICAgICAgICAgICBuICYmIE0oZy5kaXN0cmlidXRlQm94KSAmJiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGcuZGlzdHJpYnV0ZUJveC5wb3MgPyBJID0gXCJoaWRkZW5cIiA6ICh4ID0gZy5kaXN0cmlidXRlQm94LnNpemUsIE4gPSBTLnJhZGlhbERpc3RyaWJ1dGlvblkoZykpKTtcbiAgICAgICAgICAgIGRlbGV0ZSBnLnBvc2l0aW9uSW5kZXg7XG4gICAgICAgICAgICBpZiAoZi5qdXN0aWZ5KSBFID0gUy5qdXN0aWZ5KGcsIEgsIEQpO2Vsc2Ugc3dpdGNoIChmLmFsaWduVG8pIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNvbm5lY3RvcnNcIjpcbiAgICAgICAgICAgICAgICBFID0gUy5hbGlnblRvQ29ubmVjdG9ycyhjLCBrLCB2LCB3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIFwicGxvdEVkZ2VzXCI6XG4gICAgICAgICAgICAgICAgRSA9IFMuYWxpZ25Ub1Bsb3RFZGdlcyhwLCBrLCB2LCB3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIEUgPSBTLnJhZGlhbERpc3RyaWJ1dGlvblgoZSwgZywgTiwgdSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwLl9hdHRyID0ge1xuICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBJLFxuICAgICAgICAgICAgICBhbGlnbjogQy5hbGlnbm1lbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBXID0gZy5vcHRpb25zLmRhdGFMYWJlbHMgfHwge307XG4gICAgICAgICAgICBwLl9wb3MgPSB7XG4gICAgICAgICAgICAgIHg6IEUgKyB0KFcueCwgZi54KSArICh7XG4gICAgICAgICAgICAgICAgbGVmdDogYSxcbiAgICAgICAgICAgICAgICByaWdodDogLWFcbiAgICAgICAgICAgICAgfVtDLmFsaWdubWVudF0gfHwgMCksXG4gICAgICAgICAgICAgIHk6IE4gKyB0KFcueSwgZi55KSAtIDEwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQy5maW5hbC54ID0gRTtcbiAgICAgICAgICAgIEMuZmluYWwueSA9IE47XG4gICAgICAgICAgICB0KGYuY3JvcCwgITApICYmIChiID0gcC5nZXRCQm94KCkud2lkdGgsIHUgPSBudWxsLCBFIC0gYiA8IGEgJiYgMSA9PT0gayA/ICh1ID0gTWF0aC5yb3VuZChiIC0gRSArIGEpLCBQWzNdID0gTWF0aC5tYXgodSwgUFszXSkpIDogRSArIGIgPiB2IC0gYSAmJiAwID09PSBrICYmICh1ID0gTWF0aC5yb3VuZChFICsgYiAtIHYgKyBhKSwgUFsxXSA9IE1hdGgubWF4KHUsIFBbMV0pKSwgMCA+IE4gLSB4IC8gMiA/IFBbMF0gPSBNYXRoLm1heChNYXRoLnJvdW5kKC1OICsgeCAvIDIpLCBQWzBdKSA6IE4gKyB4IC8gMiA+IHIgJiYgKFBbMl0gPSBNYXRoLm1heChNYXRoLnJvdW5kKE4gKyB4IC8gMiAtIHIpLCBQWzJdKSksIHAuc2lkZU92ZXJmbG93ID0gdSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSwgMCA9PT0gdShQKSB8fCB0aGlzLnZlcmlmeURhdGFMYWJlbE92ZXJmbG93KFApKSAmJiAodGhpcy5wbGFjZURhdGFMYWJlbHMoKSwgdGhpcy5wb2ludHMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICBXID0gSihmLCBhLm9wdGlvbnMuZGF0YUxhYmVscyk7XG5cbiAgICAgICAgaWYgKGwgPSB0KFcuY29ubmVjdG9yV2lkdGgsIDEpKSB7XG4gICAgICAgICAgdmFyIGI7XG4gICAgICAgICAgQSA9IGEuY29ubmVjdG9yO1xuXG4gICAgICAgICAgaWYgKChwID0gYS5kYXRhTGFiZWwpICYmIHAuX3BvcyAmJiBhLnZpc2libGUgJiYgMCA8IGEubGFiZWxEaXN0YW5jZSkge1xuICAgICAgICAgICAgSSA9IHAuX2F0dHIudmlzaWJpbGl0eTtcbiAgICAgICAgICAgIGlmIChiID0gIUEpIGEuY29ubmVjdG9yID0gQSA9IGgucmVuZGVyZXIucGF0aCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1kYXRhLWxhYmVsLWNvbm5lY3RvciAgaGlnaGNoYXJ0cy1jb2xvci1cIiArIGEuY29sb3JJbmRleCArIChhLmNsYXNzTmFtZSA/IFwiIFwiICsgYS5jbGFzc05hbWUgOiBcIlwiKSkuYWRkKGUuZGF0YUxhYmVsc0dyb3VwKSwgaC5zdHlsZWRNb2RlIHx8IEEuYXR0cih7XG4gICAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IGwsXG4gICAgICAgICAgICAgIHN0cm9rZTogVy5jb25uZWN0b3JDb2xvciB8fCBhLmNvbG9yIHx8IFwiIzY2NjY2NlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEFbYiA/IFwiYXR0clwiIDogXCJhbmltYXRlXCJdKHtcbiAgICAgICAgICAgICAgZDogYS5nZXRDb25uZWN0b3JQYXRoKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgQS5hdHRyKFwidmlzaWJpbGl0eVwiLCBJKTtcbiAgICAgICAgICB9IGVsc2UgQSAmJiAoYS5jb25uZWN0b3IgPSBBLmRlc3Ryb3koKSk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9LCBQLnBpZS5wcm90b3R5cGUucGxhY2VEYXRhTGFiZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5wb2ludHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgYyA9IGQuZGF0YUxhYmVsLFxuICAgICAgICAgICAgZTtcbiAgICAgICAgYyAmJiBkLnZpc2libGUgJiYgKChlID0gYy5fcG9zKSA/IChjLnNpZGVPdmVyZmxvdyAmJiAoYy5fYXR0ci53aWR0aCA9IE1hdGgubWF4KGMuZ2V0QkJveCgpLndpZHRoIC0gYy5zaWRlT3ZlcmZsb3csIDApLCBjLmNzcyh7XG4gICAgICAgICAgd2lkdGg6IGMuX2F0dHIud2lkdGggKyBcInB4XCIsXG4gICAgICAgICAgdGV4dE92ZXJmbG93OiAodGhpcy5vcHRpb25zLmRhdGFMYWJlbHMuc3R5bGUgfHwge30pLnRleHRPdmVyZmxvdyB8fCBcImVsbGlwc2lzXCJcbiAgICAgICAgfSksIGMuc2hvcnRlbmVkID0gITApLCBjLmF0dHIoYy5fYXR0ciksIGNbYy5tb3ZlZCA/IFwiYW5pbWF0ZVwiIDogXCJhdHRyXCJdKGUpLCBjLm1vdmVkID0gITApIDogYyAmJiBjLmF0dHIoe1xuICAgICAgICAgIHk6IC05OTk5XG4gICAgICAgIH0pKTtcbiAgICAgICAgZGVsZXRlIGQuZGlzdHJpYnV0ZUJveDtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sIFAucGllLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbCA9IGcsIFAucGllLnByb3RvdHlwZS52ZXJpZnlEYXRhTGFiZWxPdmVyZmxvdyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgYyA9IHRoaXMuY2VudGVyLFxuICAgICAgICAgIGUgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgZyA9IGUuY2VudGVyLFxuICAgICAgICAgIGYgPSBlLm1pblNpemUgfHwgODAsXG4gICAgICAgICAgYSA9IG51bGwgIT09IGUuc2l6ZTtcblxuICAgICAgaWYgKCFhKSB7XG4gICAgICAgIGlmIChudWxsICE9PSBnWzBdKSB2YXIgaCA9IE1hdGgubWF4KGNbMl0gLSBNYXRoLm1heChkWzFdLCBkWzNdKSwgZik7ZWxzZSBoID0gTWF0aC5tYXgoY1syXSAtIGRbMV0gLSBkWzNdLCBmKSwgY1swXSArPSAoZFszXSAtIGRbMV0pIC8gMjtcbiAgICAgICAgbnVsbCAhPT0gZ1sxXSA/IGggPSBJKGgsIGYsIGNbMl0gLSBNYXRoLm1heChkWzBdLCBkWzJdKSkgOiAoaCA9IEkoaCwgZiwgY1syXSAtIGRbMF0gLSBkWzJdKSwgY1sxXSArPSAoZFswXSAtIGRbMl0pIC8gMik7XG4gICAgICAgIGggPCBjWzJdID8gKGNbMl0gPSBoLCBjWzNdID0gTWF0aC5taW4oRChlLmlubmVyU2l6ZSB8fCAwLCBoKSwgaCksIHRoaXMudHJhbnNsYXRlKGMpLCB0aGlzLmRyYXdEYXRhTGFiZWxzICYmIHRoaXMuZHJhd0RhdGFMYWJlbHMoKSkgOiBhID0gITA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhO1xuICAgIH0pO1xuICAgIFAuY29sdW1uICYmIChQLmNvbHVtbi5wcm90b3R5cGUuYWxpZ25EYXRhTGFiZWwgPSBmdW5jdGlvbiAoZCwgYywgZywgaCwgZikge1xuICAgICAgdmFyIGEgPSB0aGlzLmNoYXJ0LmludmVydGVkLFxuICAgICAgICAgIGUgPSBkLnNlcmllcyxcbiAgICAgICAgICBrID0gZC5kbEJveCB8fCBkLnNoYXBlQXJncyxcbiAgICAgICAgICBuID0gdChkLmJlbG93LCBkLnBsb3RZID4gdCh0aGlzLnRyYW5zbGF0ZWRUaHJlc2hvbGQsIGUueUF4aXMubGVuKSksXG4gICAgICAgICAgciA9IHQoZy5pbnNpZGUsICEhdGhpcy5vcHRpb25zLnN0YWNraW5nKTtcbiAgICAgIGsgJiYgKGggPSBKKGspLCAwID4gaC55ICYmIChoLmhlaWdodCArPSBoLnksIGgueSA9IDApLCBrID0gaC55ICsgaC5oZWlnaHQgLSBlLnlBeGlzLmxlbiwgMCA8IGsgJiYgayA8IGguaGVpZ2h0ICYmIChoLmhlaWdodCAtPSBrKSwgYSAmJiAoaCA9IHtcbiAgICAgICAgeDogZS55QXhpcy5sZW4gLSBoLnkgLSBoLmhlaWdodCxcbiAgICAgICAgeTogZS54QXhpcy5sZW4gLSBoLnggLSBoLndpZHRoLFxuICAgICAgICB3aWR0aDogaC5oZWlnaHQsXG4gICAgICAgIGhlaWdodDogaC53aWR0aFxuICAgICAgfSksIHIgfHwgKGEgPyAoaC54ICs9IG4gPyAwIDogaC53aWR0aCwgaC53aWR0aCA9IDApIDogKGgueSArPSBuID8gaC5oZWlnaHQgOiAwLCBoLmhlaWdodCA9IDApKSk7XG4gICAgICBnLmFsaWduID0gdChnLmFsaWduLCAhYSB8fCByID8gXCJjZW50ZXJcIiA6IG4gPyBcInJpZ2h0XCIgOiBcImxlZnRcIik7XG4gICAgICBnLnZlcnRpY2FsQWxpZ24gPSB0KGcudmVydGljYWxBbGlnbiwgYSB8fCByID8gXCJtaWRkbGVcIiA6IG4gPyBcInRvcFwiIDogXCJib3R0b21cIik7XG4gICAgICBxLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbC5jYWxsKHRoaXMsIGQsIGMsIGcsIGgsIGYpO1xuICAgICAgZy5pbnNpZGUgJiYgZC5jb250cmFzdENvbG9yICYmIGMuY3NzKHtcbiAgICAgICAgY29sb3I6IGQuY29udHJhc3RDb2xvclxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICBTKHIsIFwibW9kdWxlcy9vdmVybGFwcGluZy1kYXRhbGFiZWxzLnNyYy5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZykge1xuICAgIHZhciByID0gZy5hZGRFdmVudCxcbiAgICAgICAgdSA9IGcuZmlyZUV2ZW50LFxuICAgICAgICBJID0gZy5pc0FycmF5LFxuICAgICAgICBNID0gZy5vYmplY3RFYWNoLFxuICAgICAgICBFID0gZy5waWNrO1xuICAgIGQgPSBkLkNoYXJ0O1xuICAgIHIoZCwgXCJyZW5kZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGQgPSBbXTtcbiAgICAgICh0aGlzLmxhYmVsQ29sbGVjdG9ycyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoZykge1xuICAgICAgICBkID0gZC5jb25jYXQoZygpKTtcbiAgICAgIH0pO1xuICAgICAgKHRoaXMueUF4aXMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgZy5vcHRpb25zLnN0YWNrTGFiZWxzICYmICFnLm9wdGlvbnMuc3RhY2tMYWJlbHMuYWxsb3dPdmVybGFwICYmIE0oZy5zdGFja3MsIGZ1bmN0aW9uIChnKSB7XG4gICAgICAgICAgTShnLCBmdW5jdGlvbiAoZykge1xuICAgICAgICAgICAgZC5wdXNoKGcubGFiZWwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgKHRoaXMuc2VyaWVzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIHZhciByID0gZy5vcHRpb25zLmRhdGFMYWJlbHM7XG4gICAgICAgIGcudmlzaWJsZSAmJiAoITEgIT09IHIuZW5hYmxlZCB8fCBnLl9oYXNQb2ludExhYmVscykgJiYgKGcubm9kZXMgfHwgZy5wb2ludHMpLmZvckVhY2goZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgICBnLnZpc2libGUgJiYgKEkoZy5kYXRhTGFiZWxzKSA/IGcuZGF0YUxhYmVscyA6IGcuZGF0YUxhYmVsID8gW2cuZGF0YUxhYmVsXSA6IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHIub3B0aW9ucztcbiAgICAgICAgICAgIHIubGFiZWxyYW5rID0gRSh0LmxhYmVscmFuaywgZy5sYWJlbHJhbmssIGcuc2hhcGVBcmdzICYmIGcuc2hhcGVBcmdzLmhlaWdodCk7XG4gICAgICAgICAgICB0LmFsbG93T3ZlcmxhcCB8fCBkLnB1c2gocik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhpZGVPdmVybGFwcGluZ0xhYmVscyhkKTtcbiAgICB9KTtcblxuICAgIGQucHJvdG90eXBlLmhpZGVPdmVybGFwcGluZ0xhYmVscyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgZyA9IHRoaXMsXG4gICAgICAgICAgciA9IGQubGVuZ3RoLFxuICAgICAgICAgIHkgPSBnLnJlbmRlcmVyLFxuICAgICAgICAgIHQsXG4gICAgICAgICAgQSxcbiAgICAgICAgICBoLFxuICAgICAgICAgIEUgPSAhMTtcblxuICAgICAgdmFyIHEgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgZCA9IGMuYm94ID8gMCA6IGMucGFkZGluZyB8fCAwO1xuICAgICAgICB2YXIgZSA9IDA7XG5cbiAgICAgICAgaWYgKGMgJiYgKCFjLmFsaWduQXR0ciB8fCBjLnBsYWNlZCkpIHtcbiAgICAgICAgICB2YXIgZiA9IGMuYWxpZ25BdHRyIHx8IHtcbiAgICAgICAgICAgIHg6IGMuYXR0cihcInhcIiksXG4gICAgICAgICAgICB5OiBjLmF0dHIoXCJ5XCIpXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgYSA9IGMucGFyZW50R3JvdXA7XG4gICAgICAgICAgYy53aWR0aCB8fCAoZSA9IGMuZ2V0QkJveCgpLCBjLndpZHRoID0gZS53aWR0aCwgYy5oZWlnaHQgPSBlLmhlaWdodCwgZSA9IHkuZm9udE1ldHJpY3MobnVsbCwgYy5lbGVtZW50KS5oKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogZi54ICsgKGEudHJhbnNsYXRlWCB8fCAwKSArIGQsXG4gICAgICAgICAgICB5OiBmLnkgKyAoYS50cmFuc2xhdGVZIHx8IDApICsgZCAtIGUsXG4gICAgICAgICAgICB3aWR0aDogYy53aWR0aCAtIDIgKiBkLFxuICAgICAgICAgICAgaGVpZ2h0OiBjLmhlaWdodCAtIDIgKiBkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yIChBID0gMDsgQSA8IHI7IEErKykgaWYgKHQgPSBkW0FdKSB0Lm9sZE9wYWNpdHkgPSB0Lm9wYWNpdHksIHQubmV3T3BhY2l0eSA9IDEsIHQuYWJzb2x1dGVCb3ggPSBxKHQpO1xuXG4gICAgICBkLnNvcnQoZnVuY3Rpb24gKGMsIGQpIHtcbiAgICAgICAgcmV0dXJuIChkLmxhYmVscmFuayB8fCAwKSAtIChjLmxhYmVscmFuayB8fCAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKEEgPSAwOyBBIDwgcjsgQSsrKSB7XG4gICAgICAgIHZhciBJID0gKHEgPSBkW0FdKSAmJiBxLmFic29sdXRlQm94O1xuXG4gICAgICAgIGZvciAodCA9IEEgKyAxOyB0IDwgcjsgKyt0KSB7XG4gICAgICAgICAgdmFyIGUgPSAoaCA9IGRbdF0pICYmIGguYWJzb2x1dGVCb3g7XG4gICAgICAgICAgIUkgfHwgIWUgfHwgcSA9PT0gaCB8fCAwID09PSBxLm5ld09wYWNpdHkgfHwgMCA9PT0gaC5uZXdPcGFjaXR5IHx8IGUueCA+IEkueCArIEkud2lkdGggfHwgZS54ICsgZS53aWR0aCA8IEkueCB8fCBlLnkgPiBJLnkgKyBJLmhlaWdodCB8fCBlLnkgKyBlLmhlaWdodCA8IEkueSB8fCAoKHEubGFiZWxyYW5rIDwgaC5sYWJlbHJhbmsgPyBxIDogaCkubmV3T3BhY2l0eSA9IDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGQuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgZDtcblxuICAgICAgICBpZiAoYykge1xuICAgICAgICAgIHZhciBlID0gYy5uZXdPcGFjaXR5O1xuICAgICAgICAgIGMub2xkT3BhY2l0eSAhPT0gZSAmJiAoYy5hbGlnbkF0dHIgJiYgYy5wbGFjZWQgPyAoZSA/IGMuc2hvdyghMCkgOiBkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYy5oaWRlKCEwKTtcbiAgICAgICAgICAgIGMucGxhY2VkID0gITE7XG4gICAgICAgICAgfSwgRSA9ICEwLCBjLmFsaWduQXR0ci5vcGFjaXR5ID0gZSwgY1tjLmlzT2xkID8gXCJhbmltYXRlXCIgOiBcImF0dHJcIl0oYy5hbGlnbkF0dHIsIG51bGwsIGQpLCB1KGcsIFwiYWZ0ZXJIaWRlT3ZlcmxhcHBpbmdMYWJlbFwiKSkgOiBjLmF0dHIoe1xuICAgICAgICAgICAgb3BhY2l0eTogZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBjLmlzT2xkID0gITA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgRSAmJiB1KGcsIFwiYWZ0ZXJIaWRlQWxsT3ZlcmxhcHBpbmdMYWJlbHNcIik7XG4gICAgfTtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9JbnRlcmFjdGlvbi5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9MZWdlbmQuanNcIl0sIHJbXCJwYXJ0cy9Qb2ludC5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnLCByLCB1KSB7XG4gICAgdmFyIEkgPSB1LmFkZEV2ZW50LFxuICAgICAgICBNID0gdS5jcmVhdGVFbGVtZW50LFxuICAgICAgICBFID0gdS5jc3MsXG4gICAgICAgIEEgPSB1LmRlZmluZWQsXG4gICAgICAgIEcgPSB1LmV4dGVuZCxcbiAgICAgICAgSiA9IHUuZmlyZUV2ZW50LFxuICAgICAgICB5ID0gdS5pc0FycmF5LFxuICAgICAgICB0ID0gdS5pc0Z1bmN0aW9uLFxuICAgICAgICBEID0gdS5pc09iamVjdCxcbiAgICAgICAgaCA9IHUubWVyZ2UsXG4gICAgICAgIE4gPSB1Lm9iamVjdEVhY2gsXG4gICAgICAgIHEgPSB1LnBpY2s7XG4gICAgdSA9IGQuQ2hhcnQ7XG4gICAgdmFyIFAgPSBkLmRlZmF1bHRPcHRpb25zLFxuICAgICAgICBlID0gZC5kZWZhdWx0UGxvdE9wdGlvbnMsXG4gICAgICAgIGMgPSBkLmhhc1RvdWNoLFxuICAgICAgICBrID0gZC5TZXJpZXMsXG4gICAgICAgIG4gPSBkLnNlcmllc1R5cGVzLFxuICAgICAgICBmID0gZC5zdmc7XG4gICAgZCA9IGQuVHJhY2tlck1peGluID0ge1xuICAgICAgZHJhd1RyYWNrZXJQb2ludDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICBkID0gYS5jaGFydCxcbiAgICAgICAgICAgIGUgPSBkLnBvaW50ZXIsXG4gICAgICAgICAgICBmID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICB2YXIgYyA9IGUuZ2V0UG9pbnRGcm9tRXZlbnQoYSk7XG4gICAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGMgJiYgKGUuaXNEaXJlY3RUb3VjaCA9ICEwLCBjLm9uTW91c2VPdmVyKGEpKTtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIGc7XG5cbiAgICAgICAgYS5wb2ludHMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGcgPSB5KGEuZGF0YUxhYmVscykgPyBhLmRhdGFMYWJlbHMgOiBhLmRhdGFMYWJlbCA/IFthLmRhdGFMYWJlbF0gOiBbXTtcbiAgICAgICAgICBhLmdyYXBoaWMgJiYgKGEuZ3JhcGhpYy5lbGVtZW50LnBvaW50ID0gYSk7XG4gICAgICAgICAgZy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBjLmRpdiA/IGMuZGl2LnBvaW50ID0gYSA6IGMuZWxlbWVudC5wb2ludCA9IGE7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhLl9oYXNUcmFja2luZyB8fCAoYS50cmFja2VyR3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgICBpZiAoYVtnXSkge1xuICAgICAgICAgICAgYVtnXS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtdHJhY2tlclwiKS5vbihcIm1vdXNlb3ZlclwiLCBmKS5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgIGUub25UcmFja2VyTW91c2VPdXQoYSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjKSBhW2ddLm9uKFwidG91Y2hzdGFydFwiLCBmKTtcbiAgICAgICAgICAgICFkLnN0eWxlZE1vZGUgJiYgYS5vcHRpb25zLmN1cnNvciAmJiBhW2ddLmNzcyhFKS5jc3Moe1xuICAgICAgICAgICAgICBjdXJzb3I6IGEub3B0aW9ucy5jdXJzb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksIGEuX2hhc1RyYWNraW5nID0gITApO1xuICAgICAgICBKKHRoaXMsIFwiYWZ0ZXJEcmF3VHJhY2tlclwiKTtcbiAgICAgIH0sXG4gICAgICBkcmF3VHJhY2tlckdyYXBoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIGQgPSBhLm9wdGlvbnMsXG4gICAgICAgICAgICBlID0gZC50cmFja0J5QXJlYSxcbiAgICAgICAgICAgIGcgPSBbXS5jb25jYXQoZSA/IGEuYXJlYVBhdGggOiBhLmdyYXBoUGF0aCksXG4gICAgICAgICAgICBoID0gZy5sZW5ndGgsXG4gICAgICAgICAgICBrID0gYS5jaGFydCxcbiAgICAgICAgICAgIG4gPSBrLnBvaW50ZXIsXG4gICAgICAgICAgICBxID0gay5yZW5kZXJlcixcbiAgICAgICAgICAgIHIgPSBrLm9wdGlvbnMudG9vbHRpcC5zbmFwLFxuICAgICAgICAgICAgdCA9IGEudHJhY2tlcixcbiAgICAgICAgICAgIHAsXG4gICAgICAgICAgICBiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChrLmhvdmVyU2VyaWVzICE9PSBhKSBhLm9uTW91c2VPdmVyKCk7XG4gICAgICAgIH0sXG4gICAgICAgICAgICB1ID0gXCJyZ2JhKDE5MiwxOTIsMTkyLFwiICsgKGYgPyAuMDAwMSA6IC4wMDIpICsgXCIpXCI7XG5cbiAgICAgICAgaWYgKGggJiYgIWUpIGZvciAocCA9IGggKyAxOyBwLS07KSBcIk1cIiA9PT0gZ1twXSAmJiBnLnNwbGljZShwICsgMSwgMCwgZ1twICsgMV0gLSByLCBnW3AgKyAyXSwgXCJMXCIpLCAocCAmJiBcIk1cIiA9PT0gZ1twXSB8fCBwID09PSBoKSAmJiBnLnNwbGljZShwLCAwLCBcIkxcIiwgZ1twIC0gMl0gKyByLCBnW3AgLSAxXSk7XG4gICAgICAgIHQgPyB0LmF0dHIoe1xuICAgICAgICAgIGQ6IGdcbiAgICAgICAgfSkgOiBhLmdyYXBoICYmIChhLnRyYWNrZXIgPSBxLnBhdGgoZykuYXR0cih7XG4gICAgICAgICAgdmlzaWJpbGl0eTogYS52aXNpYmxlID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiLFxuICAgICAgICAgIHpJbmRleDogMlxuICAgICAgICB9KS5hZGRDbGFzcyhlID8gXCJoaWdoY2hhcnRzLXRyYWNrZXItYXJlYVwiIDogXCJoaWdoY2hhcnRzLXRyYWNrZXItbGluZVwiKS5hZGQoYS5ncm91cCksIGsuc3R5bGVkTW9kZSB8fCBhLnRyYWNrZXIuYXR0cih7XG4gICAgICAgICAgXCJzdHJva2UtbGluZWpvaW5cIjogXCJyb3VuZFwiLFxuICAgICAgICAgIHN0cm9rZTogdSxcbiAgICAgICAgICBmaWxsOiBlID8gdSA6IFwibm9uZVwiLFxuICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IGEuZ3JhcGguc3Ryb2tlV2lkdGgoKSArIChlID8gMCA6IDIgKiByKVxuICAgICAgICB9KSwgW2EudHJhY2tlciwgYS5tYXJrZXJHcm91cF0uZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikub24oXCJtb3VzZW92ZXJcIiwgYikub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgbi5vblRyYWNrZXJNb3VzZU91dChhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkLmN1cnNvciAmJiAhay5zdHlsZWRNb2RlICYmIGEuY3NzKHtcbiAgICAgICAgICAgIGN1cnNvcjogZC5jdXJzb3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoYykgYS5vbihcInRvdWNoc3RhcnRcIiwgYik7XG4gICAgICAgIH0pKTtcbiAgICAgICAgSih0aGlzLCBcImFmdGVyRHJhd1RyYWNrZXJcIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBuLmNvbHVtbiAmJiAobi5jb2x1bW4ucHJvdG90eXBlLmRyYXdUcmFja2VyID0gZC5kcmF3VHJhY2tlclBvaW50KTtcbiAgICBuLnBpZSAmJiAobi5waWUucHJvdG90eXBlLmRyYXdUcmFja2VyID0gZC5kcmF3VHJhY2tlclBvaW50KTtcbiAgICBuLnNjYXR0ZXIgJiYgKG4uc2NhdHRlci5wcm90b3R5cGUuZHJhd1RyYWNrZXIgPSBkLmRyYXdUcmFja2VyUG9pbnQpO1xuICAgIEcoZy5wcm90b3R5cGUsIHtcbiAgICAgIHNldEl0ZW1FdmVudHM6IGZ1bmN0aW9uIChhLCBjLCBkKSB7XG4gICAgICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgICAgIGYgPSBlLmNoYXJ0LnJlbmRlcmVyLmJveFdyYXBwZXIsXG4gICAgICAgICAgICBnID0gYSBpbnN0YW5jZW9mIHIsXG4gICAgICAgICAgICBrID0gXCJoaWdoY2hhcnRzLWxlZ2VuZC1cIiArIChnID8gXCJwb2ludFwiIDogXCJzZXJpZXNcIikgKyBcIi1hY3RpdmVcIixcbiAgICAgICAgICAgIGwgPSBlLmNoYXJ0LnN0eWxlZE1vZGU7XG4gICAgICAgIChkID8gW2MsIGEubGVnZW5kU3ltYm9sXSA6IFthLmxlZ2VuZEdyb3VwXSkuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGlmIChkKSBkLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGEudmlzaWJsZSAmJiBlLmFsbEl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgYSAhPT0gYyAmJiBjLnNldFN0YXRlKFwiaW5hY3RpdmVcIiwgIWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhLnNldFN0YXRlKFwiaG92ZXJcIik7XG4gICAgICAgICAgICBhLnZpc2libGUgJiYgZi5hZGRDbGFzcyhrKTtcbiAgICAgICAgICAgIGwgfHwgYy5jc3MoZS5vcHRpb25zLml0ZW1Ib3ZlclN0eWxlKTtcbiAgICAgICAgICB9KS5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGUuY2hhcnQuc3R5bGVkTW9kZSB8fCBjLmNzcyhoKGEudmlzaWJsZSA/IGUuaXRlbVN0eWxlIDogZS5pdGVtSGlkZGVuU3R5bGUpKTtcbiAgICAgICAgICAgIGUuYWxsSXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICBhICE9PSBjICYmIGMuc2V0U3RhdGUoXCJcIiwgIWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmLnJlbW92ZUNsYXNzKGspO1xuICAgICAgICAgICAgYS5zZXRTdGF0ZSgpO1xuICAgICAgICAgIH0pLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHZhciBkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBhLnNldFZpc2libGUgJiYgYS5zZXRWaXNpYmxlKCk7XG4gICAgICAgICAgICAgIGUuYWxsSXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgICAgIGEgIT09IGIgJiYgYi5zZXRTdGF0ZShhLnZpc2libGUgPyBcImluYWN0aXZlXCIgOiBcIlwiLCAhZyk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZi5yZW1vdmVDbGFzcyhrKTtcbiAgICAgICAgICAgIGMgPSB7XG4gICAgICAgICAgICAgIGJyb3dzZXJFdmVudDogY1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGEuZmlyZVBvaW50RXZlbnQgPyBhLmZpcmVQb2ludEV2ZW50KFwibGVnZW5kSXRlbUNsaWNrXCIsIGMsIGQpIDogSihhLCBcImxlZ2VuZEl0ZW1DbGlja1wiLCBjLCBkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgY3JlYXRlQ2hlY2tib3hGb3JJdGVtOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICBhLmNoZWNrYm94ID0gTShcImlucHV0XCIsIHtcbiAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgY2xhc3NOYW1lOiBcImhpZ2hjaGFydHMtbGVnZW5kLWNoZWNrYm94XCIsXG4gICAgICAgICAgY2hlY2tlZDogYS5zZWxlY3RlZCxcbiAgICAgICAgICBkZWZhdWx0Q2hlY2tlZDogYS5zZWxlY3RlZFxuICAgICAgICB9LCB0aGlzLm9wdGlvbnMuaXRlbUNoZWNrYm94U3R5bGUsIHRoaXMuY2hhcnQuY29udGFpbmVyKTtcbiAgICAgICAgSShhLmNoZWNrYm94LCBcImNsaWNrXCIsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgSihhLnNlcmllcyB8fCBhLCBcImNoZWNrYm94Q2xpY2tcIiwge1xuICAgICAgICAgICAgY2hlY2tlZDogYy50YXJnZXQuY2hlY2tlZCxcbiAgICAgICAgICAgIGl0ZW06IGFcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhLnNlbGVjdCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBHKHUucHJvdG90eXBlLCB7XG4gICAgICBzaG93UmVzZXRab29tOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGEoKSB7XG4gICAgICAgICAgYy56b29tT3V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHRoaXMsXG4gICAgICAgICAgICBkID0gUC5sYW5nLFxuICAgICAgICAgICAgZSA9IGMub3B0aW9ucy5jaGFydC5yZXNldFpvb21CdXR0b24sXG4gICAgICAgICAgICBmID0gZS50aGVtZSxcbiAgICAgICAgICAgIGcgPSBmLnN0YXRlcyxcbiAgICAgICAgICAgIGggPSBcImNoYXJ0XCIgPT09IGUucmVsYXRpdmVUbyB8fCBcInNwYWNlQm94XCIgPT09IGUucmVsYXRpdmVUbyA/IG51bGwgOiBcInBsb3RCb3hcIjtcbiAgICAgICAgSih0aGlzLCBcImJlZm9yZVNob3dSZXNldFpvb21cIiwgbnVsbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGMucmVzZXRab29tQnV0dG9uID0gYy5yZW5kZXJlci5idXR0b24oZC5yZXNldFpvb20sIG51bGwsIG51bGwsIGEsIGYsIGcgJiYgZy5ob3ZlcikuYXR0cih7XG4gICAgICAgICAgICBhbGlnbjogZS5wb3NpdGlvbi5hbGlnbixcbiAgICAgICAgICAgIHRpdGxlOiBkLnJlc2V0Wm9vbVRpdGxlXG4gICAgICAgICAgfSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXJlc2V0LXpvb21cIikuYWRkKCkuYWxpZ24oZS5wb3NpdGlvbiwgITEsIGgpO1xuICAgICAgICB9KTtcbiAgICAgICAgSih0aGlzLCBcImFmdGVyU2hvd1Jlc2V0Wm9vbVwiKTtcbiAgICAgIH0sXG4gICAgICB6b29tT3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIEoodGhpcywgXCJzZWxlY3Rpb25cIiwge1xuICAgICAgICAgIHJlc2V0U2VsZWN0aW9uOiAhMFxuICAgICAgICB9LCB0aGlzLnpvb20pO1xuICAgICAgfSxcbiAgICAgIHpvb206IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBjID0gdGhpcyxcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBlID0gYy5wb2ludGVyLFxuICAgICAgICAgICAgZiA9ICExLFxuICAgICAgICAgICAgZyA9IGMuaW52ZXJ0ZWQgPyBlLm1vdXNlRG93blggOiBlLm1vdXNlRG93blk7XG4gICAgICAgICFhIHx8IGEucmVzZXRTZWxlY3Rpb24gPyAoYy5heGVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBkID0gYS56b29tKCk7XG4gICAgICAgIH0pLCBlLmluaXRpYXRlZCA9ICExKSA6IGEueEF4aXMuY29uY2F0KGEueUF4aXMpLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICB2YXIgaCA9IGEuYXhpcyxcbiAgICAgICAgICAgICAgayA9IGMuaW52ZXJ0ZWQgPyBoLmxlZnQgOiBoLnRvcCxcbiAgICAgICAgICAgICAgbCA9IGMuaW52ZXJ0ZWQgPyBrICsgaC53aWR0aCA6IGsgKyBoLmhlaWdodCxcbiAgICAgICAgICAgICAgYiA9IGguaXNYQXhpcyxcbiAgICAgICAgICAgICAgbiA9ICExO1xuICAgICAgICAgIGlmICghYiAmJiBnID49IGsgJiYgZyA8PSBsIHx8IGIgfHwgIUEoZykpIG4gPSAhMDtcbiAgICAgICAgICBlW2IgPyBcInpvb21YXCIgOiBcInpvb21ZXCJdICYmIG4gJiYgKGQgPSBoLnpvb20oYS5taW4sIGEubWF4KSwgaC5kaXNwbGF5QnRuICYmIChmID0gITApKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBoID0gYy5yZXNldFpvb21CdXR0b247XG4gICAgICAgIGYgJiYgIWggPyBjLnNob3dSZXNldFpvb20oKSA6ICFmICYmIEQoaCkgJiYgKGMucmVzZXRab29tQnV0dG9uID0gaC5kZXN0cm95KCkpO1xuICAgICAgICBkICYmIGMucmVkcmF3KHEoYy5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbiwgYSAmJiBhLmFuaW1hdGlvbiwgMTAwID4gYy5wb2ludENvdW50KSk7XG4gICAgICB9LFxuICAgICAgcGFuOiBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgICBlID0gZC5ob3ZlclBvaW50cyxcbiAgICAgICAgICAgIGYgPSBkLm9wdGlvbnMuY2hhcnQsXG4gICAgICAgICAgICBnO1xuICAgICAgICBjID0gXCJvYmplY3RcIiA9PT0gdHlwZW9mIGMgPyBjIDoge1xuICAgICAgICAgIGVuYWJsZWQ6IGMsXG4gICAgICAgICAgdHlwZTogXCJ4XCJcbiAgICAgICAgfTtcbiAgICAgICAgZiAmJiBmLnBhbm5pbmcgJiYgKGYucGFubmluZyA9IGMpO1xuICAgICAgICB2YXIgaCA9IGMudHlwZTtcbiAgICAgICAgSih0aGlzLCBcInBhblwiLCB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogYVxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZSAmJiBlLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGEuc2V0U3RhdGUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgYyA9IFsxXTtcbiAgICAgICAgICBcInh5XCIgPT09IGggPyBjID0gWzEsIDBdIDogXCJ5XCIgPT09IGggJiYgKGMgPSBbMF0pO1xuICAgICAgICAgIGMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgdmFyIGUgPSBkW2MgPyBcInhBeGlzXCIgOiBcInlBeGlzXCJdWzBdLFxuICAgICAgICAgICAgICAgIGYgPSBlLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYiA9IGUuaG9yaXosXG4gICAgICAgICAgICAgICAgaCA9IGFbYiA/IFwiY2hhcnRYXCIgOiBcImNoYXJ0WVwiXTtcbiAgICAgICAgICAgIGIgPSBiID8gXCJtb3VzZURvd25YXCIgOiBcIm1vdXNlRG93bllcIjtcbiAgICAgICAgICAgIHZhciBrID0gZFtiXSxcbiAgICAgICAgICAgICAgICBsID0gKGUucG9pbnRSYW5nZSB8fCAwKSAvIDIsXG4gICAgICAgICAgICAgICAgbiA9IGUucmV2ZXJzZWQgJiYgIWQuaW52ZXJ0ZWQgfHwgIWUucmV2ZXJzZWQgJiYgZC5pbnZlcnRlZCA/IC0xIDogMSxcbiAgICAgICAgICAgICAgICBxID0gZS5nZXRFeHRyZW1lcygpLFxuICAgICAgICAgICAgICAgIHYgPSBlLnRvVmFsdWUoayAtIGgsICEwKSArIGwgKiBuO1xuICAgICAgICAgICAgbiA9IGUudG9WYWx1ZShrICsgZS5sZW4gLSBoLCAhMCkgLSBsICogbjtcbiAgICAgICAgICAgIHZhciBtID0gbiA8IHY7XG4gICAgICAgICAgICBrID0gbSA/IG4gOiB2O1xuICAgICAgICAgICAgdiA9IG0gPyB2IDogbjtcbiAgICAgICAgICAgIG4gPSBNYXRoLm1pbihxLmRhdGFNaW4sIGwgPyBxLm1pbiA6IGUudG9WYWx1ZShlLnRvUGl4ZWxzKHEubWluKSAtIGUubWluUGl4ZWxQYWRkaW5nKSk7XG4gICAgICAgICAgICBsID0gTWF0aC5tYXgocS5kYXRhTWF4LCBsID8gcS5tYXggOiBlLnRvVmFsdWUoZS50b1BpeGVscyhxLm1heCkgKyBlLm1pblBpeGVsUGFkZGluZykpO1xuXG4gICAgICAgICAgICBpZiAoIWYub3JkaW5hbCkge1xuICAgICAgICAgICAgICBjICYmIChmID0gbiAtIGssIDAgPCBmICYmICh2ICs9IGYsIGsgPSBuKSwgZiA9IHYgLSBsLCAwIDwgZiAmJiAodiA9IGwsIGsgLT0gZikpO1xuICAgICAgICAgICAgICBpZiAoZS5zZXJpZXMubGVuZ3RoICYmIGsgIT09IHEubWluICYmIHYgIT09IHEubWF4ICYmIGMgfHwgZS5wYW5uaW5nU3RhdGUgJiYgayA+PSBlLnBhbm5pbmdTdGF0ZS5zdGFydE1pbiAmJiB2IDw9IGUucGFubmluZ1N0YXRlLnN0YXJ0TWF4KSBlLnNldEV4dHJlbWVzKGssIHYsICExLCAhMSwge1xuICAgICAgICAgICAgICAgIHRyaWdnZXI6IFwicGFuXCJcbiAgICAgICAgICAgICAgfSksIGcgPSAhMDtcbiAgICAgICAgICAgICAgZFtiXSA9IGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZyAmJiBkLnJlZHJhdyghMSk7XG4gICAgICAgICAgRShkLmNvbnRhaW5lciwge1xuICAgICAgICAgICAgY3Vyc29yOiBcIm1vdmVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBHKHIucHJvdG90eXBlLCB7XG4gICAgICBzZWxlY3Q6IGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICAgIGUgPSBkLnNlcmllcyxcbiAgICAgICAgICAgIGYgPSBlLmNoYXJ0O1xuICAgICAgICB0aGlzLnNlbGVjdGVkU3RhZ2luZyA9IGEgPSBxKGEsICFkLnNlbGVjdGVkKTtcbiAgICAgICAgZC5maXJlUG9pbnRFdmVudChhID8gXCJzZWxlY3RcIiA6IFwidW5zZWxlY3RcIiwge1xuICAgICAgICAgIGFjY3VtdWxhdGU6IGNcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGQuc2VsZWN0ZWQgPSBkLm9wdGlvbnMuc2VsZWN0ZWQgPSBhO1xuICAgICAgICAgIGUub3B0aW9ucy5kYXRhW2UuZGF0YS5pbmRleE9mKGQpXSA9IGQub3B0aW9ucztcbiAgICAgICAgICBkLnNldFN0YXRlKGEgJiYgXCJzZWxlY3RcIik7XG4gICAgICAgICAgYyB8fCBmLmdldFNlbGVjdGVkUG9pbnRzKCkuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgdmFyIGMgPSBhLnNlcmllcztcbiAgICAgICAgICAgIGEuc2VsZWN0ZWQgJiYgYSAhPT0gZCAmJiAoYS5zZWxlY3RlZCA9IGEub3B0aW9ucy5zZWxlY3RlZCA9ICExLCBjLm9wdGlvbnMuZGF0YVtjLmRhdGEuaW5kZXhPZihhKV0gPSBhLm9wdGlvbnMsIGEuc2V0U3RhdGUoZi5ob3ZlclBvaW50cyAmJiBjLm9wdGlvbnMuaW5hY3RpdmVPdGhlclBvaW50cyA/IFwiaW5hY3RpdmVcIiA6IFwiXCIpLCBhLmZpcmVQb2ludEV2ZW50KFwidW5zZWxlY3RcIikpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2VsZWN0ZWRTdGFnaW5nO1xuICAgICAgfSxcbiAgICAgIG9uTW91c2VPdmVyOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYyA9IHRoaXMuc2VyaWVzLmNoYXJ0LFxuICAgICAgICAgICAgZCA9IGMucG9pbnRlcjtcbiAgICAgICAgYSA9IGEgPyBkLm5vcm1hbGl6ZShhKSA6IGQuZ2V0Q2hhcnRDb29yZGluYXRlc0Zyb21Qb2ludCh0aGlzLCBjLmludmVydGVkKTtcbiAgICAgICAgZC5ydW5Qb2ludEFjdGlvbnMoYSwgdGhpcyk7XG4gICAgICB9LFxuICAgICAgb25Nb3VzZU91dDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuc2VyaWVzLmNoYXJ0O1xuICAgICAgICB0aGlzLmZpcmVQb2ludEV2ZW50KFwibW91c2VPdXRcIik7XG4gICAgICAgIHRoaXMuc2VyaWVzLm9wdGlvbnMuaW5hY3RpdmVPdGhlclBvaW50cyB8fCAoYS5ob3ZlclBvaW50cyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEuc2V0U3RhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGEuaG92ZXJQb2ludHMgPSBhLmhvdmVyUG9pbnQgPSBudWxsO1xuICAgICAgfSxcbiAgICAgIGltcG9ydEV2ZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzSW1wb3J0ZWRFdmVudHMpIHtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICAgIGMgPSBoKGEuc2VyaWVzLm9wdGlvbnMucG9pbnQsIGEub3B0aW9ucykuZXZlbnRzO1xuICAgICAgICAgIGEuZXZlbnRzID0gYztcbiAgICAgICAgICBOKGMsIGZ1bmN0aW9uIChjLCBkKSB7XG4gICAgICAgICAgICB0KGMpICYmIEkoYSwgZCwgYyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5oYXNJbXBvcnRlZEV2ZW50cyA9ICEwO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0U3RhdGU6IGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgIHZhciBkID0gdGhpcy5zZXJpZXMsXG4gICAgICAgICAgICBmID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIGcgPSBkLm9wdGlvbnMuc3RhdGVzW2EgfHwgXCJub3JtYWxcIl0gfHwge30sXG4gICAgICAgICAgICBoID0gZVtkLnR5cGVdLm1hcmtlciAmJiBkLm9wdGlvbnMubWFya2VyLFxuICAgICAgICAgICAgayA9IGggJiYgITEgPT09IGguZW5hYmxlZCxcbiAgICAgICAgICAgIGwgPSBoICYmIGguc3RhdGVzICYmIGguc3RhdGVzW2EgfHwgXCJub3JtYWxcIl0gfHwge30sXG4gICAgICAgICAgICBuID0gITEgPT09IGwuZW5hYmxlZCxcbiAgICAgICAgICAgIHIgPSBkLnN0YXRlTWFya2VyR3JhcGhpYyxcbiAgICAgICAgICAgIHAgPSB0aGlzLm1hcmtlciB8fCB7fSxcbiAgICAgICAgICAgIGIgPSBkLmNoYXJ0LFxuICAgICAgICAgICAgdCA9IGQuaGFsbyxcbiAgICAgICAgICAgIHUsXG4gICAgICAgICAgICB5ID0gaCAmJiBkLm1hcmtlckF0dHJpYnM7XG4gICAgICAgIGEgPSBhIHx8IFwiXCI7XG5cbiAgICAgICAgaWYgKCEoYSA9PT0gdGhpcy5zdGF0ZSAmJiAhYyB8fCB0aGlzLnNlbGVjdGVkICYmIFwic2VsZWN0XCIgIT09IGEgfHwgITEgPT09IGcuZW5hYmxlZCB8fCBhICYmIChuIHx8IGsgJiYgITEgPT09IGwuZW5hYmxlZCkgfHwgYSAmJiBwLnN0YXRlcyAmJiBwLnN0YXRlc1thXSAmJiAhMSA9PT0gcC5zdGF0ZXNbYV0uZW5hYmxlZCkpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gYTtcbiAgICAgICAgICB5ICYmICh1ID0gZC5tYXJrZXJBdHRyaWJzKHRoaXMsIGEpKTtcblxuICAgICAgICAgIGlmICh0aGlzLmdyYXBoaWMpIHtcbiAgICAgICAgICAgIGYgJiYgdGhpcy5ncmFwaGljLnJlbW92ZUNsYXNzKFwiaGlnaGNoYXJ0cy1wb2ludC1cIiArIGYpO1xuICAgICAgICAgICAgYSAmJiB0aGlzLmdyYXBoaWMuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXBvaW50LVwiICsgYSk7XG5cbiAgICAgICAgICAgIGlmICghYi5zdHlsZWRNb2RlKSB7XG4gICAgICAgICAgICAgIHZhciBBID0gZC5wb2ludEF0dHJpYnModGhpcywgYSk7XG4gICAgICAgICAgICAgIHZhciBEID0gcShiLm9wdGlvbnMuY2hhcnQuYW5pbWF0aW9uLCBnLmFuaW1hdGlvbik7XG4gICAgICAgICAgICAgIGQub3B0aW9ucy5pbmFjdGl2ZU90aGVyUG9pbnRzICYmICgodGhpcy5kYXRhTGFiZWxzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgYSAmJiBhLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgICAgb3BhY2l0eTogQS5vcGFjaXR5XG4gICAgICAgICAgICAgICAgfSwgRCk7XG4gICAgICAgICAgICAgIH0pLCB0aGlzLmNvbm5lY3RvciAmJiB0aGlzLmNvbm5lY3Rvci5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiBBLm9wYWNpdHlcbiAgICAgICAgICAgICAgfSwgRCkpO1xuICAgICAgICAgICAgICB0aGlzLmdyYXBoaWMuYW5pbWF0ZShBLCBEKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdSAmJiB0aGlzLmdyYXBoaWMuYW5pbWF0ZSh1LCBxKGIub3B0aW9ucy5jaGFydC5hbmltYXRpb24sIGwuYW5pbWF0aW9uLCBoLmFuaW1hdGlvbikpO1xuICAgICAgICAgICAgciAmJiByLmhpZGUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGEgJiYgbCkge1xuICAgICAgICAgICAgICBmID0gcC5zeW1ib2wgfHwgZC5zeW1ib2w7XG4gICAgICAgICAgICAgIHIgJiYgci5jdXJyZW50U3ltYm9sICE9PSBmICYmIChyID0gci5kZXN0cm95KCkpO1xuICAgICAgICAgICAgICBpZiAodSkgaWYgKHIpIHJbYyA/IFwiYW5pbWF0ZVwiIDogXCJhdHRyXCJdKHtcbiAgICAgICAgICAgICAgICB4OiB1LngsXG4gICAgICAgICAgICAgICAgeTogdS55XG4gICAgICAgICAgICAgIH0pO2Vsc2UgZiAmJiAoZC5zdGF0ZU1hcmtlckdyYXBoaWMgPSByID0gYi5yZW5kZXJlci5zeW1ib2woZiwgdS54LCB1LnksIHUud2lkdGgsIHUuaGVpZ2h0KS5hZGQoZC5tYXJrZXJHcm91cCksIHIuY3VycmVudFN5bWJvbCA9IGYpO1xuICAgICAgICAgICAgICAhYi5zdHlsZWRNb2RlICYmIHIgJiYgci5hdHRyKGQucG9pbnRBdHRyaWJzKHRoaXMsIGEpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgciAmJiAoclthICYmIHRoaXMuaXNJbnNpZGUgPyBcInNob3dcIiA6IFwiaGlkZVwiXSgpLCByLmVsZW1lbnQucG9pbnQgPSB0aGlzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhID0gZy5oYWxvO1xuICAgICAgICAgIGcgPSAociA9IHRoaXMuZ3JhcGhpYyB8fCByKSAmJiByLnZpc2liaWxpdHkgfHwgXCJpbmhlcml0XCI7XG4gICAgICAgICAgYSAmJiBhLnNpemUgJiYgciAmJiBcImhpZGRlblwiICE9PSBnICYmICF0aGlzLmlzQ2x1c3RlciA/ICh0IHx8IChkLmhhbG8gPSB0ID0gYi5yZW5kZXJlci5wYXRoKCkuYWRkKHIucGFyZW50R3JvdXApKSwgdC5zaG93KClbYyA/IFwiYW5pbWF0ZVwiIDogXCJhdHRyXCJdKHtcbiAgICAgICAgICAgIGQ6IHRoaXMuaGFsb1BhdGgoYS5zaXplKVxuICAgICAgICAgIH0pLCB0LmF0dHIoe1xuICAgICAgICAgICAgXCJjbGFzc1wiOiBcImhpZ2hjaGFydHMtaGFsbyBoaWdoY2hhcnRzLWNvbG9yLVwiICsgcSh0aGlzLmNvbG9ySW5kZXgsIGQuY29sb3JJbmRleCkgKyAodGhpcy5jbGFzc05hbWUgPyBcIiBcIiArIHRoaXMuY2xhc3NOYW1lIDogXCJcIiksXG4gICAgICAgICAgICB2aXNpYmlsaXR5OiBnLFxuICAgICAgICAgICAgekluZGV4OiAtMVxuICAgICAgICAgIH0pLCB0LnBvaW50ID0gdGhpcywgYi5zdHlsZWRNb2RlIHx8IHQuYXR0cihHKHtcbiAgICAgICAgICAgIGZpbGw6IHRoaXMuY29sb3IgfHwgZC5jb2xvcixcbiAgICAgICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IGEub3BhY2l0eVxuICAgICAgICAgIH0sIGEuYXR0cmlidXRlcykpKSA6IHQgJiYgdC5wb2ludCAmJiB0LnBvaW50LmhhbG9QYXRoICYmIHQuYW5pbWF0ZSh7XG4gICAgICAgICAgICBkOiB0LnBvaW50LmhhbG9QYXRoKDApXG4gICAgICAgICAgfSwgbnVsbCwgdC5oaWRlKTtcbiAgICAgICAgICBKKHRoaXMsIFwiYWZ0ZXJTZXRTdGF0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhbG9QYXRoOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJpZXMuY2hhcnQucmVuZGVyZXIuc3ltYm9scy5jaXJjbGUoTWF0aC5mbG9vcih0aGlzLnBsb3RYKSAtIGEsIHRoaXMucGxvdFkgLSBhLCAyICogYSwgMiAqIGEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIEcoay5wcm90b3R5cGUsIHtcbiAgICAgIG9uTW91c2VPdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGMgPSBhLmhvdmVyU2VyaWVzO1xuICAgICAgICBpZiAoYyAmJiBjICE9PSB0aGlzKSBjLm9uTW91c2VPdXQoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmV2ZW50cy5tb3VzZU92ZXIgJiYgSih0aGlzLCBcIm1vdXNlT3ZlclwiKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcImhvdmVyXCIpO1xuICAgICAgICBhLmhvdmVyU2VyaWVzID0gdGhpcztcbiAgICAgIH0sXG4gICAgICBvbk1vdXNlT3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgYyA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBkID0gYy50b29sdGlwLFxuICAgICAgICAgICAgZSA9IGMuaG92ZXJQb2ludDtcbiAgICAgICAgYy5ob3ZlclNlcmllcyA9IG51bGw7XG4gICAgICAgIGlmIChlKSBlLm9uTW91c2VPdXQoKTtcbiAgICAgICAgdGhpcyAmJiBhLmV2ZW50cy5tb3VzZU91dCAmJiBKKHRoaXMsIFwibW91c2VPdXRcIik7XG4gICAgICAgICFkIHx8IHRoaXMuc3RpY2t5VHJhY2tpbmcgfHwgZC5zaGFyZWQgJiYgIXRoaXMubm9TaGFyZWRUb29sdGlwIHx8IGQuaGlkZSgpO1xuICAgICAgICBjLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYS5zZXRTdGF0ZShcIlwiLCAhMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHNldFN0YXRlOiBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgICBlID0gZC5vcHRpb25zLFxuICAgICAgICAgICAgZiA9IGQuZ3JhcGgsXG4gICAgICAgICAgICBnID0gZS5pbmFjdGl2ZU90aGVyUG9pbnRzLFxuICAgICAgICAgICAgaCA9IGUuc3RhdGVzLFxuICAgICAgICAgICAgayA9IGUubGluZVdpZHRoLFxuICAgICAgICAgICAgbCA9IGUub3BhY2l0eSxcbiAgICAgICAgICAgIG4gPSBxKGhbYSB8fCBcIm5vcm1hbFwiXSAmJiBoW2EgfHwgXCJub3JtYWxcIl0uYW5pbWF0aW9uLCBkLmNoYXJ0Lm9wdGlvbnMuY2hhcnQuYW5pbWF0aW9uKTtcbiAgICAgICAgZSA9IDA7XG4gICAgICAgIGEgPSBhIHx8IFwiXCI7XG5cbiAgICAgICAgaWYgKGQuc3RhdGUgIT09IGEgJiYgKFtkLmdyb3VwLCBkLm1hcmtlckdyb3VwLCBkLmRhdGFMYWJlbHNHcm91cF0uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGMgJiYgKGQuc3RhdGUgJiYgYy5yZW1vdmVDbGFzcyhcImhpZ2hjaGFydHMtc2VyaWVzLVwiICsgZC5zdGF0ZSksIGEgJiYgYy5hZGRDbGFzcyhcImhpZ2hjaGFydHMtc2VyaWVzLVwiICsgYSkpO1xuICAgICAgICB9KSwgZC5zdGF0ZSA9IGEsICFkLmNoYXJ0LnN0eWxlZE1vZGUpKSB7XG4gICAgICAgICAgaWYgKGhbYV0gJiYgITEgPT09IGhbYV0uZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICAgIGEgJiYgKGsgPSBoW2FdLmxpbmVXaWR0aCB8fCBrICsgKGhbYV0ubGluZVdpZHRoUGx1cyB8fCAwKSwgbCA9IHEoaFthXS5vcGFjaXR5LCBsKSk7XG4gICAgICAgICAgaWYgKGYgJiYgIWYuZGFzaHN0eWxlKSBmb3IgKGggPSB7XG4gICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBrXG4gICAgICAgICAgfSwgZi5hbmltYXRlKGgsIG4pOyBkW1wiem9uZS1ncmFwaC1cIiArIGVdOykgZFtcInpvbmUtZ3JhcGgtXCIgKyBlXS5hdHRyKGgpLCBlICs9IDE7XG4gICAgICAgICAgZyB8fCBbZC5ncm91cCwgZC5tYXJrZXJHcm91cCwgZC5kYXRhTGFiZWxzR3JvdXAsIGQubGFiZWxCeVNlcmllc10uZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYSAmJiBhLmFuaW1hdGUoe1xuICAgICAgICAgICAgICBvcGFjaXR5OiBsXG4gICAgICAgICAgICB9LCBuKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMgJiYgZyAmJiBkLnBvaW50cyAmJiBkLnNldEFsbFBvaW50c1RvU3RhdGUoYSk7XG4gICAgICB9LFxuICAgICAgc2V0QWxsUG9pbnRzVG9TdGF0ZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdGhpcy5wb2ludHMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGMuc2V0U3RhdGUgJiYgYy5zZXRTdGF0ZShhKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc2V0VmlzaWJsZTogZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgICAgZSA9IGQuY2hhcnQsXG4gICAgICAgICAgICBmID0gZC5sZWdlbmRJdGVtLFxuICAgICAgICAgICAgZyA9IGUub3B0aW9ucy5jaGFydC5pZ25vcmVIaWRkZW5TZXJpZXMsXG4gICAgICAgICAgICBoID0gZC52aXNpYmxlO1xuICAgICAgICB2YXIgayA9IChkLnZpc2libGUgPSBhID0gZC5vcHRpb25zLnZpc2libGUgPSBkLnVzZXJPcHRpb25zLnZpc2libGUgPSBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgYSA/ICFoIDogYSkgPyBcInNob3dcIiA6IFwiaGlkZVwiO1xuICAgICAgICBbXCJncm91cFwiLCBcImRhdGFMYWJlbHNHcm91cFwiLCBcIm1hcmtlckdyb3VwXCIsIFwidHJhY2tlclwiLCBcInR0XCJdLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBpZiAoZFthXSkgZFthXVtrXSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGUuaG92ZXJTZXJpZXMgPT09IGQgfHwgKGUuaG92ZXJQb2ludCAmJiBlLmhvdmVyUG9pbnQuc2VyaWVzKSA9PT0gZCkgZC5vbk1vdXNlT3V0KCk7XG4gICAgICAgIGYgJiYgZS5sZWdlbmQuY29sb3JpemVJdGVtKGQsIGEpO1xuICAgICAgICBkLmlzRGlydHkgPSAhMDtcbiAgICAgICAgZC5vcHRpb25zLnN0YWNraW5nICYmIGUuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhLm9wdGlvbnMuc3RhY2tpbmcgJiYgYS52aXNpYmxlICYmIChhLmlzRGlydHkgPSAhMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkLmxpbmtlZFNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgYy5zZXRWaXNpYmxlKGEsICExKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGcgJiYgKGUuaXNEaXJ0eUJveCA9ICEwKTtcbiAgICAgICAgSihkLCBrKTtcbiAgICAgICAgITEgIT09IGMgJiYgZS5yZWRyYXcoKTtcbiAgICAgIH0sXG4gICAgICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0VmlzaWJsZSghMCk7XG4gICAgICB9LFxuICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldFZpc2libGUoITEpO1xuICAgICAgfSxcbiAgICAgIHNlbGVjdDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IGEgPSB0aGlzLm9wdGlvbnMuc2VsZWN0ZWQgPSBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgYSA/ICF0aGlzLnNlbGVjdGVkIDogYTtcbiAgICAgICAgdGhpcy5jaGVja2JveCAmJiAodGhpcy5jaGVja2JveC5jaGVja2VkID0gYSk7XG4gICAgICAgIEoodGhpcywgYSA/IFwic2VsZWN0XCIgOiBcInVuc2VsZWN0XCIpO1xuICAgICAgfSxcbiAgICAgIGRyYXdUcmFja2VyOiBkLmRyYXdUcmFja2VyR3JhcGhcbiAgICB9KTtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9SZXNwb25zaXZlLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgdmFyIHIgPSBnLmZpbmQsXG4gICAgICAgIHUgPSBnLmlzQXJyYXksXG4gICAgICAgIEkgPSBnLmlzT2JqZWN0LFxuICAgICAgICBNID0gZy5tZXJnZSxcbiAgICAgICAgRSA9IGcub2JqZWN0RWFjaCxcbiAgICAgICAgQSA9IGcucGljayxcbiAgICAgICAgRyA9IGcuc3BsYXQsXG4gICAgICAgIEogPSBnLnVuaXF1ZUtleTtcbiAgICBkID0gZC5DaGFydDtcblxuICAgIGQucHJvdG90eXBlLnNldFJlc3BvbnNpdmUgPSBmdW5jdGlvbiAoZCwgZykge1xuICAgICAgdmFyIHQgPSB0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSxcbiAgICAgICAgICBoID0gW10sXG4gICAgICAgICAgdSA9IHRoaXMuY3VycmVudFJlc3BvbnNpdmU7XG4gICAgICAhZyAmJiB0ICYmIHQucnVsZXMgJiYgdC5ydWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBkLl9pZCAmJiAoZC5faWQgPSBKKCkpO1xuICAgICAgICB0aGlzLm1hdGNoUmVzcG9uc2l2ZVJ1bGUoZCwgaCk7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIGcgPSBNLmFwcGx5KDAsIGgubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiByKHQucnVsZXMsIGZ1bmN0aW9uIChnKSB7XG4gICAgICAgICAgcmV0dXJuIGcuX2lkID09PSBkO1xuICAgICAgICB9KS5jaGFydE9wdGlvbnM7XG4gICAgICB9KSk7XG4gICAgICBnLmlzUmVzcG9uc2l2ZU9wdGlvbnMgPSAhMDtcbiAgICAgIGggPSBoLnRvU3RyaW5nKCkgfHwgdm9pZCAwO1xuICAgICAgaCAhPT0gKHUgJiYgdS5ydWxlSWRzKSAmJiAodSAmJiB0aGlzLnVwZGF0ZSh1LnVuZG9PcHRpb25zLCBkLCAhMCksIGggPyAodSA9IHRoaXMuY3VycmVudE9wdGlvbnMoZyksIHUuaXNSZXNwb25zaXZlT3B0aW9ucyA9ICEwLCB0aGlzLmN1cnJlbnRSZXNwb25zaXZlID0ge1xuICAgICAgICBydWxlSWRzOiBoLFxuICAgICAgICBtZXJnZWRPcHRpb25zOiBnLFxuICAgICAgICB1bmRvT3B0aW9uczogdVxuICAgICAgfSwgdGhpcy51cGRhdGUoZywgZCwgITApKSA6IHRoaXMuY3VycmVudFJlc3BvbnNpdmUgPSB2b2lkIDApO1xuICAgIH07XG5cbiAgICBkLnByb3RvdHlwZS5tYXRjaFJlc3BvbnNpdmVSdWxlID0gZnVuY3Rpb24gKGQsIGcpIHtcbiAgICAgIHZhciByID0gZC5jb25kaXRpb247XG4gICAgICAoci5jYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYXJ0V2lkdGggPD0gQShyLm1heFdpZHRoLCBOdW1iZXIuTUFYX1ZBTFVFKSAmJiB0aGlzLmNoYXJ0SGVpZ2h0IDw9IEEoci5tYXhIZWlnaHQsIE51bWJlci5NQVhfVkFMVUUpICYmIHRoaXMuY2hhcnRXaWR0aCA+PSBBKHIubWluV2lkdGgsIDApICYmIHRoaXMuY2hhcnRIZWlnaHQgPj0gQShyLm1pbkhlaWdodCwgMCk7XG4gICAgICB9KS5jYWxsKHRoaXMpICYmIGcucHVzaChkLl9pZCk7XG4gICAgfTtcblxuICAgIGQucHJvdG90eXBlLmN1cnJlbnRPcHRpb25zID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgIGZ1bmN0aW9uIGcoZCwgaCwgdCwgZSkge1xuICAgICAgICB2YXIgYztcbiAgICAgICAgRShkLCBmdW5jdGlvbiAoZCwgbikge1xuICAgICAgICAgIGlmICghZSAmJiAtMSA8IHIuY29sbGVjdGlvbnNXaXRoVXBkYXRlLmluZGV4T2YobikpIGZvciAoZCA9IEcoZCksIHRbbl0gPSBbXSwgYyA9IDA7IGMgPCBkLmxlbmd0aDsgYysrKSBoW25dW2NdICYmICh0W25dW2NdID0ge30sIGcoZFtjXSwgaFtuXVtjXSwgdFtuXVtjXSwgZSArIDEpKTtlbHNlIEkoZCkgPyAodFtuXSA9IHUoZCkgPyBbXSA6IHt9LCBnKGQsIGhbbl0gfHwge30sIHRbbl0sIGUgKyAxKSkgOiB0W25dID0gXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGhbbl0gPyBudWxsIDogaFtuXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByID0gdGhpcyxcbiAgICAgICAgICBoID0ge307XG4gICAgICBnKGQsIHRoaXMub3B0aW9ucywgaCwgMCk7XG4gICAgICByZXR1cm4gaDtcbiAgICB9O1xuICB9KTtcbiAgUyhyLCBcIm1hc3RlcnMvaGlnaGNoYXJ0cy5zcmMuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdXSwgZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZDtcbiAgfSk7XG4gIHJbXCJtYXN0ZXJzL2hpZ2hjaGFydHMuc3JjLmpzXCJdLl9tb2R1bGVzID0gcjtcbiAgcmV0dXJuIHJbXCJtYXN0ZXJzL2hpZ2hjaGFydHMuc3JjLmpzXCJdO1xufSk7IiwiLypcbiBIaWdoY2hhcnRzIEpTIHY4LjAuNCAoMjAyMC0wMy0xMClcblxuIEV4cG9ydGluZyBtb2R1bGVcblxuIChjKSAyMDEwLTIwMTkgVG9yc3RlaW4gSG9uc2lcblxuIExpY2Vuc2U6IHd3dy5oaWdoY2hhcnRzLmNvbS9saWNlbnNlXG4qL1xuKGZ1bmN0aW9uIChlKSB7XG4gIFwib2JqZWN0XCIgPT09IHR5cGVvZiBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMgPyAoZVtcImRlZmF1bHRcIl0gPSBlLCBtb2R1bGUuZXhwb3J0cyA9IGUpIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoXCJoaWdoY2hhcnRzL21vZHVsZXMvZXhwb3J0aW5nXCIsIFtcImhpZ2hjaGFydHNcIl0sIGZ1bmN0aW9uIChtKSB7XG4gICAgZShtKTtcbiAgICBlLkhpZ2hjaGFydHMgPSBtO1xuICAgIHJldHVybiBlO1xuICB9KSA6IGUoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIEhpZ2hjaGFydHMgPyBIaWdoY2hhcnRzIDogdm9pZCAwKTtcbn0pKGZ1bmN0aW9uIChlKSB7XG4gIGZ1bmN0aW9uIG0oZiwgZywgZSwgbikge1xuICAgIGYuaGFzT3duUHJvcGVydHkoZykgfHwgKGZbZ10gPSBuLmFwcGx5KG51bGwsIGUpKTtcbiAgfVxuXG4gIGUgPSBlID8gZS5fbW9kdWxlcyA6IHt9O1xuICBtKGUsIFwibW9kdWxlcy9mdWxsLXNjcmVlbi5zcmMuanNcIiwgW2VbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdXSwgZnVuY3Rpb24gKGYpIHtcbiAgICB2YXIgZyA9IGYuYWRkRXZlbnQsXG4gICAgICAgIGUgPSBmLkNoYXJ0LFxuICAgICAgICBuID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gZyhoKSB7XG4gICAgICAgIHRoaXMuY2hhcnQgPSBoO1xuICAgICAgICB0aGlzLmlzT3BlbiA9ICExO1xuICAgICAgICBoLmNvbnRhaW5lci5wYXJlbnROb2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiAoaCA9IGguY29udGFpbmVyLnBhcmVudE5vZGUsIHRoaXMuYnJvd3NlclByb3BzIHx8IChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBoLnJlcXVlc3RGdWxsc2NyZWVuID8gdGhpcy5icm93c2VyUHJvcHMgPSB7XG4gICAgICAgICAgZnVsbHNjcmVlbkNoYW5nZTogXCJmdWxsc2NyZWVuY2hhbmdlXCIsXG4gICAgICAgICAgcmVxdWVzdEZ1bGxzY3JlZW46IFwicmVxdWVzdEZ1bGxzY3JlZW5cIixcbiAgICAgICAgICBleGl0RnVsbHNjcmVlbjogXCJleGl0RnVsbHNjcmVlblwiXG4gICAgICAgIH0gOiBoLm1velJlcXVlc3RGdWxsU2NyZWVuID8gdGhpcy5icm93c2VyUHJvcHMgPSB7XG4gICAgICAgICAgZnVsbHNjcmVlbkNoYW5nZTogXCJtb3pmdWxsc2NyZWVuY2hhbmdlXCIsXG4gICAgICAgICAgcmVxdWVzdEZ1bGxzY3JlZW46IFwibW96UmVxdWVzdEZ1bGxTY3JlZW5cIixcbiAgICAgICAgICBleGl0RnVsbHNjcmVlbjogXCJtb3pDYW5jZWxGdWxsU2NyZWVuXCJcbiAgICAgICAgfSA6IGgud2Via2l0UmVxdWVzdEZ1bGxTY3JlZW4gPyB0aGlzLmJyb3dzZXJQcm9wcyA9IHtcbiAgICAgICAgICBmdWxsc2NyZWVuQ2hhbmdlOiBcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIixcbiAgICAgICAgICByZXF1ZXN0RnVsbHNjcmVlbjogXCJ3ZWJraXRSZXF1ZXN0RnVsbFNjcmVlblwiLFxuICAgICAgICAgIGV4aXRGdWxsc2NyZWVuOiBcIndlYmtpdEV4aXRGdWxsc2NyZWVuXCJcbiAgICAgICAgfSA6IGgubXNSZXF1ZXN0RnVsbHNjcmVlbiAmJiAodGhpcy5icm93c2VyUHJvcHMgPSB7XG4gICAgICAgICAgZnVsbHNjcmVlbkNoYW5nZTogXCJNU0Z1bGxzY3JlZW5DaGFuZ2VcIixcbiAgICAgICAgICByZXF1ZXN0RnVsbHNjcmVlbjogXCJtc1JlcXVlc3RGdWxsc2NyZWVuXCIsXG4gICAgICAgICAgZXhpdEZ1bGxzY3JlZW46IFwibXNFeGl0RnVsbHNjcmVlblwiXG4gICAgICAgIH0pKSk7XG4gICAgICB9XG5cbiAgICAgIGcucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaCA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIGlmICh0aGlzLmlzT3BlbiAmJiB0aGlzLmJyb3dzZXJQcm9wcyAmJiBoLmNvbnRhaW5lci5vd25lckRvY3VtZW50IGluc3RhbmNlb2YgRG9jdW1lbnQpIGguY29udGFpbmVyLm93bmVyRG9jdW1lbnRbdGhpcy5icm93c2VyUHJvcHMuZXhpdEZ1bGxzY3JlZW5dKCk7XG4gICAgICAgIHRoaXMudW5iaW5kRnVsbHNjcmVlbkV2ZW50ICYmIHRoaXMudW5iaW5kRnVsbHNjcmVlbkV2ZW50KCk7XG4gICAgICAgIHRoaXMuaXNPcGVuID0gITE7XG4gICAgICAgIHRoaXMuc2V0QnV0dG9uVGV4dCgpO1xuICAgICAgfTtcblxuICAgICAgZy5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGggPSB0aGlzLFxuICAgICAgICAgICAgZyA9IGguY2hhcnQ7XG5cbiAgICAgICAgaWYgKGguYnJvd3NlclByb3BzKSB7XG4gICAgICAgICAgaC51bmJpbmRGdWxsc2NyZWVuRXZlbnQgPSBmLmFkZEV2ZW50KGcuY29udGFpbmVyLm93bmVyRG9jdW1lbnQsIGguYnJvd3NlclByb3BzLmZ1bGxzY3JlZW5DaGFuZ2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGguaXNPcGVuID8gKGguaXNPcGVuID0gITEsIGguY2xvc2UoKSkgOiAoaC5pc09wZW4gPSAhMCwgaC5zZXRCdXR0b25UZXh0KCkpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGcuY29udGFpbmVyLnBhcmVudE5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IGcuY29udGFpbmVyLnBhcmVudE5vZGVbaC5icm93c2VyUHJvcHMucmVxdWVzdEZ1bGxzY3JlZW5dKCk7XG4gICAgICAgICAgICBpZiAoZSkgZVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgYWxlcnQoXCJGdWxsIHNjcmVlbiBpcyBub3Qgc3VwcG9ydGVkIGluc2lkZSBhIGZyYW1lLlwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGYuYWRkRXZlbnQoZywgXCJkZXN0cm95XCIsIGgudW5iaW5kRnVsbHNjcmVlbkV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZy5wcm90b3R5cGUuc2V0QnV0dG9uVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGgsXG4gICAgICAgICAgICBnID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGYgPSBnLmV4cG9ydERpdkVsZW1lbnRzLFxuICAgICAgICAgICAgZSA9IGcub3B0aW9ucy5leHBvcnRpbmcsXG4gICAgICAgICAgICBuID0gbnVsbCA9PT0gKGggPSBudWxsID09PSBlIHx8IHZvaWQgMCA9PT0gZSA/IHZvaWQgMCA6IGUuYnV0dG9ucykgfHwgdm9pZCAwID09PSBoID8gdm9pZCAwIDogaC5jb250ZXh0QnV0dG9uLm1lbnVJdGVtcztcbiAgICAgICAgaCA9IGcub3B0aW9ucy5sYW5nO1xuICAgICAgICAobnVsbCA9PT0gZSB8fCB2b2lkIDAgPT09IGUgPyAwIDogZS5tZW51SXRlbURlZmluaXRpb25zKSAmJiAobnVsbCA9PT0gaCB8fCB2b2lkIDAgPT09IGggPyAwIDogaC5leGl0RnVsbHNjcmVlbikgJiYgaC52aWV3RnVsbHNjcmVlbiAmJiBuICYmIGYgJiYgZi5sZW5ndGggJiYgKGZbbi5pbmRleE9mKFwidmlld0Z1bGxzY3JlZW5cIildLmlubmVySFRNTCA9IHRoaXMuaXNPcGVuID8gaC5leGl0RnVsbHNjcmVlbiA6IGUubWVudUl0ZW1EZWZpbml0aW9ucy52aWV3RnVsbHNjcmVlbi50ZXh0IHx8IGgudmlld0Z1bGxzY3JlZW4pO1xuICAgICAgfTtcblxuICAgICAgZy5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzT3BlbiA/IHRoaXMuY2xvc2UoKSA6IHRoaXMub3BlbigpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGc7XG4gICAgfSgpO1xuXG4gICAgZi5GdWxsc2NyZWVuID0gbjtcbiAgICBnKGUsIFwiYmVmb3JlUmVuZGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZnVsbHNjcmVlbiA9IG5ldyBmLkZ1bGxzY3JlZW4odGhpcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGYuRnVsbHNjcmVlbjtcbiAgfSk7XG4gIG0oZSwgXCJtaXhpbnMvbmF2aWdhdGlvbi5qc1wiLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpbml0VXBkYXRlOiBmdW5jdGlvbiAoZikge1xuICAgICAgICBmLm5hdmlnYXRpb24gfHwgKGYubmF2aWdhdGlvbiA9IHtcbiAgICAgICAgICB1cGRhdGVzOiBbXSxcbiAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChnLCBmKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBlLnVwZGF0ZS5jYWxsKGUuY29udGV4dCwgZywgZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGFkZFVwZGF0ZTogZnVuY3Rpb24gKGYsIGcpIHtcbiAgICAgICAgZy5uYXZpZ2F0aW9uIHx8IHRoaXMuaW5pdFVwZGF0ZShnKTtcbiAgICAgICAgZy5uYXZpZ2F0aW9uLnVwZGF0ZXMucHVzaCh7XG4gICAgICAgICAgdXBkYXRlOiBmLFxuICAgICAgICAgIGNvbnRleHQ6IGdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIG0oZSwgXCJtb2R1bGVzL2V4cG9ydGluZy5zcmMuanNcIiwgW2VbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCBlW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdLCBlW1wibWl4aW5zL25hdmlnYXRpb24uanNcIl1dLCBmdW5jdGlvbiAoZiwgZywgZSkge1xuICAgIHZhciBuID0gZy5hZGRFdmVudCxcbiAgICAgICAgdSA9IGcuY3NzLFxuICAgICAgICBoID0gZy5jcmVhdGVFbGVtZW50LFxuICAgICAgICBtID0gZy5kaXNjYXJkRWxlbWVudCxcbiAgICAgICAgeCA9IGcuZXh0ZW5kLFxuICAgICAgICBJID0gZy5maW5kLFxuICAgICAgICBCID0gZy5maXJlRXZlbnQsXG4gICAgICAgIEogPSBnLmlzT2JqZWN0LFxuICAgICAgICBwID0gZy5tZXJnZSxcbiAgICAgICAgRSA9IGcub2JqZWN0RWFjaCxcbiAgICAgICAgcSA9IGcucGljayxcbiAgICAgICAgSyA9IGcucmVtb3ZlRXZlbnQsXG4gICAgICAgIEwgPSBnLnVuaXF1ZUtleSxcbiAgICAgICAgdyA9IGYuZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgIHkgPSBmLmRvYyxcbiAgICAgICAgQyA9IGYuQ2hhcnQsXG4gICAgICAgIE0gPSBmLmlzVG91Y2hEZXZpY2UsXG4gICAgICAgIHogPSBmLndpbixcbiAgICAgICAgRyA9IHoubmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgRiA9IGYuU1ZHUmVuZGVyZXIsXG4gICAgICAgIEggPSBmLlJlbmRlcmVyLnByb3RvdHlwZS5zeW1ib2xzLFxuICAgICAgICBOID0gL0VkZ2VcXC98VHJpZGVudFxcL3xNU0lFIC8udGVzdChHKSxcbiAgICAgICAgTyA9IC9maXJlZm94L2kudGVzdChHKTtcbiAgICB4KHcubGFuZywge1xuICAgICAgdmlld0Z1bGxzY3JlZW46IFwiVmlldyBpbiBmdWxsIHNjcmVlblwiLFxuICAgICAgZXhpdEZ1bGxzY3JlZW46IFwiRXhpdCBmcm9tIGZ1bGwgc2NyZWVuXCIsXG4gICAgICBwcmludENoYXJ0OiBcIlByaW50IGNoYXJ0XCIsXG4gICAgICBkb3dubG9hZFBORzogXCJEb3dubG9hZCBQTkcgaW1hZ2VcIixcbiAgICAgIGRvd25sb2FkSlBFRzogXCJEb3dubG9hZCBKUEVHIGltYWdlXCIsXG4gICAgICBkb3dubG9hZFBERjogXCJEb3dubG9hZCBQREYgZG9jdW1lbnRcIixcbiAgICAgIGRvd25sb2FkU1ZHOiBcIkRvd25sb2FkIFNWRyB2ZWN0b3IgaW1hZ2VcIixcbiAgICAgIGNvbnRleHRCdXR0b25UaXRsZTogXCJDaGFydCBjb250ZXh0IG1lbnVcIlxuICAgIH0pO1xuICAgIHcubmF2aWdhdGlvbiB8fCAody5uYXZpZ2F0aW9uID0ge30pO1xuICAgIHAoITAsIHcubmF2aWdhdGlvbiwge1xuICAgICAgYnV0dG9uT3B0aW9uczoge1xuICAgICAgICB0aGVtZToge30sXG4gICAgICAgIHN5bWJvbFNpemU6IDE0LFxuICAgICAgICBzeW1ib2xYOiAxMi41LFxuICAgICAgICBzeW1ib2xZOiAxMC41LFxuICAgICAgICBhbGlnbjogXCJyaWdodFwiLFxuICAgICAgICBidXR0b25TcGFjaW5nOiAzLFxuICAgICAgICBoZWlnaHQ6IDIyLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcInRvcFwiLFxuICAgICAgICB3aWR0aDogMjRcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwKCEwLCB3Lm5hdmlnYXRpb24sIHtcbiAgICAgIG1lbnVTdHlsZToge1xuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM5OTk5OTlcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZmZmZmZmXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiNXB4IDBcIlxuICAgICAgfSxcbiAgICAgIG1lbnVJdGVtU3R5bGU6IHtcbiAgICAgICAgcGFkZGluZzogXCIwLjVlbSAxZW1cIixcbiAgICAgICAgY29sb3I6IFwiIzMzMzMzM1wiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIm5vbmVcIixcbiAgICAgICAgZm9udFNpemU6IE0gPyBcIjE0cHhcIiA6IFwiMTFweFwiLFxuICAgICAgICB0cmFuc2l0aW9uOiBcImJhY2tncm91bmQgMjUwbXMsIGNvbG9yIDI1MG1zXCJcbiAgICAgIH0sXG4gICAgICBtZW51SXRlbUhvdmVyU3R5bGU6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMzM1Y2FkXCIsXG4gICAgICAgIGNvbG9yOiBcIiNmZmZmZmZcIlxuICAgICAgfSxcbiAgICAgIGJ1dHRvbk9wdGlvbnM6IHtcbiAgICAgICAgc3ltYm9sRmlsbDogXCIjNjY2NjY2XCIsXG4gICAgICAgIHN5bWJvbFN0cm9rZTogXCIjNjY2NjY2XCIsXG4gICAgICAgIHN5bWJvbFN0cm9rZVdpZHRoOiAzLFxuICAgICAgICB0aGVtZToge1xuICAgICAgICAgIHBhZGRpbmc6IDVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHcuZXhwb3J0aW5nID0ge1xuICAgICAgdHlwZTogXCJpbWFnZS9wbmdcIixcbiAgICAgIHVybDogXCJodHRwczovL2V4cG9ydC5oaWdoY2hhcnRzLmNvbS9cIixcbiAgICAgIHByaW50TWF4V2lkdGg6IDc4MCxcbiAgICAgIHNjYWxlOiAyLFxuICAgICAgYnV0dG9uczoge1xuICAgICAgICBjb250ZXh0QnV0dG9uOiB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImhpZ2hjaGFydHMtY29udGV4dGJ1dHRvblwiLFxuICAgICAgICAgIG1lbnVDbGFzc05hbWU6IFwiaGlnaGNoYXJ0cy1jb250ZXh0bWVudVwiLFxuICAgICAgICAgIHN5bWJvbDogXCJtZW51XCIsXG4gICAgICAgICAgdGl0bGVLZXk6IFwiY29udGV4dEJ1dHRvblRpdGxlXCIsXG4gICAgICAgICAgbWVudUl0ZW1zOiBcInZpZXdGdWxsc2NyZWVuIHByaW50Q2hhcnQgc2VwYXJhdG9yIGRvd25sb2FkUE5HIGRvd25sb2FkSlBFRyBkb3dubG9hZFBERiBkb3dubG9hZFNWR1wiLnNwbGl0KFwiIFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWVudUl0ZW1EZWZpbml0aW9uczoge1xuICAgICAgICB2aWV3RnVsbHNjcmVlbjoge1xuICAgICAgICAgIHRleHRLZXk6IFwidmlld0Z1bGxzY3JlZW5cIixcbiAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmZ1bGxzY3JlZW4udG9nZ2xlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcmludENoYXJ0OiB7XG4gICAgICAgICAgdGV4dEtleTogXCJwcmludENoYXJ0XCIsXG4gICAgICAgICAgb25jbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5wcmludCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2VwYXJhdG9yOiB7XG4gICAgICAgICAgc2VwYXJhdG9yOiAhMFxuICAgICAgICB9LFxuICAgICAgICBkb3dubG9hZFBORzoge1xuICAgICAgICAgIHRleHRLZXk6IFwiZG93bmxvYWRQTkdcIixcbiAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmV4cG9ydENoYXJ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkb3dubG9hZEpQRUc6IHtcbiAgICAgICAgICB0ZXh0S2V5OiBcImRvd25sb2FkSlBFR1wiLFxuICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwb3J0Q2hhcnQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImltYWdlL2pwZWdcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkb3dubG9hZFBERjoge1xuICAgICAgICAgIHRleHRLZXk6IFwiZG93bmxvYWRQREZcIixcbiAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmV4cG9ydENoYXJ0KHtcbiAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9wZGZcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkb3dubG9hZFNWRzoge1xuICAgICAgICAgIHRleHRLZXk6IFwiZG93bmxvYWRTVkdcIixcbiAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmV4cG9ydENoYXJ0KHtcbiAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZS9zdmcreG1sXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmLnBvc3QgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgdmFyIGQgPSBoKFwiZm9ybVwiLCBwKHtcbiAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgYWN0aW9uOiBhLFxuICAgICAgICBlbmN0eXBlOiBcIm11bHRpcGFydC9mb3JtLWRhdGFcIlxuICAgICAgfSwgYyksIHtcbiAgICAgICAgZGlzcGxheTogXCJub25lXCJcbiAgICAgIH0sIHkuYm9keSk7XG4gICAgICBFKGIsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGgoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgdHlwZTogXCJoaWRkZW5cIixcbiAgICAgICAgICBuYW1lOiBiLFxuICAgICAgICAgIHZhbHVlOiBhXG4gICAgICAgIH0sIG51bGwsIGQpO1xuICAgICAgfSk7XG4gICAgICBkLnN1Ym1pdCgpO1xuICAgICAgbShkKTtcbiAgICB9O1xuXG4gICAgZi5pc1NhZmFyaSAmJiBmLndpbi5tYXRjaE1lZGlhKFwicHJpbnRcIikuYWRkTGlzdGVuZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgIGYucHJpbnRpbmdDaGFydCAmJiAoYS5tYXRjaGVzID8gZi5wcmludGluZ0NoYXJ0LmJlZm9yZVByaW50KCkgOiBmLnByaW50aW5nQ2hhcnQuYWZ0ZXJQcmludCgpKTtcbiAgICB9KTtcbiAgICB4KEMucHJvdG90eXBlLCB7XG4gICAgICBzYW5pdGl6ZVNWRzogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGMgPSBhLmluZGV4T2YoXCI8L3N2Zz5cIikgKyA2LFxuICAgICAgICAgICAgZCA9IGEuc3Vic3RyKGMpO1xuICAgICAgICBhID0gYS5zdWJzdHIoMCwgYyk7XG4gICAgICAgIGIgJiYgYi5leHBvcnRpbmcgJiYgYi5leHBvcnRpbmcuYWxsb3dIVE1MICYmIGQgJiYgKGQgPSAnPGZvcmVpZ25PYmplY3QgeD1cIjBcIiB5PVwiMFwiIHdpZHRoPVwiJyArIGIuY2hhcnQud2lkdGggKyAnXCIgaGVpZ2h0PVwiJyArIGIuY2hhcnQuaGVpZ2h0ICsgJ1wiPjxib2R5IHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPicgKyBkICsgXCI8L2JvZHk+PC9mb3JlaWduT2JqZWN0PlwiLCBhID0gYS5yZXBsYWNlKFwiPC9zdmc+XCIsIGQgKyBcIjwvc3ZnPlwiKSk7XG4gICAgICAgIGEgPSBhLnJlcGxhY2UoL3pJbmRleD1cIlteXCJdK1wiL2csIFwiXCIpLnJlcGxhY2UoL3N5bWJvbE5hbWU9XCJbXlwiXStcIi9nLCBcIlwiKS5yZXBsYWNlKC9qUXVlcnlbMC05XSs9XCJbXlwiXStcIi9nLCBcIlwiKS5yZXBsYWNlKC91cmxcXCgoXCJ8JnF1b3Q7KSguKj8pKFwifCZxdW90Oyk7P1xcKS9nLCBcInVybCgkMilcIikucmVwbGFjZSgvdXJsXFwoW14jXSsjL2csIFwidXJsKCNcIikucmVwbGFjZSgvPHN2ZyAvLCAnPHN2ZyB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiAnKS5yZXBsYWNlKC8gKHxOU1swLTldKzopaHJlZj0vZywgXCIgeGxpbms6aHJlZj1cIikucmVwbGFjZSgvXFxuLywgXCIgXCIpLnJlcGxhY2UoLyhmaWxsfHN0cm9rZSk9XCJyZ2JhXFwoKFsgMC05XSssWyAwLTldKyxbIDAtOV0rKSwoWyAwLTlcXC5dKylcXClcIi9nLCAnJDE9XCJyZ2IoJDIpXCIgJDEtb3BhY2l0eT1cIiQzXCInKS5yZXBsYWNlKC8mbmJzcDsvZywgXCJcXHUwMGEwXCIpLnJlcGxhY2UoLyZzaHk7L2csIFwiXFx1MDBhZFwiKTtcbiAgICAgICAgdGhpcy5pZVNhbml0aXplU1ZHICYmIChhID0gdGhpcy5pZVNhbml0aXplU1ZHKGEpKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9LFxuICAgICAgZ2V0Q2hhcnRIVE1MOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3R5bGVkTW9kZSAmJiB0aGlzLmlubGluZVN0eWxlcygpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIuaW5uZXJIVE1MO1xuICAgICAgfSxcbiAgICAgIGdldFNWRzogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGIsXG4gICAgICAgICAgICBjID0gcCh0aGlzLm9wdGlvbnMsIGEpO1xuICAgICAgICBjLnBsb3RPcHRpb25zID0gcCh0aGlzLnVzZXJPcHRpb25zLnBsb3RPcHRpb25zLCBhICYmIGEucGxvdE9wdGlvbnMpO1xuICAgICAgICBjLnRpbWUgPSBwKHRoaXMudXNlck9wdGlvbnMudGltZSwgYSAmJiBhLnRpbWUpO1xuICAgICAgICB2YXIgZCA9IGgoXCJkaXZcIiwgbnVsbCwge1xuICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgdG9wOiBcIi05OTk5ZW1cIixcbiAgICAgICAgICB3aWR0aDogdGhpcy5jaGFydFdpZHRoICsgXCJweFwiLFxuICAgICAgICAgIGhlaWdodDogdGhpcy5jaGFydEhlaWdodCArIFwicHhcIlxuICAgICAgICB9LCB5LmJvZHkpO1xuICAgICAgICB2YXIgZyA9IHRoaXMucmVuZGVyVG8uc3R5bGUud2lkdGg7XG4gICAgICAgIHZhciBlID0gdGhpcy5yZW5kZXJUby5zdHlsZS5oZWlnaHQ7XG4gICAgICAgIGcgPSBjLmV4cG9ydGluZy5zb3VyY2VXaWR0aCB8fCBjLmNoYXJ0LndpZHRoIHx8IC9weCQvLnRlc3QoZykgJiYgcGFyc2VJbnQoZywgMTApIHx8IChjLmlzR2FudHQgPyA4MDAgOiA2MDApO1xuICAgICAgICBlID0gYy5leHBvcnRpbmcuc291cmNlSGVpZ2h0IHx8IGMuY2hhcnQuaGVpZ2h0IHx8IC9weCQvLnRlc3QoZSkgJiYgcGFyc2VJbnQoZSwgMTApIHx8IDQwMDtcbiAgICAgICAgeChjLmNoYXJ0LCB7XG4gICAgICAgICAgYW5pbWF0aW9uOiAhMSxcbiAgICAgICAgICByZW5kZXJUbzogZCxcbiAgICAgICAgICBmb3JFeHBvcnQ6ICEwLFxuICAgICAgICAgIHJlbmRlcmVyOiBcIlNWR1JlbmRlcmVyXCIsXG4gICAgICAgICAgd2lkdGg6IGcsXG4gICAgICAgICAgaGVpZ2h0OiBlXG4gICAgICAgIH0pO1xuICAgICAgICBjLmV4cG9ydGluZy5lbmFibGVkID0gITE7XG4gICAgICAgIGRlbGV0ZSBjLmRhdGE7XG4gICAgICAgIGMuc2VyaWVzID0gW107XG4gICAgICAgIHRoaXMuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBiID0gcChhLnVzZXJPcHRpb25zLCB7XG4gICAgICAgICAgICBhbmltYXRpb246ICExLFxuICAgICAgICAgICAgZW5hYmxlTW91c2VUcmFja2luZzogITEsXG4gICAgICAgICAgICBzaG93Q2hlY2tib3g6ICExLFxuICAgICAgICAgICAgdmlzaWJsZTogYS52aXNpYmxlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYi5pc0ludGVybmFsIHx8IGMuc2VyaWVzLnB1c2goYik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmF4ZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEudXNlck9wdGlvbnMuaW50ZXJuYWxLZXkgfHwgKGEudXNlck9wdGlvbnMuaW50ZXJuYWxLZXkgPSBMKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHIgPSBuZXcgZi5DaGFydChjLCB0aGlzLmNhbGxiYWNrKTtcbiAgICAgICAgYSAmJiBbXCJ4QXhpc1wiLCBcInlBeGlzXCIsIFwic2VyaWVzXCJdLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICB2YXIgZCA9IHt9O1xuICAgICAgICAgIGFbYl0gJiYgKGRbYl0gPSBhW2JdLCByLnVwZGF0ZShkKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmF4ZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHZhciBiID0gSShyLmF4ZXMsIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5vcHRpb25zLmludGVybmFsS2V5ID09PSBhLnVzZXJPcHRpb25zLmludGVybmFsS2V5O1xuICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBkID0gYS5nZXRFeHRyZW1lcygpLFxuICAgICAgICAgICAgICBjID0gZC51c2VyTWluO1xuICAgICAgICAgIGQgPSBkLnVzZXJNYXg7XG4gICAgICAgICAgYiAmJiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGMgJiYgYyAhPT0gYi5taW4gfHwgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGQgJiYgZCAhPT0gYi5tYXgpICYmIGIuc2V0RXh0cmVtZXMoYywgZCwgITAsICExKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGcgPSByLmdldENoYXJ0SFRNTCgpO1xuICAgICAgICBCKHRoaXMsIFwiZ2V0U1ZHXCIsIHtcbiAgICAgICAgICBjaGFydENvcHk6IHJcbiAgICAgICAgfSk7XG4gICAgICAgIGcgPSB0aGlzLnNhbml0aXplU1ZHKGcsIGMpO1xuICAgICAgICBjID0gbnVsbDtcbiAgICAgICAgci5kZXN0cm95KCk7XG4gICAgICAgIG0oZCk7XG4gICAgICAgIHJldHVybiBnO1xuICAgICAgfSxcbiAgICAgIGdldFNWR0ZvckV4cG9ydDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLm9wdGlvbnMuZXhwb3J0aW5nO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTVkcocCh7XG4gICAgICAgICAgY2hhcnQ6IHtcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSwgYy5jaGFydE9wdGlvbnMsIGIsIHtcbiAgICAgICAgICBleHBvcnRpbmc6IHtcbiAgICAgICAgICAgIHNvdXJjZVdpZHRoOiBhICYmIGEuc291cmNlV2lkdGggfHwgYy5zb3VyY2VXaWR0aCxcbiAgICAgICAgICAgIHNvdXJjZUhlaWdodDogYSAmJiBhLnNvdXJjZUhlaWdodCB8fCBjLnNvdXJjZUhlaWdodFxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIGdldEZpbGVuYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy51c2VyT3B0aW9ucy50aXRsZSAmJiB0aGlzLnVzZXJPcHRpb25zLnRpdGxlLnRleHQsXG4gICAgICAgICAgICBiID0gdGhpcy5vcHRpb25zLmV4cG9ydGluZy5maWxlbmFtZTtcbiAgICAgICAgaWYgKGIpIHJldHVybiBiLnJlcGxhY2UoL1xcLy9nLCBcIi1cIik7XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBhICYmIChiID0gYS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLzxcXC8/W14+XSsoPnwkKS9nLCBcIlwiKS5yZXBsYWNlKC9bXFxzX10rL2csIFwiLVwiKS5yZXBsYWNlKC9bXmEtejAtOVxcLV0vZywgXCJcIikucmVwbGFjZSgvXltcXC1dKy9nLCBcIlwiKS5yZXBsYWNlKC9bXFwtXSsvZywgXCItXCIpLnN1YnN0cigwLCAyNCkucmVwbGFjZSgvW1xcLV0rJC9nLCBcIlwiKSk7XG4gICAgICAgIGlmICghYiB8fCA1ID4gYi5sZW5ndGgpIGIgPSBcImNoYXJ0XCI7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSxcbiAgICAgIGV4cG9ydENoYXJ0OiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBiID0gdGhpcy5nZXRTVkdGb3JFeHBvcnQoYSwgYik7XG4gICAgICAgIGEgPSBwKHRoaXMub3B0aW9ucy5leHBvcnRpbmcsIGEpO1xuICAgICAgICBmLnBvc3QoYS51cmwsIHtcbiAgICAgICAgICBmaWxlbmFtZTogYS5maWxlbmFtZSA/IGEuZmlsZW5hbWUucmVwbGFjZSgvXFwvL2csIFwiLVwiKSA6IHRoaXMuZ2V0RmlsZW5hbWUoKSxcbiAgICAgICAgICB0eXBlOiBhLnR5cGUsXG4gICAgICAgICAgd2lkdGg6IGEud2lkdGggfHwgMCxcbiAgICAgICAgICBzY2FsZTogYS5zY2FsZSxcbiAgICAgICAgICBzdmc6IGJcbiAgICAgICAgfSwgYS5mb3JtQXR0cmlidXRlcyk7XG4gICAgICB9LFxuICAgICAgbW92ZUNvbnRhaW5lcnM6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICh0aGlzLmZpeGVkRGl2ID8gW3RoaXMuZml4ZWREaXYsIHRoaXMuc2Nyb2xsaW5nQ29udGFpbmVyXSA6IFt0aGlzLmNvbnRhaW5lcl0pLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBhLmFwcGVuZENoaWxkKGIpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBiZWZvcmVQcmludDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHkuYm9keSxcbiAgICAgICAgICAgIGIgPSB0aGlzLm9wdGlvbnMuZXhwb3J0aW5nLnByaW50TWF4V2lkdGgsXG4gICAgICAgICAgICBjID0ge1xuICAgICAgICAgIGNoaWxkTm9kZXM6IGEuY2hpbGROb2RlcyxcbiAgICAgICAgICBvcmlnRGlzcGxheTogW10sXG4gICAgICAgICAgcmVzZXRQYXJhbXM6IHZvaWQgMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzUHJpbnRpbmcgPSAhMDtcbiAgICAgICAgdGhpcy5wb2ludGVyLnJlc2V0KG51bGwsIDApO1xuICAgICAgICBCKHRoaXMsIFwiYmVmb3JlUHJpbnRcIik7XG4gICAgICAgIGIgJiYgdGhpcy5jaGFydFdpZHRoID4gYiAmJiAoYy5yZXNldFBhcmFtcyA9IFt0aGlzLm9wdGlvbnMuY2hhcnQud2lkdGgsIHZvaWQgMCwgITFdLCB0aGlzLnNldFNpemUoYiwgdm9pZCAwLCAhMSkpO1xuICAgICAgICBbXS5mb3JFYWNoLmNhbGwoYy5jaGlsZE5vZGVzLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIDEgPT09IGEubm9kZVR5cGUgJiYgKGMub3JpZ0Rpc3BsYXlbYl0gPSBhLnN0eWxlLmRpc3BsYXksIGEuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW92ZUNvbnRhaW5lcnMoYSk7XG4gICAgICAgIHRoaXMucHJpbnRSZXZlcnNlSW5mbyA9IGM7XG4gICAgICB9LFxuICAgICAgYWZ0ZXJQcmludDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wcmludFJldmVyc2VJbmZvKSB7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLnByaW50UmV2ZXJzZUluZm8uY2hpbGROb2RlcyxcbiAgICAgICAgICAgICAgYiA9IHRoaXMucHJpbnRSZXZlcnNlSW5mby5vcmlnRGlzcGxheSxcbiAgICAgICAgICAgICAgYyA9IHRoaXMucHJpbnRSZXZlcnNlSW5mby5yZXNldFBhcmFtcztcbiAgICAgICAgICB0aGlzLm1vdmVDb250YWluZXJzKHRoaXMucmVuZGVyVG8pO1xuICAgICAgICAgIFtdLmZvckVhY2guY2FsbChhLCBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICAgICAgMSA9PT0gYS5ub2RlVHlwZSAmJiAoYS5zdHlsZS5kaXNwbGF5ID0gYltjXSB8fCBcIlwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmlzUHJpbnRpbmcgPSAhMTtcbiAgICAgICAgICBjICYmIHRoaXMuc2V0U2l6ZS5hcHBseSh0aGlzLCBjKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5wcmludFJldmVyc2VJbmZvO1xuICAgICAgICAgIGRlbGV0ZSBmLnByaW50aW5nQ2hhcnQ7XG4gICAgICAgICAgQih0aGlzLCBcImFmdGVyUHJpbnRcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcmludDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIGEuaXNQcmludGluZyB8fCAoZi5wcmludGluZ0NoYXJ0ID0gYSwgZi5pc1NhZmFyaSB8fCBhLmJlZm9yZVByaW50KCksIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHouZm9jdXMoKTtcbiAgICAgICAgICB6LnByaW50KCk7XG4gICAgICAgICAgZi5pc1NhZmFyaSB8fCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGEuYWZ0ZXJQcmludCgpO1xuICAgICAgICAgIH0sIDFFMyk7XG4gICAgICAgIH0sIDEpKTtcbiAgICAgIH0sXG4gICAgICBjb250ZXh0TWVudTogZnVuY3Rpb24gKGEsIGIsIGMsIGQsIGUsIGYsIHIpIHtcbiAgICAgICAgdmFyIGsgPSB0aGlzLFxuICAgICAgICAgICAgRCA9IGsub3B0aW9ucy5uYXZpZ2F0aW9uLFxuICAgICAgICAgICAgcCA9IGsuY2hhcnRXaWR0aCxcbiAgICAgICAgICAgIEEgPSBrLmNoYXJ0SGVpZ2h0LFxuICAgICAgICAgICAgdCA9IFwiY2FjaGUtXCIgKyBhLFxuICAgICAgICAgICAgbCA9IGtbdF0sXG4gICAgICAgICAgICB2ID0gTWF0aC5tYXgoZSwgZik7XG5cbiAgICAgICAgaWYgKCFsKSB7XG4gICAgICAgICAgay5leHBvcnRDb250ZXh0TWVudSA9IGtbdF0gPSBsID0gaChcImRpdlwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IGFcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgekluZGV4OiAxRTMsXG4gICAgICAgICAgICBwYWRkaW5nOiB2ICsgXCJweFwiLFxuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJhdXRvXCJcbiAgICAgICAgICB9LCBrLmZpeGVkRGl2IHx8IGsuY29udGFpbmVyKTtcbiAgICAgICAgICB2YXIgbSA9IGgoXCJ1bFwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiaGlnaGNoYXJ0cy1tZW51XCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBsaXN0U3R5bGU6IFwibm9uZVwiLFxuICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgcGFkZGluZzogMFxuICAgICAgICAgIH0sIGwpO1xuICAgICAgICAgIGsuc3R5bGVkTW9kZSB8fCB1KG0sIHgoe1xuICAgICAgICAgICAgTW96Qm94U2hhZG93OiBcIjNweCAzcHggMTBweCAjODg4XCIsXG4gICAgICAgICAgICBXZWJraXRCb3hTaGFkb3c6IFwiM3B4IDNweCAxMHB4ICM4ODhcIixcbiAgICAgICAgICAgIGJveFNoYWRvdzogXCIzcHggM3B4IDEwcHggIzg4OFwiXG4gICAgICAgICAgfSwgRC5tZW51U3R5bGUpKTtcblxuICAgICAgICAgIGwuaGlkZU1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB1KGwsIHtcbiAgICAgICAgICAgICAgZGlzcGxheTogXCJub25lXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgciAmJiByLnNldFN0YXRlKDApO1xuICAgICAgICAgICAgay5vcGVuTWVudSA9ICExO1xuICAgICAgICAgICAgdShrLnJlbmRlclRvLCB7XG4gICAgICAgICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGcuY2xlYXJUaW1lb3V0KGwuaGlkZVRpbWVyKTtcbiAgICAgICAgICAgIEIoaywgXCJleHBvcnRNZW51SGlkZGVuXCIpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBrLmV4cG9ydEV2ZW50cy5wdXNoKG4obCwgXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGwuaGlkZVRpbWVyID0gei5zZXRUaW1lb3V0KGwuaGlkZU1lbnUsIDUwMCk7XG4gICAgICAgICAgfSksIG4obCwgXCJtb3VzZWVudGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGcuY2xlYXJUaW1lb3V0KGwuaGlkZVRpbWVyKTtcbiAgICAgICAgICB9KSwgbih5LCBcIm1vdXNldXBcIiwgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIGsucG9pbnRlci5pbkNsYXNzKGIudGFyZ2V0LCBhKSB8fCBsLmhpZGVNZW51KCk7XG4gICAgICAgICAgfSksIG4obCwgXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBrLm9wZW5NZW51ICYmIGwuaGlkZU1lbnUoKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgYi5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgYSAmJiAoYSA9IGsub3B0aW9ucy5leHBvcnRpbmcubWVudUl0ZW1EZWZpbml0aW9uc1thXSk7XG5cbiAgICAgICAgICAgIGlmIChKKGEsICEwKSkge1xuICAgICAgICAgICAgICBpZiAoYS5zZXBhcmF0b3IpIHZhciBiID0gaChcImhyXCIsIG51bGwsIG51bGwsIG0pO2Vsc2UgYiA9IGgoXCJsaVwiLCB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImhpZ2hjaGFydHMtbWVudS1pdGVtXCIsXG4gICAgICAgICAgICAgICAgb25jbGljazogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgICAgIGIgJiYgYi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgIGwuaGlkZU1lbnUoKTtcbiAgICAgICAgICAgICAgICAgIGEub25jbGljayAmJiBhLm9uY2xpY2suYXBwbHkoaywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlubmVySFRNTDogYS50ZXh0IHx8IGsub3B0aW9ucy5sYW5nW2EudGV4dEtleV1cbiAgICAgICAgICAgICAgfSwgbnVsbCwgbSksIGsuc3R5bGVkTW9kZSB8fCAoYi5vbm1vdXNlb3ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB1KHRoaXMsIEQubWVudUl0ZW1Ib3ZlclN0eWxlKTtcbiAgICAgICAgICAgICAgfSwgYi5vbm1vdXNlb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHUodGhpcywgRC5tZW51SXRlbVN0eWxlKTtcbiAgICAgICAgICAgICAgfSwgdShiLCB4KHtcbiAgICAgICAgICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgICAgICAgICAgIH0sIEQubWVudUl0ZW1TdHlsZSkpKTtcbiAgICAgICAgICAgICAgay5leHBvcnREaXZFbGVtZW50cy5wdXNoKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGsuZXhwb3J0RGl2RWxlbWVudHMucHVzaChtLCBsKTtcbiAgICAgICAgICBrLmV4cG9ydE1lbnVXaWR0aCA9IGwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgay5leHBvcnRNZW51SGVpZ2h0ID0gbC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBiID0ge1xuICAgICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgICAgICB9O1xuICAgICAgICBjICsgay5leHBvcnRNZW51V2lkdGggPiBwID8gYi5yaWdodCA9IHAgLSBjIC0gZSAtIHYgKyBcInB4XCIgOiBiLmxlZnQgPSBjIC0gdiArIFwicHhcIjtcbiAgICAgICAgZCArIGYgKyBrLmV4cG9ydE1lbnVIZWlnaHQgPiBBICYmIFwidG9wXCIgIT09IHIuYWxpZ25PcHRpb25zLnZlcnRpY2FsQWxpZ24gPyBiLmJvdHRvbSA9IEEgLSBkIC0gdiArIFwicHhcIiA6IGIudG9wID0gZCArIGYgLSB2ICsgXCJweFwiO1xuICAgICAgICB1KGwsIGIpO1xuICAgICAgICB1KGsucmVuZGVyVG8sIHtcbiAgICAgICAgICBvdmVyZmxvdzogXCJcIlxuICAgICAgICB9KTtcbiAgICAgICAgay5vcGVuTWVudSA9ICEwO1xuICAgICAgICBCKGssIFwiZXhwb3J0TWVudVNob3duXCIpO1xuICAgICAgfSxcbiAgICAgIGFkZEJ1dHRvbjogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICAgICAgYyA9IGIucmVuZGVyZXIsXG4gICAgICAgICAgICBkID0gcChiLm9wdGlvbnMubmF2aWdhdGlvbi5idXR0b25PcHRpb25zLCBhKSxcbiAgICAgICAgICAgIGcgPSBkLm9uY2xpY2ssXG4gICAgICAgICAgICBlID0gZC5tZW51SXRlbXMsXG4gICAgICAgICAgICBmID0gZC5zeW1ib2xTaXplIHx8IDEyO1xuICAgICAgICBiLmJ0bkNvdW50IHx8IChiLmJ0bkNvdW50ID0gMCk7XG4gICAgICAgIGIuZXhwb3J0RGl2RWxlbWVudHMgfHwgKGIuZXhwb3J0RGl2RWxlbWVudHMgPSBbXSwgYi5leHBvcnRTVkdFbGVtZW50cyA9IFtdKTtcblxuICAgICAgICBpZiAoITEgIT09IGQuZW5hYmxlZCkge1xuICAgICAgICAgIHZhciBrID0gZC50aGVtZSxcbiAgICAgICAgICAgICAgaCA9IGsuc3RhdGVzLFxuICAgICAgICAgICAgICBtID0gaCAmJiBoLmhvdmVyO1xuICAgICAgICAgIGggPSBoICYmIGguc2VsZWN0O1xuICAgICAgICAgIHZhciBBO1xuICAgICAgICAgIGIuc3R5bGVkTW9kZSB8fCAoay5maWxsID0gcShrLmZpbGwsIFwiI2ZmZmZmZlwiKSwgay5zdHJva2UgPSBxKGsuc3Ryb2tlLCBcIm5vbmVcIikpO1xuICAgICAgICAgIGRlbGV0ZSBrLnN0YXRlcztcbiAgICAgICAgICBnID8gQSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBhICYmIGEuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBnLmNhbGwoYiwgYSk7XG4gICAgICAgICAgfSA6IGUgJiYgKEEgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYSAmJiBhLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgYi5jb250ZXh0TWVudSh0Lm1lbnVDbGFzc05hbWUsIGUsIHQudHJhbnNsYXRlWCwgdC50cmFuc2xhdGVZLCB0LndpZHRoLCB0LmhlaWdodCwgdCk7XG4gICAgICAgICAgICB0LnNldFN0YXRlKDIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGQudGV4dCAmJiBkLnN5bWJvbCA/IGsucGFkZGluZ0xlZnQgPSBxKGsucGFkZGluZ0xlZnQsIDI1KSA6IGQudGV4dCB8fCB4KGssIHtcbiAgICAgICAgICAgIHdpZHRoOiBkLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBkLmhlaWdodCxcbiAgICAgICAgICAgIHBhZGRpbmc6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBiLnN0eWxlZE1vZGUgfHwgKGtbXCJzdHJva2UtbGluZWNhcFwiXSA9IFwicm91bmRcIiwgay5maWxsID0gcShrLmZpbGwsIFwiI2ZmZmZmZlwiKSwgay5zdHJva2UgPSBxKGsuc3Ryb2tlLCBcIm5vbmVcIikpO1xuICAgICAgICAgIHZhciB0ID0gYy5idXR0b24oZC50ZXh0LCAwLCAwLCBBLCBrLCBtLCBoKS5hZGRDbGFzcyhhLmNsYXNzTmFtZSkuYXR0cih7XG4gICAgICAgICAgICB0aXRsZTogcShiLm9wdGlvbnMubGFuZ1tkLl90aXRsZUtleSB8fCBkLnRpdGxlS2V5XSwgXCJcIilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0Lm1lbnVDbGFzc05hbWUgPSBhLm1lbnVDbGFzc05hbWUgfHwgXCJoaWdoY2hhcnRzLW1lbnUtXCIgKyBiLmJ0bkNvdW50Kys7XG5cbiAgICAgICAgICBpZiAoZC5zeW1ib2wpIHtcbiAgICAgICAgICAgIHZhciBsID0gYy5zeW1ib2woZC5zeW1ib2wsIGQuc3ltYm9sWCAtIGYgLyAyLCBkLnN5bWJvbFkgLSBmIC8gMiwgZiwgZiwge1xuICAgICAgICAgICAgICB3aWR0aDogZixcbiAgICAgICAgICAgICAgaGVpZ2h0OiBmXG4gICAgICAgICAgICB9KS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtYnV0dG9uLXN5bWJvbFwiKS5hdHRyKHtcbiAgICAgICAgICAgICAgekluZGV4OiAxXG4gICAgICAgICAgICB9KS5hZGQodCk7XG4gICAgICAgICAgICBiLnN0eWxlZE1vZGUgfHwgbC5hdHRyKHtcbiAgICAgICAgICAgICAgc3Ryb2tlOiBkLnN5bWJvbFN0cm9rZSxcbiAgICAgICAgICAgICAgZmlsbDogZC5zeW1ib2xGaWxsLFxuICAgICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBkLnN5bWJvbFN0cm9rZVdpZHRoIHx8IDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHQuYWRkKGIuZXhwb3J0aW5nR3JvdXApLmFsaWduKHgoZCwge1xuICAgICAgICAgICAgd2lkdGg6IHQud2lkdGgsXG4gICAgICAgICAgICB4OiBxKGQueCwgYi5idXR0b25PZmZzZXQpXG4gICAgICAgICAgfSksICEwLCBcInNwYWNpbmdCb3hcIik7XG4gICAgICAgICAgYi5idXR0b25PZmZzZXQgKz0gKHQud2lkdGggKyBkLmJ1dHRvblNwYWNpbmcpICogKFwicmlnaHRcIiA9PT0gZC5hbGlnbiA/IC0xIDogMSk7XG4gICAgICAgICAgYi5leHBvcnRTVkdFbGVtZW50cy5wdXNoKHQsIGwpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVzdHJveUV4cG9ydDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGIgPSBhID8gYS50YXJnZXQgOiB0aGlzO1xuICAgICAgICBhID0gYi5leHBvcnRTVkdFbGVtZW50cztcbiAgICAgICAgdmFyIGMgPSBiLmV4cG9ydERpdkVsZW1lbnRzLFxuICAgICAgICAgICAgZCA9IGIuZXhwb3J0RXZlbnRzLFxuICAgICAgICAgICAgZjtcbiAgICAgICAgYSAmJiAoYS5mb3JFYWNoKGZ1bmN0aW9uIChhLCBkKSB7XG4gICAgICAgICAgYSAmJiAoYS5vbmNsaWNrID0gYS5vbnRvdWNoc3RhcnQgPSBudWxsLCBmID0gXCJjYWNoZS1cIiArIGEubWVudUNsYXNzTmFtZSwgYltmXSAmJiBkZWxldGUgYltmXSwgYi5leHBvcnRTVkdFbGVtZW50c1tkXSA9IGEuZGVzdHJveSgpKTtcbiAgICAgICAgfSksIGEubGVuZ3RoID0gMCk7XG4gICAgICAgIGIuZXhwb3J0aW5nR3JvdXAgJiYgKGIuZXhwb3J0aW5nR3JvdXAuZGVzdHJveSgpLCBkZWxldGUgYi5leHBvcnRpbmdHcm91cCk7XG4gICAgICAgIGMgJiYgKGMuZm9yRWFjaChmdW5jdGlvbiAoYSwgZCkge1xuICAgICAgICAgIGcuY2xlYXJUaW1lb3V0KGEuaGlkZVRpbWVyKTtcbiAgICAgICAgICBLKGEsIFwibW91c2VsZWF2ZVwiKTtcbiAgICAgICAgICBiLmV4cG9ydERpdkVsZW1lbnRzW2RdID0gYS5vbm1vdXNlb3V0ID0gYS5vbm1vdXNlb3ZlciA9IGEub250b3VjaHN0YXJ0ID0gYS5vbmNsaWNrID0gbnVsbDtcbiAgICAgICAgICBtKGEpO1xuICAgICAgICB9KSwgYy5sZW5ndGggPSAwKTtcbiAgICAgICAgZCAmJiAoZC5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYSgpO1xuICAgICAgICB9KSwgZC5sZW5ndGggPSAwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBGLnByb3RvdHlwZS5pbmxpbmVUb0F0dHJpYnV0ZXMgPSBcImZpbGwgc3Ryb2tlIHN0cm9rZUxpbmVjYXAgc3Ryb2tlTGluZWpvaW4gc3Ryb2tlV2lkdGggdGV4dEFuY2hvciB4IHlcIi5zcGxpdChcIiBcIik7XG4gICAgRi5wcm90b3R5cGUuaW5saW5lQmxhY2tsaXN0ID0gWy8tLywgL14oY2xpcFBhdGh8Y3NzVGV4dHxkfGhlaWdodHx3aWR0aCkkLywgL15mb250JC8sIC9bbExdb2dpY2FsKFdpZHRofEhlaWdodCkkLywgL3BlcnNwZWN0aXZlLywgL1RhcEhpZ2hsaWdodENvbG9yLywgL150cmFuc2l0aW9uLywgL15sZW5ndGgkL107XG4gICAgRi5wcm90b3R5cGUudW5zdHlsZWRFbGVtZW50cyA9IFtcImNsaXBQYXRoXCIsIFwiZGVmc1wiLCBcImRlc2NcIl07XG5cbiAgICBDLnByb3RvdHlwZS5pbmxpbmVTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBhKGEpIHtcbiAgICAgICAgcmV0dXJuIGEucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBcIi1cIiArIGIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGIoYykge1xuICAgICAgICBmdW5jdGlvbiBrKGIsIGUpIHtcbiAgICAgICAgICB2ID0gdSA9ICExO1xuXG4gICAgICAgICAgaWYgKGcpIHtcbiAgICAgICAgICAgIGZvciAocSA9IGcubGVuZ3RoOyBxLS0gJiYgIXU7KSB1ID0gZ1txXS50ZXN0KGUpO1xuXG4gICAgICAgICAgICB2ID0gIXU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgXCJ0cmFuc2Zvcm1cIiA9PT0gZSAmJiBcIm5vbmVcIiA9PT0gYiAmJiAodiA9ICEwKTtcblxuICAgICAgICAgIGZvciAocSA9IGYubGVuZ3RoOyBxLS0gJiYgIXY7KSB2ID0gZltxXS50ZXN0KGUpIHx8IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGI7XG5cbiAgICAgICAgICB2IHx8IHhbZV0gPT09IGIgJiYgXCJzdmdcIiAhPT0gYy5ub2RlTmFtZSB8fCBoW2Mubm9kZU5hbWVdW2VdID09PSBiIHx8ICgtMSAhPT0gZC5pbmRleE9mKGUpID8gYy5zZXRBdHRyaWJ1dGUoYShlKSwgYikgOiBsICs9IGEoZSkgKyBcIjpcIiArIGIgKyBcIjtcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbCA9IFwiXCIsXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgdSxcbiAgICAgICAgICAgIHE7XG5cbiAgICAgICAgaWYgKDEgPT09IGMubm9kZVR5cGUgJiYgLTEgPT09IGUuaW5kZXhPZihjLm5vZGVOYW1lKSkge1xuICAgICAgICAgIHZhciByID0gei5nZXRDb21wdXRlZFN0eWxlKGMsIG51bGwpO1xuICAgICAgICAgIHZhciB4ID0gXCJzdmdcIiA9PT0gYy5ub2RlTmFtZSA/IHt9IDogei5nZXRDb21wdXRlZFN0eWxlKGMucGFyZW50Tm9kZSwgbnVsbCk7XG5cbiAgICAgICAgICBpZiAoIWhbYy5ub2RlTmFtZV0pIHtcbiAgICAgICAgICAgIG0gPSBuLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3ZnXCIpWzBdO1xuICAgICAgICAgICAgdmFyIHcgPSBuLmNyZWF0ZUVsZW1lbnROUyhjLm5hbWVzcGFjZVVSSSwgYy5ub2RlTmFtZSk7XG4gICAgICAgICAgICBtLmFwcGVuZENoaWxkKHcpO1xuICAgICAgICAgICAgaFtjLm5vZGVOYW1lXSA9IHAoei5nZXRDb21wdXRlZFN0eWxlKHcsIG51bGwpKTtcbiAgICAgICAgICAgIFwidGV4dFwiID09PSBjLm5vZGVOYW1lICYmIGRlbGV0ZSBoLnRleHQuZmlsbDtcbiAgICAgICAgICAgIG0ucmVtb3ZlQ2hpbGQodyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKE8gfHwgTikgZm9yICh2YXIgeSBpbiByKSBrKHJbeV0sIHkpO2Vsc2UgRShyLCBrKTtcbiAgICAgICAgICBsICYmIChyID0gYy5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSwgYy5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCAociA/IHIgKyBcIjtcIiA6IFwiXCIpICsgbCkpO1xuICAgICAgICAgIFwic3ZnXCIgPT09IGMubm9kZU5hbWUgJiYgYy5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgXCIxcHhcIik7XG4gICAgICAgICAgXCJ0ZXh0XCIgIT09IGMubm9kZU5hbWUgJiYgW10uZm9yRWFjaC5jYWxsKGMuY2hpbGRyZW4gfHwgYy5jaGlsZE5vZGVzLCBiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYyA9IHRoaXMucmVuZGVyZXIsXG4gICAgICAgICAgZCA9IGMuaW5saW5lVG9BdHRyaWJ1dGVzLFxuICAgICAgICAgIGYgPSBjLmlubGluZUJsYWNrbGlzdCxcbiAgICAgICAgICBnID0gYy5pbmxpbmVXaGl0ZWxpc3QsXG4gICAgICAgICAgZSA9IGMudW5zdHlsZWRFbGVtZW50cyxcbiAgICAgICAgICBoID0ge30sXG4gICAgICAgICAgbTtcbiAgICAgIGMgPSB5LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgICB1KGMsIHtcbiAgICAgICAgd2lkdGg6IFwiMXB4XCIsXG4gICAgICAgIGhlaWdodDogXCIxcHhcIixcbiAgICAgICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIlxuICAgICAgfSk7XG4gICAgICB5LmJvZHkuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICB2YXIgbiA9IGMuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICAgIG4ub3BlbigpO1xuICAgICAgbi53cml0ZSgnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PC9zdmc+Jyk7XG4gICAgICBuLmNsb3NlKCk7XG4gICAgICBiKHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIikpO1xuICAgICAgbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG0pO1xuICAgIH07XG5cbiAgICBILm1lbnUgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgcmV0dXJuIFtcIk1cIiwgYSwgYiArIDIuNSwgXCJMXCIsIGEgKyBjLCBiICsgMi41LCBcIk1cIiwgYSwgYiArIGQgLyAyICsgLjUsIFwiTFwiLCBhICsgYywgYiArIGQgLyAyICsgLjUsIFwiTVwiLCBhLCBiICsgZCAtIDEuNSwgXCJMXCIsIGEgKyBjLCBiICsgZCAtIDEuNV07XG4gICAgfTtcblxuICAgIEgubWVudWJhbGwgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgYSA9IFtdO1xuICAgICAgZCA9IGQgLyAzIC0gMjtcbiAgICAgIHJldHVybiBhID0gYS5jb25jYXQodGhpcy5jaXJjbGUoYyAtIGQsIGIsIGQsIGQpLCB0aGlzLmNpcmNsZShjIC0gZCwgYiArIGQgKyA0LCBkLCBkKSwgdGhpcy5jaXJjbGUoYyAtIGQsIGIgKyAyICogKGQgKyA0KSwgZCwgZCkpO1xuICAgIH07XG5cbiAgICBDLnByb3RvdHlwZS5yZW5kZXJFeHBvcnRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgYiA9IGEub3B0aW9ucy5leHBvcnRpbmcsXG4gICAgICAgICAgYyA9IGIuYnV0dG9ucyxcbiAgICAgICAgICBkID0gYS5pc0RpcnR5RXhwb3J0aW5nIHx8ICFhLmV4cG9ydFNWR0VsZW1lbnRzO1xuICAgICAgYS5idXR0b25PZmZzZXQgPSAwO1xuICAgICAgYS5pc0RpcnR5RXhwb3J0aW5nICYmIGEuZGVzdHJveUV4cG9ydCgpO1xuICAgICAgZCAmJiAhMSAhPT0gYi5lbmFibGVkICYmIChhLmV4cG9ydEV2ZW50cyA9IFtdLCBhLmV4cG9ydGluZ0dyb3VwID0gYS5leHBvcnRpbmdHcm91cCB8fCBhLnJlbmRlcmVyLmcoXCJleHBvcnRpbmctZ3JvdXBcIikuYXR0cih7XG4gICAgICAgIHpJbmRleDogM1xuICAgICAgfSkuYWRkKCksIEUoYywgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgYS5hZGRCdXR0b24oYik7XG4gICAgICB9KSwgYS5pc0RpcnR5RXhwb3J0aW5nID0gITEpO1xuICAgICAgbihhLCBcImRlc3Ryb3lcIiwgYS5kZXN0cm95RXhwb3J0KTtcbiAgICB9O1xuXG4gICAgbihDLCBcImluaXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgYS5leHBvcnRpbmcgPSB7XG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGIsIGMpIHtcbiAgICAgICAgICBhLmlzRGlydHlFeHBvcnRpbmcgPSAhMDtcbiAgICAgICAgICBwKCEwLCBhLm9wdGlvbnMuZXhwb3J0aW5nLCBiKTtcbiAgICAgICAgICBxKGMsICEwKSAmJiBhLnJlZHJhdygpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZS5hZGRVcGRhdGUoZnVuY3Rpb24gKGIsIGMpIHtcbiAgICAgICAgYS5pc0RpcnR5RXhwb3J0aW5nID0gITA7XG4gICAgICAgIHAoITAsIGEub3B0aW9ucy5uYXZpZ2F0aW9uLCBiKTtcbiAgICAgICAgcShjLCAhMCkgJiYgYS5yZWRyYXcoKTtcbiAgICAgIH0sIGEpO1xuICAgIH0pO1xuICAgIEMucHJvdG90eXBlLmNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICBhLnJlbmRlckV4cG9ydGluZygpO1xuICAgICAgbihhLCBcInJlZHJhd1wiLCBhLnJlbmRlckV4cG9ydGluZyk7XG4gICAgfSk7XG4gIH0pO1xuICBtKGUsIFwibWFzdGVycy9tb2R1bGVzL2V4cG9ydGluZy5zcmMuanNcIiwgW10sIGZ1bmN0aW9uICgpIHt9KTtcbn0pOyIsInZhciBnOyAvLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuXG5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0oKTtcblxudHJ5IHtcbiAgLy8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG4gIGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG4gIC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufSAvLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZzsiLCJpbXBvcnQgXCIuL3N0eWxlcy9pbmRleC5zY3NzXCI7XHJcbmltcG9ydCB7IGNhcmRTZWFyY2hlciB9IGZyb20gJy4vc2NyaXB0cy9jYXJkX3NlYXJjaGVyJztcclxuaW1wb3J0IHsgY2FyZEdlbmVyYXRvciB9IGZyb20gJy4vc2NyaXB0cy9jYXJkX2dlbmVyYXRvcic7XHJcblxyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4ge1xyXG4gIGNvbnN0IGJvYXJkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICBjb25zdCBzZWFyY2hCYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKTtcclxuICBjb25zdCBpbnB1dEZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xyXG4gIGNvbnN0IHN1Ym1pdEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XHJcbiAgY29uc3Qgc2VhcmNoSWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpXCIpO1xyXG4gIGNvbnN0IHRpdGxlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaDFcIik7XHJcbiAgY29uc3QgdGl0bGVJbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xyXG4gIGNvbnN0IG5hdkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIGNvbnN0IGdpdExpbmtJbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcclxuICBjb25zdCBsaW5rZWRpbkxpbmtJbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcclxuICBjb25zdCBhbmdlbExpbmtJbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcclxuICBjb25zdCBnaXRMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgY29uc3QgbGlua2VkaW5MaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgY29uc3QgYW5nZWxMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgY29uc3QgZXJyb3JzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICBjb25zdCBpbnN0cnVjdGlvbnNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBjb25zdCBpbnN0cnVjdGlvbnNCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcclxuXHJcbiAgaW5zdHJ1Y3Rpb25zQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2luc3RydWN0aW9ucy1jb250YWluZXInKTtcclxuICBpbnN0cnVjdGlvbnNDb250YWluZXIuYXBwZW5kKGluc3RydWN0aW9uc0J1dHRvbilcclxuXHJcbiAgZXJyb3JzQ29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaWQnLCBcImVycm9ycy1jb250YWluZXJcIik7XHJcblxyXG4gIGdpdExpbmsuYXBwZW5kKGdpdExpbmtJbWcpO1xyXG4gIGdpdExpbmsuY2xhc3NMaXN0LmFkZCgnbmF2LWxpbmsnKTtcclxuICBnaXRMaW5rLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgXCJodHRwczovL2dpdGh1Yi5jb20vTm9ydG9uLURlc2lnbi9jYXJkQXVndXJ5XCIpO1xyXG4gIGdpdExpbmsuc2V0QXR0cmlidXRlKFwidGFyZ2V0XCIsIFwiX2JsYW5rXCIpO1xyXG4gIGdpdExpbmsuc2V0QXR0cmlidXRlKFwicmVsXCIsIFwibm9vcGVuZXIgbm9yZWZlcnJlclwiKTtcclxuICBnaXRMaW5rLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnR2l0aHViIFJlcG8nKTtcclxuXHJcbiAgbGlua2VkaW5MaW5rLmFwcGVuZChsaW5rZWRpbkxpbmtJbWcpO1xyXG4gIGxpbmtlZGluTGluay5jbGFzc0xpc3QuYWRkKCduYXYtbGluaycpO1xyXG4gIGxpbmtlZGluTGluay5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIFwiaHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL21pY2hhZWwtbm9ydG9uLTViNTU1OTE5OS9cIik7XHJcbiAgbGlua2VkaW5MaW5rLnNldEF0dHJpYnV0ZShcInRhcmdldFwiLCBcIl9ibGFua1wiKTtcclxuICBsaW5rZWRpbkxpbmsuc2V0QXR0cmlidXRlKFwicmVsXCIsIFwibm9vcGVuZXIgbm9yZWZlcnJlclwiKTtcclxuICBsaW5rZWRpbkxpbmsuc2V0QXR0cmlidXRlKCd0aXRsZScsICdMaW5rZWRpbiBMaW5rJylcclxuXHJcbiAgYW5nZWxMaW5rLmFwcGVuZChhbmdlbExpbmtJbWcpO1xyXG4gIGFuZ2VsTGluay5jbGFzc0xpc3QuYWRkKCduYXYtbGluaycpO1xyXG4gIGFuZ2VsTGluay5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIFwiaHR0cHM6Ly9hbmdlbC5jby91L21pY2hhZWwtbm9ydG9uLTE3XCIpO1xyXG4gIGFuZ2VsTGluay5zZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIiwgXCJfYmxhbmtcIik7XHJcbiAgYW5nZWxMaW5rLnNldEF0dHJpYnV0ZShcInJlbFwiLCBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIik7XHJcbiAgYW5nZWxMaW5rLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIFwiQW5nZWxsaXN0IExpbmtcIik7XHJcblxyXG4gIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChcImNlbnRlclwiKTtcclxuICBkb2N1bWVudC5ib2R5LmFwcGVuZChib2FyZCk7XHJcblxyXG4gIGJvYXJkLmNsYXNzTGlzdC5hZGQoXCJib2FyZFwiLCBcImNlbnRlclwiKTtcclxuICBib2FyZC5zZXRBdHRyaWJ1dGUoJ2lkJywgXCJtYWluLWJvYXJkXCIpXHJcbiAgYm9hcmQuYXBwZW5kKGluc3RydWN0aW9uc0NvbnRhaW5lcilcclxuICBib2FyZC5hcHBlbmQoZXJyb3JzQ29udGFpbmVyKTtcclxuICBib2FyZC5hcHBlbmQodGl0bGVDb250YWluZXIpXHJcbiAgYm9hcmQuYXBwZW5kKHNlYXJjaEJhcik7XHJcbiAgYm9hcmQuYXBwZW5kKG5hdkNvbnRhaW5lcik7XHJcblxyXG4gIHRpdGxlQ29udGFpbmVyLmFwcGVuZCh0aXRsZUltZyk7XHJcbiAgdGl0bGVDb250YWluZXIuYXBwZW5kKHRpdGxlKTtcclxuICB0aXRsZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGl0bGUtY29udGFpbmVyXCIpXHJcblxyXG4gIG5hdkNvbnRhaW5lci5hcHBlbmQoZ2l0TGluayk7XHJcbiAgbmF2Q29udGFpbmVyLmFwcGVuZChsaW5rZWRpbkxpbmspO1xyXG4gIG5hdkNvbnRhaW5lci5hcHBlbmQoYW5nZWxMaW5rKVxyXG4gIG5hdkNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCduYXYnKTtcclxuXHJcbiAgdGl0bGVJbWcuc2V0QXR0cmlidXRlKFwic3JjXCIsIFwiLi9zcmMvaW1hZ2VzL2ZpbmFsLW93bDIucG5nXCIpXHJcblxyXG4gIHRpdGxlLmlubmVySFRNTCA9IFwiQ2FyZCBBdWd1cnlcIjtcclxuXHJcbiAgc2VhcmNoSWNvbi5jbGFzc0xpc3QuYWRkKFwiZmFcIik7XHJcbiAgc2VhcmNoSWNvbi5jbGFzc0xpc3QuYWRkKFwiZmEtc2VhcmNoXCIpO1xyXG5cclxuICBsaW5rZWRpbkxpbmtJbWcuY2xhc3NMaXN0LmFkZCgnZmEnKTtcclxuICBsaW5rZWRpbkxpbmtJbWcuY2xhc3NMaXN0LmFkZCgnZmEtbGlua2VkaW4nKTtcclxuXHJcbiAgZ2l0TGlua0ltZy5jbGFzc0xpc3QuYWRkKCdmYScpO1xyXG4gIGdpdExpbmtJbWcuY2xhc3NMaXN0LmFkZCgnZmEtZ2l0aHViJyk7XHJcblxyXG4gIGFuZ2VsTGlua0ltZy5jbGFzc0xpc3QuYWRkKCdmYScpO1xyXG4gIGFuZ2VsTGlua0ltZy5jbGFzc0xpc3QuYWRkKCdmYS1hbmdlbGxpc3QnKTtcclxuXHJcbiAgc3VibWl0QnV0dG9uLmFwcGVuZChzZWFyY2hJY29uKTtcclxuICBzdWJtaXRCdXR0b24uY2xhc3NMaXN0LmFkZCgnc2VhcmNoLWJ1dHRvbicpO1xyXG5cclxuICBpbnN0cnVjdGlvbnNCdXR0b24uY2xhc3NMaXN0LmFkZChcImZhXCIpO1xyXG4gIGluc3RydWN0aW9uc0J1dHRvbi5jbGFzc0xpc3QuYWRkKFwiZmEtYmFyc1wiKTtcclxuXHJcbiAgaW5wdXRGaWVsZC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNlYXJjaGJhclwiKTtcclxuICBpbnB1dEZpZWxkLnNldEF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIsIFwiU2VhcmNoIGZvciBhIGNhcmQuLi5cIik7XHJcbiAgaW5wdXRGaWVsZC5jbGFzc0xpc3QuYWRkKFwic2VhcmNoYmFyXCIpO1xyXG5cclxuICBzZWFyY2hCYXIuY2xhc3NMaXN0LmFkZChcInNlYXJjaGJhci1jb250YWluZXJcIik7XHJcbiAgc2VhcmNoQmFyLmFwcGVuZChpbnB1dEZpZWxkKTtcclxuICBzZWFyY2hCYXIuYXBwZW5kKHN1Ym1pdEJ1dHRvbik7XHJcblxyXG4gIGNvbnN0IG1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtb2RhbFwiKTtcclxuICBjb25zdCBzcGFuID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImNsb3NlXCIpWzBdO1xyXG5cclxuICB3aW5kb3cub25jbGljayA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09IG1vZGFsKSB7XHJcbiAgICAgIG1vZGFsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNwYW4ub25jbGljayA9IGZ1bmN0aW9uKCkge1xyXG4gICAgbW9kYWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gIH1cclxuXHJcbiAgaW5zdHJ1Y3Rpb25zQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcclxuICAgIG1vZGFsLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgfVxyXG5cclxuICBzdWJtaXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgIFxyXG4gICAgY2FyZFNlYXJjaGVyKClcclxuICAgICAgLnRoZW4oY2FyZCA9PiB7XHJcbiAgICAgICAgY29uc3QgbmF2Q29uID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIm5hdlwiKVswXTtcclxuICAgICAgICBpZiAobmF2Q29uKSB7XHJcbiAgICAgICAgICBib2FyZC5yZW1vdmVDaGlsZChuYXZDb250YWluZXIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhcmRHZW5lcmF0b3IoY2FyZCk7XHJcbiAgICAgICAgYm9hcmQuYXBwZW5kKG5hdkNvbnRhaW5lcilcclxuXHJcbiAgICAgICAgaWYgKGNhcmQub2JqZWN0KSB7XHJcbiAgICAgICAgICBib2FyZC5zdHlsZS5tYXJnaW4gPSBcIjAgNXJlbSAwIHJlbSA1cmVtXCI7XHJcbiAgICAgICAgICBib2FyZC5zdHlsZS5taW5IZWlnaHQgPSAnaW5oZXJpdCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RydWN0aW9uc0NvbnRhaW5lci5zdHlsZS5tYXJnaW4gPSBcIjEuMnJlbSAwXCI7XHJcbiAgICAgIH0pXHJcbiAgfSlcclxufSk7XHJcblxyXG4iLCJpbXBvcnQgeyBzZXRGZXRjaGVyIH0gZnJvbSAnLi9zZXRfZmV0Y2hlcidcclxuaW1wb3J0IHsgdHlwZVRvdGFscyB9IGZyb20gJy4vc2V0X3N0YXRzX3V0aWwnO1xyXG5pbXBvcnQgeyBtYW5hSW1hZ2VHZW5lcmF0b3IsIG9yYWNsZVRleHRIYW5kbGVyLCBidWlsZExlZ2FsaXRpZXMgfSBmcm9tICcuL2NhcmRfdXRpbCdcclxuaW1wb3J0ICdiYWJlbC1wb2x5ZmlsbCc7XHJcbmNvbnN0IEhpZ2hjaGFydHMgPSByZXF1aXJlKCdoaWdoY2hhcnRzJyk7IFxyXG5yZXF1aXJlKCdoaWdoY2hhcnRzL21vZHVsZXMvZXhwb3J0aW5nJykoSGlnaGNoYXJ0cyk7XHJcblxyXG5leHBvcnQgY29uc3QgY2FyZEdlbmVyYXRvciA9IGFzeW5jIChjYXJkSW5mbykgPT4ge1xyXG4gIGNvbnN0IGJvYXJkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtYWluLWJvYXJkXCIpO1xyXG4gIGNvbnN0IHByZXZDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhcmQtY29udGFpbmVyXCIpO1xyXG4gIGNvbnN0IGNhcmRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gIGNvbnN0IHNldFN0YXRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBjb25zdCBpbWdMaW5rID0gY2FyZEluZm8uaW1hZ2VfdXJpcy5ub3JtYWw7XHJcbiAgY29uc3Qgc2V0QmFyQ2hhcnRQbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIGNvbnN0IHNldFBpZUNoYXJ0UGxhY2Vob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBjb25zdCBwaWVMb2FkaW5nSWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpXCIpO1xyXG4gIGNvbnN0IGJhckxvYWRpbmdJY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlcIik7XHJcblxyXG4gIGlmIChwcmV2Q29udGFpbmVyKSBib2FyZC5yZW1vdmVDaGlsZChwcmV2Q29udGFpbmVyKTtcclxuICBcclxuICBwaWVMb2FkaW5nSWNvbi5jbGFzc0xpc3QuYWRkKFwiZmFcIik7XHJcbiAgcGllTG9hZGluZ0ljb24uY2xhc3NMaXN0LmFkZChcImZhLXNwaW5uZXJcIik7XHJcblxyXG4gIGJhckxvYWRpbmdJY29uLmNsYXNzTGlzdC5hZGQoXCJmYVwiKTtcclxuICBiYXJMb2FkaW5nSWNvbi5jbGFzc0xpc3QuYWRkKFwiZmEtc3Bpbm5lclwiKTtcclxuXHJcbiAgc2V0U3RhdENvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdzZXQtc3RhdHMtY29udGFpbmVyJyk7XHJcbiAgc2V0QmFyQ2hhcnRQbGFjZWhvbGRlci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNldC1iYXItcGhcIik7IC8vIDwtLS0gVEFSR0VUIFRPIFJFUExBQ0UgVEhFIEJBUkNIQVJUXHJcbiAgc2V0UGllQ2hhcnRQbGFjZWhvbGRlci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNldC1waWUtcGhcIik7IC8vIDwtLS0gVEFSR0VUIFRPIFJFUExBQ0UgVEhFIFBJRUNIQVJUXHJcblxyXG4gIHNldEJhckNoYXJ0UGxhY2Vob2xkZXIuYXBwZW5kKGJhckxvYWRpbmdJY29uKTtcclxuICBzZXRQaWVDaGFydFBsYWNlaG9sZGVyLmFwcGVuZChwaWVMb2FkaW5nSWNvbik7XHJcblxyXG4gIGJvYXJkLmFwcGVuZChjYXJkQ29udGFpbmVyKTtcclxuXHJcbiAgc2V0U3RhdENvbnRhaW5lci5hcHBlbmQoc2V0QmFyQ2hhcnRQbGFjZWhvbGRlcik7XHJcbiAgc2V0U3RhdENvbnRhaW5lci5hcHBlbmQoc2V0UGllQ2hhcnRQbGFjZWhvbGRlcik7XHJcblxyXG4gIGNhcmRDb250YWluZXIuYXBwZW5kKGltZ0NyZWF0b3IoaW1nTGluaykpO1xyXG4gIGNhcmRDb250YWluZXIuYXBwZW5kKHN0YXRCbG9ja0NyZWF0b3IoY2FyZEluZm8pKTtcclxuICBjYXJkQ29udGFpbmVyLmFwcGVuZChzZXRTdGF0Q29udGFpbmVyKTtcclxuICBjYXJkQ29udGFpbmVyLnNldEF0dHJpYnV0ZShcImlkXCIsIFwiY2FyZC1jb250YWluZXJcIik7XHJcbiAgY2FyZENvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiY2FyZC1jb250YWluZXJcIik7XHJcblxyXG4gIHNldEZldGNoZXIoY2FyZEluZm8pXHJcbiAgICAudGhlbihjYXJkU2V0ID0+IHNldFN0YXRzQ3JlYXRvcihjYXJkSW5mbywgY2FyZFNldCkpXHJcbn1cclxuXHJcbmNvbnN0IGltZ0NyZWF0b3IgPSBpbWdMaW5rID0+IHtcclxuICBjb25zdCBpbWdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gIGltZ0NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaW1hZ2UtY29udGFpbmVyXCIpO1xyXG4gIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XHJcbiAgaW1nLnNldEF0dHJpYnV0ZShcInNyY1wiLCBpbWdMaW5rKTtcclxuICBpbWdDb250YWluZXIuYXBwZW5kKGltZyk7XHJcblxyXG4gIHJldHVybiBpbWdDb250YWluZXI7XHJcbn1cclxuXHJcbmNvbnN0IHN0YXRCbG9ja0NyZWF0b3IgPSAoY2FyZEluZm8pID0+IHtcclxuICBjb25zdCB7IFxyXG4gICAgbmFtZSwgXHJcbiAgICBtYW5hX2Nvc3QsIFxyXG4gICAgcmFyaXR5LCBcclxuICAgIG9yYWNsZV90ZXh0LCBcclxuICAgIHNldF9uYW1lLCBcclxuICAgIHR5cGVfbGluZSwgXHJcbiAgICBmbGF2b3JfdGV4dCxcclxuICAgIGxlZ2FsaXRpZXNcclxuICB9ID0gY2FyZEluZm87XHJcblxyXG4gIGNvbnN0IHN0YXRCbG9ja0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiKTtcclxuICBzdGF0QmxvY2tDb250YWluZXIuY2xhc3NMaXN0LmFkZChcInN0YXQtYmxvY2stY29udGFpbmVyXCIpO1xyXG5cclxuICBjb25zdCBjYXJkVGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIilcclxuICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoMlwiKVxyXG4gIGNvbnN0IGNhcmRDb3N0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuXHJcbiAgY2FyZENvc3QuYXBwZW5kKG1hbmFJbWFnZUdlbmVyYXRvcihtYW5hX2Nvc3QpKTtcclxuXHJcbiAgdGl0bGUuaW5uZXJIVE1MID0gbmFtZTtcclxuICBjYXJkVGl0bGUuYXBwZW5kKHRpdGxlKVxyXG4gIGNhcmRUaXRsZS5hcHBlbmQoY2FyZENvc3QpO1xyXG4gIGNhcmRUaXRsZS5jbGFzc0xpc3QuYWRkKFwiY2FyZC10aXRsZS1jb250YWluZXJcIik7XHJcbiAgc3RhdEJsb2NrQ29udGFpbmVyLmFwcGVuZChjYXJkVGl0bGUpO1xyXG5cclxuXHJcbiAgLy8gU0VUIFRIRSBMSVNUIFZBTFVFUyBGT1IgVEhFIENBUkRcclxuICBjb25zdCBociA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoclwiKTtcclxuICBzdGF0QmxvY2tDb250YWluZXIuYXBwZW5kKGhyKTtcclxuXHJcbiAgY29uc3QgY2FyZFR5cGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIik7XHJcbiAgY2FyZFR5cGUuaW5uZXJIVE1MID0gY2FwaXRhbGl6ZShyYXJpdHkpICsgJyAnICsgdHlwZV9saW5lO1xyXG4gIHN0YXRCbG9ja0NvbnRhaW5lci5hcHBlbmQoY2FyZFR5cGUpO1xyXG5cclxuICBjb25zdCBjYXJkU2V0TmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcclxuICBjYXJkU2V0TmFtZS5pbm5lckhUTUwgPSBzZXRfbmFtZTtcclxuICBzdGF0QmxvY2tDb250YWluZXIuYXBwZW5kKGNhcmRTZXROYW1lKTtcclxuXHJcbiAgc3RhdEJsb2NrQ29udGFpbmVyLmFwcGVuZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaHJcIikpXHJcblxyXG4gIG9yYWNsZVRleHRIYW5kbGVyKG9yYWNsZV90ZXh0LCBzdGF0QmxvY2tDb250YWluZXIpO1xyXG5cclxuICBpZiAoZmxhdm9yX3RleHQpe1xyXG4gICAgY29uc3QgY2FyZEZsYXZvclRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIik7XHJcbiAgICBjYXJkRmxhdm9yVGV4dC5jbGFzc0xpc3QuYWRkKCdmbGF2b3InKTtcclxuICAgIGNhcmRGbGF2b3JUZXh0LmlubmVySFRNTCA9IGZsYXZvcl90ZXh0O1xyXG4gICAgc3RhdEJsb2NrQ29udGFpbmVyLmFwcGVuZChjYXJkRmxhdm9yVGV4dCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBsZWdhbGl0aWVzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcclxuICBsZWdhbGl0aWVzQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2xlZ2FsaXRpZXMtY29udGFpbmVyJyk7XHJcbiAgYnVpbGRMZWdhbGl0aWVzKGxlZ2FsaXRpZXMsIGxlZ2FsaXRpZXNDb250YWluZXIpO1xyXG4gIHN0YXRCbG9ja0NvbnRhaW5lci5hcHBlbmQobGVnYWxpdGllc0NvbnRhaW5lcik7XHJcblxyXG4gIHJldHVybiBzdGF0QmxvY2tDb250YWluZXI7XHJcbn1cclxuXHJcbmNvbnN0IHNldFN0YXRzQ3JlYXRvciA9IChjYXJkSW5mbywgY2FyZFNldCkgPT4ge1xyXG4gIC8vIGNvbnNvbGUubG9nKGNhcmRTZXQpO1xyXG4gIHR5cGVUb3RhbHMoY2FyZFNldCkudGhlbih0b3RhbEJyZWFrZG93biA9PiB7XHJcbiAgICAvLyBjb25zb2xlLmxvZyh0b3RhbEJyZWFrZG93bik7XHJcbiAgICBjb25zdCB0eXBlQ2hhcnQgPSBIaWdoY2hhcnRzLmNoYXJ0KFwic2V0LXBpZS1waFwiLCB7XHJcbiAgICAgIGNoYXJ0OiB7XHJcbiAgICAgICAgcGxvdEJhY2tncm91bmRDb2xvcjogbnVsbCxcclxuICAgICAgICBwbG90Qm9yZGVyV2lkdGg6IG51bGwsXHJcbiAgICAgICAgcGxvdFNoYWRvdzogZmFsc2UsXHJcbiAgICAgICAgdHlwZTogJ3BpZSdcclxuICAgICAgfSxcclxuICAgICAgdGl0bGU6IHtcclxuICAgICAgICB0ZXh0OiBgQ2FyZCBUeXBlcyAoJHtjYXJkSW5mby5zZXRfbmFtZX0pYCxcclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgXCJmb250LWZhbWlseVwiOiBcIiR0aXRsZS1mb250XCIsXHJcbiAgICAgICAgICBcImZvbnQtc2l6ZVwiOiBcIjFyZW1cIlxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgdG9vbHRpcDoge1xyXG4gICAgICAgIHBvaW50Rm9ybWF0OiAne3Nlcmllcy5uYW1lfToge3BvaW50LnBlcmNlbnRhZ2U6LjFmfSUnLFxyXG4gICAgICAgIGZvb3RlckZvcm1hdDogJ1xcbiAoe3BvaW50Lnl9KSdcclxuICAgICAgfSxcclxuICAgICAgYWNjZXNzaWJpbGl0eToge1xyXG4gICAgICAgIHBvaW50OiB7XHJcbiAgICAgICAgICB2YWx1ZVN1ZmZpeDogJyUnXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBwbG90T3B0aW9uczoge1xyXG4gICAgICAgIHBpZToge1xyXG4gICAgICAgICAgYWxsb3dQb2ludFNlbGVjdDogdHJ1ZSxcclxuICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxyXG4gICAgICAgICAgZGF0YUxhYmVsczoge1xyXG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgICAgICBmb3JtYXQ6ICd7cG9pbnQubmFtZX0nLFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IDQwMCxcclxuICAgICAgICAgICAgICBmb250RmFtaWx5OiBcIiRib2R5LWZvbnRcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBzZXJpZXM6IFt7XHJcbiAgICAgICAgbmFtZTogJ1R5cGVzJyxcclxuICAgICAgICBjb2xvckJ5UG9pbnQ6IHRydWUsXHJcbiAgICAgICAgZGF0YTogT2JqZWN0LmVudHJpZXModG90YWxCcmVha2Rvd24udHlwZXMpLnNvcnQoKGEsYikgPT4gYVsxXSAtIGJbMV0pLnJldmVyc2UoKS5tYXAocGFpciA9PiB7XHJcbiAgICAgICAgICByZXR1cm4ge25hbWU6IHBhaXJbMF0sIHk6IHBhaXJbMV19XHJcbiAgICAgICAgfSlcclxuICAgICAgfV1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHZhbHVlQ2hhcnQgPSBIaWdoY2hhcnRzLmNoYXJ0KFwic2V0LWJhci1waFwiLCB7XHJcbiAgICAgIGNoYXJ0OiB7XHJcbiAgICAgICAgdHlwZTogJ2NvbHVtbidcclxuICAgIH0sXHJcbiAgICB0aXRsZToge1xyXG4gICAgICAgIHRleHQ6IGBNb3N0IFZhbHVlZCAoJHtjYXJkSW5mby5zZXRfbmFtZX0pYCxcclxuICAgICAgICBzdHlsZTogeyBcclxuICAgICAgICAgIFwiZm9udC1mYW1pbHlcIjogXCIkdGl0bGUtZm9udFwiLFxyXG4gICAgICAgICAgXCJmb250LXNpemVcIjogXCIxcmVtXCJcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgeEF4aXM6IHtcclxuICAgICAgICBjYXRlZ29yaWVzOiB0b3RhbEJyZWFrZG93bi5ub25Qcm9tb1RvcFRlbi5tYXAoY2FyZCA9PiBjYXJkLm5hbWUpLFxyXG4gICAgICAgIGNyb3NzaGFpcjogdHJ1ZSxcclxuICAgICAgICBsYWJlbHM6IHsgZW5hYmxlZDogZmFsc2UgfVxyXG4gICAgfSxcclxuICAgIHlBeGlzOiB7XHJcbiAgICAgICAgbWluOiAwLFxyXG4gICAgICAgIHRpdGxlOiB7XHJcbiAgICAgICAgICAgIHRleHQ6ICdVU0QnLFxyXG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gb3Bwb3NpdGU6IHRydWVcclxuICAgIH0sXHJcbiAgICB0b29sdGlwOiB7XHJcbiAgICAgICAgaGVhZGVyRm9ybWF0OiAnPHNwYW4gc3R5bGU9XCJmb250LXNpemU6MTBweFwiPntwb2ludC5rZXl9PC9zcGFuPjx0YWJsZT4nLFxyXG4gICAgICAgIHBvaW50Rm9ybWF0OiAnPHRyPjx0ZCBzdHlsZT1cImNvbG9yOntzZXJpZXMuY29sb3J9O3BhZGRpbmc6MFwiPntzZXJpZXMubmFtZX06IDwvdGQ+JyArXHJcbiAgICAgICAgICAgICc8dGQgc3R5bGU9XCJwYWRkaW5nOjBcIj48Yj4ke3BvaW50Lnk6LjFmfTwvYj48L3RkPjwvdHI+JyxcclxuICAgICAgICBmb290ZXJGb3JtYXQ6ICc8L3RhYmxlPicsXHJcbiAgICAgICAgc2hhcmVkOiB0cnVlLFxyXG4gICAgICAgIHVzZUhUTUw6IHRydWVcclxuICAgIH0sXHJcbiAgICBwbG90T3B0aW9uczoge1xyXG4gICAgICAgIGNvbHVtbjoge1xyXG4gICAgICAgICAgICBwb2ludFBhZGRpbmc6IDAuMixcclxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDBcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2VyaWVzOiBbe1xyXG4gICAgICAgIG5hbWU6ICdWYWx1ZScsXHJcbiAgICAgICAgY29sb3JCeVBvaW50OiB0cnVlLFxyXG4gICAgICAgIGRhdGE6IHRvdGFsQnJlYWtkb3duLm5vblByb21vVG9wVGVuLm1hcChjYXJkID0+IHBhcnNlRmxvYXQoY2FyZC5wcmljZXMudXNkKSksXHJcbiAgICAgICAgc2hvd0luTGVnZW5kOiBmYWxzZVxyXG4gICAgfV1cclxuICAgIH0pO1xyXG4gIH0pXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjYXBpdGFsaXplID0gc3RyID0+e1xyXG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XHJcbn1cclxuIiwiZXhwb3J0IGxldCBjYXJkO1xyXG5pbXBvcnQgJ2JhYmVsLXBvbHlmaWxsJztcclxuXHJcbmV4cG9ydCBjb25zdCBjYXJkU2VhcmNoZXIgPSBhc3luYyAoZSkgPT4ge1xyXG4gIGNvbnN0IGlucHV0U3RyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZWFyY2hiYXJcIikudmFsdWU7XHJcbiAgY29uc3QgdXJsID0gJ2h0dHBzOi8vYXBpLnNjcnlmYWxsLmNvbS9jYXJkcy9uYW1lZD9mdXp6eT0nO1xyXG4gIGNvbnN0IHNlYXJjaFVybCA9IHVybCArIHZhbGlkU2VhcmNoSW5wdXQoaW5wdXRTdHIpO1xyXG4gIGNvbnN0IGVycm9yVGFyZ2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJlcnJvcnMtY29udGFpbmVyXCIpXHJcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChzZWFyY2hVcmwpO1xyXG4gIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gIGVycm9yVGFyZ2V0LmlubmVySFRNTCA9ICcnXHJcbiAgY2FyZCA9IGF3YWl0IGpzb247XHJcblxyXG4gIGlmIChjYXJkLm9iamVjdCA9PT0gXCJlcnJvclwiKSB7XHJcbiAgICAvL21ha2UgZXJyb3IgYW5kIGFwcGVuZCB0byBib2FyZC5pbnB1dFxyXG4gICAgY29uc3QgZXJyb3JCYW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGNvbnN0IGVycm9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKVxyXG4gICAgY29uc3QgYm9hcmQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiYm9hcmRcIilbMF07XHJcblxyXG4gICAgYm9hcmQuc3R5bGUubWFyZ2luID0gXCI1cmVtXCI7XHJcblxyXG4gICAgZXJyb3JCYW5uZXIuc2V0QXR0cmlidXRlKCdpZCcsIFwiZXJyb3Itc3ViXCIpXHJcbiAgICBlcnJvci5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2Vycm9yLW1lc3NhZ2UnKVxyXG5cclxuICAgIGVycm9yLmlubmVySFRNTCA9IGNhcmQuZGV0YWlscztcclxuICAgIGVycm9yQmFubmVyLmFwcGVuZChlcnJvcik7XHJcbiAgICBlcnJvclRhcmdldC5hcHBlbmQoZXJyb3JCYW5uZXIpXHJcblxyXG4gICAgcmV0dXJuO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zb2xlLmxvZyhjYXJkKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNhcmQ7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB2YWxpZFNlYXJjaElucHV0ID0gc2VhcmNoSW5wdXQgPT4gKCBzZWFyY2hJbnB1dC5zcGxpdCgnICcpLmpvaW4oXCItXCIpIClcclxuIiwiaW1wb3J0IHsgY2FwaXRhbGl6ZSB9IGZyb20gJy4vY2FyZF9nZW5lcmF0b3InO1xuXG5leHBvcnQgY29uc3QgbWFuYUltYWdlR2VuZXJhdG9yID0gbWFuYVN0ciA9PiB7XG4gICAgbGV0IHJlc3VsdHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXN1bHRzLmNsYXNzTGlzdC5hZGQoXCJtYW5hLXN5bWJvbC1jb250YWluZXJcIik7XG5cbiAgICBpZiAoIW1hbmFTdHIpIHJldHVybiByZXN1bHRzO1xuXG4gICAgbGV0IHN1YlN0ciA9ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYW5hU3RyLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgbGV0dGVyID0gbWFuYVN0cltpXTtcblxuICAgICAgICBpZiAobGV0dGVyID09PSAneycpe1xuICAgICAgICAgICAgc3ViU3RyID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSAnfScpe1xuICAgICAgICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgICAgIGltZy5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgYGh0dHBzOi8vaW1nLnNjcnlmYWxsLmNvbS9zeW1ib2xvZ3kvJHtzdWJTdHJ9LnN2Z2ApO1xuXG4gICAgICAgICAgICByZXN1bHRzLmFwcGVuZChpbWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ViU3RyID0gc3ViU3RyICsgbGV0dGVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmV4cG9ydCBjb25zdCBvcmFjbGVUZXh0SGFuZGxlciA9ICh0ZXh0U3RyLCBwYXJlbnRDb24pID0+IHtcbiAgICBsZXQgY29sbGVjdGlvbiA9IHRleHRTdHIuc3BsaXQoXCJcXG5cIik7XG5cbiAgICBjb2xsZWN0aW9uLmZvckVhY2goc3ViU3RyID0+IHtcbiAgICAgICAgY29uc3QgbmV3TGlzdEl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICBuZXdMaXN0SXRlbS5jbGFzc0xpc3QuYWRkKCdvcmFjbGUnKVxuICAgICAgICBuZXdMaXN0SXRlbS5pbm5lckhUTUwgPSBzdWJTdHI7XG4gICAgICAgIHBhcmVudENvbi5hcHBlbmQobmV3TGlzdEl0ZW0pO1xuICAgIH0pXG59XG5cbmV4cG9ydCBjb25zdCBidWlsZExlZ2FsaXRpZXMgPSAobGVnYWxPYmosIGxlZ0NvbnRhaW5lcikgPT4ge1xuICAgIGNvbnN0IHJlbGV2YW50Rm9ybWF0cyA9IFtcbiAgICAgICAgJ2NvbW1hbmRlcicsIFxuICAgICAgICAnc3RhbmRhcmQnLCBcbiAgICAgICAgJ3Bpb25lZXInLCBcbiAgICAgICAgJ21vZGVybicsIFxuICAgICAgICAnaGlzdG9yaWMnLCBcbiAgICAgICAgJ3BhdXBlcicsXG4gICAgICAgICdsZWdhY3knLFxuICAgICAgICAndmludGFnZScsXG4gICAgICAgICdicmF3bCcsXG4gICAgICAgICdwZW5ueSdcbiAgICBdXG4gICAgY29uc3QgaW5uZXJDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkbCcpXG5cbiAgICByZWxldmFudEZvcm1hdHMuZm9yRWFjaChmb3JtYXRTdHIgPT4ge1xuICAgICAgICBjb25zdCBsZWdhbFN0YXR1cyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RkJyk7XG4gICAgICAgIGxlZ2FsU3RhdHVzLmNsYXNzTGlzdC5hZGQoJ2xlZ2FsLXN0YXR1cycpXG5cbiAgICAgICAgY29uc3QgZm9ybWF0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZHQnKTtcbiAgICAgICAgZm9ybWF0LmlubmVySFRNTCA9IGNhcGl0YWxpemUoZm9ybWF0U3RyKTtcbiAgICAgICAgZm9ybWF0LmNsYXNzTGlzdC5hZGQoJ2Zvcm1hdC1uYW1lJyk7XG5cbiAgICAgICAgc3dpdGNoKGxlZ2FsT2JqW2Zvcm1hdFN0cl0pe1xuICAgICAgICAgICAgY2FzZSAnbGVnYWwnOlxuICAgICAgICAgICAgICAgIGxlZ2FsU3RhdHVzLmlubmVySFRNTCA9IFwiTEVHQUxcIjtcbiAgICAgICAgICAgICAgICBsZWdhbFN0YXR1cy5jbGFzc0xpc3QuYWRkKCdsZWdhbCcpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ25vdF9sZWdhbCc6XG4gICAgICAgICAgICAgICAgbGVnYWxTdGF0dXMuaW5uZXJIVE1MID0gXCJOT1QgTEVHQUxcIjtcbiAgICAgICAgICAgICAgICBsZWdhbFN0YXR1cy5jbGFzc0xpc3QuYWRkKCdub3QtbGVnYWwnKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdiYW5uZWQnOlxuICAgICAgICAgICAgICAgIGxlZ2FsU3RhdHVzLmlubmVySFRNTCA9IFwiQkFOTkVEXCI7XG4gICAgICAgICAgICAgICAgbGVnYWxTdGF0dXMuY2xhc3NMaXN0LmFkZCgnYmFubmVkJylcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAncmVzdHJpY3RlZCc6XG4gICAgICAgICAgICAgICAgbGVnYWxTdGF0dXMuaW5uZXJIVE1MID0gXCJSRVNULlwiO1xuICAgICAgICAgICAgICAgIGxlZ2FsU3RhdHVzLmNsYXNzTGlzdC5hZGQoJ3Jlc3QnKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBpbm5lckNvbnRhaW5lci5hcHBlbmQoZm9ybWF0KTtcbiAgICAgICAgaW5uZXJDb250YWluZXIuYXBwZW5kKGxlZ2FsU3RhdHVzKTtcbiAgICB9KVxuXG4gICAgbGVnQ29udGFpbmVyLmFwcGVuZChpbm5lckNvbnRhaW5lcilcbn1cbiIsImltcG9ydCAnYmFiZWwtcG9seWZpbGwnO1xyXG5cclxuZXhwb3J0IGNvbnN0IHNldEZldGNoZXIgPSBhc3luYyAoY2FyZEluZm8pID0+IHtcclxuICAgIGNvbnN0IHNlYXJjaFVybCA9IGBodHRwczovL2FwaS5zY3J5ZmFsbC5jb20vY2FyZHMvc2VhcmNoP29yZGVyPXVzZCZxPWUlM0Eke2NhcmRJbmZvLnNldH0mdW5pcXVlPXByaW50c2A7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHNlYXJjaFVybCk7XHJcbiAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgIGlmIChqc29uLmhhc19tb3JlKXtcclxuICAgICAgY29uc3QgbmV4dFVybCA9IGpzb24ubmV4dF9wYWdlO1xyXG4gICAgICBjb25zdCBuZXh0UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChuZXh0VXJsKTtcclxuICAgICAgY29uc3QgbmV4dEpzb24gPSBhd2FpdCBuZXh0UmVzcG9uc2UuanNvbigpO1xyXG4gIFxyXG4gICAgICBpZiAobmV4dEpzb24uaGFzX21vcmUpe1xyXG4gICAgICAgIGNvbnN0IGZpbmFsVXJsID0gbmV4dEpzb24ubmV4dF9wYWdlO1xyXG4gICAgICAgIGNvbnN0IGZpbmFsUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmaW5hbFVybCk7XHJcbiAgICAgICAgY29uc3QgZmluYWxKc29uID0gYXdhaXQgZmluYWxSZXNwb25zZS5qc29uKClcclxuXHJcbiAgICAgICAgcmV0dXJuIHNldE1lcmdlKFtqc29uLCBuZXh0SnNvbiwgZmluYWxKc29uXSlcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNldE1lcmdlKFtqc29uLCBuZXh0SnNvbl0pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGF3YWl0IGpzb247XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBzZXRNZXJnZSA9IGFzeW5jIChhcnJPZlNldHMpID0+IHtcclxuICBsZXQgYmFzZVNldCA9IGFyck9mU2V0c1swXTtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcnJPZlNldHMubGVuZ3RoOyBpKyspe1xyXG4gICAgY29uc3QgbWVyZ2luZ1NldCA9IGFyck9mU2V0c1tpXTtcclxuICAgIGJhc2VTZXQuZGF0YSA9IGJhc2VTZXQuZGF0YS5jb25jYXQobWVyZ2luZ1NldC5kYXRhKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGJhc2VTZXQ7XHJcbn1cclxuXHJcblxyXG4iLCJpbXBvcnQgJ2JhYmVsLXBvbHlmaWxsJztcblxuZXhwb3J0IGNvbnN0IHR5cGVUb3RhbHMgPSBhc3luYyBzZXQgPT4ge1xuICAgIC8vIHJldHVybiBvYmogd2l0aCBhbGwgdHlwZXMgYXMga2V5cyBleGNlcHQgYmFzaWMgbGFuZHNcbiAgICBjb25zdCBNVEdDQVJEVFlQRVMgPSBbJ0FydGlmYWN0JywgJ0NyZWF0dXJlJywgJ0VuY2hhbnRtZW50JywgJ0luc3RhbnQnLCAnTGFuZCcsICdQbGFuZXN3YWxrZXInLCAnU29yY2VyeScsICdUcmliYWwnXTtcbiAgICBjb25zdCBjYXJkcyA9IHNldC5kYXRhO1xuICAgIGNvbnN0IHN0YXRzID0geyBcbiAgICAgICAgbm9uQmFzaWNzVG90YWw6IDAsIFxuICAgICAgICB0b3RhbFNldFZhbHVlOiAwLFxuICAgICAgICBub25Qcm9tb1RvcFRlbjogW10sXG4gICAgICAgIHRvdGFsU2V0VmFsdWVBdmVyYWdlOiAwLFxuICAgICAgICB0eXBlczoge30sXG4gICAgICAgIHN1YlR5cGVzOiB7fVxuICAgIH07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhcmRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgY2FyZCA9IGNhcmRzW2ldO1xuICAgICAgICBsZXQgY3VycmVudENhcmRUeXBlcztcbiAgICAgICAgLy8gUkVNT1ZFIFBST01PIENBUkRTIEZST00gVEhFIFBPT0wgQkVDQVVTRSBUSEVZJ1JFIERVUEVTXG4gICAgICAgIGlmIChjYXJkLnByb21vKXtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudENhcmRUeXBlcyA9IHR5cGVMaW5lUGFyc2VyKGNhcmQudHlwZV9saW5lKTsgLy8gPC0tIFxuXG4gICAgICAgIGlmIChjdXJyZW50Q2FyZFR5cGVzLmluY2x1ZGVzKCdCYXNpYycpKXtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2FyZFZhbHVlID0gKHR5cGVvZiBjYXJkLnByaWNlcy51c2QgPT09IFwidW5kZWZpbmVkXCIgfHwgY2FyZC5wcmljZXMudXNkID09PSBudWxsKSA/IDAgOiBwYXJzZUZsb2F0KGNhcmQucHJpY2VzLnVzZClcbiAgICAgICAgICAgIGN1cnJlbnRDYXJkVHlwZXMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoTVRHQ0FSRFRZUEVTLmluY2x1ZGVzKHR5cGUpICYmIHR5cGVvZiBzdGF0cy50eXBlc1t0eXBlXSA9PT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICAgICAgICAgICAgICBzdGF0cy50eXBlc1t0eXBlXSA9IDFcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE1UR0NBUkRUWVBFUy5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0cy50eXBlc1t0eXBlXSArPSAxXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghTVRHQ0FSRFRZUEVTLmluY2x1ZGVzKHR5cGUpICYmIHR5cGVvZiBzdGF0cy5zdWJUeXBlc1t0eXBlXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMuc3ViVHlwZXNbdHlwZV0gPSAxXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMuc3ViVHlwZXNbdHlwZV0gKz0gMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdHMubm9uQmFzaWNzVG90YWwgKz0gMTtcbiAgICAgICAgICAgIHN0YXRzLnRvdGFsU2V0VmFsdWUgKz0gY2FyZFZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoc3RhdHMubm9uUHJvbW9Ub3BUZW4ubGVuZ3RoIDwgMTApe1xuICAgICAgICAgICAgICAgIHN0YXRzLm5vblByb21vVG9wVGVuLnB1c2goY2FyZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRzLm5vblByb21vVG9wVGVuVmFsdWVBdmVyYWdlID0gY2FyZEF2ZXJhZ2VyKHN0YXRzLm5vblByb21vVG9wVGVuKTtcbiAgICBzdGF0cy50b3RhbFNldFZhbHVlQXZlcmFnZSA9IHN0YXRzLnRvdGFsU2V0VmFsdWUgLyBzdGF0cy5ub25CYXNpY3NUb3RhbDtcblxuICAgIHJldHVybiBzdGF0c1xufVxuXG5jb25zdCBjYXJkQXZlcmFnZXIgPSBjYXJkQXJyID0+IHtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGNhcmRBcnIuZm9yRWFjaChjYXJkID0+IHRvdGFsICs9IHBhcnNlRmxvYXQoY2FyZC5wcmljZXMudXNkKSlcbiAgICByZXR1cm4gdG90YWwgLyBjYXJkQXJyLmxlbmd0aDtcbn1cblxuY29uc3QgdHlwZUxpbmVQYXJzZXIgPSB0eXBlTGluZVN0ciA9PiB7XG4gICAgY29uc3QgdHlwZUFyciA9IHR5cGVMaW5lU3RyLnNwbGl0KCcgJylcbiAgICByZXR1cm4gdHlwZUFyci5maWx0ZXIodHlwZSA9PiB0eXBlLmxlbmd0aCA+IDIpXG59XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9
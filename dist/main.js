/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-polyfill/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/babel-polyfill/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

__webpack_require__(/*! core-js/shim */ "./node_modules/core-js/shim.js");

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/babel-polyfill/node_modules/regenerator-runtime/runtime.js");

__webpack_require__(/*! core-js/fn/regexp/escape */ "./node_modules/core-js/fn/regexp/escape.js");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}

global._babelPolyfill = true;
var DEFINE_PROPERTY = "defineProperty";

function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);
"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/regenerator-runtime/runtime.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/regenerator-runtime/runtime.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */
!function (global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;

  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    } // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.


    return;
  } // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.


  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  runtime.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  runtime.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function () {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function (record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
}( // Among the various tricks for obtaining a reference to the global
// object, this seems to be the most reliable technique that does not
// use indirect eval (which violates Content Security Policy).
typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/core-js/fn/regexp/escape.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/fn/regexp/escape.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/core.regexp.escape */ "./node_modules/core-js/modules/core.regexp.escape.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/modules/_core.js").RegExp.escape;

/***/ }),

/***/ "./node_modules/core-js/modules/_a-function.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_a-function.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_a-number-value.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_a-number-value.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_add-to-unscopables.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_add-to-unscopables.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('unscopables');

var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(ArrayProto, UNSCOPABLES, {});

module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_advance-string-index.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_advance-string-index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(true); // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex


module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_an-instance.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_an-instance.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
    throw TypeError(name + ': incorrect invocation!');
  }

  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_an-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_an-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-copy-within.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-copy-within.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)


var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = [].copyWithin || function copyWithin(target
/* = 0 */
, start
/* = 0, end = @length */
) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;

  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }

  while (count-- > 0) {
    if (from in O) O[to] = O[from];else delete O[to];
    to += inc;
    from += inc;
  }

  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-fill.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_array-fill.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = function fill(value
/* , start = 0, end = @length */
) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

  while (endPos > index) O[index++] = value;

  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-from-iterable.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-from-iterable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-includes.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_array-includes.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-methods.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_array-methods.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var asc = __webpack_require__(/*! ./_array-species-create */ "./node_modules/core-js/modules/_array-species-create.js");

module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;

    for (; length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);

      if (TYPE) {
        if (IS_MAP) result[index] = res; // map
        else if (res) switch (TYPE) {
            case 3:
              return true;
            // some

            case 5:
              return val;
            // find

            case 6:
              return index;
            // findIndex

            case 2:
              result.push(val);
            // filter
          } else if (IS_EVERY) return false; // every
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-reduce.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_array-reduce.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }

    index += i;

    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }

  for (; isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }

  return memo;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-species-constructor.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-species-constructor.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (original) {
  var C;

  if (isArray(original)) {
    C = original.constructor; // cross-realm fallback

    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;

    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }

  return C === undefined ? Array : C;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_array-species-create.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-species-create.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ "./node_modules/core-js/modules/_array-species-constructor.js");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_bind.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_bind.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/core-js/modules/_invoke.js");

var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']'; // eslint-disable-next-line no-new-func


    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  }

  return factories[len](F, args);
};

module.exports = Function.bind || function bind(that
/* , ...args */
) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);

  var bound = function ()
  /* args... */
  {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };

  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_classof.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_classof.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag'); // ES3 wrong here


var ARG = cof(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) {
    /* empty */
  }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
  : ARG ? cof(O) // ES3 arguments fallback
  : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_cof.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_cof.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_collection-strong.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_collection-strong.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

var $iterDefine = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/modules/_iter-define.js");

var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/modules/_iter-step.js");

var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var fastKey = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").fastKey;

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index]; // frozen object case

  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type

      that._i = create(null); // index

      that._f = undefined; // first entry

      that._l = undefined; // last entry

      that[SIZE] = 0; // size

      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }

        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);

        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        }

        return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn
      /* , that = undefined */
      ) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;

        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this); // revert to the last existing entry

          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index; // change existing entry

    if (entry) {
      entry.v = value; // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true),
        // <- index
        k: key,
        // <- key
        v: value,
        // <- value
        p: prev = that._l,
        // <- previous entry
        n: undefined,
        // <- next entry
        r: false // <- removed

      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++; // add to index

      if (index !== 'F') that._i[index] = entry;
    }

    return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target

      this._k = kind; // kind

      this._l = undefined; // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l; // revert to the last existing entry

      while (entry && entry.r) entry = entry.p; // get next entry


      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      } // return step by kind


      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

    setSpecies(NAME);
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_collection-to-json.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_collection-to-json.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

var from = __webpack_require__(/*! ./_array-from-iterable */ "./node_modules/core-js/modules/_array-from-iterable.js");

module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_collection-weak.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_collection-weak.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

var getWeak = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").getWeak;

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js");

var $has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0; // fallback for uncaught frozen keys

var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function () {
  this.a = [];
};

var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};
module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type

      that._i = id++; // collection id

      that._l = undefined; // leak store for uncaught frozen objects

      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

/***/ }),

/***/ "./node_modules/core-js/modules/_collection.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_collection.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/core-js/modules/_inherit-if-required.js");

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};

  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY, KEY == 'delete' ? function (a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'has' ? function has(a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'get' ? function get(a) {
      return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'add' ? function add(a) {
      fn.call(this, a === 0 ? 0 : a);
      return this;
    } : function set(a, b) {
      fn.call(this, a === 0 ? 0 : a, b);
      return this;
    });
  };

  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C(); // early implementations not supports chaining

    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false

    var THROWS_ON_PRIMITIVES = fails(function () {
      instance.has(1);
    }); // most early implementations doesn't supports iterables, most modern - not close it correctly

    var ACCEPT_ITERABLES = $iterDetect(function (iter) {
      new C(iter);
    }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same

    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;

      while (index--) $instance[ADDER](index, index);

      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);
  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);
  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
  return C;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_core.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_core.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = {
  version: '2.6.11'
};
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/core-js/modules/_create-property.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_create-property.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_ctx.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_ctx.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_date-to-iso-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_date-to-iso-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
}; // PhantomJS / old WebKit has a broken implementations


module.exports = fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
}) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

/***/ }),

/***/ "./node_modules/core-js/modules/_date-to-primitive.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_date-to-primitive.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_defined.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_defined.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_descriptors.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_descriptors.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/core-js/modules/_dom-create.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_dom-create.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document; // typeof document.createElement is 'object' in old IE


var is = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),

/***/ "./node_modules/core-js/modules/_enum-bug-keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_enum-bug-keys.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

/***/ }),

/***/ "./node_modules/core-js/modules/_enum-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_enum-keys.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");

module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;

  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;

    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  }

  return result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_export.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_export.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;

  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

    out = (own ? target : source)[key]; // bind timers to global for call from export context

    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global

    if (target) redefine(target, key, out, type & $export.U); // export

    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};

global.core = core; // type bitmap

$export.F = 1; // forced

$export.G = 2; // global

$export.S = 4; // static

$export.P = 8; // proto

$export.B = 16; // bind

$export.W = 32; // wrap

$export.U = 64; // safe

$export.R = 128; // real proto method for `library`

module.exports = $export;

/***/ }),

/***/ "./node_modules/core-js/modules/_fails-is-regexp.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_fails-is-regexp.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match');

module.exports = function (KEY) {
  var re = /./;

  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) {
      /* empty */
    }
  }

  return true;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_fails.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_fails.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_fix-re-wks.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_fix-re-wks.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./es6.regexp.exec */ "./node_modules/core-js/modules/es6.regexp.exec.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");

var SPECIES = wks('species');
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;

  re.exec = function () {
    var result = [];
    result.groups = {
      a: '7'
    };
    return result;
  };

  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;

  re.exec = function () {
    return originalExec.apply(this, arguments);
  };

  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
}();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};

    O[SYMBOL] = function () {
      return 7;
    };

    return ''[KEY](O) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    re.exec = function () {
      execCalled = true;
      return null;
    };

    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};

      re.constructor[SPECIES] = function () {
        return re;
      };
    }

    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return {
            done: true,
            value: nativeRegExpMethod.call(regexp, str, arg2)
          };
        }

        return {
          done: true,
          value: nativeMethod.call(str, regexp, arg2)
        };
      }

      return {
        done: false
      };
    });
    var strfn = fns[0];
    var rxfn = fns[1];
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {
      return rxfn.call(string, this, arg);
    } // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {
      return rxfn.call(string, this);
    });
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_flags.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_flags.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 21.2.5.3 get RegExp.prototype.flags

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_flatten-into-array.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_flatten-into-array.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray

var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var IS_CONCAT_SPREADABLE = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
      spreadable = false;

      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }

    sourceIndex++;
  }

  return targetIndex;
}

module.exports = flattenIntoArray;

/***/ }),

/***/ "./node_modules/core-js/modules/_for-of.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_for-of.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/modules/_iter-call.js");

var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");

var BREAK = {};
var RETURN = {};

var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () {
    return iterable;
  } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator

  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};

exports.BREAK = BREAK;
exports.RETURN = RETURN;

/***/ }),

/***/ "./node_modules/core-js/modules/_function-to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/_function-to-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('native-function-to-string', Function.toString);

/***/ }),

/***/ "./node_modules/core-js/modules/_global.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/core-js/modules/_has.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_has.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_hide.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_hide.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_html.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_html.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").document;

module.exports = document && document.documentElement;

/***/ }),

/***/ "./node_modules/core-js/modules/_ie8-dom-define.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_ie8-dom-define.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js")('div'), 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/core-js/modules/_inherit-if-required.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_inherit-if-required.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var setPrototypeOf = __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/modules/_set-proto.js").set;

module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;

  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  }

  return that;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_invoke.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_invoke.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;

  switch (args.length) {
    case 0:
      return un ? fn() : fn.call(that);

    case 1:
      return un ? fn(args[0]) : fn.call(that, args[0]);

    case 2:
      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);

    case 3:
      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);

    case 4:
      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
  }

  return fn.apply(that, args);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iobject.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_iobject.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js"); // eslint-disable-next-line no-prototype-builtins


module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-array-iter.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_is-array-iter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');

var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-array.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_is-array.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-integer.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-integer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var floor = Math.floor;

module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),

/***/ "./node_modules/core-js/modules/_is-regexp.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_is-regexp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

var MATCH = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match');

module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-call.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-call.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-create.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-create.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

__webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator'), function () {
  return this;
});

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, {
    next: descriptor(1, next)
  });
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-define.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-define.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/modules/_iter-create.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');

var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () {
  return this;
};

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);

  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];

    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };

      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }

    return function entries() {
      return new Constructor(this, kind);
    };
  };

  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype; // Fix native

  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));

    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  } // fix Array#{values, @@iterator}.name in V8 / FF


  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;

    $default = function values() {
      return $native.call(this);
    };
  } // Define iterator


  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  } // Plug for library


  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;

  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }

  return methods;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-detect.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-detect.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');

var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();

  riter['return'] = function () {
    SAFE_CLOSING = true;
  }; // eslint-disable-next-line no-throw-literal


  Array.from(riter, function () {
    throw 2;
  });
} catch (e) {
  /* empty */
}

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;

  try {
    var arr = [7];
    var iter = arr[ITERATOR]();

    iter.next = function () {
      return {
        done: safe = true
      };
    };

    arr[ITERATOR] = function () {
      return iter;
    };

    exec(arr);
  } catch (e) {
    /* empty */
  }

  return safe;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iter-step.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iter-step.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return {
    value: value,
    done: !!done
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_iterators.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_iterators.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),

/***/ "./node_modules/core-js/modules/_library.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_library.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = false;

/***/ }),

/***/ "./node_modules/core-js/modules/_math-expm1.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_math-expm1.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = !$expm1 // Old FF bug
|| $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 // Tor Browser bug
|| $expm1(-2e-17) != -2e-17 ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

/***/ }),

/***/ "./node_modules/core-js/modules/_math-fround.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_math-fround.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(/*! ./_math-sign */ "./node_modules/core-js/modules/_math-sign.js");

var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs); // eslint-disable-next-line no-self-compare

  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_math-log1p.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_math-log1p.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_math-scale.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_math-scale.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (arguments.length === 0 // eslint-disable-next-line no-self-compare
  || x != x // eslint-disable-next-line no-self-compare
  || inLow != inLow // eslint-disable-next-line no-self-compare
  || inHigh != inHigh // eslint-disable-next-line no-self-compare
  || outLow != outLow // eslint-disable-next-line no-self-compare
  || outHigh != outHigh) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_math-sign.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_math-sign.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_meta.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_meta.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js")('meta');

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var setDesc = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var FREEZE = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});

var setMeta = function (it) {
  setDesc(it, META, {
    value: {
      i: 'O' + ++id,
      // object ID
      w: {} // weak collections IDs

    }
  });
};

var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F'; // not necessary to add metadata

    if (!create) return 'E'; // add missing metadata

    setMeta(it); // return object ID
  }

  return it[META].i;
};

var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true; // not necessary to add metadata

    if (!create) return false; // add missing metadata

    setMeta(it); // return hash weak collections IDs
  }

  return it[META].w;
}; // add metadata on freeze-family methods calling


var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};

var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

/***/ }),

/***/ "./node_modules/core-js/modules/_metadata.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_metadata.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Map = __webpack_require__(/*! ./es6.map */ "./node_modules/core-js/modules/es6.map.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('metadata');

var store = shared.store || (shared.store = new (__webpack_require__(/*! ./es6.weak-map */ "./node_modules/core-js/modules/es6.weak-map.js"))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);

  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }

  var keyMetadata = targetMetadata.get(targetKey);

  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  }

  return keyMetadata;
};

var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};

var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};

var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};

var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) {
    keys.push(key);
  });
  return keys;
};

var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};

var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

/***/ }),

/***/ "./node_modules/core-js/modules/_microtask.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_microtask.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var macrotask = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js").set;

var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();

    while (head) {
      fn = head.fn;
      head = head.next;

      try {
        fn();
      } catch (e) {
        if (head) notify();else last = undefined;
        throw e;
      }
    }

    last = undefined;
    if (parent) parent.enter();
  }; // Node.js


  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    }; // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339

  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, {
      characterData: true
    }); // eslint-disable-line no-new

    notify = function () {
      node.data = toggle = !toggle;
    }; // environments with maybe non-completely correct, but existent Promise

  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);

    notify = function () {
      promise.then(flush);
    }; // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout

  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = {
      fn: fn,
      next: undefined
    };
    if (last) last.next = task;

    if (!head) {
      head = task;
      notify();
    }

    last = task;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_new-promise-capability.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/_new-promise-capability.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 25.4.1.5 NewPromiseCapability(C)

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-assign.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-assign.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 19.1.2.1 Object.assign(target, source, ...)

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");

var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

module.exports = !$assign || __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  var A = {};
  var B = {}; // eslint-disable-next-line no-undef

  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;

  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  }

  return T;
} : $assign;

/***/ }),

/***/ "./node_modules/core-js/modules/_object-create.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-create.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/modules/_object-dps.js");

var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js");

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

var Empty = function () {
  /* empty */
};

var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js")('iframe');

  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';

  __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js").appendChild(iframe);

  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);

  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;

  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];

  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO] = O;
  } else result = createDict();

  return Properties === undefined ? result : dPs(result, Properties);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-dp.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dp.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/modules/_ie8-dom-define.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var dP = Object.defineProperty;
exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-dps.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-dps.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;

  while (length > i) dP.f(O, P = keys[i++], Properties[P]);

  return O;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-forced-pam.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_object-forced-pam.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Forced replacement prototype accessors methods

module.exports = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js") || !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  var K = Math.random(); // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call

  __defineSetter__.call(null, K, function () {
    /* empty */
  });

  delete __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js")[K];
});

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopd.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopd.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/modules/_ie8-dom-define.js");

var gOPD = Object.getOwnPropertyDescriptor;
exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) {
    /* empty */
  }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopn-ext.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopn-ext.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

var toString = {}.toString;
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gopn.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gopn.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/modules/_object-keys-internal.js");

var hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gops.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gops.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),

/***/ "./node_modules/core-js/modules/_object-gpo.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-gpo.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];

  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }

  return O instanceof Object ? ObjectProto : null;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys-internal.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys-internal.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(false);

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key); // Don't enum bug & hidden keys


  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }

  return result;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-keys.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_object-keys.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/modules/_object-keys-internal.js");

var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-pie.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-pie.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),

/***/ "./node_modules/core-js/modules/_object-sap.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_object-sap.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () {
    fn(1);
  }), 'Object', exp);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_object-to-array.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_object-to-array.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var isEnum = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js").f;

module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;

    while (length > i) {
      key = keys[i++];

      if (!DESCRIPTORS || isEnum.call(O, key)) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }

    return result;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_own-keys.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_own-keys.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var Reflect = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Reflect;

module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_parse-float.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_parse-float.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").parseFloat;

var $trim = __webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js").trim;

module.exports = 1 / $parseFloat(__webpack_require__(/*! ./_string-ws */ "./node_modules/core-js/modules/_string-ws.js") + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

/***/ }),

/***/ "./node_modules/core-js/modules/_parse-int.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_parse-int.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").parseInt;

var $trim = __webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js").trim;

var ws = __webpack_require__(/*! ./_string-ws */ "./node_modules/core-js/modules/_string-ws.js");

var hex = /^[-+]?0[xX]/;
module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
} : $parseInt;

/***/ }),

/***/ "./node_modules/core-js/modules/_perform.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_perform.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return {
      e: false,
      v: exec()
    };
  } catch (e) {
    return {
      e: true,
      v: e
    };
  }
};

/***/ }),

/***/ "./node_modules/core-js/modules/_promise-resolve.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/_promise-resolve.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/modules/_new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_property-desc.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_property-desc.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_redefine-all.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_redefine-all.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);

  return target;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_redefine.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_redefine.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var SRC = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js")('src');

var $toString = __webpack_require__(/*! ./_function-to-string */ "./node_modules/core-js/modules/_function-to-string.js");

var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

/***/ }),

/***/ "./node_modules/core-js/modules/_regexp-exec-abstract.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/_regexp-exec-abstract.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec

module.exports = function (R, S) {
  var exec = R.exec;

  if (typeof exec === 'function') {
    var result = exec.call(R, S);

    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }

    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }

  return builtinExec.call(R, S);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_regexp-exec.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_regexp-exec.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpFlags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");

var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.

var nativeReplace = String.prototype.replace;
var patchedExec = nativeExec;
var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
}(); // nonparticipating capturing group, copied from es5-shim's String#split patch.


var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }

    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }

    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;

/***/ }),

/***/ "./node_modules/core-js/modules/_replacer.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_replacer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_same-value.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_same-value.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-collection-from.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_set-collection-from.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-setmap-offrom/

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, {
    from: function from(source
    /* , mapFn, thisArg */
    ) {
      var mapFn = arguments[1];
      var mapping, A, n, cb;
      aFunction(this);
      mapping = mapFn !== undefined;
      if (mapping) aFunction(mapFn);
      if (source == undefined) return new this();
      A = [];

      if (mapping) {
        n = 0;
        cb = ctx(mapFn, arguments[2], 2);
        forOf(source, false, function (nextItem) {
          A.push(cb(nextItem, n++));
        });
      } else {
        forOf(source, false, A.push, A);
      }

      return new this(A);
    }
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-collection-of.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_set-collection-of.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-setmap-offrom/

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, {
    of: function of() {
      var length = arguments.length;
      var A = new Array(length);

      while (length--) A[length] = arguments[length];

      return new this(A);
    }
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-proto.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_set-proto.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.

/* eslint-disable no-proto */
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};

module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
    try {
      set = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js")(Function.call, __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f(Object.prototype, '__proto__').set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }

    return function setPrototypeOf(O, proto) {
      check(O, proto);
      if (buggy) O.__proto__ = proto;else set(O, proto);
      return O;
    };
  }({}, false) : undefined),
  check: check
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-species.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_set-species.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () {
      return this;
    }
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_set-to-string-tag.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_set-to-string-tag.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
    configurable: true,
    value: tag
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_shared-key.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_shared-key.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('keys');

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_shared.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/_shared.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js") ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});

/***/ }),

/***/ "./node_modules/core-js/modules/_species-constructor.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_species-constructor.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species');

module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_strict-method.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_strict-method.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () {
      /* empty */
    }, 1) : method.call(null);
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-at.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-at.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js"); // true  -> String#at
// false -> String#codePointAt


module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-context.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/_string-context.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-html.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_string-html.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value)

var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};

module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-pad.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-pad.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var repeat = __webpack_require__(/*! ./_string-repeat */ "./node_modules/core-js/modules/_string-repeat.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-repeat.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/_string-repeat.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");

  for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;

  return res;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_string-trim.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_string-trim.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var spaces = __webpack_require__(/*! ./_string-ws */ "./node_modules/core-js/modules/_string-ws.js");

var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
}; // 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim


var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

/***/ }),

/***/ "./node_modules/core-js/modules/_string-ws.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_string-ws.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ }),

/***/ "./node_modules/core-js/modules/_task.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/modules/_task.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/core-js/modules/_invoke.js");

var html = __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js");

var cel = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/modules/_dom-create.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function () {
  var id = +this; // eslint-disable-next-line no-prototype-builtins

  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var listener = function (event) {
  run.call(event.data);
}; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;

    while (arguments.length > i) args.push(arguments[i++]);

    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };

    defer(counter);
    return counter;
  };

  clearTask = function clearImmediate(id) {
    delete queue[id];
  }; // Node.js 0.8-


  if (__webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js")(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    }; // Sphere (JS game engine) Dispatch API

  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    }; // Browsers with MessageChannel, includes WebWorkers

  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };

    global.addEventListener('message', listener, false); // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    }; // Rest old browsers

  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}

module.exports = {
  set: setTask,
  clear: clearTask
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-absolute-index.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_to-absolute-index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var max = Math.max;
var min = Math.min;

module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-index.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_to-index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-integer.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-integer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;

module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-iobject.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-iobject.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function (it) {
  return IObject(defined(it));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-length.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-length.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var min = Math.min;

module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-object.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/_to-object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

module.exports = function (it) {
  return Object(defined(it));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_to-primitive.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_to-primitive.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js"); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),

/***/ "./node_modules/core-js/modules/_typed-array.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_typed-array.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js")) {
  var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

  var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

  var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

  var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

  var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");

  var $buffer = __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js");

  var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

  var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

  var propertyDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

  var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

  var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

  var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

  var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

  var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/core-js/modules/_to-index.js");

  var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

  var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

  var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

  var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

  var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

  var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");

  var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

  var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

  var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

  var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");

  var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

  var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

  var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js");

  var createArrayIncludes = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js");

  var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

  var ArrayIterators = __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");

  var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

  var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js");

  var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js");

  var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js");

  var arrayCopyWithin = __webpack_require__(/*! ./_array-copy-within */ "./node_modules/core-js/modules/_array-copy-within.js");

  var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

  var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';
  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });
  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });
  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    }

    return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);

    while (length > index) result[index] = list[index++];

    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, {
      get: function () {
        return this._d[internal];
      }
    });
  };

  var $from = function from(source
  /* , mapfn, thisArg */
  ) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;

    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      }

      O = values;
    }

    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);

    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }

    return result;
  };

  var $of = function of()
  /* ...items */
  {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);

    while (length > index) result[index] = arguments[index++];

    return result;
  }; // iOS Safari 6.x fails here


  var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
    arrayToLocaleString.call(new Uint8Array(1));
  });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start
    /* , end */
    ) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn
    /* , thisArg */
    ) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value
    /* , start, end */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn
    /* , thisArg */
    ) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate
    /* , thisArg */
    ) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate
    /* , thisArg */
    ) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn
    /* , thisArg */
    ) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement
    /* , fromIndex */
    ) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement
    /* , fromIndex */
    ) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) {
      // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement
    /* , fromIndex */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn
    /* , thisArg */
    ) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn
    /* , initialValue */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn
    /* , initialValue */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;

      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      }

      return that;
    },
    some: function some(callbackfn
    /* , thisArg */
    ) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike
  /* , offset */
  ) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);

    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target) && target[TYPED_ARRAY] && typeof key != 'symbol' && key in target && String(+key) == String(key);
  };

  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
  };

  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') // TODO: add validation descriptor w/o calling accessors
    && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
      target[key] = desc.value;
      return target;
    }

    return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () {
    arrayToString.call({});
  })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () {
      /* noop */
    },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () {
      return this[TYPED_ARRAY];
    }
  }); // eslint-disable-next-line max-statements

  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];

    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };

    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };

    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;

        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;

          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }

          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }

        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });

        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new

      new TypedArray(null); // eslint-disable-line no-new

      new TypedArray(1.5); // eslint-disable-line no-new

      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass; // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645

        if (!isObject(data)) return new Base(toIndex(data));

        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
        }

        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }

    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () {
          return NAME;
        }
      });
    }

    O[NAME] = TypedArray;
    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });
    $export($export.S + $export.F * fails(function () {
      Base.of.call(TypedArray, 1);
    }), NAME, {
      from: $from,
      of: $of
    });
    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
    $export($export.P, NAME, proto);
    setSpecies(NAME);
    $export($export.P + $export.F * FORCED_SET, NAME, {
      set: $set
    });
    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, {
      slice: $slice
    });
    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, {
      toLocaleString: $toLocaleString
    });
    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () {
  /* empty */
};

/***/ }),

/***/ "./node_modules/core-js/modules/_typed-buffer.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_typed-buffer.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/core-js/modules/_to-index.js");

var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError; // eslint-disable-next-line no-shadow-restricted-names

var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET; // IEEE754 conversions based on https://github.com/feross/ieee754

function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value); // eslint-disable-next-line no-self-compare

  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);

    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);

  buffer[--i] |= s * 128;
  return buffer;
}

function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;

  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}

function packI8(it) {
  return [it & 0xff];
}

function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}

function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}

function packF64(it) {
  return packIEEE754(it, 52, 8);
}

function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, {
    get: function () {
      return this[internal];
    }
  });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}

function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);

  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset
    /* , littleEndian */
    ) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset
    /* , littleEndian */
    ) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new

    new $ArrayBuffer(1.5); // eslint-disable-line no-new

    new $ArrayBuffer(NaN); // eslint-disable-line no-new

    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };

    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];

    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }

    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  } // iOS Safari 7.x bug


  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

/***/ }),

/***/ "./node_modules/core-js/modules/_typed.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_typed.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;
var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

/***/ }),

/***/ "./node_modules/core-js/modules/_uid.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_uid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();

module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),

/***/ "./node_modules/core-js/modules/_user-agent.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_user-agent.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var navigator = global.navigator;
module.exports = navigator && navigator.userAgent || '';

/***/ }),

/***/ "./node_modules/core-js/modules/_validate-collection.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/_validate-collection.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/modules/_wks-define.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_wks-define.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/modules/_wks-ext.js");

var defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, {
    value: wksExt.f(name)
  });
};

/***/ }),

/***/ "./node_modules/core-js/modules/_wks-ext.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/_wks-ext.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

/***/ }),

/***/ "./node_modules/core-js/modules/_wks.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/modules/_wks.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js")('wks');

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

var Symbol = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Symbol;

var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),

/***/ "./node_modules/core-js/modules/core.get-iterator-method.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/core.get-iterator-method.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('iterator');

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

module.exports = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

/***/ }),

/***/ "./node_modules/core-js/modules/core.regexp.escape.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/core.regexp.escape.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/benjamingr/RexExp.escape
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $re = __webpack_require__(/*! ./_replacer */ "./node_modules/core-js/modules/_replacer.js")(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', {
  escape: function escape(it) {
    return $re(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.copy-within.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.copy-within.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', {
  copyWithin: __webpack_require__(/*! ./_array-copy-within */ "./node_modules/core-js/modules/_array-copy-within.js")
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('copyWithin');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.every.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.every.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $every = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(4);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn
  /* , thisArg */
  ) {
    return $every(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.fill.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.fill.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', {
  fill: __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js")
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('fill');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.filter.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.filter.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $filter = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(2);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn
  /* , thisArg */
  ) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.find-index.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.find-index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $find = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(6);

var KEY = 'findIndex';
var forced = true; // Shouldn't skip holes

if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")(KEY);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.find.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.find.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $find = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(5);

var KEY = 'find';
var forced = true; // Shouldn't skip holes

if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")(KEY);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.for-each.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.for-each.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $forEach = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(0);

var STRICT = __webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn
  /* , thisArg */
  ) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.from.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.from.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/modules/_iter-call.js");

var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/modules/_create-property.js");

var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");

$export($export.S + $export.F * !__webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  Array.from(iter);
}), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike
  /* , mapfn = undefined, thisArg = undefined */
  ) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);

      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }

    result.length = index;
    return result;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.index-of.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.index-of.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $indexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(false);

var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement
  /* , fromIndex = 0 */
  ) {
    return NEGATIVE_ZERO // convert -0 to +0
    ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.is-array.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.is-array.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Array', {
  isArray: __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js");

var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/modules/_iter-step.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js"); // 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()


module.exports = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target

  this._i = 0; // next index

  this._k = kind; // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;

  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }

  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

Iterators.Arguments = Iterators.Array;
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.join.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.join.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.13 Array.prototype.join(separator)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var arrayJoin = [].join; // fallback for not array-like strings

$export($export.P + $export.F * (__webpack_require__(/*! ./_iobject */ "./node_modules/core-js/modules/_iobject.js") != Object || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.last-index-of.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.last-index-of.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement
  /* , fromIndex = @[*-1] */
  ) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;

    for (; index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;

    return -1;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.map.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.map.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $map = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(1);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn
  /* , thisArg */
  ) {
    return $map(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.of.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.of.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/modules/_create-property.js"); // WebKit Array.of isn't generic


$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  function F() {
    /* empty */
  }

  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of()
  /* ...args */
  {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);

    while (aLen > index) createProperty(result, index, arguments[index++]);

    result.length = aLen;
    return result;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.reduce-right.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.reduce-right.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $reduce = __webpack_require__(/*! ./_array-reduce */ "./node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.reduce.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.reduce.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $reduce = __webpack_require__(/*! ./_array-reduce */ "./node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.slice.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.slice.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var html = __webpack_require__(/*! ./_html */ "./node_modules/core-js/modules/_html.js");

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var arraySlice = [].slice; // fallback for not array-like ES3 strings and DOM objects

$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;

    for (; i < size; i++) cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];

    return cloned;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.some.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.some.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $some = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(3);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn
  /* , thisArg */
  ) {
    return $some(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.sort.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.sort.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var $sort = [].sort;
var test = [1, 2, 3];
$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null); // Old WebKit
}) || !__webpack_require__(/*! ./_strict-method */ "./node_modules/core-js/modules/_strict-method.js")($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.array.species.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.array.species.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")('Array');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.now.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.now.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Date', {
  now: function () {
    return new Date().getTime();
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-iso-string.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-iso-string.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toISOString = __webpack_require__(/*! ./_date-to-iso-string */ "./node_modules/core-js/modules/_date-to-iso-string.js"); // PhantomJS / old WebKit has a broken implementations


$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-json.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-json.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
    toISOString: function () {
      return 1;
    }
  }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-primitive.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-primitive.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toPrimitive');

var proto = Date.prototype;
if (!(TO_PRIMITIVE in proto)) __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")(proto, TO_PRIMITIVE, __webpack_require__(/*! ./_date-to-primitive */ "./node_modules/core-js/modules/_date-to-primitive.js"));

/***/ }),

/***/ "./node_modules/core-js/modules/es6.date.to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.date.to-string.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;

if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this); // eslint-disable-next-line no-self-compare

    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.bind.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.function.bind.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'Function', {
  bind: __webpack_require__(/*! ./_bind */ "./node_modules/core-js/modules/_bind.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.has-instance.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.function.has-instance.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var HAS_INSTANCE = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('hasInstance');

var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype[@@hasInstance](V)

if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f(FunctionProto, HAS_INSTANCE, {
  value: function (O) {
    if (typeof this != 'function' || !isObject(O)) return false;
    if (!isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:

    while (O = getPrototypeOf(O)) if (this.prototype === O) return true;

    return false;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.function.name.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.function.name.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name'; // 19.2.4.2 name

NAME in FProto || __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.map.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/es6.map.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(/*! ./_collection-strong */ "./node_modules/core-js/modules/_collection-strong.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var MAP = 'Map'; // 23.1 Map Objects

module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(MAP, function (get) {
  return function Map() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.acosh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.acosh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var log1p = __webpack_require__(/*! ./_math-log1p */ "./node_modules/core-js/modules/_math-log1p.js");

var sqrt = Math.sqrt;
var $acosh = Math.acosh;
$export($export.S + $export.F * !($acosh // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
&& Math.floor($acosh(Number.MAX_VALUE)) == 710 // Tor Browser bug: Math.acosh(Infinity) -> NaN
&& $acosh(Infinity) == Infinity), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.asinh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.asinh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
} // Tor Browser bug: Math.asinh(0) -> -0


$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {
  asinh: asinh
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.atanh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.atanh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $atanh = Math.atanh; // Tor Browser bug: Math.atanh(-0) -> 0

$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.cbrt.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.cbrt.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var sign = __webpack_require__(/*! ./_math-sign */ "./node_modules/core-js/modules/_math-sign.js");

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.clz32.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.clz32.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.cosh.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.cosh.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var exp = Math.exp;
$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.expm1.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.expm1.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/core-js/modules/_math-expm1.js");

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {
  expm1: $expm1
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.fround.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.fround.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  fround: __webpack_require__(/*! ./_math-fround */ "./node_modules/core-js/modules/_math-fround.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.hypot.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.hypot.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var abs = Math.abs;
$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) {
    // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;

    while (i < aLen) {
      arg = abs(arguments[i++]);

      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }

    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.imul.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.imul.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $imul = Math.imul; // some WebKit versions fails with big numbers, some has wrong arity

$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.log10.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.log10.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.log1p.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.log1p.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log1p: __webpack_require__(/*! ./_math-log1p */ "./node_modules/core-js/modules/_math-log1p.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.log2.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.log2.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.sign.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.sign.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  sign: __webpack_require__(/*! ./_math-sign */ "./node_modules/core-js/modules/_math-sign.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.sinh.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.sinh.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/core-js/modules/_math-expm1.js");

var exp = Math.exp; // V8 near Chromium 38 has a problem with very small numbers

$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.tanh.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.tanh.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/core-js/modules/_math-expm1.js");

var exp = Math.exp;
$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.math.trunc.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.math.trunc.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.constructor.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.constructor.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/core-js/modules/_inherit-if-required.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f;

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var $trim = __webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js").trim;

var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype; // Opera ~12 has broken Object#toString

var BROKEN_COF = cof(__webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js")(proto)) == NUMBER;
var TRIM = ('trim' in String.prototype); // 7.1.3 ToNumber(argument)

var toNumber = function (argument) {
  var it = toPrimitive(argument, false);

  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;

    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        // fast equal /^0b[01]+$/i

        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        // fast equal /^0o[0-7]+$/i

        default:
          return +it;
      }

      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i); // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols

        if (code < 48 || code > maxCode) return NaN;
      }

      return parseInt(digits, radix);
    }
  }

  return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number // check on 1..constructor(foo) case
    && (BROKEN_COF ? fails(function () {
      proto.valueOf.call(that);
    }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };

  for (var keys = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") ? gOPN(Base) : ( // ES3:
  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES6 (in case, if modules with ES6 Number statics required before):
  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }

  $Number.prototype = proto;
  proto.constructor = $Number;

  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(global, NUMBER, $Number);
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.epsilon.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.epsilon.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  EPSILON: Math.pow(2, -52)
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-finite.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-finite.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var _isFinite = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-integer.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-integer.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  isInteger: __webpack_require__(/*! ./_is-integer */ "./node_modules/core-js/modules/_is-integer.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-nan.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-nan.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.is-safe-integer.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.is-safe-integer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var isInteger = __webpack_require__(/*! ./_is-integer */ "./node_modules/core-js/modules/_is-integer.js");

var abs = Math.abs;
$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.max-safe-integer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.max-safe-integer.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  MAX_SAFE_INTEGER: 0x1fffffffffffff
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.min-safe-integer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.min-safe-integer.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  MIN_SAFE_INTEGER: -0x1fffffffffffff
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.parse-float.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.parse-float.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $parseFloat = __webpack_require__(/*! ./_parse-float */ "./node_modules/core-js/modules/_parse-float.js"); // 20.1.2.12 Number.parseFloat(string)


$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {
  parseFloat: $parseFloat
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.parse-int.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.parse-int.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $parseInt = __webpack_require__(/*! ./_parse-int */ "./node_modules/core-js/modules/_parse-int.js"); // 20.1.2.13 Number.parseInt(string, radix)


$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {
  parseInt: $parseInt
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.to-fixed.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.to-fixed.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var aNumberValue = __webpack_require__(/*! ./_a-number-value */ "./node_modules/core-js/modules/_a-number-value.js");

var repeat = __webpack_require__(/*! ./_string-repeat */ "./node_modules/core-js/modules/_string-repeat.js");

var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;

  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};

var divide = function (n) {
  var i = 6;
  var c = 0;

  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = c % n * 1e7;
  }
};

var numToString = function () {
  var i = 6;
  var s = '';

  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  }

  return s;
};

var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function (x) {
  var n = 0;
  var x2 = x;

  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }

  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  }

  return n;
};

$export($export.P + $export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR); // eslint-disable-next-line no-self-compare

    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);

    if (x < 0) {
      s = '-';
      x = -x;
    }

    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;

      if (e > 0) {
        multiply(0, z);
        j = f;

        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }

        multiply(pow(10, j, 1), 0);
        j = e - 1;

        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }

        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }

    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    }

    return m;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.number.to-precision.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.number.to-precision.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var aNumberValue = __webpack_require__(/*! ./_a-number-value */ "./node_modules/core-js/modules/_a-number-value.js");

var $toPrecision = 1.0.toPrecision;
$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.assign.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.assign.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S + $export.F, 'Object', {
  assign: __webpack_require__(/*! ./_object-assign */ "./node_modules/core-js/modules/_object-assign.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.create.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.create.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js"); // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])


$export($export.S, 'Object', {
  create: __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.define-properties.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.define-properties.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js"); // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)


$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js"), 'Object', {
  defineProperties: __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/modules/_object-dps.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.define-property.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.define-property.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js"); // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)


$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js"), 'Object', {
  defineProperty: __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.freeze.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.freeze.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.get-own-property-descriptor.js":
/*!********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.get-own-property-descriptor.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var $getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.get-own-property-names.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.get-own-property-names.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('getOwnPropertyNames', function () {
  return __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/core-js/modules/_object-gopn-ext.js").f;
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.get-prototype-of.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.get-prototype-of.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var $getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is-extensible.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is-extensible.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is-frozen.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is-frozen.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is-sealed.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is-sealed.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.is.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.is.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Object', {
  is: __webpack_require__(/*! ./_same-value */ "./node_modules/core-js/modules/_same-value.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.keys.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.prevent-extensions.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.prevent-extensions.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.seal.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.seal.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/modules/_object-sap.js")('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.set-prototype-of.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.set-prototype-of.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Object', {
  setPrototypeOf: __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/modules/_set-proto.js").set
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.object.to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.object.to-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 19.1.3.6 Object.prototype.toString()

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

var test = {};
test[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('toStringTag')] = 'z';

if (test + '' != '[object z]') {
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.parse-float.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.parse-float.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $parseFloat = __webpack_require__(/*! ./_parse-float */ "./node_modules/core-js/modules/_parse-float.js"); // 18.2.4 parseFloat(string)


$export($export.G + $export.F * (parseFloat != $parseFloat), {
  parseFloat: $parseFloat
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.parse-int.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.parse-int.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $parseInt = __webpack_require__(/*! ./_parse-int */ "./node_modules/core-js/modules/_parse-int.js"); // 18.2.5 parseInt(string, radix)


$export($export.G + $export.F * (parseInt != $parseInt), {
  parseInt: $parseInt
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.promise.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/es6.promise.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

var task = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js").set;

var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/core-js/modules/_microtask.js")();

var newPromiseCapabilityModule = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/modules/_new-promise-capability.js");

var perform = __webpack_require__(/*! ./_perform */ "./node_modules/core-js/modules/_perform.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js");

var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/core-js/modules/_promise-resolve.js");

var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';

var empty = function () {
  /* empty */
};

var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);

    var FakePromise = (promise.constructor = {})[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('species')] = function (exec) {
      exec(empty, empty);
    }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test


    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // we can't detect it synchronously, so just check versions
    && v8.indexOf('6.6') !== 0 && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) {
    /* empty */
  }
}(); // helpers

var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;

    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;

      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }

          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value); // may throw

            if (domain) {
              domain.exit();
              exited = true;
            }
          }

          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };

    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach


    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};

var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;

    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({
            promise: promise,
            reason: value
          });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    }

    promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};

var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};

var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;

    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({
        promise: promise,
        reason: promise._v
      });
    }
  });
};

var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};

var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");

    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = {
          _w: promise,
          _d: false
        }; // wrap

        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({
      _w: promise,
      _d: false
    }, e); // wrap
  }
}; // constructor polyfill


if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);

    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  }; // eslint-disable-next-line no-unused-vars


  Internal = function Promise(executor) {
    this._c = []; // <- awaiting reactions

    this._a = undefined; // <- checked in isUnhandled reactions

    this._s = 0; // <- state

    this._d = false; // <- done

    this._v = undefined; // <- value

    this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled

    this._n = false; // <- notify
  };

  Internal.prototype = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;

      this._c.push(reaction);

      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });

  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };

  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Promise: $Promise
});

__webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js")($Promise, PROMISE);

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")(PROMISE);

Wrapper = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js")[PROMISE]; // statics

$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.apply.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.apply.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var rApply = (__webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Reflect || {}).apply;
var fApply = Function.apply; // MS Edge argumentsList argument is optional

$export($export.S + $export.F * !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  rApply(function () {
    /* empty */
  });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.construct.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.construct.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var bind = __webpack_require__(/*! ./_bind */ "./node_modules/core-js/modules/_bind.js");

var rConstruct = (__webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").Reflect || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it

var NEW_TARGET_BUG = fails(function () {
  function F() {
    /* empty */
  }

  return !(rConstruct(function () {
    /* empty */
  }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () {
    /* empty */
  });
});
$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args
  /* , newTarget */
  ) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);

    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0:
          return new Target();

        case 1:
          return new Target(args[0]);

        case 2:
          return new Target(args[0], args[1]);

        case 3:
          return new Target(args[0], args[1], args[2]);

        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      } // w/o altered newTarget, lot of arguments case


      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    } // with altered newTarget, not support built-in constructors


    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.define-property.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.define-property.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js"); // MS Edge has broken Reflect.defineProperty - throwing instead of returning false


$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, {
    value: 1
  }), 1, {
    value: 2
  });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);

    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.delete-property.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.delete-property.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f;

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.enumerate.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.enumerate.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 26.1.5 Reflect.enumerate(target)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target

  this._i = 0; // next index

  var keys = this._k = []; // keys

  var key;

  for (key in iterated) keys.push(key);
};

__webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/modules/_iter-create.js")(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;

  do {
    if (that._i >= keys.length) return {
      value: undefined,
      done: true
    };
  } while (!((key = keys[that._i++]) in that._t));

  return {
    value: key,
    done: false
  };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.get-prototype-of.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.get-prototype-of.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var getProto = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.get.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.get.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

function get(target, propertyKey
/* , receiver */
) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', {
  get: get
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.has.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.has.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.is-extensible.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.is-extensible.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var $isExtensible = Object.isExtensible;
$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.own-keys.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.own-keys.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', {
  ownKeys: __webpack_require__(/*! ./_own-keys */ "./node_modules/core-js/modules/_own-keys.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.prevent-extensions.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.prevent-extensions.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var $preventExtensions = Object.preventExtensions;
$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);

    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.set-prototype-of.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.set-prototype-of.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var setProto = __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/modules/_set-proto.js");

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);

    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.reflect.set.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.reflect.set.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

function set(target, propertyKey, V
/* , receiver */
) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;

  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }

    ownDesc = createDesc(0);
  }

  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;

    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));

    return true;
  }

  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', {
  set: set
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.constructor.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.constructor.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/core-js/modules/_inherit-if-required.js");

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;

var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;

var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");

var $flags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");

var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g; // "new" creates a new object, old webkit buggy here

var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && (!CORRECT_NEW || __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  re2[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('match')] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp);
  };

  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () {
        return Base[key];
      },
      set: function (it) {
        Base[key] = it;
      }
    });
  };

  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);

  proto.constructor = $RegExp;
  $RegExp.prototype = proto;

  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(global, 'RegExp', $RegExp);
}

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")('RegExp');

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.exec.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.exec.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");

__webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js")({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.flags.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.flags.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && /./g.flags != 'g') __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.match.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.match.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js"); // @@match logic


__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [// `String.prototype.match` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.match
  function match(regexp) {
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, // `RegExp.prototype[@@match]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
  function (regexp) {
    var res = maybeCallNative($match, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    if (!rx.global) return regExpExec(rx, S);
    var fullUnicode = rx.unicode;
    rx.lastIndex = 0;
    var A = [];
    var n = 0;
    var result;

    while ((result = regExpExec(rx, S)) !== null) {
      var matchStr = String(result[0]);
      A[n] = matchStr;
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      n++;
    }

    return n === 0 ? null : A;
  }];
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.replace.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.replace.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");

var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
}; // @@replace logic


__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [// `String.prototype.replace` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.replace
  function replace(searchValue, replaceValue) {
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
  }, // `RegExp.prototype[@@replace]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
  function (regexp, replaceValue) {
    var res = maybeCallNative($replace, regexp, this, replaceValue);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var functionalReplace = typeof replaceValue === 'function';
    if (!functionalReplace) replaceValue = String(replaceValue);
    var global = rx.global;

    if (global) {
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
    }

    var results = [];

    while (true) {
      var result = regExpExec(rx, S);
      if (result === null) break;
      results.push(result);
      if (!global) break;
      var matchStr = String(result[0]);
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
    }

    var accumulatedResult = '';
    var nextSourcePosition = 0;

    for (var i = 0; i < results.length; i++) {
      result = results[i];
      var matched = String(result[0]);
      var position = max(min(toInteger(result.index), S.length), 0);
      var captures = []; // NOTE: This is equivalent to
      //   captures = result.slice(1).map(maybeToString)
      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

      for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));

      var namedCaptures = result.groups;

      if (functionalReplace) {
        var replacerArgs = [matched].concat(captures, position, S);
        if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
        var replacement = String(replaceValue.apply(undefined, replacerArgs));
      } else {
        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
      }

      if (position >= nextSourcePosition) {
        accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
        nextSourcePosition = position + matched.length;
      }
    }

    return accumulatedResult + S.slice(nextSourcePosition);
  }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }

    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;

      switch (ch.charAt(0)) {
        case '$':
          return '$';

        case '&':
          return matched;

        case '`':
          return str.slice(0, position);

        case "'":
          return str.slice(tailPos);

        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;

        default:
          // \d\d?
          var n = +ch;
          if (n === 0) return match;

          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }

          capture = captures[n - 1];
      }

      return capture === undefined ? '' : capture;
    });
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.search.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.search.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var sameValue = __webpack_require__(/*! ./_same-value */ "./node_modules/core-js/modules/_same-value.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js"); // @@search logic


__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [// `String.prototype.search` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.search
  function search(regexp) {
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, // `RegExp.prototype[@@search]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
  function (regexp) {
    var res = maybeCallNative($search, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var previousLastIndex = rx.lastIndex;
    if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
    var result = regExpExec(rx, S);
    if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
    return result === null ? -1 : result.index;
  }];
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.split.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.split.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/core-js/modules/_advance-string-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var callRegExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/core-js/modules/_regexp-exec-abstract.js");

var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/core-js/modules/_regexp-exec.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff; // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError

var SUPPORTS_Y = !fails(function () {
  RegExp(MAX_UINT32, 'y');
}); // @@split logic

__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/core-js/modules/_fix-re-wks.js")('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;

  if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return []; // If `separator` is not a regex, use native split

      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0; // Make `global` and avoid `lastIndex` issues by working with a copy

      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;

      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];

        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }

        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }

      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));

      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    }; // Chakra, V8

  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [// `String.prototype.split` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.split
  function split(separator, limit) {
    var O = defined(this);
    var splitter = separator == undefined ? undefined : separator[SPLIT];
    return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
  }, // `RegExp.prototype[@@split]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
  //
  // NOTE: This cannot be properly polyfilled in engines that don't support
  // the 'y' flag.
  function (regexp, limit) {
    var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var C = speciesConstructor(rx, RegExp);
    var unicodeMatching = rx.unicode;
    var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g'); // ^(? + rx + ) is needed, in combination with some S slicing, to
    // simulate the 'y' flag.

    var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
    var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
    if (lim === 0) return [];
    if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
    var p = 0;
    var q = 0;
    var A = [];

    while (q < S.length) {
      splitter.lastIndex = SUPPORTS_Y ? q : 0;
      var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
      var e;

      if (z === null || (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
        q = advanceStringIndex(S, q, unicodeMatching);
      } else {
        A.push(S.slice(p, q));
        if (A.length === lim) return A;

        for (var i = 1; i <= z.length - 1; i++) {
          A.push(z[i]);
          if (A.length === lim) return A;
        }

        q = p = e;
      }
    }

    A.push(S.slice(p));
    return A;
  }];
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.regexp.to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.regexp.to-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./es6.regexp.flags */ "./node_modules/core-js/modules/es6.regexp.flags.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var $flags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js")(RegExp.prototype, TO_STRING, fn, true);
}; // 21.2.5.14 RegExp.prototype.toString()


if (__webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return $toString.call({
    source: 'a',
    flags: 'b'
  }) != '/a/b';
})) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  }); // FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.set.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/es6.set.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(/*! ./_collection-strong */ "./node_modules/core-js/modules/_collection-strong.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var SET = 'Set'; // 23.2 Set Objects

module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(SET, function (get) {
  return function Set() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.anchor.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.anchor.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.2 String.prototype.anchor(name)

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.big.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.big.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.3 String.prototype.big()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.blink.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.blink.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.4 String.prototype.blink()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.bold.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.bold.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.5 String.prototype.bold()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.code-point-at.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.code-point-at.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(false);

$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.ends-with.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.ends-with.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var context = __webpack_require__(/*! ./_string-context */ "./node_modules/core-js/modules/_string-context.js");

var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/core-js/modules/_fails-is-regexp.js")(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString
  /* , endPosition = @length */
  ) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.fixed.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.fixed.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.6 String.prototype.fixed()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.fontcolor.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.fontcolor.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.7 String.prototype.fontcolor(color)

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.fontsize.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.fontsize.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.8 String.prototype.fontsize(size)

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.from-code-point.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.from-code-point.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem

$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) {
    // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;

    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
    }

    return res.join('');
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.includes.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.includes.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var context = __webpack_require__(/*! ./_string-context */ "./node_modules/core-js/modules/_string-context.js");

var INCLUDES = 'includes';
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/core-js/modules/_fails-is-regexp.js")(INCLUDES), 'String', {
  includes: function includes(searchString
  /* , position = 0 */
  ) {
    return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.italics.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.italics.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.9 String.prototype.italics()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.iterator.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(true); // 21.1.3.27 String.prototype[@@iterator]()


__webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target

  this._i = 0; // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return {
    value: undefined,
    done: true
  };
  point = $at(O, index);
  this._i += point.length;
  return {
    value: point,
    done: false
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.link.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.link.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.10 String.prototype.link(url)

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.raw.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.raw.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;

    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    }

    return res.join('');
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.repeat.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.repeat.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(/*! ./_string-repeat */ "./node_modules/core-js/modules/_string-repeat.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.small.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.small.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.11 String.prototype.small()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.starts-with.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.starts-with.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var context = __webpack_require__(/*! ./_string-context */ "./node_modules/core-js/modules/_string-context.js");

var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/core-js/modules/_fails-is-regexp.js")(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString
  /* , position = 0 */
  ) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.strike.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.strike.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.12 String.prototype.strike()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.sub.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.sub.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.13 String.prototype.sub()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.sup.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.sup.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.14 String.prototype.sup()

__webpack_require__(/*! ./_string-html */ "./node_modules/core-js/modules/_string-html.js")('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.string.trim.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es6.string.trim.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 21.1.3.25 String.prototype.trim()

__webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js")('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.symbol.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es6.symbol.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // ECMAScript 6 symbols shim

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var META = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js").KEY;

var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/modules/_shared.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");

var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/modules/_wks-ext.js");

var wksDefine = __webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/modules/_wks-define.js");

var enumKeys = __webpack_require__(/*! ./_enum-keys */ "./node_modules/core-js/modules/_enum-keys.js");

var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/modules/_is-array.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");

var _create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");

var gOPNExt = __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/core-js/modules/_object-gopn-ext.js");

var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var $GOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/modules/_object-gops.js");

var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");

var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;

var _stringify = $JSON && $JSON.stringify;

var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () {
      return dP(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);

  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);

  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, {
        enumerable: createDesc(0, false)
      });
    }

    return setSymbolDesc(it, key, D);
  }

  return dP(it, key, D);
};

var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;

  while (l > i) $defineProperty(it, key = keys[i++], P[key]);

  return it;
};

var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};

var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};

var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  }

  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  }

  return result;
}; // 19.4.1.1 Symbol([description])


if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);

    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };

    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: $set
    });
    return wrap(tag);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });
  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/modules/_object-pie.js").f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Symbol: $Symbol
});

for (var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');

    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () {
    setter = true;
  },
  useSimple: function () {
    setter = false;
  }
});
$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
}); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443

var FAILS_ON_PRIMITIVES = $fails(function () {
  $GOPS.f(1);
});
$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
}); // 24.3.2 JSON.stringify(value [, replacer [, space]])

$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol(); // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols

  return _stringify([S]) != '[null]' || _stringify({
    a: S
  }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;

    while (arguments.length > i) args.push(arguments[i++]);

    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
}); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)

$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag]

setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag]

setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag]

setToStringTag(global.JSON, 'JSON', true);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.array-buffer.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.array-buffer.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");

var buffer = __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var ArrayBuffer = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").ArrayBuffer;

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';
$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {
  ArrayBuffer: $ArrayBuffer
});
$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});
$export($export.P + $export.U + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js")(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix

    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;

    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    }

    return result;
  }
});

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")(ARRAY_BUFFER);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.data-view.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.data-view.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.G + $export.W + $export.F * !__webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js").ABV, {
  DataView: __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js").DataView
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.float32-array.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.float32-array.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.float64-array.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.float64-array.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.int16-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.int16-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.int32-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.int32-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.int8-array.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.int8-array.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint16-array.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint16-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint32-array.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint32-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint8-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint8-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint8-clamped-array.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint8-clamped-array.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

/***/ }),

/***/ "./node_modules/core-js/modules/es6.weak-map.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.weak-map.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var each = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js")(0);

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/modules/_meta.js");

var assign = __webpack_require__(/*! ./_object-assign */ "./node_modules/core-js/modules/_object-assign.js");

var weak = __webpack_require__(/*! ./_collection-weak */ "./node_modules/core-js/modules/_collection-weak.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var NATIVE_WEAK_MAP = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
}; // 23.3 WeakMap Objects

var $WeakMap = module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(WEAK_MAP, wrapper, methods, weak, true, true); // IE11 WeakMap frozen keys fix


if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();

        var result = this._f[key](a, b);

        return key == 'set' ? this : result; // store all the rest on native weakmap
      }

      return method.call(this, a, b);
    });
  });
}

/***/ }),

/***/ "./node_modules/core-js/modules/es6.weak-set.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es6.weak-set.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var weak = __webpack_require__(/*! ./_collection-weak */ "./node_modules/core-js/modules/_collection-weak.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/core-js/modules/_validate-collection.js");

var WEAK_SET = 'WeakSet'; // 23.4 WeakSet Objects

__webpack_require__(/*! ./_collection */ "./node_modules/core-js/modules/_collection.js")(WEAK_SET, function (get) {
  return function WeakSet() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

/***/ }),

/***/ "./node_modules/core-js/modules/es7.array.flat-map.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.array.flat-map.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var flattenIntoArray = __webpack_require__(/*! ./_flatten-into-array */ "./node_modules/core-js/modules/_flatten-into-array.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var arraySpeciesCreate = __webpack_require__(/*! ./_array-species-create */ "./node_modules/core-js/modules/_array-species-create.js");

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn
  /* , thisArg */
  ) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('flatMap');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.array.flatten.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.array.flatten.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var flattenIntoArray = __webpack_require__(/*! ./_flatten-into-array */ "./node_modules/core-js/modules/_flatten-into-array.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");

var arraySpeciesCreate = __webpack_require__(/*! ./_array-species-create */ "./node_modules/core-js/modules/_array-species-create.js");

$export($export.P, 'Array', {
  flatten: function flatten()
  /* depthArg = 1 */
  {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('flatten');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.array.includes.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.array.includes.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/Array.prototype.includes

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $includes = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js")(true);

$export($export.P, 'Array', {
  includes: function includes(el
  /* , fromIndex = 0 */
  ) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/modules/_add-to-unscopables.js")('includes');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.asap.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/modules/es7.asap.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/core-js/modules/_microtask.js")();

var process = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js").process;

var isNode = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js")(process) == 'process';
$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.error.is-error.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.error.is-error.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/ljharb/proposal-is-error
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/modules/_cof.js");

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.global.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es7.global.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.G, {
  global: __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.map.from.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es7.map.from.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/core-js/modules/_set-collection-from.js")('Map');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.map.of.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es7.map.of.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/core-js/modules/_set-collection-of.js")('Map');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.map.to-json.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.map.to-json.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P + $export.R, 'Map', {
  toJSON: __webpack_require__(/*! ./_collection-to-json */ "./node_modules/core-js/modules/_collection-to-json.js")('Map')
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.clamp.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.clamp.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.deg-per-rad.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.deg-per-rad.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  DEG_PER_RAD: Math.PI / 180
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.degrees.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.degrees.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var RAD_PER_DEG = 180 / Math.PI;
$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.fscale.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.fscale.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var scale = __webpack_require__(/*! ./_math-scale */ "./node_modules/core-js/modules/_math-scale.js");

var fround = __webpack_require__(/*! ./_math-fround */ "./node_modules/core-js/modules/_math-fround.js");

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.iaddh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.iaddh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.imulh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.imulh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.isubh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.isubh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.rad-per-deg.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.rad-per-deg.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  RAD_PER_DEG: 180 / Math.PI
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.radians.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.radians.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var DEG_PER_RAD = Math.PI / 180;
$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.scale.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.scale.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  scale: __webpack_require__(/*! ./_math-scale */ "./node_modules/core-js/modules/_math-scale.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.signbit.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.signbit.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// http://jfbastien.github.io/papers/Math.signbit.html
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  signbit: function signbit(x) {
    // eslint-disable-next-line no-self-compare
    return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.math.umulh.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.math.umulh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.define-getter.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.define-getter.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js"); // B.2.2.2 Object.prototype.__defineGetter__(P, getter)


__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "./node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, {
      get: aFunction(getter),
      enumerable: true,
      configurable: true
    });
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.define-setter.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.define-setter.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js"); // B.2.2.3 Object.prototype.__defineSetter__(P, setter)


__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "./node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, {
      set: aFunction(setter),
      enumerable: true,
      configurable: true
    });
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.entries.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.entries.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $entries = __webpack_require__(/*! ./_object-to-array */ "./node_modules/core-js/modules/_object-to-array.js")(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var ownKeys = __webpack_require__(/*! ./_own-keys */ "./node_modules/core-js/modules/_own-keys.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/modules/_to-iobject.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/modules/_create-property.js");

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;

    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }

    return result;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.lookup-getter.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.lookup-getter.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f; // B.2.2.4 Object.prototype.__lookupGetter__(P)


__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "./node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;

    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.lookup-setter.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.lookup-setter.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js").f; // B.2.2.5 Object.prototype.__lookupSetter__(P)


__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "./node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;

    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.object.values.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.object.values.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $values = __webpack_require__(/*! ./_object-to-array */ "./node_modules/core-js/modules/_object-to-array.js")(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.observable.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.observable.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/zenparsing/es-observable

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/core-js/modules/_microtask.js")();

var OBSERVABLE = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js")('observable');

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/modules/_for-of.js");

var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;

  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);

  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;

    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () {
        subscription.unsubscribe();
      };else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  }

  if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() {
    closeSubscription(this);
  }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;

    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;

      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;

    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    }

    cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;

    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;

      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      }

      cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});
redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);

    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }

    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          }

          observer.complete();
        }
      });
      return function () {
        done = true;
      };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];

    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          }

          observer.complete();
        }
      });
      return function () {
        done = true;
      };
    });
  }
});
hide($Observable.prototype, OBSERVABLE, function () {
  return this;
});
$export($export.G, {
  Observable: $Observable
});

__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js")('Observable');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.promise.finally.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.promise.finally.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/modules/_core.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");

var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/core-js/modules/_promise-resolve.js");

$export($export.P + $export.R, 'Promise', {
  'finally': function (onFinally) {
    var C = speciesConstructor(this, core.Promise || global.Promise);
    var isFunction = typeof onFinally == 'function';
    return this.then(isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () {
        return x;
      });
    } : onFinally, isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () {
        throw e;
      });
    } : onFinally);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.promise.try.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.promise.try.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-promise-try

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/modules/_new-promise-capability.js");

var perform = __webpack_require__(/*! ./_perform */ "./node_modules/core-js/modules/_perform.js");

$export($export.S, 'Promise', {
  'try': function (callbackfn) {
    var promiseCapability = newPromiseCapability.f(this);
    var result = perform(callbackfn);
    (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
    return promiseCapability.promise;
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.define-metadata.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.define-metadata.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;
metadata.exp({
  defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
    ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.delete-metadata.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.delete-metadata.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;
metadata.exp({
  deleteMetadata: function deleteMetadata(metadataKey, target
  /* , targetKey */
  ) {
    var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
    var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
    if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
    if (metadataMap.size) return true;
    var targetMetadata = store.get(target);
    targetMetadata['delete'](targetKey);
    return !!targetMetadata.size || store['delete'](target);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.get-metadata-keys.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.get-metadata-keys.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(/*! ./es6.set */ "./node_modules/core-js/modules/es6.set.js");

var from = __webpack_require__(/*! ./_array-from-iterable */ "./node_modules/core-js/modules/_array-from-iterable.js");

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({
  getMetadataKeys: function getMetadataKeys(target
  /* , targetKey */
  ) {
    return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.get-metadata.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.get-metadata.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({
  getMetadata: function getMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;
metadata.exp({
  getOwnMetadataKeys: function getOwnMetadataKeys(target
  /* , targetKey */
  ) {
    return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.get-own-metadata.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.get-own-metadata.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;
metadata.exp({
  getOwnMetadata: function getOwnMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryGetOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.has-metadata.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.has-metadata.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");

var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({
  hasMetadata: function hasMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.has-own-metadata.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.has-own-metadata.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;
metadata.exp({
  hasOwnMetadata: function hasOwnMetadata(metadataKey, target
  /* , targetKey */
  ) {
    return ordinaryHasOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.reflect.metadata.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.reflect.metadata.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/core-js/modules/_metadata.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/modules/_an-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/modules/_a-function.js");

var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;
$metadata.exp({
  metadata: function metadata(metadataKey, metadataValue) {
    return function decorator(target, targetKey) {
      ordinaryDefineOwnMetadata(metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey(targetKey));
    };
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.set.from.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es7.set.from.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/core-js/modules/_set-collection-from.js")('Set');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.set.of.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es7.set.of.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/core-js/modules/_set-collection-of.js")('Set');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.set.to-json.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.set.to-json.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.P + $export.R, 'Set', {
  toJSON: __webpack_require__(/*! ./_collection-to-json */ "./node_modules/core-js/modules/_collection-to-json.js")('Set')
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.at.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.at.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/mathiasbynens/String.prototype.at

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/modules/_string-at.js")(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.match-all.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.match-all.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/String.prototype.matchAll/

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/modules/_defined.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/core-js/modules/_is-regexp.js");

var getFlags = __webpack_require__(/*! ./_flags */ "./node_modules/core-js/modules/_flags.js");

var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

__webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/modules/_iter-create.js")($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);

  return {
    value: match,
    done: match === null
  };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.pad-end.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.pad-end.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $pad = __webpack_require__(/*! ./_string-pad */ "./node_modules/core-js/modules/_string-pad.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js"); // https://github.com/zloirock/core-js/issues/280


var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padEnd: function padEnd(maxLength
  /* , fillString = ' ' */
  ) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.pad-start.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.pad-start.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $pad = __webpack_require__(/*! ./_string-pad */ "./node_modules/core-js/modules/_string-pad.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js"); // https://github.com/zloirock/core-js/issues/280


var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength
  /* , fillString = ' ' */
  ) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.trim-left.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.trim-left.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/sebmarkbage/ecmascript-string-left-right-trim

__webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js")('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.string.trim-right.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.string.trim-right.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/sebmarkbage/ecmascript-string-left-right-trim

__webpack_require__(/*! ./_string-trim */ "./node_modules/core-js/modules/_string-trim.js")('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.symbol.async-iterator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.symbol.async-iterator.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/modules/_wks-define.js")('asyncIterator');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.symbol.observable.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es7.symbol.observable.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/modules/_wks-define.js")('observable');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.system.global.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.system.global.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

$export($export.S, 'System', {
  global: __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js")
});

/***/ }),

/***/ "./node_modules/core-js/modules/es7.weak-map.from.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.weak-map.from.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/core-js/modules/_set-collection-from.js")('WeakMap');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.weak-map.of.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.weak-map.of.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/core-js/modules/_set-collection-of.js")('WeakMap');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.weak-set.from.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.weak-set.from.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/core-js/modules/_set-collection-from.js")('WeakSet');

/***/ }),

/***/ "./node_modules/core-js/modules/es7.weak-set.of.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es7.weak-set.of.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/core-js/modules/_set-collection-of.js")('WeakSet');

/***/ }),

/***/ "./node_modules/core-js/modules/web.dom.iterable.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom.iterable.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/modules/_object-keys.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/modules/_redefine.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");

var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");

var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;
var DOMIterables = {
  CSSRuleList: true,
  // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true,
  // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true,
  // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;

  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

/***/ }),

/***/ "./node_modules/core-js/modules/web.immediate.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/web.immediate.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var $task = __webpack_require__(/*! ./_task */ "./node_modules/core-js/modules/_task.js");

$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

/***/ }),

/***/ "./node_modules/core-js/modules/web.timers.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/web.timers.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/modules/_user-agent.js");

var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check

var wrap = function (set) {
  return function (fn, time
  /* , ...args */
  ) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};

$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

/***/ }),

/***/ "./node_modules/core-js/shim.js":
/*!**************************************!*\
  !*** ./node_modules/core-js/shim.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./modules/es6.symbol */ "./node_modules/core-js/modules/es6.symbol.js");

__webpack_require__(/*! ./modules/es6.object.create */ "./node_modules/core-js/modules/es6.object.create.js");

__webpack_require__(/*! ./modules/es6.object.define-property */ "./node_modules/core-js/modules/es6.object.define-property.js");

__webpack_require__(/*! ./modules/es6.object.define-properties */ "./node_modules/core-js/modules/es6.object.define-properties.js");

__webpack_require__(/*! ./modules/es6.object.get-own-property-descriptor */ "./node_modules/core-js/modules/es6.object.get-own-property-descriptor.js");

__webpack_require__(/*! ./modules/es6.object.get-prototype-of */ "./node_modules/core-js/modules/es6.object.get-prototype-of.js");

__webpack_require__(/*! ./modules/es6.object.keys */ "./node_modules/core-js/modules/es6.object.keys.js");

__webpack_require__(/*! ./modules/es6.object.get-own-property-names */ "./node_modules/core-js/modules/es6.object.get-own-property-names.js");

__webpack_require__(/*! ./modules/es6.object.freeze */ "./node_modules/core-js/modules/es6.object.freeze.js");

__webpack_require__(/*! ./modules/es6.object.seal */ "./node_modules/core-js/modules/es6.object.seal.js");

__webpack_require__(/*! ./modules/es6.object.prevent-extensions */ "./node_modules/core-js/modules/es6.object.prevent-extensions.js");

__webpack_require__(/*! ./modules/es6.object.is-frozen */ "./node_modules/core-js/modules/es6.object.is-frozen.js");

__webpack_require__(/*! ./modules/es6.object.is-sealed */ "./node_modules/core-js/modules/es6.object.is-sealed.js");

__webpack_require__(/*! ./modules/es6.object.is-extensible */ "./node_modules/core-js/modules/es6.object.is-extensible.js");

__webpack_require__(/*! ./modules/es6.object.assign */ "./node_modules/core-js/modules/es6.object.assign.js");

__webpack_require__(/*! ./modules/es6.object.is */ "./node_modules/core-js/modules/es6.object.is.js");

__webpack_require__(/*! ./modules/es6.object.set-prototype-of */ "./node_modules/core-js/modules/es6.object.set-prototype-of.js");

__webpack_require__(/*! ./modules/es6.object.to-string */ "./node_modules/core-js/modules/es6.object.to-string.js");

__webpack_require__(/*! ./modules/es6.function.bind */ "./node_modules/core-js/modules/es6.function.bind.js");

__webpack_require__(/*! ./modules/es6.function.name */ "./node_modules/core-js/modules/es6.function.name.js");

__webpack_require__(/*! ./modules/es6.function.has-instance */ "./node_modules/core-js/modules/es6.function.has-instance.js");

__webpack_require__(/*! ./modules/es6.parse-int */ "./node_modules/core-js/modules/es6.parse-int.js");

__webpack_require__(/*! ./modules/es6.parse-float */ "./node_modules/core-js/modules/es6.parse-float.js");

__webpack_require__(/*! ./modules/es6.number.constructor */ "./node_modules/core-js/modules/es6.number.constructor.js");

__webpack_require__(/*! ./modules/es6.number.to-fixed */ "./node_modules/core-js/modules/es6.number.to-fixed.js");

__webpack_require__(/*! ./modules/es6.number.to-precision */ "./node_modules/core-js/modules/es6.number.to-precision.js");

__webpack_require__(/*! ./modules/es6.number.epsilon */ "./node_modules/core-js/modules/es6.number.epsilon.js");

__webpack_require__(/*! ./modules/es6.number.is-finite */ "./node_modules/core-js/modules/es6.number.is-finite.js");

__webpack_require__(/*! ./modules/es6.number.is-integer */ "./node_modules/core-js/modules/es6.number.is-integer.js");

__webpack_require__(/*! ./modules/es6.number.is-nan */ "./node_modules/core-js/modules/es6.number.is-nan.js");

__webpack_require__(/*! ./modules/es6.number.is-safe-integer */ "./node_modules/core-js/modules/es6.number.is-safe-integer.js");

__webpack_require__(/*! ./modules/es6.number.max-safe-integer */ "./node_modules/core-js/modules/es6.number.max-safe-integer.js");

__webpack_require__(/*! ./modules/es6.number.min-safe-integer */ "./node_modules/core-js/modules/es6.number.min-safe-integer.js");

__webpack_require__(/*! ./modules/es6.number.parse-float */ "./node_modules/core-js/modules/es6.number.parse-float.js");

__webpack_require__(/*! ./modules/es6.number.parse-int */ "./node_modules/core-js/modules/es6.number.parse-int.js");

__webpack_require__(/*! ./modules/es6.math.acosh */ "./node_modules/core-js/modules/es6.math.acosh.js");

__webpack_require__(/*! ./modules/es6.math.asinh */ "./node_modules/core-js/modules/es6.math.asinh.js");

__webpack_require__(/*! ./modules/es6.math.atanh */ "./node_modules/core-js/modules/es6.math.atanh.js");

__webpack_require__(/*! ./modules/es6.math.cbrt */ "./node_modules/core-js/modules/es6.math.cbrt.js");

__webpack_require__(/*! ./modules/es6.math.clz32 */ "./node_modules/core-js/modules/es6.math.clz32.js");

__webpack_require__(/*! ./modules/es6.math.cosh */ "./node_modules/core-js/modules/es6.math.cosh.js");

__webpack_require__(/*! ./modules/es6.math.expm1 */ "./node_modules/core-js/modules/es6.math.expm1.js");

__webpack_require__(/*! ./modules/es6.math.fround */ "./node_modules/core-js/modules/es6.math.fround.js");

__webpack_require__(/*! ./modules/es6.math.hypot */ "./node_modules/core-js/modules/es6.math.hypot.js");

__webpack_require__(/*! ./modules/es6.math.imul */ "./node_modules/core-js/modules/es6.math.imul.js");

__webpack_require__(/*! ./modules/es6.math.log10 */ "./node_modules/core-js/modules/es6.math.log10.js");

__webpack_require__(/*! ./modules/es6.math.log1p */ "./node_modules/core-js/modules/es6.math.log1p.js");

__webpack_require__(/*! ./modules/es6.math.log2 */ "./node_modules/core-js/modules/es6.math.log2.js");

__webpack_require__(/*! ./modules/es6.math.sign */ "./node_modules/core-js/modules/es6.math.sign.js");

__webpack_require__(/*! ./modules/es6.math.sinh */ "./node_modules/core-js/modules/es6.math.sinh.js");

__webpack_require__(/*! ./modules/es6.math.tanh */ "./node_modules/core-js/modules/es6.math.tanh.js");

__webpack_require__(/*! ./modules/es6.math.trunc */ "./node_modules/core-js/modules/es6.math.trunc.js");

__webpack_require__(/*! ./modules/es6.string.from-code-point */ "./node_modules/core-js/modules/es6.string.from-code-point.js");

__webpack_require__(/*! ./modules/es6.string.raw */ "./node_modules/core-js/modules/es6.string.raw.js");

__webpack_require__(/*! ./modules/es6.string.trim */ "./node_modules/core-js/modules/es6.string.trim.js");

__webpack_require__(/*! ./modules/es6.string.iterator */ "./node_modules/core-js/modules/es6.string.iterator.js");

__webpack_require__(/*! ./modules/es6.string.code-point-at */ "./node_modules/core-js/modules/es6.string.code-point-at.js");

__webpack_require__(/*! ./modules/es6.string.ends-with */ "./node_modules/core-js/modules/es6.string.ends-with.js");

__webpack_require__(/*! ./modules/es6.string.includes */ "./node_modules/core-js/modules/es6.string.includes.js");

__webpack_require__(/*! ./modules/es6.string.repeat */ "./node_modules/core-js/modules/es6.string.repeat.js");

__webpack_require__(/*! ./modules/es6.string.starts-with */ "./node_modules/core-js/modules/es6.string.starts-with.js");

__webpack_require__(/*! ./modules/es6.string.anchor */ "./node_modules/core-js/modules/es6.string.anchor.js");

__webpack_require__(/*! ./modules/es6.string.big */ "./node_modules/core-js/modules/es6.string.big.js");

__webpack_require__(/*! ./modules/es6.string.blink */ "./node_modules/core-js/modules/es6.string.blink.js");

__webpack_require__(/*! ./modules/es6.string.bold */ "./node_modules/core-js/modules/es6.string.bold.js");

__webpack_require__(/*! ./modules/es6.string.fixed */ "./node_modules/core-js/modules/es6.string.fixed.js");

__webpack_require__(/*! ./modules/es6.string.fontcolor */ "./node_modules/core-js/modules/es6.string.fontcolor.js");

__webpack_require__(/*! ./modules/es6.string.fontsize */ "./node_modules/core-js/modules/es6.string.fontsize.js");

__webpack_require__(/*! ./modules/es6.string.italics */ "./node_modules/core-js/modules/es6.string.italics.js");

__webpack_require__(/*! ./modules/es6.string.link */ "./node_modules/core-js/modules/es6.string.link.js");

__webpack_require__(/*! ./modules/es6.string.small */ "./node_modules/core-js/modules/es6.string.small.js");

__webpack_require__(/*! ./modules/es6.string.strike */ "./node_modules/core-js/modules/es6.string.strike.js");

__webpack_require__(/*! ./modules/es6.string.sub */ "./node_modules/core-js/modules/es6.string.sub.js");

__webpack_require__(/*! ./modules/es6.string.sup */ "./node_modules/core-js/modules/es6.string.sup.js");

__webpack_require__(/*! ./modules/es6.date.now */ "./node_modules/core-js/modules/es6.date.now.js");

__webpack_require__(/*! ./modules/es6.date.to-json */ "./node_modules/core-js/modules/es6.date.to-json.js");

__webpack_require__(/*! ./modules/es6.date.to-iso-string */ "./node_modules/core-js/modules/es6.date.to-iso-string.js");

__webpack_require__(/*! ./modules/es6.date.to-string */ "./node_modules/core-js/modules/es6.date.to-string.js");

__webpack_require__(/*! ./modules/es6.date.to-primitive */ "./node_modules/core-js/modules/es6.date.to-primitive.js");

__webpack_require__(/*! ./modules/es6.array.is-array */ "./node_modules/core-js/modules/es6.array.is-array.js");

__webpack_require__(/*! ./modules/es6.array.from */ "./node_modules/core-js/modules/es6.array.from.js");

__webpack_require__(/*! ./modules/es6.array.of */ "./node_modules/core-js/modules/es6.array.of.js");

__webpack_require__(/*! ./modules/es6.array.join */ "./node_modules/core-js/modules/es6.array.join.js");

__webpack_require__(/*! ./modules/es6.array.slice */ "./node_modules/core-js/modules/es6.array.slice.js");

__webpack_require__(/*! ./modules/es6.array.sort */ "./node_modules/core-js/modules/es6.array.sort.js");

__webpack_require__(/*! ./modules/es6.array.for-each */ "./node_modules/core-js/modules/es6.array.for-each.js");

__webpack_require__(/*! ./modules/es6.array.map */ "./node_modules/core-js/modules/es6.array.map.js");

__webpack_require__(/*! ./modules/es6.array.filter */ "./node_modules/core-js/modules/es6.array.filter.js");

__webpack_require__(/*! ./modules/es6.array.some */ "./node_modules/core-js/modules/es6.array.some.js");

__webpack_require__(/*! ./modules/es6.array.every */ "./node_modules/core-js/modules/es6.array.every.js");

__webpack_require__(/*! ./modules/es6.array.reduce */ "./node_modules/core-js/modules/es6.array.reduce.js");

__webpack_require__(/*! ./modules/es6.array.reduce-right */ "./node_modules/core-js/modules/es6.array.reduce-right.js");

__webpack_require__(/*! ./modules/es6.array.index-of */ "./node_modules/core-js/modules/es6.array.index-of.js");

__webpack_require__(/*! ./modules/es6.array.last-index-of */ "./node_modules/core-js/modules/es6.array.last-index-of.js");

__webpack_require__(/*! ./modules/es6.array.copy-within */ "./node_modules/core-js/modules/es6.array.copy-within.js");

__webpack_require__(/*! ./modules/es6.array.fill */ "./node_modules/core-js/modules/es6.array.fill.js");

__webpack_require__(/*! ./modules/es6.array.find */ "./node_modules/core-js/modules/es6.array.find.js");

__webpack_require__(/*! ./modules/es6.array.find-index */ "./node_modules/core-js/modules/es6.array.find-index.js");

__webpack_require__(/*! ./modules/es6.array.species */ "./node_modules/core-js/modules/es6.array.species.js");

__webpack_require__(/*! ./modules/es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");

__webpack_require__(/*! ./modules/es6.regexp.constructor */ "./node_modules/core-js/modules/es6.regexp.constructor.js");

__webpack_require__(/*! ./modules/es6.regexp.exec */ "./node_modules/core-js/modules/es6.regexp.exec.js");

__webpack_require__(/*! ./modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");

__webpack_require__(/*! ./modules/es6.regexp.flags */ "./node_modules/core-js/modules/es6.regexp.flags.js");

__webpack_require__(/*! ./modules/es6.regexp.match */ "./node_modules/core-js/modules/es6.regexp.match.js");

__webpack_require__(/*! ./modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");

__webpack_require__(/*! ./modules/es6.regexp.search */ "./node_modules/core-js/modules/es6.regexp.search.js");

__webpack_require__(/*! ./modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");

__webpack_require__(/*! ./modules/es6.promise */ "./node_modules/core-js/modules/es6.promise.js");

__webpack_require__(/*! ./modules/es6.map */ "./node_modules/core-js/modules/es6.map.js");

__webpack_require__(/*! ./modules/es6.set */ "./node_modules/core-js/modules/es6.set.js");

__webpack_require__(/*! ./modules/es6.weak-map */ "./node_modules/core-js/modules/es6.weak-map.js");

__webpack_require__(/*! ./modules/es6.weak-set */ "./node_modules/core-js/modules/es6.weak-set.js");

__webpack_require__(/*! ./modules/es6.typed.array-buffer */ "./node_modules/core-js/modules/es6.typed.array-buffer.js");

__webpack_require__(/*! ./modules/es6.typed.data-view */ "./node_modules/core-js/modules/es6.typed.data-view.js");

__webpack_require__(/*! ./modules/es6.typed.int8-array */ "./node_modules/core-js/modules/es6.typed.int8-array.js");

__webpack_require__(/*! ./modules/es6.typed.uint8-array */ "./node_modules/core-js/modules/es6.typed.uint8-array.js");

__webpack_require__(/*! ./modules/es6.typed.uint8-clamped-array */ "./node_modules/core-js/modules/es6.typed.uint8-clamped-array.js");

__webpack_require__(/*! ./modules/es6.typed.int16-array */ "./node_modules/core-js/modules/es6.typed.int16-array.js");

__webpack_require__(/*! ./modules/es6.typed.uint16-array */ "./node_modules/core-js/modules/es6.typed.uint16-array.js");

__webpack_require__(/*! ./modules/es6.typed.int32-array */ "./node_modules/core-js/modules/es6.typed.int32-array.js");

__webpack_require__(/*! ./modules/es6.typed.uint32-array */ "./node_modules/core-js/modules/es6.typed.uint32-array.js");

__webpack_require__(/*! ./modules/es6.typed.float32-array */ "./node_modules/core-js/modules/es6.typed.float32-array.js");

__webpack_require__(/*! ./modules/es6.typed.float64-array */ "./node_modules/core-js/modules/es6.typed.float64-array.js");

__webpack_require__(/*! ./modules/es6.reflect.apply */ "./node_modules/core-js/modules/es6.reflect.apply.js");

__webpack_require__(/*! ./modules/es6.reflect.construct */ "./node_modules/core-js/modules/es6.reflect.construct.js");

__webpack_require__(/*! ./modules/es6.reflect.define-property */ "./node_modules/core-js/modules/es6.reflect.define-property.js");

__webpack_require__(/*! ./modules/es6.reflect.delete-property */ "./node_modules/core-js/modules/es6.reflect.delete-property.js");

__webpack_require__(/*! ./modules/es6.reflect.enumerate */ "./node_modules/core-js/modules/es6.reflect.enumerate.js");

__webpack_require__(/*! ./modules/es6.reflect.get */ "./node_modules/core-js/modules/es6.reflect.get.js");

__webpack_require__(/*! ./modules/es6.reflect.get-own-property-descriptor */ "./node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js");

__webpack_require__(/*! ./modules/es6.reflect.get-prototype-of */ "./node_modules/core-js/modules/es6.reflect.get-prototype-of.js");

__webpack_require__(/*! ./modules/es6.reflect.has */ "./node_modules/core-js/modules/es6.reflect.has.js");

__webpack_require__(/*! ./modules/es6.reflect.is-extensible */ "./node_modules/core-js/modules/es6.reflect.is-extensible.js");

__webpack_require__(/*! ./modules/es6.reflect.own-keys */ "./node_modules/core-js/modules/es6.reflect.own-keys.js");

__webpack_require__(/*! ./modules/es6.reflect.prevent-extensions */ "./node_modules/core-js/modules/es6.reflect.prevent-extensions.js");

__webpack_require__(/*! ./modules/es6.reflect.set */ "./node_modules/core-js/modules/es6.reflect.set.js");

__webpack_require__(/*! ./modules/es6.reflect.set-prototype-of */ "./node_modules/core-js/modules/es6.reflect.set-prototype-of.js");

__webpack_require__(/*! ./modules/es7.array.includes */ "./node_modules/core-js/modules/es7.array.includes.js");

__webpack_require__(/*! ./modules/es7.array.flat-map */ "./node_modules/core-js/modules/es7.array.flat-map.js");

__webpack_require__(/*! ./modules/es7.array.flatten */ "./node_modules/core-js/modules/es7.array.flatten.js");

__webpack_require__(/*! ./modules/es7.string.at */ "./node_modules/core-js/modules/es7.string.at.js");

__webpack_require__(/*! ./modules/es7.string.pad-start */ "./node_modules/core-js/modules/es7.string.pad-start.js");

__webpack_require__(/*! ./modules/es7.string.pad-end */ "./node_modules/core-js/modules/es7.string.pad-end.js");

__webpack_require__(/*! ./modules/es7.string.trim-left */ "./node_modules/core-js/modules/es7.string.trim-left.js");

__webpack_require__(/*! ./modules/es7.string.trim-right */ "./node_modules/core-js/modules/es7.string.trim-right.js");

__webpack_require__(/*! ./modules/es7.string.match-all */ "./node_modules/core-js/modules/es7.string.match-all.js");

__webpack_require__(/*! ./modules/es7.symbol.async-iterator */ "./node_modules/core-js/modules/es7.symbol.async-iterator.js");

__webpack_require__(/*! ./modules/es7.symbol.observable */ "./node_modules/core-js/modules/es7.symbol.observable.js");

__webpack_require__(/*! ./modules/es7.object.get-own-property-descriptors */ "./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js");

__webpack_require__(/*! ./modules/es7.object.values */ "./node_modules/core-js/modules/es7.object.values.js");

__webpack_require__(/*! ./modules/es7.object.entries */ "./node_modules/core-js/modules/es7.object.entries.js");

__webpack_require__(/*! ./modules/es7.object.define-getter */ "./node_modules/core-js/modules/es7.object.define-getter.js");

__webpack_require__(/*! ./modules/es7.object.define-setter */ "./node_modules/core-js/modules/es7.object.define-setter.js");

__webpack_require__(/*! ./modules/es7.object.lookup-getter */ "./node_modules/core-js/modules/es7.object.lookup-getter.js");

__webpack_require__(/*! ./modules/es7.object.lookup-setter */ "./node_modules/core-js/modules/es7.object.lookup-setter.js");

__webpack_require__(/*! ./modules/es7.map.to-json */ "./node_modules/core-js/modules/es7.map.to-json.js");

__webpack_require__(/*! ./modules/es7.set.to-json */ "./node_modules/core-js/modules/es7.set.to-json.js");

__webpack_require__(/*! ./modules/es7.map.of */ "./node_modules/core-js/modules/es7.map.of.js");

__webpack_require__(/*! ./modules/es7.set.of */ "./node_modules/core-js/modules/es7.set.of.js");

__webpack_require__(/*! ./modules/es7.weak-map.of */ "./node_modules/core-js/modules/es7.weak-map.of.js");

__webpack_require__(/*! ./modules/es7.weak-set.of */ "./node_modules/core-js/modules/es7.weak-set.of.js");

__webpack_require__(/*! ./modules/es7.map.from */ "./node_modules/core-js/modules/es7.map.from.js");

__webpack_require__(/*! ./modules/es7.set.from */ "./node_modules/core-js/modules/es7.set.from.js");

__webpack_require__(/*! ./modules/es7.weak-map.from */ "./node_modules/core-js/modules/es7.weak-map.from.js");

__webpack_require__(/*! ./modules/es7.weak-set.from */ "./node_modules/core-js/modules/es7.weak-set.from.js");

__webpack_require__(/*! ./modules/es7.global */ "./node_modules/core-js/modules/es7.global.js");

__webpack_require__(/*! ./modules/es7.system.global */ "./node_modules/core-js/modules/es7.system.global.js");

__webpack_require__(/*! ./modules/es7.error.is-error */ "./node_modules/core-js/modules/es7.error.is-error.js");

__webpack_require__(/*! ./modules/es7.math.clamp */ "./node_modules/core-js/modules/es7.math.clamp.js");

__webpack_require__(/*! ./modules/es7.math.deg-per-rad */ "./node_modules/core-js/modules/es7.math.deg-per-rad.js");

__webpack_require__(/*! ./modules/es7.math.degrees */ "./node_modules/core-js/modules/es7.math.degrees.js");

__webpack_require__(/*! ./modules/es7.math.fscale */ "./node_modules/core-js/modules/es7.math.fscale.js");

__webpack_require__(/*! ./modules/es7.math.iaddh */ "./node_modules/core-js/modules/es7.math.iaddh.js");

__webpack_require__(/*! ./modules/es7.math.isubh */ "./node_modules/core-js/modules/es7.math.isubh.js");

__webpack_require__(/*! ./modules/es7.math.imulh */ "./node_modules/core-js/modules/es7.math.imulh.js");

__webpack_require__(/*! ./modules/es7.math.rad-per-deg */ "./node_modules/core-js/modules/es7.math.rad-per-deg.js");

__webpack_require__(/*! ./modules/es7.math.radians */ "./node_modules/core-js/modules/es7.math.radians.js");

__webpack_require__(/*! ./modules/es7.math.scale */ "./node_modules/core-js/modules/es7.math.scale.js");

__webpack_require__(/*! ./modules/es7.math.umulh */ "./node_modules/core-js/modules/es7.math.umulh.js");

__webpack_require__(/*! ./modules/es7.math.signbit */ "./node_modules/core-js/modules/es7.math.signbit.js");

__webpack_require__(/*! ./modules/es7.promise.finally */ "./node_modules/core-js/modules/es7.promise.finally.js");

__webpack_require__(/*! ./modules/es7.promise.try */ "./node_modules/core-js/modules/es7.promise.try.js");

__webpack_require__(/*! ./modules/es7.reflect.define-metadata */ "./node_modules/core-js/modules/es7.reflect.define-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.delete-metadata */ "./node_modules/core-js/modules/es7.reflect.delete-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.get-metadata */ "./node_modules/core-js/modules/es7.reflect.get-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.get-metadata-keys */ "./node_modules/core-js/modules/es7.reflect.get-metadata-keys.js");

__webpack_require__(/*! ./modules/es7.reflect.get-own-metadata */ "./node_modules/core-js/modules/es7.reflect.get-own-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.get-own-metadata-keys */ "./node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js");

__webpack_require__(/*! ./modules/es7.reflect.has-metadata */ "./node_modules/core-js/modules/es7.reflect.has-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.has-own-metadata */ "./node_modules/core-js/modules/es7.reflect.has-own-metadata.js");

__webpack_require__(/*! ./modules/es7.reflect.metadata */ "./node_modules/core-js/modules/es7.reflect.metadata.js");

__webpack_require__(/*! ./modules/es7.asap */ "./node_modules/core-js/modules/es7.asap.js");

__webpack_require__(/*! ./modules/es7.observable */ "./node_modules/core-js/modules/es7.observable.js");

__webpack_require__(/*! ./modules/web.timers */ "./node_modules/core-js/modules/web.timers.js");

__webpack_require__(/*! ./modules/web.immediate */ "./node_modules/core-js/modules/web.immediate.js");

__webpack_require__(/*! ./modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");

module.exports = __webpack_require__(/*! ./modules/_core */ "./node_modules/core-js/modules/_core.js");

/***/ }),

/***/ "./node_modules/highcharts/highcharts.js":
/*!***********************************************!*\
  !*** ./node_modules/highcharts/highcharts.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 Highcharts JS v8.0.4 (2020-03-10)

 (c) 2009-2018 Torstein Honsi

 License: www.highcharts.com/license
*/
(function (aa, S) {
   true && module.exports ? (S["default"] = S, module.exports = aa.document ? S(aa) : S) :  true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    return S(aa);
  }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
})("undefined" !== typeof window ? window : this, function (aa) {
  function S(d, g, W, u) {
    d.hasOwnProperty(g) || (d[g] = u.apply(null, W));
  }

  var r = {};
  S(r, "parts/Globals.js", [], function () {
    var d = "undefined" !== typeof aa ? aa : "undefined" !== typeof window ? window : {},
        g = d.document,
        W = d.navigator && d.navigator.userAgent || "",
        u = g && g.createElementNS && !!g.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect,
        r = /(edge|msie|trident)/i.test(W) && !d.opera,
        M = -1 !== W.indexOf("Firefox"),
        E = -1 !== W.indexOf("Chrome"),
        A = M && 4 > parseInt(W.split("Firefox/")[1], 10);
    return {
      product: "Highcharts",
      version: "8.0.4",
      deg2rad: 2 * Math.PI / 360,
      doc: g,
      hasBidiBug: A,
      hasTouch: !!d.TouchEvent,
      isMS: r,
      isWebKit: -1 !== W.indexOf("AppleWebKit"),
      isFirefox: M,
      isChrome: E,
      isSafari: !E && -1 !== W.indexOf("Safari"),
      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(W),
      SVG_NS: "http://www.w3.org/2000/svg",
      chartCount: 0,
      seriesTypes: {},
      symbolSizes: {},
      svg: u,
      win: d,
      marginNames: ["plotTop", "marginRight", "marginBottom", "plotLeft"],
      noop: function () {},
      charts: [],
      dateFormats: {}
    };
  });
  S(r, "parts/Utilities.js", [r["parts/Globals.js"]], function (d) {
    function g() {
      var b,
          a = arguments,
          m = {},
          f = function (b, a) {
        "object" !== typeof b && (b = {});
        Y(a, function (m, c) {
          !h(m, !0) || q(m) || N(m) ? b[c] = a[c] : b[c] = f(b[c] || {}, m);
        });
        return b;
      };

      !0 === a[0] && (m = a[1], a = Array.prototype.slice.call(a, 2));
      var c = a.length;

      for (b = 0; b < c; b++) m = f(m, a[b]);

      return m;
    }

    function W(b, a, m) {
      var f;
      t(a) ? c(m) ? b.setAttribute(a, m) : b && b.getAttribute && ((f = b.getAttribute(a)) || "class" !== a || (f = b.getAttribute(a + "Name"))) : Y(a, function (a, m) {
        b.setAttribute(m, a);
      });
      return f;
    }

    function u() {
      for (var b = arguments, a = b.length, m = 0; m < a; m++) {
        var f = b[m];
        if ("undefined" !== typeof f && null !== f) return f;
      }
    }

    function r(b, a) {
      if (!b) return a;
      var m = b.split(".").reverse();
      if (1 === m.length) return a[b];

      for (b = m.pop(); "undefined" !== typeof b && "undefined" !== typeof a && null !== a;) a = a[b], b = m.pop();

      return a;
    }

    d.timers = [];

    var M = d.charts,
        E = d.doc,
        A = d.win,
        G = d.error = function (b, a, m, f) {
      var c = P(b),
          p = c ? "Highcharts error #" + b + ": www.highcharts.com/errors/" + b + "/" : b.toString(),
          e = function () {
        if (a) throw Error(p);
        A.console && console.log(p);
      };

      if ("undefined" !== typeof f) {
        var x = "";
        c && (p += "?");
        d.objectEach(f, function (b, a) {
          x += "\n" + a + ": " + b;
          c && (p += encodeURI(a) + "=" + encodeURI(b));
        });
        p += x;
      }

      m ? d.fireEvent(m, "displayError", {
        code: b,
        message: p,
        params: f
      }, e) : e();
    },
        J = function () {
      function b(b, a, m) {
        this.options = a;
        this.elem = b;
        this.prop = m;
      }

      b.prototype.dSetter = function () {
        var b = this.paths[0],
            a = this.paths[1],
            m = [],
            f = this.now,
            c = b.length;
        if (1 === f) m = this.toD;else if (c === a.length && 1 > f) for (; c--;) {
          var p = parseFloat(b[c]);
          m[c] = isNaN(p) || "A" === a[c - 4] || "A" === a[c - 5] ? a[c] : f * parseFloat("" + (a[c] - p)) + p;
        } else m = a;
        this.elem.attr("d", m, null, !0);
      };

      b.prototype.update = function () {
        var b = this.elem,
            a = this.prop,
            m = this.now,
            f = this.options.step;
        if (this[a + "Setter"]) this[a + "Setter"]();else b.attr ? b.element && b.attr(a, m, null, !0) : b.style[a] = m + this.unit;
        f && f.call(b, m, this);
      };

      b.prototype.run = function (b, a, m) {
        var f = this,
            c = f.options,
            p = function (b) {
          return p.stopped ? !1 : f.step(b);
        },
            e = A.requestAnimationFrame || function (b) {
          setTimeout(b, 13);
        },
            x = function () {
          for (var b = 0; b < d.timers.length; b++) d.timers[b]() || d.timers.splice(b--, 1);

          d.timers.length && e(x);
        };

        b !== a || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = b, this.end = a, this.unit = m, this.now = this.start, this.pos = 0, p.elem = this.elem, p.prop = this.prop, p() && 1 === d.timers.push(p) && e(x)) : (delete c.curAnim[this.prop], c.complete && 0 === Object.keys(c.curAnim).length && c.complete.call(this.elem));
      };

      b.prototype.step = function (b) {
        var a = +new Date(),
            m = this.options,
            f = this.elem,
            c = m.complete,
            p = m.duration,
            e = m.curAnim;
        if (f.attr && !f.element) b = !1;else if (b || a >= p + this.startTime) {
          this.now = this.end;
          this.pos = 1;
          this.update();
          var x = e[this.prop] = !0;
          Y(e, function (b) {
            !0 !== b && (x = !1);
          });
          x && c && c.call(f);
          b = !1;
        } else this.pos = m.easing((a - this.startTime) / p), this.now = this.start + (this.end - this.start) * this.pos, this.update(), b = !0;
        return b;
      };

      b.prototype.initPath = function (b, a, m) {
        function f(b) {
          for (C = b.length; C--;) {
            var a = "M" === b[C] || "L" === b[C];
            var m = /[a-zA-Z]/.test(b[C + 3]);
            a && m && b.splice(C + 1, 0, b[C + 1], b[C + 2], b[C + 1], b[C + 2]);
          }
        }

        function c(b, a) {
          for (; b.length < v;) {
            b[0] = a[v - b.length];
            var m = b.slice(0, T);
            [].splice.apply(b, [0, 0].concat(m));
            k && (m = b.slice(b.length - T), [].splice.apply(b, [b.length, 0].concat(m)), C--);
          }

          b[0] = "M";
        }

        function p(b, a) {
          for (var m = (v - b.length) / T; 0 < m && m--;) l = b.slice().splice(b.length / n - T, T * n), l[0] = a[v - T - m * T], F && (l[T - 6] = l[T - 2], l[T - 5] = l[T - 1]), [].splice.apply(b, [b.length / n, 0].concat(l)), k && m--;
        }

        a = a || "";
        var e = b.startX,
            x = b.endX,
            F = -1 < a.indexOf("C"),
            T = F ? 7 : 3,
            l,
            C;
        a = a.split(" ");
        m = m.slice();
        var k = b.isArea,
            n = k ? 2 : 1;
        F && (f(a), f(m));

        if (e && x) {
          for (C = 0; C < e.length; C++) if (e[C] === x[0]) {
            var V = C;
            break;
          } else if (e[0] === x[x.length - e.length + C]) {
            V = C;
            var w = !0;
            break;
          } else if (e[e.length - 1] === x[x.length - e.length + C]) {
            V = e.length - C;
            break;
          }

          "undefined" === typeof V && (a = []);
        }

        if (a.length && P(V)) {
          var v = m.length + V * n * T;
          w ? (c(a, m), p(m, a)) : (c(m, a), p(a, m));
        }

        return [a, m];
      };

      b.prototype.fillSetter = function () {
        d.Fx.prototype.strokeSetter.apply(this, arguments);
      };

      b.prototype.strokeSetter = function () {
        this.elem.attr(this.prop, d.color(this.start).tweenTo(d.color(this.end), this.pos), null, !0);
      };

      return b;
    }();

    d.Fx = J;
    d.merge = g;

    var y = d.pInt = function (b, a) {
      return parseInt(b, a || 10);
    },
        t = d.isString = function (b) {
      return "string" === typeof b;
    },
        D = d.isArray = function (b) {
      b = Object.prototype.toString.call(b);
      return "[object Array]" === b || "[object Array Iterator]" === b;
    },
        h = d.isObject = function (b, a) {
      return !!b && "object" === typeof b && (!a || !D(b));
    },
        N = d.isDOMElement = function (b) {
      return h(b) && "number" === typeof b.nodeType;
    },
        q = d.isClass = function (b) {
      var a = b && b.constructor;
      return !(!h(b, !0) || N(b) || !a || !a.name || "Object" === a.name);
    },
        P = d.isNumber = function (b) {
      return "number" === typeof b && !isNaN(b) && Infinity > b && -Infinity < b;
    },
        e = d.erase = function (b, a) {
      for (var m = b.length; m--;) if (b[m] === a) {
        b.splice(m, 1);
        break;
      }
    },
        c = d.defined = function (b) {
      return "undefined" !== typeof b && null !== b;
    };

    d.attr = W;

    var k = d.splat = function (b) {
      return D(b) ? b : [b];
    },
        n = d.syncTimeout = function (b, a, m) {
      if (0 < a) return setTimeout(b, a, m);
      b.call(0, m);
      return -1;
    },
        f = d.clearTimeout = function (b) {
      c(b) && clearTimeout(b);
    },
        a = d.extend = function (b, a) {
      var m;
      b || (b = {});

      for (m in a) b[m] = a[m];

      return b;
    };

    d.pick = u;

    var l = d.css = function (b, m) {
      d.isMS && !d.svg && m && "undefined" !== typeof m.opacity && (m.filter = "alpha(opacity=" + 100 * m.opacity + ")");
      a(b.style, m);
    },
        v = d.createElement = function (b, m, f, c, p) {
      b = E.createElement(b);
      m && a(b, m);
      p && l(b, {
        padding: "0",
        border: "none",
        margin: "0"
      });
      f && l(b, f);
      c && c.appendChild(b);
      return b;
    },
        z = d.extendClass = function (b, m) {
      var f = function () {};

      f.prototype = new b();
      a(f.prototype, m);
      return f;
    },
        w = d.pad = function (b, a, m) {
      return Array((a || 2) + 1 - String(b).replace("-", "").length).join(m || "0") + b;
    },
        B = d.relativeLength = function (b, a, m) {
      return /%$/.test(b) ? a * parseFloat(b) / 100 + (m || 0) : parseFloat(b);
    },
        L = d.wrap = function (b, a, m) {
      var f = b[a];

      b[a] = function () {
        var b = Array.prototype.slice.call(arguments),
            a = arguments,
            c = this;

        c.proceed = function () {
          f.apply(c, arguments.length ? arguments : a);
        };

        b.unshift(f);
        b = m.apply(this, b);
        c.proceed = null;
        return b;
      };
    },
        Q = d.format = function (b, a, m) {
      var f = "{",
          c = !1,
          p = [],
          e = /f$/,
          x = /\.([0-9])/,
          F = d.defaultOptions.lang,
          C = m && m.time || d.time;

      for (m = m && m.numberFormatter || T; b;) {
        var l = b.indexOf(f);
        if (-1 === l) break;
        var k = b.slice(0, l);

        if (c) {
          k = k.split(":");
          f = r(k.shift() || "", a);
          if (k.length && "number" === typeof f) if (k = k.join(":"), e.test(k)) {
            var n = parseInt((k.match(x) || ["", "-1"])[1], 10);
            null !== f && (f = m(f, n, F.decimalPoint, -1 < k.indexOf(",") ? F.thousandsSep : ""));
          } else f = C.dateFormat(k, f);
          p.push(f);
        } else p.push(k);

        b = b.slice(l + 1);
        f = (c = !c) ? "}" : "{";
      }

      p.push(b);
      return p.join("");
    },
        H = d.getMagnitude = function (b) {
      return Math.pow(10, Math.floor(Math.log(b) / Math.LN10));
    },
        K = d.normalizeTickInterval = function (b, a, m, f, c) {
      var p = b;
      m = u(m, 1);
      var e = b / m;
      a || (a = c ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === f && (1 === m ? a = a.filter(function (b) {
        return 0 === b % 1;
      }) : .1 >= m && (a = [1 / m])));

      for (f = 0; f < a.length && !(p = a[f], c && p * m >= b || !c && e <= (a[f] + (a[f + 1] || a[f])) / 2); f++);

      return p = O(p * m, -Math.round(Math.log(.001) / Math.LN10));
    },
        p = d.stableSort = function (b, a) {
      var m = b.length,
          f,
          c;

      for (c = 0; c < m; c++) b[c].safeI = c;

      b.sort(function (b, m) {
        f = a(b, m);
        return 0 === f ? b.safeI - m.safeI : f;
      });

      for (c = 0; c < m; c++) delete b[c].safeI;
    },
        b = d.arrayMin = function (b) {
      for (var a = b.length, m = b[0]; a--;) b[a] < m && (m = b[a]);

      return m;
    },
        C = d.arrayMax = function (b) {
      for (var a = b.length, m = b[0]; a--;) b[a] > m && (m = b[a]);

      return m;
    },
        x = d.destroyObjectProperties = function (b, a) {
      Y(b, function (m, f) {
        m && m !== a && m.destroy && m.destroy();
        delete b[f];
      });
    },
        R = d.discardElement = function (b) {
      var a = d.garbageBin;
      a || (a = v("div"));
      b && a.appendChild(b);
      a.innerHTML = "";
    },
        O = d.correctFloat = function (b, a) {
      return parseFloat(b.toPrecision(a || 14));
    },
        X = d.setAnimation = function (b, a) {
      a.renderer.globalAnimation = u(b, a.options.chart.animation, !0);
    },
        U = d.animObject = function (b) {
      return h(b) ? g(b) : {
        duration: b ? 500 : 0
      };
    },
        m = d.timeUnits = {
      millisecond: 1,
      second: 1E3,
      minute: 6E4,
      hour: 36E5,
      day: 864E5,
      week: 6048E5,
      month: 24192E5,
      year: 314496E5
    },
        T = d.numberFormat = function (b, a, m, f) {
      b = +b || 0;
      a = +a;
      var c = d.defaultOptions.lang,
          p = (b.toString().split(".")[1] || "").split("e")[0].length,
          e = b.toString().split("e");
      if (-1 === a) a = Math.min(p, 20);else if (!P(a)) a = 2;else if (a && e[1] && 0 > e[1]) {
        var x = a + +e[1];
        0 <= x ? (e[0] = (+e[0]).toExponential(x).split("e")[0], a = x) : (e[0] = e[0].split(".")[0] || 0, b = 20 > a ? (e[0] * Math.pow(10, e[1])).toFixed(a) : 0, e[1] = 0);
      }
      var F = (Math.abs(e[1] ? e[0] : b) + Math.pow(10, -Math.max(a, p) - 1)).toFixed(a);
      p = String(y(F));
      x = 3 < p.length ? p.length % 3 : 0;
      m = u(m, c.decimalPoint);
      f = u(f, c.thousandsSep);
      b = (0 > b ? "-" : "") + (x ? p.substr(0, x) + f : "");
      b += p.substr(x).replace(/(\d{3})(?=\d)/g, "$1" + f);
      a && (b += m + F.slice(-a));
      e[1] && 0 !== +b && (b += "e" + e[1]);
      return b;
    };

    Math.easeInOutSine = function (b) {
      return -.5 * (Math.cos(Math.PI * b) - 1);
    };

    var Z = d.getStyle = function (b, a, m) {
      if ("width" === a) return a = Math.min(b.offsetWidth, b.scrollWidth), m = b.getBoundingClientRect && b.getBoundingClientRect().width, m < a && m >= a - 1 && (a = Math.floor(m)), Math.max(0, a - d.getStyle(b, "padding-left") - d.getStyle(b, "padding-right"));
      if ("height" === a) return Math.max(0, Math.min(b.offsetHeight, b.scrollHeight) - d.getStyle(b, "padding-top") - d.getStyle(b, "padding-bottom"));
      A.getComputedStyle || G(27, !0);
      if (b = A.getComputedStyle(b, void 0)) b = b.getPropertyValue(a), u(m, "opacity" !== a) && (b = y(b));
      return b;
    },
        ca = d.inArray = function (b, a, m) {
      return a.indexOf(b, m);
    },
        F = d.find = Array.prototype.find ? function (b, a) {
      return b.find(a);
    } : function (b, a) {
      var m,
          f = b.length;

      for (m = 0; m < f; m++) if (a(b[m], m)) return b[m];
    };

    d.keys = Object.keys;

    var V = d.offset = function (b) {
      var a = E.documentElement;
      b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {
        top: 0,
        left: 0
      };
      return {
        top: b.top + (A.pageYOffset || a.scrollTop) - (a.clientTop || 0),
        left: b.left + (A.pageXOffset || a.scrollLeft) - (a.clientLeft || 0)
      };
    },
        ba = d.stop = function (b, a) {
      for (var m = d.timers.length; m--;) d.timers[m].elem !== b || a && a !== d.timers[m].prop || (d.timers[m].stopped = !0);
    },
        Y = d.objectEach = function (b, a, m) {
      for (var f in b) Object.hasOwnProperty.call(b, f) && a.call(m || b[f], b[f], f, b);
    };

    Y({
      map: "map",
      each: "forEach",
      grep: "filter",
      reduce: "reduce",
      some: "some"
    }, function (b, a) {
      d[a] = function (a) {
        return Array.prototype[b].apply(a, [].slice.call(arguments, 1));
      };
    });

    var fa = d.addEvent = function (b, a, m, f) {
      void 0 === f && (f = {});
      var c = b.addEventListener || d.addEventListenerPolyfill;
      var p = "function" === typeof b && b.prototype ? b.prototype.protoEvents = b.prototype.protoEvents || {} : b.hcEvents = b.hcEvents || {};
      d.Point && b instanceof d.Point && b.series && b.series.chart && (b.series.chart.runTrackerClick = !0);
      c && c.call(b, a, m, !1);
      p[a] || (p[a] = []);
      p[a].push({
        fn: m,
        order: "number" === typeof f.order ? f.order : Infinity
      });
      p[a].sort(function (b, a) {
        return b.order - a.order;
      });
      return function () {
        da(b, a, m);
      };
    },
        da = d.removeEvent = function (b, a, m) {
      function f(a, m) {
        var f = b.removeEventListener || d.removeEventListenerPolyfill;
        f && f.call(b, a, m, !1);
      }

      function c(m) {
        var c;

        if (b.nodeName) {
          if (a) {
            var p = {};
            p[a] = !0;
          } else p = m;

          Y(p, function (b, a) {
            if (m[a]) for (c = m[a].length; c--;) f(a, m[a][c].fn);
          });
        }
      }

      var p;
      ["protoEvents", "hcEvents"].forEach(function (e, x) {
        var F = (x = x ? b : b.prototype) && x[e];
        F && (a ? (p = F[a] || [], m ? (F[a] = p.filter(function (b) {
          return m !== b.fn;
        }), f(a, m)) : (c(F), F[a] = [])) : (c(F), x[e] = {}));
      });
    },
        ha = d.fireEvent = function (b, m, f, c) {
      var p;
      f = f || {};

      if (E.createEvent && (b.dispatchEvent || b.fireEvent)) {
        var e = E.createEvent("Events");
        e.initEvent(m, !0, !0);
        a(e, f);
        b.dispatchEvent ? b.dispatchEvent(e) : b.fireEvent(m, e);
      } else f.target || a(f, {
        preventDefault: function () {
          f.defaultPrevented = !0;
        },
        target: b,
        type: m
      }), function (a, m) {
        void 0 === a && (a = []);
        void 0 === m && (m = []);
        var c = 0,
            e = 0,
            x = a.length + m.length;

        for (p = 0; p < x; p++) !1 === (a[c] ? m[e] ? a[c].order <= m[e].order ? a[c++] : m[e++] : a[c++] : m[e++]).fn.call(b, f) && f.preventDefault();
      }(b.protoEvents && b.protoEvents[m], b.hcEvents && b.hcEvents[m]);

      c && !f.defaultPrevented && c.call(b, f);
    },
        ia = d.animate = function (b, a, m) {
      var f,
          c = "",
          p,
          e;

      if (!h(m)) {
        var x = arguments;
        m = {
          duration: x[2],
          easing: x[3],
          complete: x[4]
        };
      }

      P(m.duration) || (m.duration = 400);
      m.easing = "function" === typeof m.easing ? m.easing : Math[m.easing] || Math.easeInOutSine;
      m.curAnim = g(a);
      Y(a, function (x, F) {
        ba(b, F);
        e = new J(b, m, F);
        p = null;
        "d" === F ? (e.paths = e.initPath(b, b.d, a.d), e.toD = a.d, f = 0, p = 1) : b.attr ? f = b.attr(F) : (f = parseFloat(Z(b, F)) || 0, "opacity" !== F && (c = "px"));
        p || (p = x);
        p && p.match && p.match("px") && (p = p.replace(/px/g, ""));
        e.run(f, p, c);
      });
    },
        ja = d.seriesType = function (b, a, m, f, c) {
      var p = d.getOptions(),
          e = d.seriesTypes;
      p.plotOptions[b] = g(p.plotOptions[a], m);
      e[b] = z(e[a] || function () {}, f);
      e[b].prototype.type = b;
      c && (e[b].prototype.pointClass = z(d.Point, c));
      return e[b];
    },
        ea = d.uniqueKey = function () {
      var b = Math.random().toString(36).substring(2, 9),
          a = 0;
      return function () {
        return "highcharts-" + b + "-" + a++;
      };
    }(),
        ka = d.isFunction = function (b) {
      return "function" === typeof b;
    };

    A.jQuery && (A.jQuery.fn.highcharts = function () {
      var b = [].slice.call(arguments);
      if (this[0]) return b[0] ? (new d[t(b[0]) ? b.shift() : "Chart"](this[0], b[0], b[1]), this) : M[W(this[0], "data-highcharts-chart")];
    });
    return {
      Fx: J,
      addEvent: fa,
      animate: ia,
      animObject: U,
      arrayMax: C,
      arrayMin: b,
      attr: W,
      clamp: function (b, a, m) {
        return b > a ? b < m ? b : m : a;
      },
      clearTimeout: f,
      correctFloat: O,
      createElement: v,
      css: l,
      defined: c,
      destroyObjectProperties: x,
      discardElement: R,
      erase: e,
      error: G,
      extend: a,
      extendClass: z,
      find: F,
      fireEvent: ha,
      format: Q,
      getMagnitude: H,
      getNestedProperty: r,
      getStyle: Z,
      inArray: ca,
      isArray: D,
      isClass: q,
      isDOMElement: N,
      isFunction: ka,
      isNumber: P,
      isObject: h,
      isString: t,
      merge: g,
      normalizeTickInterval: K,
      numberFormat: T,
      objectEach: Y,
      offset: V,
      pad: w,
      pick: u,
      pInt: y,
      relativeLength: B,
      removeEvent: da,
      seriesType: ja,
      setAnimation: X,
      splat: k,
      stableSort: p,
      stop: ba,
      syncTimeout: n,
      timeUnits: m,
      uniqueKey: ea,
      wrap: L
    };
  });
  S(r, "parts/Color.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var W = g.isNumber,
        u = g.merge,
        r = g.pInt;

    g = function () {
      function d(g) {
        this.parsers = [{
          regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
          parse: function (d) {
            return [r(d[1]), r(d[2]), r(d[3]), parseFloat(d[4], 10)];
          }
        }, {
          regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
          parse: function (d) {
            return [r(d[1]), r(d[2]), r(d[3]), 1];
          }
        }];
        this.rgba = [];
        if (!(this instanceof d)) return new d(g);
        this.init(g);
      }

      d.parse = function (g) {
        return new d(g);
      };

      d.prototype.init = function (g) {
        var A, G;
        if ((this.input = g = d.names[g && g.toLowerCase ? g.toLowerCase() : ""] || g) && g.stops) this.stops = g.stops.map(function (t) {
          return new d(t[1]);
        });else {
          if (g && g.charAt && "#" === g.charAt()) {
            var u = g.length;
            g = parseInt(g.substr(1), 16);
            7 === u ? A = [(g & 16711680) >> 16, (g & 65280) >> 8, g & 255, 1] : 4 === u && (A = [(g & 3840) >> 4 | (g & 3840) >> 8, (g & 240) >> 4 | g & 240, (g & 15) << 4 | g & 15, 1]);
          }

          if (!A) for (G = this.parsers.length; G-- && !A;) {
            var y = this.parsers[G];
            (u = y.regex.exec(g)) && (A = y.parse(u));
          }
        }
        this.rgba = A || [];
      };

      d.prototype.get = function (d) {
        var g = this.input,
            G = this.rgba;

        if ("undefined" !== typeof this.stops) {
          var E = u(g);
          E.stops = [].concat(E.stops);
          this.stops.forEach(function (g, t) {
            E.stops[t] = [E.stops[t][0], g.get(d)];
          });
        } else E = G && W(G[0]) ? "rgb" === d || !d && 1 === G[3] ? "rgb(" + G[0] + "," + G[1] + "," + G[2] + ")" : "a" === d ? G[3] : "rgba(" + G.join(",") + ")" : g;

        return E;
      };

      d.prototype.brighten = function (d) {
        var g,
            u = this.rgba;
        if (this.stops) this.stops.forEach(function (g) {
          g.brighten(d);
        });else if (W(d) && 0 !== d) for (g = 0; 3 > g; g++) u[g] += r(255 * d), 0 > u[g] && (u[g] = 0), 255 < u[g] && (u[g] = 255);
        return this;
      };

      d.prototype.setOpacity = function (d) {
        this.rgba[3] = d;
        return this;
      };

      d.prototype.tweenTo = function (d, g) {
        var u = this.rgba,
            A = d.rgba;
        A.length && u && u.length ? (d = 1 !== A[3] || 1 !== u[3], g = (d ? "rgba(" : "rgb(") + Math.round(A[0] + (u[0] - A[0]) * (1 - g)) + "," + Math.round(A[1] + (u[1] - A[1]) * (1 - g)) + "," + Math.round(A[2] + (u[2] - A[2]) * (1 - g)) + (d ? "," + (A[3] + (u[3] - A[3]) * (1 - g)) : "") + ")") : g = d.input || "none";
        return g;
      };

      d.names = {
        white: "#ffffff",
        black: "#000000"
      };
      return d;
    }();

    d.Color = g;
    d.color = g.parse;
    return d.Color;
  });
  S(r, "parts/SvgRenderer.js", [r["parts/Globals.js"], r["parts/Color.js"], r["parts/Utilities.js"]], function (d, g, r) {
    var u = g.parse,
        I = r.addEvent,
        M = r.animate,
        E = r.animObject,
        A = r.attr,
        G = r.createElement,
        J = r.css,
        y = r.defined,
        t = r.destroyObjectProperties,
        D = r.erase,
        h = r.extend,
        N = r.inArray,
        q = r.isArray,
        P = r.isNumber,
        e = r.isObject,
        c = r.isString,
        k = r.merge,
        n = r.objectEach,
        f = r.pick,
        a = r.pInt,
        l = r.removeEvent,
        v = r.splat,
        z = r.stop,
        w = r.uniqueKey,
        B = d.charts,
        L = d.deg2rad,
        Q = d.doc,
        H = d.hasTouch,
        K = d.isFirefox,
        p = d.isMS,
        b = d.isWebKit,
        C = d.noop,
        x = d.svg,
        R = d.SVG_NS,
        O = d.symbolSizes,
        X = d.win;

    var U = d.SVGElement = function () {
      return this;
    };

    h(U.prototype, {
      opacity: 1,
      SVG_NS: R,
      textProps: "direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline cursor".split(" "),
      init: function (b, a) {
        this.element = "span" === a ? G(a) : Q.createElementNS(this.SVG_NS, a);
        this.renderer = b;
        d.fireEvent(this, "afterInit");
      },
      animate: function (b, a, c) {
        var m = E(f(a, this.renderer.globalAnimation, !0));
        f(Q.hidden, Q.msHidden, Q.webkitHidden, !1) && (m.duration = 0);
        0 !== m.duration ? (c && (m.complete = c), M(this, b, m)) : (this.attr(b, void 0, c), n(b, function (b, a) {
          m.step && m.step.call(this, b, {
            prop: a,
            pos: 1
          });
        }, this));
        return this;
      },
      complexColor: function (b, a, f) {
        var m = this.renderer,
            c,
            p,
            e,
            x,
            T,
            C,
            l,
            v,
            z,
            Z,
            O,
            R = [],
            B;
        d.fireEvent(this.renderer, "complexColor", {
          args: arguments
        }, function () {
          b.radialGradient ? p = "radialGradient" : b.linearGradient && (p = "linearGradient");
          p && (e = b[p], T = m.gradients, l = b.stops, Z = f.radialReference, q(e) && (b[p] = e = {
            x1: e[0],
            y1: e[1],
            x2: e[2],
            y2: e[3],
            gradientUnits: "userSpaceOnUse"
          }), "radialGradient" === p && Z && !y(e.gradientUnits) && (x = e, e = k(e, m.getRadialAttr(Z, x), {
            gradientUnits: "userSpaceOnUse"
          })), n(e, function (b, a) {
            "id" !== a && R.push(a, b);
          }), n(l, function (b) {
            R.push(b);
          }), R = R.join(","), T[R] ? O = T[R].attr("id") : (e.id = O = w(), T[R] = C = m.createElement(p).attr(e).add(m.defs), C.radAttr = x, C.stops = [], l.forEach(function (b) {
            0 === b[1].indexOf("rgba") ? (c = u(b[1]), v = c.get("rgb"), z = c.get("a")) : (v = b[1], z = 1);
            b = m.createElement("stop").attr({
              offset: b[0],
              "stop-color": v,
              "stop-opacity": z
            }).add(C);
            C.stops.push(b);
          })), B = "url(" + m.url + "#" + O + ")", f.setAttribute(a, B), f.gradient = R, b.toString = function () {
            return B;
          });
        });
      },
      applyTextOutline: function (b) {
        var a = this.element,
            m;
        -1 !== b.indexOf("contrast") && (b = b.replace(/contrast/g, this.renderer.getContrast(a.style.fill)));
        b = b.split(" ");
        var f = b[b.length - 1];

        if ((m = b[0]) && "none" !== m && d.svg) {
          this.fakeTS = !0;
          b = [].slice.call(a.getElementsByTagName("tspan"));
          this.ySetter = this.xSetter;
          m = m.replace(/(^[\d\.]+)(.*?)$/g, function (b, a, m) {
            return 2 * a + m;
          });
          this.removeTextOutline(b);
          var c = a.textContent ? /^[\u0591-\u065F\u066A-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC]/.test(a.textContent) : !1;
          var p = a.firstChild;
          b.forEach(function (b, e) {
            0 === e && (b.setAttribute("x", a.getAttribute("x")), e = a.getAttribute("y"), b.setAttribute("y", e || 0), null === e && a.setAttribute("y", 0));
            e = b.cloneNode(!0);
            A(c && !K ? b : e, {
              "class": "highcharts-text-outline",
              fill: f,
              stroke: f,
              "stroke-width": m,
              "stroke-linejoin": "round"
            });
            a.insertBefore(e, p);
          });
          c && K && b[0] && (b = b[0].cloneNode(!0), b.textContent = " ", a.insertBefore(b, p));
        }
      },
      removeTextOutline: function (b) {
        for (var a = b.length, m; a--;) m = b[a], "highcharts-text-outline" === m.getAttribute("class") && D(b, this.element.removeChild(m));
      },
      symbolCustomAttribs: "x y width height r start end innerR anchorX anchorY rounded".split(" "),
      attr: function (b, a, f, c) {
        var m = this.element,
            p,
            e = this,
            x,
            C,
            l = this.symbolCustomAttribs;

        if ("string" === typeof b && "undefined" !== typeof a) {
          var T = b;
          b = {};
          b[T] = a;
        }

        "string" === typeof b ? e = (this[b + "Getter"] || this._defaultGetter).call(this, b, m) : (n(b, function (a, f) {
          x = !1;
          c || z(this, f);
          this.symbolName && -1 !== N(f, l) && (p || (this.symbolAttr(b), p = !0), x = !0);
          !this.rotation || "x" !== f && "y" !== f || (this.doTransform = !0);
          x || (C = this[f + "Setter"] || this._defaultSetter, C.call(this, a, f, m), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(f) && this.updateShadows(f, a, C));
        }, this), this.afterSetters());
        f && f.call(this);
        return e;
      },
      afterSetters: function () {
        this.doTransform && (this.updateTransform(), this.doTransform = !1);
      },
      updateShadows: function (b, a, f) {
        for (var m = this.shadows, c = m.length; c--;) f.call(m[c], "height" === b ? Math.max(a - (m[c].cutHeight || 0), 0) : "d" === b ? this.d : a, b, m[c]);
      },
      addClass: function (b, a) {
        var m = a ? "" : this.attr("class") || "";
        b = (b || "").split(/ /g).reduce(function (b, a) {
          -1 === m.indexOf(a) && b.push(a);
          return b;
        }, m ? [m] : []).join(" ");
        b !== m && this.attr("class", b);
        return this;
      },
      hasClass: function (b) {
        return -1 !== (this.attr("class") || "").split(" ").indexOf(b);
      },
      removeClass: function (b) {
        return this.attr("class", (this.attr("class") || "").replace(c(b) ? new RegExp(" ?" + b + " ?") : b, ""));
      },
      symbolAttr: function (b) {
        var a = this;
        "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (m) {
          a[m] = f(b[m], a[m]);
        });
        a.attr({
          d: a.renderer.symbols[a.symbolName](a.x, a.y, a.width, a.height, a)
        });
      },
      clip: function (b) {
        return this.attr("clip-path", b ? "url(" + this.renderer.url + "#" + b.id + ")" : "none");
      },
      crisp: function (b, a) {
        a = a || b.strokeWidth || 0;
        var m = Math.round(a) % 2 / 2;
        b.x = Math.floor(b.x || this.x || 0) + m;
        b.y = Math.floor(b.y || this.y || 0) + m;
        b.width = Math.floor((b.width || this.width || 0) - 2 * m);
        b.height = Math.floor((b.height || this.height || 0) - 2 * m);
        y(b.strokeWidth) && (b.strokeWidth = a);
        return b;
      },
      css: function (b) {
        var m = this.styles,
            f = {},
            c = this.element,
            p = "",
            e = !m,
            C = ["textOutline", "textOverflow", "width"];
        b && b.color && (b.fill = b.color);
        m && n(b, function (b, a) {
          b !== m[a] && (f[a] = b, e = !0);
        });

        if (e) {
          m && (b = h(m, f));
          if (b) if (null === b.width || "auto" === b.width) delete this.textWidth;else if ("text" === c.nodeName.toLowerCase() && b.width) var l = this.textWidth = a(b.width);
          this.styles = b;
          l && !x && this.renderer.forExport && delete b.width;

          if (c.namespaceURI === this.SVG_NS) {
            var k = function (b, a) {
              return "-" + a.toLowerCase();
            };

            n(b, function (b, a) {
              -1 === C.indexOf(a) && (p += a.replace(/([A-Z])/g, k) + ":" + b + ";");
            });
            p && A(c, "style", p);
          } else J(c, b);

          this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), b && b.textOutline && this.applyTextOutline(b.textOutline));
        }

        return this;
      },
      getStyle: function (b) {
        return X.getComputedStyle(this.element || this, "").getPropertyValue(b);
      },
      strokeWidth: function () {
        if (!this.renderer.styledMode) return this["stroke-width"] || 0;
        var b = this.getStyle("stroke-width"),
            f = 0;
        if (b.indexOf("px") === b.length - 2) f = a(b);else if ("" !== b) {
          var c = Q.createElementNS(R, "rect");
          A(c, {
            width: b,
            "stroke-width": 0
          });
          this.element.parentNode.appendChild(c);
          f = c.getBBox().width;
          c.parentNode.removeChild(c);
        }
        return f;
      },
      on: function (b, a) {
        var m,
            f,
            c = this.element,
            p;
        H && "click" === b ? (c.ontouchstart = function (b) {
          m = b.touches[0].clientX;
          f = b.touches[0].clientY;
        }, c.ontouchend = function (b) {
          m && 4 <= Math.sqrt(Math.pow(m - b.changedTouches[0].clientX, 2) + Math.pow(f - b.changedTouches[0].clientY, 2)) || a.call(c, b);
          p = !0;
          b.preventDefault();
        }, c.onclick = function (b) {
          p || a.call(c, b);
        }) : c["on" + b] = a;
        return this;
      },
      setRadialReference: function (b) {
        var a = this.renderer.gradients[this.element.gradient];
        this.element.radialReference = b;
        a && a.radAttr && a.animate(this.renderer.getRadialAttr(b, a.radAttr));
        return this;
      },
      translate: function (b, a) {
        return this.attr({
          translateX: b,
          translateY: a
        });
      },
      invert: function (b) {
        this.inverted = b;
        this.updateTransform();
        return this;
      },
      updateTransform: function () {
        var b = this.translateX || 0,
            a = this.translateY || 0,
            c = this.scaleX,
            p = this.scaleY,
            e = this.inverted,
            x = this.rotation,
            C = this.matrix,
            l = this.element;
        e && (b += this.width, a += this.height);
        b = ["translate(" + b + "," + a + ")"];
        y(C) && b.push("matrix(" + C.join(",") + ")");
        e ? b.push("rotate(90) scale(-1,1)") : x && b.push("rotate(" + x + " " + f(this.rotationOriginX, l.getAttribute("x"), 0) + " " + f(this.rotationOriginY, l.getAttribute("y") || 0) + ")");
        (y(c) || y(p)) && b.push("scale(" + f(c, 1) + " " + f(p, 1) + ")");
        b.length && l.setAttribute("transform", b.join(" "));
      },
      toFront: function () {
        var b = this.element;
        b.parentNode.appendChild(b);
        return this;
      },
      align: function (b, a, p) {
        var m,
            e = {};
        var x = this.renderer;
        var C = x.alignedObjects;
        var l, k;

        if (b) {
          if (this.alignOptions = b, this.alignByTranslate = a, !p || c(p)) this.alignTo = m = p || "renderer", D(C, this), C.push(this), p = null;
        } else b = this.alignOptions, a = this.alignByTranslate, m = this.alignTo;

        p = f(p, x[m], x);
        m = b.align;
        x = b.verticalAlign;
        C = (p.x || 0) + (b.x || 0);
        var T = (p.y || 0) + (b.y || 0);
        "right" === m ? l = 1 : "center" === m && (l = 2);
        l && (C += (p.width - (b.width || 0)) / l);
        e[a ? "translateX" : "x"] = Math.round(C);
        "bottom" === x ? k = 1 : "middle" === x && (k = 2);
        k && (T += (p.height - (b.height || 0)) / k);
        e[a ? "translateY" : "y"] = Math.round(T);
        this[this.placed ? "animate" : "attr"](e);
        this.placed = !0;
        this.alignAttr = e;
        return this;
      },
      getBBox: function (b, a) {
        var m,
            c = this.renderer,
            p = this.element,
            e = this.styles,
            x = this.textStr,
            C,
            l = c.cache,
            k = c.cacheKeys,
            T = p.namespaceURI === this.SVG_NS;
        a = f(a, this.rotation, 0);
        var n = c.styledMode ? p && U.prototype.getStyle.call(p, "font-size") : e && e.fontSize;

        if (y(x)) {
          var v = x.toString();
          -1 === v.indexOf("<") && (v = v.replace(/[0-9]/g, "0"));
          v += ["", a, n, this.textWidth, e && e.textOverflow].join();
        }

        v && !b && (m = l[v]);

        if (!m) {
          if (T || c.forExport) {
            try {
              (C = this.fakeTS && function (b) {
                [].forEach.call(p.querySelectorAll(".highcharts-text-outline"), function (a) {
                  a.style.display = b;
                });
              }) && C("none"), m = p.getBBox ? h({}, p.getBBox()) : {
                width: p.offsetWidth,
                height: p.offsetHeight
              }, C && C("");
            } catch (ea) {
              "";
            }

            if (!m || 0 > m.width) m = {
              width: 0,
              height: 0
            };
          } else m = this.htmlGetBBox();

          c.isSVG && (b = m.width, c = m.height, T && (m.height = c = {
            "11px,17": 14,
            "13px,20": 16
          }[e && e.fontSize + "," + Math.round(c)] || c), a && (e = a * L, m.width = Math.abs(c * Math.sin(e)) + Math.abs(b * Math.cos(e)), m.height = Math.abs(c * Math.cos(e)) + Math.abs(b * Math.sin(e))));

          if (v && 0 < m.height) {
            for (; 250 < k.length;) delete l[k.shift()];

            l[v] || k.push(v);
            l[v] = m;
          }
        }

        return m;
      },
      show: function (b) {
        return this.attr({
          visibility: b ? "inherit" : "visible"
        });
      },
      hide: function (b) {
        b ? this.attr({
          y: -9999
        }) : this.attr({
          visibility: "hidden"
        });
        return this;
      },
      fadeOut: function (b) {
        var a = this;
        a.animate({
          opacity: 0
        }, {
          duration: b || 150,
          complete: function () {
            a.attr({
              y: -9999
            });
          }
        });
      },
      add: function (b) {
        var a = this.renderer,
            m = this.element;
        b && (this.parentGroup = b);
        this.parentInverted = b && b.inverted;
        "undefined" !== typeof this.textStr && a.buildText(this);
        this.added = !0;
        if (!b || b.handleZ || this.zIndex) var f = this.zIndexSetter();
        f || (b ? b.element : a.box).appendChild(m);
        if (this.onAdd) this.onAdd();
        return this;
      },
      safeRemoveChild: function (b) {
        var a = b.parentNode;
        a && a.removeChild(b);
      },
      destroy: function () {
        var b = this,
            a = b.element || {},
            f = b.renderer,
            c = f.isSVG && "SPAN" === a.nodeName && b.parentGroup,
            p = a.ownerSVGElement,
            e = b.clipPath;
        a.onclick = a.onmouseout = a.onmouseover = a.onmousemove = a.point = null;
        z(b);
        e && p && ([].forEach.call(p.querySelectorAll("[clip-path],[CLIP-PATH]"), function (b) {
          -1 < b.getAttribute("clip-path").indexOf(e.element.id) && b.removeAttribute("clip-path");
        }), b.clipPath = e.destroy());

        if (b.stops) {
          for (p = 0; p < b.stops.length; p++) b.stops[p] = b.stops[p].destroy();

          b.stops = null;
        }

        b.safeRemoveChild(a);

        for (f.styledMode || b.destroyShadows(); c && c.div && 0 === c.div.childNodes.length;) a = c.parentGroup, b.safeRemoveChild(c.div), delete c.div, c = a;

        b.alignTo && D(f.alignedObjects, b);
        n(b, function (a, m) {
          b[m] && b[m].parentGroup === b && b[m].destroy && b[m].destroy();
          delete b[m];
        });
      },
      shadow: function (b, a, c) {
        var m = [],
            p,
            e = this.element;
        if (!b) this.destroyShadows();else if (!this.shadows) {
          var x = f(b.width, 3);
          var C = (b.opacity || .15) / x;
          var l = this.parentInverted ? "(-1,-1)" : "(" + f(b.offsetX, 1) + ", " + f(b.offsetY, 1) + ")";

          for (p = 1; p <= x; p++) {
            var k = e.cloneNode(0);
            var n = 2 * x + 1 - 2 * p;
            A(k, {
              stroke: b.color || "#000000",
              "stroke-opacity": C * p,
              "stroke-width": n,
              transform: "translate" + l,
              fill: "none"
            });
            k.setAttribute("class", (k.getAttribute("class") || "") + " highcharts-shadow");
            c && (A(k, "height", Math.max(A(k, "height") - n, 0)), k.cutHeight = n);
            a ? a.element.appendChild(k) : e.parentNode && e.parentNode.insertBefore(k, e);
            m.push(k);
          }

          this.shadows = m;
        }
        return this;
      },
      destroyShadows: function () {
        (this.shadows || []).forEach(function (b) {
          this.safeRemoveChild(b);
        }, this);
        this.shadows = void 0;
      },
      xGetter: function (b) {
        "circle" === this.element.nodeName && ("x" === b ? b = "cx" : "y" === b && (b = "cy"));
        return this._defaultGetter(b);
      },
      _defaultGetter: function (b) {
        b = f(this[b + "Value"], this[b], this.element ? this.element.getAttribute(b) : null, 0);
        /^[\-0-9\.]+$/.test(b) && (b = parseFloat(b));
        return b;
      },
      dSetter: function (b, a, f) {
        b && b.join && (b = b.join(" "));
        /(NaN| {2}|^$)/.test(b) && (b = "M 0 0");
        this[a] !== b && (f.setAttribute(a, b), this[a] = b);
      },
      dashstyleSetter: function (b) {
        var f,
            c = this["stroke-width"];
        "inherit" === c && (c = 1);

        if (b = b && b.toLowerCase()) {
          b = b.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");

          for (f = b.length; f--;) b[f] = a(b[f]) * c;

          b = b.join(",").replace(/NaN/g, "none");
          this.element.setAttribute("stroke-dasharray", b);
        }
      },
      alignSetter: function (b) {
        var a = {
          left: "start",
          center: "middle",
          right: "end"
        };
        a[b] && (this.alignValue = b, this.element.setAttribute("text-anchor", a[b]));
      },
      opacitySetter: function (b, a, f) {
        this[a] = b;
        f.setAttribute(a, b);
      },
      titleSetter: function (b) {
        var a = this.element.getElementsByTagName("title")[0];
        a || (a = Q.createElementNS(this.SVG_NS, "title"), this.element.appendChild(a));
        a.firstChild && a.removeChild(a.firstChild);
        a.appendChild(Q.createTextNode(String(f(b, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">")));
      },
      textSetter: function (b) {
        b !== this.textStr && (delete this.bBox, delete this.textPxLength, this.textStr = b, this.added && this.renderer.buildText(this));
      },
      setTextPath: function (b, a) {
        var f = this.element,
            c = {
          textAnchor: "text-anchor"
        },
            m = !1,
            p = this.textPathWrapper,
            e = !p;
        a = k(!0, {
          enabled: !0,
          attributes: {
            dy: -5,
            startOffset: "50%",
            textAnchor: "middle"
          }
        }, a);
        var x = a.attributes;

        if (b && a && a.enabled) {
          p && null === p.element.parentNode ? (e = !0, p = p.destroy()) : p && this.removeTextOutline.call(p.parentGroup, [].slice.call(f.getElementsByTagName("tspan")));
          this.options && this.options.padding && (x.dx = -this.options.padding);
          p || (this.textPathWrapper = p = this.renderer.createElement("textPath"), m = !0);
          var l = p.element;
          (a = b.element.getAttribute("id")) || b.element.setAttribute("id", a = w());
          if (e) for (b = f.getElementsByTagName("tspan"); b.length;) b[0].setAttribute("y", 0), P(x.dx) && b[0].setAttribute("x", -x.dx), l.appendChild(b[0]);
          m && p.add({
            element: this.text ? this.text.element : f
          });
          l.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + a);
          y(x.dy) && (l.parentNode.setAttribute("dy", x.dy), delete x.dy);
          y(x.dx) && (l.parentNode.setAttribute("dx", x.dx), delete x.dx);
          n(x, function (b, a) {
            l.setAttribute(c[a] || a, b);
          });
          f.removeAttribute("transform");
          this.removeTextOutline.call(p, [].slice.call(f.getElementsByTagName("tspan")));
          this.text && !this.renderer.styledMode && this.attr({
            fill: "none",
            "stroke-width": 0
          });
          this.applyTextOutline = this.updateTransform = C;
        } else p && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(f, b), this.updateTransform(), this.options.rotation && this.applyTextOutline(this.options.style.textOutline));

        return this;
      },
      destroyTextPath: function (b, a) {
        var f = b.getElementsByTagName("text")[0];

        if (f) {
          if (f.removeAttribute("dx"), f.removeAttribute("dy"), a.element.setAttribute("id", ""), f.getElementsByTagName("textPath").length) {
            for (b = this.textPathWrapper.element.childNodes; b.length;) f.appendChild(b[0]);

            f.removeChild(this.textPathWrapper.element);
          }
        } else if (b.getAttribute("dx") || b.getAttribute("dy")) b.removeAttribute("dx"), b.removeAttribute("dy");

        this.textPathWrapper = this.textPathWrapper.destroy();
      },
      fillSetter: function (b, a, f) {
        "string" === typeof b ? f.setAttribute(a, b) : b && this.complexColor(b, a, f);
      },
      visibilitySetter: function (b, a, f) {
        "inherit" === b ? f.removeAttribute(a) : this[a] !== b && f.setAttribute(a, b);
        this[a] = b;
      },
      zIndexSetter: function (b, f) {
        var c = this.renderer,
            m = this.parentGroup,
            p = (m || c).element || c.box,
            e = this.element,
            x = !1;
        c = p === c.box;
        var C = this.added;
        var l;
        y(b) ? (e.setAttribute("data-z-index", b), b = +b, this[f] === b && (C = !1)) : y(this[f]) && e.removeAttribute("data-z-index");
        this[f] = b;

        if (C) {
          (b = this.zIndex) && m && (m.handleZ = !0);
          f = p.childNodes;

          for (l = f.length - 1; 0 <= l && !x; l--) {
            m = f[l];
            C = m.getAttribute("data-z-index");
            var k = !y(C);
            if (m !== e) if (0 > b && k && !c && !l) p.insertBefore(e, f[l]), x = !0;else if (a(C) <= b || k && (!y(b) || 0 <= b)) p.insertBefore(e, f[l + 1] || null), x = !0;
          }

          x || (p.insertBefore(e, f[c ? 3 : 0] || null), x = !0);
        }

        return x;
      },
      _defaultSetter: function (b, a, f) {
        f.setAttribute(a, b);
      }
    });
    U.prototype.yGetter = U.prototype.xGetter;

    U.prototype.translateXSetter = U.prototype.translateYSetter = U.prototype.rotationSetter = U.prototype.verticalAlignSetter = U.prototype.rotationOriginXSetter = U.prototype.rotationOriginYSetter = U.prototype.scaleXSetter = U.prototype.scaleYSetter = U.prototype.matrixSetter = function (b, a) {
      this[a] = b;
      this.doTransform = !0;
    };

    U.prototype["stroke-widthSetter"] = U.prototype.strokeSetter = function (b, a, f) {
      this[a] = b;
      this.stroke && this["stroke-width"] ? (U.prototype.fillSetter.call(this, this.stroke, "stroke", f), f.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === a && 0 === b && this.hasStroke ? (f.removeAttribute("stroke"), this.hasStroke = !1) : this.renderer.styledMode && this["stroke-width"] && (f.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0);
    };

    g = d.SVGRenderer = function () {
      this.init.apply(this, arguments);
    };

    h(g.prototype, {
      Element: U,
      SVG_NS: R,
      init: function (a, f, c, p, e, x, C) {
        var m = this.createElement("svg").attr({
          version: "1.1",
          "class": "highcharts-root"
        });
        C || m.css(this.getStyle(p));
        p = m.element;
        a.appendChild(p);
        A(a, "dir", "ltr");
        -1 === a.innerHTML.indexOf("xmlns") && A(p, "xmlns", this.SVG_NS);
        this.isSVG = !0;
        this.box = p;
        this.boxWrapper = m;
        this.alignedObjects = [];
        this.url = (K || b) && Q.getElementsByTagName("base").length ? X.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "";
        this.createElement("desc").add().element.appendChild(Q.createTextNode("Created with Highcharts 8.0.4"));
        this.defs = this.createElement("defs").add();
        this.allowHTML = x;
        this.forExport = e;
        this.styledMode = C;
        this.gradients = {};
        this.cache = {};
        this.cacheKeys = [];
        this.imgCount = 0;
        this.setSize(f, c, !1);
        var l;
        K && a.getBoundingClientRect && (f = function () {
          J(a, {
            left: 0,
            top: 0
          });
          l = a.getBoundingClientRect();
          J(a, {
            left: Math.ceil(l.left) - l.left + "px",
            top: Math.ceil(l.top) - l.top + "px"
          });
        }, f(), this.unSubPixelFix = I(X, "resize", f));
      },
      definition: function (b) {
        function a(b, c) {
          var p;
          v(b).forEach(function (b) {
            var m = f.createElement(b.tagName),
                e = {};
            n(b, function (b, a) {
              "tagName" !== a && "children" !== a && "textContent" !== a && (e[a] = b);
            });
            m.attr(e);
            m.add(c || f.defs);
            b.textContent && m.element.appendChild(Q.createTextNode(b.textContent));
            a(b.children || [], m);
            p = m;
          });
          return p;
        }

        var f = this;
        return a(b);
      },
      getStyle: function (b) {
        return this.style = h({
          fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
          fontSize: "12px"
        }, b);
      },
      setStyle: function (b) {
        this.boxWrapper.css(this.getStyle(b));
      },
      isHidden: function () {
        return !this.boxWrapper.getBBox().width;
      },
      destroy: function () {
        var b = this.defs;
        this.box = null;
        this.boxWrapper = this.boxWrapper.destroy();
        t(this.gradients || {});
        this.gradients = null;
        b && (this.defs = b.destroy());
        this.unSubPixelFix && this.unSubPixelFix();
        return this.alignedObjects = null;
      },
      createElement: function (b) {
        var a = new this.Element();
        a.init(this, b);
        return a;
      },
      draw: C,
      getRadialAttr: function (b, a) {
        return {
          cx: b[0] - b[2] / 2 + a.cx * b[2],
          cy: b[1] - b[2] / 2 + a.cy * b[2],
          r: a.r * b[2]
        };
      },
      truncate: function (b, a, f, c, p, e, x) {
        var m = this,
            C = b.rotation,
            l,
            k = c ? 1 : 0,
            F = (f || c).length,
            n = F,
            v = [],
            w = function (b) {
          a.firstChild && a.removeChild(a.firstChild);
          b && a.appendChild(Q.createTextNode(b));
        },
            z = function (e, l) {
          l = l || e;
          if ("undefined" === typeof v[l]) if (a.getSubStringLength) try {
            v[l] = p + a.getSubStringLength(0, c ? l + 1 : l);
          } catch (la) {
            "";
          } else m.getSpanWidth && (w(x(f || c, e)), v[l] = p + m.getSpanWidth(b, a));
          return v[l];
        },
            O;

        b.rotation = 0;
        var T = z(a.textContent.length);

        if (O = p + T > e) {
          for (; k <= F;) n = Math.ceil((k + F) / 2), c && (l = x(c, n)), T = z(n, l && l.length - 1), k === F ? k = F + 1 : T > e ? F = n - 1 : k = n;

          0 === F ? w("") : f && F === f.length - 1 || w(l || x(f || c, n));
        }

        c && c.splice(0, n);
        b.actualWidth = T;
        b.rotation = C;
        return O;
      },
      escapes: {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "'": "&#39;",
        '"': "&quot;"
      },
      buildText: function (b) {
        var c = b.element,
            p = this,
            e = p.forExport,
            m = f(b.textStr, "").toString(),
            l = -1 !== m.indexOf("<"),
            C = c.childNodes,
            k,
            v = A(c, "x"),
            w = b.styles,
            z = b.textWidth,
            O = w && w.lineHeight,
            q = w && w.textOutline,
            B = w && "ellipsis" === w.textOverflow,
            d = w && "nowrap" === w.whiteSpace,
            N = w && w.fontSize,
            X,
            h = C.length;
        w = z && !b.added && this.box;

        var L = function (b) {
          var f;
          p.styledMode || (f = /(px|em)$/.test(b && b.style.fontSize) ? b.style.fontSize : N || p.style.fontSize || 12);
          return O ? a(O) : p.fontMetrics(f, b.getAttribute("style") ? b : c).h;
        },
            t = function (b, a) {
          n(p.escapes, function (f, c) {
            a && -1 !== a.indexOf(f) || (b = b.toString().replace(new RegExp(f, "g"), c));
          });
          return b;
        },
            U = function (b, a) {
          var f = b.indexOf("<");
          b = b.substring(f, b.indexOf(">") - f);
          f = b.indexOf(a + "=");
          if (-1 !== f && (f = f + a.length + 1, a = b.charAt(f), '"' === a || "'" === a)) return b = b.substring(f + 1), b.substring(0, b.indexOf(a));
        },
            P = /<br.*?>/g;

        var g = [m, B, d, O, q, N, z].join();

        if (g !== b.textCache) {
          for (b.textCache = g; h--;) c.removeChild(C[h]);

          l || q || B || z || -1 !== m.indexOf(" ") && (!d || P.test(m)) ? (w && w.appendChild(c), l ? (m = p.styledMode ? m.replace(/<(b|strong)>/g, '<span class="highcharts-strong">').replace(/<(i|em)>/g, '<span class="highcharts-emphasized">') : m.replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">'), m = m.replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(P)) : m = [m], m = m.filter(function (b) {
            return "" !== b;
          }), m.forEach(function (a, f) {
            var m = 0,
                l = 0;
            a = a.replace(/^\s+|\s+$/g, "").replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||");
            var C = a.split("|||");
            C.forEach(function (a) {
              if ("" !== a || 1 === C.length) {
                var n = {},
                    F = Q.createElementNS(p.SVG_NS, "tspan"),
                    w,
                    O;
                (w = U(a, "class")) && A(F, "class", w);
                if (w = U(a, "style")) w = w.replace(/(;| |^)color([ :])/, "$1fill$2"), A(F, "style", w);
                (O = U(a, "href")) && !e && (A(F, "onclick", 'location.href="' + O + '"'), A(F, "class", "highcharts-anchor"), p.styledMode || J(F, {
                  cursor: "pointer"
                }));
                a = t(a.replace(/<[a-zA-Z\/](.|\n)*?>/g, "") || " ");

                if (" " !== a) {
                  F.appendChild(Q.createTextNode(a));
                  m ? n.dx = 0 : f && null !== v && (n.x = v);
                  A(F, n);
                  c.appendChild(F);
                  !m && X && (!x && e && J(F, {
                    display: "block"
                  }), A(F, "dy", L(F)));

                  if (z) {
                    var q = a.replace(/([^\^])-/g, "$1- ").split(" ");
                    n = !d && (1 < C.length || f || 1 < q.length);
                    O = 0;
                    var T = L(F);
                    if (B) k = p.truncate(b, F, a, void 0, 0, Math.max(0, z - parseInt(N || 12, 10)), function (b, a) {
                      return b.substring(0, a) + "\u2026";
                    });else if (n) for (; q.length;) q.length && !d && 0 < O && (F = Q.createElementNS(R, "tspan"), A(F, {
                      dy: T,
                      x: v
                    }), w && A(F, "style", w), F.appendChild(Q.createTextNode(q.join(" ").replace(/- /g, "-"))), c.appendChild(F)), p.truncate(b, F, null, q, 0 === O ? l : 0, z, function (b, a) {
                      return q.slice(0, a).join(" ").replace(/- /g, "-");
                    }), l = b.actualWidth, O++;
                  }

                  m++;
                }
              }
            });
            X = X || c.childNodes.length;
          }), B && k && b.attr("title", t(b.textStr, ["&lt;", "&gt;"])), w && w.removeChild(c), q && b.applyTextOutline && b.applyTextOutline(q)) : c.appendChild(Q.createTextNode(t(m)));
        }
      },
      getContrast: function (b) {
        b = u(b).rgba;
        b[0] *= 1;
        b[1] *= 1.2;
        b[2] *= .5;
        return 459 < b[0] + b[1] + b[2] ? "#000000" : "#FFFFFF";
      },
      button: function (b, a, f, c, e, x, l, C, n, w) {
        var m = this.label(b, a, f, n, null, null, w, null, "button"),
            F = 0,
            v = this.styledMode;
        m.attr(k({
          padding: 8,
          r: 2
        }, e));

        if (!v) {
          e = k({
            fill: "#f7f7f7",
            stroke: "#cccccc",
            "stroke-width": 1,
            style: {
              color: "#333333",
              cursor: "pointer",
              fontWeight: "normal"
            }
          }, e);
          var z = e.style;
          delete e.style;
          x = k(e, {
            fill: "#e6e6e6"
          }, x);
          var O = x.style;
          delete x.style;
          l = k(e, {
            fill: "#e6ebf5",
            style: {
              color: "#000000",
              fontWeight: "bold"
            }
          }, l);
          var q = l.style;
          delete l.style;
          C = k(e, {
            style: {
              color: "#cccccc"
            }
          }, C);
          var R = C.style;
          delete C.style;
        }

        I(m.element, p ? "mouseover" : "mouseenter", function () {
          3 !== F && m.setState(1);
        });
        I(m.element, p ? "mouseout" : "mouseleave", function () {
          3 !== F && m.setState(F);
        });

        m.setState = function (b) {
          1 !== b && (m.state = F = b);
          m.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][b || 0]);
          v || m.attr([e, x, l, C][b || 0]).css([z, O, q, R][b || 0]);
        };

        v || m.attr(e).css(h({
          cursor: "default"
        }, z));
        return m.on("click", function (b) {
          3 !== F && c.call(m, b);
        });
      },
      crispLine: function (b, a) {
        b[1] === b[4] && (b[1] = b[4] = Math.round(b[1]) - a % 2 / 2);
        b[2] === b[5] && (b[2] = b[5] = Math.round(b[2]) + a % 2 / 2);
        return b;
      },
      path: function (b) {
        var a = this.styledMode ? {} : {
          fill: "none"
        };
        q(b) ? a.d = b : e(b) && h(a, b);
        return this.createElement("path").attr(a);
      },
      circle: function (b, a, f) {
        b = e(b) ? b : "undefined" === typeof b ? {} : {
          x: b,
          y: a,
          r: f
        };
        a = this.createElement("circle");

        a.xSetter = a.ySetter = function (b, a, f) {
          f.setAttribute("c" + a, b);
        };

        return a.attr(b);
      },
      arc: function (b, a, f, c, p, x) {
        e(b) ? (c = b, a = c.y, f = c.r, b = c.x) : c = {
          innerR: c,
          start: p,
          end: x
        };
        b = this.symbol("arc", b, a, f, f, c);
        b.r = f;
        return b;
      },
      rect: function (b, a, f, c, p, x) {
        p = e(b) ? b.r : p;
        var m = this.createElement("rect");
        b = e(b) ? b : "undefined" === typeof b ? {} : {
          x: b,
          y: a,
          width: Math.max(f, 0),
          height: Math.max(c, 0)
        };
        this.styledMode || ("undefined" !== typeof x && (b.strokeWidth = x, b = m.crisp(b)), b.fill = "none");
        p && (b.r = p);

        m.rSetter = function (b, a, f) {
          m.r = b;
          A(f, {
            rx: b,
            ry: b
          });
        };

        m.rGetter = function () {
          return m.r;
        };

        return m.attr(b);
      },
      setSize: function (b, a, c) {
        var p = this.alignedObjects,
            e = p.length;
        this.width = b;
        this.height = a;

        for (this.boxWrapper.animate({
          width: b,
          height: a
        }, {
          step: function () {
            this.attr({
              viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
            });
          },
          duration: f(c, !0) ? void 0 : 0
        }); e--;) p[e].align();
      },
      g: function (b) {
        var a = this.createElement("g");
        return b ? a.attr({
          "class": "highcharts-" + b
        }) : a;
      },
      image: function (b, a, f, c, p, e) {
        var x = {
          preserveAspectRatio: "none"
        },
            m = function (b, a) {
          b.setAttributeNS ? b.setAttributeNS("http://www.w3.org/1999/xlink", "href", a) : b.setAttribute("hc-svg-href", a);
        },
            l = function (a) {
          m(C.element, b);
          e.call(C, a);
        };

        1 < arguments.length && h(x, {
          x: a,
          y: f,
          width: c,
          height: p
        });
        var C = this.createElement("image").attr(x);
        e ? (m(C.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), x = new X.Image(), I(x, "load", l), x.src = b, x.complete && l({})) : m(C.element, b);
        return C;
      },
      symbol: function (b, a, c, p, e, x) {
        var m = this,
            l = /^url\((.*?)\)$/,
            C = l.test(b),
            k = !C && (this.symbols[b] ? b : "circle"),
            n = k && this.symbols[k],
            F = y(a) && n && n.call(this.symbols, Math.round(a), Math.round(c), p, e, x);

        if (n) {
          var w = this.path(F);
          m.styledMode || w.attr("fill", "none");
          h(w, {
            symbolName: k,
            x: a,
            y: c,
            width: p,
            height: e
          });
          x && h(w, x);
        } else if (C) {
          var v = b.match(l)[1];
          w = this.image(v);
          w.imgwidth = f(O[v] && O[v].width, x && x.width);
          w.imgheight = f(O[v] && O[v].height, x && x.height);

          var z = function () {
            w.attr({
              width: w.width,
              height: w.height
            });
          };

          ["width", "height"].forEach(function (b) {
            w[b + "Setter"] = function (b, a) {
              var f = {},
                  c = this["img" + a],
                  p = "width" === a ? "translateX" : "translateY";
              this[a] = b;
              y(c) && (x && "within" === x.backgroundSize && this.width && this.height && (c = Math.round(c * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(a, c), this.alignByTranslate || (f[p] = ((this[a] || 0) - c) / 2, this.attr(f)));
            };
          });
          y(a) && w.attr({
            x: a,
            y: c
          });
          w.isImg = !0;
          y(w.imgwidth) && y(w.imgheight) ? z() : (w.attr({
            width: 0,
            height: 0
          }), G("img", {
            onload: function () {
              var b = B[m.chartIndex];
              0 === this.width && (J(this, {
                position: "absolute",
                top: "-999em"
              }), Q.body.appendChild(this));
              O[v] = {
                width: this.width,
                height: this.height
              };
              w.imgwidth = this.width;
              w.imgheight = this.height;
              w.element && z();
              this.parentNode && this.parentNode.removeChild(this);
              m.imgCount--;
              if (!m.imgCount && b && !b.hasLoaded) b.onload();
            },
            src: v
          }), this.imgCount++);
        }

        return w;
      },
      symbols: {
        circle: function (b, a, f, c) {
          return this.arc(b + f / 2, a + c / 2, f / 2, c / 2, {
            start: .5 * Math.PI,
            end: 2.5 * Math.PI,
            open: !1
          });
        },
        square: function (b, a, f, c) {
          return ["M", b, a, "L", b + f, a, b + f, a + c, b, a + c, "Z"];
        },
        triangle: function (b, a, f, c) {
          return ["M", b + f / 2, a, "L", b + f, a + c, b, a + c, "Z"];
        },
        "triangle-down": function (b, a, f, c) {
          return ["M", b, a, "L", b + f, a, b + f / 2, a + c, "Z"];
        },
        diamond: function (b, a, f, c) {
          return ["M", b + f / 2, a, "L", b + f, a + c / 2, b + f / 2, a + c, b, a + c / 2, "Z"];
        },
        arc: function (b, a, c, p, e) {
          var x = e.start,
              m = e.r || c,
              l = e.r || p || c,
              C = e.end - .001;
          c = e.innerR;
          p = f(e.open, .001 > Math.abs(e.end - e.start - 2 * Math.PI));
          var k = Math.cos(x),
              n = Math.sin(x),
              w = Math.cos(C);
          C = Math.sin(C);
          x = f(e.longArc, .001 > e.end - x - Math.PI ? 0 : 1);
          m = ["M", b + m * k, a + l * n, "A", m, l, 0, x, f(e.clockwise, 1), b + m * w, a + l * C];
          y(c) && m.push(p ? "M" : "L", b + c * w, a + c * C, "A", c, c, 0, x, y(e.clockwise) ? 1 - e.clockwise : 0, b + c * k, a + c * n);
          m.push(p ? "" : "Z");
          return m;
        },
        callout: function (b, a, f, c, p) {
          var e = Math.min(p && p.r || 0, f, c),
              x = e + 6,
              l = p && p.anchorX;
          p = p && p.anchorY;
          var m = ["M", b + e, a, "L", b + f - e, a, "C", b + f, a, b + f, a, b + f, a + e, "L", b + f, a + c - e, "C", b + f, a + c, b + f, a + c, b + f - e, a + c, "L", b + e, a + c, "C", b, a + c, b, a + c, b, a + c - e, "L", b, a + e, "C", b, a, b, a, b + e, a];
          l && l > f ? p > a + x && p < a + c - x ? m.splice(13, 3, "L", b + f, p - 6, b + f + 6, p, b + f, p + 6, b + f, a + c - e) : m.splice(13, 3, "L", b + f, c / 2, l, p, b + f, c / 2, b + f, a + c - e) : l && 0 > l ? p > a + x && p < a + c - x ? m.splice(33, 3, "L", b, p + 6, b - 6, p, b, p - 6, b, a + e) : m.splice(33, 3, "L", b, c / 2, l, p, b, c / 2, b, a + e) : p && p > c && l > b + x && l < b + f - x ? m.splice(23, 3, "L", l + 6, a + c, l, a + c + 6, l - 6, a + c, b + e, a + c) : p && 0 > p && l > b + x && l < b + f - x && m.splice(3, 3, "L", l - 6, a, l, a - 6, l + 6, a, f - e, a);
          return m;
        }
      },
      clipRect: function (b, a, f, c) {
        var p = w() + "-",
            e = this.createElement("clipPath").attr({
          id: p
        }).add(this.defs);
        b = this.rect(b, a, f, c, 0).add(e);
        b.id = p;
        b.clipPath = e;
        b.count = 0;
        return b;
      },
      text: function (b, a, f, c) {
        var p = {};
        if (c && (this.allowHTML || !this.forExport)) return this.html(b, a, f);
        p.x = Math.round(a || 0);
        f && (p.y = Math.round(f));
        y(b) && (p.text = b);
        b = this.createElement("text").attr(p);
        c || (b.xSetter = function (b, a, f) {
          var c = f.getElementsByTagName("tspan"),
              p = f.getAttribute(a),
              e;

          for (e = 0; e < c.length; e++) {
            var x = c[e];
            x.getAttribute(a) === p && x.setAttribute(a, b);
          }

          f.setAttribute(a, b);
        });
        return b;
      },
      fontMetrics: function (b, f) {
        b = !this.styledMode && /px/.test(b) || !X.getComputedStyle ? b || f && f.style && f.style.fontSize || this.style && this.style.fontSize : f && U.prototype.getStyle.call(f, "font-size");
        b = /px/.test(b) ? a(b) : 12;
        f = 24 > b ? b + 3 : Math.round(1.2 * b);
        return {
          h: f,
          b: Math.round(.8 * f),
          f: b
        };
      },
      rotCorr: function (b, a, f) {
        var c = b;
        a && f && (c = Math.max(c * Math.cos(a * L), 4));
        return {
          x: -b / 3 * Math.sin(a * L),
          y: c
        };
      },
      label: function (b, a, f, c, p, e, x, C, n) {
        var m = this,
            w = m.styledMode,
            v = m.g("button" !== n && "label"),
            F = v.text = m.text("", 0, 0, x).attr({
          zIndex: 1
        }),
            z,
            O,
            q = 0,
            R = 3,
            B = 0,
            d,
            N,
            X,
            V,
            L,
            t = {},
            T,
            g,
            Q = /^url\((.*?)\)$/.test(c),
            H = w || Q,
            K = function () {
          return w ? z.strokeWidth() % 2 / 2 : (T ? parseInt(T, 10) : 0) % 2 / 2;
        };

        n && v.addClass("highcharts-" + n);

        var ba = function () {
          var b = F.element.style,
              a = {};
          O = ("undefined" === typeof d || "undefined" === typeof N || L) && y(F.textStr) && F.getBBox();
          v.width = (d || O.width || 0) + 2 * R + B;
          v.height = (N || O.height || 0) + 2 * R;
          g = R + Math.min(m.fontMetrics(b && b.fontSize, F).b, O ? O.height : Infinity);
          H && (z || (v.box = z = m.symbols[c] || Q ? m.symbol(c) : m.rect(), z.addClass(("button" === n ? "" : "highcharts-label-box") + (n ? " highcharts-" + n + "-box" : "")), z.add(v), b = K(), a.x = b, a.y = (C ? -g : 0) + b), a.width = Math.round(v.width), a.height = Math.round(v.height), z.attr(h(a, t)), t = {});
        };

        var u = function () {
          var b = B + R;
          var a = C ? 0 : g;
          y(d) && O && ("center" === L || "right" === L) && (b += {
            center: .5,
            right: 1
          }[L] * (d - O.width));
          if (b !== F.x || a !== F.y) F.attr("x", b), F.hasBoxWidthChanged && (O = F.getBBox(!0), ba()), "undefined" !== typeof a && F.attr("y", a);
          F.x = b;
          F.y = a;
        };

        var Y = function (b, a) {
          z ? z.attr(b, a) : t[b] = a;
        };

        v.onAdd = function () {
          F.add(v);
          v.attr({
            text: b || 0 === b ? b : "",
            x: a,
            y: f
          });
          z && y(p) && v.attr({
            anchorX: p,
            anchorY: e
          });
        };

        v.widthSetter = function (b) {
          d = P(b) ? b : null;
        };

        v.heightSetter = function (b) {
          N = b;
        };

        v["text-alignSetter"] = function (b) {
          L = b;
        };

        v.paddingSetter = function (b) {
          y(b) && b !== R && (R = v.padding = b, u());
        };

        v.paddingLeftSetter = function (b) {
          y(b) && b !== B && (B = b, u());
        };

        v.alignSetter = function (b) {
          b = {
            left: 0,
            center: .5,
            right: 1
          }[b];
          b !== q && (q = b, O && v.attr({
            x: X
          }));
        };

        v.textSetter = function (b) {
          "undefined" !== typeof b && F.attr({
            text: b
          });
          ba();
          u();
        };

        v["stroke-widthSetter"] = function (b, a) {
          b && (H = !0);
          T = this["stroke-width"] = b;
          Y(a, b);
        };

        w ? v.rSetter = function (b, a) {
          Y(a, b);
        } : v.strokeSetter = v.fillSetter = v.rSetter = function (b, a) {
          "r" !== a && ("fill" === a && b && (H = !0), v[a] = b);
          Y(a, b);
        };

        v.anchorXSetter = function (b, a) {
          p = v.anchorX = b;
          Y(a, Math.round(b) - K() - X);
        };

        v.anchorYSetter = function (b, a) {
          e = v.anchorY = b;
          Y(a, b - V);
        };

        v.xSetter = function (b) {
          v.x = b;
          q && (b -= q * ((d || O.width) + 2 * R), v["forceAnimate:x"] = !0);
          X = Math.round(b);
          v.attr("translateX", X);
        };

        v.ySetter = function (b) {
          V = v.y = Math.round(b);
          v.attr("translateY", V);
        };

        var D = v.css;
        x = {
          css: function (b) {
            if (b) {
              var a = {};
              b = k(b);
              v.textProps.forEach(function (f) {
                "undefined" !== typeof b[f] && (a[f] = b[f], delete b[f]);
              });
              F.css(a);
              "width" in a && ba();
              "fontSize" in a && (ba(), u());
            }

            return D.call(v, b);
          },
          getBBox: function () {
            return {
              width: O.width + 2 * R,
              height: O.height + 2 * R,
              x: O.x - R,
              y: O.y - R
            };
          },
          destroy: function () {
            l(v.element, "mouseenter");
            l(v.element, "mouseleave");
            F && (F = F.destroy());
            z && (z = z.destroy());
            U.prototype.destroy.call(v);
            v = m = ba = u = Y = null;
          }
        };
        w || (x.shadow = function (b) {
          b && (ba(), z && z.shadow(b));
          return v;
        });
        return h(v, x);
      }
    });
    d.Renderer = g;
  });
  S(r, "parts/Html.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.attr,
        u = g.createElement,
        I = g.css,
        M = g.defined,
        E = g.extend,
        A = g.pick,
        G = g.pInt,
        J = d.isFirefox,
        y = d.isMS,
        t = d.isWebKit,
        D = d.SVGElement;
    g = d.SVGRenderer;
    var h = d.win;
    E(D.prototype, {
      htmlCss: function (d) {
        var q = "SPAN" === this.element.tagName && d && "width" in d,
            N = A(q && d.width, void 0);

        if (q) {
          delete d.width;
          this.textWidth = N;
          var e = !0;
        }

        d && "ellipsis" === d.textOverflow && (d.whiteSpace = "nowrap", d.overflow = "hidden");
        this.styles = E(this.styles, d);
        I(this.element, d);
        e && this.htmlUpdateTransform();
        return this;
      },
      htmlGetBBox: function () {
        var d = this.element;
        return {
          x: d.offsetLeft,
          y: d.offsetTop,
          width: d.offsetWidth,
          height: d.offsetHeight
        };
      },
      htmlUpdateTransform: function () {
        if (this.added) {
          var d = this.renderer,
              q = this.element,
              h = this.translateX || 0,
              e = this.translateY || 0,
              c = this.x || 0,
              k = this.y || 0,
              n = this.textAlign || "left",
              f = {
            left: 0,
            center: .5,
            right: 1
          }[n],
              a = this.styles,
              l = a && a.whiteSpace;
          I(q, {
            marginLeft: h,
            marginTop: e
          });
          !d.styledMode && this.shadows && this.shadows.forEach(function (a) {
            I(a, {
              marginLeft: h + 1,
              marginTop: e + 1
            });
          });
          this.inverted && [].forEach.call(q.childNodes, function (a) {
            d.invertChild(a, q);
          });

          if ("SPAN" === q.tagName) {
            a = this.rotation;
            var v = this.textWidth && G(this.textWidth),
                z = [a, n, q.innerHTML, this.textWidth, this.textAlign].join(),
                w;
            (w = v !== this.oldTextWidth) && !(w = v > this.oldTextWidth) && ((w = this.textPxLength) || (I(q, {
              width: "",
              whiteSpace: l || "nowrap"
            }), w = q.offsetWidth), w = w > v);
            w && (/[ \-]/.test(q.textContent || q.innerText) || "ellipsis" === q.style.textOverflow) ? (I(q, {
              width: v + "px",
              display: "block",
              whiteSpace: l || "normal"
            }), this.oldTextWidth = v, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;
            z !== this.cTT && (l = d.fontMetrics(q.style.fontSize, q).b, !M(a) || a === (this.oldRotation || 0) && n === this.oldAlign || this.setSpanRotation(a, f, l), this.getSpanCorrection(!M(a) && this.textPxLength || q.offsetWidth, l, f, a, n));
            I(q, {
              left: c + (this.xCorr || 0) + "px",
              top: k + (this.yCorr || 0) + "px"
            });
            this.cTT = z;
            this.oldRotation = a;
            this.oldAlign = n;
          }
        } else this.alignOnAdd = !0;
      },
      setSpanRotation: function (d, q, h) {
        var e = {},
            c = this.renderer.getTransformKey();
        e[c] = e.transform = "rotate(" + d + "deg)";
        e[c + (J ? "Origin" : "-origin")] = e.transformOrigin = 100 * q + "% " + h + "px";
        I(this.element, e);
      },
      getSpanCorrection: function (d, q, h) {
        this.xCorr = -d * h;
        this.yCorr = -q;
      }
    });
    E(g.prototype, {
      getTransformKey: function () {
        return y && !/Edge/.test(h.navigator.userAgent) ? "-ms-transform" : t ? "-webkit-transform" : J ? "MozTransform" : h.opera ? "-o-transform" : "";
      },
      html: function (d, q, h) {
        var e = this.createElement("span"),
            c = e.element,
            k = e.renderer,
            n = k.isSVG,
            f = function (a, f) {
          ["opacity", "visibility"].forEach(function (c) {
            a[c + "Setter"] = function (e, l, k) {
              var v = a.div ? a.div.style : f;
              D.prototype[c + "Setter"].call(this, e, l, k);
              v && (v[l] = e);
            };
          });
          a.addedSetters = !0;
        };

        e.textSetter = function (a) {
          a !== c.innerHTML && (delete this.bBox, delete this.oldTextWidth);
          this.textStr = a;
          c.innerHTML = A(a, "");
          e.doTransform = !0;
        };

        n && f(e, e.element.style);

        e.xSetter = e.ySetter = e.alignSetter = e.rotationSetter = function (a, f) {
          "align" === f && (f = "textAlign");
          e[f] = a;
          e.doTransform = !0;
        };

        e.afterSetters = function () {
          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
        };

        e.attr({
          text: d,
          x: Math.round(q),
          y: Math.round(h)
        }).css({
          position: "absolute"
        });
        k.styledMode || e.css({
          fontFamily: this.style.fontFamily,
          fontSize: this.style.fontSize
        });
        c.style.whiteSpace = "nowrap";
        e.css = e.htmlCss;
        n && (e.add = function (a) {
          var l = k.box.parentNode,
              v = [];

          if (this.parentGroup = a) {
            var n = a.div;

            if (!n) {
              for (; a;) v.push(a), a = a.parentGroup;

              v.reverse().forEach(function (a) {
                function c(f, c) {
                  a[c] = f;
                  "translateX" === c ? w.left = f + "px" : w.top = f + "px";
                  a.doTransform = !0;
                }

                var k = r(a.element, "class");
                n = a.div = a.div || u("div", k ? {
                  className: k
                } : void 0, {
                  position: "absolute",
                  left: (a.translateX || 0) + "px",
                  top: (a.translateY || 0) + "px",
                  display: a.display,
                  opacity: a.opacity,
                  pointerEvents: a.styles && a.styles.pointerEvents
                }, n || l);
                var w = n.style;
                E(a, {
                  classSetter: function (a) {
                    return function (f) {
                      this.element.setAttribute("class", f);
                      a.className = f;
                    };
                  }(n),
                  on: function () {
                    v[0].div && e.on.apply({
                      element: v[0].div
                    }, arguments);
                    return a;
                  },
                  translateXSetter: c,
                  translateYSetter: c
                });
                a.addedSetters || f(a);
              });
            }
          } else n = l;

          n.appendChild(c);
          e.added = !0;
          e.alignOnAdd && e.htmlUpdateTransform();
          return e;
        });
        return e;
      }
    });
  });
  S(r, "parts/Tick.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.clamp,
        u = g.correctFloat,
        I = g.defined,
        M = g.destroyObjectProperties,
        E = g.extend,
        A = g.isNumber,
        G = g.merge,
        J = g.objectEach,
        y = g.pick,
        t = d.fireEvent,
        D = d.deg2rad;

    g = function () {
      function h(d, q, h, e, c) {
        this.isNewLabel = this.isNew = !0;
        this.axis = d;
        this.pos = q;
        this.type = h || "";
        this.parameters = c || {};
        this.tickmarkOffset = this.parameters.tickmarkOffset;
        this.options = this.parameters.options;
        h || e || this.addLabel();
      }

      h.prototype.addLabel = function () {
        var d = this,
            q = d.axis,
            h = q.options,
            e = q.chart,
            c = q.categories,
            k = q.names,
            n = d.pos,
            f = y(d.options && d.options.labels, h.labels),
            a = q.tickPositions,
            l = n === a[0],
            v = n === a[a.length - 1];
        k = this.parameters.category || (c ? y(c[n], k[n], n) : n);
        var z = d.label;
        c = (!f.step || 1 === f.step) && 1 === q.tickInterval;
        a = a.info;
        var w, B;

        if (q.isDatetimeAxis && a) {
          var L = e.time.resolveDTLFormat(h.dateTimeLabelFormats[!h.grid && a.higherRanks[n] || a.unitName]);
          var t = L.main;
        }

        d.isFirst = l;
        d.isLast = v;
        d.formatCtx = {
          axis: q,
          chart: e,
          isFirst: l,
          isLast: v,
          dateTimeLabelFormat: t,
          tickPositionInfo: a,
          value: q.isLog ? u(q.lin2log(k)) : k,
          pos: n
        };
        h = q.labelFormatter.call(d.formatCtx, this.formatCtx);
        if (B = L && L.list) d.shortenLabel = function () {
          for (w = 0; w < B.length; w++) if (z.attr({
            text: q.labelFormatter.call(E(d.formatCtx, {
              dateTimeLabelFormat: B[w]
            }))
          }), z.getBBox().width < q.getSlotWidth(d) - 2 * y(f.padding, 5)) return;

          z.attr({
            text: ""
          });
        };
        c && q._addedPlotLB && q.isXAxis && d.moveLabel(h, f);
        I(z) || d.movedLabel ? z && z.textStr !== h && !c && (!z.textWidth || f.style && f.style.width || z.styles.width || z.css({
          width: null
        }), z.attr({
          text: h
        }), z.textPxLength = z.getBBox().width) : (d.label = z = d.createLabel({
          x: 0,
          y: 0
        }, h, f), d.rotation = 0);
      };

      h.prototype.createLabel = function (d, q, h) {
        var e = this.axis,
            c = e.chart;
        if (d = I(q) && h.enabled ? c.renderer.text(q, d.x, d.y, h.useHTML).add(e.labelGroup) : null) c.styledMode || d.css(G(h.style)), d.textPxLength = d.getBBox().width;
        return d;
      };

      h.prototype.destroy = function () {
        M(this, this.axis);
      };

      h.prototype.getPosition = function (d, q, h, e) {
        var c = this.axis,
            k = c.chart,
            n = e && k.oldChartHeight || k.chartHeight;
        d = {
          x: d ? u(c.translate(q + h, null, null, e) + c.transB) : c.left + c.offset + (c.opposite ? (e && k.oldChartWidth || k.chartWidth) - c.right - c.left : 0),
          y: d ? n - c.bottom + c.offset - (c.opposite ? c.height : 0) : u(n - c.translate(q + h, null, null, e) - c.transB)
        };
        d.y = r(d.y, -1E5, 1E5);
        t(this, "afterGetPosition", {
          pos: d
        });
        return d;
      };

      h.prototype.getLabelPosition = function (d, q, h, e, c, k, n, f) {
        var a = this.axis,
            l = a.transA,
            v = a.isLinked && a.linkedParent ? a.linkedParent.reversed : a.reversed,
            z = a.staggerLines,
            w = a.tickRotCorr || {
          x: 0,
          y: 0
        },
            B = c.y,
            L = e || a.reserveSpaceDefault ? 0 : -a.labelOffset * ("center" === a.labelAlign ? .5 : 1),
            N = {};
        I(B) || (B = 0 === a.side ? h.rotation ? -8 : -h.getBBox().height : 2 === a.side ? w.y + 8 : Math.cos(h.rotation * D) * (w.y - h.getBBox(!1, 0).height / 2));
        d = d + c.x + L + w.x - (k && e ? k * l * (v ? -1 : 1) : 0);
        q = q + B - (k && !e ? k * l * (v ? 1 : -1) : 0);
        z && (h = n / (f || 1) % z, a.opposite && (h = z - h - 1), q += a.labelOffset / z * h);
        N.x = d;
        N.y = Math.round(q);
        t(this, "afterGetLabelPosition", {
          pos: N,
          tickmarkOffset: k,
          index: n
        });
        return N;
      };

      h.prototype.getLabelSize = function () {
        return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
      };

      h.prototype.getMarkPath = function (d, q, h, e, c, k) {
        return k.crispLine(["M", d, q, "L", d + (c ? 0 : -h), q + (c ? h : 0)], e);
      };

      h.prototype.handleOverflow = function (d) {
        var q = this.axis,
            h = q.options.labels,
            e = d.x,
            c = q.chart.chartWidth,
            k = q.chart.spacing,
            n = y(q.labelLeft, Math.min(q.pos, k[3]));
        k = y(q.labelRight, Math.max(q.isRadial ? 0 : q.pos + q.len, c - k[1]));
        var f = this.label,
            a = this.rotation,
            l = {
          left: 0,
          center: .5,
          right: 1
        }[q.labelAlign || f.attr("align")],
            v = f.getBBox().width,
            z = q.getSlotWidth(this),
            w = z,
            B = 1,
            L,
            t = {};
        if (a || "justify" !== y(h.overflow, "justify")) 0 > a && e - l * v < n ? L = Math.round(e / Math.cos(a * D) - n) : 0 < a && e + l * v > k && (L = Math.round((c - e) / Math.cos(a * D)));else if (c = e + (1 - l) * v, e - l * v < n ? w = d.x + w * (1 - l) - n : c > k && (w = k - d.x + w * l, B = -1), w = Math.min(z, w), w < z && "center" === q.labelAlign && (d.x += B * (z - w - l * (z - Math.min(v, w)))), v > w || q.autoRotation && (f.styles || {}).width) L = w;
        L && (this.shortenLabel ? this.shortenLabel() : (t.width = Math.floor(L), (h.style || {}).textOverflow || (t.textOverflow = "ellipsis"), f.css(t)));
      };

      h.prototype.moveLabel = function (d, q) {
        var h = this,
            e = h.label,
            c = !1,
            k = h.axis,
            n = k.reversed,
            f = k.chart.inverted;
        e && e.textStr === d ? (h.movedLabel = e, c = !0, delete h.label) : J(k.ticks, function (a) {
          c || a.isNew || a === h || !a.label || a.label.textStr !== d || (h.movedLabel = a.label, c = !0, a.labelPos = h.movedLabel.xy, delete a.label);
        });

        if (!c && (h.labelPos || e)) {
          var a = h.labelPos || e.xy;
          e = f ? a.x : n ? 0 : k.width + k.left;
          k = f ? n ? k.width + k.left : 0 : a.y;
          h.movedLabel = h.createLabel({
            x: e,
            y: k
          }, d, q);
          h.movedLabel && h.movedLabel.attr({
            opacity: 0
          });
        }
      };

      h.prototype.render = function (h, q, t) {
        var e = this.axis,
            c = e.horiz,
            k = this.pos,
            n = y(this.tickmarkOffset, e.tickmarkOffset);
        k = this.getPosition(c, k, n, q);
        n = k.x;
        var f = k.y;
        e = c && n === e.pos + e.len || !c && f === e.pos ? -1 : 1;
        t = y(t, 1);
        this.isActive = !0;
        this.renderGridLine(q, t, e);
        this.renderMark(k, t, e);
        this.renderLabel(k, q, t, h);
        this.isNew = !1;
        d.fireEvent(this, "afterRender");
      };

      h.prototype.renderGridLine = function (d, q, h) {
        var e = this.axis,
            c = e.options,
            k = this.gridLine,
            n = {},
            f = this.pos,
            a = this.type,
            l = y(this.tickmarkOffset, e.tickmarkOffset),
            v = e.chart.renderer,
            z = a ? a + "Grid" : "grid",
            w = c[z + "LineWidth"],
            B = c[z + "LineColor"];
        c = c[z + "LineDashStyle"];
        k || (e.chart.styledMode || (n.stroke = B, n["stroke-width"] = w, c && (n.dashstyle = c)), a || (n.zIndex = 1), d && (q = 0), this.gridLine = k = v.path().attr(n).addClass("highcharts-" + (a ? a + "-" : "") + "grid-line").add(e.gridGroup));
        if (k && (h = e.getPlotLinePath({
          value: f + l,
          lineWidth: k.strokeWidth() * h,
          force: "pass",
          old: d
        }))) k[d || this.isNew ? "attr" : "animate"]({
          d: h,
          opacity: q
        });
      };

      h.prototype.renderMark = function (d, q, h) {
        var e = this.axis,
            c = e.options,
            k = e.chart.renderer,
            n = this.type,
            f = n ? n + "Tick" : "tick",
            a = e.tickSize(f),
            l = this.mark,
            v = !l,
            z = d.x;
        d = d.y;
        var w = y(c[f + "Width"], !n && e.isXAxis ? 1 : 0);
        c = c[f + "Color"];
        a && (e.opposite && (a[0] = -a[0]), v && (this.mark = l = k.path().addClass("highcharts-" + (n ? n + "-" : "") + "tick").add(e.axisGroup), e.chart.styledMode || l.attr({
          stroke: c,
          "stroke-width": w
        })), l[v ? "attr" : "animate"]({
          d: this.getMarkPath(z, d, a[0], l.strokeWidth() * h, e.horiz, k),
          opacity: q
        }));
      };

      h.prototype.renderLabel = function (d, q, h, e) {
        var c = this.axis,
            k = c.horiz,
            n = c.options,
            f = this.label,
            a = n.labels,
            l = a.step;
        c = y(this.tickmarkOffset, c.tickmarkOffset);
        var v = !0,
            z = d.x;
        d = d.y;
        f && A(z) && (f.xy = d = this.getLabelPosition(z, d, f, k, a, c, e, l), this.isFirst && !this.isLast && !y(n.showFirstLabel, 1) || this.isLast && !this.isFirst && !y(n.showLastLabel, 1) ? v = !1 : !k || a.step || a.rotation || q || 0 === h || this.handleOverflow(d), l && e % l && (v = !1), v && A(d.y) ? (d.opacity = h, f[this.isNewLabel ? "attr" : "animate"](d), this.isNewLabel = !1) : (f.attr("y", -9999), this.isNewLabel = !0));
      };

      h.prototype.replaceMovedLabel = function () {
        var d = this.label,
            q = this.axis,
            h = q.reversed,
            e = this.axis.chart.inverted;

        if (d && !this.isNew) {
          var c = e ? d.xy.x : h ? q.left : q.width + q.left;
          h = e ? h ? q.width + q.top : q.top : d.xy.y;
          d.animate({
            x: c,
            y: h,
            opacity: 0
          }, void 0, d.destroy);
          delete this.label;
        }

        q.isDirty = !0;
        this.label = this.movedLabel;
        delete this.movedLabel;
      };

      return h;
    }();

    d.Tick = g;
    return d.Tick;
  });
  S(r, "parts/Time.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.defined,
        u = g.error,
        I = g.extend,
        M = g.isObject,
        E = g.merge,
        A = g.objectEach,
        G = g.pad,
        J = g.pick,
        y = g.splat,
        t = g.timeUnits,
        D = d.win;

    g = function () {
      function h(d) {
        this.options = {};
        this.variableTimezone = this.useUTC = !1;
        this.Date = D.Date;
        this.getTimezoneOffset = this.timezoneOffsetFunction();
        this.update(d);
      }

      h.prototype.get = function (d, q) {
        if (this.variableTimezone || this.timezoneOffset) {
          var h = q.getTime(),
              e = h - this.getTimezoneOffset(q);
          q.setTime(e);
          d = q["getUTC" + d]();
          q.setTime(h);
          return d;
        }

        return this.useUTC ? q["getUTC" + d]() : q["get" + d]();
      };

      h.prototype.set = function (d, q, h) {
        if (this.variableTimezone || this.timezoneOffset) {
          if ("Milliseconds" === d || "Seconds" === d || "Minutes" === d) return q["setUTC" + d](h);
          var e = this.getTimezoneOffset(q);
          e = q.getTime() - e;
          q.setTime(e);
          q["setUTC" + d](h);
          d = this.getTimezoneOffset(q);
          e = q.getTime() + d;
          return q.setTime(e);
        }

        return this.useUTC ? q["setUTC" + d](h) : q["set" + d](h);
      };

      h.prototype.update = function (d) {
        var q = J(d && d.useUTC, !0);
        this.options = d = E(!0, this.options || {}, d);
        this.Date = d.Date || D.Date || Date;
        this.timezoneOffset = (this.useUTC = q) && d.timezoneOffset;
        this.getTimezoneOffset = this.timezoneOffsetFunction();
        this.variableTimezone = !(q && !d.getTimezoneOffset && !d.timezone);
      };

      h.prototype.makeTime = function (h, q, t, e, c, k) {
        if (this.useUTC) {
          var n = this.Date.UTC.apply(0, arguments);
          var f = this.getTimezoneOffset(n);
          n += f;
          var a = this.getTimezoneOffset(n);
          f !== a ? n += a - f : f - 36E5 !== this.getTimezoneOffset(n - 36E5) || d.isSafari || (n -= 36E5);
        } else n = new this.Date(h, q, J(t, 1), J(e, 0), J(c, 0), J(k, 0)).getTime();

        return n;
      };

      h.prototype.timezoneOffsetFunction = function () {
        var d = this,
            q = this.options,
            h = D.moment;
        if (!this.useUTC) return function (e) {
          return 6E4 * new Date(e.toString()).getTimezoneOffset();
        };

        if (q.timezone) {
          if (h) return function (e) {
            return 6E4 * -h.tz(e, q.timezone).utcOffset();
          };
          u(25);
        }

        return this.useUTC && q.getTimezoneOffset ? function (e) {
          return 6E4 * q.getTimezoneOffset(e.valueOf());
        } : function () {
          return 6E4 * (d.timezoneOffset || 0);
        };
      };

      h.prototype.dateFormat = function (h, q, t) {
        var e;
        if (!r(q) || isNaN(q)) return (null === (e = d.defaultOptions.lang) || void 0 === e ? void 0 : e.invalidDate) || "";
        h = J(h, "%Y-%m-%d %H:%M:%S");
        var c = this;
        e = new this.Date(q);
        var k = this.get("Hours", e),
            n = this.get("Day", e),
            f = this.get("Date", e),
            a = this.get("Month", e),
            l = this.get("FullYear", e),
            v = d.defaultOptions.lang,
            z = null === v || void 0 === v ? void 0 : v.weekdays,
            w = null === v || void 0 === v ? void 0 : v.shortWeekdays;
        e = I({
          a: w ? w[n] : z[n].substr(0, 3),
          A: z[n],
          d: G(f),
          e: G(f, 2, " "),
          w: n,
          b: v.shortMonths[a],
          B: v.months[a],
          m: G(a + 1),
          o: a + 1,
          y: l.toString().substr(2, 2),
          Y: l,
          H: G(k),
          k: k,
          I: G(k % 12 || 12),
          l: k % 12 || 12,
          M: G(this.get("Minutes", e)),
          p: 12 > k ? "AM" : "PM",
          P: 12 > k ? "am" : "pm",
          S: G(e.getSeconds()),
          L: G(Math.floor(q % 1E3), 3)
        }, d.dateFormats);
        A(e, function (a, f) {
          for (; -1 !== h.indexOf("%" + f);) h = h.replace("%" + f, "function" === typeof a ? a.call(c, q) : a);
        });
        return t ? h.substr(0, 1).toUpperCase() + h.substr(1) : h;
      };

      h.prototype.resolveDTLFormat = function (d) {
        return M(d, !0) ? d : (d = y(d), {
          main: d[0],
          from: d[1],
          to: d[2]
        });
      };

      h.prototype.getTimeTicks = function (d, h, g, e) {
        var c = this,
            k = [],
            n = {};
        var f = new c.Date(h);
        var a = d.unitRange,
            l = d.count || 1,
            v;
        e = J(e, 1);

        if (r(h)) {
          c.set("Milliseconds", f, a >= t.second ? 0 : l * Math.floor(c.get("Milliseconds", f) / l));
          a >= t.second && c.set("Seconds", f, a >= t.minute ? 0 : l * Math.floor(c.get("Seconds", f) / l));
          a >= t.minute && c.set("Minutes", f, a >= t.hour ? 0 : l * Math.floor(c.get("Minutes", f) / l));
          a >= t.hour && c.set("Hours", f, a >= t.day ? 0 : l * Math.floor(c.get("Hours", f) / l));
          a >= t.day && c.set("Date", f, a >= t.month ? 1 : Math.max(1, l * Math.floor(c.get("Date", f) / l)));

          if (a >= t.month) {
            c.set("Month", f, a >= t.year ? 0 : l * Math.floor(c.get("Month", f) / l));
            var z = c.get("FullYear", f);
          }

          a >= t.year && c.set("FullYear", f, z - z % l);
          a === t.week && (z = c.get("Day", f), c.set("Date", f, c.get("Date", f) - z + e + (z < e ? -7 : 0)));
          z = c.get("FullYear", f);
          e = c.get("Month", f);
          var w = c.get("Date", f),
              q = c.get("Hours", f);
          h = f.getTime();
          c.variableTimezone && (v = g - h > 4 * t.month || c.getTimezoneOffset(h) !== c.getTimezoneOffset(g));
          h = f.getTime();

          for (f = 1; h < g;) k.push(h), h = a === t.year ? c.makeTime(z + f * l, 0) : a === t.month ? c.makeTime(z, e + f * l) : !v || a !== t.day && a !== t.week ? v && a === t.hour && 1 < l ? c.makeTime(z, e, w, q + f * l) : h + a * l : c.makeTime(z, e, w + f * l * (a === t.day ? 1 : 7)), f++;

          k.push(h);
          a <= t.hour && 1E4 > k.length && k.forEach(function (a) {
            0 === a % 18E5 && "000000000" === c.dateFormat("%H%M%S%L", a) && (n[a] = "day");
          });
        }

        k.info = I(d, {
          higherRanks: n,
          totalRange: a * l
        });
        return k;
      };

      h.defaultOptions = {
        Date: void 0,
        getTimezoneOffset: void 0,
        timezone: void 0,
        timezoneOffset: 0,
        useUTC: !0
      };
      return h;
    }();

    d.Time = g;
    return d.Time;
  });
  S(r, "parts/Options.js", [r["parts/Globals.js"], r["parts/Time.js"], r["parts/Color.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    r = r.parse;
    var I = u.merge;
    d.defaultOptions = {
      colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),
      symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
      lang: {
        loading: "Loading...",
        months: "January February March April May June July August September October November December".split(" "),
        shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
        weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
        decimalPoint: ".",
        numericSymbols: "kMGTPE".split(""),
        resetZoom: "Reset zoom",
        resetZoomTitle: "Reset zoom level 1:1",
        thousandsSep: " "
      },
      global: {},
      time: g.defaultOptions,
      chart: {
        styledMode: !1,
        borderRadius: 0,
        colorCount: 10,
        defaultSeriesType: "line",
        ignoreHiddenSeries: !0,
        spacing: [10, 10, 15, 10],
        resetZoomButton: {
          theme: {
            zIndex: 6
          },
          position: {
            align: "right",
            x: -10,
            y: 10
          }
        },
        width: null,
        height: null,
        borderColor: "#335cad",
        backgroundColor: "#ffffff",
        plotBorderColor: "#cccccc"
      },
      title: {
        text: "Chart title",
        align: "center",
        margin: 15,
        widthAdjust: -44
      },
      subtitle: {
        text: "",
        align: "center",
        widthAdjust: -44
      },
      caption: {
        margin: 15,
        text: "",
        align: "left",
        verticalAlign: "bottom"
      },
      plotOptions: {},
      labels: {
        style: {
          position: "absolute",
          color: "#333333"
        }
      },
      legend: {
        enabled: !0,
        align: "center",
        alignColumns: !0,
        layout: "horizontal",
        labelFormatter: function () {
          return this.name;
        },
        borderColor: "#999999",
        borderRadius: 0,
        navigation: {
          activeColor: "#003399",
          inactiveColor: "#cccccc"
        },
        itemStyle: {
          color: "#333333",
          cursor: "pointer",
          fontSize: "12px",
          fontWeight: "bold",
          textOverflow: "ellipsis"
        },
        itemHoverStyle: {
          color: "#000000"
        },
        itemHiddenStyle: {
          color: "#cccccc"
        },
        shadow: !1,
        itemCheckboxStyle: {
          position: "absolute",
          width: "13px",
          height: "13px"
        },
        squareSymbol: !0,
        symbolPadding: 5,
        verticalAlign: "bottom",
        x: 0,
        y: 0,
        title: {
          style: {
            fontWeight: "bold"
          }
        }
      },
      loading: {
        labelStyle: {
          fontWeight: "bold",
          position: "relative",
          top: "45%"
        },
        style: {
          position: "absolute",
          backgroundColor: "#ffffff",
          opacity: .5,
          textAlign: "center"
        }
      },
      tooltip: {
        enabled: !0,
        animation: d.svg,
        borderRadius: 3,
        dateTimeLabelFormats: {
          millisecond: "%A, %b %e, %H:%M:%S.%L",
          second: "%A, %b %e, %H:%M:%S",
          minute: "%A, %b %e, %H:%M",
          hour: "%A, %b %e, %H:%M",
          day: "%A, %b %e, %Y",
          week: "Week from %A, %b %e, %Y",
          month: "%B %Y",
          year: "%Y"
        },
        footerFormat: "",
        padding: 8,
        snap: d.isTouchDevice ? 25 : 10,
        headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
        pointFormat: '<span style="color:{point.color}">\u25cf</span> {series.name}: <b>{point.y}</b><br/>',
        backgroundColor: r("#f7f7f7").setOpacity(.85).get(),
        borderWidth: 1,
        shadow: !0,
        style: {
          color: "#333333",
          cursor: "default",
          fontSize: "12px",
          whiteSpace: "nowrap"
        }
      },
      credits: {
        enabled: !0,
        href: "https://www.highcharts.com?credits",
        position: {
          align: "right",
          x: -10,
          verticalAlign: "bottom",
          y: -5
        },
        style: {
          cursor: "pointer",
          color: "#999999",
          fontSize: "9px"
        },
        text: "Highcharts.com"
      }
    };

    d.setOptions = function (g) {
      d.defaultOptions = I(!0, d.defaultOptions, g);
      (g.time || g.global) && d.time.update(I(d.defaultOptions.global, d.defaultOptions.time, g.global, g.time));
      return d.defaultOptions;
    };

    d.getOptions = function () {
      return d.defaultOptions;
    };

    d.defaultPlotOptions = d.defaultOptions.plotOptions;
    d.time = new g(I(d.defaultOptions.global, d.defaultOptions.time));

    d.dateFormat = function (g, u, A) {
      return d.time.dateFormat(g, u, A);
    };

    "";
  });
  S(r, "parts/Axis.js", [r["parts/Globals.js"], r["parts/Color.js"], r["parts/Tick.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    var I = g.parse,
        M = u.addEvent,
        E = u.animObject,
        A = u.arrayMax,
        G = u.arrayMin,
        J = u.clamp,
        y = u.correctFloat,
        t = u.defined,
        D = u.destroyObjectProperties,
        h = u.error,
        N = u.extend,
        q = u.fireEvent,
        P = u.format,
        e = u.getMagnitude,
        c = u.isArray,
        k = u.isFunction,
        n = u.isNumber,
        f = u.isString,
        a = u.merge,
        l = u.normalizeTickInterval,
        v = u.objectEach,
        z = u.pick,
        w = u.relativeLength,
        B = u.removeEvent,
        L = u.splat,
        Q = u.syncTimeout,
        H = d.defaultOptions,
        K = d.deg2rad;

    g = function () {
      this.init.apply(this, arguments);
    };

    N(g.prototype, {
      defaultOptions: {
        dateTimeLabelFormats: {
          millisecond: {
            main: "%H:%M:%S.%L",
            range: !1
          },
          second: {
            main: "%H:%M:%S",
            range: !1
          },
          minute: {
            main: "%H:%M",
            range: !1
          },
          hour: {
            main: "%H:%M",
            range: !1
          },
          day: {
            main: "%e. %b"
          },
          week: {
            main: "%e. %b"
          },
          month: {
            main: "%b '%y"
          },
          year: {
            main: "%Y"
          }
        },
        endOnTick: !1,
        labels: {
          enabled: !0,
          indentation: 10,
          x: 0,
          style: {
            color: "#666666",
            cursor: "default",
            fontSize: "11px"
          }
        },
        maxPadding: .01,
        minorTickLength: 2,
        minorTickPosition: "outside",
        minPadding: .01,
        showEmpty: !0,
        startOfWeek: 1,
        startOnTick: !1,
        tickLength: 10,
        tickPixelInterval: 100,
        tickmarkPlacement: "between",
        tickPosition: "outside",
        title: {
          align: "middle",
          style: {
            color: "#666666"
          }
        },
        type: "linear",
        minorGridLineColor: "#f2f2f2",
        minorGridLineWidth: 1,
        minorTickColor: "#999999",
        lineColor: "#ccd6eb",
        lineWidth: 1,
        gridLineColor: "#e6e6e6",
        tickColor: "#ccd6eb"
      },
      defaultYAxisOptions: {
        endOnTick: !0,
        maxPadding: .05,
        minPadding: .05,
        tickPixelInterval: 72,
        showLastLabel: !0,
        labels: {
          x: -8
        },
        startOnTick: !0,
        title: {
          rotation: 270,
          text: "Values"
        },
        stackLabels: {
          allowOverlap: !1,
          enabled: !1,
          crop: !0,
          overflow: "justify",
          formatter: function () {
            var a = this.axis.chart.numberFormatter;
            return a(this.total, -1);
          },
          style: {
            color: "#000000",
            fontSize: "11px",
            fontWeight: "bold",
            textOutline: "1px contrast"
          }
        },
        gridLineWidth: 1,
        lineWidth: 0
      },
      defaultLeftAxisOptions: {
        labels: {
          x: -15
        },
        title: {
          rotation: 270
        }
      },
      defaultRightAxisOptions: {
        labels: {
          x: 15
        },
        title: {
          rotation: 90
        }
      },
      defaultBottomAxisOptions: {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        margin: 15,
        title: {
          rotation: 0
        }
      },
      defaultTopAxisOptions: {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        margin: 15,
        title: {
          rotation: 0
        }
      },
      init: function (a, b) {
        var f = b.isX,
            c = this;
        c.chart = a;
        c.horiz = a.inverted && !c.isZAxis ? !f : f;
        c.isXAxis = f;
        c.coll = c.coll || (f ? "xAxis" : "yAxis");
        q(this, "init", {
          userOptions: b
        });
        c.opposite = b.opposite;
        c.side = b.side || (c.horiz ? c.opposite ? 0 : 2 : c.opposite ? 1 : 3);
        c.setOptions(b);
        var p = this.options,
            e = p.type;
        c.labelFormatter = p.labels.formatter || c.defaultLabelFormatter;
        c.userOptions = b;
        c.minPixelPadding = 0;
        c.reversed = p.reversed;
        c.visible = !1 !== p.visible;
        c.zoomEnabled = !1 !== p.zoomEnabled;
        c.hasNames = "category" === e || !0 === p.categories;
        c.categories = p.categories || c.hasNames;
        c.names || (c.names = [], c.names.keys = {});
        c.plotLinesAndBandsGroups = {};
        c.isLog = "logarithmic" === e;
        c.isDatetimeAxis = "datetime" === e;
        c.positiveValuesOnly = c.isLog && !c.allowNegativeLog;
        c.isLinked = t(p.linkedTo);
        c.ticks = {};
        c.labelEdge = [];
        c.minorTicks = {};
        c.plotLinesAndBands = [];
        c.alternateBands = {};
        c.len = 0;
        c.minRange = c.userMinRange = p.minRange || p.maxZoom;
        c.range = p.range;
        c.offset = p.offset || 0;
        c.stacks = {};
        c.oldStacks = {};
        c.stacksTouched = 0;
        c.max = null;
        c.min = null;
        c.crosshair = z(p.crosshair, L(a.options.tooltip.crosshairs)[f ? 0 : 1], !1);
        b = c.options.events;
        -1 === a.axes.indexOf(c) && (f ? a.axes.splice(a.xAxis.length, 0, c) : a.axes.push(c), a[c.coll].push(c));
        c.series = c.series || [];
        a.inverted && !c.isZAxis && f && "undefined" === typeof c.reversed && (c.reversed = !0);
        v(b, function (b, a) {
          k(b) && M(c, a, b);
        });
        c.lin2log = p.linearToLogConverter || c.lin2log;
        c.isLog && (c.val2lin = c.log2lin, c.lin2val = c.lin2log);
        q(this, "afterInit");
      },
      setOptions: function (c) {
        this.options = a(this.defaultOptions, "yAxis" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], a(H[this.coll], c));
        q(this, "afterSetOptions", {
          userOptions: c
        });
      },
      defaultLabelFormatter: function () {
        var a = this.axis,
            b = this.value,
            c = a.chart.time,
            f = a.categories,
            e = this.dateTimeLabelFormat,
            l = H.lang,
            k = l.numericSymbols;
        l = l.numericSymbolMagnitude || 1E3;
        var v = k && k.length,
            m = a.options.labels.format;
        a = a.isLog ? Math.abs(b) : a.tickInterval;
        var n = this.chart,
            d = n.numberFormatter;
        if (m) var w = P(m, this, n);else if (f) w = b;else if (e) w = c.dateFormat(e, b);else if (v && 1E3 <= a) for (; v-- && "undefined" === typeof w;) c = Math.pow(l, v + 1), a >= c && 0 === 10 * b % c && null !== k[v] && 0 !== b && (w = d(b / c, -1) + k[v]);
        "undefined" === typeof w && (w = 1E4 <= Math.abs(b) ? d(b, -1) : d(b, -1, void 0, ""));
        return w;
      },
      getSeriesExtremes: function () {
        var a = this,
            b = a.chart,
            c;
        q(this, "getSeriesExtremes", null, function () {
          a.hasVisibleSeries = !1;
          a.dataMin = a.dataMax = a.threshold = null;
          a.softThreshold = !a.isXAxis;
          a.buildStacks && a.buildStacks();
          a.series.forEach(function (f) {
            if (f.visible || !b.options.chart.ignoreHiddenSeries) {
              var e = f.options,
                  p = e.threshold;
              a.hasVisibleSeries = !0;
              a.positiveValuesOnly && 0 >= p && (p = null);

              if (a.isXAxis) {
                if (e = f.xData, e.length) {
                  c = f.getXExtremes(e);
                  var x = c.min;
                  var l = c.max;
                  n(x) || x instanceof Date || (e = e.filter(n), c = f.getXExtremes(e), x = c.min, l = c.max);
                  e.length && (a.dataMin = Math.min(z(a.dataMin, x), x), a.dataMax = Math.max(z(a.dataMax, l), l));
                }
              } else if (f.getExtremes(), l = f.dataMax, x = f.dataMin, t(x) && t(l) && (a.dataMin = Math.min(z(a.dataMin, x), x), a.dataMax = Math.max(z(a.dataMax, l), l)), t(p) && (a.threshold = p), !e.softThreshold || a.positiveValuesOnly) a.softThreshold = !1;
            }
          });
        });
        q(this, "afterGetSeriesExtremes");
      },
      translate: function (a, b, c, f, e, l) {
        var p = this.linkedParent || this,
            x = 1,
            m = 0,
            C = f ? p.oldTransA : p.transA;
        f = f ? p.oldMin : p.min;
        var k = p.minPixelPadding;
        e = (p.isOrdinal || p.isBroken || p.isLog && e) && p.lin2val;
        C || (C = p.transA);
        c && (x *= -1, m = p.len);
        p.reversed && (x *= -1, m -= x * (p.sector || p.len));
        b ? (a = (a * x + m - k) / C + f, e && (a = p.lin2val(a))) : (e && (a = p.val2lin(a)), a = n(f) ? x * (a - f) * C + m + x * k + (n(l) ? C * l : 0) : void 0);
        return a;
      },
      toPixels: function (a, b) {
        return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);
      },
      toValue: function (a, b) {
        return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);
      },
      getPlotLinePath: function (a) {
        var b = this,
            c = b.chart,
            f = b.left,
            e = b.top,
            p = a.old,
            l = a.value,
            k = a.translatedValue,
            m = a.lineWidth,
            v = a.force,
            d,
            w,
            F,
            h,
            B = p && c.oldChartHeight || c.chartHeight,
            L = p && c.oldChartWidth || c.chartWidth,
            t,
            g = b.transB,
            H = function (b, a, c) {
          if ("pass" !== v && b < a || b > c) v ? b = J(b, a, c) : t = !0;
          return b;
        };

        a = {
          value: l,
          lineWidth: m,
          old: p,
          force: v,
          acrossPanes: a.acrossPanes,
          translatedValue: k
        };
        q(this, "getPlotLinePath", a, function (a) {
          k = z(k, b.translate(l, null, null, p));
          k = J(k, -1E5, 1E5);
          d = F = Math.round(k + g);
          w = h = Math.round(B - k - g);
          n(k) ? b.horiz ? (w = e, h = B - b.bottom, d = F = H(d, f, f + b.width)) : (d = f, F = L - b.right, w = h = H(w, e, e + b.height)) : (t = !0, v = !1);
          a.path = t && !v ? null : c.renderer.crispLine(["M", d, w, "L", F, h], m || 1);
        });
        return a.path;
      },
      getLinearTickPositions: function (a, b, c) {
        var f = y(Math.floor(b / a) * a);
        c = y(Math.ceil(c / a) * a);
        var e = [],
            p;
        y(f + a) === f && (p = 20);
        if (this.single) return [b];

        for (b = f; b <= c;) {
          e.push(b);
          b = y(b + a, p);
          if (b === l) break;
          var l = b;
        }

        return e;
      },
      getMinorTickInterval: function () {
        var a = this.options;
        return !0 === a.minorTicks ? z(a.minorTickInterval, "auto") : !1 === a.minorTicks ? null : a.minorTickInterval;
      },
      getMinorTickPositions: function () {
        var a = this,
            b = a.options,
            c = a.tickPositions,
            f = a.minorTickInterval,
            e = [],
            l = a.pointRangePadding || 0,
            k = a.min - l;
        l = a.max + l;
        var v = l - k;
        if (v && v / f < a.len / 3) if (a.isLog) this.paddedTicks.forEach(function (b, c, p) {
          c && e.push.apply(e, a.getLogTickPositions(f, p[c - 1], p[c], !0));
        });else if (a.isDatetimeAxis && "auto" === this.getMinorTickInterval()) e = e.concat(a.getTimeTicks(a.normalizeTimeTickInterval(f), k, l, b.startOfWeek));else for (b = k + (c[0] - k) % f; b <= l && b !== e[0]; b += f) e.push(b);
        0 !== e.length && a.trimTicks(e);
        return e;
      },
      adjustForMinRange: function () {
        var a = this.options,
            b = this.min,
            c = this.max,
            f,
            e,
            l,
            k,
            v;
        this.isXAxis && "undefined" === typeof this.minRange && !this.isLog && (t(a.min) || t(a.max) ? this.minRange = null : (this.series.forEach(function (b) {
          k = b.xData;

          for (e = v = b.xIncrement ? 1 : k.length - 1; 0 < e; e--) if (l = k[e] - k[e - 1], "undefined" === typeof f || l < f) f = l;
        }), this.minRange = Math.min(5 * f, this.dataMax - this.dataMin)));

        if (c - b < this.minRange) {
          var m = this.dataMax - this.dataMin >= this.minRange;
          var n = this.minRange;
          var d = (n - c + b) / 2;
          d = [b - d, z(a.min, b - d)];
          m && (d[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin);
          b = A(d);
          c = [b + n, z(a.max, b + n)];
          m && (c[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax);
          c = G(c);
          c - b < n && (d[0] = c - n, d[1] = z(a.min, c - n), b = A(d));
        }

        this.min = b;
        this.max = c;
      },
      getClosest: function () {
        var a;
        this.categories ? a = 1 : this.series.forEach(function (b) {
          var c = b.closestPointRange,
              f = b.visible || !b.chart.options.chart.ignoreHiddenSeries;
          !b.noSharedTooltip && t(c) && f && (a = t(a) ? Math.min(a, c) : c);
        });
        return a;
      },
      nameToX: function (a) {
        var b = c(this.categories),
            f = b ? this.categories : this.names,
            e = a.options.x;
        a.series.requireSorting = !1;
        t(e) || (e = !1 === this.options.uniqueNames ? a.series.autoIncrement() : b ? f.indexOf(a.name) : z(f.keys[a.name], -1));

        if (-1 === e) {
          if (!b) var p = f.length;
        } else p = e;

        "undefined" !== typeof p && (this.names[p] = a.name, this.names.keys[a.name] = p);
        return p;
      },
      updateNames: function () {
        var a = this,
            b = this.names;
        0 < b.length && (Object.keys(b.keys).forEach(function (a) {
          delete b.keys[a];
        }), b.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (b) {
          b.xIncrement = null;
          if (!b.points || b.isDirtyData) a.max = Math.max(a.max, b.xData.length - 1), b.processData(), b.generatePoints();
          b.data.forEach(function (c, f) {
            if (c && c.options && "undefined" !== typeof c.name) {
              var e = a.nameToX(c);
              "undefined" !== typeof e && e !== c.x && (c.x = e, b.xData[f] = e);
            }
          });
        }));
      },
      setAxisTranslation: function (a) {
        var b = this,
            c = b.max - b.min,
            e = b.axisPointRange || 0,
            p = 0,
            l = 0,
            k = b.linkedParent,
            v = !!b.categories,
            m = b.transA,
            d = b.isXAxis;

        if (d || v || e) {
          var n = b.getClosest();
          k ? (p = k.minPointOffset, l = k.pointRangePadding) : b.series.forEach(function (a) {
            var c = v ? 1 : d ? z(a.options.pointRange, n, 0) : b.axisPointRange || 0,
                x = a.options.pointPlacement;
            e = Math.max(e, c);
            if (!b.single || v) a = a.is("xrange") ? !d : d, p = Math.max(p, a && f(x) ? 0 : c / 2), l = Math.max(l, a && "on" === x ? 0 : c);
          });
          k = b.ordinalSlope && n ? b.ordinalSlope / n : 1;
          b.minPointOffset = p *= k;
          b.pointRangePadding = l *= k;
          b.pointRange = Math.min(e, b.single && v ? 1 : c);
          d && (b.closestPointRange = n);
        }

        a && (b.oldTransA = m);
        b.translationSlope = b.transA = m = b.staticScale || b.len / (c + l || 1);
        b.transB = b.horiz ? b.left : b.bottom;
        b.minPixelPadding = m * p;
        q(this, "afterSetAxisTranslation");
      },
      minFromRange: function () {
        return this.max - this.range;
      },
      setTickInterval: function (a) {
        var b = this,
            c = b.chart,
            f = b.options,
            p = b.isLog,
            k = b.isDatetimeAxis,
            v = b.isXAxis,
            d = b.isLinked,
            m = f.maxPadding,
            w = f.minPadding,
            B = f.tickInterval,
            L = f.tickPixelInterval,
            F = b.categories,
            V = n(b.threshold) ? b.threshold : null,
            g = b.softThreshold;
        k || F || d || this.getTickAmount();
        var H = z(b.userMin, f.min);
        var K = z(b.userMax, f.max);

        if (d) {
          b.linkedParent = c[b.coll][f.linkedTo];
          var Q = b.linkedParent.getExtremes();
          b.min = z(Q.min, Q.dataMin);
          b.max = z(Q.max, Q.dataMax);
          f.type !== b.linkedParent.options.type && h(11, 1, c);
        } else {
          if (!g && t(V)) if (b.dataMin >= V) Q = V, w = 0;else if (b.dataMax <= V) {
            var u = V;
            m = 0;
          }
          b.min = z(H, Q, b.dataMin);
          b.max = z(K, u, b.dataMax);
        }

        p && (b.positiveValuesOnly && !a && 0 >= Math.min(b.min, z(b.dataMin, b.min)) && h(10, 1, c), b.min = y(b.log2lin(b.min), 16), b.max = y(b.log2lin(b.max), 16));
        b.range && t(b.max) && (b.userMin = b.min = H = Math.max(b.dataMin, b.minFromRange()), b.userMax = K = b.max, b.range = null);
        q(b, "foundExtremes");
        b.beforePadding && b.beforePadding();
        b.adjustForMinRange();
        !(F || b.axisPointRange || b.usePercentage || d) && t(b.min) && t(b.max) && (c = b.max - b.min) && (!t(H) && w && (b.min -= c * w), !t(K) && m && (b.max += c * m));
        n(b.userMin) || (n(f.softMin) && f.softMin < b.min && (b.min = H = f.softMin), n(f.floor) && (b.min = Math.max(b.min, f.floor)));
        n(b.userMax) || (n(f.softMax) && f.softMax > b.max && (b.max = K = f.softMax), n(f.ceiling) && (b.max = Math.min(b.max, f.ceiling)));
        g && t(b.dataMin) && (V = V || 0, !t(H) && b.min < V && b.dataMin >= V ? b.min = b.options.minRange ? Math.min(V, b.max - b.minRange) : V : !t(K) && b.max > V && b.dataMax <= V && (b.max = b.options.minRange ? Math.max(V, b.min + b.minRange) : V));
        b.tickInterval = b.min === b.max || "undefined" === typeof b.min || "undefined" === typeof b.max ? 1 : d && !B && L === b.linkedParent.options.tickPixelInterval ? B = b.linkedParent.tickInterval : z(B, this.tickAmount ? (b.max - b.min) / Math.max(this.tickAmount - 1, 1) : void 0, F ? 1 : (b.max - b.min) * L / Math.max(b.len, L));
        v && !a && b.series.forEach(function (a) {
          a.processData(b.min !== b.oldMin || b.max !== b.oldMax);
        });
        b.setAxisTranslation(!0);
        b.beforeSetTickPositions && b.beforeSetTickPositions();
        b.postProcessTickInterval && (b.tickInterval = b.postProcessTickInterval(b.tickInterval));
        b.pointRange && !B && (b.tickInterval = Math.max(b.pointRange, b.tickInterval));
        a = z(f.minTickInterval, b.isDatetimeAxis && b.closestPointRange);
        !B && b.tickInterval < a && (b.tickInterval = a);
        k || p || B || (b.tickInterval = l(b.tickInterval, null, e(b.tickInterval), z(f.allowDecimals, !(.5 < b.tickInterval && 5 > b.tickInterval && 1E3 < b.max && 9999 > b.max)), !!this.tickAmount));
        this.tickAmount || (b.tickInterval = b.unsquish());
        this.setTickPositions();
      },
      setTickPositions: function () {
        var a = this.options,
            b = a.tickPositions;
        var c = this.getMinorTickInterval();
        var f = a.tickPositioner,
            e = a.startOnTick,
            l = a.endOnTick;
        this.tickmarkOffset = this.categories && "between" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
        this.minorTickInterval = "auto" === c && this.tickInterval ? this.tickInterval / 5 : c;
        this.single = this.min === this.max && t(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== a.allowDecimals);
        this.tickPositions = c = b && b.slice();
        !c && (!this.ordinalPositions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200) ? (c = [this.min, this.max], h(19, !1, this.chart)) : c = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), c.length > this.len && (c = [c[0], c.pop()], c[0] === c[1] && (c.length = 1)), this.tickPositions = c, f && (f = f.apply(this, [this.min, this.max]))) && (this.tickPositions = c = f);
        this.paddedTicks = c.slice(0);
        this.trimTicks(c, e, l);
        this.isLinked || (this.single && 2 > c.length && !this.categories && !this.series.some(function (b) {
          return b.is("heatmap") && "between" === b.options.pointPlacement;
        }) && (this.min -= .5, this.max += .5), b || f || this.adjustTickAmount());
        q(this, "afterSetTickPositions");
      },
      trimTicks: function (a, b, c) {
        var f = a[0],
            e = a[a.length - 1],
            p = !this.isOrdinal && this.minPointOffset || 0;
        q(this, "trimTicks");

        if (!this.isLinked) {
          if (b && -Infinity !== f) this.min = f;else for (; this.min - p > a[0];) a.shift();
          if (c) this.max = e;else for (; this.max + p < a[a.length - 1];) a.pop();
          0 === a.length && t(f) && !this.options.tickPositions && a.push((e + f) / 2);
        }
      },
      alignToOthers: function () {
        var a = {},
            b,
            c = this.options;
        !1 === this.chart.options.chart.alignTicks || !1 === c.alignTicks || !1 === c.startOnTick || !1 === c.endOnTick || this.isLog || this.chart[this.coll].forEach(function (c) {
          var f = c.options;
          f = [c.horiz ? f.left : f.top, f.width, f.height, f.pane].join();
          c.series.length && (a[f] ? b = !0 : a[f] = 1);
        });
        return b;
      },
      getTickAmount: function () {
        var a = this.options,
            b = a.tickAmount,
            c = a.tickPixelInterval;
        !t(a.tickInterval) && this.len < c && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (b = 2);
        !b && this.alignToOthers() && (b = Math.ceil(this.len / c) + 1);
        4 > b && (this.finalTickAmt = b, b = 5);
        this.tickAmount = b;
      },
      adjustTickAmount: function () {
        var a = this.options,
            b = this.tickInterval,
            c = this.tickPositions,
            f = this.tickAmount,
            e = this.finalTickAmt,
            l = c && c.length,
            k = z(this.threshold, this.softThreshold ? 0 : null),
            v;

        if (this.hasData()) {
          if (l < f) {
            for (v = this.min; c.length < f;) c.length % 2 || v === k ? c.push(y(c[c.length - 1] + b)) : c.unshift(y(c[0] - b));

            this.transA *= (l - 1) / (f - 1);
            this.min = a.startOnTick ? c[0] : Math.min(this.min, c[0]);
            this.max = a.endOnTick ? c[c.length - 1] : Math.max(this.max, c[c.length - 1]);
          } else l > f && (this.tickInterval *= 2, this.setTickPositions());

          if (t(e)) {
            for (b = a = c.length; b--;) (3 === e && 1 === b % 2 || 2 >= e && 0 < b && b < a - 1) && c.splice(b, 1);

            this.finalTickAmt = void 0;
          }
        }
      },
      setScale: function () {
        var a = this.series.some(function (b) {
          return b.isDirtyData || b.isDirty || b.xAxis && b.xAxis.isDirty;
        }),
            b;
        this.oldMin = this.min;
        this.oldMax = this.max;
        this.oldAxisLength = this.len;
        this.setAxisSize();
        (b = this.len !== this.oldAxisLength) || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();
        q(this, "afterSetScale");
      },
      setExtremes: function (a, b, c, f, e) {
        var p = this,
            l = p.chart;
        c = z(c, !0);
        p.series.forEach(function (b) {
          delete b.kdTree;
        });
        e = N(e, {
          min: a,
          max: b
        });
        q(p, "setExtremes", e, function () {
          p.userMin = a;
          p.userMax = b;
          p.eventArgs = e;
          c && l.redraw(f);
        });
      },
      zoom: function (a, b) {
        var c = this.dataMin,
            f = this.dataMax,
            e = this.options,
            p = Math.min(c, z(e.min, c)),
            l = Math.max(f, z(e.max, f));
        a = {
          newMin: a,
          newMax: b
        };
        q(this, "zoom", a, function (b) {
          var a = b.newMin,
              e = b.newMax;
          if (a !== this.min || e !== this.max) this.allowZoomOutside || (t(c) && (a < p && (a = p), a > l && (a = l)), t(f) && (e < p && (e = p), e > l && (e = l))), this.displayBtn = "undefined" !== typeof a || "undefined" !== typeof e, this.setExtremes(a, e, !1, void 0, {
            trigger: "zoom"
          });
          b.zoomed = !0;
        });
        return a.zoomed;
      },
      setAxisSize: function () {
        var a = this.chart,
            b = this.options,
            c = b.offsets || [0, 0, 0, 0],
            f = this.horiz,
            e = this.width = Math.round(w(z(b.width, a.plotWidth - c[3] + c[1]), a.plotWidth)),
            l = this.height = Math.round(w(z(b.height, a.plotHeight - c[0] + c[2]), a.plotHeight)),
            k = this.top = Math.round(w(z(b.top, a.plotTop + c[0]), a.plotHeight, a.plotTop));
        b = this.left = Math.round(w(z(b.left, a.plotLeft + c[3]), a.plotWidth, a.plotLeft));
        this.bottom = a.chartHeight - l - k;
        this.right = a.chartWidth - e - b;
        this.len = Math.max(f ? e : l, 0);
        this.pos = f ? b : k;
      },
      getExtremes: function () {
        var a = this.isLog;
        return {
          min: a ? y(this.lin2log(this.min)) : this.min,
          max: a ? y(this.lin2log(this.max)) : this.max,
          dataMin: this.dataMin,
          dataMax: this.dataMax,
          userMin: this.userMin,
          userMax: this.userMax
        };
      },
      getThreshold: function (a) {
        var b = this.isLog,
            c = b ? this.lin2log(this.min) : this.min;
        b = b ? this.lin2log(this.max) : this.max;
        null === a || -Infinity === a ? a = c : Infinity === a ? a = b : c > a ? a = c : b < a && (a = b);
        return this.translate(a, 0, 1, 0, 1);
      },
      autoLabelAlign: function (a) {
        var b = (z(a, 0) - 90 * this.side + 720) % 360;
        a = {
          align: "center"
        };
        q(this, "autoLabelAlign", a, function (a) {
          15 < b && 165 > b ? a.align = "right" : 195 < b && 345 > b && (a.align = "left");
        });
        return a.align;
      },
      tickSize: function (a) {
        var b = this.options,
            c = b[a + "Length"],
            f = z(b[a + "Width"], "tick" === a && this.isXAxis && !this.categories ? 1 : 0);

        if (f && c) {
          "inside" === b[a + "Position"] && (c = -c);
          var e = [c, f];
        }

        a = {
          tickSize: e
        };
        q(this, "afterTickSize", a);
        return a.tickSize;
      },
      labelMetrics: function () {
        var a = this.tickPositions && this.tickPositions[0] || 0;
        return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);
      },
      unsquish: function () {
        var a = this.options.labels,
            b = this.horiz,
            c = this.tickInterval,
            f = c,
            e = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / c),
            l,
            k = a.rotation,
            v = this.labelMetrics(),
            m,
            d = Number.MAX_VALUE,
            n,
            w = this.max - this.min,
            F = function (b) {
          var a = b / (e || 1);
          a = 1 < a ? Math.ceil(a) : 1;
          a * c > w && Infinity !== b && Infinity !== e && w && (a = Math.ceil(w / c));
          return y(a * c);
        };

        b ? (n = !a.staggerLines && !a.step && (t(k) ? [k] : e < z(a.autoRotationLimit, 80) && a.autoRotation)) && n.forEach(function (b) {
          if (b === k || b && -90 <= b && 90 >= b) {
            m = F(Math.abs(v.h / Math.sin(K * b)));
            var a = m + Math.abs(b / 360);
            a < d && (d = a, l = b, f = m);
          }
        }) : a.step || (f = F(v.h));
        this.autoRotation = n;
        this.labelRotation = z(l, k);
        return f;
      },
      getSlotWidth: function (a) {
        var b = this.chart,
            c = this.horiz,
            f = this.options.labels,
            e = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
            l = b.margin[3];
        return a && a.slotWidth || c && 2 > (f.step || 0) && !f.rotation && (this.staggerLines || 1) * this.len / e || !c && (f.style && parseInt(f.style.width, 10) || l && l - b.spacing[3] || .33 * b.chartWidth);
      },
      renderUnsquish: function () {
        var a = this.chart,
            b = a.renderer,
            c = this.tickPositions,
            e = this.ticks,
            l = this.options.labels,
            k = l && l.style || {},
            v = this.horiz,
            d = this.getSlotWidth(),
            m = Math.max(1, Math.round(d - 2 * (l.padding || 5))),
            n = {},
            w = this.labelMetrics(),
            h = l.style && l.style.textOverflow,
            F = 0;
        f(l.rotation) || (n.rotation = l.rotation || 0);
        c.forEach(function (b) {
          b = e[b];
          b.movedLabel && b.replaceMovedLabel();
          b && b.label && b.label.textPxLength > F && (F = b.label.textPxLength);
        });
        this.maxLabelLength = F;
        if (this.autoRotation) F > m && F > w.h ? n.rotation = this.labelRotation : this.labelRotation = 0;else if (d) {
          var z = m;

          if (!h) {
            var q = "clip";

            for (m = c.length; !v && m--;) {
              var B = c[m];
              if (B = e[B].label) B.styles && "ellipsis" === B.styles.textOverflow ? B.css({
                textOverflow: "clip"
              }) : B.textPxLength > d && B.css({
                width: d + "px"
              }), B.getBBox().height > this.len / c.length - (w.h - w.f) && (B.specificTextOverflow = "ellipsis");
            }
          }
        }
        n.rotation && (z = F > .5 * a.chartHeight ? .33 * a.chartHeight : F, h || (q = "ellipsis"));
        if (this.labelAlign = l.align || this.autoLabelAlign(this.labelRotation)) n.align = this.labelAlign;
        c.forEach(function (b) {
          var a = (b = e[b]) && b.label,
              c = k.width,
              f = {};
          a && (a.attr(n), b.shortenLabel ? b.shortenLabel() : z && !c && "nowrap" !== k.whiteSpace && (z < a.textPxLength || "SPAN" === a.element.tagName) ? (f.width = z, h || (f.textOverflow = a.specificTextOverflow || q), a.css(f)) : a.styles && a.styles.width && !f.width && !c && a.css({
            width: null
          }), delete a.specificTextOverflow, b.rotation = n.rotation);
        }, this);
        this.tickRotCorr = b.rotCorr(w.b, this.labelRotation || 0, 0 !== this.side);
      },
      hasData: function () {
        return this.series.some(function (a) {
          return a.hasData();
        }) || this.options.showEmpty && t(this.min) && t(this.max);
      },
      addTitle: function (c) {
        var b = this.chart.renderer,
            f = this.horiz,
            e = this.opposite,
            l = this.options.title,
            p,
            k = this.chart.styledMode;
        this.axisTitle || ((p = l.textAlign) || (p = (f ? {
          low: "left",
          middle: "center",
          high: "right"
        } : {
          low: e ? "right" : "left",
          middle: "center",
          high: e ? "left" : "right"
        })[l.align]), this.axisTitle = b.text(l.text, 0, 0, l.useHTML).attr({
          zIndex: 7,
          rotation: l.rotation || 0,
          align: p
        }).addClass("highcharts-axis-title"), k || this.axisTitle.css(a(l.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);
        k || l.style.width || this.isRadial || this.axisTitle.css({
          width: this.len
        });
        this.axisTitle[c ? "show" : "hide"](c);
      },
      generateTick: function (a) {
        var b = this.ticks;
        b[a] ? b[a].addLabel() : b[a] = new r(this, a);
      },
      getOffset: function () {
        var a = this,
            b = a.chart,
            c = b.renderer,
            f = a.options,
            e = a.tickPositions,
            l = a.ticks,
            k = a.horiz,
            d = a.side,
            m = b.inverted && !a.isZAxis ? [1, 0, 3, 2][d] : d,
            n,
            w = 0,
            h = 0,
            F = f.title,
            B = f.labels,
            L = 0,
            g = b.axisOffset;
        b = b.clipOffset;
        var H = [-1, 1, 1, -1][d],
            K = f.className,
            Q = a.axisParent;
        var y = a.hasData();
        a.showAxis = n = y || z(f.showEmpty, !0);
        a.staggerLines = a.horiz && B.staggerLines;
        a.axisGroup || (a.gridGroup = c.g("grid").attr({
          zIndex: f.gridZIndex || 1
        }).addClass("highcharts-" + this.coll.toLowerCase() + "-grid " + (K || "")).add(Q), a.axisGroup = c.g("axis").attr({
          zIndex: f.zIndex || 2
        }).addClass("highcharts-" + this.coll.toLowerCase() + " " + (K || "")).add(Q), a.labelGroup = c.g("axis-labels").attr({
          zIndex: B.zIndex || 7
        }).addClass("highcharts-" + a.coll.toLowerCase() + "-labels " + (K || "")).add(Q));
        y || a.isLinked ? (e.forEach(function (b, c) {
          a.generateTick(b, c);
        }), a.renderUnsquish(), a.reserveSpaceDefault = 0 === d || 2 === d || {
          1: "left",
          3: "right"
        }[d] === a.labelAlign, z(B.reserveSpace, "center" === a.labelAlign ? !0 : null, a.reserveSpaceDefault) && e.forEach(function (b) {
          L = Math.max(l[b].getLabelSize(), L);
        }), a.staggerLines && (L *= a.staggerLines), a.labelOffset = L * (a.opposite ? -1 : 1)) : v(l, function (b, a) {
          b.destroy();
          delete l[a];
        });

        if (F && F.text && !1 !== F.enabled && (a.addTitle(n), n && !1 !== F.reserveSpace)) {
          a.titleOffset = w = a.axisTitle.getBBox()[k ? "height" : "width"];
          var u = F.offset;
          h = t(u) ? 0 : z(F.margin, k ? 5 : 10);
        }

        a.renderLine();
        a.offset = H * z(f.offset, g[d] ? g[d] + (f.margin || 0) : 0);
        a.tickRotCorr = a.tickRotCorr || {
          x: 0,
          y: 0
        };
        c = 0 === d ? -a.labelMetrics().h : 2 === d ? a.tickRotCorr.y : 0;
        h = Math.abs(L) + h;
        L && (h = h - c + H * (k ? z(B.y, a.tickRotCorr.y + 8 * H) : B.x));
        a.axisTitleMargin = z(u, h);
        a.getMaxLabelDimensions && (a.maxLabelDimensions = a.getMaxLabelDimensions(l, e));
        k = this.tickSize("tick");
        g[d] = Math.max(g[d], a.axisTitleMargin + w + H * a.offset, h, e && e.length && k ? k[0] + H * a.offset : 0);
        f = f.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);
        b[m] = Math.max(b[m], f);
        q(this, "afterGetOffset");
      },
      getLinePath: function (a) {
        var b = this.chart,
            c = this.opposite,
            f = this.offset,
            e = this.horiz,
            l = this.left + (c ? this.width : 0) + f;
        f = b.chartHeight - this.bottom - (c ? this.height : 0) + f;
        c && (a *= -1);
        return b.renderer.crispLine(["M", e ? this.left : l, e ? f : this.top, "L", e ? b.chartWidth - this.right : l, e ? f : b.chartHeight - this.bottom], a);
      },
      renderLine: function () {
        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
          stroke: this.options.lineColor,
          "stroke-width": this.options.lineWidth,
          zIndex: 7
        }));
      },
      getTitlePosition: function () {
        var a = this.horiz,
            b = this.left,
            c = this.top,
            f = this.len,
            e = this.options.title,
            l = a ? b : c,
            k = this.opposite,
            d = this.offset,
            m = e.x || 0,
            v = e.y || 0,
            n = this.axisTitle,
            w = this.chart.renderer.fontMetrics(e.style && e.style.fontSize, n);
        n = Math.max(n.getBBox(null, 0).height - w.h - 1, 0);
        f = {
          low: l + (a ? 0 : f),
          middle: l + f / 2,
          high: l + (a ? f : 0)
        }[e.align];
        b = (a ? c + this.height : b) + (a ? 1 : -1) * (k ? -1 : 1) * this.axisTitleMargin + [-n, n, w.f, -n][this.side];
        a = {
          x: a ? f + m : b + (k ? this.width : 0) + d + m,
          y: a ? b + v - (k ? this.height : 0) + d : f + v
        };
        q(this, "afterGetTitlePosition", {
          titlePosition: a
        });
        return a;
      },
      renderMinorTick: function (a) {
        var b = this.chart.hasRendered && n(this.oldMin),
            c = this.minorTicks;
        c[a] || (c[a] = new r(this, a, "minor"));
        b && c[a].isNew && c[a].render(null, !0);
        c[a].render(null, !1, 1);
      },
      renderTick: function (a, b) {
        var c = this.isLinked,
            f = this.ticks,
            e = this.chart.hasRendered && n(this.oldMin);
        if (!c || a >= this.min && a <= this.max) f[a] || (f[a] = new r(this, a)), e && f[a].isNew && f[a].render(b, !0, -1), f[a].render(b);
      },
      render: function () {
        var a = this,
            b = a.chart,
            c = a.options,
            f = a.isLog,
            e = a.isLinked,
            l = a.tickPositions,
            k = a.axisTitle,
            w = a.ticks,
            m = a.minorTicks,
            h = a.alternateBands,
            z = c.stackLabels,
            B = c.alternateGridColor,
            F = a.tickmarkOffset,
            L = a.axisLine,
            t = a.showAxis,
            g = E(b.renderer.globalAnimation),
            H,
            K;
        a.labelEdge.length = 0;
        a.overlap = !1;
        [w, m, h].forEach(function (b) {
          v(b, function (b) {
            b.isActive = !1;
          });
        });
        if (a.hasData() || e) a.minorTickInterval && !a.categories && a.getMinorTickPositions().forEach(function (b) {
          a.renderMinorTick(b);
        }), l.length && (l.forEach(function (b, c) {
          a.renderTick(b, c);
        }), F && (0 === a.min || a.single) && (w[-1] || (w[-1] = new r(a, -1, null, !0)), w[-1].render(-1))), B && l.forEach(function (c, e) {
          K = "undefined" !== typeof l[e + 1] ? l[e + 1] + F : a.max - F;
          0 === e % 2 && c < a.max && K <= a.max + (b.polar ? -F : F) && (h[c] || (h[c] = new d.PlotLineOrBand(a)), H = c + F, h[c].options = {
            from: f ? a.lin2log(H) : H,
            to: f ? a.lin2log(K) : K,
            color: B
          }, h[c].render(), h[c].isActive = !0);
        }), a._addedPlotLB || ((c.plotLines || []).concat(c.plotBands || []).forEach(function (b) {
          a.addPlotBandOrLine(b);
        }), a._addedPlotLB = !0);
        [w, m, h].forEach(function (a) {
          var c,
              f = [],
              e = g.duration;
          v(a, function (b, a) {
            b.isActive || (b.render(a, !1, 0), b.isActive = !1, f.push(a));
          });
          Q(function () {
            for (c = f.length; c--;) a[f[c]] && !a[f[c]].isActive && (a[f[c]].destroy(), delete a[f[c]]);
          }, a !== h && b.hasRendered && e ? e : 0);
        });
        L && (L[L.isPlaced ? "animate" : "attr"]({
          d: this.getLinePath(L.strokeWidth())
        }), L.isPlaced = !0, L[t ? "show" : "hide"](t));
        k && t && (c = a.getTitlePosition(), n(c.y) ? (k[k.isNew ? "attr" : "animate"](c), k.isNew = !1) : (k.attr("y", -9999), k.isNew = !0));
        z && z.enabled && a.renderStackTotals();
        a.isDirty = !1;
        q(this, "afterRender");
      },
      redraw: function () {
        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (a) {
          a.render();
        }));
        this.series.forEach(function (a) {
          a.isDirty = !0;
        });
      },
      keepProps: "extKey hcEvents names series userMax userMin".split(" "),
      destroy: function (a) {
        var b = this,
            c = b.stacks,
            f = b.plotLinesAndBands,
            e;
        q(this, "destroy", {
          keepEvents: a
        });
        a || B(b);
        v(c, function (b, a) {
          D(b);
          c[a] = null;
        });
        [b.ticks, b.minorTicks, b.alternateBands].forEach(function (b) {
          D(b);
        });
        if (f) for (a = f.length; a--;) f[a].destroy();
        "stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (a) {
          b[a] && (b[a] = b[a].destroy());
        });

        for (e in b.plotLinesAndBandsGroups) b.plotLinesAndBandsGroups[e] = b.plotLinesAndBandsGroups[e].destroy();

        v(b, function (a, c) {
          -1 === b.keepProps.indexOf(c) && delete b[c];
        });
      },
      drawCrosshair: function (a, b) {
        var c = this.crosshair,
            f = z(c.snap, !0),
            e,
            l = this.cross,
            k = this.chart;
        q(this, "drawCrosshair", {
          e: a,
          point: b
        });
        a || (a = this.cross && this.cross.e);

        if (this.crosshair && !1 !== (t(b) || !f)) {
          f ? t(b) && (e = z("colorAxis" !== this.coll ? b.crosshairPos : null, this.isXAxis ? b.plotX : this.len - b.plotY)) : e = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);

          if (t(e)) {
            var d = {
              value: b && (this.isXAxis ? b.x : z(b.stackY, b.y)),
              translatedValue: e
            };
            k.polar && N(d, {
              isCrosshair: !0,
              chartX: a && a.chartX,
              chartY: a && a.chartY,
              point: b
            });
            d = this.getPlotLinePath(d) || null;
          }

          if (!t(d)) {
            this.hideCrosshair();
            return;
          }

          f = this.categories && !this.isRadial;
          l || (this.cross = l = k.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (f ? "category " : "thin ") + c.className).attr({
            zIndex: z(c.zIndex, 2)
          }).add(), k.styledMode || (l.attr({
            stroke: c.color || (f ? I("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
            "stroke-width": z(c.width, 1)
          }).css({
            "pointer-events": "none"
          }), c.dashStyle && l.attr({
            dashstyle: c.dashStyle
          })));
          l.show().attr({
            d: d
          });
          f && !c.width && l.attr({
            "stroke-width": this.transA
          });
          this.cross.e = a;
        } else this.hideCrosshair();

        q(this, "afterDrawCrosshair", {
          e: a,
          point: b
        });
      },
      hideCrosshair: function () {
        this.cross && this.cross.hide();
        q(this, "afterHideCrosshair");
      }
    });
    return d.Axis = g;
  });
  S(r, "parts/DateTimeAxis.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.getMagnitude,
        u = g.normalizeTickInterval,
        I = g.timeUnits;
    d = d.Axis;

    d.prototype.getTimeTicks = function () {
      return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
    };

    d.prototype.normalizeTimeTickInterval = function (d, g) {
      var A = g || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
      g = A[A.length - 1];
      var G = I[g[0]],
          E = g[1],
          y;

      for (y = 0; y < A.length && !(g = A[y], G = I[g[0]], E = g[1], A[y + 1] && d <= (G * E[E.length - 1] + I[A[y + 1][0]]) / 2); y++);

      G === I.year && d < 5 * G && (E = [1, 2, 5]);
      d = u(d / G, E, "year" === g[0] ? Math.max(r(d / G), 1) : 1);
      return {
        unitRange: G,
        count: d,
        unitName: g[0]
      };
    };
  });
  S(r, "parts/LogarithmicAxis.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.getMagnitude,
        u = g.normalizeTickInterval,
        I = g.pick;
    d = d.Axis;

    d.prototype.getLogTickPositions = function (d, g, A, G) {
      var E = this.options,
          y = this.len,
          t = [];
      G || (this._minorAutoInterval = null);
      if (.5 <= d) d = Math.round(d), t = this.getLinearTickPositions(d, g, A);else if (.08 <= d) {
        y = Math.floor(g);
        var D, h;

        for (E = .3 < d ? [1, 2, 4] : .15 < d ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; y < A + 1 && !h; y++) {
          var N = E.length;

          for (D = 0; D < N && !h; D++) {
            var q = this.log2lin(this.lin2log(y) * E[D]);
            q > g && (!G || P <= A) && "undefined" !== typeof P && t.push(P);
            P > A && (h = !0);
            var P = q;
          }
        }
      } else g = this.lin2log(g), A = this.lin2log(A), d = G ? this.getMinorTickInterval() : E.tickInterval, d = I("auto" === d ? null : d, this._minorAutoInterval, E.tickPixelInterval / (G ? 5 : 1) * (A - g) / ((G ? y / this.tickPositions.length : y) || 1)), d = u(d, null, r(d)), t = this.getLinearTickPositions(d, g, A).map(this.log2lin), G || (this._minorAutoInterval = d / 5);
      G || (this.tickInterval = d);
      return t;
    };

    d.prototype.log2lin = function (d) {
      return Math.log(d) / Math.LN10;
    };

    d.prototype.lin2log = function (d) {
      return Math.pow(10, d);
    };
  });
  S(r, "parts/PlotLineOrBand.js", [r["parts/Globals.js"], r["parts/Axis.js"], r["parts/Utilities.js"]], function (d, g, r) {
    var u = r.arrayMax,
        I = r.arrayMin,
        M = r.defined,
        E = r.destroyObjectProperties,
        A = r.erase,
        G = r.extend,
        J = r.merge,
        y = r.objectEach,
        t = r.pick,
        D = function () {
      function h(d, h) {
        this.axis = d;
        h && (this.options = h, this.id = h.id);
      }

      h.prototype.render = function () {
        d.fireEvent(this, "render");
        var h = this,
            q = h.axis,
            g = q.horiz,
            e = h.options,
            c = e.label,
            k = h.label,
            n = e.to,
            f = e.from,
            a = e.value,
            l = M(f) && M(n),
            v = M(a),
            z = h.svgElem,
            w = !z,
            B = [],
            L = e.color,
            Q = t(e.zIndex, 0),
            H = e.events;
        B = {
          "class": "highcharts-plot-" + (l ? "band " : "line ") + (e.className || "")
        };
        var K = {},
            p = q.chart.renderer,
            b = l ? "bands" : "lines";
        q.isLog && (f = q.log2lin(f), n = q.log2lin(n), a = q.log2lin(a));
        q.chart.styledMode || (v ? (B.stroke = L || "#999999", B["stroke-width"] = t(e.width, 1), e.dashStyle && (B.dashstyle = e.dashStyle)) : l && (B.fill = L || "#e6ebf5", e.borderWidth && (B.stroke = e.borderColor, B["stroke-width"] = e.borderWidth)));
        K.zIndex = Q;
        b += "-" + Q;
        (L = q.plotLinesAndBandsGroups[b]) || (q.plotLinesAndBandsGroups[b] = L = p.g("plot-" + b).attr(K).add());
        w && (h.svgElem = z = p.path().attr(B).add(L));
        if (v) B = q.getPlotLinePath({
          value: a,
          lineWidth: z.strokeWidth(),
          acrossPanes: e.acrossPanes
        });else if (l) B = q.getPlotBandPath(f, n, e);else return;
        (w || !z.d) && B && B.length ? (z.attr({
          d: B
        }), H && y(H, function (b, a) {
          z.on(a, function (b) {
            H[a].apply(h, [b]);
          });
        })) : z && (B ? (z.show(!0), z.animate({
          d: B
        })) : z.d && (z.hide(), k && (h.label = k = k.destroy())));
        c && (M(c.text) || M(c.formatter)) && B && B.length && 0 < q.width && 0 < q.height && !B.isFlat ? (c = J({
          align: g && l && "center",
          x: g ? !l && 4 : 10,
          verticalAlign: !g && l && "middle",
          y: g ? l ? 16 : 10 : l ? 6 : -4,
          rotation: g && !l && 90
        }, c), this.renderLabel(c, B, l, Q)) : k && k.hide();
        return h;
      };

      h.prototype.renderLabel = function (d, h, g, e) {
        var c = this.label,
            k = this.axis.chart.renderer;
        c || (c = {
          align: d.textAlign || d.align,
          rotation: d.rotation,
          "class": "highcharts-plot-" + (g ? "band" : "line") + "-label " + (d.className || "")
        }, c.zIndex = e, e = this.getLabelText(d), this.label = c = k.text(e, 0, 0, d.useHTML).attr(c).add(), this.axis.chart.styledMode || c.css(d.style));
        k = h.xBounds || [h[1], h[4], g ? h[6] : h[1]];
        h = h.yBounds || [h[2], h[5], g ? h[7] : h[2]];
        g = I(k);
        e = I(h);
        c.align(d, !1, {
          x: g,
          y: e,
          width: u(k) - g,
          height: u(h) - e
        });
        c.show(!0);
      };

      h.prototype.getLabelText = function (d) {
        return M(d.formatter) ? d.formatter.call(this) : d.text;
      };

      h.prototype.destroy = function () {
        A(this.axis.plotLinesAndBands, this);
        delete this.axis;
        E(this);
      };

      return h;
    }();

    G(g.prototype, {
      getPlotBandPath: function (d, g) {
        var h = this.getPlotLinePath({
          value: g,
          force: !0,
          acrossPanes: this.options.acrossPanes
        }),
            t = this.getPlotLinePath({
          value: d,
          force: !0,
          acrossPanes: this.options.acrossPanes
        }),
            e = [],
            c = this.horiz,
            k = 1;
        d = d < this.min && g < this.min || d > this.max && g > this.max;

        if (t && h) {
          if (d) {
            var n = t.toString() === h.toString();
            k = 0;
          }

          for (d = 0; d < t.length; d += 6) c && h[d + 1] === t[d + 1] ? (h[d + 1] += k, h[d + 4] += k) : c || h[d + 2] !== t[d + 2] || (h[d + 2] += k, h[d + 5] += k), e.push("M", t[d + 1], t[d + 2], "L", t[d + 4], t[d + 5], h[d + 4], h[d + 5], h[d + 1], h[d + 2], "z"), e.isFlat = n;
        }

        return e;
      },
      addPlotBand: function (d) {
        return this.addPlotBandOrLine(d, "plotBands");
      },
      addPlotLine: function (d) {
        return this.addPlotBandOrLine(d, "plotLines");
      },
      addPlotBandOrLine: function (d, g) {
        var h = new D(this, d).render(),
            t = this.userOptions;

        if (h) {
          if (g) {
            var e = t[g] || [];
            e.push(d);
            t[g] = e;
          }

          this.plotLinesAndBands.push(h);
        }

        return h;
      },
      removePlotBandOrLine: function (d) {
        for (var h = this.plotLinesAndBands, q = this.options, g = this.userOptions, e = h.length; e--;) h[e].id === d && h[e].destroy();

        [q.plotLines || [], g.plotLines || [], q.plotBands || [], g.plotBands || []].forEach(function (c) {
          for (e = c.length; e--;) c[e].id === d && A(c, c[e]);
        });
      },
      removePlotBand: function (d) {
        this.removePlotBandOrLine(d);
      },
      removePlotLine: function (d) {
        this.removePlotBandOrLine(d);
      }
    });
    d.PlotLineOrBand = D;
    return d.PlotLineOrBand;
  });
  S(r, "parts/Tooltip.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.clamp,
        u = g.css,
        I = g.defined,
        M = g.discardElement,
        E = g.extend,
        A = g.format,
        G = g.isNumber,
        J = g.isString,
        y = g.merge,
        t = g.pick,
        D = g.splat,
        h = g.syncTimeout,
        N = g.timeUnits;
    "";

    var q = d.doc,
        P = function () {
      function e(c, e) {
        this.crosshairs = [];
        this.distance = 0;
        this.isHidden = !0;
        this.isSticky = !1;
        this.now = {};
        this.options = {};
        this.outside = !1;
        this.chart = c;
        this.init(c, e);
      }

      e.prototype.applyFilter = function () {
        var c = this.chart;
        c.renderer.definition({
          tagName: "filter",
          id: "drop-shadow-" + c.index,
          opacity: .5,
          children: [{
            tagName: "feGaussianBlur",
            "in": "SourceAlpha",
            stdDeviation: 1
          }, {
            tagName: "feOffset",
            dx: 1,
            dy: 1
          }, {
            tagName: "feComponentTransfer",
            children: [{
              tagName: "feFuncA",
              type: "linear",
              slope: .3
            }]
          }, {
            tagName: "feMerge",
            children: [{
              tagName: "feMergeNode"
            }, {
              tagName: "feMergeNode",
              "in": "SourceGraphic"
            }]
          }]
        });
        c.renderer.definition({
          tagName: "style",
          textContent: ".highcharts-tooltip-" + c.index + "{filter:url(#drop-shadow-" + c.index + ")}"
        });
      };

      e.prototype.bodyFormatter = function (c) {
        return c.map(function (c) {
          var e = c.series.tooltipOptions;
          return (e[(c.point.formatPrefix || "point") + "Formatter"] || c.point.tooltipFormatter).call(c.point, e[(c.point.formatPrefix || "point") + "Format"] || "");
        });
      };

      e.prototype.cleanSplit = function (c) {
        this.chart.series.forEach(function (e) {
          var d = e && e.tt;
          d && (!d.isActive || c ? e.tt = d.destroy() : d.isActive = !1);
        });
      };

      e.prototype.defaultFormatter = function (c) {
        var e = this.points || D(this);
        var d = [c.tooltipFooterHeaderFormatter(e[0])];
        d = d.concat(c.bodyFormatter(e));
        d.push(c.tooltipFooterHeaderFormatter(e[0], !0));
        return d;
      };

      e.prototype.destroy = function () {
        this.label && (this.label = this.label.destroy());
        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());
        this.renderer && (this.renderer = this.renderer.destroy(), M(this.container));
        g.clearTimeout(this.hideTimer);
        g.clearTimeout(this.tooltipTimeout);
      };

      e.prototype.getAnchor = function (c, e) {
        var d = this.chart,
            f = d.pointer,
            a = d.inverted,
            l = d.plotTop,
            k = d.plotLeft,
            h = 0,
            w = 0,
            B,
            q;
        c = D(c);
        this.followPointer && e ? ("undefined" === typeof e.chartX && (e = f.normalize(e)), c = [e.chartX - k, e.chartY - l]) : c[0].tooltipPos ? c = c[0].tooltipPos : (c.forEach(function (c) {
          B = c.series.yAxis;
          q = c.series.xAxis;
          h += c.plotX + (!a && q ? q.left - k : 0);
          w += (c.plotLow ? (c.plotLow + c.plotHigh) / 2 : c.plotY) + (!a && B ? B.top - l : 0);
        }), h /= c.length, w /= c.length, c = [a ? d.plotWidth - w : h, this.shared && !a && 1 < c.length && e ? e.chartY - l : a ? d.plotHeight - h : w]);
        return c.map(Math.round);
      };

      e.prototype.getDateFormat = function (c, e, d, f) {
        var a = this.chart.time,
            l = a.dateFormat("%m-%d %H:%M:%S.%L", e),
            k = {
          millisecond: 15,
          second: 12,
          minute: 9,
          hour: 6,
          day: 3
        },
            n = "millisecond";

        for (w in N) {
          if (c === N.week && +a.dateFormat("%w", e) === d && "00:00:00.000" === l.substr(6)) {
            var w = "week";
            break;
          }

          if (N[w] > c) {
            w = n;
            break;
          }

          if (k[w] && l.substr(k[w]) !== "01-01 00:00:00.000".substr(k[w])) break;
          "week" !== w && (n = w);
        }

        if (w) var h = a.resolveDTLFormat(f[w]).main;
        return h;
      };

      e.prototype.getLabel = function () {
        var c,
            e = this,
            n = this.chart.renderer,
            f = this.chart.styledMode,
            a = this.options,
            l = "tooltip" + (I(a.className) ? " " + a.className : ""),
            v = (null === (c = a.style) || void 0 === c ? void 0 : c.pointerEvents) || (!this.followPointer && a.stickOnContact ? "auto" : "none"),
            h;

        c = function () {
          e.inContact = !0;
        };

        var w = function () {
          var a = e.chart.hoverSeries;
          e.inContact = !1;
          if (a && a.onMouseOut) a.onMouseOut();
        };

        if (!this.label) {
          this.outside && (this.container = h = d.doc.createElement("div"), h.className = "highcharts-tooltip-container", u(h, {
            position: "absolute",
            top: "1px",
            pointerEvents: v,
            zIndex: 3
          }), d.doc.body.appendChild(h), this.renderer = n = new d.Renderer(h, 0, 0, {}, void 0, void 0, n.styledMode));
          this.split ? this.label = n.g(l) : (this.label = n.label("", 0, 0, a.shape || "callout", null, null, a.useHTML, null, l).attr({
            padding: a.padding,
            r: a.borderRadius
          }), f || this.label.attr({
            fill: a.backgroundColor,
            "stroke-width": a.borderWidth
          }).css(a.style).css({
            pointerEvents: v
          }).shadow(a.shadow));
          f && (this.applyFilter(), this.label.addClass("highcharts-tooltip-" + this.chart.index));

          if (e.outside && !e.split) {
            var B = {
              x: this.label.xSetter,
              y: this.label.ySetter
            };

            this.label.xSetter = function (a, c) {
              B[c].call(this.label, e.distance);
              h.style.left = a + "px";
            };

            this.label.ySetter = function (a, c) {
              B[c].call(this.label, e.distance);
              h.style.top = a + "px";
            };
          }

          this.label.on("mouseenter", c).on("mouseleave", w).attr({
            zIndex: 8
          }).add();
        }

        return this.label;
      };

      e.prototype.getPosition = function (c, e, d) {
        var f = this.chart,
            a = this.distance,
            l = {},
            k = f.inverted && d.h || 0,
            n,
            w = this.outside,
            h = w ? q.documentElement.clientWidth - 2 * a : f.chartWidth,
            g = w ? Math.max(q.body.scrollHeight, q.documentElement.scrollHeight, q.body.offsetHeight, q.documentElement.offsetHeight, q.documentElement.clientHeight) : f.chartHeight,
            Q = f.pointer.getChartPosition(),
            H = f.containerScaling,
            K = function (b) {
          return H ? b * H.scaleX : b;
        },
            p = function (b) {
          return H ? b * H.scaleY : b;
        },
            b = function (b) {
          var l = "x" === b;
          return [b, l ? h : g, l ? c : e].concat(w ? [l ? K(c) : p(e), l ? Q.left - a + K(d.plotX + f.plotLeft) : Q.top - a + p(d.plotY + f.plotTop), 0, l ? h : g] : [l ? c : e, l ? d.plotX + f.plotLeft : d.plotY + f.plotTop, l ? f.plotLeft : f.plotTop, l ? f.plotLeft + f.plotWidth : f.plotTop + f.plotHeight]);
        },
            C = b("y"),
            x = b("x"),
            R = !this.followPointer && t(d.ttBelow, !f.inverted === !!d.negative),
            O = function (b, c, f, e, d, m, v) {
          var n = "y" === b ? p(a) : K(a),
              w = (f - e) / 2,
              x = e < d - a,
              h = d + a + e < c,
              F = d - n - f + w;
          d = d + n - w;
          if (R && h) l[b] = d;else if (!R && x) l[b] = F;else if (x) l[b] = Math.min(v - e, 0 > F - k ? F : F - k);else if (h) l[b] = Math.max(m, d + k + f > c ? d : d + k);else return !1;
        },
            y = function (b, c, f, e, d) {
          var k;
          d < a || d > c - a ? k = !1 : l[b] = d < f / 2 ? 1 : d > c - e / 2 ? c - e - 2 : d - f / 2;
          return k;
        },
            u = function (b) {
          var a = C;
          C = x;
          x = a;
          n = b;
        },
            m = function () {
          !1 !== O.apply(0, C) ? !1 !== y.apply(0, x) || n || (u(!0), m()) : n ? l.x = l.y = 0 : (u(!0), m());
        };

        (f.inverted || 1 < this.len) && u();
        m();
        return l;
      };

      e.prototype.getXDateFormat = function (c, e, d) {
        e = e.dateTimeLabelFormats;
        var f = d && d.closestPointRange;
        return (f ? this.getDateFormat(f, c.x, d.options.startOfWeek, e) : e.day) || e.year;
      };

      e.prototype.hide = function (c) {
        var e = this;
        g.clearTimeout(this.hideTimer);
        c = t(c, this.options.hideDelay, 500);
        this.isHidden || (this.hideTimer = h(function () {
          e.getLabel()[c ? "fadeOut" : "hide"]();
          e.isHidden = !0;
        }, c));
      };

      e.prototype.init = function (c, e) {
        this.chart = c;
        this.options = e;
        this.crosshairs = [];
        this.now = {
          x: 0,
          y: 0
        };
        this.isHidden = !0;
        this.split = e.split && !c.inverted && !c.polar;
        this.shared = e.shared || this.split;
        this.outside = t(e.outside, !(!c.scrollablePixelsX && !c.scrollablePixelsY));
      };

      e.prototype.isStickyOnContact = function () {
        return !(this.followPointer || !this.options.stickOnContact || !this.inContact);
      };

      e.prototype.move = function (c, e, d, f) {
        var a = this,
            l = a.now,
            k = !1 !== a.options.animation && !a.isHidden && (1 < Math.abs(c - l.x) || 1 < Math.abs(e - l.y)),
            n = a.followPointer || 1 < a.len;
        E(l, {
          x: k ? (2 * l.x + c) / 3 : c,
          y: k ? (l.y + e) / 2 : e,
          anchorX: n ? void 0 : k ? (2 * l.anchorX + d) / 3 : d,
          anchorY: n ? void 0 : k ? (l.anchorY + f) / 2 : f
        });
        a.getLabel().attr(l);
        a.drawTracker();
        k && (g.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
          a && a.move(c, e, d, f);
        }, 32));
      };

      e.prototype.refresh = function (c, e) {
        var k = this.chart,
            f = this.options,
            a = c,
            l = {},
            v = [],
            h = f.formatter || this.defaultFormatter;
        l = this.shared;
        var w = k.styledMode;

        if (f.enabled) {
          g.clearTimeout(this.hideTimer);
          this.followPointer = D(a)[0].series.tooltipOptions.followPointer;
          var B = this.getAnchor(a, e);
          e = B[0];
          var q = B[1];
          !l || a.series && a.series.noSharedTooltip ? l = a.getLabelConfig() : (k.pointer.applyInactiveState(a), a.forEach(function (a) {
            a.setState("hover");
            v.push(a.getLabelConfig());
          }), l = {
            x: a[0].category,
            y: a[0].y
          }, l.points = v, a = a[0]);
          this.len = v.length;
          k = h.call(l, this);
          h = a.series;
          this.distance = t(h.tooltipOptions.distance, 16);
          !1 === k ? this.hide() : (this.split ? this.renderSplit(k, D(c)) : (c = this.getLabel(), f.style.width && !w || c.css({
            width: this.chart.spacingBox.width
          }), c.attr({
            text: k && k.join ? k.join("") : k
          }), c.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + t(a.colorIndex, h.colorIndex)), w || c.attr({
            stroke: f.borderColor || a.color || h.color || "#666666"
          }), this.updatePosition({
            plotX: e,
            plotY: q,
            negative: a.negative,
            ttBelow: a.ttBelow,
            h: B[2] || 0
          })), this.isHidden && this.label && this.label.attr({
            opacity: 1
          }).show(), this.isHidden = !1);
          d.fireEvent(this, "refresh");
        }
      };

      e.prototype.renderSplit = function (c, e) {
        function k(b, a, c, f, e) {
          void 0 === e && (e = !0);
          c ? (a = u ? 0 : A, b = r(b - f / 2, O.left, O.right - f)) : (a -= m, b = e ? b - f - C : b + C, b = r(b, e ? b : O.left, O.right));
          return {
            x: b,
            y: a
          };
        }

        var f = this,
            a = f.chart,
            l = f.chart,
            v = l.plotHeight,
            h = l.plotLeft,
            w = l.plotTop,
            B = l.pointer,
            q = l.renderer,
            g = l.scrollablePixelsY,
            H = void 0 === g ? 0 : g;
        g = l.scrollingContainer;
        g = void 0 === g ? {
          scrollLeft: 0,
          scrollTop: 0
        } : g;
        var K = g.scrollLeft,
            p = g.scrollTop,
            b = l.styledMode,
            C = f.distance,
            x = f.options,
            R = f.options.positioner,
            O = {
          left: K,
          right: K + l.chartWidth,
          top: p,
          bottom: p + l.chartHeight
        },
            y = f.getLabel(),
            u = !(!a.xAxis[0] || !a.xAxis[0].opposite),
            m = w + p,
            D = 0,
            A = v - H;
        J(c) && (c = [!1, c]);
        c = c.slice(0, e.length + 1).reduce(function (a, c, l) {
          if (!1 !== c && "" !== c) {
            l = e[l - 1] || {
              isHeader: !0,
              plotX: e[0].plotX,
              plotY: v,
              series: {}
            };
            var d = l.isHeader,
                n = d ? f : l.series,
                F = n.tt,
                z = l.isHeader;
            var B = l.series;
            var g = "highcharts-color-" + t(l.colorIndex, B.colorIndex, "none");
            F || (F = {
              padding: x.padding,
              r: x.borderRadius
            }, b || (F.fill = x.backgroundColor, F["stroke-width"] = x.borderWidth), F = q.label("", 0, 0, x[z ? "headerShape" : "shape"] || "callout", void 0, void 0, x.useHTML).addClass((z ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + g).attr(F).add(y));
            F.isActive = !0;
            F.attr({
              text: c
            });
            b || F.css(x.style).shadow(x.shadow).attr({
              stroke: x.borderColor || l.color || B.color || "#333333"
            });
            c = n.tt = F;
            z = c.getBBox();
            n = z.width + c.strokeWidth();
            d && (D = z.height, A += D, u && (m -= D));
            B = l.plotX;
            B = void 0 === B ? 0 : B;
            g = l.plotY;
            g = void 0 === g ? 0 : g;
            var L = l.series;

            if (l.isHeader) {
              B = h + B;
              var K = w + v / 2;
            } else F = L.xAxis, L = L.yAxis, B = F.pos + r(B, -C, F.len + C), L.pos + g >= p + w && L.pos + g <= p + w + v - H && (K = L.pos + g);

            B = r(B, O.left - C, O.right + C);
            "number" === typeof K ? (z = z.height + 1, g = R ? R.call(f, n, z, l) : k(B, K, d, n), a.push({
              align: R ? 0 : void 0,
              anchorX: B,
              anchorY: K,
              boxWidth: n,
              point: l,
              rank: t(g.rank, d ? 1 : 0),
              size: z,
              target: g.y,
              tt: c,
              x: g.x
            })) : c.isActive = !1;
          }

          return a;
        }, []);
        !R && c.some(function (b) {
          return b.x < O.left;
        }) && (c = c.map(function (b) {
          var a = k(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);
          return E(b, {
            target: a.y,
            x: a.x
          });
        }));
        f.cleanSplit();
        d.distribute(c, A);
        c.forEach(function (b) {
          var a = b.pos;
          b.tt.attr({
            visibility: "undefined" === typeof a ? "hidden" : "inherit",
            x: b.x,
            y: a + m,
            anchorX: b.anchorX,
            anchorY: b.anchorY
          });
        });
        c = f.container;
        a = f.renderer;
        f.outside && c && a && (l = y.getBBox(), a.setSize(l.width + l.x, l.height + l.y, !1), B = B.getChartPosition(), c.style.left = B.left + "px", c.style.top = B.top + "px");
      };

      e.prototype.drawTracker = function () {
        if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {
          var c = this.chart,
              e = this.label,
              d = c.hoverPoint;

          if (e && d) {
            var f = {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            };
            d = this.getAnchor(d);
            var a = e.getBBox();
            d[0] += c.plotLeft - e.translateX;
            d[1] += c.plotTop - e.translateY;
            f.x = Math.min(0, d[0]);
            f.y = Math.min(0, d[1]);
            f.width = 0 > d[0] ? Math.max(Math.abs(d[0]), a.width - d[0]) : Math.max(Math.abs(d[0]), a.width);
            f.height = 0 > d[1] ? Math.max(Math.abs(d[1]), a.height - Math.abs(d[1])) : Math.max(Math.abs(d[1]), a.height);
            this.tracker ? this.tracker.attr(f) : (this.tracker = e.renderer.rect(f).addClass("highcharts-tracker").add(e), c.styledMode || this.tracker.attr({
              fill: "rgba(0,0,0,0)"
            }));
          }
        }
      };

      e.prototype.styledModeFormat = function (c) {
        return c.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
      };

      e.prototype.tooltipFooterHeaderFormatter = function (c, e) {
        var k = e ? "footer" : "header",
            f = c.series,
            a = f.tooltipOptions,
            l = a.xDateFormat,
            v = f.xAxis,
            h = v && "datetime" === v.options.type && G(c.key),
            w = a[k + "Format"];
        e = {
          isFooter: e,
          labelConfig: c
        };
        d.fireEvent(this, "headerFormatter", e, function (e) {
          h && !l && (l = this.getXDateFormat(c, a, v));
          h && l && (c.point && c.point.tooltipDateKeys || ["key"]).forEach(function (a) {
            w = w.replace("{point." + a + "}", "{point." + a + ":" + l + "}");
          });
          f.chart.styledMode && (w = this.styledModeFormat(w));
          e.text = A(w, {
            point: c,
            series: f
          }, this.chart);
        });
        return e.text;
      };

      e.prototype.update = function (c) {
        this.destroy();
        y(!0, this.chart.options.tooltip.userOptions, c);
        this.init(this.chart, y(!0, this.options, c));
      };

      e.prototype.updatePosition = function (c) {
        var e = this.chart,
            d = e.pointer,
            f = this.getLabel(),
            a = c.plotX + e.plotLeft,
            l = c.plotY + e.plotTop;
        d = d.getChartPosition();
        c = (this.options.positioner || this.getPosition).call(this, f.width, f.height, c);

        if (this.outside) {
          var v = (this.options.borderWidth || 0) + 2 * this.distance;
          this.renderer.setSize(f.width + v, f.height + v, !1);
          if (e = e.containerScaling) u(this.container, {
            transform: "scale(" + e.scaleX + ", " + e.scaleY + ")"
          }), a *= e.scaleX, l *= e.scaleY;
          a += d.left - c.x;
          l += d.top - c.y;
        }

        this.move(Math.round(c.x), Math.round(c.y || 0), a, l);
      };

      return e;
    }();

    d.Tooltip = P;
    return d.Tooltip;
  });
  S(r, "parts/Pointer.js", [r["parts/Globals.js"], r["parts/Utilities.js"], r["parts/Tooltip.js"], r["parts/Color.js"]], function (d, g, r, u) {
    var I = g.addEvent,
        M = g.attr,
        E = g.css,
        A = g.defined,
        G = g.extend,
        J = g.find,
        y = g.fireEvent,
        t = g.isNumber,
        D = g.isObject,
        h = g.objectEach,
        N = g.offset,
        q = g.pick,
        P = g.splat,
        e = u.parse,
        c = d.charts,
        k = d.noop;

    g = function () {
      function n(c, a) {
        this.lastValidTouch = {};
        this.pinchDown = [];
        this.runChartClick = !1;
        this.chart = c;
        this.hasDragged = !1;
        this.options = a;

        this.unbindContainerMouseLeave = function () {};

        this.init(c, a);
      }

      n.prototype.applyInactiveState = function (c) {
        var a = [],
            f;
        (c || []).forEach(function (c) {
          f = c.series;
          a.push(f);
          f.linkedParent && a.push(f.linkedParent);
          f.linkedSeries && (a = a.concat(f.linkedSeries));
          f.navigatorSeries && a.push(f.navigatorSeries);
        });
        this.chart.series.forEach(function (c) {
          -1 === a.indexOf(c) ? c.setState("inactive", !0) : c.options.inactiveOtherPoints && c.setAllPointsToState("inactive");
        });
      };

      n.prototype.destroy = function () {
        var c = this;
        "undefined" !== typeof c.unDocMouseMove && c.unDocMouseMove();
        this.unbindContainerMouseLeave();
        d.chartCount || (d.unbindDocumentMouseUp && (d.unbindDocumentMouseUp = d.unbindDocumentMouseUp()), d.unbindDocumentTouchEnd && (d.unbindDocumentTouchEnd = d.unbindDocumentTouchEnd()));
        clearInterval(c.tooltipTimeout);
        h(c, function (a, f) {
          c[f] = null;
        });
      };

      n.prototype.drag = function (c) {
        var a = this.chart,
            f = a.options.chart,
            d = c.chartX,
            k = c.chartY,
            w = this.zoomHor,
            n = this.zoomVert,
            h = a.plotLeft,
            q = a.plotTop,
            g = a.plotWidth,
            t = a.plotHeight,
            p = this.selectionMarker,
            b = this.mouseDownX || 0,
            C = this.mouseDownY || 0,
            x = D(f.panning) ? f.panning && f.panning.enabled : f.panning,
            y = f.panKey && c[f.panKey + "Key"];
        if (!p || !p.touch) if (d < h ? d = h : d > h + g && (d = h + g), k < q ? k = q : k > q + t && (k = q + t), this.hasDragged = Math.sqrt(Math.pow(b - d, 2) + Math.pow(C - k, 2)), 10 < this.hasDragged) {
          var O = a.isInsidePlot(b - h, C - q);
          a.hasCartesianSeries && (this.zoomX || this.zoomY) && O && !y && !p && (this.selectionMarker = p = a.renderer.rect(h, q, w ? 1 : g, n ? 1 : t, 0).attr({
            "class": "highcharts-selection-marker",
            zIndex: 7
          }).add(), a.styledMode || p.attr({
            fill: f.selectionMarkerFill || e("#335cad").setOpacity(.25).get()
          }));
          p && w && (d -= b, p.attr({
            width: Math.abs(d),
            x: (0 < d ? 0 : d) + b
          }));
          p && n && (d = k - C, p.attr({
            height: Math.abs(d),
            y: (0 < d ? 0 : d) + C
          }));
          O && !p && x && a.pan(c, f.panning);
        }
      };

      n.prototype.dragStart = function (c) {
        var a = this.chart;
        a.mouseIsDown = c.type;
        a.cancelClick = !1;
        a.mouseDownX = this.mouseDownX = c.chartX;
        a.mouseDownY = this.mouseDownY = c.chartY;
      };

      n.prototype.drop = function (c) {
        var a = this,
            f = this.chart,
            e = this.hasPinched;

        if (this.selectionMarker) {
          var d = {
            originalEvent: c,
            xAxis: [],
            yAxis: []
          },
              k = this.selectionMarker,
              n = k.attr ? k.attr("x") : k.x,
              h = k.attr ? k.attr("y") : k.y,
              q = k.attr ? k.attr("width") : k.width,
              g = k.attr ? k.attr("height") : k.height,
              K;
          if (this.hasDragged || e) f.axes.forEach(function (f) {
            if (f.zoomEnabled && A(f.min) && (e || a[{
              xAxis: "zoomX",
              yAxis: "zoomY"
            }[f.coll]])) {
              var b = f.horiz,
                  l = "touchend" === c.type ? f.minPixelPadding : 0,
                  k = f.toValue((b ? n : h) + l);
              b = f.toValue((b ? n + q : h + g) - l);
              d[f.coll].push({
                axis: f,
                min: Math.min(k, b),
                max: Math.max(k, b)
              });
              K = !0;
            }
          }), K && y(f, "selection", d, function (a) {
            f.zoom(G(a, e ? {
              animation: !1
            } : null));
          });
          t(f.index) && (this.selectionMarker = this.selectionMarker.destroy());
          e && this.scaleGroups();
        }

        f && t(f.index) && (E(f.container, {
          cursor: f._cursor
        }), f.cancelClick = 10 < this.hasDragged, f.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
      };

      n.prototype.findNearestKDPoint = function (c, a, e) {
        var f = this.chart,
            d = f.hoverPoint;
        f = f.tooltip;
        if (d && f && f.isStickyOnContact()) return d;
        var l;
        c.forEach(function (c) {
          var f = !(c.noSharedTooltip && a) && 0 > c.options.findNearestPointBy.indexOf("y");
          c = c.searchPoint(e, f);

          if ((f = D(c, !0)) && !(f = !D(l, !0))) {
            f = l.distX - c.distX;
            var d = l.dist - c.dist,
                k = (c.series.group && c.series.group.zIndex) - (l.series.group && l.series.group.zIndex);
            f = 0 < (0 !== f && a ? f : 0 !== d ? d : 0 !== k ? k : l.series.index > c.series.index ? -1 : 1);
          }

          f && (l = c);
        });
        return l;
      };

      n.prototype.getChartCoordinatesFromPoint = function (c, a) {
        var f = c.series,
            e = f.xAxis;
        f = f.yAxis;
        var d = q(c.clientX, c.plotX),
            k = c.shapeArgs;
        if (e && f) return a ? {
          chartX: e.len + e.pos - d,
          chartY: f.len + f.pos - c.plotY
        } : {
          chartX: d + e.pos,
          chartY: c.plotY + f.pos
        };
        if (k && k.x && k.y) return {
          chartX: k.x,
          chartY: k.y
        };
      };

      n.prototype.getChartPosition = function () {
        return this.chartPosition || (this.chartPosition = N(this.chart.container));
      };

      n.prototype.getCoordinates = function (c) {
        var a = {
          xAxis: [],
          yAxis: []
        };
        this.chart.axes.forEach(function (f) {
          a[f.isXAxis ? "xAxis" : "yAxis"].push({
            axis: f,
            value: f.toValue(c[f.horiz ? "chartX" : "chartY"])
          });
        });
        return a;
      };

      n.prototype.getHoverData = function (c, a, e, d, k, n) {
        var f,
            l = [];
        d = !(!d || !c);
        var v = a && !a.stickyTracking,
            h = {
          chartX: n ? n.chartX : void 0,
          chartY: n ? n.chartY : void 0,
          shared: k
        };
        y(this, "beforeGetHoverData", h);
        v = v ? [a] : e.filter(function (a) {
          return h.filter ? h.filter(a) : a.visible && !(!k && a.directTouch) && q(a.options.enableMouseTracking, !0) && a.stickyTracking;
        });
        a = (f = d || !n ? c : this.findNearestKDPoint(v, k, n)) && f.series;
        f && (k && !a.noSharedTooltip ? (v = e.filter(function (a) {
          return h.filter ? h.filter(a) : a.visible && !(!k && a.directTouch) && q(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;
        }), v.forEach(function (a) {
          var c = J(a.points, function (b) {
            return b.x === f.x && !b.isNull;
          });
          D(c) && (a.chart.isBoosting && (c = a.getPoint(c)), l.push(c));
        })) : l.push(f));
        h = {
          hoverPoint: f
        };
        y(this, "afterGetHoverData", h);
        return {
          hoverPoint: h.hoverPoint,
          hoverSeries: a,
          hoverPoints: l
        };
      };

      n.prototype.getPointFromEvent = function (c) {
        c = c.target;

        for (var a; c && !a;) a = c.point, c = c.parentNode;

        return a;
      };

      n.prototype.onTrackerMouseOut = function (c) {
        var a = this.chart.hoverSeries;
        c = c.relatedTarget || c.toElement;
        this.isDirectTouch = !1;
        if (!(!a || !c || a.stickyTracking || this.inClass(c, "highcharts-tooltip") || this.inClass(c, "highcharts-series-" + a.index) && this.inClass(c, "highcharts-tracker"))) a.onMouseOut();
      };

      n.prototype.inClass = function (c, a) {
        for (var f; c;) {
          if (f = M(c, "class")) {
            if (-1 !== f.indexOf(a)) return !0;
            if (-1 !== f.indexOf("highcharts-container")) return !1;
          }

          c = c.parentNode;
        }
      };

      n.prototype.init = function (c, a) {
        this.options = a;
        this.chart = c;
        this.runChartClick = a.chart.events && !!a.chart.events.click;
        this.pinchDown = [];
        this.lastValidTouch = {};
        r && (c.tooltip = new r(c, a.tooltip), this.followTouchMove = q(a.tooltip.followTouchMove, !0));
        this.setDOMEvents();
      };

      n.prototype.normalize = function (c, a) {
        var f = c.touches,
            e = f ? f.length ? f.item(0) : f.changedTouches[0] : c;
        a || (a = this.getChartPosition());
        f = e.pageX - a.left;
        a = e.pageY - a.top;
        if (e = this.chart.containerScaling) f /= e.scaleX, a /= e.scaleY;
        return G(c, {
          chartX: Math.round(f),
          chartY: Math.round(a)
        });
      };

      n.prototype.onContainerClick = function (c) {
        var a = this.chart,
            f = a.hoverPoint,
            e = a.plotLeft,
            d = a.plotTop;
        c = this.normalize(c);
        a.cancelClick || (f && this.inClass(c.target, "highcharts-tracker") ? (y(f.series, "click", G(c, {
          point: f
        })), a.hoverPoint && f.firePointEvent("click", c)) : (G(c, this.getCoordinates(c)), a.isInsidePlot(c.chartX - e, c.chartY - d) && y(a, "click", c)));
      };

      n.prototype.onContainerMouseDown = function (c) {
        c = this.normalize(c);
        2 !== c.button && (this.zoomOption(c), c.preventDefault && c.preventDefault(), this.dragStart(c));
      };

      n.prototype.onContainerMouseLeave = function (f) {
        var a = c[d.hoverChartIndex];
        a && (f.relatedTarget || f.toElement) && (a.pointer.reset(), a.pointer.chartPosition = void 0);
      };

      n.prototype.onContainerMouseMove = function (f) {
        var a = this.chart;
        A(d.hoverChartIndex) && c[d.hoverChartIndex] && c[d.hoverChartIndex].mouseIsDown || (d.hoverChartIndex = a.index);
        f = this.normalize(f);
        f.preventDefault || (f.returnValue = !1);
        "mousedown" === a.mouseIsDown && this.drag(f);
        a.openMenu || !this.inClass(f.target, "highcharts-tracker") && !a.isInsidePlot(f.chartX - a.plotLeft, f.chartY - a.plotTop) || this.runPointActions(f);
      };

      n.prototype.onDocumentTouchEnd = function (f) {
        c[d.hoverChartIndex] && c[d.hoverChartIndex].pointer.drop(f);
      };

      n.prototype.onContainerTouchMove = function (c) {
        this.touch(c);
      };

      n.prototype.onContainerTouchStart = function (c) {
        this.zoomOption(c);
        this.touch(c, !0);
      };

      n.prototype.onDocumentMouseMove = function (c) {
        var a = this.chart,
            f = this.chartPosition,
            e = a.tooltip;
        c = this.normalize(c, f);
        !f || e && e.isStickyOnContact() || a.isInsidePlot(c.chartX - a.plotLeft, c.chartY - a.plotTop) || this.inClass(c.target, "highcharts-tracker") || this.reset();
      };

      n.prototype.onDocumentMouseUp = function (f) {
        c[d.hoverChartIndex] && c[d.hoverChartIndex].pointer.drop(f);
      };

      n.prototype.pinch = function (c) {
        var a = this,
            f = a.chart,
            e = a.pinchDown,
            d = c.touches || [],
            n = d.length,
            h = a.lastValidTouch,
            g = a.hasZoom,
            t = a.selectionMarker,
            H = {},
            K = 1 === n && (a.inClass(c.target, "highcharts-tracker") && f.runTrackerClick || a.runChartClick),
            p = {};
        1 < n && (a.initiated = !0);
        g && a.initiated && !K && c.preventDefault();
        [].map.call(d, function (b) {
          return a.normalize(b);
        });
        "touchstart" === c.type ? ([].forEach.call(d, function (b, a) {
          e[a] = {
            chartX: b.chartX,
            chartY: b.chartY
          };
        }), h.x = [e[0].chartX, e[1] && e[1].chartX], h.y = [e[0].chartY, e[1] && e[1].chartY], f.axes.forEach(function (b) {
          if (b.zoomEnabled) {
            var a = f.bounds[b.horiz ? "h" : "v"],
                c = b.minPixelPadding,
                e = b.toPixels(Math.min(q(b.options.min, b.dataMin), b.dataMin)),
                d = b.toPixels(Math.max(q(b.options.max, b.dataMax), b.dataMax)),
                l = Math.max(e, d);
            a.min = Math.min(b.pos, Math.min(e, d) - c);
            a.max = Math.max(b.pos + b.len, l + c);
          }
        }), a.res = !0) : a.followTouchMove && 1 === n ? this.runPointActions(a.normalize(c)) : e.length && (t || (a.selectionMarker = t = G({
          destroy: k,
          touch: !0
        }, f.plotBox)), a.pinchTranslate(e, d, H, t, p, h), a.hasPinched = g, a.scaleGroups(H, p), a.res && (a.res = !1, this.reset(!1, 0)));
      };

      n.prototype.pinchTranslate = function (c, a, e, d, k, n) {
        this.zoomHor && this.pinchTranslateDirection(!0, c, a, e, d, k, n);
        this.zoomVert && this.pinchTranslateDirection(!1, c, a, e, d, k, n);
      };

      n.prototype.pinchTranslateDirection = function (c, a, e, d, k, n, h, q) {
        var f = this.chart,
            l = c ? "x" : "y",
            v = c ? "X" : "Y",
            p = "chart" + v,
            b = c ? "width" : "height",
            w = f["plot" + (c ? "Left" : "Top")],
            x,
            B,
            g = q || 1,
            z = f.inverted,
            t = f.bounds[c ? "h" : "v"],
            m = 1 === a.length,
            L = a[0][p],
            y = e[0][p],
            u = !m && a[1][p],
            F = !m && e[1][p];

        e = function () {
          "number" === typeof F && 20 < Math.abs(L - u) && (g = q || Math.abs(y - F) / Math.abs(L - u));
          B = (w - y) / g + L;
          x = f["plot" + (c ? "Width" : "Height")] / g;
        };

        e();
        a = B;

        if (a < t.min) {
          a = t.min;
          var V = !0;
        } else a + x > t.max && (a = t.max - x, V = !0);

        V ? (y -= .8 * (y - h[l][0]), "number" === typeof F && (F -= .8 * (F - h[l][1])), e()) : h[l] = [y, F];
        z || (n[l] = B - w, n[b] = x);
        n = z ? 1 / g : g;
        k[b] = x;
        k[l] = a;
        d[z ? c ? "scaleY" : "scaleX" : "scale" + v] = g;
        d["translate" + v] = n * w + (y - n * L);
      };

      n.prototype.reset = function (c, a) {
        var f = this.chart,
            e = f.hoverSeries,
            d = f.hoverPoint,
            k = f.hoverPoints,
            n = f.tooltip,
            h = n && n.shared ? k : d;
        c && h && P(h).forEach(function (a) {
          a.series.isCartesian && "undefined" === typeof a.plotX && (c = !1);
        });
        if (c) n && h && P(h).length && (n.refresh(h), n.shared && k ? k.forEach(function (a) {
          a.setState(a.state, !0);
          a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));
        }) : d && (d.setState(d.state, !0), f.axes.forEach(function (a) {
          a.crosshair && d.series[a.coll] === a && a.drawCrosshair(null, d);
        })));else {
          if (d) d.onMouseOut();
          k && k.forEach(function (a) {
            a.setState();
          });
          if (e) e.onMouseOut();
          n && n.hide(a);
          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
          f.axes.forEach(function (a) {
            a.hideCrosshair();
          });
          this.hoverX = f.hoverPoints = f.hoverPoint = null;
        }
      };

      n.prototype.runPointActions = function (f, a) {
        var e = this.chart,
            k = e.tooltip && e.tooltip.options.enabled ? e.tooltip : void 0,
            n = k ? k.shared : !1,
            h = a || e.hoverPoint,
            g = h && h.series || e.hoverSeries;
        g = this.getHoverData(h, g, e.series, (!f || "touchmove" !== f.type) && (!!a || g && g.directTouch && this.isDirectTouch), n, f);
        h = g.hoverPoint;
        var t = g.hoverPoints;
        a = (g = g.hoverSeries) && g.tooltipOptions.followPointer;
        n = n && g && !g.noSharedTooltip;

        if (h && (h !== e.hoverPoint || k && k.isHidden)) {
          (e.hoverPoints || []).forEach(function (a) {
            -1 === t.indexOf(a) && a.setState();
          });
          if (e.hoverSeries !== g) g.onMouseOver();
          this.applyInactiveState(t);
          (t || []).forEach(function (a) {
            a.setState("hover");
          });
          e.hoverPoint && e.hoverPoint.firePointEvent("mouseOut");
          if (!h.series) return;
          h.firePointEvent("mouseOver");
          e.hoverPoints = t;
          e.hoverPoint = h;
          k && k.refresh(n ? t : h, f);
        } else a && k && !k.isHidden && (h = k.getAnchor([{}], f), k.updatePosition({
          plotX: h[0],
          plotY: h[1]
        }));

        this.unDocMouseMove || (this.unDocMouseMove = I(e.container.ownerDocument, "mousemove", function (a) {
          var f = c[d.hoverChartIndex];
          if (f) f.pointer.onDocumentMouseMove(a);
        }));
        e.axes.forEach(function (a) {
          var c = q(a.crosshair.snap, !0),
              e = c ? J(t, function (c) {
            return c.series[a.coll] === a;
          }) : void 0;
          e || !c ? a.drawCrosshair(f, e) : a.hideCrosshair();
        });
      };

      n.prototype.scaleGroups = function (c, a) {
        var f = this.chart,
            e;
        f.series.forEach(function (d) {
          e = c || d.getPlotBox();
          d.xAxis && d.xAxis.zoomEnabled && d.group && (d.group.attr(e), d.markerGroup && (d.markerGroup.attr(e), d.markerGroup.clip(a ? f.clipRect : null)), d.dataLabelsGroup && d.dataLabelsGroup.attr(e));
        });
        f.clipRect.attr(a || f.clipBox);
      };

      n.prototype.setDOMEvents = function () {
        var c = this,
            a = c.chart.container,
            e = a.ownerDocument;

        a.onmousedown = function (a) {
          c.onContainerMouseDown(a);
        };

        a.onmousemove = function (a) {
          c.onContainerMouseMove(a);
        };

        a.onclick = function (a) {
          c.onContainerClick(a);
        };

        this.unbindContainerMouseLeave = I(a, "mouseleave", c.onContainerMouseLeave);
        d.unbindDocumentMouseUp || (d.unbindDocumentMouseUp = I(e, "mouseup", c.onDocumentMouseUp));
        d.hasTouch && (I(a, "touchstart", function (a) {
          c.onContainerTouchStart(a);
        }), I(a, "touchmove", function (a) {
          c.onContainerTouchMove(a);
        }), d.unbindDocumentTouchEnd || (d.unbindDocumentTouchEnd = I(e, "touchend", c.onDocumentTouchEnd)));
      };

      n.prototype.touch = function (c, a) {
        var f = this.chart,
            e;
        if (f.index !== d.hoverChartIndex) this.onContainerMouseLeave({
          relatedTarget: !0
        });
        d.hoverChartIndex = f.index;
        if (1 === c.touches.length) {
          if (c = this.normalize(c), (e = f.isInsidePlot(c.chartX - f.plotLeft, c.chartY - f.plotTop)) && !f.openMenu) {
            a && this.runPointActions(c);

            if ("touchmove" === c.type) {
              a = this.pinchDown;
              var k = a[0] ? 4 <= Math.sqrt(Math.pow(a[0].chartX - c.chartX, 2) + Math.pow(a[0].chartY - c.chartY, 2)) : !1;
            }

            q(k, !0) && this.pinch(c);
          } else a && this.reset();
        } else 2 === c.touches.length && this.pinch(c);
      };

      n.prototype.zoomOption = function (c) {
        var a = this.chart,
            f = a.options.chart,
            e = f.zoomType || "";
        a = a.inverted;
        /touch/.test(c.type) && (e = q(f.pinchType, e));
        this.zoomX = c = /x/.test(e);
        this.zoomY = e = /y/.test(e);
        this.zoomHor = c && !a || e && a;
        this.zoomVert = e && !a || c && a;
        this.hasZoom = c || e;
      };

      return n;
    }();

    d.Pointer = g;
    return d.Pointer;
  });
  S(r, "parts/MSPointer.js", [r["parts/Globals.js"], r["parts/Pointer.js"], r["parts/Utilities.js"]], function (d, g, r) {
    function u() {
      var d = [];

      d.item = function (d) {
        return this[d];
      };

      G(h, function (h) {
        d.push({
          pageX: h.pageX,
          pageY: h.pageY,
          target: h.target
        });
      });
      return d;
    }

    function I(h, g, e, c) {
      "touch" !== h.pointerType && h.pointerType !== h.MSPOINTER_TYPE_TOUCH || !y[d.hoverChartIndex] || (c(h), c = y[d.hoverChartIndex].pointer, c[g]({
        type: e,
        target: h.currentTarget,
        preventDefault: D,
        touches: u()
      }));
    }

    var M = this && this.__extends || function () {
      var d = function (h, e) {
        d = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (c, e) {
          c.__proto__ = e;
        } || function (c, e) {
          for (var d in e) e.hasOwnProperty(d) && (c[d] = e[d]);
        };

        return d(h, e);
      };

      return function (h, e) {
        function c() {
          this.constructor = h;
        }

        d(h, e);
        h.prototype = null === e ? Object.create(e) : (c.prototype = e.prototype, new c());
      };
    }(),
        E = r.addEvent,
        A = r.css,
        G = r.objectEach,
        J = r.removeEvent,
        y = d.charts,
        t = d.doc,
        D = d.noop,
        h = {},
        N = !!d.win.PointerEvent;

    return function (d) {
      function g() {
        return null !== d && d.apply(this, arguments) || this;
      }

      M(g, d);

      g.prototype.batchMSEvents = function (e) {
        e(this.chart.container, N ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
        e(this.chart.container, N ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
        e(t, N ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
      };

      g.prototype.destroy = function () {
        this.batchMSEvents(J);
        d.prototype.destroy.call(this);
      };

      g.prototype.init = function (e, c) {
        d.prototype.init.call(this, e, c);
        this.hasZoom && A(e.container, {
          "-ms-touch-action": "none",
          "touch-action": "none"
        });
      };

      g.prototype.onContainerPointerDown = function (e) {
        I(e, "onContainerTouchStart", "touchstart", function (c) {
          h[c.pointerId] = {
            pageX: c.pageX,
            pageY: c.pageY,
            target: c.currentTarget
          };
        });
      };

      g.prototype.onContainerPointerMove = function (e) {
        I(e, "onContainerTouchMove", "touchmove", function (c) {
          h[c.pointerId] = {
            pageX: c.pageX,
            pageY: c.pageY
          };
          h[c.pointerId].target || (h[c.pointerId].target = c.currentTarget);
        });
      };

      g.prototype.onDocumentPointerUp = function (e) {
        I(e, "onDocumentTouchEnd", "touchend", function (c) {
          delete h[c.pointerId];
        });
      };

      g.prototype.setDOMEvents = function () {
        d.prototype.setDOMEvents.call(this);
        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(E);
      };

      return g;
    }(g);
  });
  S(r, "parts/Legend.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.addEvent,
        u = g.css,
        I = g.defined,
        M = g.discardElement,
        E = g.find,
        A = g.fireEvent,
        G = g.format,
        J = g.isNumber,
        y = g.merge,
        t = g.pick,
        D = g.relativeLength,
        h = g.setAnimation,
        N = g.stableSort,
        q = g.syncTimeout;
    g = g.wrap;

    var P = d.isFirefox,
        e = d.marginNames,
        c = d.win,
        k = function () {
      function c(c, a) {
        this.allItems = [];
        this.contentGroup = this.box = void 0;
        this.display = !1;
        this.group = void 0;
        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
        this.options = {};
        this.padding = 0;
        this.pages = [];
        this.proximate = !1;
        this.scrollGroup = void 0;
        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
        this.chart = c;
        this.init(c, a);
      }

      c.prototype.init = function (c, a) {
        this.chart = c;
        this.setOptions(a);
        a.enabled && (this.render(), r(this.chart, "endResize", function () {
          this.legend.positionCheckboxes();
        }), this.proximate ? this.unchartrender = r(this.chart, "render", function () {
          this.legend.proximatePositions();
          this.legend.positionItems();
        }) : this.unchartrender && this.unchartrender());
      };

      c.prototype.setOptions = function (c) {
        var a = t(c.padding, 8);
        this.options = c;
        this.chart.styledMode || (this.itemStyle = c.itemStyle, this.itemHiddenStyle = y(this.itemStyle, c.itemHiddenStyle));
        this.itemMarginTop = c.itemMarginTop || 0;
        this.itemMarginBottom = c.itemMarginBottom || 0;
        this.padding = a;
        this.initialItemY = a - 5;
        this.symbolWidth = t(c.symbolWidth, 16);
        this.pages = [];
        this.proximate = "proximate" === c.layout && !this.chart.inverted;
        this.baseline = void 0;
      };

      c.prototype.update = function (c, a) {
        var f = this.chart;
        this.setOptions(y(!0, this.options, c));
        this.destroy();
        f.isDirtyLegend = f.isDirtyBox = !0;
        t(a, !0) && f.redraw();
        A(this, "afterUpdate");
      };

      c.prototype.colorizeItem = function (c, a) {
        c.legendGroup[a ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");

        if (!this.chart.styledMode) {
          var f = this.options,
              e = c.legendItem,
              d = c.legendLine,
              k = c.legendSymbol,
              h = this.itemHiddenStyle.color;
          f = a ? f.itemStyle.color : h;
          var n = a ? c.color || h : h,
              g = c.options && c.options.marker,
              q = {
            fill: n
          };
          e && e.css({
            fill: f,
            color: f
          });
          d && d.attr({
            stroke: n
          });
          k && (g && k.isMarker && (q = c.pointAttribs(), a || (q.stroke = q.fill = h)), k.attr(q));
        }

        A(this, "afterColorizeItem", {
          item: c,
          visible: a
        });
      };

      c.prototype.positionItems = function () {
        this.allItems.forEach(this.positionItem, this);
        this.chart.isResizing || this.positionCheckboxes();
      };

      c.prototype.positionItem = function (c) {
        var a = this.options,
            f = a.symbolPadding;
        a = !a.rtl;
        var e = c._legendItemPos,
            d = e[0];
        e = e[1];
        var k = c.checkbox;
        if ((c = c.legendGroup) && c.element) c[I(c.translateY) ? "animate" : "attr"]({
          translateX: a ? d : this.legendWidth - d - 2 * f - 4,
          translateY: e
        });
        k && (k.x = d, k.y = e);
      };

      c.prototype.destroyItem = function (c) {
        var a = c.checkbox;
        ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function (a) {
          c[a] && (c[a] = c[a].destroy());
        });
        a && M(c.checkbox);
      };

      c.prototype.destroy = function () {
        function c(a) {
          this[a] && (this[a] = this[a].destroy());
        }

        this.getAllItems().forEach(function (a) {
          ["legendItem", "legendGroup"].forEach(c, a);
        });
        "clipRect up down pager nav box title group".split(" ").forEach(c, this);
        this.display = null;
      };

      c.prototype.positionCheckboxes = function () {
        var c = this.group && this.group.alignAttr,
            a = this.clipHeight || this.legendHeight,
            e = this.titleHeight;

        if (c) {
          var d = c.translateY;
          this.allItems.forEach(function (f) {
            var k = f.checkbox;

            if (k) {
              var l = d + e + k.y + (this.scrollOffset || 0) + 3;
              u(k, {
                left: c.translateX + f.checkboxOffset + k.x - 20 + "px",
                top: l + "px",
                display: this.proximate || l > d - 6 && l < d + a - 6 ? "" : "none"
              });
            }
          }, this);
        }
      };

      c.prototype.renderTitle = function () {
        var c = this.options,
            a = this.padding,
            e = c.title,
            d = 0;
        e.text && (this.title || (this.title = this.chart.renderer.label(e.text, a - 3, a - 4, null, null, null, c.useHTML, null, "legend-title").attr({
          zIndex: 1
        }), this.chart.styledMode || this.title.css(e.style), this.title.add(this.group)), e.width || this.title.css({
          width: this.maxLegendWidth + "px"
        }), c = this.title.getBBox(), d = c.height, this.offsetWidth = c.width, this.contentGroup.attr({
          translateY: d
        }));
        this.titleHeight = d;
      };

      c.prototype.setText = function (c) {
        var a = this.options;
        c.legendItem.attr({
          text: a.labelFormat ? G(a.labelFormat, c, this.chart) : a.labelFormatter.call(c)
        });
      };

      c.prototype.renderItem = function (c) {
        var a = this.chart,
            e = a.renderer,
            f = this.options,
            d = this.symbolWidth,
            k = f.symbolPadding,
            h = this.itemStyle,
            n = this.itemHiddenStyle,
            g = "horizontal" === f.layout ? t(f.itemDistance, 20) : 0,
            q = !f.rtl,
            K = c.legendItem,
            p = !c.series,
            b = !p && c.series.drawLegendSymbol ? c.series : c,
            C = b.options;
        C = this.createCheckboxForItem && C && C.showCheckbox;
        g = d + k + g + (C ? 20 : 0);
        var x = f.useHTML,
            R = c.options.className;
        K || (c.legendGroup = e.g("legend-item").addClass("highcharts-" + b.type + "-series highcharts-color-" + c.colorIndex + (R ? " " + R : "") + (p ? " highcharts-series-" + c.index : "")).attr({
          zIndex: 1
        }).add(this.scrollGroup), c.legendItem = K = e.text("", q ? d + k : -k, this.baseline || 0, x), a.styledMode || K.css(y(c.visible ? h : n)), K.attr({
          align: q ? "left" : "right",
          zIndex: 2
        }).add(c.legendGroup), this.baseline || (this.fontMetrics = e.fontMetrics(a.styledMode ? 12 : h.fontSize, K), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, K.attr("y", this.baseline)), this.symbolHeight = f.symbolHeight || this.fontMetrics.f, b.drawLegendSymbol(this, c), this.setItemEvents && this.setItemEvents(c, K, x));
        C && !c.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(c);
        this.colorizeItem(c, c.visible);
        !a.styledMode && h.width || K.css({
          width: (f.itemWidth || this.widthOption || a.spacingBox.width) - g
        });
        this.setText(c);
        a = K.getBBox();
        c.itemWidth = c.checkboxOffset = f.itemWidth || c.legendItemWidth || a.width + g;
        this.maxItemWidth = Math.max(this.maxItemWidth, c.itemWidth);
        this.totalItemWidth += c.itemWidth;
        this.itemHeight = c.itemHeight = Math.round(c.legendItemHeight || a.height || this.symbolHeight);
      };

      c.prototype.layoutItem = function (c) {
        var a = this.options,
            e = this.padding,
            f = "horizontal" === a.layout,
            d = c.itemHeight,
            k = this.itemMarginBottom,
            h = this.itemMarginTop,
            n = f ? t(a.itemDistance, 20) : 0,
            g = this.maxLegendWidth;
        a = a.alignColumns && this.totalItemWidth > g ? this.maxItemWidth : c.itemWidth;
        f && this.itemX - e + a > g && (this.itemX = e, this.lastLineHeight && (this.itemY += h + this.lastLineHeight + k), this.lastLineHeight = 0);
        this.lastItemY = h + this.itemY + k;
        this.lastLineHeight = Math.max(d, this.lastLineHeight);
        c._legendItemPos = [this.itemX, this.itemY];
        f ? this.itemX += a : (this.itemY += h + d + k, this.lastLineHeight = d);
        this.offsetWidth = this.widthOption || Math.max((f ? this.itemX - e - (c.checkbox ? 0 : n) : a) + e, this.offsetWidth);
      };

      c.prototype.getAllItems = function () {
        var c = [];
        this.chart.series.forEach(function (a) {
          var e = a && a.options;
          a && t(e.showInLegend, I(e.linkedTo) ? !1 : void 0, !0) && (c = c.concat(a.legendItems || ("point" === e.legendType ? a.data : a)));
        });
        A(this, "afterGetAllItems", {
          allItems: c
        });
        return c;
      };

      c.prototype.getAlignment = function () {
        var c = this.options;
        return this.proximate ? c.align.charAt(0) + "tv" : c.floating ? "" : c.align.charAt(0) + c.verticalAlign.charAt(0) + c.layout.charAt(0);
      };

      c.prototype.adjustMargins = function (c, a) {
        var f = this.chart,
            d = this.options,
            k = this.getAlignment();
        k && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (l, h) {
          l.test(k) && !I(c[h]) && (f[e[h]] = Math.max(f[e[h]], f.legend[(h + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][h] * d[h % 2 ? "x" : "y"] + t(d.margin, 12) + a[h] + (f.titleOffset[h] || 0)));
        });
      };

      c.prototype.proximatePositions = function () {
        var c = this.chart,
            a = [],
            e = "left" === this.options.align;
        this.allItems.forEach(function (f) {
          var d = e;

          if (f.yAxis && f.points) {
            f.xAxis.options.reversed && (d = !d);
            var k = E(d ? f.points : f.points.slice(0).reverse(), function (a) {
              return J(a.plotY);
            });
            d = this.itemMarginTop + f.legendItem.getBBox().height + this.itemMarginBottom;
            var l = f.yAxis.top - c.plotTop;
            f.visible ? (k = k ? k.plotY : f.yAxis.height, k += l - .3 * d) : k = l + f.yAxis.height;
            a.push({
              target: k,
              size: d,
              item: f
            });
          }
        }, this);
        d.distribute(a, c.plotHeight);
        a.forEach(function (a) {
          a.item._legendItemPos[1] = c.plotTop - c.spacing[0] + a.pos;
        });
      };

      c.prototype.render = function () {
        var c = this.chart,
            a = c.renderer,
            e = this.group,
            d,
            k = this.box,
            h = this.options,
            n = this.padding;
        this.itemX = n;
        this.itemY = this.initialItemY;
        this.lastItemY = this.offsetWidth = 0;
        this.widthOption = D(h.width, c.spacingBox.width - n);
        var g = c.spacingBox.width - 2 * n - h.x;
        -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (g /= 2);
        this.maxLegendWidth = this.widthOption || g;
        e || (this.group = e = a.g("legend").attr({
          zIndex: 7
        }).add(), this.contentGroup = a.g().attr({
          zIndex: 1
        }).add(e), this.scrollGroup = a.g().add(this.contentGroup));
        this.renderTitle();
        g = this.getAllItems();
        N(g, function (a, c) {
          return (a.options && a.options.legendIndex || 0) - (c.options && c.options.legendIndex || 0);
        });
        h.reversed && g.reverse();
        this.allItems = g;
        this.display = d = !!g.length;
        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
        g.forEach(this.renderItem, this);
        g.forEach(this.layoutItem, this);
        g = (this.widthOption || this.offsetWidth) + n;
        var q = this.lastItemY + this.lastLineHeight + this.titleHeight;
        q = this.handleOverflow(q);
        q += n;
        k || (this.box = k = a.rect().addClass("highcharts-legend-box").attr({
          r: h.borderRadius
        }).add(e), k.isNew = !0);
        c.styledMode || k.attr({
          stroke: h.borderColor,
          "stroke-width": h.borderWidth || 0,
          fill: h.backgroundColor || "none"
        }).shadow(h.shadow);
        0 < g && 0 < q && (k[k.isNew ? "attr" : "animate"](k.crisp.call({}, {
          x: 0,
          y: 0,
          width: g,
          height: q
        }, k.strokeWidth())), k.isNew = !1);
        k[d ? "show" : "hide"]();
        c.styledMode && "none" === e.getStyle("display") && (g = q = 0);
        this.legendWidth = g;
        this.legendHeight = q;
        d && (a = c.spacingBox, k = a.y, /(lth|ct|rth)/.test(this.getAlignment()) && 0 < c.titleOffset[0] ? k += c.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < c.titleOffset[2] && (k -= c.titleOffset[2]), k !== a.y && (a = y(a, {
          y: k
        })), e.align(y(h, {
          width: g,
          height: q,
          verticalAlign: this.proximate ? "top" : h.verticalAlign
        }), !0, a));
        this.proximate || this.positionItems();
        A(this, "afterRender");
      };

      c.prototype.handleOverflow = function (c) {
        var a = this,
            e = this.chart,
            f = e.renderer,
            d = this.options,
            k = d.y,
            h = this.padding;
        k = e.spacingBox.height + ("top" === d.verticalAlign ? -k : k) - h;

        var n = d.maxHeight,
            g,
            q = this.clipRect,
            y = d.navigation,
            p = t(y.animation, !0),
            b = y.arrowSize || 12,
            C = this.nav,
            x = this.pages,
            R,
            O = this.allItems,
            u = function (b) {
          "number" === typeof b ? q.attr({
            height: b
          }) : q && (a.clipRect = q.destroy(), a.contentGroup.clip());
          a.contentGroup.div && (a.contentGroup.div.style.clip = b ? "rect(" + h + "px,9999px," + (h + b) + "px,0)" : "auto");
        },
            D = function (c) {
          a[c] = f.circle(0, 0, 1.3 * b).translate(b / 2, b / 2).add(C);
          e.styledMode || a[c].attr("fill", "rgba(0,0,0,0.0001)");
          return a[c];
        };

        "horizontal" !== d.layout || "middle" === d.verticalAlign || d.floating || (k /= 2);
        n && (k = Math.min(k, n));
        x.length = 0;
        c > k && !1 !== y.enabled ? (this.clipHeight = g = Math.max(k - 20 - this.titleHeight - h, 0), this.currentPage = t(this.currentPage, 1), this.fullHeight = c, O.forEach(function (b, a) {
          var c = b._legendItemPos[1],
              e = Math.round(b.legendItem.getBBox().height),
              f = x.length;
          if (!f || c - x[f - 1] > g && (R || c) !== x[f - 1]) x.push(R || c), f++;
          b.pageIx = f - 1;
          R && (O[a - 1].pageIx = f - 1);
          a === O.length - 1 && c + e - x[f - 1] > g && c !== R && (x.push(c), b.pageIx = f);
          c !== R && (R = c);
        }), q || (q = a.clipRect = f.clipRect(0, h, 9999, 0), a.contentGroup.clip(q)), u(g), C || (this.nav = C = f.g().attr({
          zIndex: 1
        }).add(this.group), this.up = f.symbol("triangle", 0, 0, b, b).add(C), D("upTracker").on("click", function () {
          a.scroll(-1, p);
        }), this.pager = f.text("", 15, 10).addClass("highcharts-legend-navigation"), e.styledMode || this.pager.css(y.style), this.pager.add(C), this.down = f.symbol("triangle-down", 0, 0, b, b).add(C), D("downTracker").on("click", function () {
          a.scroll(1, p);
        })), a.scroll(0), c = k) : C && (u(), this.nav = C.destroy(), this.scrollGroup.attr({
          translateY: 1
        }), this.clipHeight = 0);
        return c;
      };

      c.prototype.scroll = function (c, a) {
        var e = this,
            f = this.chart,
            k = this.pages,
            n = k.length,
            g = this.currentPage + c;
        c = this.clipHeight;
        var y = this.options.navigation,
            u = this.pager,
            H = this.padding;
        g > n && (g = n);
        0 < g && ("undefined" !== typeof a && h(a, f), this.nav.attr({
          translateX: H,
          translateY: c + this.padding + 7 + this.titleHeight,
          visibility: "visible"
        }), [this.up, this.upTracker].forEach(function (a) {
          a.attr({
            "class": 1 === g ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
          });
        }), u.attr({
          text: g + "/" + n
        }), [this.down, this.downTracker].forEach(function (a) {
          a.attr({
            x: 18 + this.pager.getBBox().width,
            "class": g === n ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
          });
        }, this), f.styledMode || (this.up.attr({
          fill: 1 === g ? y.inactiveColor : y.activeColor
        }), this.upTracker.css({
          cursor: 1 === g ? "default" : "pointer"
        }), this.down.attr({
          fill: g === n ? y.inactiveColor : y.activeColor
        }), this.downTracker.css({
          cursor: g === n ? "default" : "pointer"
        })), this.scrollOffset = -k[g - 1] + this.initialItemY, this.scrollGroup.animate({
          translateY: this.scrollOffset
        }), this.currentPage = g, this.positionCheckboxes(), a = d.animObject(t(a, f.renderer.globalAnimation, !0)), q(function () {
          A(e, "afterScroll", {
            currentPage: g
          });
        }, a.duration || 0));
      };

      return c;
    }();

    (/Trident\/7\.0/.test(c.navigator && c.navigator.userAgent) || P) && g(k.prototype, "positionItem", function (c, e) {
      var a = this,
          f = function () {
        e._legendItemPos && c.call(a, e);
      };

      f();
      a.bubbleLegend || setTimeout(f);
    });
    d.Legend = k;
    return d.Legend;
  });
  S(r, "parts/Chart.js", [r["parts/Globals.js"], r["parts/Legend.js"], r["parts/MSPointer.js"], r["parts/Pointer.js"], r["parts/Time.js"], r["parts/Utilities.js"]], function (d, g, r, u, I, M) {
    var E = M.addEvent,
        A = M.animate,
        G = M.animObject,
        J = M.attr,
        y = M.createElement,
        t = M.css,
        D = M.defined,
        h = M.discardElement,
        N = M.erase,
        q = M.error,
        P = M.extend,
        e = M.find,
        c = M.fireEvent,
        k = M.getStyle,
        n = M.isArray,
        f = M.isFunction,
        a = M.isNumber,
        l = M.isObject,
        v = M.isString,
        z = M.merge,
        w = M.numberFormat,
        B = M.objectEach,
        L = M.pick,
        Q = M.pInt,
        H = M.relativeLength,
        K = M.removeEvent,
        p = M.setAnimation,
        b = M.splat,
        C = M.syncTimeout,
        x = M.uniqueKey,
        R = d.doc,
        O = d.Axis,
        X = d.defaultOptions,
        U = d.charts,
        m = d.marginNames,
        T = d.seriesTypes,
        Z = d.win,
        ca = d.Chart = function () {
      this.getArgs.apply(this, arguments);
    };

    d.chart = function (b, a, c) {
      return new ca(b, a, c);
    };

    P(ca.prototype, {
      callbacks: [],
      getArgs: function () {
        var b = [].slice.call(arguments);
        if (v(b[0]) || b[0].nodeName) this.renderTo = b.shift();
        this.init(b[0], b[1]);
      },
      init: function (b, a) {
        var e,
            k = b.series,
            h = b.plotOptions || {};
        c(this, "init", {
          args: arguments
        }, function () {
          b.series = null;
          e = z(X, b);
          B(e.plotOptions, function (b, a) {
            l(b) && (b.tooltip = h[a] && z(h[a].tooltip) || void 0);
          });
          e.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;
          e.series = b.series = k;
          this.userOptions = b;
          var m = e.chart,
              n = m.events;
          this.margin = [];
          this.spacing = [];
          this.bounds = {
            h: {},
            v: {}
          };
          this.labelCollectors = [];
          this.callback = a;
          this.isResizing = 0;
          this.options = e;
          this.axes = [];
          this.series = [];
          this.time = b.time && Object.keys(b.time).length ? new I(b.time) : d.time;
          this.numberFormatter = m.numberFormatter || w;
          this.styledMode = m.styledMode;
          this.hasCartesianSeries = m.showAxes;
          var p = this;
          p.index = U.length;
          U.push(p);
          d.chartCount++;
          n && B(n, function (b, a) {
            f(b) && E(p, a, b);
          });
          p.xAxis = [];
          p.yAxis = [];
          p.pointCount = p.colorCounter = p.symbolCounter = 0;
          c(p, "afterInit");
          p.firstRender();
        });
      },
      initSeries: function (b) {
        var a = this.options.chart;
        a = b.type || a.type || a.defaultSeriesType;
        var c = T[a];
        c || q(17, !0, this, {
          missingModuleFor: a
        });
        a = new c();
        a.init(this, b);
        return a;
      },
      setSeriesData: function () {
        this.getSeriesOrderByLinks().forEach(function (b) {
          b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);
        });
      },
      getSeriesOrderByLinks: function () {
        return this.series.concat().sort(function (b, a) {
          return b.linkedSeries.length || a.linkedSeries.length ? a.linkedSeries.length - b.linkedSeries.length : 0;
        });
      },
      orderSeries: function (b) {
        var a = this.series;

        for (b = b || 0; b < a.length; b++) a[b] && (a[b].index = b, a[b].name = a[b].getName());
      },
      isInsidePlot: function (b, a, e) {
        var f = e ? a : b;
        b = e ? b : a;
        f = {
          x: f,
          y: b,
          isInsidePlot: 0 <= f && f <= this.plotWidth && 0 <= b && b <= this.plotHeight
        };
        c(this, "afterIsInsidePlot", f);
        return f.isInsidePlot;
      },
      redraw: function (b) {
        c(this, "beforeRedraw");
        var a = this.axes,
            e = this.series,
            f = this.pointer,
            d = this.legend,
            k = this.userOptions.legend,
            l = this.isDirtyLegend,
            h = this.hasCartesianSeries,
            m = this.isDirtyBox,
            n = this.renderer,
            x = n.isHidden(),
            g = [];
        this.setResponsive && this.setResponsive(!1);
        p(this.hasRendered ? b : !1, this);
        x && this.temporaryDisplay();
        this.layOutTitles();

        for (b = e.length; b--;) {
          var w = e[b];

          if (w.options.stacking) {
            var C = !0;

            if (w.isDirty) {
              var v = !0;
              break;
            }
          }
        }

        if (v) for (b = e.length; b--;) w = e[b], w.options.stacking && (w.isDirty = !0);
        e.forEach(function (b) {
          b.isDirty && ("point" === b.options.legendType ? (b.updateTotals && b.updateTotals(), l = !0) : k && (k.labelFormatter || k.labelFormat) && (l = !0));
          b.isDirtyData && c(b, "updatedData");
        });
        l && d && d.options.enabled && (d.render(), this.isDirtyLegend = !1);
        C && this.getStacks();
        h && a.forEach(function (b) {
          b.updateNames();
          b.setScale();
        });
        this.getMargins();
        h && (a.forEach(function (b) {
          b.isDirty && (m = !0);
        }), a.forEach(function (b) {
          var a = b.min + "," + b.max;
          b.extKey !== a && (b.extKey = a, g.push(function () {
            c(b, "afterSetExtremes", P(b.eventArgs, b.getExtremes()));
            delete b.eventArgs;
          }));
          (m || C) && b.redraw();
        }));
        m && this.drawChartBox();
        c(this, "predraw");
        e.forEach(function (b) {
          (m || b.isDirty) && b.visible && b.redraw();
          b.isDirtyData = !1;
        });
        f && f.reset(!0);
        n.draw();
        c(this, "redraw");
        c(this, "render");
        x && this.temporaryDisplay(!0);
        g.forEach(function (b) {
          b.call();
        });
      },
      get: function (b) {
        function a(a) {
          return a.id === b || a.options && a.options.id === b;
        }

        var c = this.series,
            f;
        var d = e(this.axes, a) || e(this.series, a);

        for (f = 0; !d && f < c.length; f++) d = e(c[f].points || [], a);

        return d;
      },
      getAxes: function () {
        var a = this,
            e = this.options,
            f = e.xAxis = b(e.xAxis || {});
        e = e.yAxis = b(e.yAxis || {});
        c(this, "getAxes");
        f.forEach(function (b, a) {
          b.index = a;
          b.isX = !0;
        });
        e.forEach(function (b, a) {
          b.index = a;
        });
        f.concat(e).forEach(function (b) {
          new O(a, b);
        });
        c(this, "afterGetAxes");
      },
      getSelectedPoints: function () {
        var b = [];
        this.series.forEach(function (a) {
          b = b.concat(a.getPointsCollection().filter(function (b) {
            return L(b.selectedStaging, b.selected);
          }));
        });
        return b;
      },
      getSelectedSeries: function () {
        return this.series.filter(function (b) {
          return b.selected;
        });
      },
      setTitle: function (b, a, c) {
        this.applyDescription("title", b);
        this.applyDescription("subtitle", a);
        this.applyDescription("caption", void 0);
        this.layOutTitles(c);
      },
      applyDescription: function (b, a) {
        var c = this,
            e = "title" === b ? {
          color: "#333333",
          fontSize: this.options.isStock ? "16px" : "18px"
        } : {
          color: "#666666"
        };
        e = this.options[b] = z(!this.styledMode && {
          style: e
        }, this.options[b], a);
        var f = this[b];
        f && a && (this[b] = f = f.destroy());
        e && !f && (f = this.renderer.text(e.text, 0, 0, e.useHTML).attr({
          align: e.align,
          "class": "highcharts-" + b,
          zIndex: e.zIndex || 4
        }).add(), f.update = function (a) {
          c[{
            title: "setTitle",
            subtitle: "setSubtitle",
            caption: "setCaption"
          }[b]](a);
        }, this.styledMode || f.css(e.style), this[b] = f);
      },
      layOutTitles: function (b) {
        var a = [0, 0, 0],
            e = this.renderer,
            f = this.spacingBox;
        ["title", "subtitle", "caption"].forEach(function (b) {
          var c = this[b],
              d = this.options[b],
              k = d.verticalAlign || "top";
          b = "title" === b ? -3 : "top" === k ? a[0] + 2 : 0;

          if (c) {
            if (!this.styledMode) var l = d.style.fontSize;
            l = e.fontMetrics(l, c).b;
            c.css({
              width: (d.width || f.width + (d.widthAdjust || 0)) + "px"
            });
            var h = Math.round(c.getBBox(d.useHTML).height);
            c.align(P({
              y: "bottom" === k ? l : b + l,
              height: h
            }, d), !1, "spacingBox");
            d.floating || ("top" === k ? a[0] = Math.ceil(a[0] + h) : "bottom" === k && (a[2] = Math.ceil(a[2] + h)));
          }
        }, this);
        a[0] && "top" === (this.options.title.verticalAlign || "top") && (a[0] += this.options.title.margin);
        a[2] && "bottom" === this.options.caption.verticalAlign && (a[2] += this.options.caption.margin);
        var d = !this.titleOffset || this.titleOffset.join(",") !== a.join(",");
        this.titleOffset = a;
        c(this, "afterLayOutTitles");
        !this.isDirtyBox && d && (this.isDirtyBox = this.isDirtyLegend = d, this.hasRendered && L(b, !0) && this.isDirtyBox && this.redraw());
      },
      getChartSize: function () {
        var b = this.options.chart,
            a = b.width;
        b = b.height;
        var c = this.renderTo;
        D(a) || (this.containerWidth = k(c, "width"));
        D(b) || (this.containerHeight = k(c, "height"));
        this.chartWidth = Math.max(0, a || this.containerWidth || 600);
        this.chartHeight = Math.max(0, H(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
      },
      temporaryDisplay: function (b) {
        var a = this.renderTo;
        if (b) for (; a && a.style;) a.hcOrigStyle && (t(a, a.hcOrigStyle), delete a.hcOrigStyle), a.hcOrigDetached && (R.body.removeChild(a), a.hcOrigDetached = !1), a = a.parentNode;else for (; a && a.style;) {
          R.body.contains(a) || a.parentNode || (a.hcOrigDetached = !0, R.body.appendChild(a));
          if ("none" === k(a, "display", !1) || a.hcOricDetached) a.hcOrigStyle = {
            display: a.style.display,
            height: a.style.height,
            overflow: a.style.overflow
          }, b = {
            display: "block",
            overflow: "hidden"
          }, a !== this.renderTo && (b.height = 0), t(a, b), a.offsetWidth || a.style.setProperty("display", "block", "important");
          a = a.parentNode;
          if (a === R.body) break;
        }
      },
      setClassName: function (b) {
        this.container.className = "highcharts-container " + (b || "");
      },
      getContainer: function () {
        var b = this.options,
            e = b.chart;
        var f = this.renderTo;
        var k = x(),
            l,
            h;
        f || (this.renderTo = f = e.renderTo);
        v(f) && (this.renderTo = f = R.getElementById(f));
        f || q(13, !0, this);
        var m = Q(J(f, "data-highcharts-chart"));
        a(m) && U[m] && U[m].hasRendered && U[m].destroy();
        J(f, "data-highcharts-chart", this.index);
        f.innerHTML = "";
        e.skipClone || f.offsetWidth || this.temporaryDisplay();
        this.getChartSize();
        m = this.chartWidth;
        var n = this.chartHeight;
        t(f, {
          overflow: "hidden"
        });
        this.styledMode || (l = P({
          position: "relative",
          overflow: "hidden",
          width: m + "px",
          height: n + "px",
          textAlign: "left",
          lineHeight: "normal",
          zIndex: 0,
          "-webkit-tap-highlight-color": "rgba(0,0,0,0)"
        }, e.style));
        this.container = f = y("div", {
          id: k
        }, l, f);
        this._cursor = f.style.cursor;
        this.renderer = new (d[e.renderer] || d.Renderer)(f, m, n, null, e.forExport, b.exporting && b.exporting.allowHTML, this.styledMode);
        p(void 0, this);
        this.setClassName(e.className);
        if (this.styledMode) for (h in b.defs) this.renderer.definition(b.defs[h]);else this.renderer.setStyle(e.style);
        this.renderer.chartIndex = this.index;
        c(this, "afterGetContainer");
      },
      getMargins: function (b) {
        var a = this.spacing,
            e = this.margin,
            f = this.titleOffset;
        this.resetMargins();
        f[0] && !D(e[0]) && (this.plotTop = Math.max(this.plotTop, f[0] + a[0]));
        f[2] && !D(e[2]) && (this.marginBottom = Math.max(this.marginBottom, f[2] + a[2]));
        this.legend && this.legend.display && this.legend.adjustMargins(e, a);
        c(this, "getMargins");
        b || this.getAxisMargins();
      },
      getAxisMargins: function () {
        var b = this,
            a = b.axisOffset = [0, 0, 0, 0],
            c = b.colorAxis,
            e = b.margin,
            f = function (b) {
          b.forEach(function (b) {
            b.visible && b.getOffset();
          });
        };

        b.hasCartesianSeries ? f(b.axes) : c && c.length && f(c);
        m.forEach(function (c, f) {
          D(e[f]) || (b[c] += a[f]);
        });
        b.setChartSize();
      },
      reflow: function (b) {
        var a = this,
            c = a.options.chart,
            e = a.renderTo,
            f = D(c.width) && D(c.height),
            d = c.width || k(e, "width");
        c = c.height || k(e, "height");
        e = b ? b.target : Z;

        if (!f && !a.isPrinting && d && c && (e === Z || e === R)) {
          if (d !== a.containerWidth || c !== a.containerHeight) M.clearTimeout(a.reflowTimeout), a.reflowTimeout = C(function () {
            a.container && a.setSize(void 0, void 0, !1);
          }, b ? 100 : 0);
          a.containerWidth = d;
          a.containerHeight = c;
        }
      },
      setReflow: function (b) {
        var a = this;
        !1 === b || this.unbindReflow ? !1 === b && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = E(Z, "resize", function (b) {
          a.options && a.reflow(b);
        }), E(this, "destroy", this.unbindReflow));
      },
      setSize: function (b, a, e) {
        var f = this,
            d = f.renderer;
        f.isResizing += 1;
        p(e, f);
        e = d.globalAnimation;
        f.oldChartHeight = f.chartHeight;
        f.oldChartWidth = f.chartWidth;
        "undefined" !== typeof b && (f.options.chart.width = b);
        "undefined" !== typeof a && (f.options.chart.height = a);
        f.getChartSize();
        f.styledMode || (e ? A : t)(f.container, {
          width: f.chartWidth + "px",
          height: f.chartHeight + "px"
        }, e);
        f.setChartSize(!0);
        d.setSize(f.chartWidth, f.chartHeight, e);
        f.axes.forEach(function (b) {
          b.isDirty = !0;
          b.setScale();
        });
        f.isDirtyLegend = !0;
        f.isDirtyBox = !0;
        f.layOutTitles();
        f.getMargins();
        f.redraw(e);
        f.oldChartHeight = null;
        c(f, "resize");
        C(function () {
          f && c(f, "endResize", null, function () {
            --f.isResizing;
          });
        }, G(e).duration || 0);
      },
      setChartSize: function (b) {
        var a = this.inverted,
            e = this.renderer,
            f = this.chartWidth,
            d = this.chartHeight,
            k = this.options.chart,
            l = this.spacing,
            h = this.clipOffset,
            m,
            n,
            p,
            x;
        this.plotLeft = m = Math.round(this.plotLeft);
        this.plotTop = n = Math.round(this.plotTop);
        this.plotWidth = p = Math.max(0, Math.round(f - m - this.marginRight));
        this.plotHeight = x = Math.max(0, Math.round(d - n - this.marginBottom));
        this.plotSizeX = a ? x : p;
        this.plotSizeY = a ? p : x;
        this.plotBorderWidth = k.plotBorderWidth || 0;
        this.spacingBox = e.spacingBox = {
          x: l[3],
          y: l[0],
          width: f - l[3] - l[1],
          height: d - l[0] - l[2]
        };
        this.plotBox = e.plotBox = {
          x: m,
          y: n,
          width: p,
          height: x
        };
        f = 2 * Math.floor(this.plotBorderWidth / 2);
        a = Math.ceil(Math.max(f, h[3]) / 2);
        e = Math.ceil(Math.max(f, h[0]) / 2);
        this.clipBox = {
          x: a,
          y: e,
          width: Math.floor(this.plotSizeX - Math.max(f, h[1]) / 2 - a),
          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(f, h[2]) / 2 - e))
        };
        b || this.axes.forEach(function (b) {
          b.setAxisSize();
          b.setAxisTranslation();
        });
        c(this, "afterSetChartSize", {
          skipAxes: b
        });
      },
      resetMargins: function () {
        c(this, "resetMargins");
        var b = this,
            a = b.options.chart;
        ["margin", "spacing"].forEach(function (c) {
          var e = a[c],
              f = l(e) ? e : [e, e, e, e];
          ["Top", "Right", "Bottom", "Left"].forEach(function (e, d) {
            b[c][d] = L(a[c + e], f[d]);
          });
        });
        m.forEach(function (a, c) {
          b[a] = L(b.margin[c], b.spacing[c]);
        });
        b.axisOffset = [0, 0, 0, 0];
        b.clipOffset = [0, 0, 0, 0];
      },
      drawChartBox: function () {
        var b = this.options.chart,
            a = this.renderer,
            e = this.chartWidth,
            f = this.chartHeight,
            d = this.chartBackground,
            k = this.plotBackground,
            l = this.plotBorder,
            h = this.styledMode,
            m = this.plotBGImage,
            n = b.backgroundColor,
            p = b.plotBackgroundColor,
            x = b.plotBackgroundImage,
            g,
            w = this.plotLeft,
            C = this.plotTop,
            v = this.plotWidth,
            q = this.plotHeight,
            t = this.plotBox,
            B = this.clipRect,
            z = this.clipBox,
            O = "animate";
        d || (this.chartBackground = d = a.rect().addClass("highcharts-background").add(), O = "attr");
        if (h) var y = g = d.strokeWidth();else {
          y = b.borderWidth || 0;
          g = y + (b.shadow ? 8 : 0);
          n = {
            fill: n || "none"
          };
          if (y || d["stroke-width"]) n.stroke = b.borderColor, n["stroke-width"] = y;
          d.attr(n).shadow(b.shadow);
        }
        d[O]({
          x: g / 2,
          y: g / 2,
          width: e - g - y % 2,
          height: f - g - y % 2,
          r: b.borderRadius
        });
        O = "animate";
        k || (O = "attr", this.plotBackground = k = a.rect().addClass("highcharts-plot-background").add());
        k[O](t);
        h || (k.attr({
          fill: p || "none"
        }).shadow(b.plotShadow), x && (m ? (x !== m.attr("href") && m.attr("href", x), m.animate(t)) : this.plotBGImage = a.image(x, w, C, v, q).add()));
        B ? B.animate({
          width: z.width,
          height: z.height
        }) : this.clipRect = a.clipRect(z);
        O = "animate";
        l || (O = "attr", this.plotBorder = l = a.rect().addClass("highcharts-plot-border").attr({
          zIndex: 1
        }).add());
        h || l.attr({
          stroke: b.plotBorderColor,
          "stroke-width": b.plotBorderWidth || 0,
          fill: "none"
        });
        l[O](l.crisp({
          x: w,
          y: C,
          width: v,
          height: q
        }, -l.strokeWidth()));
        this.isDirtyBox = !1;
        c(this, "afterDrawChartBox");
      },
      propFromSeries: function () {
        var b = this,
            a = b.options.chart,
            c,
            e = b.options.series,
            f,
            d;
        ["inverted", "angular", "polar"].forEach(function (k) {
          c = T[a.type || a.defaultSeriesType];
          d = a[k] || c && c.prototype[k];

          for (f = e && e.length; !d && f--;) (c = T[e[f].type]) && c.prototype[k] && (d = !0);

          b[k] = d;
        });
      },
      linkSeries: function () {
        var b = this,
            a = b.series;
        a.forEach(function (b) {
          b.linkedSeries.length = 0;
        });
        a.forEach(function (a) {
          var c = a.options.linkedTo;
          v(c) && (c = ":previous" === c ? b.series[a.index - 1] : b.get(c)) && c.linkedParent !== a && (c.linkedSeries.push(a), a.linkedParent = c, c.enabledDataSorting && a.setDataSortingOptions(), a.visible = L(a.options.visible, c.options.visible, a.visible));
        });
        c(this, "afterLinkSeries");
      },
      renderSeries: function () {
        this.series.forEach(function (b) {
          b.translate();
          b.render();
        });
      },
      renderLabels: function () {
        var b = this,
            a = b.options.labels;
        a.items && a.items.forEach(function (c) {
          var e = P(a.style, c.style),
              f = Q(e.left) + b.plotLeft,
              d = Q(e.top) + b.plotTop + 12;
          delete e.left;
          delete e.top;
          b.renderer.text(c.html, f, d).attr({
            zIndex: 2
          }).css(e).add();
        });
      },
      render: function () {
        var b = this.axes,
            a = this.colorAxis,
            c = this.renderer,
            e = this.options,
            f = 0,
            d = function (b) {
          b.forEach(function (b) {
            b.visible && b.render();
          });
        };

        this.setTitle();
        this.legend = new g(this, e.legend);
        this.getStacks && this.getStacks();
        this.getMargins(!0);
        this.setChartSize();
        e = this.plotWidth;
        b.some(function (b) {
          if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return f = 21, !0;
        });
        var k = this.plotHeight = Math.max(this.plotHeight - f, 0);
        b.forEach(function (b) {
          b.setScale();
        });
        this.getAxisMargins();
        var l = 1.1 < e / this.plotWidth;
        var h = 1.05 < k / this.plotHeight;
        if (l || h) b.forEach(function (b) {
          (b.horiz && l || !b.horiz && h) && b.setTickInterval(!0);
        }), this.getMargins();
        this.drawChartBox();
        this.hasCartesianSeries ? d(b) : a && a.length && d(a);
        this.seriesGroup || (this.seriesGroup = c.g("series-group").attr({
          zIndex: 3
        }).add());
        this.renderSeries();
        this.renderLabels();
        this.addCredits();
        this.setResponsive && this.setResponsive();
        this.updateContainerScaling();
        this.hasRendered = !0;
      },
      addCredits: function (b) {
        var a = this;
        b = z(!0, this.options.credits, b);
        b.enabled && !this.credits && (this.credits = this.renderer.text(b.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
          b.href && (Z.location.href = b.href);
        }).attr({
          align: b.position.align,
          zIndex: 8
        }), a.styledMode || this.credits.css(b.style), this.credits.add().align(b.position), this.credits.update = function (b) {
          a.credits = a.credits.destroy();
          a.addCredits(b);
        });
      },
      updateContainerScaling: function () {
        var b = this.container;

        if (b.offsetWidth && b.offsetHeight && b.getBoundingClientRect) {
          var a = b.getBoundingClientRect(),
              c = a.width / b.offsetWidth;
          b = a.height / b.offsetHeight;
          1 !== c || 1 !== b ? this.containerScaling = {
            scaleX: c,
            scaleY: b
          } : delete this.containerScaling;
        }
      },
      destroy: function () {
        var b = this,
            a = b.axes,
            e = b.series,
            f = b.container,
            k,
            l = f && f.parentNode;
        c(b, "destroy");
        b.renderer.forExport ? N(U, b) : U[b.index] = void 0;
        d.chartCount--;
        b.renderTo.removeAttribute("data-highcharts-chart");
        K(b);

        for (k = a.length; k--;) a[k] = a[k].destroy();

        this.scroller && this.scroller.destroy && this.scroller.destroy();

        for (k = e.length; k--;) e[k] = e[k].destroy();

        "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (a) {
          var c = b[a];
          c && c.destroy && (b[a] = c.destroy());
        });
        f && (f.innerHTML = "", K(f), l && h(f));
        B(b, function (a, c) {
          delete b[c];
        });
      },
      firstRender: function () {
        var b = this,
            a = b.options;

        if (!b.isReadyToRender || b.isReadyToRender()) {
          b.getContainer();
          b.resetMargins();
          b.setChartSize();
          b.propFromSeries();
          b.getAxes();
          (n(a.series) ? a.series : []).forEach(function (a) {
            b.initSeries(a);
          });
          b.linkSeries();
          b.setSeriesData();
          c(b, "beforeRender");
          u && (b.pointer = d.hasTouch || !Z.PointerEvent && !Z.MSPointerEvent ? new u(b, a) : new r(b, a));
          b.render();
          if (!b.renderer.imgCount && !b.hasLoaded) b.onload();
          b.temporaryDisplay(!0);
        }
      },
      onload: function () {
        this.callbacks.concat([this.callback]).forEach(function (b) {
          b && "undefined" !== typeof this.index && b.apply(this, [this]);
        }, this);
        c(this, "load");
        c(this, "render");
        D(this.index) && this.setReflow(this.options.chart.reflow);
        this.hasLoaded = !0;
      }
    });
  });
  S(r, "parts/ScrollablePlotArea.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.addEvent,
        u = g.createElement,
        I = g.pick,
        M = g.stop;
    g = d.Chart;
    "";
    r(g, "afterSetChartSize", function (g) {
      var u = this.options.chart.scrollablePlotArea,
          r = u && u.minWidth;
      u = u && u.minHeight;

      if (!this.renderer.forExport) {
        if (r) {
          if (this.scrollablePixelsX = r = Math.max(0, r - this.chartWidth)) {
            this.plotWidth += r;
            this.inverted ? (this.clipBox.height += r, this.plotBox.height += r) : (this.clipBox.width += r, this.plotBox.width += r);
            var E = {
              1: {
                name: "right",
                value: r
              }
            };
          }
        } else u && (this.scrollablePixelsY = r = Math.max(0, u - this.chartHeight)) && (this.plotHeight += r, this.inverted ? (this.clipBox.width += r, this.plotBox.width += r) : (this.clipBox.height += r, this.plotBox.height += r), E = {
          2: {
            name: "bottom",
            value: r
          }
        });

        E && !g.skipAxes && this.axes.forEach(function (g) {
          E[g.side] ? g.getPlotLinePath = function () {
            var t = E[g.side].name,
                y = this[t];
            this[t] = y - E[g.side].value;
            var h = d.Axis.prototype.getPlotLinePath.apply(this, arguments);
            this[t] = y;
            return h;
          } : (g.setAxisSize(), g.setAxisTranslation());
        });
      }
    });
    r(g, "render", function () {
      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
    });

    g.prototype.setUpScrolling = function () {
      var d = this,
          g = {
        WebkitOverflowScrolling: "touch",
        overflowX: "hidden",
        overflowY: "hidden"
      };
      this.scrollablePixelsX && (g.overflowX = "auto");
      this.scrollablePixelsY && (g.overflowY = "auto");
      this.scrollingContainer = u("div", {
        className: "highcharts-scrolling"
      }, g, this.renderTo);
      r(this.scrollingContainer, "scroll", function () {
        d.pointer && delete d.pointer.chartPosition;
      });
      this.innerContainer = u("div", {
        className: "highcharts-inner-container"
      }, null, this.scrollingContainer);
      this.innerContainer.appendChild(this.container);
      this.setUpScrolling = null;
    };

    g.prototype.moveFixedElements = function () {
      var d = this.container,
          g = this.fixedRenderer,
          u = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),
          r;
      this.scrollablePixelsX && !this.inverted ? r = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? r = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? r = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (r = ".highcharts-yaxis");
      u.push(r, r + "-labels");
      u.forEach(function (y) {
        [].forEach.call(d.querySelectorAll(y), function (d) {
          (d.namespaceURI === g.SVG_NS ? g.box : g.box.parentNode).appendChild(d);
          d.style.pointerEvents = "auto";
        });
      });
    };

    g.prototype.applyFixed = function () {
      var g,
          A = !this.fixedDiv,
          G = this.options.chart.scrollablePlotArea;
      A ? (this.fixedDiv = u("div", {
        className: "highcharts-fixed"
      }, {
        position: "absolute",
        overflow: "hidden",
        pointerEvents: "none",
        zIndex: 2
      }, null, !0), this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild), this.renderTo.style.overflow = "visible", this.fixedRenderer = g = new d.Renderer(this.fixedDiv, this.chartWidth, this.chartHeight), this.scrollableMask = g.path().attr({
        fill: this.options.chart.backgroundColor || "#fff",
        "fill-opacity": I(G.opacity, .85),
        zIndex: -1
      }).addClass("highcharts-scrollable-mask").add(), this.moveFixedElements(), r(this, "afterShowResetZoom", this.moveFixedElements), r(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
      g = this.chartWidth + (this.scrollablePixelsX || 0);
      var J = this.chartHeight + (this.scrollablePixelsY || 0);
      M(this.container);
      this.container.style.width = g + "px";
      this.container.style.height = J + "px";
      this.renderer.boxWrapper.attr({
        width: g,
        height: J,
        viewBox: [0, 0, g, J].join(" ")
      });
      this.chartBackground.attr({
        width: g,
        height: J
      });
      this.scrollablePixelsY && (this.scrollingContainer.style.height = this.chartHeight + "px");
      A && (G.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * G.scrollPositionX), G.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * G.scrollPositionY));
      J = this.axisOffset;
      A = this.plotTop - J[0] - 1;
      G = this.plotLeft - J[3] - 1;
      g = this.plotTop + this.plotHeight + J[2] + 1;
      J = this.plotLeft + this.plotWidth + J[1] + 1;
      var y = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
          t = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
      A = this.scrollablePixelsX ? ["M", 0, A, "L", this.plotLeft - 1, A, "L", this.plotLeft - 1, g, "L", 0, g, "Z", "M", y, A, "L", this.chartWidth, A, "L", this.chartWidth, g, "L", y, g, "Z"] : this.scrollablePixelsY ? ["M", G, 0, "L", G, this.plotTop - 1, "L", J, this.plotTop - 1, "L", J, 0, "Z", "M", G, t, "L", G, this.chartHeight, "L", J, this.chartHeight, "L", J, t, "Z"] : ["M", 0, 0];
      "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({
        d: A
      });
    };
  });
  S(r, "mixins/legend-symbol.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.merge,
        u = g.pick;
    d.LegendSymbolMixin = {
      drawRectangle: function (d, g) {
        var r = d.symbolHeight,
            A = d.options.squareSymbol;
        g.legendSymbol = this.chart.renderer.rect(A ? (d.symbolWidth - r) / 2 : 0, d.baseline - r + 1, A ? r : d.symbolWidth, r, u(d.options.symbolRadius, r / 2)).addClass("highcharts-point").attr({
          zIndex: 3
        }).add(g.legendGroup);
      },
      drawLineMarker: function (d) {
        var g = this.options,
            E = g.marker,
            A = d.symbolWidth,
            G = d.symbolHeight,
            J = G / 2,
            y = this.chart.renderer,
            t = this.legendGroup;
        d = d.baseline - Math.round(.3 * d.fontMetrics.b);
        var D = {};
        this.chart.styledMode || (D = {
          "stroke-width": g.lineWidth || 0
        }, g.dashStyle && (D.dashstyle = g.dashStyle));
        this.legendLine = y.path(["M", 0, d, "L", A, d]).addClass("highcharts-graph").attr(D).add(t);
        E && !1 !== E.enabled && A && (g = Math.min(u(E.radius, J), J), 0 === this.symbol.indexOf("url") && (E = r(E, {
          width: G,
          height: G
        }), g = 0), this.legendSymbol = E = y.symbol(this.symbol, A / 2 - g, d - g, 2 * g, 2 * g, E).addClass("highcharts-point").add(t), E.isMarker = !0);
      }
    };
    return d.LegendSymbolMixin;
  });
  S(r, "parts/Point.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    "";

    var r = g.animObject,
        u = g.defined,
        I = g.erase,
        M = g.extend,
        E = g.format,
        A = g.getNestedProperty,
        G = g.isArray,
        J = g.isNumber,
        y = g.isObject,
        t = g.syncTimeout,
        D = g.pick,
        h = g.removeEvent,
        N = g.uniqueKey,
        q = d.fireEvent;

    g = function () {
      function d() {
        this.colorIndex = this.category = void 0;
        this.formatPrefix = "point";
        this.id = void 0;
        this.isNull = !1;
        this.percentage = this.options = this.name = void 0;
        this.selected = !1;
        this.total = this.series = void 0;
        this.visible = !0;
        this.x = void 0;
      }

      d.prototype.animateBeforeDestroy = function () {
        var e = this,
            c = {
          x: e.startXPos,
          opacity: 0
        },
            d,
            h = e.getGraphicalProps();
        h.singular.forEach(function (f) {
          d = "dataLabel" === f;
          e[f] = e[f].animate(d ? {
            x: e[f].startXPos,
            y: e[f].startYPos,
            opacity: 0
          } : c);
        });
        h.plural.forEach(function (c) {
          e[c].forEach(function (a) {
            a.element && a.animate(M({
              x: e.startXPos
            }, a.startYPos ? {
              x: a.startXPos,
              y: a.startYPos
            } : {}));
          });
        });
      };

      d.prototype.applyOptions = function (e, c) {
        var k = this.series,
            h = k.options.pointValKey || k.pointValKey;
        e = d.prototype.optionsToObject.call(this, e);
        M(this, e);
        this.options = this.options ? M(this.options, e) : e;
        e.group && delete this.group;
        e.dataLabels && delete this.dataLabels;
        h && (this.y = d.prototype.getNestedProperty.call(this, h));
        this.formatPrefix = (this.isNull = D(this.isValid && !this.isValid(), null === this.x || !J(this.y))) ? "null" : "point";
        this.selected && (this.state = "select");
        "name" in this && "undefined" === typeof c && k.xAxis && k.xAxis.hasNames && (this.x = k.xAxis.nameToX(this));
        "undefined" === typeof this.x && k && (this.x = "undefined" === typeof c ? k.autoIncrement(this) : c);
        return this;
      };

      d.prototype.destroy = function () {
        function e() {
          if (c.graphic || c.dataLabel || c.dataLabels) h(c), c.destroyElements();

          for (l in c) c[l] = null;
        }

        var c = this,
            d = c.series,
            n = d.chart;
        d = d.options.dataSorting;
        var f = n.hoverPoints,
            a = r(c.series.chart.renderer.globalAnimation),
            l;
        c.legendItem && n.legend.destroyItem(c);
        f && (c.setState(), I(f, c), f.length || (n.hoverPoints = null));
        if (c === n.hoverPoint) c.onMouseOut();
        d && d.enabled ? (this.animateBeforeDestroy(), t(e, a.duration)) : e();
        n.pointCount--;
      };

      d.prototype.destroyElements = function (e) {
        var c = this;
        e = c.getGraphicalProps(e);
        e.singular.forEach(function (e) {
          c[e] = c[e].destroy();
        });
        e.plural.forEach(function (e) {
          c[e].forEach(function (c) {
            c.element && c.destroy();
          });
          delete c[e];
        });
      };

      d.prototype.firePointEvent = function (e, c, d) {
        var k = this,
            f = this.series.options;
        (f.point.events[e] || k.options && k.options.events && k.options.events[e]) && k.importEvents();
        "click" === e && f.allowPointSelect && (d = function (a) {
          k.select && k.select(null, a.ctrlKey || a.metaKey || a.shiftKey);
        });
        q(k, e, c, d);
      };

      d.prototype.getClassName = function () {
        return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
      };

      d.prototype.getGraphicalProps = function (e) {
        var c = this,
            d = [],
            h,
            f = {
          singular: [],
          plural: []
        };
        e = e || {
          graphic: 1,
          dataLabel: 1
        };
        e.graphic && d.push("graphic", "shadowGroup");
        e.dataLabel && d.push("dataLabel", "dataLabelUpper", "connector");

        for (h = d.length; h--;) {
          var a = d[h];
          c[a] && f.singular.push(a);
        }

        ["dataLabel", "connector"].forEach(function (a) {
          var d = a + "s";
          e[a] && c[d] && f.plural.push(d);
        });
        return f;
      };

      d.prototype.getLabelConfig = function () {
        return {
          x: this.category,
          y: this.y,
          color: this.color,
          colorIndex: this.colorIndex,
          key: this.name || this.category,
          series: this.series,
          point: this,
          percentage: this.percentage,
          total: this.total || this.stackTotal
        };
      };

      d.prototype.getNestedProperty = function (e) {
        if (e) return 0 === e.indexOf("custom.") ? A(e, this.options) : this[e];
      };

      d.prototype.getZone = function () {
        var e = this.series,
            c = e.zones;
        e = e.zoneAxis || "y";
        var d = 0,
            h;

        for (h = c[d]; this[e] >= h.value;) h = c[++d];

        this.nonZonedColor || (this.nonZonedColor = this.color);
        this.color = h && h.color && !this.options.color ? h.color : this.nonZonedColor;
        return h;
      };

      d.prototype.hasNewShapeType = function () {
        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
      };

      d.prototype.init = function (e, c, d) {
        this.series = e;
        this.applyOptions(c, d);
        this.id = u(this.id) ? this.id : N();
        this.resolveColor();
        e.chart.pointCount++;
        q(this, "afterInit");
        return this;
      };

      d.prototype.optionsToObject = function (e) {
        var c = {},
            k = this.series,
            h = k.options.keys,
            f = h || k.pointArrayMap || ["y"],
            a = f.length,
            l = 0,
            g = 0;
        if (J(e) || null === e) c[f[0]] = e;else if (G(e)) for (!h && e.length > a && (k = typeof e[0], "string" === k ? c.name = e[0] : "number" === k && (c.x = e[0]), l++); g < a;) h && "undefined" === typeof e[l] || (0 < f[g].indexOf(".") ? d.prototype.setNestedProperty(c, e[l], f[g]) : c[f[g]] = e[l]), l++, g++;else "object" === typeof e && (c = e, e.dataLabels && (k._hasPointLabels = !0), e.marker && (k._hasPointMarkers = !0));
        return c;
      };

      d.prototype.resolveColor = function () {
        var e = this.series;
        var c = e.chart.options.chart.colorCount;
        var d = e.chart.styledMode;
        d || this.options.color || (this.color = e.color);
        e.options.colorByPoint ? (d || (c = e.options.colors || e.chart.options.colors, this.color = this.color || c[e.colorCounter], c = c.length), d = e.colorCounter, e.colorCounter++, e.colorCounter === c && (e.colorCounter = 0)) : d = e.colorIndex;
        this.colorIndex = D(this.colorIndex, d);
      };

      d.prototype.setNestedProperty = function (e, c, d) {
        d.split(".").reduce(function (e, f, a, d) {
          e[f] = d.length - 1 === a ? c : y(e[f], !0) ? e[f] : {};
          return e[f];
        }, e);
        return e;
      };

      d.prototype.tooltipFormatter = function (e) {
        var c = this.series,
            d = c.tooltipOptions,
            h = D(d.valueDecimals, ""),
            f = d.valuePrefix || "",
            a = d.valueSuffix || "";
        c.chart.styledMode && (e = c.chart.tooltip.styledModeFormat(e));
        (c.pointArrayMap || ["y"]).forEach(function (c) {
          c = "{point." + c;
          if (f || a) e = e.replace(RegExp(c + "}", "g"), f + c + "}" + a);
          e = e.replace(RegExp(c + "}", "g"), c + ":,." + h + "f}");
        });
        return E(e, {
          point: this,
          series: this.series
        }, c.chart);
      };

      return d;
    }();

    d.Point = g;
    return d.Point;
  });
  S(r, "parts/Series.js", [r["parts/Globals.js"], r["mixins/legend-symbol.js"], r["parts/Point.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    "";

    var I = u.addEvent,
        M = u.animObject,
        E = u.arrayMax,
        A = u.arrayMin,
        G = u.clamp,
        J = u.correctFloat,
        y = u.defined,
        t = u.erase,
        D = u.error,
        h = u.extend,
        N = u.find,
        q = u.fireEvent,
        P = u.getNestedProperty,
        e = u.isArray,
        c = u.isFunction,
        k = u.isNumber,
        n = u.isString,
        f = u.merge,
        a = u.objectEach,
        l = u.pick,
        v = u.removeEvent,
        z = u.seriesType,
        w = u.splat,
        B = u.syncTimeout,
        L = d.defaultOptions,
        Q = d.defaultPlotOptions,
        H = d.seriesTypes,
        K = d.SVGElement,
        p = d.win;
    d.Series = z("line", null, {
      lineWidth: 2,
      allowPointSelect: !1,
      showCheckbox: !1,
      animation: {
        duration: 1E3
      },
      events: {},
      marker: {
        enabledThreshold: 2,
        lineColor: "#ffffff",
        lineWidth: 0,
        radius: 4,
        states: {
          normal: {
            animation: !0
          },
          hover: {
            animation: {
              duration: 50
            },
            enabled: !0,
            radiusPlus: 2,
            lineWidthPlus: 1
          },
          select: {
            fillColor: "#cccccc",
            lineColor: "#000000",
            lineWidth: 2
          }
        }
      },
      point: {
        events: {}
      },
      dataLabels: {
        align: "center",
        formatter: function () {
          var b = this.series.chart.numberFormatter;
          return "number" !== typeof this.y ? "" : b(this.y, -1);
        },
        padding: 5,
        style: {
          fontSize: "11px",
          fontWeight: "bold",
          color: "contrast",
          textOutline: "1px contrast"
        },
        verticalAlign: "bottom",
        x: 0,
        y: 0
      },
      cropThreshold: 300,
      opacity: 1,
      pointRange: 0,
      softThreshold: !0,
      states: {
        normal: {
          animation: !0
        },
        hover: {
          animation: {
            duration: 50
          },
          lineWidthPlus: 1,
          marker: {},
          halo: {
            size: 10,
            opacity: .25
          }
        },
        select: {
          animation: {
            duration: 0
          }
        },
        inactive: {
          animation: {
            duration: 50
          },
          opacity: .2
        }
      },
      stickyTracking: !0,
      turboThreshold: 1E3,
      findNearestPointBy: "x"
    }, {
      axisTypes: ["xAxis", "yAxis"],
      coll: "series",
      colorCounter: 0,
      cropShoulder: 1,
      directTouch: !1,
      eventsToUnbind: [],
      isCartesian: !0,
      parallelArrays: ["x", "y"],
      pointClass: r,
      requireSorting: !0,
      sorted: !0,
      init: function (b, e) {
        q(this, "init", {
          options: e
        });
        var f = this,
            d = b.series,
            k;
        this.eventOptions = this.eventOptions || {};
        f.chart = b;
        f.options = e = f.setOptions(e);
        f.linkedSeries = [];
        f.bindAxes();
        h(f, {
          name: e.name,
          state: "",
          visible: !1 !== e.visible,
          selected: !0 === e.selected
        });
        var p = e.events;
        a(p, function (b, a) {
          c(b) && f.eventOptions[a] !== b && (c(f.eventOptions[a]) && v(f, a, f.eventOptions[a]), f.eventOptions[a] = b, I(f, a, b));
        });
        if (p && p.click || e.point && e.point.events && e.point.events.click || e.allowPointSelect) b.runTrackerClick = !0;
        f.getColor();
        f.getSymbol();
        f.parallelArrays.forEach(function (b) {
          f[b + "Data"] || (f[b + "Data"] = []);
        });
        f.isCartesian && (b.hasCartesianSeries = !0);
        d.length && (k = d[d.length - 1]);
        f._i = l(k && k._i, -1) + 1;
        b.orderSeries(this.insert(d));
        e.dataSorting && e.dataSorting.enabled ? f.setDataSortingOptions() : f.points || f.data || f.setData(e.data, !1);
        q(this, "afterInit");
      },
      is: function (b) {
        return H[b] && this instanceof H[b];
      },
      insert: function (b) {
        var a = this.options.index,
            c;

        if (k(a)) {
          for (c = b.length; c--;) if (a >= l(b[c].options.index, b[c]._i)) {
            b.splice(c + 1, 0, this);
            break;
          }

          -1 === c && b.unshift(this);
          c += 1;
        } else b.push(this);

        return l(c, b.length - 1);
      },
      bindAxes: function () {
        var b = this,
            a = b.options,
            c = b.chart,
            e;
        q(this, "bindAxes", null, function () {
          (b.axisTypes || []).forEach(function (f) {
            c[f].forEach(function (c) {
              e = c.options;
              if (a[f] === e.index || "undefined" !== typeof a[f] && a[f] === e.id || "undefined" === typeof a[f] && 0 === e.index) b.insert(c.series), b[f] = c, c.isDirty = !0;
            });
            b[f] || b.optionalAxis === f || D(18, !0, c);
          });
        });
        q(this, "afterBindAxes");
      },
      updateParallelArrays: function (b, a) {
        var c = b.series,
            e = arguments,
            f = k(a) ? function (e) {
          var f = "y" === e && c.toYData ? c.toYData(b) : b[e];
          c[e + "Data"][a] = f;
        } : function (b) {
          Array.prototype[a].apply(c[b + "Data"], Array.prototype.slice.call(e, 2));
        };
        c.parallelArrays.forEach(f);
      },
      hasData: function () {
        return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
      },
      autoIncrement: function () {
        var b = this.options,
            a = this.xIncrement,
            c,
            e = b.pointIntervalUnit,
            f = this.chart.time;
        a = l(a, b.pointStart, 0);
        this.pointInterval = c = l(this.pointInterval, b.pointInterval, 1);
        e && (b = new f.Date(a), "day" === e ? f.set("Date", b, f.get("Date", b) + c) : "month" === e ? f.set("Month", b, f.get("Month", b) + c) : "year" === e && f.set("FullYear", b, f.get("FullYear", b) + c), c = b.getTime() - a);
        this.xIncrement = a + c;
        return a;
      },
      setDataSortingOptions: function () {
        var b = this.options;
        h(this, {
          requireSorting: !1,
          sorted: !1,
          enabledDataSorting: !0,
          allowDG: !1
        });
        y(b.pointRange) || (b.pointRange = 1);
      },
      setOptions: function (b) {
        var a = this.chart,
            c = a.options,
            e = c.plotOptions,
            d = a.userOptions || {};
        b = f(b);
        a = a.styledMode;
        var k = {
          plotOptions: e,
          userOptions: b
        };
        q(this, "setOptions", k);
        var h = k.plotOptions[this.type],
            m = d.plotOptions || {};
        this.userOptions = k.userOptions;
        d = f(h, e.series, d.plotOptions && d.plotOptions[this.type], b);
        this.tooltipOptions = f(L.tooltip, L.plotOptions.series && L.plotOptions.series.tooltip, L.plotOptions[this.type].tooltip, c.tooltip.userOptions, e.series && e.series.tooltip, e[this.type].tooltip, b.tooltip);
        this.stickyTracking = l(b.stickyTracking, m[this.type] && m[this.type].stickyTracking, m.series && m.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : d.stickyTracking);
        null === h.marker && delete d.marker;
        this.zoneAxis = d.zoneAxis;
        c = this.zones = (d.zones || []).slice();
        !d.negativeColor && !d.negativeFillColor || d.zones || (e = {
          value: d[this.zoneAxis + "Threshold"] || d.threshold || 0,
          className: "highcharts-negative"
        }, a || (e.color = d.negativeColor, e.fillColor = d.negativeFillColor), c.push(e));
        c.length && y(c[c.length - 1].value) && c.push(a ? {} : {
          color: this.color,
          fillColor: this.fillColor
        });
        q(this, "afterSetOptions", {
          options: d
        });
        return d;
      },
      getName: function () {
        return l(this.options.name, "Series " + (this.index + 1));
      },
      getCyclic: function (b, a, c) {
        var e = this.chart,
            f = this.userOptions,
            d = b + "Index",
            k = b + "Counter",
            h = c ? c.length : l(e.options.chart[b + "Count"], e[b + "Count"]);

        if (!a) {
          var p = l(f[d], f["_" + d]);
          y(p) || (e.series.length || (e[k] = 0), f["_" + d] = p = e[k] % h, e[k] += 1);
          c && (a = c[p]);
        }

        "undefined" !== typeof p && (this[d] = p);
        this[b] = a;
      },
      getColor: function () {
        this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.options.color = null : this.getCyclic("color", this.options.color || Q[this.type].color, this.chart.options.colors);
      },
      getPointsCollection: function () {
        return (this.hasGroupedData ? this.points : this.data) || [];
      },
      getSymbol: function () {
        this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
      },
      findPointIndex: function (b, a) {
        var c = b.id,
            e = b.x,
            f = this.points,
            d,
            h = this.options.dataSorting;
        if (c) var l = this.chart.get(c);else if (this.linkedParent || this.enabledDataSorting) {
          var p = h && h.matchByName ? "name" : "index";
          l = N(f, function (a) {
            return !a.touched && a[p] === b[p];
          });
          if (!l) return;
        }

        if (l) {
          var n = l && l.index;
          "undefined" !== typeof n && (d = !0);
        }

        "undefined" === typeof n && k(e) && (n = this.xData.indexOf(e, a));
        -1 !== n && "undefined" !== typeof n && this.cropped && (n = n >= this.cropStart ? n - this.cropStart : n);
        !d && f[n] && f[n].touched && (n = void 0);
        return n;
      },
      drawLegendSymbol: g.drawLineMarker,
      updateData: function (b, a) {
        var c = this.options,
            e = c.dataSorting,
            f = this.points,
            d = [],
            h,
            l,
            n,
            p = this.requireSorting,
            g = b.length === f.length,
            w = !0;
        this.xIncrement = null;
        b.forEach(function (b, a) {
          var l = y(b) && this.pointClass.prototype.optionsToObject.call({
            series: this
          }, b) || {};
          var m = l.x;

          if (l.id || k(m)) {
            if (m = this.findPointIndex(l, n), -1 === m || "undefined" === typeof m ? d.push(b) : f[m] && b !== c.data[m] ? (f[m].update(b, !1, null, !1), f[m].touched = !0, p && (n = m + 1)) : f[m] && (f[m].touched = !0), !g || a !== m || e && e.enabled || this.hasDerivedData) h = !0;
          } else d.push(b);
        }, this);
        if (h) for (b = f.length; b--;) (l = f[b]) && !l.touched && l.remove && l.remove(!1, a);else !g || e && e.enabled ? w = !1 : (b.forEach(function (b, a) {
          f[a].update && b !== f[a].y && f[a].update(b, !1, null, !1);
        }), d.length = 0);
        f.forEach(function (b) {
          b && (b.touched = !1);
        });
        if (!w) return !1;
        d.forEach(function (b) {
          this.addPoint(b, !1, null, null, !1);
        }, this);
        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = E(this.xData), this.autoIncrement());
        return !0;
      },
      setData: function (b, a, c, f) {
        var d = this,
            h = d.points,
            p = h && h.length || 0,
            m,
            g = d.options,
            w = d.chart,
            x = g.dataSorting,
            q = null,
            v = d.xAxis;
        q = g.turboThreshold;
        var C = this.xData,
            t = this.yData,
            B = (m = d.pointArrayMap) && m.length,
            z = g.keys,
            y = 0,
            L = 1,
            u;
        b = b || [];
        m = b.length;
        a = l(a, !0);
        x && x.enabled && (b = this.sortData(b));
        !1 !== f && m && p && !d.cropped && !d.hasGroupedData && d.visible && !d.isSeriesBoosting && (u = this.updateData(b, c));

        if (!u) {
          d.xIncrement = null;
          d.colorCounter = 0;
          this.parallelArrays.forEach(function (b) {
            d[b + "Data"].length = 0;
          });
          if (q && m > q) {
            if (q = d.getFirstValidPoint(b), k(q)) for (c = 0; c < m; c++) C[c] = this.autoIncrement(), t[c] = b[c];else if (e(q)) {
              if (B) for (c = 0; c < m; c++) f = b[c], C[c] = f[0], t[c] = f.slice(1, B + 1);else for (z && (y = z.indexOf("x"), L = z.indexOf("y"), y = 0 <= y ? y : 0, L = 0 <= L ? L : 1), c = 0; c < m; c++) f = b[c], C[c] = f[y], t[c] = f[L];
            } else D(12, !1, w);
          } else for (c = 0; c < m; c++) "undefined" !== typeof b[c] && (f = {
            series: d
          }, d.pointClass.prototype.applyOptions.apply(f, [b[c]]), d.updateParallelArrays(f, c));
          t && n(t[0]) && D(14, !0, w);
          d.data = [];
          d.options.data = d.userOptions.data = b;

          for (c = p; c--;) h[c] && h[c].destroy && h[c].destroy();

          v && (v.minRange = v.userMinRange);
          d.isDirty = w.isDirtyBox = !0;
          d.isDirtyData = !!h;
          c = !1;
        }

        "point" === g.legendType && (this.processData(), this.generatePoints());
        a && w.redraw(c);
      },
      sortData: function (b) {
        var a = this,
            c = a.options.dataSorting.sortKey || "y",
            e = function (b, a) {
          return y(a) && b.pointClass.prototype.optionsToObject.call({
            series: b
          }, a) || {};
        };

        b.forEach(function (c, f) {
          b[f] = e(a, c);
          b[f].index = f;
        }, this);
        b.concat().sort(function (b, a) {
          b = P(c, b);
          a = P(c, a);
          return a < b ? -1 : a > b ? 1 : 0;
        }).forEach(function (b, a) {
          b.x = a;
        }, this);
        a.linkedSeries && a.linkedSeries.forEach(function (a) {
          var c = a.options,
              f = c.data;
          c.dataSorting && c.dataSorting.enabled || !f || (f.forEach(function (c, d) {
            f[d] = e(a, c);
            b[d] && (f[d].x = b[d].x, f[d].index = d);
          }), a.setData(f, !1));
        });
        return b;
      },
      processData: function (b) {
        var a = this.xData,
            c = this.yData,
            e = a.length;
        var f = 0;
        var d = this.xAxis,
            k = this.options;
        var h = k.cropThreshold;
        var l = this.getExtremesFromAll || k.getExtremesFromAll,
            p = this.isCartesian;
        k = d && d.val2lin;
        var n = d && d.isLog,
            g = this.requireSorting;
        if (p && !this.isDirty && !d.isDirty && !this.yAxis.isDirty && !b) return !1;

        if (d) {
          b = d.getExtremes();
          var w = b.min;
          var q = b.max;
        }

        if (p && this.sorted && !l && (!h || e > h || this.forceCrop)) if (a[e - 1] < w || a[0] > q) a = [], c = [];else if (this.yData && (a[0] < w || a[e - 1] > q)) {
          f = this.cropData(this.xData, this.yData, w, q);
          a = f.xData;
          c = f.yData;
          f = f.start;
          var v = !0;
        }

        for (h = a.length || 1; --h;) if (e = n ? k(a[h]) - k(a[h - 1]) : a[h] - a[h - 1], 0 < e && ("undefined" === typeof t || e < t)) var t = e;else 0 > e && g && (D(15, !1, this.chart), g = !1);

        this.cropped = v;
        this.cropStart = f;
        this.processedXData = a;
        this.processedYData = c;
        this.closestPointRange = this.basePointRange = t;
      },
      cropData: function (b, a, c, e, f) {
        var d = b.length,
            k = 0,
            h = d,
            p;
        f = l(f, this.cropShoulder);

        for (p = 0; p < d; p++) if (b[p] >= c) {
          k = Math.max(0, p - f);
          break;
        }

        for (c = p; c < d; c++) if (b[c] > e) {
          h = c + f;
          break;
        }

        return {
          xData: b.slice(k, h),
          yData: a.slice(k, h),
          start: k,
          end: h
        };
      },
      generatePoints: function () {
        var b = this.options,
            a = b.data,
            c = this.data,
            e,
            f = this.processedXData,
            d = this.processedYData,
            k = this.pointClass,
            l = f.length,
            p = this.cropStart || 0,
            n = this.hasGroupedData;
        b = b.keys;
        var g = [],
            v;
        c || n || (c = [], c.length = a.length, c = this.data = c);
        b && n && (this.options.keys = !1);

        for (v = 0; v < l; v++) {
          var t = p + v;

          if (n) {
            var B = new k().init(this, [f[v]].concat(w(d[v])));
            B.dataGroup = this.groupMap[v];
            B.dataGroup.options && (B.options = B.dataGroup.options, h(B, B.dataGroup.options), delete B.dataLabels);
          } else (B = c[t]) || "undefined" === typeof a[t] || (c[t] = B = new k().init(this, a[t], f[v]));

          B && (B.index = t, g[v] = B);
        }

        this.options.keys = b;
        if (c && (l !== (e = c.length) || n)) for (v = 0; v < e; v++) v !== p || n || (v += l), c[v] && (c[v].destroyElements(), c[v].plotX = void 0);
        this.data = c;
        this.points = g;
        q(this, "afterGeneratePoints");
      },
      getXExtremes: function (b) {
        return {
          min: A(b),
          max: E(b)
        };
      },
      getExtremes: function (b) {
        var a = this.xAxis,
            c = this.yAxis,
            f = this.processedXData || this.xData,
            d = [],
            h = 0,
            l = 0;
        var m = 0;
        var p = this.requireSorting ? this.cropShoulder : 0,
            n = c ? c.positiveValuesOnly : !1,
            g;
        b = b || this.stackedYData || this.processedYData || [];
        c = b.length;
        a && (m = a.getExtremes(), l = m.min, m = m.max);

        for (g = 0; g < c; g++) {
          var w = f[g];
          var v = b[g];
          var t = (k(v) || e(v)) && (v.length || 0 < v || !n);
          w = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !a || (f[g + p] || w) >= l && (f[g - p] || w) <= m;
          if (t && w) if (t = v.length) for (; t--;) k(v[t]) && (d[h++] = v[t]);else d[h++] = v;
        }

        this.dataMin = A(d);
        this.dataMax = E(d);
        q(this, "afterGetExtremes");
      },
      getFirstValidPoint: function (b) {
        for (var a = null, c = b.length, e = 0; null === a && e < c;) a = b[e], e++;

        return a;
      },
      translate: function () {
        this.processedXData || this.processData();
        this.generatePoints();
        var b = this.options,
            a = b.stacking,
            c = this.xAxis,
            f = c.categories,
            d = this.enabledDataSorting,
            h = this.yAxis,
            p = this.points,
            m = p.length,
            n = !!this.modifyValue,
            g,
            w = this.pointPlacementToXValue(),
            v = !!w,
            t = b.threshold,
            B = b.startFromThreshold ? t : 0,
            z,
            L = this.zoneAxis || "y",
            u = Number.MAX_VALUE;

        for (g = 0; g < m; g++) {
          var K = p[g],
              r = K.x,
              H = K.y,
              D = K.low,
              A = a && h.stacks[(this.negStacks && H < (B ? 0 : t) ? "-" : "") + this.stackKey];
          h.positiveValuesOnly && null !== H && 0 >= H && (K.isNull = !0);
          K.plotX = z = J(G(c.translate(r, 0, 0, 0, 1, w, "flags" === this.type), -1E5, 1E5));

          if (a && this.visible && A && A[r]) {
            var N = this.getStackIndicator(N, r, this.index);

            if (!K.isNull) {
              var Q = A[r];
              var E = Q.points[N.key];
            }
          }

          e(E) && (D = E[0], H = E[1], D === B && N.key === A[r].base && (D = l(k(t) && t, h.min)), h.positiveValuesOnly && 0 >= D && (D = null), K.total = K.stackTotal = Q.total, K.percentage = Q.total && K.y / Q.total * 100, K.stackY = H, this.irregularWidths || Q.setOffset(this.pointXOffset || 0, this.barW || 0));
          K.yBottom = y(D) ? G(h.translate(D, 0, 1, 0, 1), -1E5, 1E5) : null;
          n && (H = this.modifyValue(H, K));
          K.plotY = "number" === typeof H && Infinity !== H ? G(h.translate(H, 0, 1, 0, 1), -1E5, 1E5) : void 0;
          K.isInside = this.isPointInside(K);
          K.clientX = v ? J(c.translate(r, 0, 0, 0, 1, w)) : z;
          K.negative = K[L] < (b[L + "Threshold"] || t || 0);
          K.category = f && "undefined" !== typeof f[K.x] ? f[K.x] : K.x;

          if (!K.isNull && !1 !== K.visible) {
            "undefined" !== typeof P && (u = Math.min(u, Math.abs(z - P)));
            var P = z;
          }

          K.zone = this.zones.length && K.getZone();
          !K.graphic && this.group && d && (K.isNew = !0);
        }

        this.closestPointRangePx = u;
        q(this, "afterTranslate");
      },
      getValidPoints: function (b, a, c) {
        var e = this.chart;
        return (b || this.points || []).filter(function (b) {
          return a && !e.isInsidePlot(b.plotX, b.plotY, e.inverted) ? !1 : !1 !== b.visible && (c || !b.isNull);
        });
      },
      getClipBox: function (b, a) {
        var c = this.options,
            e = this.chart,
            f = e.inverted,
            d = this.xAxis,
            k = d && this.yAxis;
        b && !1 === c.clip && k ? b = f ? {
          y: -e.chartWidth + k.len + k.pos,
          height: e.chartWidth,
          width: e.chartHeight,
          x: -e.chartHeight + d.len + d.pos
        } : {
          y: -k.pos,
          height: e.chartHeight,
          width: e.chartWidth,
          x: -d.pos
        } : (b = this.clipBox || e.clipBox, a && (b.width = e.plotSizeX, b.x = 0));
        return a ? {
          width: b.width,
          x: b.x
        } : b;
      },
      setClip: function (b) {
        var a = this.chart,
            c = this.options,
            e = a.renderer,
            f = a.inverted,
            d = this.clipBox,
            k = this.getClipBox(b),
            h = this.sharedClipKey || ["_sharedClip", b && b.duration, b && b.easing, k.height, c.xAxis, c.yAxis].join(),
            l = a[h],
            p = a[h + "m"];
        b && (k.width = 0, f && (k.x = a.plotHeight + (!1 !== c.clip ? 0 : a.plotTop)));
        l ? a.hasLoaded || l.attr(k) : (b && (a[h + "m"] = p = e.clipRect(f ? a.plotSizeX + 99 : -99, f ? -a.plotLeft : -a.plotTop, 99, f ? a.chartWidth : a.chartHeight)), a[h] = l = e.clipRect(k), l.count = {
          length: 0
        });
        b && !l.count[this.index] && (l.count[this.index] = !0, l.count.length += 1);
        if (!1 !== c.clip || b) this.group.clip(b || d ? l : a.clipRect), this.markerGroup.clip(p), this.sharedClipKey = h;
        b || (l.count[this.index] && (delete l.count[this.index], --l.count.length), 0 === l.count.length && h && a[h] && (d || (a[h] = a[h].destroy()), a[h + "m"] && (a[h + "m"] = a[h + "m"].destroy())));
      },
      animate: function (b) {
        var a = this.chart,
            c = M(this.options.animation);
        if (!a.hasRendered) if (b) this.setClip(c);else {
          var e = this.sharedClipKey;
          b = a[e];
          var f = this.getClipBox(c, !0);
          b && b.animate(f, c);
          a[e + "m"] && a[e + "m"].animate({
            width: f.width + 99,
            x: f.x - (a.inverted ? 0 : 99)
          }, c);
        }
      },
      afterAnimate: function () {
        this.setClip();
        q(this, "afterAnimate");
        this.finishedAnimating = !0;
      },
      drawPoints: function () {
        var b = this.points,
            a = this.chart,
            c,
            e,
            f = this.options.marker,
            d = this[this.specialGroup] || this.markerGroup,
            k = this.xAxis,
            h = l(f.enabled, !k || k.isRadial ? !0 : null, this.closestPointRangePx >= f.enabledThreshold * f.radius);
        if (!1 !== f.enabled || this._hasPointMarkers) for (c = 0; c < b.length; c++) {
          var p = b[c];
          var n = (e = p.graphic) ? "animate" : "attr";
          var g = p.marker || {};
          var w = !!p.marker;

          if ((h && "undefined" === typeof g.enabled || g.enabled) && !p.isNull && !1 !== p.visible) {
            var v = l(g.symbol, this.symbol);
            var q = this.markerAttribs(p, p.selected && "select");
            this.enabledDataSorting && (p.startXPos = k.reversed ? -q.width : k.width);
            var t = !1 !== p.isInside;
            e ? e[t ? "show" : "hide"](t).animate(q) : t && (0 < q.width || p.hasImage) && (p.graphic = e = a.renderer.symbol(v, q.x, q.y, q.width, q.height, w ? g : f).add(d), this.enabledDataSorting && a.hasRendered && (e.attr({
              x: p.startXPos
            }), n = "animate"));
            e && "animate" === n && e[t ? "show" : "hide"](t).animate(q);
            if (e && !a.styledMode) e[n](this.pointAttribs(p, p.selected && "select"));
            e && e.addClass(p.getClassName(), !0);
          } else e && (p.graphic = e.destroy());
        }
      },
      markerAttribs: function (b, a) {
        var c = this.options.marker,
            e = b.marker || {},
            f = e.symbol || c.symbol,
            d = l(e.radius, c.radius);
        a && (c = c.states[a], a = e.states && e.states[a], d = l(a && a.radius, c && c.radius, d + (c && c.radiusPlus || 0)));
        b.hasImage = f && 0 === f.indexOf("url");
        b.hasImage && (d = 0);
        b = {
          x: Math.floor(b.plotX) - d,
          y: b.plotY - d
        };
        d && (b.width = b.height = 2 * d);
        return b;
      },
      pointAttribs: function (b, a) {
        var c = this.options.marker,
            e = b && b.options,
            f = e && e.marker || {},
            d = this.color,
            k = e && e.color,
            h = b && b.color;
        e = l(f.lineWidth, c.lineWidth);
        var p = b && b.zone && b.zone.color;
        b = 1;
        d = k || p || h || d;
        k = f.fillColor || c.fillColor || d;
        d = f.lineColor || c.lineColor || d;
        a = a || "normal";
        c = c.states[a];
        a = f.states && f.states[a] || {};
        e = l(a.lineWidth, c.lineWidth, e + l(a.lineWidthPlus, c.lineWidthPlus, 0));
        k = a.fillColor || c.fillColor || k;
        d = a.lineColor || c.lineColor || d;
        b = l(a.opacity, c.opacity, b);
        return {
          stroke: d,
          "stroke-width": e,
          fill: k,
          opacity: b
        };
      },
      destroy: function (b) {
        var c = this,
            e = c.chart,
            f = /AppleWebKit\/533/.test(p.navigator.userAgent),
            d,
            k,
            h = c.data || [],
            l,
            n;
        q(c, "destroy");
        this.removeEvents(b);
        (c.axisTypes || []).forEach(function (b) {
          (n = c[b]) && n.series && (t(n.series, c), n.isDirty = n.forceRedraw = !0);
        });
        c.legendItem && c.chart.legend.destroyItem(c);

        for (k = h.length; k--;) (l = h[k]) && l.destroy && l.destroy();

        c.points = null;
        u.clearTimeout(c.animationTimeout);
        a(c, function (b, a) {
          b instanceof K && !b.survive && (d = f && "group" === a ? "hide" : "destroy", b[d]());
        });
        e.hoverSeries === c && (e.hoverSeries = null);
        t(e.series, c);
        e.orderSeries();
        a(c, function (a, e) {
          b && "hcEvents" === e || delete c[e];
        });
      },
      getGraphPath: function (b, a, c) {
        var e = this,
            f = e.options,
            d = f.step,
            k,
            h = [],
            l = [],
            p;
        b = b || e.points;
        (k = b.reversed) && b.reverse();
        (d = {
          right: 1,
          center: 2
        }[d] || d && 3) && k && (d = 4 - d);
        b = this.getValidPoints(b, !1, !(f.connectNulls && !a && !c));
        b.forEach(function (k, n) {
          var m = k.plotX,
              g = k.plotY,
              w = b[n - 1];
          (k.leftCliff || w && w.rightCliff) && !c && (p = !0);
          k.isNull && !y(a) && 0 < n ? p = !f.connectNulls : k.isNull && !a ? p = !0 : (0 === n || p ? n = ["M", k.plotX, k.plotY] : e.getPointSpline ? n = e.getPointSpline(b, k, n) : d ? (n = 1 === d ? ["L", w.plotX, g] : 2 === d ? ["L", (w.plotX + m) / 2, w.plotY, "L", (w.plotX + m) / 2, g] : ["L", m, w.plotY], n.push("L", m, g)) : n = ["L", m, g], l.push(k.x), d && (l.push(k.x), 2 === d && l.push(k.x)), h.push.apply(h, n), p = !1);
        });
        h.xMap = l;
        return e.graphPath = h;
      },
      drawGraph: function () {
        var b = this,
            a = this.options,
            c = (this.gappedPath || this.getGraphPath).call(this),
            e = this.chart.styledMode,
            f = [["graph", "highcharts-graph"]];
        e || f[0].push(a.lineColor || this.color || "#cccccc", a.dashStyle);
        f = b.getZonesGraphs(f);
        f.forEach(function (f, d) {
          var k = f[0],
              h = b[k],
              l = h ? "animate" : "attr";
          h ? (h.endX = b.preventGraphAnimation ? null : c.xMap, h.animate({
            d: c
          })) : c.length && (b[k] = h = b.chart.renderer.path(c).addClass(f[1]).attr({
            zIndex: 1
          }).add(b.group));
          h && !e && (k = {
            stroke: f[2],
            "stroke-width": a.lineWidth,
            fill: b.fillGraph && b.color || "none"
          }, f[3] ? k.dashstyle = f[3] : "square" !== a.linecap && (k["stroke-linecap"] = k["stroke-linejoin"] = "round"), h[l](k).shadow(2 > d && a.shadow));
          h && (h.startX = c.xMap, h.isArea = c.isArea);
        });
      },
      getZonesGraphs: function (a) {
        this.zones.forEach(function (b, c) {
          c = ["zone-graph-" + c, "highcharts-graph highcharts-zone-graph-" + c + " " + (b.className || "")];
          this.chart.styledMode || c.push(b.color || this.color, b.dashStyle || this.options.dashStyle);
          a.push(c);
        }, this);
        return a;
      },
      applyZones: function () {
        var a = this,
            c = this.chart,
            e = c.renderer,
            f = this.zones,
            d,
            k,
            h = this.clips || [],
            p,
            n = this.graph,
            g = this.area,
            w = Math.max(c.chartWidth, c.chartHeight),
            v = this[(this.zoneAxis || "y") + "Axis"],
            q = c.inverted,
            t,
            B,
            z,
            y = !1;

        if (f.length && (n || g) && v && "undefined" !== typeof v.min) {
          var K = v.reversed;
          var L = v.horiz;
          n && !this.showLine && n.hide();
          g && g.hide();
          var u = v.getExtremes();
          f.forEach(function (b, f) {
            d = K ? L ? c.plotWidth : 0 : L ? 0 : v.toPixels(u.min) || 0;
            d = G(l(k, d), 0, w);
            k = G(Math.round(v.toPixels(l(b.value, u.max), !0) || 0), 0, w);
            y && (d = k = v.toPixels(u.max));
            t = Math.abs(d - k);
            B = Math.min(d, k);
            z = Math.max(d, k);
            v.isXAxis ? (p = {
              x: q ? z : B,
              y: 0,
              width: t,
              height: w
            }, L || (p.x = c.plotHeight - p.x)) : (p = {
              x: 0,
              y: q ? z : B,
              width: w,
              height: t
            }, L && (p.y = c.plotWidth - p.y));
            q && e.isVML && (p = v.isXAxis ? {
              x: 0,
              y: K ? B : z,
              height: p.width,
              width: c.chartWidth
            } : {
              x: p.y - c.plotLeft - c.spacingBox.x,
              y: 0,
              width: p.height,
              height: c.chartHeight
            });
            h[f] ? h[f].animate(p) : h[f] = e.clipRect(p);
            n && a["zone-graph-" + f].clip(h[f]);
            g && a["zone-area-" + f].clip(h[f]);
            y = b.value > u.max;
            a.resetZones && 0 === k && (k = void 0);
          });
          this.clips = h;
        } else a.visible && (n && n.show(!0), g && g.show(!0));
      },
      invertGroups: function (a) {
        function b() {
          ["group", "markerGroup"].forEach(function (b) {
            c[b] && (e.renderer.isVML && c[b].attr({
              width: c.yAxis.len,
              height: c.xAxis.len
            }), c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(c.isRadialSeries ? !1 : a));
          });
        }

        var c = this,
            e = c.chart;
        c.xAxis && (c.eventsToUnbind.push(I(e, "resize", b)), b(), c.invertGroups = b);
      },
      plotGroup: function (a, c, e, f, d) {
        var b = this[a],
            k = !b;
        k && (this[a] = b = this.chart.renderer.g().attr({
          zIndex: f || .1
        }).add(d));
        b.addClass("highcharts-" + c + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (y(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (b.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
        b.attr({
          visibility: e
        })[k ? "attr" : "animate"](this.getPlotBox());
        return b;
      },
      getPlotBox: function () {
        var a = this.chart,
            c = this.xAxis,
            e = this.yAxis;
        a.inverted && (c = e, e = this.xAxis);
        return {
          translateX: c ? c.left : a.plotLeft,
          translateY: e ? e.top : a.plotTop,
          scaleX: 1,
          scaleY: 1
        };
      },
      removeEvents: function (a) {
        a ? this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (a) {
          a();
        }), this.eventsToUnbind.length = 0) : v(this);
      },
      render: function () {
        var a = this,
            c = a.chart,
            e = a.options,
            f = !a.finishedAnimating && c.renderer.isSVG && M(e.animation).duration,
            d = a.visible ? "inherit" : "hidden",
            k = e.zIndex,
            h = a.hasRendered,
            l = c.seriesGroup,
            p = c.inverted;
        q(this, "render");
        var n = a.plotGroup("group", "series", d, k, l);
        a.markerGroup = a.plotGroup("markerGroup", "markers", d, k, l);
        f && a.animate && a.animate(!0);
        n.inverted = a.isCartesian || a.invertable ? p : !1;
        a.drawGraph && (a.drawGraph(), a.applyZones());
        a.visible && a.drawPoints();
        a.drawDataLabels && a.drawDataLabels();
        a.redrawPoints && a.redrawPoints();
        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();
        a.invertGroups(p);
        !1 === e.clip || a.sharedClipKey || h || n.clip(c.clipRect);
        f && a.animate && a.animate();
        h || (a.animationTimeout = B(function () {
          a.afterAnimate();
        }, f || 0));
        a.isDirty = !1;
        a.hasRendered = !0;
        q(a, "afterRender");
      },
      redraw: function () {
        var a = this.chart,
            c = this.isDirty || this.isDirtyData,
            e = this.group,
            f = this.xAxis,
            d = this.yAxis;
        e && (a.inverted && e.attr({
          width: a.plotWidth,
          height: a.plotHeight
        }), e.animate({
          translateX: l(f && f.left, a.plotLeft),
          translateY: l(d && d.top, a.plotTop)
        }));
        this.translate();
        this.render();
        c && delete this.kdTree;
      },
      kdAxisArray: ["clientX", "plotY"],
      searchPoint: function (a, c) {
        var b = this.xAxis,
            e = this.yAxis,
            f = this.chart.inverted;
        return this.searchKDTree({
          clientX: f ? b.len - a.chartY + b.pos : a.chartX - b.pos,
          plotY: f ? e.len - a.chartX + e.pos : a.chartY - e.pos
        }, c, a);
      },
      buildKDTree: function (a) {
        function b(a, e, f) {
          var d;

          if (d = a && a.length) {
            var k = c.kdAxisArray[e % f];
            a.sort(function (a, b) {
              return a[k] - b[k];
            });
            d = Math.floor(d / 2);
            return {
              point: a[d],
              left: b(a.slice(0, d), e + 1, f),
              right: b(a.slice(d + 1), e + 1, f)
            };
          }
        }

        this.buildingKdTree = !0;
        var c = this,
            e = -1 < c.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        delete c.kdTree;
        B(function () {
          c.kdTree = b(c.getValidPoints(null, !c.directTouch), e, e);
          c.buildingKdTree = !1;
        }, c.options.kdNow || a && "touchstart" === a.type ? 0 : 1);
      },
      searchKDTree: function (a, c, e) {
        function b(a, c, e, l) {
          var p = c.point,
              n = f.kdAxisArray[e % l],
              g = p;
          var m = y(a[d]) && y(p[d]) ? Math.pow(a[d] - p[d], 2) : null;
          var w = y(a[k]) && y(p[k]) ? Math.pow(a[k] - p[k], 2) : null;
          w = (m || 0) + (w || 0);
          p.dist = y(w) ? Math.sqrt(w) : Number.MAX_VALUE;
          p.distX = y(m) ? Math.sqrt(m) : Number.MAX_VALUE;
          n = a[n] - p[n];
          w = 0 > n ? "left" : "right";
          m = 0 > n ? "right" : "left";
          c[w] && (w = b(a, c[w], e + 1, l), g = w[h] < g[h] ? w : p);
          c[m] && Math.sqrt(n * n) < g[h] && (a = b(a, c[m], e + 1, l), g = a[h] < g[h] ? a : g);
          return g;
        }

        var f = this,
            d = this.kdAxisArray[0],
            k = this.kdAxisArray[1],
            h = c ? "distX" : "dist";
        c = -1 < f.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        this.kdTree || this.buildingKdTree || this.buildKDTree(e);
        if (this.kdTree) return b(a, this.kdTree, c, c);
      },
      pointPlacementToXValue: function () {
        var a = this.options,
            c = a.pointRange,
            e = this.xAxis;
        a = a.pointPlacement;
        "between" === a && (a = e.reversed ? -.5 : .5);
        return k(a) ? a * l(c, e.pointRange) : 0;
      },
      isPointInside: function (a) {
        return "undefined" !== typeof a.plotY && "undefined" !== typeof a.plotX && 0 <= a.plotY && a.plotY <= this.yAxis.len && 0 <= a.plotX && a.plotX <= this.xAxis.len;
      }
    });
    "";
  });
  S(r, "parts/Stacking.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.correctFloat,
        u = g.defined,
        I = g.destroyObjectProperties,
        M = g.format,
        E = g.objectEach,
        A = g.pick;
    g = d.Axis;
    var G = d.Chart,
        J = d.Series;

    d.StackItem = function (d, g, u, h, r) {
      var q = d.chart.inverted;
      this.axis = d;
      this.isNegative = u;
      this.options = g = g || {};
      this.x = h;
      this.total = null;
      this.points = {};
      this.stack = r;
      this.rightCliff = this.leftCliff = 0;
      this.alignOptions = {
        align: g.align || (q ? u ? "left" : "right" : "center"),
        verticalAlign: g.verticalAlign || (q ? "middle" : u ? "bottom" : "top"),
        y: g.y,
        x: g.x
      };
      this.textAlign = g.textAlign || (q ? u ? "right" : "left" : "center");
    };

    d.StackItem.prototype = {
      destroy: function () {
        I(this, this.axis);
      },
      render: function (d) {
        var g = this.axis.chart,
            y = this.options,
            h = y.format;
        h = h ? M(h, this, g) : y.formatter.call(this);
        this.label ? this.label.attr({
          text: h,
          visibility: "hidden"
        }) : (this.label = g.renderer.label(h, null, null, y.shape, null, null, y.useHTML, !1, "stack-labels"), h = {
          text: h,
          rotation: y.rotation,
          padding: A(y.padding, 5),
          visibility: "hidden"
        }, this.label.attr(h), g.styledMode || this.label.css(y.style), this.label.added || this.label.add(d));
        this.label.labelrank = g.plotHeight;
      },
      setOffset: function (d, g, r, h, N) {
        var q = this.axis,
            t = q.chart;
        h = q.translate(q.usePercentage ? 100 : h ? h : this.total, 0, 0, 0, 1);
        r = q.translate(r ? r : 0);
        r = u(h) && Math.abs(h - r);
        d = A(N, t.xAxis[0].translate(this.x)) + d;
        q = u(h) && this.getStackBox(t, this, d, h, g, r, q);
        g = this.label;
        r = this.isNegative;
        d = "justify" === A(this.options.overflow, "justify");
        var e = this.textAlign;
        g && q && (N = g.getBBox(), h = g.padding, e = "left" === e ? t.inverted ? -h : h : "right" === e ? N.width : t.inverted && "center" === e ? N.width / 2 : t.inverted ? r ? N.width + h : -h : N.width / 2, r = t.inverted ? N.height / 2 : r ? -h : N.height, this.alignOptions.x = A(this.options.x, 0), this.alignOptions.y = A(this.options.y, 0), q.x -= e, q.y -= r, g.align(this.alignOptions, null, q), t.isInsidePlot(g.alignAttr.x + e - this.alignOptions.x, g.alignAttr.y + r - this.alignOptions.y) ? g.show() : (g.alignAttr.y = -9999, d = !1), d && J.prototype.justifyDataLabel.call(this.axis, g, this.alignOptions, g.alignAttr, N, q), g.attr({
          x: g.alignAttr.x,
          y: g.alignAttr.y
        }), A(!d && this.options.crop, !0) && ((t = t.isInsidePlot(g.x - h + g.width, g.y) && t.isInsidePlot(g.x + h, g.y)) || g.hide()));
      },
      getStackBox: function (d, g, r, h, u, q, A) {
        var e = g.axis.reversed,
            c = d.inverted;
        d = A.height + A.pos - (c ? d.plotLeft : d.plotTop);
        g = g.isNegative && !e || !g.isNegative && e;
        return {
          x: c ? g ? h : h - q : r,
          y: c ? d - r - u : g ? d - h - q : d - h,
          width: c ? q : u,
          height: c ? u : q
        };
      }
    };

    G.prototype.getStacks = function () {
      var d = this,
          g = d.inverted;
      d.yAxis.forEach(function (d) {
        d.stacks && d.hasVisibleSeries && (d.oldStacks = d.stacks);
      });
      d.series.forEach(function (t) {
        var h = t.xAxis && t.xAxis.options || {};
        !t.options.stacking || !0 !== t.visible && !1 !== d.options.chart.ignoreHiddenSeries || (t.stackKey = [t.type, A(t.options.stack, ""), g ? h.top : h.left, g ? h.height : h.width].join());
      });
    };

    g.prototype.buildStacks = function () {
      var g = this.series,
          t = A(this.options.reversedStacks, !0),
          r = g.length,
          h;

      if (!this.isXAxis) {
        this.usePercentage = !1;

        for (h = r; h--;) {
          var u = g[t ? h : r - h - 1];
          u.setStackedPoints();
        }

        for (h = 0; h < r; h++) g[h].modifyStacks();

        d.fireEvent(this, "afterBuildStacks");
      }
    };

    g.prototype.renderStackTotals = function () {
      var d = this.chart,
          g = d.renderer,
          r = this.stacks,
          h = this.stackTotalGroup;
      h || (this.stackTotalGroup = h = g.g("stack-labels").attr({
        visibility: "visible",
        zIndex: 6
      }).add());
      h.translate(d.plotLeft, d.plotTop);
      E(r, function (d) {
        E(d, function (d) {
          d.render(h);
        });
      });
    };

    g.prototype.resetStacks = function () {
      var d = this,
          g = d.stacks;
      d.isXAxis || E(g, function (g) {
        E(g, function (h, t) {
          h.touched < d.stacksTouched ? (h.destroy(), delete g[t]) : (h.total = null, h.cumulative = null);
        });
      });
    };

    g.prototype.cleanStacks = function () {
      if (!this.isXAxis) {
        if (this.oldStacks) var d = this.stacks = this.oldStacks;
        E(d, function (d) {
          E(d, function (d) {
            d.cumulative = d.total;
          });
        });
      }
    };

    J.prototype.setStackedPoints = function () {
      if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
        var g = this.processedXData,
            t = this.processedYData,
            D = [],
            h = t.length,
            N = this.options,
            q = N.threshold,
            G = A(N.startFromThreshold && q, 0),
            e = N.stack;
        N = N.stacking;
        var c = this.stackKey,
            k = "-" + c,
            n = this.negStacks,
            f = this.yAxis,
            a = f.stacks,
            l = f.oldStacks,
            v,
            z;
        f.stacksTouched += 1;

        for (z = 0; z < h; z++) {
          var w = g[z];
          var B = t[z];
          var L = this.getStackIndicator(L, w, this.index);
          var Q = L.key;
          var H = (v = n && B < (G ? 0 : q)) ? k : c;
          a[H] || (a[H] = {});
          a[H][w] || (l[H] && l[H][w] ? (a[H][w] = l[H][w], a[H][w].total = null) : a[H][w] = new d.StackItem(f, f.options.stackLabels, v, w, e));
          H = a[H][w];
          null !== B ? (H.points[Q] = H.points[this.index] = [A(H.cumulative, G)], u(H.cumulative) || (H.base = Q), H.touched = f.stacksTouched, 0 < L.index && !1 === this.singleStacks && (H.points[Q][0] = H.points[this.index + "," + w + ",0"][0])) : H.points[Q] = H.points[this.index] = null;
          "percent" === N ? (v = v ? c : k, n && a[v] && a[v][w] ? (v = a[v][w], H.total = v.total = Math.max(v.total, H.total) + Math.abs(B) || 0) : H.total = r(H.total + (Math.abs(B) || 0))) : H.total = r(H.total + (B || 0));
          H.cumulative = A(H.cumulative, G) + (B || 0);
          null !== B && (H.points[Q].push(H.cumulative), D[z] = H.cumulative);
        }

        "percent" === N && (f.usePercentage = !0);
        this.stackedYData = D;
        f.oldStacks = {};
      }
    };

    J.prototype.modifyStacks = function () {
      var d = this,
          g = d.stackKey,
          r = d.yAxis.stacks,
          h = d.processedXData,
          u,
          q = d.options.stacking;
      d[q + "Stacker"] && [g, "-" + g].forEach(function (g) {
        for (var e = h.length, c, k; e--;) if (c = h[e], u = d.getStackIndicator(u, c, d.index, g), k = (c = r[g] && r[g][c]) && c.points[u.key]) d[q + "Stacker"](k, c, e);
      });
    };

    J.prototype.percentStacker = function (d, g, u) {
      g = g.total ? 100 / g.total : 0;
      d[0] = r(d[0] * g);
      d[1] = r(d[1] * g);
      this.stackedYData[u] = d[1];
    };

    J.prototype.getStackIndicator = function (d, g, r, h) {
      !u(d) || d.x !== g || h && d.key !== h ? d = {
        x: g,
        index: 0,
        key: h
      } : d.index++;
      d.key = [r, g, d.index].join();
      return d;
    };
  });
  S(r, "parts/Dynamics.js", [r["parts/Globals.js"], r["parts/Point.js"], r["parts/Time.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    var I = u.addEvent,
        M = u.animate,
        E = u.createElement,
        A = u.css,
        G = u.defined,
        J = u.erase,
        y = u.error,
        t = u.extend,
        D = u.fireEvent,
        h = u.isArray,
        N = u.isNumber,
        q = u.isObject,
        P = u.isString,
        e = u.merge,
        c = u.objectEach,
        k = u.pick,
        n = u.relativeLength,
        f = u.setAnimation,
        a = u.splat,
        l = d.Axis;
    u = d.Chart;
    var v = d.Series,
        z = d.seriesTypes;

    d.cleanRecursively = function (a, e) {
      var f = {};
      c(a, function (c, k) {
        if (q(a[k], !0) && !a.nodeType && e[k]) c = d.cleanRecursively(a[k], e[k]), Object.keys(c).length && (f[k] = c);else if (q(a[k]) || a[k] !== e[k]) f[k] = a[k];
      });
      return f;
    };

    t(u.prototype, {
      addSeries: function (a, c, e) {
        var f,
            d = this;
        a && (c = k(c, !0), D(d, "addSeries", {
          options: a
        }, function () {
          f = d.initSeries(a);
          d.isDirtyLegend = !0;
          d.linkSeries();
          f.enabledDataSorting && f.setData(a.data, !1);
          D(d, "afterAddSeries", {
            series: f
          });
          c && d.redraw(e);
        }));
        return f;
      },
      addAxis: function (a, c, e, f) {
        return this.createAxis(c ? "xAxis" : "yAxis", {
          axis: a,
          redraw: e,
          animation: f
        });
      },
      addColorAxis: function (a, c, e) {
        return this.createAxis("colorAxis", {
          axis: a,
          redraw: c,
          animation: e
        });
      },
      createAxis: function (c, f) {
        var h = this.options,
            g = "colorAxis" === c,
            n = f.redraw,
            w = f.animation;
        f = e(f.axis, {
          index: this[c].length,
          isX: "xAxis" === c
        });
        var p = g ? new d.ColorAxis(this, f) : new l(this, f);
        h[c] = a(h[c] || {});
        h[c].push(f);
        g && (this.isDirtyLegend = !0, this.axes.forEach(function (a) {
          a.series = [];
        }), this.series.forEach(function (a) {
          a.bindAxes();
          a.isDirtyData = !0;
        }));
        k(n, !0) && this.redraw(w);
        return p;
      },
      showLoading: function (a) {
        var c = this,
            e = c.options,
            f = c.loadingDiv,
            d = e.loading,
            h = function () {
          f && A(f, {
            left: c.plotLeft + "px",
            top: c.plotTop + "px",
            width: c.plotWidth + "px",
            height: c.plotHeight + "px"
          });
        };

        f || (c.loadingDiv = f = E("div", {
          className: "highcharts-loading highcharts-loading-hidden"
        }, null, c.container), c.loadingSpan = E("span", {
          className: "highcharts-loading-inner"
        }, null, f), I(c, "redraw", h));
        f.className = "highcharts-loading";
        c.loadingSpan.innerHTML = k(a, e.lang.loading, "");
        c.styledMode || (A(f, t(d.style, {
          zIndex: 10
        })), A(c.loadingSpan, d.labelStyle), c.loadingShown || (A(f, {
          opacity: 0,
          display: ""
        }), M(f, {
          opacity: d.style.opacity || .5
        }, {
          duration: d.showDuration || 0
        })));
        c.loadingShown = !0;
        h();
      },
      hideLoading: function () {
        var a = this.options,
            c = this.loadingDiv;
        c && (c.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || M(c, {
          opacity: 0
        }, {
          duration: a.loading.hideDuration || 100,
          complete: function () {
            A(c, {
              display: "none"
            });
          }
        }));
        this.loadingShown = !1;
      },
      propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
      propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
      propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" "),
      collectionsWithUpdate: ["xAxis", "yAxis", "zAxis", "series"],
      update: function (f, h, l, g) {
        var v = this,
            w = {
          credits: "addCredits",
          title: "setTitle",
          subtitle: "setSubtitle",
          caption: "setCaption"
        },
            p,
            b,
            q,
            t = f.isResponsiveOptions,
            z = [];
        D(v, "update", {
          options: f
        });
        t || v.setResponsive(!1, !0);
        f = d.cleanRecursively(f, v.options);
        e(!0, v.userOptions, f);

        if (p = f.chart) {
          e(!0, v.options.chart, p);
          "className" in p && v.setClassName(p.className);
          "reflow" in p && v.setReflow(p.reflow);

          if ("inverted" in p || "polar" in p || "type" in p) {
            v.propFromSeries();
            var B = !0;
          }

          "alignTicks" in p && (B = !0);
          c(p, function (a, c) {
            -1 !== v.propsRequireUpdateSeries.indexOf("chart." + c) && (b = !0);
            -1 !== v.propsRequireDirtyBox.indexOf(c) && (v.isDirtyBox = !0);
            t || -1 === v.propsRequireReflow.indexOf(c) || (q = !0);
          });
          !v.styledMode && "style" in p && v.renderer.setStyle(p.style);
        }

        !v.styledMode && f.colors && (this.options.colors = f.colors);
        f.plotOptions && e(!0, this.options.plotOptions, f.plotOptions);
        f.time && this.time === d.time && (this.time = new r(f.time));
        c(f, function (a, c) {
          if (v[c] && "function" === typeof v[c].update) v[c].update(a, !1);else if ("function" === typeof v[w[c]]) v[w[c]](a);
          "chart" !== c && -1 !== v.propsRequireUpdateSeries.indexOf(c) && (b = !0);
        });
        this.collectionsWithUpdate.forEach(function (b) {
          if (f[b]) {
            if ("series" === b) {
              var c = [];
              v[b].forEach(function (a, b) {
                a.options.isInternal || c.push(k(a.options.index, b));
              });
            }

            a(f[b]).forEach(function (a, e) {
              (e = G(a.id) && v.get(a.id) || v[b][c ? c[e] : e]) && e.coll === b && (e.update(a, !1), l && (e.touched = !0));
              !e && l && v.collectionsWithInit[b] && (v.collectionsWithInit[b][0].apply(v, [a].concat(v.collectionsWithInit[b][1] || []).concat([!1])).touched = !0);
            });
            l && v[b].forEach(function (a) {
              a.touched || a.options.isInternal ? delete a.touched : z.push(a);
            });
          }
        });
        z.forEach(function (a) {
          a.remove && a.remove(!1);
        });
        B && v.axes.forEach(function (a) {
          a.update({}, !1);
        });
        b && v.getSeriesOrderByLinks().forEach(function (a) {
          a.chart && a.update({}, !1);
        }, this);
        f.loading && e(!0, v.options.loading, f.loading);
        B = p && p.width;
        p = p && p.height;
        P(p) && (p = n(p, B || v.chartWidth));
        q || N(B) && B !== v.chartWidth || N(p) && p !== v.chartHeight ? v.setSize(B, p, g) : k(h, !0) && v.redraw(g);
        D(v, "afterUpdate", {
          options: f,
          redraw: h,
          animation: g
        });
      },
      setSubtitle: function (a, c) {
        this.applyDescription("subtitle", a);
        this.layOutTitles(c);
      },
      setCaption: function (a, c) {
        this.applyDescription("caption", a);
        this.layOutTitles(c);
      }
    });
    u.prototype.collectionsWithInit = {
      xAxis: [u.prototype.addAxis, [!0]],
      yAxis: [u.prototype.addAxis, [!1]],
      series: [u.prototype.addSeries]
    };
    t(g.prototype, {
      update: function (a, c, e, f) {
        function d() {
          h.applyOptions(a);
          var f = b && h.hasDummyGraphic;
          f = null === h.y ? !f : f;
          b && f && (h.graphic = b.destroy(), delete h.hasDummyGraphic);
          q(a, !0) && (b && b.element && a && a.marker && "undefined" !== typeof a.marker.symbol && (h.graphic = b.destroy()), a && a.dataLabels && h.dataLabel && (h.dataLabel = h.dataLabel.destroy()), h.connector && (h.connector = h.connector.destroy()));
          g = h.index;
          l.updateParallelArrays(h, g);
          v.data[g] = q(v.data[g], !0) || q(a, !0) ? h.options : k(a, v.data[g]);
          l.isDirty = l.isDirtyData = !0;
          !l.fixedBox && l.hasCartesianSeries && (n.isDirtyBox = !0);
          "point" === v.legendType && (n.isDirtyLegend = !0);
          c && n.redraw(e);
        }

        var h = this,
            l = h.series,
            b = h.graphic,
            g,
            n = l.chart,
            v = l.options;
        c = k(c, !0);
        !1 === f ? d() : h.firePointEvent("update", {
          options: a
        }, d);
      },
      remove: function (a, c) {
        this.series.removePoint(this.series.data.indexOf(this), a, c);
      }
    });
    t(v.prototype, {
      addPoint: function (a, c, e, f, d) {
        var h = this.options,
            l = this.data,
            b = this.chart,
            g = this.xAxis;
        g = g && g.hasNames && g.names;
        var n = h.data,
            v = this.xData,
            q;
        c = k(c, !0);
        var w = {
          series: this
        };
        this.pointClass.prototype.applyOptions.apply(w, [a]);
        var t = w.x;
        var m = v.length;
        if (this.requireSorting && t < v[m - 1]) for (q = !0; m && v[m - 1] > t;) m--;
        this.updateParallelArrays(w, "splice", m, 0, 0);
        this.updateParallelArrays(w, m);
        g && w.name && (g[t] = w.name);
        n.splice(m, 0, a);
        q && (this.data.splice(m, 0, null), this.processData());
        "point" === h.legendType && this.generatePoints();
        e && (l[0] && l[0].remove ? l[0].remove(!1) : (l.shift(), this.updateParallelArrays(w, "shift"), n.shift()));
        !1 !== d && D(this, "addPoint", {
          point: w
        });
        this.isDirtyData = this.isDirty = !0;
        c && b.redraw(f);
      },
      removePoint: function (a, c, e) {
        var d = this,
            h = d.data,
            l = h[a],
            g = d.points,
            b = d.chart,
            n = function () {
          g && g.length === h.length && g.splice(a, 1);
          h.splice(a, 1);
          d.options.data.splice(a, 1);
          d.updateParallelArrays(l || {
            series: d
          }, "splice", a, 1);
          l && l.destroy();
          d.isDirty = !0;
          d.isDirtyData = !0;
          c && b.redraw();
        };

        f(e, b);
        c = k(c, !0);
        l ? l.firePointEvent("remove", null, n) : n();
      },
      remove: function (a, c, e, f) {
        function d() {
          h.destroy(f);
          h.remove = null;
          l.isDirtyLegend = l.isDirtyBox = !0;
          l.linkSeries();
          k(a, !0) && l.redraw(c);
        }

        var h = this,
            l = h.chart;
        !1 !== e ? D(h, "remove", null, d) : d();
      },
      update: function (a, c) {
        a = d.cleanRecursively(a, this.userOptions);
        D(this, "update", {
          options: a
        });
        var f = this,
            h = f.chart,
            l = f.userOptions,
            g = f.initialType || f.type,
            n = a.type || l.type || h.options.chart.type,
            b = !(this.hasDerivedData || a.dataGrouping || n && n !== this.type || "undefined" !== typeof a.pointStart || a.pointInterval || a.pointIntervalUnit || a.keys),
            v = z[g].prototype,
            q,
            w = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"],
            r = ["eventOptions", "navigatorSeries", "baseSeries"],
            B = f.finishedAnimating && {
          animation: !1
        },
            u = {};
        b && (r.push("data", "isDirtyData", "points", "processedXData", "processedYData", "xIncrement", "_hasPointMarkers", "_hasPointLabels", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== a.visible && r.push("area", "graph"), f.parallelArrays.forEach(function (a) {
          r.push(a + "Data");
        }), a.data && (a.dataSorting && t(f.options.dataSorting, a.dataSorting), this.setData(a.data, !1)));
        a = e(l, B, {
          index: "undefined" === typeof l.index ? f.index : l.index,
          pointStart: k(l.pointStart, f.xData[0])
        }, !b && {
          data: f.options.data
        }, a);
        b && a.data && (a.data = f.options.data);
        r = w.concat(r);
        r.forEach(function (a) {
          r[a] = f[a];
          delete f[a];
        });
        f.remove(!1, null, !1, !0);

        for (q in v) f[q] = void 0;

        z[n || g] ? t(f, z[n || g].prototype) : y(17, !0, h, {
          missingModuleFor: n || g
        });
        r.forEach(function (a) {
          f[a] = r[a];
        });
        f.init(h, a);

        if (b && this.points) {
          var m = f.options;
          !1 === m.visible ? (u.graphic = 1, u.dataLabel = 1) : f._hasPointLabels || (n = m.marker, v = m.dataLabels, n && (!1 === n.enabled || "symbol" in n) && (u.graphic = 1), v && !1 === v.enabled && (u.dataLabel = 1));
          this.points.forEach(function (a) {
            a && a.series && (a.resolveColor(), Object.keys(u).length && a.destroyElements(u), !1 === m.showInLegend && a.legendItem && h.legend.destroyItem(a));
          }, this);
        }

        a.zIndex !== l.zIndex && w.forEach(function (b) {
          f[b] && f[b].attr({
            zIndex: a.zIndex
          });
        });
        f.initialType = g;
        h.linkSeries();
        D(this, "afterUpdate");
        k(c, !0) && h.redraw(b ? void 0 : !1);
      },
      setName: function (a) {
        this.name = this.options.name = this.userOptions.name = a;
        this.chart.isDirtyLegend = !0;
      }
    });
    t(l.prototype, {
      update: function (a, f) {
        var d = this.chart,
            h = a && a.events || {};
        a = e(this.userOptions, a);
        d.options[this.coll].indexOf && (d.options[this.coll][d.options[this.coll].indexOf(this.userOptions)] = a);
        c(d.options[this.coll].events, function (a, c) {
          "undefined" === typeof h[c] && (h[c] = void 0);
        });
        this.destroy(!0);
        this.init(d, t(a, {
          events: h
        }));
        d.isDirtyBox = !0;
        k(f, !0) && d.redraw();
      },
      remove: function (a) {
        for (var c = this.chart, e = this.coll, f = this.series, d = f.length; d--;) f[d] && f[d].remove(!1);

        J(c.axes, this);
        J(c[e], this);
        h(c.options[e]) ? c.options[e].splice(this.options.index, 1) : delete c.options[e];
        c[e].forEach(function (a, c) {
          a.options.index = a.userOptions.index = c;
        });
        this.destroy();
        c.isDirtyBox = !0;
        k(a, !0) && c.redraw();
      },
      setTitle: function (a, c) {
        this.update({
          title: a
        }, c);
      },
      setCategories: function (a, c) {
        this.update({
          categories: a
        }, c);
      }
    });
  });
  S(r, "parts/AreaSeries.js", [r["parts/Globals.js"], r["parts/Color.js"], r["mixins/legend-symbol.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    var I = g.parse,
        M = u.objectEach,
        E = u.pick;
    g = u.seriesType;
    var A = d.Series;
    g("area", "line", {
      softThreshold: !1,
      threshold: 0
    }, {
      singleStacks: !1,
      getStackPoints: function (d) {
        var g = [],
            r = [],
            t = this.xAxis,
            u = this.yAxis,
            h = u.stacks[this.stackKey],
            A = {},
            q = this.index,
            G = u.series,
            e = G.length,
            c = E(u.options.reversedStacks, !0) ? 1 : -1,
            k;
        d = d || this.points;

        if (this.options.stacking) {
          for (k = 0; k < d.length; k++) d[k].leftNull = d[k].rightNull = void 0, A[d[k].x] = d[k];

          M(h, function (c, a) {
            null !== c.total && r.push(a);
          });
          r.sort(function (c, a) {
            return c - a;
          });
          var n = G.map(function (c) {
            return c.visible;
          });
          r.forEach(function (f, a) {
            var d = 0,
                v,
                z;
            if (A[f] && !A[f].isNull) g.push(A[f]), [-1, 1].forEach(function (d) {
              var l = 1 === d ? "rightNull" : "leftNull",
                  g = 0,
                  w = h[r[a + d]];
              if (w) for (k = q; 0 <= k && k < e;) v = w.points[k], v || (k === q ? A[f][l] = !0 : n[k] && (z = h[f].points[k]) && (g -= z[1] - z[0])), k += c;
              A[f][1 === d ? "rightCliff" : "leftCliff"] = g;
            });else {
              for (k = q; 0 <= k && k < e;) {
                if (v = h[f].points[k]) {
                  d = v[1];
                  break;
                }

                k += c;
              }

              d = u.translate(d, 0, 1, 0, 1);
              g.push({
                isNull: !0,
                plotX: t.translate(f, 0, 0, 0, 1),
                x: f,
                plotY: d,
                yBottom: d
              });
            }
          });
        }

        return g;
      },
      getGraphPath: function (d) {
        var g = A.prototype.getGraphPath,
            r = this.options,
            t = r.stacking,
            u = this.yAxis,
            h,
            N = [],
            q = [],
            G = this.index,
            e = u.stacks[this.stackKey],
            c = r.threshold,
            k = Math.round(u.getThreshold(r.threshold));
        r = E(r.connectNulls, "percent" === t);

        var n = function (f, h, l) {
          var g = d[f];
          f = t && e[g.x].points[G];
          var n = g[l + "Null"] || 0;
          l = g[l + "Cliff"] || 0;
          g = !0;

          if (l || n) {
            var v = (n ? f[0] : f[1]) + l;
            var w = f[0] + l;
            g = !!n;
          } else !t && d[h] && d[h].isNull && (v = w = c);

          "undefined" !== typeof v && (q.push({
            plotX: a,
            plotY: null === v ? k : u.getThreshold(v),
            isNull: g,
            isCliff: !0
          }), N.push({
            plotX: a,
            plotY: null === w ? k : u.getThreshold(w),
            doCurve: !1
          }));
        };

        d = d || this.points;
        t && (d = this.getStackPoints(d));

        for (h = 0; h < d.length; h++) {
          t || (d[h].leftCliff = d[h].rightCliff = d[h].leftNull = d[h].rightNull = void 0);
          var f = d[h].isNull;
          var a = E(d[h].rectPlotX, d[h].plotX);
          var l = E(d[h].yBottom, k);
          if (!f || r) r || n(h, h - 1, "left"), f && !t && r || (q.push(d[h]), N.push({
            x: h,
            plotX: a,
            plotY: l
          })), r || n(h, h + 1, "right");
        }

        h = g.call(this, q, !0, !0);
        N.reversed = !0;
        f = g.call(this, N, !0, !0);
        f.length && (f[0] = "L");
        f = h.concat(f);
        g = g.call(this, q, !1, r);
        f.xMap = h.xMap;
        this.areaPath = f;
        return g;
      },
      drawGraph: function () {
        this.areaPath = [];
        A.prototype.drawGraph.apply(this);
        var d = this,
            g = this.areaPath,
            r = this.options,
            t = [["area", "highcharts-area", this.color, r.fillColor]];
        this.zones.forEach(function (g, h) {
          t.push(["zone-area-" + h, "highcharts-area highcharts-zone-area-" + h + " " + g.className, g.color || d.color, g.fillColor || r.fillColor]);
        });
        t.forEach(function (t) {
          var h = t[0],
              u = d[h],
              q = u ? "animate" : "attr",
              y = {};
          u ? (u.endX = d.preventGraphAnimation ? null : g.xMap, u.animate({
            d: g
          })) : (y.zIndex = 0, u = d[h] = d.chart.renderer.path(g).addClass(t[1]).add(d.group), u.isArea = !0);
          d.chart.styledMode || (y.fill = E(t[3], I(t[2]).setOpacity(E(r.fillOpacity, .75)).get()));
          u[q](y);
          u.startX = g.xMap;
          u.shiftUnit = r.step ? 2 : 1;
        });
      },
      drawLegendSymbol: r.drawRectangle
    });
    "";
  });
  S(r, "parts/SplineSeries.js", [r["parts/Utilities.js"]], function (d) {
    var g = d.pick;
    d = d.seriesType;
    d("spline", "line", {}, {
      getPointSpline: function (d, r, I) {
        var u = r.plotX,
            E = r.plotY,
            A = d[I - 1];
        I = d[I + 1];

        if (A && !A.isNull && !1 !== A.doCurve && !r.isCliff && I && !I.isNull && !1 !== I.doCurve && !r.isCliff) {
          d = A.plotY;
          var G = I.plotX;
          I = I.plotY;
          var J = 0;
          var y = (1.5 * u + A.plotX) / 2.5;
          var t = (1.5 * E + d) / 2.5;
          G = (1.5 * u + G) / 2.5;
          var D = (1.5 * E + I) / 2.5;
          G !== y && (J = (D - t) * (G - u) / (G - y) + E - D);
          t += J;
          D += J;
          t > d && t > E ? (t = Math.max(d, E), D = 2 * E - t) : t < d && t < E && (t = Math.min(d, E), D = 2 * E - t);
          D > I && D > E ? (D = Math.max(I, E), t = 2 * E - D) : D < I && D < E && (D = Math.min(I, E), t = 2 * E - D);
          r.rightContX = G;
          r.rightContY = D;
        }

        r = ["C", g(A.rightContX, A.plotX), g(A.rightContY, A.plotY), g(y, u), g(t, E), u, E];
        A.rightContX = A.rightContY = null;
        return r;
      }
    });
    "";
  });
  S(r, "parts/AreaSplineSeries.js", [r["parts/Globals.js"], r["mixins/legend-symbol.js"], r["parts/Utilities.js"]], function (d, g, r) {
    r = r.seriesType;
    var u = d.seriesTypes.area.prototype;
    r("areaspline", "spline", d.defaultPlotOptions.area, {
      getStackPoints: u.getStackPoints,
      getGraphPath: u.getGraphPath,
      drawGraph: u.drawGraph,
      drawLegendSymbol: g.drawRectangle
    });
    "";
  });
  S(r, "parts/ColumnSeries.js", [r["parts/Globals.js"], r["parts/Color.js"], r["mixins/legend-symbol.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    "";

    var I = g.parse,
        M = u.animObject,
        E = u.clamp,
        A = u.defined,
        G = u.extend,
        J = u.isNumber,
        y = u.merge,
        t = u.pick;
    g = u.seriesType;
    var D = d.Series;
    g("column", "line", {
      borderRadius: 0,
      crisp: !0,
      groupPadding: .2,
      marker: null,
      pointPadding: .1,
      minPointLength: 0,
      cropThreshold: 50,
      pointRange: null,
      states: {
        hover: {
          halo: !1,
          brightness: .1
        },
        select: {
          color: "#cccccc",
          borderColor: "#000000"
        }
      },
      dataLabels: {
        align: null,
        verticalAlign: null,
        y: null
      },
      softThreshold: !1,
      startFromThreshold: !0,
      stickyTracking: !1,
      tooltip: {
        distance: 6
      },
      threshold: 0,
      borderColor: "#ffffff"
    }, {
      cropShoulder: 0,
      directTouch: !0,
      trackerGroups: ["group", "dataLabelsGroup"],
      negStacks: !0,
      init: function () {
        D.prototype.init.apply(this, arguments);
        var d = this,
            g = d.chart;
        g.hasRendered && g.series.forEach(function (h) {
          h.type === d.type && (h.isDirty = !0);
        });
      },
      getColumnMetrics: function () {
        var d = this,
            g = d.options,
            q = d.xAxis,
            r = d.yAxis,
            e = q.options.reversedStacks;
        e = q.reversed && !e || !q.reversed && e;
        var c,
            k = {},
            n = 0;
        !1 === g.grouping ? n = 1 : d.chart.series.forEach(function (a) {
          var e = a.yAxis,
              f = a.options;

          if (a.type === d.type && (a.visible || !d.chart.options.chart.ignoreHiddenSeries) && r.len === e.len && r.pos === e.pos) {
            if (f.stacking) {
              c = a.stackKey;
              "undefined" === typeof k[c] && (k[c] = n++);
              var h = k[c];
            } else !1 !== f.grouping && (h = n++);

            a.columnIndex = h;
          }
        });
        var f = Math.min(Math.abs(q.transA) * (q.ordinalSlope || g.pointRange || q.closestPointRange || q.tickInterval || 1), q.len),
            a = f * g.groupPadding,
            l = (f - 2 * a) / (n || 1);
        g = Math.min(g.maxPointWidth || q.len, t(g.pointWidth, l * (1 - 2 * g.pointPadding)));
        d.columnMetrics = {
          width: g,
          offset: (l - g) / 2 + (a + ((d.columnIndex || 0) + (e ? 1 : 0)) * l - f / 2) * (e ? -1 : 1)
        };
        return d.columnMetrics;
      },
      crispCol: function (d, g, q, t) {
        var e = this.chart,
            c = this.borderWidth,
            k = -(c % 2 ? .5 : 0);
        c = c % 2 ? .5 : 1;
        e.inverted && e.renderer.isVML && (c += 1);
        this.options.crisp && (q = Math.round(d + q) + k, d = Math.round(d) + k, q -= d);
        t = Math.round(g + t) + c;
        k = .5 >= Math.abs(g) && .5 < t;
        g = Math.round(g) + c;
        t -= g;
        k && t && (--g, t += 1);
        return {
          x: d,
          y: g,
          width: q,
          height: t
        };
      },
      translate: function () {
        var d = this,
            g = d.chart,
            q = d.options,
            r = d.dense = 2 > d.closestPointRange * d.xAxis.transA;
        r = d.borderWidth = t(q.borderWidth, r ? 0 : 1);
        var e = d.xAxis,
            c = d.yAxis,
            k = q.threshold,
            n = d.translatedThreshold = c.getThreshold(k),
            f = t(q.minPointLength, 5),
            a = d.getColumnMetrics(),
            l = a.width,
            v = d.barW = Math.max(l, 1 + 2 * r),
            z = d.pointXOffset = a.offset,
            w = d.dataMin,
            u = d.dataMax;
        g.inverted && (n -= .5);
        q.pointPadding && (v = Math.ceil(v));
        D.prototype.translate.apply(d);
        d.points.forEach(function (a) {
          var h = t(a.yBottom, n),
              q = 999 + Math.abs(h),
              r = l,
              p = a.plotX;
          q = E(a.plotY, -q, c.len + q);
          var b = a.plotX + z,
              B = v,
              x = Math.min(q, h),
              y = Math.max(q, h) - x;

          if (f && Math.abs(y) < f) {
            y = f;
            var L = !c.reversed && !a.negative || c.reversed && a.negative;
            a.y === k && d.dataMax <= k && c.min < k && w !== u && (L = !L);
            x = Math.abs(x - n) > f ? h - f : n - (L ? f : 0);
          }

          A(a.options.pointWidth) && (r = B = Math.ceil(a.options.pointWidth), b -= Math.round((r - l) / 2));
          a.barX = b;
          a.pointWidth = r;
          a.tooltipPos = g.inverted ? [c.len + c.pos - g.plotLeft - q, e.len + e.pos - g.plotTop - (p || 0) - z - B / 2, y] : [b + B / 2, q + c.pos - g.plotTop, y];
          a.shapeType = d.pointClass.prototype.shapeType || "rect";
          a.shapeArgs = d.crispCol.apply(d, a.isNull ? [b, n, B, 0] : [b, x, B, y]);
        });
      },
      getSymbol: d.noop,
      drawLegendSymbol: r.drawRectangle,
      drawGraph: function () {
        this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
      },
      pointAttribs: function (d, g) {
        var h = this.options,
            r = this.pointAttrToOptions || {};
        var e = r.stroke || "borderColor";
        var c = r["stroke-width"] || "borderWidth",
            k = d && d.color || this.color,
            n = d && d[e] || h[e] || this.color || k,
            f = d && d[c] || h[c] || this[c] || 0;
        r = d && d.options.dashStyle || h.dashStyle;
        var a = t(d && d.opacity, h.opacity, 1);

        if (d && this.zones.length) {
          var l = d.getZone();
          k = d.options.color || l && (l.color || d.nonZonedColor) || this.color;
          l && (n = l.borderColor || n, r = l.dashStyle || r, f = l.borderWidth || f);
        }

        g && d && (d = y(h.states[g], d.options.states && d.options.states[g] || {}), g = d.brightness, k = d.color || "undefined" !== typeof g && I(k).brighten(d.brightness).get() || k, n = d[e] || n, f = d[c] || f, r = d.dashStyle || r, a = t(d.opacity, a));
        e = {
          fill: k,
          stroke: n,
          "stroke-width": f,
          opacity: a
        };
        r && (e.dashstyle = r);
        return e;
      },
      drawPoints: function () {
        var d = this,
            g = this.chart,
            q = d.options,
            t = g.renderer,
            e = q.animationLimit || 250,
            c;
        d.points.forEach(function (k) {
          var h = k.graphic,
              f = !!h,
              a = h && g.pointCount < e ? "animate" : "attr";

          if (J(k.plotY) && null !== k.y) {
            c = k.shapeArgs;
            h && k.hasNewShapeType() && (h = h.destroy());
            d.enabledDataSorting && (k.startXPos = d.xAxis.reversed ? -(c ? c.width : 0) : d.xAxis.width);
            h || (k.graphic = h = t[k.shapeType](c).add(k.group || d.group)) && d.enabledDataSorting && g.hasRendered && g.pointCount < e && (h.attr({
              x: k.startXPos
            }), f = !0, a = "animate");
            if (h && f) h[a](y(c));
            if (q.borderRadius) h[a]({
              r: q.borderRadius
            });
            g.styledMode || h[a](d.pointAttribs(k, k.selected && "select")).shadow(!1 !== k.allowShadow && q.shadow, null, q.stacking && !q.borderRadius);
            h.addClass(k.getClassName(), !0);
          } else h && (k.graphic = h.destroy());
        });
      },
      animate: function (d) {
        var h = this,
            g = this.yAxis,
            t = h.options,
            e = this.chart.inverted,
            c = {},
            k = e ? "translateX" : "translateY";
        if (d) c.scaleY = .001, d = E(g.toPixels(t.threshold), g.pos, g.pos + g.len), e ? c.translateX = d - g.len : c.translateY = d, h.clipBox && h.setClip(), h.group.attr(c);else {
          var n = h.group.attr(k);
          h.group.animate({
            scaleY: 1
          }, G(M(h.options.animation), {
            step: function (e, a) {
              h.group && (c[k] = n + a.pos * (g.pos - n), h.group.attr(c));
            }
          }));
        }
      },
      remove: function () {
        var d = this,
            g = d.chart;
        g.hasRendered && g.series.forEach(function (h) {
          h.type === d.type && (h.isDirty = !0);
        });
        D.prototype.remove.apply(d, arguments);
      }
    });
    "";
  });
  S(r, "parts/BarSeries.js", [r["parts/Utilities.js"]], function (d) {
    d = d.seriesType;
    d("bar", "column", null, {
      inverted: !0
    });
    "";
  });
  S(r, "parts/ScatterSeries.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.addEvent;
    g = g.seriesType;
    var u = d.Series;
    g("scatter", "line", {
      lineWidth: 0,
      findNearestPointBy: "xy",
      jitter: {
        x: 0,
        y: 0
      },
      marker: {
        enabled: !0
      },
      tooltip: {
        headerFormat: '<span style="color:{point.color}">\u25cf</span> <span style="font-size: 10px"> {series.name}</span><br/>',
        pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
      }
    }, {
      sorted: !1,
      requireSorting: !1,
      noSharedTooltip: !0,
      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
      takeOrdinalPosition: !1,
      drawGraph: function () {
        this.options.lineWidth && u.prototype.drawGraph.call(this);
      },
      applyJitter: function () {
        var d = this,
            g = this.options.jitter,
            r = this.points.length;
        g && this.points.forEach(function (u, E) {
          ["x", "y"].forEach(function (A, y) {
            var t = "plot" + A.toUpperCase();

            if (g[A] && !u.isNull) {
              var D = d[A + "Axis"];
              var h = g[A] * D.transA;

              if (D && !D.isLog) {
                var G = Math.max(0, u[t] - h);
                D = Math.min(D.len, u[t] + h);
                y = 1E4 * Math.sin(E + y * r);
                u[t] = G + (D - G) * (y - Math.floor(y));
                "x" === A && (u.clientX = u.plotX);
              }
            }
          });
        });
      }
    });
    r(u, "afterTranslate", function () {
      this.applyJitter && this.applyJitter();
    });
    "";
  });
  S(r, "mixins/centered-series.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.isNumber,
        u = g.pick,
        I = g.relativeLength,
        M = d.deg2rad;
    d.CenteredSeriesMixin = {
      getCenter: function () {
        var d = this.options,
            g = this.chart,
            r = 2 * (d.slicedOffset || 0),
            J = g.plotWidth - 2 * r,
            y = g.plotHeight - 2 * r,
            t = d.center,
            D = Math.min(J, y),
            h = d.size,
            N = d.innerSize || 0;
        "string" === typeof h && (h = parseFloat(h));
        "string" === typeof N && (N = parseFloat(N));
        d = [u(t[0], "50%"), u(t[1], "50%"), u(h && 0 > h ? void 0 : d.size, "100%"), u(N && 0 > N ? void 0 : d.innerSize || 0, "0%")];
        g.angular && (d[3] = 0);

        for (t = 0; 4 > t; ++t) h = d[t], g = 2 > t || 2 === t && /%$/.test(h), d[t] = I(h, [J, y, D, d[2]][t]) + (g ? r : 0);

        d[3] > d[2] && (d[3] = d[2]);
        return d;
      },
      getStartAndEndRadians: function (d, g) {
        d = r(d) ? d : 0;
        g = r(g) && g > d && 360 > g - d ? g : d + 360;
        return {
          start: M * (d + -90),
          end: M * (g + -90)
        };
      }
    };
  });
  S(r, "parts/PieSeries.js", [r["parts/Globals.js"], r["mixins/legend-symbol.js"], r["parts/Point.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    var I = u.addEvent,
        M = u.clamp,
        E = u.defined,
        A = u.fireEvent,
        G = u.isNumber,
        J = u.merge,
        y = u.pick,
        t = u.relativeLength,
        D = u.seriesType,
        h = u.setAnimation;
    u = d.CenteredSeriesMixin;
    var N = u.getStartAndEndRadians,
        q = d.noop,
        P = d.Series;
    D("pie", "line", {
      center: [null, null],
      clip: !1,
      colorByPoint: !0,
      dataLabels: {
        allowOverlap: !0,
        connectorPadding: 5,
        connectorShape: "fixedOffset",
        crookDistance: "70%",
        distance: 30,
        enabled: !0,
        formatter: function () {
          return this.point.isNull ? void 0 : this.point.name;
        },
        softConnector: !0,
        x: 0
      },
      fillColor: void 0,
      ignoreHiddenPoint: !0,
      inactiveOtherPoints: !0,
      legendType: "point",
      marker: null,
      size: null,
      showInLegend: !1,
      slicedOffset: 10,
      stickyTracking: !1,
      tooltip: {
        followPointer: !0
      },
      borderColor: "#ffffff",
      borderWidth: 1,
      lineWidth: void 0,
      states: {
        hover: {
          brightness: .1
        }
      }
    }, {
      isCartesian: !1,
      requireSorting: !1,
      directTouch: !0,
      noSharedTooltip: !0,
      trackerGroups: ["group", "dataLabelsGroup"],
      axisTypes: [],
      pointAttribs: d.seriesTypes.column.prototype.pointAttribs,
      animate: function (e) {
        var c = this,
            d = c.points,
            g = c.startAngleRad;
        e || d.forEach(function (e) {
          var a = e.graphic,
              f = e.shapeArgs;
          a && f && (a.attr({
            r: y(e.startR, c.center && c.center[3] / 2),
            start: g,
            end: g
          }), a.animate({
            r: f.r,
            start: f.start,
            end: f.end
          }, c.options.animation));
        });
      },
      hasData: function () {
        return !!this.processedXData.length;
      },
      updateTotals: function () {
        var e,
            c = 0,
            d = this.points,
            g = d.length,
            f = this.options.ignoreHiddenPoint;

        for (e = 0; e < g; e++) {
          var a = d[e];
          c += f && !a.visible ? 0 : a.isNull ? 0 : a.y;
        }

        this.total = c;

        for (e = 0; e < g; e++) a = d[e], a.percentage = 0 < c && (a.visible || !f) ? a.y / c * 100 : 0, a.total = c;
      },
      generatePoints: function () {
        P.prototype.generatePoints.call(this);
        this.updateTotals();
      },
      getX: function (e, c, d) {
        var k = this.center,
            f = this.radii ? this.radii[d.index] : k[2] / 2;
        e = Math.asin(M((e - k[1]) / (f + d.labelDistance), -1, 1));
        return k[0] + (c ? -1 : 1) * Math.cos(e) * (f + d.labelDistance) + (0 < d.labelDistance ? (c ? -1 : 1) * this.options.dataLabels.padding : 0);
      },
      translate: function (e) {
        this.generatePoints();
        var c = 0,
            d = this.options,
            g = d.slicedOffset,
            f = g + (d.borderWidth || 0),
            a = N(d.startAngle, d.endAngle),
            h = this.startAngleRad = a.start;
        a = (this.endAngleRad = a.end) - h;
        var v = this.points,
            q = d.dataLabels.distance;
        d = d.ignoreHiddenPoint;
        var w,
            r = v.length;
        e || (this.center = e = this.getCenter());

        for (w = 0; w < r; w++) {
          var u = v[w];
          var D = h + c * a;
          if (!d || u.visible) c += u.percentage / 100;
          var H = h + c * a;
          u.shapeType = "arc";
          u.shapeArgs = {
            x: e[0],
            y: e[1],
            r: e[2] / 2,
            innerR: e[3] / 2,
            start: Math.round(1E3 * D) / 1E3,
            end: Math.round(1E3 * H) / 1E3
          };
          u.labelDistance = y(u.options.dataLabels && u.options.dataLabels.distance, q);
          u.labelDistance = t(u.labelDistance, u.shapeArgs.r);
          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, u.labelDistance);
          H = (H + D) / 2;
          H > 1.5 * Math.PI ? H -= 2 * Math.PI : H < -Math.PI / 2 && (H += 2 * Math.PI);
          u.slicedTranslation = {
            translateX: Math.round(Math.cos(H) * g),
            translateY: Math.round(Math.sin(H) * g)
          };
          var K = Math.cos(H) * e[2] / 2;
          var p = Math.sin(H) * e[2] / 2;
          u.tooltipPos = [e[0] + .7 * K, e[1] + .7 * p];
          u.half = H < -Math.PI / 2 || H > Math.PI / 2 ? 1 : 0;
          u.angle = H;
          D = Math.min(f, u.labelDistance / 5);
          u.labelPosition = {
            natural: {
              x: e[0] + K + Math.cos(H) * u.labelDistance,
              y: e[1] + p + Math.sin(H) * u.labelDistance
            },
            "final": {},
            alignment: 0 > u.labelDistance ? "center" : u.half ? "right" : "left",
            connectorPosition: {
              breakAt: {
                x: e[0] + K + Math.cos(H) * D,
                y: e[1] + p + Math.sin(H) * D
              },
              touchingSliceAt: {
                x: e[0] + K,
                y: e[1] + p
              }
            }
          };
        }

        A(this, "afterTranslate");
      },
      drawEmpty: function () {
        var e = this.options;

        if (0 === this.total) {
          var c = this.center[0];
          var d = this.center[1];
          this.graph || (this.graph = this.chart.renderer.circle(c, d, 0).addClass("highcharts-graph").add(this.group));
          this.graph.animate({
            "stroke-width": e.borderWidth,
            cx: c,
            cy: d,
            r: this.center[2] / 2,
            fill: e.fillColor || "none",
            stroke: e.color || "#cccccc"
          }, this.options.animation);
        } else this.graph && (this.graph = this.graph.destroy());
      },
      redrawPoints: function () {
        var e = this,
            c = e.chart,
            d = c.renderer,
            g,
            f,
            a,
            h,
            v = e.options.shadow;
        this.drawEmpty();
        !v || e.shadowGroup || c.styledMode || (e.shadowGroup = d.g("shadow").attr({
          zIndex: -1
        }).add(e.group));
        e.points.forEach(function (k) {
          var l = {};
          f = k.graphic;

          if (!k.isNull && f) {
            h = k.shapeArgs;
            g = k.getTranslate();

            if (!c.styledMode) {
              var n = k.shadowGroup;
              v && !n && (n = k.shadowGroup = d.g("shadow").add(e.shadowGroup));
              n && n.attr(g);
              a = e.pointAttribs(k, k.selected && "select");
            }

            k.delayedRendering ? (f.setRadialReference(e.center).attr(h).attr(g), c.styledMode || f.attr(a).attr({
              "stroke-linejoin": "round"
            }).shadow(v, n), k.delayedRendering = !1) : (f.setRadialReference(e.center), c.styledMode || J(!0, l, a), J(!0, l, h, g), f.animate(l));
            f.attr({
              visibility: k.visible ? "inherit" : "hidden"
            });
            f.addClass(k.getClassName());
          } else f && (k.graphic = f.destroy());
        });
      },
      drawPoints: function () {
        var e = this.chart.renderer;
        this.points.forEach(function (c) {
          c.graphic && c.hasNewShapeType() && (c.graphic = c.graphic.destroy());
          c.graphic || (c.graphic = e[c.shapeType](c.shapeArgs).add(c.series.group), c.delayedRendering = !0);
        });
      },
      searchPoint: q,
      sortByAngle: function (e, c) {
        e.sort(function (e, d) {
          return "undefined" !== typeof e.angle && (d.angle - e.angle) * c;
        });
      },
      drawLegendSymbol: g.drawRectangle,
      getCenter: u.getCenter,
      getSymbol: q,
      drawGraph: null
    }, {
      init: function () {
        r.prototype.init.apply(this, arguments);
        var e = this;
        e.name = y(e.name, "Slice");

        var c = function (c) {
          e.slice("select" === c.type);
        };

        I(e, "select", c);
        I(e, "unselect", c);
        return e;
      },
      isValid: function () {
        return G(this.y) && 0 <= this.y;
      },
      setVisible: function (e, c) {
        var d = this,
            g = d.series,
            f = g.chart,
            a = g.options.ignoreHiddenPoint;
        c = y(c, a);
        e !== d.visible && (d.visible = d.options.visible = e = "undefined" === typeof e ? !d.visible : e, g.options.data[g.data.indexOf(d)] = d.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (a) {
          if (d[a]) d[a][e ? "show" : "hide"](!0);
        }), d.legendItem && f.legend.colorizeItem(d, e), e || "hover" !== d.state || d.setState(""), a && (g.isDirty = !0), c && f.redraw());
      },
      slice: function (e, c, d) {
        var g = this.series;
        h(d, g.chart);
        y(c, !0);
        this.sliced = this.options.sliced = E(e) ? e : !this.sliced;
        g.options.data[g.data.indexOf(this)] = this.options;
        this.graphic.animate(this.getTranslate());
        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
      },
      getTranslate: function () {
        return this.sliced ? this.slicedTranslation : {
          translateX: 0,
          translateY: 0
        };
      },
      haloPath: function (e) {
        var c = this.shapeArgs;
        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + e, c.r + e, {
          innerR: c.r - 1,
          start: c.start,
          end: c.end
        });
      },
      connectorShapes: {
        fixedOffset: function (e, c, d) {
          var g = c.breakAt;
          c = c.touchingSliceAt;
          return ["M", e.x, e.y].concat(d.softConnector ? ["C", e.x + ("left" === e.alignment ? -5 : 5), e.y, 2 * g.x - c.x, 2 * g.y - c.y, g.x, g.y] : ["L", g.x, g.y]).concat(["L", c.x, c.y]);
        },
        straight: function (e, c) {
          c = c.touchingSliceAt;
          return ["M", e.x, e.y, "L", c.x, c.y];
        },
        crookedLine: function (e, c, d) {
          c = c.touchingSliceAt;
          var g = this.series,
              f = g.center[0],
              a = g.chart.plotWidth,
              k = g.chart.plotLeft;
          g = e.alignment;
          var h = this.shapeArgs.r;
          d = t(d.crookDistance, 1);
          d = "left" === g ? f + h + (a + k - f - h) * (1 - d) : k + (f - h) * d;
          f = ["L", d, e.y];
          if ("left" === g ? d > e.x || d < c.x : d < e.x || d > c.x) f = [];
          return ["M", e.x, e.y].concat(f).concat(["L", c.x, c.y]);
        }
      },
      getConnectorPath: function () {
        var e = this.labelPosition,
            c = this.series.options.dataLabels,
            d = c.connectorShape,
            g = this.connectorShapes;
        g[d] && (d = g[d]);
        return d.call(this, {
          x: e.final.x,
          y: e.final.y,
          alignment: e.alignment
        }, e.connectorPosition, c);
      }
    });
    "";
  });
  S(r, "parts/DataLabels.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.animObject,
        u = g.arrayMax,
        I = g.clamp,
        M = g.defined,
        E = g.extend,
        A = g.format,
        G = g.isArray,
        J = g.merge,
        y = g.objectEach,
        t = g.pick,
        D = g.relativeLength,
        h = g.splat,
        N = g.stableSort;
    g = d.noop;
    var q = d.Series,
        P = d.seriesTypes;

    d.distribute = function (e, c, g) {
      function h(a, c) {
        return a.target - c.target;
      }

      var f,
          a = !0,
          k = e,
          v = [];
      var q = 0;
      var w = k.reducedLen || c;

      for (f = e.length; f--;) q += e[f].size;

      if (q > w) {
        N(e, function (a, c) {
          return (c.rank || 0) - (a.rank || 0);
        });

        for (q = f = 0; q <= w;) q += e[f].size, f++;

        v = e.splice(f - 1, e.length);
      }

      N(e, h);

      for (e = e.map(function (a) {
        return {
          size: a.size,
          targets: [a.target],
          align: t(a.align, .5)
        };
      }); a;) {
        for (f = e.length; f--;) a = e[f], q = (Math.min.apply(0, a.targets) + Math.max.apply(0, a.targets)) / 2, a.pos = I(q - a.size * a.align, 0, c - a.size);

        f = e.length;

        for (a = !1; f--;) 0 < f && e[f - 1].pos + e[f - 1].size > e[f].pos && (e[f - 1].size += e[f].size, e[f - 1].targets = e[f - 1].targets.concat(e[f].targets), e[f - 1].align = .5, e[f - 1].pos + e[f - 1].size > c && (e[f - 1].pos = c - e[f - 1].size), e.splice(f, 1), a = !0);
      }

      k.push.apply(k, v);
      f = 0;
      e.some(function (a) {
        var e = 0;
        if (a.targets.some(function () {
          k[f].pos = a.pos + e;
          if ("undefined" !== typeof g && Math.abs(k[f].pos - k[f].target) > g) return k.slice(0, f + 1).forEach(function (a) {
            delete a.pos;
          }), k.reducedLen = (k.reducedLen || c) - .1 * c, k.reducedLen > .1 * c && d.distribute(k, c, g), !0;
          e += k[f].size;
          f++;
        })) return !0;
      });
      N(k, h);
    };

    q.prototype.drawDataLabels = function () {
      function e(a, c) {
        var b = c.filter;
        return b ? (c = b.operator, a = a[b.property], b = b.value, ">" === c && a > b || "<" === c && a < b || ">=" === c && a >= b || "<=" === c && a <= b || "==" === c && a == b || "===" === c && a === b ? !0 : !1) : !0;
      }

      function c(a, c) {
        var b = [],
            e;
        if (G(a) && !G(c)) b = a.map(function (a) {
          return J(a, c);
        });else if (G(c) && !G(a)) b = c.map(function (b) {
          return J(a, b);
        });else if (G(a) || G(c)) for (e = Math.max(a.length, c.length); e--;) b[e] = J(a[e], c[e]);else b = J(a, c);
        return b;
      }

      var g = this,
          n = g.chart,
          f = g.options,
          a = f.dataLabels,
          l = g.points,
          v,
          q = g.hasRendered || 0,
          w = r(f.animation).duration,
          u = Math.min(w, 200),
          L = !n.renderer.forExport && t(a.defer, 0 < u),
          D = n.renderer;
      a = c(c(n.options.plotOptions && n.options.plotOptions.series && n.options.plotOptions.series.dataLabels, n.options.plotOptions && n.options.plotOptions[g.type] && n.options.plotOptions[g.type].dataLabels), a);
      d.fireEvent(this, "drawDataLabels");

      if (G(a) || a.enabled || g._hasPointLabels) {
        var H = g.plotGroup("dataLabelsGroup", "data-labels", L && !q ? "hidden" : "inherit", a.zIndex || 6);
        L && (H.attr({
          opacity: +q
        }), q || setTimeout(function () {
          var a = g.dataLabelsGroup;
          a && (g.visible && H.show(!0), a[f.animation ? "animate" : "attr"]({
            opacity: 1
          }, {
            duration: u
          }));
        }, w - u));
        l.forEach(function (d) {
          v = h(c(a, d.dlOptions || d.options && d.options.dataLabels));
          v.forEach(function (a, b) {
            var c = a.enabled && (!d.isNull || d.dataLabelOnNull) && e(d, a),
                h = d.dataLabels ? d.dataLabels[b] : d.dataLabel,
                k = d.connectors ? d.connectors[b] : d.connector,
                l = t(a.distance, d.labelDistance),
                p = !h;

            if (c) {
              var v = d.getLabelConfig();
              var m = t(a[d.formatPrefix + "Format"], a.format);
              v = M(m) ? A(m, v, n) : (a[d.formatPrefix + "Formatter"] || a.formatter).call(v, a);
              m = a.style;
              var q = a.rotation;
              n.styledMode || (m.color = t(a.color, m.color, g.color, "#000000"), "contrast" === m.color ? (d.contrastColor = D.getContrast(d.color || g.color), m.color = !M(l) && a.inside || 0 > l || f.stacking ? d.contrastColor : "#000000") : delete d.contrastColor, f.cursor && (m.cursor = f.cursor));
              var w = {
                r: a.borderRadius || 0,
                rotation: q,
                padding: a.padding,
                zIndex: 1
              };
              n.styledMode || (w.fill = a.backgroundColor, w.stroke = a.borderColor, w["stroke-width"] = a.borderWidth);
              y(w, function (a, b) {
                "undefined" === typeof a && delete w[b];
              });
            }

            !h || c && M(v) ? c && M(v) && (h ? w.text = v : (d.dataLabels = d.dataLabels || [], h = d.dataLabels[b] = q ? D.text(v, 0, -9999, a.useHTML).addClass("highcharts-data-label") : D.label(v, 0, -9999, a.shape, null, null, a.useHTML, null, "data-label"), b || (d.dataLabel = h), h.addClass(" highcharts-data-label-color-" + d.colorIndex + " " + (a.className || "") + (a.useHTML ? " highcharts-tracker" : ""))), h.options = a, h.attr(w), n.styledMode || h.css(m).shadow(a.shadow), h.added || h.add(H), a.textPath && !a.useHTML && (h.setTextPath(d.getDataLabelPath && d.getDataLabelPath(h) || d.graphic, a.textPath), d.dataLabelPath && !a.textPath.enabled && (d.dataLabelPath = d.dataLabelPath.destroy())), g.alignDataLabel(d, h, a, null, p)) : (d.dataLabel = d.dataLabel && d.dataLabel.destroy(), d.dataLabels && (1 === d.dataLabels.length ? delete d.dataLabels : delete d.dataLabels[b]), b || delete d.dataLabel, k && (d.connector = d.connector.destroy(), d.connectors && (1 === d.connectors.length ? delete d.connectors : delete d.connectors[b])));
          });
        });
      }

      d.fireEvent(this, "afterDrawDataLabels");
    };

    q.prototype.alignDataLabel = function (d, c, g, h, f) {
      var a = this,
          e = this.chart,
          k = this.isCartesian && e.inverted,
          n = this.enabledDataSorting,
          q = t(d.dlBox && d.dlBox.centerX, d.plotX, -9999),
          r = t(d.plotY, -9999),
          u = c.getBBox(),
          y = g.rotation,
          A = g.align,
          K = e.isInsidePlot(q, Math.round(r), k),
          p = "justify" === t(g.overflow, n ? "none" : "justify"),
          b = this.visible && !1 !== d.visible && (d.series.forceDL || n && !p || K || g.inside && h && e.isInsidePlot(q, k ? h.x + 1 : h.y + h.height - 1, k));

      var C = function (b) {
        n && a.xAxis && !p && a.setDataLabelStartPos(d, c, f, K, b);
      };

      if (b) {
        var x = e.renderer.fontMetrics(e.styledMode ? void 0 : g.style.fontSize, c).b;
        h = E({
          x: k ? this.yAxis.len - r : q,
          y: Math.round(k ? this.xAxis.len - q : r),
          width: 0,
          height: 0
        }, h);
        E(g, {
          width: u.width,
          height: u.height
        });
        y ? (p = !1, q = e.renderer.rotCorr(x, y), q = {
          x: h.x + g.x + h.width / 2 + q.x,
          y: h.y + g.y + {
            top: 0,
            middle: .5,
            bottom: 1
          }[g.verticalAlign] * h.height
        }, C(q), c[f ? "attr" : "animate"](q).attr({
          align: A
        }), C = (y + 720) % 360, C = 180 < C && 360 > C, "left" === A ? q.y -= C ? u.height : 0 : "center" === A ? (q.x -= u.width / 2, q.y -= u.height / 2) : "right" === A && (q.x -= u.width, q.y -= C ? 0 : u.height), c.placed = !0, c.alignAttr = q) : (C(h), c.align(g, null, h), q = c.alignAttr);
        p && 0 <= h.height ? this.justifyDataLabel(c, g, q, u, h, f) : t(g.crop, !0) && (b = e.isInsidePlot(q.x, q.y) && e.isInsidePlot(q.x + u.width, q.y + u.height));
        if (g.shape && !y) c[f ? "attr" : "animate"]({
          anchorX: k ? e.plotWidth - d.plotY : d.plotX,
          anchorY: k ? e.plotHeight - d.plotX : d.plotY
        });
      }

      f && n && (c.placed = !1);
      b || n && !p || (c.hide(!0), c.placed = !1);
    };

    q.prototype.setDataLabelStartPos = function (d, c, g, h, f) {
      var a = this.chart,
          e = a.inverted,
          k = this.xAxis,
          n = k.reversed,
          q = e ? c.height / 2 : c.width / 2;
      d = (d = d.pointWidth) ? d / 2 : 0;
      k = e ? f.x : n ? -q - d : k.width - q + d;
      f = e ? n ? this.yAxis.height - q + d : -q - d : f.y;
      c.startXPos = k;
      c.startYPos = f;
      h ? "hidden" === c.visibility && (c.show(), c.attr({
        opacity: 0
      }).animate({
        opacity: 1
      })) : c.attr({
        opacity: 1
      }).animate({
        opacity: 0
      }, void 0, c.hide);
      a.hasRendered && (g && c.attr({
        x: c.startXPos,
        y: c.startYPos
      }), c.placed = !0);
    };

    q.prototype.justifyDataLabel = function (d, c, g, h, f, a) {
      var e = this.chart,
          k = c.align,
          n = c.verticalAlign,
          q = d.box ? 0 : d.padding || 0;
      var r = g.x + q;

      if (0 > r) {
        "right" === k ? (c.align = "left", c.inside = !0) : c.x = -r;
        var t = !0;
      }

      r = g.x + h.width - q;
      r > e.plotWidth && ("left" === k ? (c.align = "right", c.inside = !0) : c.x = e.plotWidth - r, t = !0);
      r = g.y + q;
      0 > r && ("bottom" === n ? (c.verticalAlign = "top", c.inside = !0) : c.y = -r, t = !0);
      r = g.y + h.height - q;
      r > e.plotHeight && ("top" === n ? (c.verticalAlign = "bottom", c.inside = !0) : c.y = e.plotHeight - r, t = !0);
      t && (d.placed = !a, d.align(c, null, f));
      return t;
    };

    P.pie && (P.pie.prototype.dataLabelPositioners = {
      radialDistributionY: function (d) {
        return d.top + d.distributeBox.pos;
      },
      radialDistributionX: function (d, c, g, h) {
        return d.getX(g < c.top + 2 || g > c.bottom - 2 ? h : g, c.half, c);
      },
      justify: function (d, c, g) {
        return g[0] + (d.half ? -1 : 1) * (c + d.labelDistance);
      },
      alignToPlotEdges: function (d, c, g, h) {
        d = d.getBBox().width;
        return c ? d + h : g - d - h;
      },
      alignToConnectors: function (d, c, g, h) {
        var e = 0,
            a;
        d.forEach(function (c) {
          a = c.dataLabel.getBBox().width;
          a > e && (e = a);
        });
        return c ? e + h : g - e - h;
      }
    }, P.pie.prototype.drawDataLabels = function () {
      var e = this,
          c = e.data,
          g,
          h = e.chart,
          f = e.options.dataLabels || {},
          a = f.connectorPadding,
          l,
          v = h.plotWidth,
          r = h.plotHeight,
          w = h.plotLeft,
          y = Math.round(h.chartWidth / 3),
          A,
          D = e.center,
          H = D[2] / 2,
          K = D[1],
          p,
          b,
          C,
          x,
          G = [[], []],
          E,
          N,
          I,
          m,
          P = [0, 0, 0, 0],
          S = e.dataLabelPositioners,
          W;
      e.visible && (f.enabled || e._hasPointLabels) && (c.forEach(function (a) {
        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({
          width: "auto"
        }).css({
          width: "auto",
          textOverflow: "clip"
        }), a.dataLabel.shortened = !1);
      }), q.prototype.drawDataLabels.apply(e), c.forEach(function (a) {
        a.dataLabel && (a.visible ? (G[a.half].push(a), a.dataLabel._pos = null, !M(f.style.width) && !M(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > y && (a.dataLabel.css({
          width: .7 * y
        }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));
      }), G.forEach(function (c, k) {
        var l = c.length,
            n = [],
            q;

        if (l) {
          e.sortByAngle(c, k - .5);

          if (0 < e.maxLabelDistance) {
            var u = Math.max(0, K - H - e.maxLabelDistance);
            var z = Math.min(K + H + e.maxLabelDistance, h.plotHeight);
            c.forEach(function (a) {
              0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, K - H - a.labelDistance), a.bottom = Math.min(K + H + a.labelDistance, h.plotHeight), q = a.dataLabel.getBBox().height || 21, a.distributeBox = {
                target: a.labelPosition.natural.y - a.top + q / 2,
                size: q,
                rank: a.y
              }, n.push(a.distributeBox));
            });
            u = z + q - u;
            d.distribute(n, u, u / 5);
          }

          for (m = 0; m < l; m++) {
            g = c[m];
            C = g.labelPosition;
            p = g.dataLabel;
            I = !1 === g.visible ? "hidden" : "inherit";
            N = u = C.natural.y;
            n && M(g.distributeBox) && ("undefined" === typeof g.distributeBox.pos ? I = "hidden" : (x = g.distributeBox.size, N = S.radialDistributionY(g)));
            delete g.positionIndex;
            if (f.justify) E = S.justify(g, H, D);else switch (f.alignTo) {
              case "connectors":
                E = S.alignToConnectors(c, k, v, w);
                break;

              case "plotEdges":
                E = S.alignToPlotEdges(p, k, v, w);
                break;

              default:
                E = S.radialDistributionX(e, g, N, u);
            }
            p._attr = {
              visibility: I,
              align: C.alignment
            };
            W = g.options.dataLabels || {};
            p._pos = {
              x: E + t(W.x, f.x) + ({
                left: a,
                right: -a
              }[C.alignment] || 0),
              y: N + t(W.y, f.y) - 10
            };
            C.final.x = E;
            C.final.y = N;
            t(f.crop, !0) && (b = p.getBBox().width, u = null, E - b < a && 1 === k ? (u = Math.round(b - E + a), P[3] = Math.max(u, P[3])) : E + b > v - a && 0 === k && (u = Math.round(E + b - v + a), P[1] = Math.max(u, P[1])), 0 > N - x / 2 ? P[0] = Math.max(Math.round(-N + x / 2), P[0]) : N + x / 2 > r && (P[2] = Math.max(Math.round(N + x / 2 - r), P[2])), p.sideOverflow = u);
          }
        }
      }), 0 === u(P) || this.verifyDataLabelOverflow(P)) && (this.placeDataLabels(), this.points.forEach(function (a) {
        W = J(f, a.options.dataLabels);

        if (l = t(W.connectorWidth, 1)) {
          var b;
          A = a.connector;

          if ((p = a.dataLabel) && p._pos && a.visible && 0 < a.labelDistance) {
            I = p._attr.visibility;
            if (b = !A) a.connector = A = h.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + a.colorIndex + (a.className ? " " + a.className : "")).add(e.dataLabelsGroup), h.styledMode || A.attr({
              "stroke-width": l,
              stroke: W.connectorColor || a.color || "#666666"
            });
            A[b ? "attr" : "animate"]({
              d: a.getConnectorPath()
            });
            A.attr("visibility", I);
          } else A && (a.connector = A.destroy());
        }
      }));
    }, P.pie.prototype.placeDataLabels = function () {
      this.points.forEach(function (d) {
        var c = d.dataLabel,
            e;
        c && d.visible && ((e = c._pos) ? (c.sideOverflow && (c._attr.width = Math.max(c.getBBox().width - c.sideOverflow, 0), c.css({
          width: c._attr.width + "px",
          textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
        }), c.shortened = !0), c.attr(c._attr), c[c.moved ? "animate" : "attr"](e), c.moved = !0) : c && c.attr({
          y: -9999
        }));
        delete d.distributeBox;
      }, this);
    }, P.pie.prototype.alignDataLabel = g, P.pie.prototype.verifyDataLabelOverflow = function (d) {
      var c = this.center,
          e = this.options,
          g = e.center,
          f = e.minSize || 80,
          a = null !== e.size;

      if (!a) {
        if (null !== g[0]) var h = Math.max(c[2] - Math.max(d[1], d[3]), f);else h = Math.max(c[2] - d[1] - d[3], f), c[0] += (d[3] - d[1]) / 2;
        null !== g[1] ? h = I(h, f, c[2] - Math.max(d[0], d[2])) : (h = I(h, f, c[2] - d[0] - d[2]), c[1] += (d[0] - d[2]) / 2);
        h < c[2] ? (c[2] = h, c[3] = Math.min(D(e.innerSize || 0, h), h), this.translate(c), this.drawDataLabels && this.drawDataLabels()) : a = !0;
      }

      return a;
    });
    P.column && (P.column.prototype.alignDataLabel = function (d, c, g, h, f) {
      var a = this.chart.inverted,
          e = d.series,
          k = d.dlBox || d.shapeArgs,
          n = t(d.below, d.plotY > t(this.translatedThreshold, e.yAxis.len)),
          r = t(g.inside, !!this.options.stacking);
      k && (h = J(k), 0 > h.y && (h.height += h.y, h.y = 0), k = h.y + h.height - e.yAxis.len, 0 < k && k < h.height && (h.height -= k), a && (h = {
        x: e.yAxis.len - h.y - h.height,
        y: e.xAxis.len - h.x - h.width,
        width: h.height,
        height: h.width
      }), r || (a ? (h.x += n ? 0 : h.width, h.width = 0) : (h.y += n ? h.height : 0, h.height = 0)));
      g.align = t(g.align, !a || r ? "center" : n ? "right" : "left");
      g.verticalAlign = t(g.verticalAlign, a || r ? "middle" : n ? "top" : "bottom");
      q.prototype.alignDataLabel.call(this, d, c, g, h, f);
      g.inside && d.contrastColor && c.css({
        color: d.contrastColor
      });
    });
  });
  S(r, "modules/overlapping-datalabels.src.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.addEvent,
        u = g.fireEvent,
        I = g.isArray,
        M = g.objectEach,
        E = g.pick;
    d = d.Chart;
    r(d, "render", function () {
      var d = [];
      (this.labelCollectors || []).forEach(function (g) {
        d = d.concat(g());
      });
      (this.yAxis || []).forEach(function (g) {
        g.options.stackLabels && !g.options.stackLabels.allowOverlap && M(g.stacks, function (g) {
          M(g, function (g) {
            d.push(g.label);
          });
        });
      });
      (this.series || []).forEach(function (g) {
        var r = g.options.dataLabels;
        g.visible && (!1 !== r.enabled || g._hasPointLabels) && (g.nodes || g.points).forEach(function (g) {
          g.visible && (I(g.dataLabels) ? g.dataLabels : g.dataLabel ? [g.dataLabel] : []).forEach(function (r) {
            var t = r.options;
            r.labelrank = E(t.labelrank, g.labelrank, g.shapeArgs && g.shapeArgs.height);
            t.allowOverlap || d.push(r);
          });
        });
      });
      this.hideOverlappingLabels(d);
    });

    d.prototype.hideOverlappingLabels = function (d) {
      var g = this,
          r = d.length,
          y = g.renderer,
          t,
          A,
          h,
          E = !1;

      var q = function (c) {
        var d = c.box ? 0 : c.padding || 0;
        var e = 0;

        if (c && (!c.alignAttr || c.placed)) {
          var f = c.alignAttr || {
            x: c.attr("x"),
            y: c.attr("y")
          };
          var a = c.parentGroup;
          c.width || (e = c.getBBox(), c.width = e.width, c.height = e.height, e = y.fontMetrics(null, c.element).h);
          return {
            x: f.x + (a.translateX || 0) + d,
            y: f.y + (a.translateY || 0) + d - e,
            width: c.width - 2 * d,
            height: c.height - 2 * d
          };
        }
      };

      for (A = 0; A < r; A++) if (t = d[A]) t.oldOpacity = t.opacity, t.newOpacity = 1, t.absoluteBox = q(t);

      d.sort(function (c, d) {
        return (d.labelrank || 0) - (c.labelrank || 0);
      });

      for (A = 0; A < r; A++) {
        var I = (q = d[A]) && q.absoluteBox;

        for (t = A + 1; t < r; ++t) {
          var e = (h = d[t]) && h.absoluteBox;
          !I || !e || q === h || 0 === q.newOpacity || 0 === h.newOpacity || e.x > I.x + I.width || e.x + e.width < I.x || e.y > I.y + I.height || e.y + e.height < I.y || ((q.labelrank < h.labelrank ? q : h).newOpacity = 0);
        }
      }

      d.forEach(function (c) {
        var d;

        if (c) {
          var e = c.newOpacity;
          c.oldOpacity !== e && (c.alignAttr && c.placed ? (e ? c.show(!0) : d = function () {
            c.hide(!0);
            c.placed = !1;
          }, E = !0, c.alignAttr.opacity = e, c[c.isOld ? "animate" : "attr"](c.alignAttr, null, d), u(g, "afterHideOverlappingLabel")) : c.attr({
            opacity: e
          }));
          c.isOld = !0;
        }
      });
      E && u(g, "afterHideAllOverlappingLabels");
    };
  });
  S(r, "parts/Interaction.js", [r["parts/Globals.js"], r["parts/Legend.js"], r["parts/Point.js"], r["parts/Utilities.js"]], function (d, g, r, u) {
    var I = u.addEvent,
        M = u.createElement,
        E = u.css,
        A = u.defined,
        G = u.extend,
        J = u.fireEvent,
        y = u.isArray,
        t = u.isFunction,
        D = u.isObject,
        h = u.merge,
        N = u.objectEach,
        q = u.pick;
    u = d.Chart;
    var P = d.defaultOptions,
        e = d.defaultPlotOptions,
        c = d.hasTouch,
        k = d.Series,
        n = d.seriesTypes,
        f = d.svg;
    d = d.TrackerMixin = {
      drawTrackerPoint: function () {
        var a = this,
            d = a.chart,
            e = d.pointer,
            f = function (a) {
          var c = e.getPointFromEvent(a);
          "undefined" !== typeof c && (e.isDirectTouch = !0, c.onMouseOver(a));
        },
            g;

        a.points.forEach(function (a) {
          g = y(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];
          a.graphic && (a.graphic.element.point = a);
          g.forEach(function (c) {
            c.div ? c.div.point = a : c.element.point = a;
          });
        });
        a._hasTracking || (a.trackerGroups.forEach(function (g) {
          if (a[g]) {
            a[g].addClass("highcharts-tracker").on("mouseover", f).on("mouseout", function (a) {
              e.onTrackerMouseOut(a);
            });
            if (c) a[g].on("touchstart", f);
            !d.styledMode && a.options.cursor && a[g].css(E).css({
              cursor: a.options.cursor
            });
          }
        }), a._hasTracking = !0);
        J(this, "afterDrawTracker");
      },
      drawTrackerGraph: function () {
        var a = this,
            d = a.options,
            e = d.trackByArea,
            g = [].concat(e ? a.areaPath : a.graphPath),
            h = g.length,
            k = a.chart,
            n = k.pointer,
            q = k.renderer,
            r = k.options.tooltip.snap,
            t = a.tracker,
            p,
            b = function () {
          if (k.hoverSeries !== a) a.onMouseOver();
        },
            u = "rgba(192,192,192," + (f ? .0001 : .002) + ")";

        if (h && !e) for (p = h + 1; p--;) "M" === g[p] && g.splice(p + 1, 0, g[p + 1] - r, g[p + 2], "L"), (p && "M" === g[p] || p === h) && g.splice(p, 0, "L", g[p - 2] + r, g[p - 1]);
        t ? t.attr({
          d: g
        }) : a.graph && (a.tracker = q.path(g).attr({
          visibility: a.visible ? "visible" : "hidden",
          zIndex: 2
        }).addClass(e ? "highcharts-tracker-area" : "highcharts-tracker-line").add(a.group), k.styledMode || a.tracker.attr({
          "stroke-linejoin": "round",
          stroke: u,
          fill: e ? u : "none",
          "stroke-width": a.graph.strokeWidth() + (e ? 0 : 2 * r)
        }), [a.tracker, a.markerGroup].forEach(function (a) {
          a.addClass("highcharts-tracker").on("mouseover", b).on("mouseout", function (a) {
            n.onTrackerMouseOut(a);
          });
          d.cursor && !k.styledMode && a.css({
            cursor: d.cursor
          });
          if (c) a.on("touchstart", b);
        }));
        J(this, "afterDrawTracker");
      }
    };
    n.column && (n.column.prototype.drawTracker = d.drawTrackerPoint);
    n.pie && (n.pie.prototype.drawTracker = d.drawTrackerPoint);
    n.scatter && (n.scatter.prototype.drawTracker = d.drawTrackerPoint);
    G(g.prototype, {
      setItemEvents: function (a, c, d) {
        var e = this,
            f = e.chart.renderer.boxWrapper,
            g = a instanceof r,
            k = "highcharts-legend-" + (g ? "point" : "series") + "-active",
            l = e.chart.styledMode;
        (d ? [c, a.legendSymbol] : [a.legendGroup]).forEach(function (d) {
          if (d) d.on("mouseover", function () {
            a.visible && e.allItems.forEach(function (c) {
              a !== c && c.setState("inactive", !g);
            });
            a.setState("hover");
            a.visible && f.addClass(k);
            l || c.css(e.options.itemHoverStyle);
          }).on("mouseout", function () {
            e.chart.styledMode || c.css(h(a.visible ? e.itemStyle : e.itemHiddenStyle));
            e.allItems.forEach(function (c) {
              a !== c && c.setState("", !g);
            });
            f.removeClass(k);
            a.setState();
          }).on("click", function (c) {
            var d = function () {
              a.setVisible && a.setVisible();
              e.allItems.forEach(function (b) {
                a !== b && b.setState(a.visible ? "inactive" : "", !g);
              });
            };

            f.removeClass(k);
            c = {
              browserEvent: c
            };
            a.firePointEvent ? a.firePointEvent("legendItemClick", c, d) : J(a, "legendItemClick", c, d);
          });
        });
      },
      createCheckboxForItem: function (a) {
        a.checkbox = M("input", {
          type: "checkbox",
          className: "highcharts-legend-checkbox",
          checked: a.selected,
          defaultChecked: a.selected
        }, this.options.itemCheckboxStyle, this.chart.container);
        I(a.checkbox, "click", function (c) {
          J(a.series || a, "checkboxClick", {
            checked: c.target.checked,
            item: a
          }, function () {
            a.select();
          });
        });
      }
    });
    G(u.prototype, {
      showResetZoom: function () {
        function a() {
          c.zoomOut();
        }

        var c = this,
            d = P.lang,
            e = c.options.chart.resetZoomButton,
            f = e.theme,
            g = f.states,
            h = "chart" === e.relativeTo || "spaceBox" === e.relativeTo ? null : "plotBox";
        J(this, "beforeShowResetZoom", null, function () {
          c.resetZoomButton = c.renderer.button(d.resetZoom, null, null, a, f, g && g.hover).attr({
            align: e.position.align,
            title: d.resetZoomTitle
          }).addClass("highcharts-reset-zoom").add().align(e.position, !1, h);
        });
        J(this, "afterShowResetZoom");
      },
      zoomOut: function () {
        J(this, "selection", {
          resetSelection: !0
        }, this.zoom);
      },
      zoom: function (a) {
        var c = this,
            d,
            e = c.pointer,
            f = !1,
            g = c.inverted ? e.mouseDownX : e.mouseDownY;
        !a || a.resetSelection ? (c.axes.forEach(function (a) {
          d = a.zoom();
        }), e.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {
          var h = a.axis,
              k = c.inverted ? h.left : h.top,
              l = c.inverted ? k + h.width : k + h.height,
              b = h.isXAxis,
              n = !1;
          if (!b && g >= k && g <= l || b || !A(g)) n = !0;
          e[b ? "zoomX" : "zoomY"] && n && (d = h.zoom(a.min, a.max), h.displayBtn && (f = !0));
        });
        var h = c.resetZoomButton;
        f && !h ? c.showResetZoom() : !f && D(h) && (c.resetZoomButton = h.destroy());
        d && c.redraw(q(c.options.chart.animation, a && a.animation, 100 > c.pointCount));
      },
      pan: function (a, c) {
        var d = this,
            e = d.hoverPoints,
            f = d.options.chart,
            g;
        c = "object" === typeof c ? c : {
          enabled: c,
          type: "x"
        };
        f && f.panning && (f.panning = c);
        var h = c.type;
        J(this, "pan", {
          originalEvent: a
        }, function () {
          e && e.forEach(function (a) {
            a.setState();
          });
          var c = [1];
          "xy" === h ? c = [1, 0] : "y" === h && (c = [0]);
          c.forEach(function (c) {
            var e = d[c ? "xAxis" : "yAxis"][0],
                f = e.options,
                b = e.horiz,
                h = a[b ? "chartX" : "chartY"];
            b = b ? "mouseDownX" : "mouseDownY";
            var k = d[b],
                l = (e.pointRange || 0) / 2,
                n = e.reversed && !d.inverted || !e.reversed && d.inverted ? -1 : 1,
                q = e.getExtremes(),
                v = e.toValue(k - h, !0) + l * n;
            n = e.toValue(k + e.len - h, !0) - l * n;
            var m = n < v;
            k = m ? n : v;
            v = m ? v : n;
            n = Math.min(q.dataMin, l ? q.min : e.toValue(e.toPixels(q.min) - e.minPixelPadding));
            l = Math.max(q.dataMax, l ? q.max : e.toValue(e.toPixels(q.max) + e.minPixelPadding));

            if (!f.ordinal) {
              c && (f = n - k, 0 < f && (v += f, k = n), f = v - l, 0 < f && (v = l, k -= f));
              if (e.series.length && k !== q.min && v !== q.max && c || e.panningState && k >= e.panningState.startMin && v <= e.panningState.startMax) e.setExtremes(k, v, !1, !1, {
                trigger: "pan"
              }), g = !0;
              d[b] = h;
            }
          });
          g && d.redraw(!1);
          E(d.container, {
            cursor: "move"
          });
        });
      }
    });
    G(r.prototype, {
      select: function (a, c) {
        var d = this,
            e = d.series,
            f = e.chart;
        this.selectedStaging = a = q(a, !d.selected);
        d.firePointEvent(a ? "select" : "unselect", {
          accumulate: c
        }, function () {
          d.selected = d.options.selected = a;
          e.options.data[e.data.indexOf(d)] = d.options;
          d.setState(a && "select");
          c || f.getSelectedPoints().forEach(function (a) {
            var c = a.series;
            a.selected && a !== d && (a.selected = a.options.selected = !1, c.options.data[c.data.indexOf(a)] = a.options, a.setState(f.hoverPoints && c.options.inactiveOtherPoints ? "inactive" : ""), a.firePointEvent("unselect"));
          });
        });
        delete this.selectedStaging;
      },
      onMouseOver: function (a) {
        var c = this.series.chart,
            d = c.pointer;
        a = a ? d.normalize(a) : d.getChartCoordinatesFromPoint(this, c.inverted);
        d.runPointActions(a, this);
      },
      onMouseOut: function () {
        var a = this.series.chart;
        this.firePointEvent("mouseOut");
        this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (a) {
          a.setState();
        });
        a.hoverPoints = a.hoverPoint = null;
      },
      importEvents: function () {
        if (!this.hasImportedEvents) {
          var a = this,
              c = h(a.series.options.point, a.options).events;
          a.events = c;
          N(c, function (c, d) {
            t(c) && I(a, d, c);
          });
          this.hasImportedEvents = !0;
        }
      },
      setState: function (a, c) {
        var d = this.series,
            f = this.state,
            g = d.options.states[a || "normal"] || {},
            h = e[d.type].marker && d.options.marker,
            k = h && !1 === h.enabled,
            l = h && h.states && h.states[a || "normal"] || {},
            n = !1 === l.enabled,
            r = d.stateMarkerGraphic,
            p = this.marker || {},
            b = d.chart,
            t = d.halo,
            u,
            y = h && d.markerAttribs;
        a = a || "";

        if (!(a === this.state && !c || this.selected && "select" !== a || !1 === g.enabled || a && (n || k && !1 === l.enabled) || a && p.states && p.states[a] && !1 === p.states[a].enabled)) {
          this.state = a;
          y && (u = d.markerAttribs(this, a));

          if (this.graphic) {
            f && this.graphic.removeClass("highcharts-point-" + f);
            a && this.graphic.addClass("highcharts-point-" + a);

            if (!b.styledMode) {
              var A = d.pointAttribs(this, a);
              var D = q(b.options.chart.animation, g.animation);
              d.options.inactiveOtherPoints && ((this.dataLabels || []).forEach(function (a) {
                a && a.animate({
                  opacity: A.opacity
                }, D);
              }), this.connector && this.connector.animate({
                opacity: A.opacity
              }, D));
              this.graphic.animate(A, D);
            }

            u && this.graphic.animate(u, q(b.options.chart.animation, l.animation, h.animation));
            r && r.hide();
          } else {
            if (a && l) {
              f = p.symbol || d.symbol;
              r && r.currentSymbol !== f && (r = r.destroy());
              if (u) if (r) r[c ? "animate" : "attr"]({
                x: u.x,
                y: u.y
              });else f && (d.stateMarkerGraphic = r = b.renderer.symbol(f, u.x, u.y, u.width, u.height).add(d.markerGroup), r.currentSymbol = f);
              !b.styledMode && r && r.attr(d.pointAttribs(this, a));
            }

            r && (r[a && this.isInside ? "show" : "hide"](), r.element.point = this);
          }

          a = g.halo;
          g = (r = this.graphic || r) && r.visibility || "inherit";
          a && a.size && r && "hidden" !== g && !this.isCluster ? (t || (d.halo = t = b.renderer.path().add(r.parentGroup)), t.show()[c ? "animate" : "attr"]({
            d: this.haloPath(a.size)
          }), t.attr({
            "class": "highcharts-halo highcharts-color-" + q(this.colorIndex, d.colorIndex) + (this.className ? " " + this.className : ""),
            visibility: g,
            zIndex: -1
          }), t.point = this, b.styledMode || t.attr(G({
            fill: this.color || d.color,
            "fill-opacity": a.opacity
          }, a.attributes))) : t && t.point && t.point.haloPath && t.animate({
            d: t.point.haloPath(0)
          }, null, t.hide);
          J(this, "afterSetState");
        }
      },
      haloPath: function (a) {
        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);
      }
    });
    G(k.prototype, {
      onMouseOver: function () {
        var a = this.chart,
            c = a.hoverSeries;
        if (c && c !== this) c.onMouseOut();
        this.options.events.mouseOver && J(this, "mouseOver");
        this.setState("hover");
        a.hoverSeries = this;
      },
      onMouseOut: function () {
        var a = this.options,
            c = this.chart,
            d = c.tooltip,
            e = c.hoverPoint;
        c.hoverSeries = null;
        if (e) e.onMouseOut();
        this && a.events.mouseOut && J(this, "mouseOut");
        !d || this.stickyTracking || d.shared && !this.noSharedTooltip || d.hide();
        c.series.forEach(function (a) {
          a.setState("", !0);
        });
      },
      setState: function (a, c) {
        var d = this,
            e = d.options,
            f = d.graph,
            g = e.inactiveOtherPoints,
            h = e.states,
            k = e.lineWidth,
            l = e.opacity,
            n = q(h[a || "normal"] && h[a || "normal"].animation, d.chart.options.chart.animation);
        e = 0;
        a = a || "";

        if (d.state !== a && ([d.group, d.markerGroup, d.dataLabelsGroup].forEach(function (c) {
          c && (d.state && c.removeClass("highcharts-series-" + d.state), a && c.addClass("highcharts-series-" + a));
        }), d.state = a, !d.chart.styledMode)) {
          if (h[a] && !1 === h[a].enabled) return;
          a && (k = h[a].lineWidth || k + (h[a].lineWidthPlus || 0), l = q(h[a].opacity, l));
          if (f && !f.dashstyle) for (h = {
            "stroke-width": k
          }, f.animate(h, n); d["zone-graph-" + e];) d["zone-graph-" + e].attr(h), e += 1;
          g || [d.group, d.markerGroup, d.dataLabelsGroup, d.labelBySeries].forEach(function (a) {
            a && a.animate({
              opacity: l
            }, n);
          });
        }

        c && g && d.points && d.setAllPointsToState(a);
      },
      setAllPointsToState: function (a) {
        this.points.forEach(function (c) {
          c.setState && c.setState(a);
        });
      },
      setVisible: function (a, c) {
        var d = this,
            e = d.chart,
            f = d.legendItem,
            g = e.options.chart.ignoreHiddenSeries,
            h = d.visible;
        var k = (d.visible = a = d.options.visible = d.userOptions.visible = "undefined" === typeof a ? !h : a) ? "show" : "hide";
        ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (a) {
          if (d[a]) d[a][k]();
        });
        if (e.hoverSeries === d || (e.hoverPoint && e.hoverPoint.series) === d) d.onMouseOut();
        f && e.legend.colorizeItem(d, a);
        d.isDirty = !0;
        d.options.stacking && e.series.forEach(function (a) {
          a.options.stacking && a.visible && (a.isDirty = !0);
        });
        d.linkedSeries.forEach(function (c) {
          c.setVisible(a, !1);
        });
        g && (e.isDirtyBox = !0);
        J(d, k);
        !1 !== c && e.redraw();
      },
      show: function () {
        this.setVisible(!0);
      },
      hide: function () {
        this.setVisible(!1);
      },
      select: function (a) {
        this.selected = a = this.options.selected = "undefined" === typeof a ? !this.selected : a;
        this.checkbox && (this.checkbox.checked = a);
        J(this, a ? "select" : "unselect");
      },
      drawTracker: d.drawTrackerGraph
    });
  });
  S(r, "parts/Responsive.js", [r["parts/Globals.js"], r["parts/Utilities.js"]], function (d, g) {
    var r = g.find,
        u = g.isArray,
        I = g.isObject,
        M = g.merge,
        E = g.objectEach,
        A = g.pick,
        G = g.splat,
        J = g.uniqueKey;
    d = d.Chart;

    d.prototype.setResponsive = function (d, g) {
      var t = this.options.responsive,
          h = [],
          u = this.currentResponsive;
      !g && t && t.rules && t.rules.forEach(function (d) {
        "undefined" === typeof d._id && (d._id = J());
        this.matchResponsiveRule(d, h);
      }, this);
      g = M.apply(0, h.map(function (d) {
        return r(t.rules, function (g) {
          return g._id === d;
        }).chartOptions;
      }));
      g.isResponsiveOptions = !0;
      h = h.toString() || void 0;
      h !== (u && u.ruleIds) && (u && this.update(u.undoOptions, d, !0), h ? (u = this.currentOptions(g), u.isResponsiveOptions = !0, this.currentResponsive = {
        ruleIds: h,
        mergedOptions: g,
        undoOptions: u
      }, this.update(g, d, !0)) : this.currentResponsive = void 0);
    };

    d.prototype.matchResponsiveRule = function (d, g) {
      var r = d.condition;
      (r.callback || function () {
        return this.chartWidth <= A(r.maxWidth, Number.MAX_VALUE) && this.chartHeight <= A(r.maxHeight, Number.MAX_VALUE) && this.chartWidth >= A(r.minWidth, 0) && this.chartHeight >= A(r.minHeight, 0);
      }).call(this) && g.push(d._id);
    };

    d.prototype.currentOptions = function (d) {
      function g(d, h, t, e) {
        var c;
        E(d, function (d, n) {
          if (!e && -1 < r.collectionsWithUpdate.indexOf(n)) for (d = G(d), t[n] = [], c = 0; c < d.length; c++) h[n][c] && (t[n][c] = {}, g(d[c], h[n][c], t[n][c], e + 1));else I(d) ? (t[n] = u(d) ? [] : {}, g(d, h[n] || {}, t[n], e + 1)) : t[n] = "undefined" === typeof h[n] ? null : h[n];
        });
      }

      var r = this,
          h = {};
      g(d, this.options, h, 0);
      return h;
    };
  });
  S(r, "masters/highcharts.src.js", [r["parts/Globals.js"]], function (d) {
    return d;
  });
  r["masters/highcharts.src.js"]._modules = r;
  return r["masters/highcharts.src.js"];
});

/***/ }),

/***/ "./node_modules/highcharts/modules/exporting.js":
/*!******************************************************!*\
  !*** ./node_modules/highcharts/modules/exporting.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 Highcharts JS v8.0.4 (2020-03-10)

 Exporting module

 (c) 2010-2019 Torstein Honsi

 License: www.highcharts.com/license
*/
(function (e) {
   true && module.exports ? (e["default"] = e, module.exports = e) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! highcharts */ "./node_modules/highcharts/highcharts.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (m) {
    e(m);
    e.Highcharts = m;
    return e;
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(function (e) {
  function m(f, g, e, n) {
    f.hasOwnProperty(g) || (f[g] = n.apply(null, e));
  }

  e = e ? e._modules : {};
  m(e, "modules/full-screen.src.js", [e["parts/Globals.js"]], function (f) {
    var g = f.addEvent,
        e = f.Chart,
        n = function () {
      function g(h) {
        this.chart = h;
        this.isOpen = !1;
        h.container.parentNode instanceof Element && (h = h.container.parentNode, this.browserProps || ("function" === typeof h.requestFullscreen ? this.browserProps = {
          fullscreenChange: "fullscreenchange",
          requestFullscreen: "requestFullscreen",
          exitFullscreen: "exitFullscreen"
        } : h.mozRequestFullScreen ? this.browserProps = {
          fullscreenChange: "mozfullscreenchange",
          requestFullscreen: "mozRequestFullScreen",
          exitFullscreen: "mozCancelFullScreen"
        } : h.webkitRequestFullScreen ? this.browserProps = {
          fullscreenChange: "webkitfullscreenchange",
          requestFullscreen: "webkitRequestFullScreen",
          exitFullscreen: "webkitExitFullscreen"
        } : h.msRequestFullscreen && (this.browserProps = {
          fullscreenChange: "MSFullscreenChange",
          requestFullscreen: "msRequestFullscreen",
          exitFullscreen: "msExitFullscreen"
        })));
      }

      g.prototype.close = function () {
        var h = this.chart;
        if (this.isOpen && this.browserProps && h.container.ownerDocument instanceof Document) h.container.ownerDocument[this.browserProps.exitFullscreen]();
        this.unbindFullscreenEvent && this.unbindFullscreenEvent();
        this.isOpen = !1;
        this.setButtonText();
      };

      g.prototype.open = function () {
        var h = this,
            g = h.chart;

        if (h.browserProps) {
          h.unbindFullscreenEvent = f.addEvent(g.container.ownerDocument, h.browserProps.fullscreenChange, function () {
            h.isOpen ? (h.isOpen = !1, h.close()) : (h.isOpen = !0, h.setButtonText());
          });

          if (g.container.parentNode instanceof Element) {
            var e = g.container.parentNode[h.browserProps.requestFullscreen]();
            if (e) e["catch"](function () {
              alert("Full screen is not supported inside a frame.");
            });
          }

          f.addEvent(g, "destroy", h.unbindFullscreenEvent);
        }
      };

      g.prototype.setButtonText = function () {
        var h,
            g = this.chart,
            f = g.exportDivElements,
            e = g.options.exporting,
            n = null === (h = null === e || void 0 === e ? void 0 : e.buttons) || void 0 === h ? void 0 : h.contextButton.menuItems;
        h = g.options.lang;
        (null === e || void 0 === e ? 0 : e.menuItemDefinitions) && (null === h || void 0 === h ? 0 : h.exitFullscreen) && h.viewFullscreen && n && f && f.length && (f[n.indexOf("viewFullscreen")].innerHTML = this.isOpen ? h.exitFullscreen : e.menuItemDefinitions.viewFullscreen.text || h.viewFullscreen);
      };

      g.prototype.toggle = function () {
        this.isOpen ? this.close() : this.open();
      };

      return g;
    }();

    f.Fullscreen = n;
    g(e, "beforeRender", function () {
      this.fullscreen = new f.Fullscreen(this);
    });
    return f.Fullscreen;
  });
  m(e, "mixins/navigation.js", [], function () {
    return {
      initUpdate: function (f) {
        f.navigation || (f.navigation = {
          updates: [],
          update: function (g, f) {
            this.updates.forEach(function (e) {
              e.update.call(e.context, g, f);
            });
          }
        });
      },
      addUpdate: function (f, g) {
        g.navigation || this.initUpdate(g);
        g.navigation.updates.push({
          update: f,
          context: g
        });
      }
    };
  });
  m(e, "modules/exporting.src.js", [e["parts/Globals.js"], e["parts/Utilities.js"], e["mixins/navigation.js"]], function (f, g, e) {
    var n = g.addEvent,
        u = g.css,
        h = g.createElement,
        m = g.discardElement,
        x = g.extend,
        I = g.find,
        B = g.fireEvent,
        J = g.isObject,
        p = g.merge,
        E = g.objectEach,
        q = g.pick,
        K = g.removeEvent,
        L = g.uniqueKey,
        w = f.defaultOptions,
        y = f.doc,
        C = f.Chart,
        M = f.isTouchDevice,
        z = f.win,
        G = z.navigator.userAgent,
        F = f.SVGRenderer,
        H = f.Renderer.prototype.symbols,
        N = /Edge\/|Trident\/|MSIE /.test(G),
        O = /firefox/i.test(G);
    x(w.lang, {
      viewFullscreen: "View in full screen",
      exitFullscreen: "Exit from full screen",
      printChart: "Print chart",
      downloadPNG: "Download PNG image",
      downloadJPEG: "Download JPEG image",
      downloadPDF: "Download PDF document",
      downloadSVG: "Download SVG vector image",
      contextButtonTitle: "Chart context menu"
    });
    w.navigation || (w.navigation = {});
    p(!0, w.navigation, {
      buttonOptions: {
        theme: {},
        symbolSize: 14,
        symbolX: 12.5,
        symbolY: 10.5,
        align: "right",
        buttonSpacing: 3,
        height: 22,
        verticalAlign: "top",
        width: 24
      }
    });
    p(!0, w.navigation, {
      menuStyle: {
        border: "1px solid #999999",
        background: "#ffffff",
        padding: "5px 0"
      },
      menuItemStyle: {
        padding: "0.5em 1em",
        color: "#333333",
        background: "none",
        fontSize: M ? "14px" : "11px",
        transition: "background 250ms, color 250ms"
      },
      menuItemHoverStyle: {
        background: "#335cad",
        color: "#ffffff"
      },
      buttonOptions: {
        symbolFill: "#666666",
        symbolStroke: "#666666",
        symbolStrokeWidth: 3,
        theme: {
          padding: 5
        }
      }
    });
    w.exporting = {
      type: "image/png",
      url: "https://export.highcharts.com/",
      printMaxWidth: 780,
      scale: 2,
      buttons: {
        contextButton: {
          className: "highcharts-contextbutton",
          menuClassName: "highcharts-contextmenu",
          symbol: "menu",
          titleKey: "contextButtonTitle",
          menuItems: "viewFullscreen printChart separator downloadPNG downloadJPEG downloadPDF downloadSVG".split(" ")
        }
      },
      menuItemDefinitions: {
        viewFullscreen: {
          textKey: "viewFullscreen",
          onclick: function () {
            this.fullscreen.toggle();
          }
        },
        printChart: {
          textKey: "printChart",
          onclick: function () {
            this.print();
          }
        },
        separator: {
          separator: !0
        },
        downloadPNG: {
          textKey: "downloadPNG",
          onclick: function () {
            this.exportChart();
          }
        },
        downloadJPEG: {
          textKey: "downloadJPEG",
          onclick: function () {
            this.exportChart({
              type: "image/jpeg"
            });
          }
        },
        downloadPDF: {
          textKey: "downloadPDF",
          onclick: function () {
            this.exportChart({
              type: "application/pdf"
            });
          }
        },
        downloadSVG: {
          textKey: "downloadSVG",
          onclick: function () {
            this.exportChart({
              type: "image/svg+xml"
            });
          }
        }
      }
    };

    f.post = function (a, b, c) {
      var d = h("form", p({
        method: "post",
        action: a,
        enctype: "multipart/form-data"
      }, c), {
        display: "none"
      }, y.body);
      E(b, function (a, b) {
        h("input", {
          type: "hidden",
          name: b,
          value: a
        }, null, d);
      });
      d.submit();
      m(d);
    };

    f.isSafari && f.win.matchMedia("print").addListener(function (a) {
      f.printingChart && (a.matches ? f.printingChart.beforePrint() : f.printingChart.afterPrint());
    });
    x(C.prototype, {
      sanitizeSVG: function (a, b) {
        var c = a.indexOf("</svg>") + 6,
            d = a.substr(c);
        a = a.substr(0, c);
        b && b.exporting && b.exporting.allowHTML && d && (d = '<foreignObject x="0" y="0" width="' + b.chart.width + '" height="' + b.chart.height + '"><body xmlns="http://www.w3.org/1999/xhtml">' + d + "</body></foreignObject>", a = a.replace("</svg>", d + "</svg>"));
        a = a.replace(/zIndex="[^"]+"/g, "").replace(/symbolName="[^"]+"/g, "").replace(/jQuery[0-9]+="[^"]+"/g, "").replace(/url\(("|&quot;)(.*?)("|&quot;);?\)/g, "url($2)").replace(/url\([^#]+#/g, "url(#").replace(/<svg /, '<svg xmlns:xlink="http://www.w3.org/1999/xlink" ').replace(/ (|NS[0-9]+:)href=/g, " xlink:href=").replace(/\n/, " ").replace(/(fill|stroke)="rgba\(([ 0-9]+,[ 0-9]+,[ 0-9]+),([ 0-9\.]+)\)"/g, '$1="rgb($2)" $1-opacity="$3"').replace(/&nbsp;/g, "\u00a0").replace(/&shy;/g, "\u00ad");
        this.ieSanitizeSVG && (a = this.ieSanitizeSVG(a));
        return a;
      },
      getChartHTML: function () {
        this.styledMode && this.inlineStyles();
        return this.container.innerHTML;
      },
      getSVG: function (a) {
        var b,
            c = p(this.options, a);
        c.plotOptions = p(this.userOptions.plotOptions, a && a.plotOptions);
        c.time = p(this.userOptions.time, a && a.time);
        var d = h("div", null, {
          position: "absolute",
          top: "-9999em",
          width: this.chartWidth + "px",
          height: this.chartHeight + "px"
        }, y.body);
        var g = this.renderTo.style.width;
        var e = this.renderTo.style.height;
        g = c.exporting.sourceWidth || c.chart.width || /px$/.test(g) && parseInt(g, 10) || (c.isGantt ? 800 : 600);
        e = c.exporting.sourceHeight || c.chart.height || /px$/.test(e) && parseInt(e, 10) || 400;
        x(c.chart, {
          animation: !1,
          renderTo: d,
          forExport: !0,
          renderer: "SVGRenderer",
          width: g,
          height: e
        });
        c.exporting.enabled = !1;
        delete c.data;
        c.series = [];
        this.series.forEach(function (a) {
          b = p(a.userOptions, {
            animation: !1,
            enableMouseTracking: !1,
            showCheckbox: !1,
            visible: a.visible
          });
          b.isInternal || c.series.push(b);
        });
        this.axes.forEach(function (a) {
          a.userOptions.internalKey || (a.userOptions.internalKey = L());
        });
        var r = new f.Chart(c, this.callback);
        a && ["xAxis", "yAxis", "series"].forEach(function (b) {
          var d = {};
          a[b] && (d[b] = a[b], r.update(d));
        });
        this.axes.forEach(function (a) {
          var b = I(r.axes, function (b) {
            return b.options.internalKey === a.userOptions.internalKey;
          }),
              d = a.getExtremes(),
              c = d.userMin;
          d = d.userMax;
          b && ("undefined" !== typeof c && c !== b.min || "undefined" !== typeof d && d !== b.max) && b.setExtremes(c, d, !0, !1);
        });
        g = r.getChartHTML();
        B(this, "getSVG", {
          chartCopy: r
        });
        g = this.sanitizeSVG(g, c);
        c = null;
        r.destroy();
        m(d);
        return g;
      },
      getSVGForExport: function (a, b) {
        var c = this.options.exporting;
        return this.getSVG(p({
          chart: {
            borderRadius: 0
          }
        }, c.chartOptions, b, {
          exporting: {
            sourceWidth: a && a.sourceWidth || c.sourceWidth,
            sourceHeight: a && a.sourceHeight || c.sourceHeight
          }
        }));
      },
      getFilename: function () {
        var a = this.userOptions.title && this.userOptions.title.text,
            b = this.options.exporting.filename;
        if (b) return b.replace(/\//g, "-");
        "string" === typeof a && (b = a.toLowerCase().replace(/<\/?[^>]+(>|$)/g, "").replace(/[\s_]+/g, "-").replace(/[^a-z0-9\-]/g, "").replace(/^[\-]+/g, "").replace(/[\-]+/g, "-").substr(0, 24).replace(/[\-]+$/g, ""));
        if (!b || 5 > b.length) b = "chart";
        return b;
      },
      exportChart: function (a, b) {
        b = this.getSVGForExport(a, b);
        a = p(this.options.exporting, a);
        f.post(a.url, {
          filename: a.filename ? a.filename.replace(/\//g, "-") : this.getFilename(),
          type: a.type,
          width: a.width || 0,
          scale: a.scale,
          svg: b
        }, a.formAttributes);
      },
      moveContainers: function (a) {
        (this.fixedDiv ? [this.fixedDiv, this.scrollingContainer] : [this.container]).forEach(function (b) {
          a.appendChild(b);
        });
      },
      beforePrint: function () {
        var a = y.body,
            b = this.options.exporting.printMaxWidth,
            c = {
          childNodes: a.childNodes,
          origDisplay: [],
          resetParams: void 0
        };
        this.isPrinting = !0;
        this.pointer.reset(null, 0);
        B(this, "beforePrint");
        b && this.chartWidth > b && (c.resetParams = [this.options.chart.width, void 0, !1], this.setSize(b, void 0, !1));
        [].forEach.call(c.childNodes, function (a, b) {
          1 === a.nodeType && (c.origDisplay[b] = a.style.display, a.style.display = "none");
        });
        this.moveContainers(a);
        this.printReverseInfo = c;
      },
      afterPrint: function () {
        if (this.printReverseInfo) {
          var a = this.printReverseInfo.childNodes,
              b = this.printReverseInfo.origDisplay,
              c = this.printReverseInfo.resetParams;
          this.moveContainers(this.renderTo);
          [].forEach.call(a, function (a, c) {
            1 === a.nodeType && (a.style.display = b[c] || "");
          });
          this.isPrinting = !1;
          c && this.setSize.apply(this, c);
          delete this.printReverseInfo;
          delete f.printingChart;
          B(this, "afterPrint");
        }
      },
      print: function () {
        var a = this;
        a.isPrinting || (f.printingChart = a, f.isSafari || a.beforePrint(), setTimeout(function () {
          z.focus();
          z.print();
          f.isSafari || setTimeout(function () {
            a.afterPrint();
          }, 1E3);
        }, 1));
      },
      contextMenu: function (a, b, c, d, e, f, r) {
        var k = this,
            D = k.options.navigation,
            p = k.chartWidth,
            A = k.chartHeight,
            t = "cache-" + a,
            l = k[t],
            v = Math.max(e, f);

        if (!l) {
          k.exportContextMenu = k[t] = l = h("div", {
            className: a
          }, {
            position: "absolute",
            zIndex: 1E3,
            padding: v + "px",
            pointerEvents: "auto"
          }, k.fixedDiv || k.container);
          var m = h("ul", {
            className: "highcharts-menu"
          }, {
            listStyle: "none",
            margin: 0,
            padding: 0
          }, l);
          k.styledMode || u(m, x({
            MozBoxShadow: "3px 3px 10px #888",
            WebkitBoxShadow: "3px 3px 10px #888",
            boxShadow: "3px 3px 10px #888"
          }, D.menuStyle));

          l.hideMenu = function () {
            u(l, {
              display: "none"
            });
            r && r.setState(0);
            k.openMenu = !1;
            u(k.renderTo, {
              overflow: "hidden"
            });
            g.clearTimeout(l.hideTimer);
            B(k, "exportMenuHidden");
          };

          k.exportEvents.push(n(l, "mouseleave", function () {
            l.hideTimer = z.setTimeout(l.hideMenu, 500);
          }), n(l, "mouseenter", function () {
            g.clearTimeout(l.hideTimer);
          }), n(y, "mouseup", function (b) {
            k.pointer.inClass(b.target, a) || l.hideMenu();
          }), n(l, "click", function () {
            k.openMenu && l.hideMenu();
          }));
          b.forEach(function (a) {
            "string" === typeof a && (a = k.options.exporting.menuItemDefinitions[a]);

            if (J(a, !0)) {
              if (a.separator) var b = h("hr", null, null, m);else b = h("li", {
                className: "highcharts-menu-item",
                onclick: function (b) {
                  b && b.stopPropagation();
                  l.hideMenu();
                  a.onclick && a.onclick.apply(k, arguments);
                },
                innerHTML: a.text || k.options.lang[a.textKey]
              }, null, m), k.styledMode || (b.onmouseover = function () {
                u(this, D.menuItemHoverStyle);
              }, b.onmouseout = function () {
                u(this, D.menuItemStyle);
              }, u(b, x({
                cursor: "pointer"
              }, D.menuItemStyle)));
              k.exportDivElements.push(b);
            }
          });
          k.exportDivElements.push(m, l);
          k.exportMenuWidth = l.offsetWidth;
          k.exportMenuHeight = l.offsetHeight;
        }

        b = {
          display: "block"
        };
        c + k.exportMenuWidth > p ? b.right = p - c - e - v + "px" : b.left = c - v + "px";
        d + f + k.exportMenuHeight > A && "top" !== r.alignOptions.verticalAlign ? b.bottom = A - d - v + "px" : b.top = d + f - v + "px";
        u(l, b);
        u(k.renderTo, {
          overflow: ""
        });
        k.openMenu = !0;
        B(k, "exportMenuShown");
      },
      addButton: function (a) {
        var b = this,
            c = b.renderer,
            d = p(b.options.navigation.buttonOptions, a),
            g = d.onclick,
            e = d.menuItems,
            f = d.symbolSize || 12;
        b.btnCount || (b.btnCount = 0);
        b.exportDivElements || (b.exportDivElements = [], b.exportSVGElements = []);

        if (!1 !== d.enabled) {
          var k = d.theme,
              h = k.states,
              m = h && h.hover;
          h = h && h.select;
          var A;
          b.styledMode || (k.fill = q(k.fill, "#ffffff"), k.stroke = q(k.stroke, "none"));
          delete k.states;
          g ? A = function (a) {
            a && a.stopPropagation();
            g.call(b, a);
          } : e && (A = function (a) {
            a && a.stopPropagation();
            b.contextMenu(t.menuClassName, e, t.translateX, t.translateY, t.width, t.height, t);
            t.setState(2);
          });
          d.text && d.symbol ? k.paddingLeft = q(k.paddingLeft, 25) : d.text || x(k, {
            width: d.width,
            height: d.height,
            padding: 0
          });
          b.styledMode || (k["stroke-linecap"] = "round", k.fill = q(k.fill, "#ffffff"), k.stroke = q(k.stroke, "none"));
          var t = c.button(d.text, 0, 0, A, k, m, h).addClass(a.className).attr({
            title: q(b.options.lang[d._titleKey || d.titleKey], "")
          });
          t.menuClassName = a.menuClassName || "highcharts-menu-" + b.btnCount++;

          if (d.symbol) {
            var l = c.symbol(d.symbol, d.symbolX - f / 2, d.symbolY - f / 2, f, f, {
              width: f,
              height: f
            }).addClass("highcharts-button-symbol").attr({
              zIndex: 1
            }).add(t);
            b.styledMode || l.attr({
              stroke: d.symbolStroke,
              fill: d.symbolFill,
              "stroke-width": d.symbolStrokeWidth || 1
            });
          }

          t.add(b.exportingGroup).align(x(d, {
            width: t.width,
            x: q(d.x, b.buttonOffset)
          }), !0, "spacingBox");
          b.buttonOffset += (t.width + d.buttonSpacing) * ("right" === d.align ? -1 : 1);
          b.exportSVGElements.push(t, l);
        }
      },
      destroyExport: function (a) {
        var b = a ? a.target : this;
        a = b.exportSVGElements;
        var c = b.exportDivElements,
            d = b.exportEvents,
            f;
        a && (a.forEach(function (a, d) {
          a && (a.onclick = a.ontouchstart = null, f = "cache-" + a.menuClassName, b[f] && delete b[f], b.exportSVGElements[d] = a.destroy());
        }), a.length = 0);
        b.exportingGroup && (b.exportingGroup.destroy(), delete b.exportingGroup);
        c && (c.forEach(function (a, d) {
          g.clearTimeout(a.hideTimer);
          K(a, "mouseleave");
          b.exportDivElements[d] = a.onmouseout = a.onmouseover = a.ontouchstart = a.onclick = null;
          m(a);
        }), c.length = 0);
        d && (d.forEach(function (a) {
          a();
        }), d.length = 0);
      }
    });
    F.prototype.inlineToAttributes = "fill stroke strokeLinecap strokeLinejoin strokeWidth textAnchor x y".split(" ");
    F.prototype.inlineBlacklist = [/-/, /^(clipPath|cssText|d|height|width)$/, /^font$/, /[lL]ogical(Width|Height)$/, /perspective/, /TapHighlightColor/, /^transition/, /^length$/];
    F.prototype.unstyledElements = ["clipPath", "defs", "desc"];

    C.prototype.inlineStyles = function () {
      function a(a) {
        return a.replace(/([A-Z])/g, function (a, b) {
          return "-" + b.toLowerCase();
        });
      }

      function b(c) {
        function k(b, e) {
          v = u = !1;

          if (g) {
            for (q = g.length; q-- && !u;) u = g[q].test(e);

            v = !u;
          }

          "transform" === e && "none" === b && (v = !0);

          for (q = f.length; q-- && !v;) v = f[q].test(e) || "function" === typeof b;

          v || x[e] === b && "svg" !== c.nodeName || h[c.nodeName][e] === b || (-1 !== d.indexOf(e) ? c.setAttribute(a(e), b) : l += a(e) + ":" + b + ";");
        }

        var l = "",
            v,
            u,
            q;

        if (1 === c.nodeType && -1 === e.indexOf(c.nodeName)) {
          var r = z.getComputedStyle(c, null);
          var x = "svg" === c.nodeName ? {} : z.getComputedStyle(c.parentNode, null);

          if (!h[c.nodeName]) {
            m = n.getElementsByTagName("svg")[0];
            var w = n.createElementNS(c.namespaceURI, c.nodeName);
            m.appendChild(w);
            h[c.nodeName] = p(z.getComputedStyle(w, null));
            "text" === c.nodeName && delete h.text.fill;
            m.removeChild(w);
          }

          if (O || N) for (var y in r) k(r[y], y);else E(r, k);
          l && (r = c.getAttribute("style"), c.setAttribute("style", (r ? r + ";" : "") + l));
          "svg" === c.nodeName && c.setAttribute("stroke-width", "1px");
          "text" !== c.nodeName && [].forEach.call(c.children || c.childNodes, b);
        }
      }

      var c = this.renderer,
          d = c.inlineToAttributes,
          f = c.inlineBlacklist,
          g = c.inlineWhitelist,
          e = c.unstyledElements,
          h = {},
          m;
      c = y.createElement("iframe");
      u(c, {
        width: "1px",
        height: "1px",
        visibility: "hidden"
      });
      y.body.appendChild(c);
      var n = c.contentWindow.document;
      n.open();
      n.write('<svg xmlns="http://www.w3.org/2000/svg"></svg>');
      n.close();
      b(this.container.querySelector("svg"));
      m.parentNode.removeChild(m);
    };

    H.menu = function (a, b, c, d) {
      return ["M", a, b + 2.5, "L", a + c, b + 2.5, "M", a, b + d / 2 + .5, "L", a + c, b + d / 2 + .5, "M", a, b + d - 1.5, "L", a + c, b + d - 1.5];
    };

    H.menuball = function (a, b, c, d) {
      a = [];
      d = d / 3 - 2;
      return a = a.concat(this.circle(c - d, b, d, d), this.circle(c - d, b + d + 4, d, d), this.circle(c - d, b + 2 * (d + 4), d, d));
    };

    C.prototype.renderExporting = function () {
      var a = this,
          b = a.options.exporting,
          c = b.buttons,
          d = a.isDirtyExporting || !a.exportSVGElements;
      a.buttonOffset = 0;
      a.isDirtyExporting && a.destroyExport();
      d && !1 !== b.enabled && (a.exportEvents = [], a.exportingGroup = a.exportingGroup || a.renderer.g("exporting-group").attr({
        zIndex: 3
      }).add(), E(c, function (b) {
        a.addButton(b);
      }), a.isDirtyExporting = !1);
      n(a, "destroy", a.destroyExport);
    };

    n(C, "init", function () {
      var a = this;
      a.exporting = {
        update: function (b, c) {
          a.isDirtyExporting = !0;
          p(!0, a.options.exporting, b);
          q(c, !0) && a.redraw();
        }
      };
      e.addUpdate(function (b, c) {
        a.isDirtyExporting = !0;
        p(!0, a.options.navigation, b);
        q(c, !0) && a.redraw();
      }, a);
    });
    C.prototype.callbacks.push(function (a) {
      a.renderExporting();
      n(a, "redraw", a.renderExporting);
    });
  });
  m(e, "masters/modules/exporting.src.js", [], function () {});
});

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _styles_index_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles/index.scss */ "./src/styles/index.scss");
/* harmony import */ var _styles_index_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_styles_index_scss__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _scripts_card_searcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scripts/card_searcher */ "./src/scripts/card_searcher.js");
/* harmony import */ var _scripts_card_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scripts/card_generator */ "./src/scripts/card_generator.js");



window.addEventListener("DOMContentLoaded", function () {
  var board = document.createElement("div");
  var searchBar = document.createElement("form");
  var inputField = document.createElement("input");
  var submitButton = document.createElement("button");
  var searchIcon = document.createElement("i");
  var titleContainer = document.createElement('div');
  var title = document.createElement("h1");
  var titleImg = document.createElement("img");
  var navContainer = document.createElement('div');
  var gitLinkImg = document.createElement("i");
  var linkedinLinkImg = document.createElement("i");
  var angelLinkImg = document.createElement("i");
  var gitLink = document.createElement("a");
  var linkedinLink = document.createElement("a");
  var angelLink = document.createElement("a");
  var errorsContainer = document.createElement("div");
  var instructionsContainer = document.createElement('div');
  var instructionsButton = document.createElement("i");
  instructionsContainer.classList.add('instructions-container');
  instructionsContainer.append(instructionsButton);
  errorsContainer.setAttribute('id', "errors-container");
  gitLink.append(gitLinkImg);
  gitLink.classList.add('nav-link');
  gitLink.setAttribute("href", "https://github.com/Norton-Design/cardAugury");
  gitLink.setAttribute("target", "_blank");
  gitLink.setAttribute("rel", "noopener noreferrer");
  gitLink.setAttribute('title', 'Github Repo');
  linkedinLink.append(linkedinLinkImg);
  linkedinLink.classList.add('nav-link');
  linkedinLink.setAttribute("href", "https://www.linkedin.com/in/michael-norton-5b5559199/");
  linkedinLink.setAttribute("target", "_blank");
  linkedinLink.setAttribute("rel", "noopener noreferrer");
  linkedinLink.setAttribute('title', 'Linkedin Link');
  angelLink.append(angelLinkImg);
  angelLink.classList.add('nav-link');
  angelLink.setAttribute("href", "https://angel.co/u/michael-norton-17");
  angelLink.setAttribute("target", "_blank");
  angelLink.setAttribute("rel", "noopener noreferrer");
  angelLink.setAttribute("title", "Angellist Link");
  document.body.classList.add("center");
  document.body.append(board);
  board.classList.add("board", "center");
  board.setAttribute('id', "main-board");
  board.append(instructionsContainer);
  board.append(errorsContainer);
  board.append(titleContainer);
  board.append(searchBar);
  board.append(navContainer);
  titleContainer.append(titleImg);
  titleContainer.append(title);
  titleContainer.classList.add("title-container");
  navContainer.append(gitLink);
  navContainer.append(linkedinLink);
  navContainer.append(angelLink);
  navContainer.classList.add('nav');
  titleImg.setAttribute("src", "./src/images/final-owl2.png");
  title.innerHTML = "Card Augury";
  searchIcon.classList.add("fa");
  searchIcon.classList.add("fa-search");
  linkedinLinkImg.classList.add('fa');
  linkedinLinkImg.classList.add('fa-linkedin');
  gitLinkImg.classList.add('fa');
  gitLinkImg.classList.add('fa-github');
  angelLinkImg.classList.add('fa');
  angelLinkImg.classList.add('fa-angellist');
  submitButton.append(searchIcon);
  submitButton.classList.add('search-button');
  instructionsButton.classList.add("fa");
  instructionsButton.classList.add("fa-bars");
  inputField.setAttribute("id", "searchbar");
  inputField.setAttribute("placeholder", "Search for a card...");
  inputField.classList.add("searchbar");
  searchBar.classList.add("searchbar-container");
  searchBar.append(inputField);
  searchBar.append(submitButton);
  var modal = document.getElementById("modal");
  var span = document.getElementsByClassName("close")[0];

  window.onclick = function (event) {
    if (event.target == modal) {
      modal.style.display = "none";
    }
  };

  span.onclick = function () {
    modal.style.display = "none";
  };

  instructionsButton.onclick = function () {
    modal.style.display = "block";
  };

  submitButton.addEventListener('click', function (e) {
    e.preventDefault();
    Object(_scripts_card_searcher__WEBPACK_IMPORTED_MODULE_1__["cardSearcher"])().then(function (card) {
      var navCon = document.getElementsByClassName("nav")[0];

      if (navCon) {
        board.removeChild(navContainer);
      }

      Object(_scripts_card_generator__WEBPACK_IMPORTED_MODULE_2__["default"])(card);
      board.append(navContainer);

      if (card.object) {
        board.style.margin = "0 5rem 0 rem 5rem";
        board.style.minHeight = 'inherit';
      }

      instructionsContainer.style.margin = "1.2rem 0";
    });
  });
});

/***/ }),

/***/ "./src/scripts/card_generator.js":
/*!***************************************!*\
  !*** ./src/scripts/card_generator.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _set_fetcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./set_fetcher */ "./src/scripts/set_fetcher.js");
/* harmony import */ var _set_stats_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./set_stats_util */ "./src/scripts/set_stats_util.js");
/* harmony import */ var _card_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./card_util */ "./src/scripts/card_util.js");
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! babel-polyfill */ "./node_modules/babel-polyfill/lib/index.js");
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(babel_polyfill__WEBPACK_IMPORTED_MODULE_3__);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }






var Highcharts = __webpack_require__(/*! highcharts */ "./node_modules/highcharts/highcharts.js");

__webpack_require__(/*! highcharts/modules/exporting */ "./node_modules/highcharts/modules/exporting.js")(Highcharts);

var cardGenerator = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(cardInfo) {
    var board, prevContainer, cardContainer, setStatContainer, imgLink, setBarChartPlaceholder, setPieChartPlaceholder, pieLoadingIcon, barLoadingIcon;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            board = document.getElementById("main-board");
            prevContainer = document.getElementById("card-container");
            cardContainer = document.createElement("div");
            setStatContainer = document.createElement('div');
            imgLink = cardInfo.image_uris.normal;
            setBarChartPlaceholder = document.createElement('div');
            setPieChartPlaceholder = document.createElement('div');
            pieLoadingIcon = document.createElement("i");
            barLoadingIcon = document.createElement("i");
            if (prevContainer) board.removeChild(prevContainer);
            pieLoadingIcon.classList.add("fa");
            pieLoadingIcon.classList.add("fa-spinner");
            barLoadingIcon.classList.add("fa");
            barLoadingIcon.classList.add("fa-spinner");
            setStatContainer.classList.add('set-stats-container');
            setBarChartPlaceholder.setAttribute("id", "set-bar-ph"); // <--- TARGET TO REPLACE THE BARCHART

            setPieChartPlaceholder.setAttribute("id", "set-pie-ph"); // <--- TARGET TO REPLACE THE PIECHART

            setBarChartPlaceholder.append(barLoadingIcon);
            setPieChartPlaceholder.append(pieLoadingIcon);
            board.append(cardContainer);
            setStatContainer.append(setBarChartPlaceholder);
            setStatContainer.append(setPieChartPlaceholder);
            cardContainer.append(imgCreator(imgLink));
            cardContainer.append(statBlockCreator(cardInfo));
            cardContainer.append(setStatContainer);
            cardContainer.setAttribute("id", "card-container");
            cardContainer.classList.add("card-container");
            Object(_set_fetcher__WEBPACK_IMPORTED_MODULE_0__["setFetcher"])(cardInfo).then(function (cardSet) {
              return setStatsCreator(cardInfo, cardSet);
            });

          case 28:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function cardGenerator(_x) {
    return _ref.apply(this, arguments);
  };
}();

var imgCreator = function imgCreator(imgLink) {
  var imgContainer = document.createElement("div");
  imgContainer.classList.add("image-container");
  var img = document.createElement("img");
  img.setAttribute("src", imgLink);
  imgContainer.append(img);
  return imgContainer;
};

var statBlockCreator = function statBlockCreator(cardInfo) {
  var name = cardInfo.name,
      mana_cost = cardInfo.mana_cost,
      rarity = cardInfo.rarity,
      oracle_text = cardInfo.oracle_text,
      set_name = cardInfo.set_name,
      type_line = cardInfo.type_line,
      flavor_text = cardInfo.flavor_text;
  var statBlockContainer = document.createElement("ul");
  statBlockContainer.classList.add("stat-block-container");
  var cardTitle = document.createElement("li");
  var title = document.createElement("h2");
  var cardCost = document.createElement("div");
  cardCost.append(Object(_card_util__WEBPACK_IMPORTED_MODULE_2__["manaImageGenerator"])(mana_cost));
  title.innerHTML = name;
  cardTitle.append(title);
  cardTitle.append(cardCost);
  cardTitle.classList.add("card-title-container");
  statBlockContainer.append(cardTitle); // SET THE LIST VALUES FOR THE CARD

  var hr = document.createElement("hr");
  statBlockContainer.append(hr);
  var cardType = document.createElement("li");
  cardType.innerHTML = type_line;
  statBlockContainer.append(cardType);
  var cardSetName = document.createElement("li");
  cardSetName.innerHTML = set_name;
  statBlockContainer.append(cardSetName);
  var cardRarity = document.createElement("li");
  cardRarity.innerHTML = capitalize(rarity);
  statBlockContainer.append(cardRarity); // const cardOracle = document.createElement("li");
  // cardOracle.innerHTML = oracle_text;
  // statBlockContainer.append(cardOracle);

  Object(_card_util__WEBPACK_IMPORTED_MODULE_2__["oracleTextHandler"])(oracle_text, statBlockContainer); //<--- This is the new testing script ------

  if (flavor_text) {
    var cardFlavorText = document.createElement("li");
    cardFlavorText.innerHTML = flavor_text;
    statBlockContainer.append(cardFlavorText);
  }

  return statBlockContainer;
};

var setStatsCreator = function setStatsCreator(cardInfo, cardSet) {
  // console.log(cardSet);
  Object(_set_stats_util__WEBPACK_IMPORTED_MODULE_1__["typeTotals"])(cardSet).then(function (totalBreakdown) {
    // console.log(totalBreakdown);
    var typeChart = Highcharts.chart("set-pie-ph", {
      chart: {
        plotBackgroundColor: null,
        plotBorderWidth: null,
        plotShadow: false,
        type: 'pie'
      },
      title: {
        text: "Card Types (".concat(cardInfo.set_name, ")"),
        style: {
          "font-family": "$title-font",
          "font-size": "1rem"
        }
      },
      tooltip: {
        pointFormat: '{series.name}: {point.percentage:.1f}%',
        footerFormat: '\n ({point.y})'
      },
      accessibility: {
        point: {
          valueSuffix: '%'
        }
      },
      plotOptions: {
        pie: {
          allowPointSelect: true,
          cursor: 'pointer',
          dataLabels: {
            enabled: true,
            format: '{point.name}',
            style: {
              fontWeight: 400,
              fontFamily: "$body-font"
            }
          }
        }
      },
      series: [{
        name: 'Types',
        colorByPoint: true,
        data: Object.entries(totalBreakdown.types).sort(function (a, b) {
          return a[1] - b[1];
        }).reverse().map(function (pair) {
          return {
            name: pair[0],
            y: pair[1]
          };
        })
      }]
    });
    var valueChart = Highcharts.chart("set-bar-ph", {
      chart: {
        type: 'column'
      },
      title: {
        text: "Most Valued (".concat(cardInfo.set_name, ")"),
        style: {
          "font-family": "$title-font",
          "font-size": "1rem"
        }
      },
      xAxis: {
        categories: totalBreakdown.nonPromoTopTen.map(function (card) {
          return card.name;
        }),
        crosshair: true,
        labels: {
          enabled: false
        }
      },
      yAxis: {
        min: 0,
        title: {
          text: 'USD',
          enabled: false
        } // opposite: true

      },
      tooltip: {
        headerFormat: '<span style="font-size:10px">{point.key}</span><table>',
        pointFormat: '<tr><td style="color:{series.color};padding:0">{series.name}: </td>' + '<td style="padding:0"><b>${point.y:.1f}</b></td></tr>',
        footerFormat: '</table>',
        shared: true,
        useHTML: true
      },
      plotOptions: {
        column: {
          pointPadding: 0.2,
          borderWidth: 0
        }
      },
      series: [{
        name: 'Value',
        colorByPoint: true,
        data: totalBreakdown.nonPromoTopTen.map(function (card) {
          return parseFloat(card.prices.usd);
        }),
        showInLegend: false
      }]
    });
  });
};

var capitalize = function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

/* harmony default export */ __webpack_exports__["default"] = (cardGenerator);

/***/ }),

/***/ "./src/scripts/card_searcher.js":
/*!**************************************!*\
  !*** ./src/scripts/card_searcher.js ***!
  \**************************************/
/*! exports provided: card, cardSearcher, validSearchInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "card", function() { return card; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cardSearcher", function() { return cardSearcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validSearchInput", function() { return validSearchInput; });
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-polyfill */ "./node_modules/babel-polyfill/lib/index.js");
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_polyfill__WEBPACK_IMPORTED_MODULE_0__);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var card;

var cardSearcher = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e) {
    var inputStr, url, searchUrl, errorTarget, response, json, errorBanner, error, board;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            inputStr = document.getElementById("searchbar").value;
            url = 'https://api.scryfall.com/cards/named?fuzzy=';
            searchUrl = url + validSearchInput(inputStr);
            errorTarget = document.getElementById("errors-container");
            _context.next = 6;
            return fetch(searchUrl);

          case 6:
            response = _context.sent;
            _context.next = 9;
            return response.json();

          case 9:
            json = _context.sent;
            errorTarget.innerHTML = '';
            _context.next = 13;
            return json;

          case 13:
            card = _context.sent;

            if (!(card.object === "error")) {
              _context.next = 27;
              break;
            }

            //make error and append to board.input
            errorBanner = document.createElement('div');
            error = document.createElement('h2');
            board = document.getElementsByClassName("board")[0];
            board.style.margin = "5rem";
            errorBanner.setAttribute('id', "error-sub");
            error.setAttribute('id', 'error-message');
            error.innerHTML = card.details;
            errorBanner.append(error);
            errorTarget.append(errorBanner);
            return _context.abrupt("return");

          case 27:
            console.log(card);

          case 28:
            return _context.abrupt("return", card);

          case 29:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function cardSearcher(_x) {
    return _ref.apply(this, arguments);
  };
}();
var validSearchInput = function validSearchInput(searchInput) {
  return searchInput.split(' ').join("-");
};

/***/ }),

/***/ "./src/scripts/card_util.js":
/*!**********************************!*\
  !*** ./src/scripts/card_util.js ***!
  \**********************************/
/*! exports provided: manaImageGenerator, oracleTextHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "manaImageGenerator", function() { return manaImageGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "oracleTextHandler", function() { return oracleTextHandler; });
var manaImageGenerator = function manaImageGenerator(manaStr) {
  var results = document.createElement('div');
  results.classList.add("mana-symbol-container");
  if (!manaStr) return results;
  var subStr = '';

  for (var i = 0; i < manaStr.length; i++) {
    var letter = manaStr[i];

    if (letter === '{') {
      subStr = '';
    } else if (letter === '}') {
      var img = document.createElement("img");
      img.setAttribute("src", "https://img.scryfall.com/symbology/".concat(subStr, ".svg"));
      results.append(img);
    } else {
      subStr = subStr + letter;
    }
  }

  return results;
};
var oracleTextHandler = function oracleTextHandler(textStr, parentCon) {
  var collection = [];
  var subStr = ''; // console.log(textStr);

  var testArr = textStr.split("\n");
  console.log(testArr.length);

  for (var i = 0; i < textStr.length; i++) {
    var char = textStr[i]; // console.log(char);

    if (char === '↵') {
      collection.push(subStr); // console.log(subStr);

      subStr = '';
    } else {
      subStr += char;
    }
  }

  collection.push(subStr);
  collection.forEach(function (subStr) {
    var newListItem = document.createElement('li');
    newListItem.innerHTML = subStr;
    parentCon.append(newListItem);
  });
};

/***/ }),

/***/ "./src/scripts/set_fetcher.js":
/*!************************************!*\
  !*** ./src/scripts/set_fetcher.js ***!
  \************************************/
/*! exports provided: setFetcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setFetcher", function() { return setFetcher; });
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-polyfill */ "./node_modules/babel-polyfill/lib/index.js");
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_polyfill__WEBPACK_IMPORTED_MODULE_0__);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }


var setFetcher = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(cardInfo) {
    var searchUrl, response, json, nextUrl, nextResponse, nextJson, finalUrl, finalResponse, finalJson;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            searchUrl = "https://api.scryfall.com/cards/search?order=usd&q=e%3A".concat(cardInfo.set, "&unique=prints");
            _context.next = 3;
            return fetch(searchUrl);

          case 3:
            response = _context.sent;
            _context.next = 6;
            return response.json();

          case 6:
            json = _context.sent;

            if (!json.has_more) {
              _context.next = 29;
              break;
            }

            nextUrl = json.next_page;
            _context.next = 11;
            return fetch(nextUrl);

          case 11:
            nextResponse = _context.sent;
            _context.next = 14;
            return nextResponse.json();

          case 14:
            nextJson = _context.sent;

            if (!nextJson.has_more) {
              _context.next = 26;
              break;
            }

            finalUrl = nextJson.next_page;
            _context.next = 19;
            return fetch(finalUrl);

          case 19:
            finalResponse = _context.sent;
            _context.next = 22;
            return finalResponse.json();

          case 22:
            finalJson = _context.sent;
            return _context.abrupt("return", setMerge([json, nextJson, finalJson]));

          case 26:
            return _context.abrupt("return", setMerge([json, nextJson]));

          case 27:
            _context.next = 32;
            break;

          case 29:
            _context.next = 31;
            return json;

          case 31:
            return _context.abrupt("return", _context.sent);

          case 32:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function setFetcher(_x) {
    return _ref.apply(this, arguments);
  };
}();

var setMerge = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(arrOfSets) {
    var baseSet, i, mergingSet;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            baseSet = arrOfSets[0];

            for (i = 1; i < arrOfSets.length; i++) {
              mergingSet = arrOfSets[i];
              baseSet.data = baseSet.data.concat(mergingSet.data);
            }

            return _context2.abrupt("return", baseSet);

          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function setMerge(_x2) {
    return _ref2.apply(this, arguments);
  };
}();

/***/ }),

/***/ "./src/scripts/set_stats_util.js":
/*!***************************************!*\
  !*** ./src/scripts/set_stats_util.js ***!
  \***************************************/
/*! exports provided: typeTotals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typeTotals", function() { return typeTotals; });
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-polyfill */ "./node_modules/babel-polyfill/lib/index.js");
/* harmony import */ var babel_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(babel_polyfill__WEBPACK_IMPORTED_MODULE_0__);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }


var typeTotals = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(set) {
    var MTGCARDTYPES, cards, stats, i, card, currentCardTypes, cardValue;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            // return obj with all types as keys except basic lands
            MTGCARDTYPES = ['Artifact', 'Creature', 'Enchantment', 'Instant', 'Land', 'Planeswalker', 'Sorcery', 'Tribal'];
            cards = set.data;
            stats = {
              nonBasicsTotal: 0,
              totalSetValue: 0,
              nonPromoTopTen: [],
              totalSetValueAverage: 0,
              types: {},
              subTypes: {}
            };
            i = 0;

          case 4:
            if (!(i < cards.length)) {
              _context.next = 22;
              break;
            }

            card = cards[i];
            currentCardTypes = void 0; // REMOVE PROMO CARDS FROM THE POOL BECAUSE THEY'RE DUPES

            if (!card.promo) {
              _context.next = 9;
              break;
            }

            return _context.abrupt("continue", 19);

          case 9:
            currentCardTypes = typeLineParser(card.type_line); // <-- 

            if (!currentCardTypes.includes('Basic')) {
              _context.next = 14;
              break;
            }

            return _context.abrupt("continue", 19);

          case 14:
            cardValue = typeof card.prices.usd === "undefined" || card.prices.usd === null ? 0 : parseFloat(card.prices.usd);
            currentCardTypes.forEach(function (type) {
              if (MTGCARDTYPES.includes(type) && typeof stats.types[type] === 'undefined') {
                stats.types[type] = 1;
              } else if (MTGCARDTYPES.includes(type)) {
                stats.types[type] += 1;
              } else if (!MTGCARDTYPES.includes(type) && typeof stats.subTypes[type] === 'undefined') {
                stats.subTypes[type] = 1;
              } else {
                stats.subTypes[type] += 1;
              }
            });
            stats.nonBasicsTotal += 1;
            stats.totalSetValue += cardValue;

            if (stats.nonPromoTopTen.length < 10) {
              stats.nonPromoTopTen.push(card);
            }

          case 19:
            i++;
            _context.next = 4;
            break;

          case 22:
            stats.nonPromoTopTenValueAverage = cardAverager(stats.nonPromoTopTen);
            stats.totalSetValueAverage = stats.totalSetValue / stats.nonBasicsTotal;
            return _context.abrupt("return", stats);

          case 25:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function typeTotals(_x) {
    return _ref.apply(this, arguments);
  };
}();

var cardAverager = function cardAverager(cardArr) {
  var total = 0;
  cardArr.forEach(function (card) {
    return total += parseFloat(card.prices.usd);
  });
  return total / cardArr.length;
};

var typeLineParser = function typeLineParser(typeLineStr) {
  var typeArr = typeLineStr.split(' ');
  return typeArr.filter(function (type) {
    return type.length > 2;
  });
};

/***/ }),

/***/ "./src/styles/index.scss":
/*!*******************************!*\
  !*** ./src/styles/index.scss ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXBvbHlmaWxsL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcG9seWZpbGwvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1udW1iZXItdmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkdmFuY2Utc3RyaW5nLWluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1maWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19iaW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1pc28tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhdHRlbi1pbnRvLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mdW5jdGlvbi10by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1mcm91bmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1sb2cxcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLXNjYWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZm9yY2VkLXBhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX293bi1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWZsb2F0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wZXJmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb21pc2UtcmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy1hYnN0cmFjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZXBsYWNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1jb2xsZWN0aW9uLWZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC1zcGVjaWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaWN0LW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWh0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXBhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcmVwZWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy10cmltLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy13cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190YXNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VzZXItYWdlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdmFsaWRhdGUtY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmluZGV4LW9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmpvaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkub2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zbGljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb21lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLm5vdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1qc29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYWNvc2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmF0YW5oLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2JydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY29zaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5pbXVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2luaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRhbmguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lmhhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5leGVjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ibGluay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udGNvbG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3ViLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDMyLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstc2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmZsYXQtbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXNhcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLmZyb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLm9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguY2xhbXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5kZWctcGVyLXJhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmRlZ3JlZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5mc2NhbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pYWRkaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmltdWxoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaXN1YmguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5yYWQtcGVyLWRlZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnJhZGlhbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5zY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnNpZ25iaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC51bXVsaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLXNldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnByb21pc2UudHJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC5mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC5vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcuYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLXNldC5mcm9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstc2V0Lm9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudGltZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL3NoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpZ2hjaGFydHMvaGlnaGNoYXJ0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlnaGNoYXJ0cy9tb2R1bGVzL2V4cG9ydGluZy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9jYXJkX2dlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9jYXJkX3NlYXJjaGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2NhcmRfdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9zZXRfZmV0Y2hlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9zZXRfc3RhdHNfdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL2luZGV4LnNjc3M/YzgwNyJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiYm9hcmQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzZWFyY2hCYXIiLCJpbnB1dEZpZWxkIiwic3VibWl0QnV0dG9uIiwic2VhcmNoSWNvbiIsInRpdGxlQ29udGFpbmVyIiwidGl0bGUiLCJ0aXRsZUltZyIsIm5hdkNvbnRhaW5lciIsImdpdExpbmtJbWciLCJsaW5rZWRpbkxpbmtJbWciLCJhbmdlbExpbmtJbWciLCJnaXRMaW5rIiwibGlua2VkaW5MaW5rIiwiYW5nZWxMaW5rIiwiZXJyb3JzQ29udGFpbmVyIiwiaW5zdHJ1Y3Rpb25zQ29udGFpbmVyIiwiaW5zdHJ1Y3Rpb25zQnV0dG9uIiwiY2xhc3NMaXN0IiwiYWRkIiwiYXBwZW5kIiwic2V0QXR0cmlidXRlIiwiYm9keSIsImlubmVySFRNTCIsIm1vZGFsIiwiZ2V0RWxlbWVudEJ5SWQiLCJzcGFuIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsIm9uY2xpY2siLCJldmVudCIsInRhcmdldCIsInN0eWxlIiwiZGlzcGxheSIsImUiLCJwcmV2ZW50RGVmYXVsdCIsImNhcmRTZWFyY2hlciIsInRoZW4iLCJjYXJkIiwibmF2Q29uIiwicmVtb3ZlQ2hpbGQiLCJjYXJkR2VuZXJhdG9yIiwib2JqZWN0IiwibWFyZ2luIiwibWluSGVpZ2h0IiwiSGlnaGNoYXJ0cyIsInJlcXVpcmUiLCJjYXJkSW5mbyIsInByZXZDb250YWluZXIiLCJjYXJkQ29udGFpbmVyIiwic2V0U3RhdENvbnRhaW5lciIsImltZ0xpbmsiLCJpbWFnZV91cmlzIiwibm9ybWFsIiwic2V0QmFyQ2hhcnRQbGFjZWhvbGRlciIsInNldFBpZUNoYXJ0UGxhY2Vob2xkZXIiLCJwaWVMb2FkaW5nSWNvbiIsImJhckxvYWRpbmdJY29uIiwiaW1nQ3JlYXRvciIsInN0YXRCbG9ja0NyZWF0b3IiLCJzZXRGZXRjaGVyIiwiY2FyZFNldCIsInNldFN0YXRzQ3JlYXRvciIsImltZ0NvbnRhaW5lciIsImltZyIsIm5hbWUiLCJtYW5hX2Nvc3QiLCJyYXJpdHkiLCJvcmFjbGVfdGV4dCIsInNldF9uYW1lIiwidHlwZV9saW5lIiwiZmxhdm9yX3RleHQiLCJzdGF0QmxvY2tDb250YWluZXIiLCJjYXJkVGl0bGUiLCJjYXJkQ29zdCIsIm1hbmFJbWFnZUdlbmVyYXRvciIsImhyIiwiY2FyZFR5cGUiLCJjYXJkU2V0TmFtZSIsImNhcmRSYXJpdHkiLCJjYXBpdGFsaXplIiwib3JhY2xlVGV4dEhhbmRsZXIiLCJjYXJkRmxhdm9yVGV4dCIsInR5cGVUb3RhbHMiLCJ0b3RhbEJyZWFrZG93biIsInR5cGVDaGFydCIsImNoYXJ0IiwicGxvdEJhY2tncm91bmRDb2xvciIsInBsb3RCb3JkZXJXaWR0aCIsInBsb3RTaGFkb3ciLCJ0eXBlIiwidGV4dCIsInRvb2x0aXAiLCJwb2ludEZvcm1hdCIsImZvb3RlckZvcm1hdCIsImFjY2Vzc2liaWxpdHkiLCJwb2ludCIsInZhbHVlU3VmZml4IiwicGxvdE9wdGlvbnMiLCJwaWUiLCJhbGxvd1BvaW50U2VsZWN0IiwiY3Vyc29yIiwiZGF0YUxhYmVscyIsImVuYWJsZWQiLCJmb3JtYXQiLCJmb250V2VpZ2h0IiwiZm9udEZhbWlseSIsInNlcmllcyIsImNvbG9yQnlQb2ludCIsImRhdGEiLCJPYmplY3QiLCJlbnRyaWVzIiwidHlwZXMiLCJzb3J0IiwiYSIsImIiLCJyZXZlcnNlIiwibWFwIiwicGFpciIsInkiLCJ2YWx1ZUNoYXJ0IiwieEF4aXMiLCJjYXRlZ29yaWVzIiwibm9uUHJvbW9Ub3BUZW4iLCJjcm9zc2hhaXIiLCJsYWJlbHMiLCJ5QXhpcyIsIm1pbiIsImhlYWRlckZvcm1hdCIsInNoYXJlZCIsInVzZUhUTUwiLCJjb2x1bW4iLCJwb2ludFBhZGRpbmciLCJib3JkZXJXaWR0aCIsInBhcnNlRmxvYXQiLCJwcmljZXMiLCJ1c2QiLCJzaG93SW5MZWdlbmQiLCJzdHIiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiaW5wdXRTdHIiLCJ2YWx1ZSIsInVybCIsInNlYXJjaFVybCIsInZhbGlkU2VhcmNoSW5wdXQiLCJlcnJvclRhcmdldCIsImZldGNoIiwicmVzcG9uc2UiLCJqc29uIiwiZXJyb3JCYW5uZXIiLCJlcnJvciIsImRldGFpbHMiLCJjb25zb2xlIiwibG9nIiwic2VhcmNoSW5wdXQiLCJzcGxpdCIsImpvaW4iLCJtYW5hU3RyIiwicmVzdWx0cyIsInN1YlN0ciIsImkiLCJsZW5ndGgiLCJsZXR0ZXIiLCJ0ZXh0U3RyIiwicGFyZW50Q29uIiwiY29sbGVjdGlvbiIsInRlc3RBcnIiLCJjaGFyIiwicHVzaCIsImZvckVhY2giLCJuZXdMaXN0SXRlbSIsInNldCIsImhhc19tb3JlIiwibmV4dFVybCIsIm5leHRfcGFnZSIsIm5leHRSZXNwb25zZSIsIm5leHRKc29uIiwiZmluYWxVcmwiLCJmaW5hbFJlc3BvbnNlIiwiZmluYWxKc29uIiwic2V0TWVyZ2UiLCJhcnJPZlNldHMiLCJiYXNlU2V0IiwibWVyZ2luZ1NldCIsImNvbmNhdCIsIk1UR0NBUkRUWVBFUyIsImNhcmRzIiwic3RhdHMiLCJub25CYXNpY3NUb3RhbCIsInRvdGFsU2V0VmFsdWUiLCJ0b3RhbFNldFZhbHVlQXZlcmFnZSIsInN1YlR5cGVzIiwiY3VycmVudENhcmRUeXBlcyIsInByb21vIiwidHlwZUxpbmVQYXJzZXIiLCJpbmNsdWRlcyIsImNhcmRWYWx1ZSIsIm5vblByb21vVG9wVGVuVmFsdWVBdmVyYWdlIiwiY2FyZEF2ZXJhZ2VyIiwiY2FyZEFyciIsInRvdGFsIiwidHlwZUxpbmVTdHIiLCJ0eXBlQXJyIiwiZmlsdGVyIl0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZBLDhDQUFhOztBQUViLG1CQUFPLENBQUMsb0RBQWM7O0FBRXRCLG1CQUFPLENBQUMsOEdBQTZCOztBQUVyQyxtQkFBTyxDQUFDLDRFQUEwQjs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRTs7Ozs7Ozs7Ozs7O0FDM0JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDBDQUEwQztBQUMxQzs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QywyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBLEdBQUcsZ0NBQWdDLGtCQUFrQjtBQUNyRDs7O0FBR0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx5QkFBeUI7QUFDekIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Vzs7QUFFbkI7QUFDQTs7QUFFQSxRQUFRLFVBQVU7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFdBQVc7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSSxlQUFlLElBQUksZUFBZSxJQUFJO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQ0FBaUMsSUFBSSxlQUFlLElBQUksZUFBZSxJQUFJO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEVBQUU7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxXQUFXO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRSxxQ0FBcUMsT0FBTztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnREFBZ0QsS0FBSztBQUNyRCxPQUFPO0FBQ1A7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Q0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK1RBQStUO0FBQy9UOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixHQUFHOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtNQUFrTSx1UUFBdVE7QUFDemMsZ0dBQWdHO0FBQ2hHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFVBQVU7QUFDaEUsMENBQTBDLFlBQVksaUJBQWlCLFlBQVksTUFBTSxRQUFRO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCLG1DQUFtQyw4QkFBOEIsaUNBQWlDO0FBQ3pKO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxFQUFFLHVKQUF1SixpQ0FBaUMsc0JBQXNCO0FBQ3pOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQsT0FBTztBQUM5RCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRFQUE0RTtBQUN2RjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkJBQTJCLDBEQUEwRCwwREFBMEQ7QUFDOUssU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVHQUF1RztBQUN2RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3R0FBd0csc0JBQXNCLCtCQUErQixjQUFjO0FBQzNLOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0IsS0FBSywwQkFBMEI7QUFDM0UsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbURBQW1EO0FBQzVEO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxXQUFXOztBQUU1QztBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixLQUFLOztBQUUvQjs7QUFFQSwwQkFBMEIsS0FBSzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsS0FBSztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0Isb0JBQW9COztBQUUxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrSUFBa0ksT0FBTyx3SUFBd0k7QUFDN1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpREFBaUQsbUJBQW1CO0FBQ3BFLHFDQUFxQyw0QkFBNEI7QUFDakUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSwwQkFBMEIsS0FBSzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFD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O0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixPQUFPO0FBQzFCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixLQUFLOztBQUU3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULHVCQUF1QixRQUFROztBQUUvQjtBQUNBOztB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Q0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNElBQTRJLGVBQWUsRUFBRSxtVEFBbVQsNEJBQTRCO0FBQzVlO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7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Q0g7O0FBM0NhO0FBYVk0SCxhQUFDLEVBYmI7QUFBQTtBQUFBOztBQUFBO0FBK0N0QjJCLGlCQUFLLENBQUNVLDBCQUFOLEdBQW1DQyxZQUFZLENBQUNYLEtBQUssQ0FBQ2xFLGNBQVAsQ0FBL0M7QUFDQWtFLGlCQUFLLENBQUNHLG9CQUFOLEdBQTZCSCxLQUFLLENBQUNFLGFBQU4sR0FBc0JGLEtBQUssQ0FBQ0MsY0FBekQ7QUFoRHNCLDZDQWtEZkQsS0FsRGU7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FBSDs7QUFBQSxrQkFBVjFHLFVBQVU7QUFBQTtBQUFBO0FBQUEsR0FBaEI7O0FBcURQLElBQU1xSCxZQUFZLEdBQUcsU0FBZkEsWUFBZSxDQUFBQyxPQUFPLEVBQUk7QUFDNUIsTUFBSUMsS0FBSyxHQUFHLENBQVo7QUFDQUQsU0FBTyxDQUFDOUIsT0FBUixDQUFnQixVQUFBckksSUFBSTtBQUFBLFdBQUlvSyxLQUFLLElBQUlwRSxVQUFVLENBQUNoRyxJQUFJLENBQUNpRyxNQUFMLENBQVlDLEdBQWIsQ0FBdkI7QUFBQSxHQUFwQjtBQUNBLFNBQU9rRSxLQUFLLEdBQUdELE9BQU8sQ0FBQ3RDLE1BQXZCO0FBQ0gsQ0FKRDs7QUFNQSxJQUFNaUMsY0FBYyxHQUFHLFNBQWpCQSxjQUFpQixDQUFBTyxXQUFXLEVBQUk7QUFDbEMsTUFBTUMsT0FBTyxHQUFHRCxXQUFXLENBQUM5QyxLQUFaLENBQWtCLEdBQWxCLENBQWhCO0FBQ0EsU0FBTytDLE9BQU8sQ0FBQ0MsTUFBUixDQUFlLFVBQUFuSCxJQUFJO0FBQUEsV0FBSUEsSUFBSSxDQUFDeUUsTUFBTCxHQUFjLENBQWxCO0FBQUEsR0FBbkIsQ0FBUDtBQUNILENBSEQsQzs7Ozs7Ozs7Ozs7QUM3REEsdUMiLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL2Rpc3QvXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2luZGV4LmpzXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL3NoaW1cIik7XG5cbnJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWVcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL2ZuL3JlZ2V4cC9lc2NhcGVcIik7XG5cbmlmIChnbG9iYWwuX2JhYmVsUG9seWZpbGwpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwib25seSBvbmUgaW5zdGFuY2Ugb2YgYmFiZWwtcG9seWZpbGwgaXMgYWxsb3dlZFwiKTtcbn1cblxuZ2xvYmFsLl9iYWJlbFBvbHlmaWxsID0gdHJ1ZTtcbnZhciBERUZJTkVfUFJPUEVSVFkgPSBcImRlZmluZVByb3BlcnR5XCI7XG5cbmZ1bmN0aW9uIGRlZmluZShPLCBrZXksIHZhbHVlKSB7XG4gIE9ba2V5XSB8fCBPYmplY3RbREVGSU5FX1BST1BFUlRZXShPLCBrZXksIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xufVxuXG5kZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgXCJwYWRMZWZ0XCIsIFwiXCIucGFkU3RhcnQpO1xuZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIFwicGFkUmlnaHRcIiwgXCJcIi5wYWRFbmQpO1xuXCJwb3AscmV2ZXJzZSxzaGlmdCxrZXlzLHZhbHVlcyxlbnRyaWVzLGluZGV4T2YsZXZlcnksc29tZSxmb3JFYWNoLG1hcCxmaWx0ZXIsZmluZCxmaW5kSW5kZXgsaW5jbHVkZXMsam9pbixzbGljZSxjb25jYXQscHVzaCxzcGxpY2UsdW5zaGlmdCxzb3J0LGxhc3RJbmRleE9mLHJlZHVjZSxyZWR1Y2VSaWdodCxjb3B5V2l0aGluLGZpbGxcIi5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFtdW2tleV0gJiYgZGVmaW5lKEFycmF5LCBrZXksIEZ1bmN0aW9uLmNhbGwuYmluZChbXVtrZXldKSk7XG59KTsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuIWZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cblxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfSAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuXG5cbiAgICByZXR1cm47XG4gIH0gLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cblxuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pOyAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cblxuICBydW50aW1lLndyYXAgPSB3cmFwOyAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibm9ybWFsXCIsXG4gICAgICAgIGFyZzogZm4uY2FsbChvYmosIGFyZylcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInRocm93XCIsXG4gICAgICAgIGFyZzogZXJyXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjsgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTsgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge30gLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuXG5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuXG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9IEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiOyAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvciA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuXG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07IC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG5cblxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB7XG4gICAgICBfX2F3YWl0OiBhcmdcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZ2xvYmFsLnByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgZ2xvYmFsLnByb2Nlc3MuZG9tYWluKSB7XG4gICAgICBpbnZva2UgPSBnbG9iYWwucHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID0gLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9IC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG5cblxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuXG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7IC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpKTtcbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfSAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG5cblxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuXG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IEdlblN0YXRlQ29tcGxldGVkIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkOyAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cblxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0gLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuXG5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG5cbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTsgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jOyAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfSAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG5cblxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9IC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cblxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7IC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cblxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7XG4gICAgICB0cnlMb2M6IGxvY3NbMF1cbiAgICB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7XG4gICAgICB0cnlMb2M6IFwicm9vdFwiXG4gICAgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cblxuICAgIGtleXMucmV2ZXJzZSgpOyAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcblxuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG5cblxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG5cbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsXG4gICAgICAgICAgICBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9IC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cblxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGRvbmVSZXN1bHRcbiAgICB9O1xuICB9XG5cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGRvbmU6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIChza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDsgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcblxuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhIWNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFicnVwdDogZnVuY3Rpb24gKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiYgKHR5cGUgPT09IFwiYnJlYWtcIiB8fCB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHwgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG4gICAgZmluaXNoOiBmdW5jdGlvbiAoZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbiAodHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG5cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KCAvLyBBbW9uZyB0aGUgdmFyaW91cyB0cmlja3MgZm9yIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsXG4vLyBvYmplY3QsIHRoaXMgc2VlbXMgdG8gYmUgdGhlIG1vc3QgcmVsaWFibGUgdGVjaG5pcXVlIHRoYXQgZG9lcyBub3Rcbi8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG50eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXMpOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlJlZ0V4cC5lc2NhcGU7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59OyIsInZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIG1zZykge1xuICBpZiAodHlwZW9mIGl0ICE9ICdudW1iZXInICYmIGNvZihpdCkgIT0gJ051bWJlcicpIHRocm93IFR5cGVFcnJvcihtc2cpO1xuICByZXR1cm4gK2l0O1xufTsiLCIvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuL193a3MnKSgndW5zY29wYWJsZXMnKTtcblxudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSByZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpOyAvLyBgQWR2YW5jZVN0cmluZ0luZGV4YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFkdmFuY2VzdHJpbmdpbmRleFxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFMsIGluZGV4LCB1bmljb2RlKSB7XG4gIHJldHVybiBpbmRleCArICh1bmljb2RlID8gYXQoUywgaW5kZXgpLmxlbmd0aCA6IDEpO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9XG5cbiAgcmV0dXJuIGl0O1xufTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCIvLyAyMi4xLjMuMyBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0LCBlbmQgPSB0aGlzLmxlbmd0aClcbid1c2Ugc3RyaWN0JztcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBbXS5jb3B5V2l0aGluIHx8IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0XG4vKiA9IDAgKi9cbiwgc3RhcnRcbi8qID0gMCwgZW5kID0gQGxlbmd0aCAqL1xuKSB7XG4gIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gIHZhciBsZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciB0byA9IHRvQWJzb2x1dGVJbmRleCh0YXJnZXQsIGxlbik7XG4gIHZhciBmcm9tID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xuICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBjb3VudCA9IE1hdGgubWluKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbikpIC0gZnJvbSwgbGVuIC0gdG8pO1xuICB2YXIgaW5jID0gMTtcblxuICBpZiAoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KSB7XG4gICAgaW5jID0gLTE7XG4gICAgZnJvbSArPSBjb3VudCAtIDE7XG4gICAgdG8gKz0gY291bnQgLSAxO1xuICB9XG5cbiAgd2hpbGUgKGNvdW50LS0gPiAwKSB7XG4gICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO2Vsc2UgZGVsZXRlIE9bdG9dO1xuICAgIHRvICs9IGluYztcbiAgICBmcm9tICs9IGluYztcbiAgfVxuXG4gIHJldHVybiBPO1xufTsiLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbid1c2Ugc3RyaWN0JztcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaWxsKHZhbHVlXG4vKiAsIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqL1xuKSB7XG4gIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpO1xuICB2YXIgZW5kID0gYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCk7XG5cbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG5cbiAgcmV0dXJuIE87XG59OyIsInZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyLCBJVEVSQVRPUikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59OyIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTsgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcblxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcblxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTsgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07IiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xuXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG52YXIgYXNjID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVFlQRSwgJGNyZWF0ZSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHZhciBjcmVhdGUgPSAkY3JlYXRlIHx8IGFzYztcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSU9iamVjdChPKTtcbiAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbCwgcmVzO1xuXG4gICAgZm9yICg7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuXG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSByZXN1bHRbaW5kZXhdID0gcmVzOyAvLyBtYXBcbiAgICAgICAgZWxzZSBpZiAocmVzKSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAvLyBzb21lXG5cbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIC8vIGZpbmRcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICAvLyBmaW5kSW5kZXhcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWwpO1xuICAgICAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgICAgfSBlbHNlIGlmIChJU19FVkVSWSkgcmV0dXJuIGZhbHNlOyAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59OyIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIGNhbGxiYWNrZm4sIGFMZW4sIG1lbW8sIGlzUmlnaHQpIHtcbiAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xuICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBpbmRleCA9IGlzUmlnaHQgPyBsZW5ndGggLSAxIDogMDtcbiAgdmFyIGkgPSBpc1JpZ2h0ID8gLTEgOiAxO1xuICBpZiAoYUxlbiA8IDIpIGZvciAoOzspIHtcbiAgICBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGluZGV4ICs9IGk7XG5cbiAgICBpZiAoaXNSaWdodCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IGlzUmlnaHQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgc2VsZltpbmRleF0sIGluZGV4LCBPKTtcbiAgfVxuXG4gIHJldHVybiBtZW1vO1xufTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xuXG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gIHZhciBDO1xuXG4gIGlmIChpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjsgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcblxuICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNPYmplY3QoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07IiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwsIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG5cbnZhciBhcnJheVNsaWNlID0gW10uc2xpY2U7XG52YXIgZmFjdG9yaWVzID0ge307XG5cbnZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbiAoRiwgbGVuLCBhcmdzKSB7XG4gIGlmICghKGxlbiBpbiBmYWN0b3JpZXMpKSB7XG4gICAgZm9yICh2YXIgbiA9IFtdLCBpID0gMDsgaSA8IGxlbjsgaSsrKSBuW2ldID0gJ2FbJyArIGkgKyAnXSc7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuXG5cbiAgICBmYWN0b3JpZXNbbGVuXSA9IEZ1bmN0aW9uKCdGLGEnLCAncmV0dXJuIG5ldyBGKCcgKyBuLmpvaW4oJywnKSArICcpJyk7XG4gIH1cblxuICByZXR1cm4gZmFjdG9yaWVzW2xlbl0oRiwgYXJncyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmJpbmQgfHwgZnVuY3Rpb24gYmluZCh0aGF0XG4vKiAsIC4uLmFyZ3MgKi9cbikge1xuICB2YXIgZm4gPSBhRnVuY3Rpb24odGhpcyk7XG4gIHZhciBwYXJ0QXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uICgpXG4gIC8qIGFyZ3MuLi4gKi9cbiAge1xuICAgIHZhciBhcmdzID0gcGFydEFyZ3MuY29uY2F0KGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gY29uc3RydWN0KGZuLCBhcmdzLmxlbmd0aCwgYXJncykgOiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xuXG4gIGlmIChpc09iamVjdChmbi5wcm90b3R5cGUpKSBib3VuZC5wcm90b3R5cGUgPSBmbi5wcm90b3R5cGU7XG4gIHJldHVybiBib3VuZDtcbn07IiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcblxudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpOyAvLyBFUzMgd3JvbmcgaGVyZVxuXG5cbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gYXJndW1lbnRzO1xufSgpKSA9PSAnQXJndW1lbnRzJzsgLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcblxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICA6IEFSRyA/IGNvZihPKSAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTsiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xuXG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xuXG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcblxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xuXG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG5cbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG52YXIgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpO1xuXG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xuXG52YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJyk7XG5cbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG5cbnZhciBmYXN0S2V5ID0gcmVxdWlyZSgnLi9fbWV0YScpLmZhc3RLZXk7XG5cbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcblxudmFyIFNJWkUgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uICh0aGF0LCBrZXkpIHtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KTtcbiAgdmFyIGVudHJ5O1xuICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHRoYXQuX2lbaW5kZXhdOyAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcblxuICBmb3IgKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgIGlmIChlbnRyeS5rID09IGtleSkgcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAvLyBjb2xsZWN0aW9uIHR5cGVcblxuICAgICAgdGhhdC5faSA9IGNyZWF0ZShudWxsKTsgLy8gaW5kZXhcblxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgLy8gZmlyc3QgZW50cnlcblxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgLy8gbGFzdCBlbnRyeVxuXG4gICAgICB0aGF0W1NJWkVdID0gMDsgLy8gc2l6ZVxuXG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIGZvciAodmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKSwgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChlbnRyeS5wKSBlbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcblxuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm47XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmICh0aGF0Ll9mID09IGVudHJ5KSB0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZiAodGhhdC5fbCA9PSBlbnRyeSkgdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmblxuICAgICAgLyogLCB0aGF0ID0gdW5kZWZpbmVkICovXG4gICAgICApIHtcbiAgICAgICAgdmFsaWRhdGUodGhpcywgTkFNRSk7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKTtcbiAgICAgICAgdmFyIGVudHJ5O1xuXG4gICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2YpIHtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpOyAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcblxuICAgICAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSwga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUodGhpcywgTkFNRSlbU0laRV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgIHZhciBwcmV2LCBpbmRleDsgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG5cbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTsgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9sID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLFxuICAgICAgICAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksXG4gICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsXG4gICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCxcbiAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAvLyA8LSByZW1vdmVkXG5cbiAgICAgIH07XG4gICAgICBpZiAoIXRoYXQuX2YpIHRoYXQuX2YgPSBlbnRyeTtcbiAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKzsgLy8gYWRkIHRvIGluZGV4XG5cbiAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSB0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24gKEMsIE5BTUUsIElTX01BUCkge1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgICAgIHRoaXMuX3QgPSB2YWxpZGF0ZShpdGVyYXRlZCwgTkFNRSk7IC8vIHRhcmdldFxuXG4gICAgICB0aGlzLl9rID0ga2luZDsgLy8ga2luZFxuXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBraW5kID0gdGhhdC5faztcbiAgICAgIHZhciBlbnRyeSA9IHRoYXQuX2w7IC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuXG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wOyAvLyBnZXQgbmV4dCBlbnRyeVxuXG5cbiAgICAgIGlmICghdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKSB7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfSAvLyByZXR1cm4gc3RlcCBieSBraW5kXG5cblxuICAgICAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycsICFJU19NQVAsIHRydWUpOyAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcbiAgfVxufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcblxudmFyIGZyb20gPSByZXF1aXJlKCcuL19hcnJheS1mcm9tLWl0ZXJhYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICBpZiAoY2xhc3NvZih0aGlzKSAhPSBOQU1FKSB0aHJvdyBUeXBlRXJyb3IoTkFNRSArIFwiI3RvSlNPTiBpc24ndCBnZW5lcmljXCIpO1xuICAgIHJldHVybiBmcm9tKHRoaXMpO1xuICB9O1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xuXG52YXIgZ2V0V2VhayA9IHJlcXVpcmUoJy4vX21ldGEnKS5nZXRXZWFrO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcblxudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbnZhciBjcmVhdGVBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKTtcblxudmFyICRoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcblxudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xuXG52YXIgYXJyYXlGaW5kID0gY3JlYXRlQXJyYXlNZXRob2QoNSk7XG52YXIgYXJyYXlGaW5kSW5kZXggPSBjcmVhdGVBcnJheU1ldGhvZCg2KTtcbnZhciBpZCA9IDA7IC8vIGZhbGxiYWNrIGZvciB1bmNhdWdodCBmcm96ZW4ga2V5c1xuXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gIHJldHVybiB0aGF0Ll9sIHx8ICh0aGF0Ll9sID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG59O1xuXG52YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hID0gW107XG59O1xuXG52YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24gKHN0b3JlLCBrZXkpIHtcbiAgcmV0dXJuIGFycmF5RmluZChzdG9yZS5hLCBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59O1xuXG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO2Vsc2UgdGhpcy5hLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gICAgfSk7XG4gICAgaWYgKH5pbmRleCkgdGhpcy5hLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgLy8gY29sbGVjdGlvbiB0eXBlXG5cbiAgICAgIHRoYXQuX2kgPSBpZCsrOyAvLyBjb2xsZWN0aW9uIGlkXG5cbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7IC8vIGxlYWsgc3RvcmUgZm9yIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RzXG5cbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKSAmJiBkZWxldGUgZGF0YVt0aGlzLl9pXTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gZ2V0V2Vhayhhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7ZWxzZSBkYXRhW3RoYXQuX2ldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIHVmc3RvcmU6IHVuY2F1Z2h0RnJvemVuU3RvcmVcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5cbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xuXG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKTtcblxudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbnZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG5cbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG5cbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspIHtcbiAgdmFyIEJhc2UgPSBnbG9iYWxbTkFNRV07XG4gIHZhciBDID0gQmFzZTtcbiAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgdmFyIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZTtcbiAgdmFyIE8gPSB7fTtcblxuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24gKEtFWSkge1xuICAgIHZhciBmbiA9IHByb3RvW0tFWV07XG4gICAgcmVkZWZpbmUocHJvdG8sIEtFWSwgS0VZID09ICdkZWxldGUnID8gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgIH0gOiBLRVkgPT0gJ2hhcycgPyBmdW5jdGlvbiBoYXMoYSkge1xuICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKSB7XG4gICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyB1bmRlZmluZWQgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgfSA6IEtFWSA9PSAnYWRkJyA/IGZ1bmN0aW9uIGFkZChhKSB7XG4gICAgICBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IDogZnVuY3Rpb24gc2V0KGEsIGIpIHtcbiAgICAgIGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9O1xuXG4gIGlmICh0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IEMoKTsgLy8gZWFybHkgaW1wbGVtZW50YXRpb25zIG5vdCBzdXBwb3J0cyBjaGFpbmluZ1xuXG4gICAgdmFyIEhBU05UX0NIQUlOSU5HID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZTsgLy8gVjggfiAgQ2hyb21pdW0gNDAtIHdlYWstY29sbGVjdGlvbnMgdGhyb3dzIG9uIHByaW1pdGl2ZXMsIGJ1dCBzaG91bGQgcmV0dXJuIGZhbHNlXG5cbiAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBpbnN0YW5jZS5oYXMoMSk7XG4gICAgfSk7IC8vIG1vc3QgZWFybHkgaW1wbGVtZW50YXRpb25zIGRvZXNuJ3Qgc3VwcG9ydHMgaXRlcmFibGVzLCBtb3N0IG1vZGVybiAtIG5vdCBjbG9zZSBpdCBjb3JyZWN0bHlcblxuICAgIHZhciBBQ0NFUFRfSVRFUkFCTEVTID0gJGl0ZXJEZXRlY3QoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgICAgIG5ldyBDKGl0ZXIpO1xuICAgIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuXG4gICAgdmFyIEJVR0dZX1pFUk8gPSAhSVNfV0VBSyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBWOCB+IENocm9taXVtIDQyLSBmYWlscyBvbmx5IHdpdGggNSsgZWxlbWVudHNcbiAgICAgIHZhciAkaW5zdGFuY2UgPSBuZXcgQygpO1xuICAgICAgdmFyIGluZGV4ID0gNTtcblxuICAgICAgd2hpbGUgKGluZGV4LS0pICRpbnN0YW5jZVtBRERFUl0oaW5kZXgsIGluZGV4KTtcblxuICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICB9KTtcblxuICAgIGlmICghQUNDRVBUX0lURVJBQkxFUykge1xuICAgICAgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRhcmdldCwgaXRlcmFibGUpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUpO1xuICAgICAgICB2YXIgdGhhdCA9IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlKCksIHRhcmdldCwgQyk7XG4gICAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICB9KTtcbiAgICAgIEMucHJvdG90eXBlID0gcHJvdG87XG4gICAgICBwcm90by5jb25zdHJ1Y3RvciA9IEM7XG4gICAgfVxuXG4gICAgaWYgKFRIUk9XU19PTl9QUklNSVRJVkVTIHx8IEJVR0dZX1pFUk8pIHtcbiAgICAgIGZpeE1ldGhvZCgnZGVsZXRlJyk7XG4gICAgICBmaXhNZXRob2QoJ2hhcycpO1xuICAgICAgSVNfTUFQICYmIGZpeE1ldGhvZCgnZ2V0Jyk7XG4gICAgfVxuXG4gICAgaWYgKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpIGZpeE1ldGhvZChBRERFUik7IC8vIHdlYWsgY29sbGVjdGlvbnMgc2hvdWxkIG5vdCBjb250YWlucyAuY2xlYXIgbWV0aG9kXG5cbiAgICBpZiAoSVNfV0VBSyAmJiBwcm90by5jbGVhcikgZGVsZXRlIHByb3RvLmNsZWFyO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChDICE9IEJhc2UpLCBPKTtcbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG4gIHJldHVybiBDO1xufTsiLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICB2ZXJzaW9uOiAnMi42LjExJ1xufTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGluZGV4LCB2YWx1ZSkge1xuICBpZiAoaW5kZXggaW4gb2JqZWN0KSAkZGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGluZGV4LCBjcmVhdGVEZXNjKDAsIHZhbHVlKSk7ZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59OyIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG5cbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgICB9O1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgICAgfTtcblxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKClcbiAgLyogLi4uYXJncyAqL1xuICB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JzsgLy8gMjAuMy40LjM2IC8gMTUuOS41LjQzIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKClcblxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxudmFyIGdldFRpbWUgPSBEYXRlLnByb3RvdHlwZS5nZXRUaW1lO1xudmFyICR0b0lTT1N0cmluZyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nO1xuXG52YXIgbHogPSBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiBudW0gPiA5ID8gbnVtIDogJzAnICsgbnVtO1xufTsgLy8gUGhhbnRvbUpTIC8gb2xkIFdlYktpdCBoYXMgYSBicm9rZW4gaW1wbGVtZW50YXRpb25zXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAkdG9JU09TdHJpbmcuY2FsbChuZXcgRGF0ZSgtNWUxMyAtIDEpKSAhPSAnMDM4NS0wNy0yNVQwNzowNjozOS45OTlaJztcbn0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICR0b0lTT1N0cmluZy5jYWxsKG5ldyBEYXRlKE5hTikpO1xufSkgPyBmdW5jdGlvbiB0b0lTT1N0cmluZygpIHtcbiAgaWYgKCFpc0Zpbml0ZShnZXRUaW1lLmNhbGwodGhpcykpKSB0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIHRpbWUgdmFsdWUnKTtcbiAgdmFyIGQgPSB0aGlzO1xuICB2YXIgeSA9IGQuZ2V0VVRDRnVsbFllYXIoKTtcbiAgdmFyIG0gPSBkLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICB2YXIgcyA9IHkgPCAwID8gJy0nIDogeSA+IDk5OTkgPyAnKycgOiAnJztcbiAgcmV0dXJuIHMgKyAoJzAwMDAwJyArIE1hdGguYWJzKHkpKS5zbGljZShzID8gLTYgOiAtNCkgKyAnLScgKyBseihkLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArIGx6KGQuZ2V0VVRDRGF0ZSgpKSArICdUJyArIGx6KGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBseihkLmdldFVUQ01pbnV0ZXMoKSkgKyAnOicgKyBseihkLmdldFVUQ1NlY29uZHMoKSkgKyAnLicgKyAobSA+IDk5ID8gbSA6ICcwJyArIGx6KG0pKSArICdaJztcbn0gOiAkdG9JU09TdHJpbmc7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbnZhciBOVU1CRVIgPSAnbnVtYmVyJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaGludCkge1xuICBpZiAoaGludCAhPT0gJ3N0cmluZycgJiYgaGludCAhPT0gTlVNQkVSICYmIGhpbnQgIT09ICdkZWZhdWx0JykgdGhyb3cgVHlwZUVycm9yKCdJbmNvcnJlY3QgaGludCcpO1xuICByZXR1cm4gdG9QcmltaXRpdmUoYW5PYmplY3QodGhpcyksIGhpbnQgIT0gTlVNQkVSKTtcbn07IiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTsiLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gNztcbiAgICB9XG4gIH0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDsgLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG5cblxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTsiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9ICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnLnNwbGl0KCcsJyk7IiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xuXG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gZ2V0S2V5cyhpdCk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuXG4gIGlmIChnZXRTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KTtcbiAgICB2YXIgaXNFbnVtID0gcElFLmY7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXk7XG5cbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xuXG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcblxudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcblxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xuXG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gfHwgKGdsb2JhbFtuYW1lXSA9IHt9KSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pO1xuICB2YXIga2V5LCBvd24sIG91dCwgZXhwO1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuXG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7IC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG5cbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldOyAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuXG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7IC8vIGV4dGVuZCBnbG9iYWxcblxuICAgIGlmICh0YXJnZXQpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpOyAvLyBleHBvcnRcblxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5cbmdsb2JhbC5jb3JlID0gY29yZTsgLy8gdHlwZSBiaXRtYXBcblxuJGV4cG9ydC5GID0gMTsgLy8gZm9yY2VkXG5cbiRleHBvcnQuRyA9IDI7IC8vIGdsb2JhbFxuXG4kZXhwb3J0LlMgPSA0OyAvLyBzdGF0aWNcblxuJGV4cG9ydC5QID0gODsgLy8gcHJvdG9cblxuJGV4cG9ydC5CID0gMTY7IC8vIGJpbmRcblxuJGV4cG9ydC5XID0gMzI7IC8vIHdyYXBcblxuJGV4cG9ydC5VID0gNjQ7IC8vIHNhZmVcblxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5cbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDsiLCJ2YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciByZSA9IC8uLztcblxuICB0cnkge1xuICAgICcvLi8nW0tFWV0ocmUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlW01BVENIXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuICEnLy4vJ1tLRVldKHJlKTtcbiAgICB9IGNhdGNoIChmKSB7XG4gICAgICAvKiBlbXB0eSAqL1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL2VzNi5yZWdleHAuZXhlYycpO1xuXG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xuXG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcblxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcblxudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYycpO1xuXG52YXIgU1BFQ0lFUyA9IHdrcygnc3BlY2llcycpO1xudmFyIFJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gI3JlcGxhY2UgbmVlZHMgYnVpbHQtaW4gc3VwcG9ydCBmb3IgbmFtZWQgZ3JvdXBzLlxuICAvLyAjbWF0Y2ggd29ya3MgZmluZSBiZWNhdXNlIGl0IGp1c3QgcmV0dXJuIHRoZSBleGVjIHJlc3VsdHMsIGV2ZW4gaWYgaXQgaGFzXG4gIC8vIGEgXCJncm9wc1wiIHByb3BlcnR5LlxuICB2YXIgcmUgPSAvLi87XG5cbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0Lmdyb3VwcyA9IHtcbiAgICAgIGE6ICc3J1xuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gJycucmVwbGFjZShyZSwgJyQ8YT4nKSAhPT0gJzcnO1xufSk7XG5cbnZhciBTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIENocm9tZSA1MSBoYXMgYSBidWdneSBcInNwbGl0XCIgaW1wbGVtZW50YXRpb24gd2hlbiBSZWdFeHAjZXhlYyAhPT0gbmF0aXZlRXhlY1xuICB2YXIgcmUgPSAvKD86KS87XG4gIHZhciBvcmlnaW5hbEV4ZWMgPSByZS5leGVjO1xuXG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG9yaWdpbmFsRXhlYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciByZXN1bHQgPSAnYWInLnNwbGl0KHJlKTtcbiAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDIgJiYgcmVzdWx0WzBdID09PSAnYScgJiYgcmVzdWx0WzFdID09PSAnYic7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgbGVuZ3RoLCBleGVjKSB7XG4gIHZhciBTWU1CT0wgPSB3a3MoS0VZKTtcbiAgdmFyIERFTEVHQVRFU19UT19TWU1CT0wgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN0cmluZyBtZXRob2RzIGNhbGwgc3ltYm9sLW5hbWVkIFJlZ0VwIG1ldGhvZHNcbiAgICB2YXIgTyA9IHt9O1xuXG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIDc7XG4gICAgfTtcblxuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pO1xuICB2YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBERUxFR0FURVNfVE9fU1lNQk9MID8gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTeW1ib2wtbmFtZWQgUmVnRXhwIG1ldGhvZHMgY2FsbCAuZXhlY1xuICAgIHZhciBleGVjQ2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHJlID0gL2EvO1xuXG4gICAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGV4ZWNDYWxsZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIGlmIChLRVkgPT09ICdzcGxpdCcpIHtcbiAgICAgIC8vIFJlZ0V4cFtAQHNwbGl0XSBkb2Vzbid0IGNhbGwgdGhlIHJlZ2V4J3MgZXhlYyBtZXRob2QsIGJ1dCBmaXJzdCBjcmVhdGVzXG4gICAgICAvLyBhIG5ldyBvbmUuIFdlIG5lZWQgdG8gcmV0dXJuIHRoZSBwYXRjaGVkIHJlZ2V4IHdoZW4gY3JlYXRpbmcgdGhlIG5ldyBvbmUuXG4gICAgICByZS5jb25zdHJ1Y3RvciA9IHt9O1xuXG4gICAgICByZS5jb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZVtTWU1CT0xdKCcnKTtcbiAgICByZXR1cm4gIWV4ZWNDYWxsZWQ7XG4gIH0pIDogdW5kZWZpbmVkO1xuXG4gIGlmICghREVMRUdBVEVTX1RPX1NZTUJPTCB8fCAhREVMRUdBVEVTX1RPX0VYRUMgfHwgS0VZID09PSAncmVwbGFjZScgJiYgIVJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTIHx8IEtFWSA9PT0gJ3NwbGl0JyAmJiAhU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDKSB7XG4gICAgdmFyIG5hdGl2ZVJlZ0V4cE1ldGhvZCA9IC8uL1tTWU1CT0xdO1xuICAgIHZhciBmbnMgPSBleGVjKGRlZmluZWQsIFNZTUJPTCwgJydbS0VZXSwgZnVuY3Rpb24gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZU1ldGhvZCwgcmVnZXhwLCBzdHIsIGFyZzIsIGZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICBpZiAocmVnZXhwLmV4ZWMgPT09IHJlZ2V4cEV4ZWMpIHtcbiAgICAgICAgaWYgKERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgICAgLy8gVGhlIG5hdGl2ZSBTdHJpbmcgbWV0aG9kIGFscmVhZHkgZGVsZWdhdGVzIHRvIEBAbWV0aG9kICh0aGlzXG4gICAgICAgICAgLy8gcG9seWZpbGxlZCBmdW5jdGlvbiksIGxlYXNpbmcgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgICAgICAgIC8vIFdlIGF2b2lkIGl0IGJ5IGRpcmVjdGx5IGNhbGxpbmcgdGhlIG5hdGl2ZSBAQG1ldGhvZCBtZXRob2QuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmF0aXZlUmVnRXhwTWV0aG9kLmNhbGwocmVnZXhwLCBzdHIsIGFyZzIpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogbmF0aXZlTWV0aG9kLmNhbGwoc3RyLCByZWdleHAsIGFyZzIpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHZhciBzdHJmbiA9IGZuc1swXTtcbiAgICB2YXIgcnhmbiA9IGZuc1sxXTtcbiAgICByZWRlZmluZShTdHJpbmcucHJvdG90eXBlLCBLRVksIHN0cmZuKTtcbiAgICBoaWRlKFJlZ0V4cC5wcm90b3R5cGUsIFNZTUJPTCwgbGVuZ3RoID09IDIgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgIC8vIDIxLjIuNS4xMSBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdKHN0cmluZywgbGltaXQpXG4gICAgPyBmdW5jdGlvbiAoc3RyaW5nLCBhcmcpIHtcbiAgICAgIHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzLCBhcmcpO1xuICAgIH0gLy8gMjEuMi41LjYgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXShzdHJpbmcpXG4gICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKVxuICAgIDogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMpO1xuICAgIH0pO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0JzsgLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59OyIsIid1c2Ugc3RyaWN0JzsgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1mbGF0TWFwLyNzZWMtRmxhdHRlbkludG9BcnJheVxuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xuXG52YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEUgPSByZXF1aXJlKCcuL193a3MnKSgnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG5cbmZ1bmN0aW9uIGZsYXR0ZW5JbnRvQXJyYXkodGFyZ2V0LCBvcmlnaW5hbCwgc291cmNlLCBzb3VyY2VMZW4sIHN0YXJ0LCBkZXB0aCwgbWFwcGVyLCB0aGlzQXJnKSB7XG4gIHZhciB0YXJnZXRJbmRleCA9IHN0YXJ0O1xuICB2YXIgc291cmNlSW5kZXggPSAwO1xuICB2YXIgbWFwRm4gPSBtYXBwZXIgPyBjdHgobWFwcGVyLCB0aGlzQXJnLCAzKSA6IGZhbHNlO1xuICB2YXIgZWxlbWVudCwgc3ByZWFkYWJsZTtcblxuICB3aGlsZSAoc291cmNlSW5kZXggPCBzb3VyY2VMZW4pIHtcbiAgICBpZiAoc291cmNlSW5kZXggaW4gc291cmNlKSB7XG4gICAgICBlbGVtZW50ID0gbWFwRm4gPyBtYXBGbihzb3VyY2Vbc291cmNlSW5kZXhdLCBzb3VyY2VJbmRleCwgb3JpZ2luYWwpIDogc291cmNlW3NvdXJjZUluZGV4XTtcbiAgICAgIHNwcmVhZGFibGUgPSBmYWxzZTtcblxuICAgICAgaWYgKGlzT2JqZWN0KGVsZW1lbnQpKSB7XG4gICAgICAgIHNwcmVhZGFibGUgPSBlbGVtZW50W0lTX0NPTkNBVF9TUFJFQURBQkxFXTtcbiAgICAgICAgc3ByZWFkYWJsZSA9IHNwcmVhZGFibGUgIT09IHVuZGVmaW5lZCA/ICEhc3ByZWFkYWJsZSA6IGlzQXJyYXkoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcHJlYWRhYmxlICYmIGRlcHRoID4gMCkge1xuICAgICAgICB0YXJnZXRJbmRleCA9IGZsYXR0ZW5JbnRvQXJyYXkodGFyZ2V0LCBvcmlnaW5hbCwgZWxlbWVudCwgdG9MZW5ndGgoZWxlbWVudC5sZW5ndGgpLCB0YXJnZXRJbmRleCwgZGVwdGggLSAxKSAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGFyZ2V0SW5kZXggPj0gMHgxZmZmZmZmZmZmZmZmZikgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgIHRhcmdldFt0YXJnZXRJbmRleF0gPSBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICB0YXJnZXRJbmRleCsrO1xuICAgIH1cblxuICAgIHNvdXJjZUluZGV4Kys7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0SW5kZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbkludG9BcnJheTsiLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG5cbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG5cbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcblxudmFyIEJSRUFLID0ge307XG52YXIgUkVUVVJOID0ge307XG5cbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGl0ZXJhYmxlO1xuICB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKTtcbiAgdmFyIGYgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpOyAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcblxuICBpZiAoaXNBcnJheUl0ZXIoaXRlckZuKSkgZm9yIChsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTspIHtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnbmF0aXZlLWZ1bmN0aW9uLXRvLXN0cmluZycsIEZ1bmN0aW9uLnRvU3RyaW5nKTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTsiLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59OyIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsiLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiA3O1xuICAgIH1cbiAgfSkuYSAhPSA3O1xufSk7IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgdGFyZ2V0LCBDKSB7XG4gIHZhciBTID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICB2YXIgUDtcblxuICBpZiAoUyAhPT0gQyAmJiB0eXBlb2YgUyA9PSAnZnVuY3Rpb24nICYmIChQID0gUy5wcm90b3R5cGUpICE9PSBDLnByb3RvdHlwZSAmJiBpc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZikge1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9XG5cbiAgcmV0dXJuIHRoYXQ7XG59OyIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuXG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gdW4gPyBmbigpIDogZm4uY2FsbCh0aGF0KTtcblxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiB1biA/IGZuKGFyZ3NbMF0pIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcblxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcblxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcblxuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfVxuXG4gIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07IiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTsiLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5cbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xuXG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07IiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTsiLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzSW50ZWdlcihpdCkge1xuICByZXR1cm4gIWlzT2JqZWN0KGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IoaXQpID09PSBpdDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07IiwiLy8gNy4yLjggSXNSZWdFeHAoYXJndW1lbnQpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuXG52YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59OyIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTsgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xuXG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcblxudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307IC8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5cbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7XG4gICAgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KVxuICB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5cbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xuXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5cbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG5cbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG5cbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG5cbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuXG52YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcblxuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTtcblxuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpO1xuICAgICAgICB9O1xuXG4gICAgICBjYXNlIFZBTFVFUzpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7IC8vIEZpeCBuYXRpdmVcblxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcblxuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTsgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG5cbiAgICAgIGlmICghTElCUkFSWSAmJiB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH0gLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuXG5cbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuXG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gIH0gLy8gRGVmaW5lIGl0ZXJhdG9yXG5cblxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9IC8vIFBsdWcgZm9yIGxpYnJhcnlcblxuXG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7XG5cbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuXG4gIHJldHVybiBtZXRob2RzO1xufTsiLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcblxudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG5cbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24gKCkge1xuICAgIFNBRkVfQ0xPU0lORyA9IHRydWU7XG4gIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG5cblxuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgMjtcbiAgfSk7XG59IGNhdGNoIChlKSB7XG4gIC8qIGVtcHR5ICovXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIHNraXBDbG9zaW5nKSB7XG4gIGlmICghc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcblxuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IHNhZmUgPSB0cnVlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGl0ZXI7XG4gICAgfTtcblxuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cblxuICByZXR1cm4gc2FmZTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZG9uZTogISFkb25lXG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0ge307IiwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTsiLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBtMSA9IE1hdGguZXhwbTE7XG5tb2R1bGUuZXhwb3J0cyA9ICEkZXhwbTEgLy8gT2xkIEZGIGJ1Z1xufHwgJGV4cG0xKDEwKSA+IDIyMDI1LjQ2NTc5NDgwNjcxOSB8fCAkZXhwbTEoMTApIDwgMjIwMjUuNDY1Nzk0ODA2NzE2NTE2OCAvLyBUb3IgQnJvd3NlciBidWdcbnx8ICRleHBtMSgtMmUtMTcpICE9IC0yZS0xNyA/IGZ1bmN0aW9uIGV4cG0xKHgpIHtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogeCA+IC0xZS02ICYmIHggPCAxZS02ID8geCArIHggKiB4IC8gMiA6IE1hdGguZXhwKHgpIC0gMTtcbn0gOiAkZXhwbTE7IiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xuXG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgRVBTSUxPTiA9IHBvdygyLCAtNTIpO1xudmFyIEVQU0lMT04zMiA9IHBvdygyLCAtMjMpO1xudmFyIE1BWDMyID0gcG93KDIsIDEyNykgKiAoMiAtIEVQU0lMT04zMik7XG52YXIgTUlOMzIgPSBwb3coMiwgLTEyNik7XG5cbnZhciByb3VuZFRpZXNUb0V2ZW4gPSBmdW5jdGlvbiAobikge1xuICByZXR1cm4gbiArIDEgLyBFUFNJTE9OIC0gMSAvIEVQU0lMT047XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguZnJvdW5kIHx8IGZ1bmN0aW9uIGZyb3VuZCh4KSB7XG4gIHZhciAkYWJzID0gTWF0aC5hYnMoeCk7XG4gIHZhciAkc2lnbiA9IHNpZ24oeCk7XG4gIHZhciBhLCByZXN1bHQ7XG4gIGlmICgkYWJzIDwgTUlOMzIpIHJldHVybiAkc2lnbiAqIHJvdW5kVGllc1RvRXZlbigkYWJzIC8gTUlOMzIgLyBFUFNJTE9OMzIpICogTUlOMzIgKiBFUFNJTE9OMzI7XG4gIGEgPSAoMSArIEVQU0lMT04zMiAvIEVQU0lMT04pICogJGFicztcbiAgcmVzdWx0ID0gYSAtIChhIC0gJGFicyk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcblxuICBpZiAocmVzdWx0ID4gTUFYMzIgfHwgcmVzdWx0ICE9IHJlc3VsdCkgcmV0dXJuICRzaWduICogSW5maW5pdHk7XG4gIHJldHVybiAkc2lnbiAqIHJlc3VsdDtcbn07IiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5sb2cxcCB8fCBmdW5jdGlvbiBsb2cxcCh4KSB7XG4gIHJldHVybiAoeCA9ICt4KSA+IC0xZS04ICYmIHggPCAxZS04ID8geCAtIHggKiB4IC8gMiA6IE1hdGgubG9nKDEgKyB4KTtcbn07IiwiLy8gaHR0cHM6Ly9yd2FsZHJvbi5naXRodWIuaW8vcHJvcG9zYWwtbWF0aC1leHRlbnNpb25zL1xubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNjYWxlIHx8IGZ1bmN0aW9uIHNjYWxlKHgsIGluTG93LCBpbkhpZ2gsIG91dExvdywgb3V0SGlnaCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHx8IHggIT0geCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHx8IGluTG93ICE9IGluTG93IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgfHwgaW5IaWdoICE9IGluSGlnaCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHx8IG91dExvdyAhPSBvdXRMb3cgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICB8fCBvdXRIaWdoICE9IG91dEhpZ2gpIHJldHVybiBOYU47XG4gIGlmICh4ID09PSBJbmZpbml0eSB8fCB4ID09PSAtSW5maW5pdHkpIHJldHVybiB4O1xuICByZXR1cm4gKHggLSBpbkxvdykgKiAob3V0SGlnaCAtIG91dExvdykgLyAoaW5IaWdoIC0gaW5Mb3cpICsgb3V0TG93O1xufTsiLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiBzaWduKHgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4gKHggPSAreCkgPT0gMCB8fCB4ICE9IHggPyB4IDogeCA8IDAgPyAtMSA6IDE7XG59OyIsInZhciBNRVRBID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKTtcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcblxudmFyIHNldERlc2MgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xuXG52YXIgaWQgPSAwO1xuXG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xuXG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7XG4gICAgdmFsdWU6IHtcbiAgICAgIGk6ICdPJyArICsraWQsXG4gICAgICAvLyBvYmplY3QgSURcbiAgICAgIHc6IHt9IC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG5cbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuXG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnOyAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7IC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG5cbiAgICBzZXRNZXRhKGl0KTsgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9XG5cbiAgcmV0dXJuIGl0W01FVEFdLmk7XG59O1xuXG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTsgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcblxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7IC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG5cbiAgICBzZXRNZXRhKGl0KTsgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfVxuXG4gIHJldHVybiBpdFtNRVRBXS53O1xufTsgLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG5cblxudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07IiwidmFyIE1hcCA9IHJlcXVpcmUoJy4vZXM2Lm1hcCcpO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ21ldGFkYXRhJyk7XG5cbnZhciBzdG9yZSA9IHNoYXJlZC5zdG9yZSB8fCAoc2hhcmVkLnN0b3JlID0gbmV3IChyZXF1aXJlKCcuL2VzNi53ZWFrLW1hcCcpKSgpKTtcblxudmFyIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRLZXksIGNyZWF0ZSkge1xuICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBzdG9yZS5nZXQodGFyZ2V0KTtcblxuICBpZiAoIXRhcmdldE1ldGFkYXRhKSB7XG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgc3RvcmUuc2V0KHRhcmdldCwgdGFyZ2V0TWV0YWRhdGEgPSBuZXcgTWFwKCkpO1xuICB9XG5cbiAgdmFyIGtleU1ldGFkYXRhID0gdGFyZ2V0TWV0YWRhdGEuZ2V0KHRhcmdldEtleSk7XG5cbiAgaWYgKCFrZXlNZXRhZGF0YSkge1xuICAgIGlmICghY3JlYXRlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHRhcmdldE1ldGFkYXRhLnNldCh0YXJnZXRLZXksIGtleU1ldGFkYXRhID0gbmV3IE1hcCgpKTtcbiAgfVxuXG4gIHJldHVybiBrZXlNZXRhZGF0YTtcbn07XG5cbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpO1xuICByZXR1cm4gbWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogbWV0YWRhdGFNYXAuaGFzKE1ldGFkYXRhS2V5KTtcbn07XG5cbnZhciBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gZnVuY3Rpb24gKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpO1xuICByZXR1cm4gbWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG1ldGFkYXRhTWFwLmdldChNZXRhZGF0YUtleSk7XG59O1xuXG52YXIgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IGZ1bmN0aW9uIChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUCkge1xuICBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIHRydWUpLnNldChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSk7XG59O1xuXG52YXIgb3JkaW5hcnlPd25NZXRhZGF0YUtleXMgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRLZXkpIHtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCh0YXJnZXQsIHRhcmdldEtleSwgZmFsc2UpO1xuICB2YXIga2V5cyA9IFtdO1xuICBpZiAobWV0YWRhdGFNYXApIG1ldGFkYXRhTWFwLmZvckVhY2goZnVuY3Rpb24gKF8sIGtleSkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9KTtcbiAgcmV0dXJuIGtleXM7XG59O1xuXG52YXIgdG9NZXRhS2V5ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG5cbnZhciBleHAgPSBmdW5jdGlvbiAoTykge1xuICAkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCBPKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdG9yZTogc3RvcmUsXG4gIG1hcDogZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCxcbiAgaGFzOiBvcmRpbmFyeUhhc093bk1ldGFkYXRhLFxuICBnZXQ6IG9yZGluYXJ5R2V0T3duTWV0YWRhdGEsXG4gIHNldDogb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSxcbiAga2V5czogb3JkaW5hcnlPd25NZXRhZGF0YUtleXMsXG4gIGtleTogdG9NZXRhS2V5LFxuICBleHA6IGV4cFxufTsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xuXG52YXIgT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcblxuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5KCk7ZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07IC8vIE5vZGUuanNcblxuXG4gIGlmIChpc05vZGUpIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9OyAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXIsIGV4Y2VwdCBpT1MgU2FmYXJpIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMzOVxuXG4gIH0gZWxzZSBpZiAoT2JzZXJ2ZXIgJiYgIShnbG9iYWwubmF2aWdhdG9yICYmIGdsb2JhbC5uYXZpZ2F0b3Iuc3RhbmRhbG9uZSkpIHtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuXG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9OyAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuXG4gIH0gZWxzZSBpZiAoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHtcbiAgICAvLyBQcm9taXNlLnJlc29sdmUgd2l0aG91dCBhbiBhcmd1bWVudCB0aHJvd3MgYW4gZXJyb3IgaW4gTEcgV2ViT1MgMlxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG5cbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07IC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gICAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gICAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAgIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gICAgLy8gLSBzZXRUaW1lb3V0XG5cbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIHZhciB0YXNrID0ge1xuICAgICAgZm46IGZuLFxuICAgICAgbmV4dDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzaztcblxuICAgIGlmICghaGVhZCkge1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9XG5cbiAgICBsYXN0ID0gdGFzaztcbiAgfTtcbn07IiwiJ3VzZSBzdHJpY3QnOyAvLyAyNS40LjEuNSBOZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxuXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG5mdW5jdGlvbiBQcm9taXNlQ2FwYWJpbGl0eShDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTsiLCIndXNlIHN0cmljdCc7IC8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcblxudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcblxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG5cbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcblxudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduOyAvLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1ZylcblxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cbiAgdmFyIFMgPSBTeW1ib2woKTtcbiAgdmFyIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIEJba10gPSBrO1xuICB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuXG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuXG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIHtcbiAgICAgIGtleSA9IGtleXNbaisrXTtcbiAgICAgIGlmICghREVTQ1JJUFRPUlMgfHwgaXNFbnVtLmNhbGwoUywga2V5KSkgVFtrZXldID0gU1trZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBUO1xufSA6ICRhc3NpZ247IiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcblxudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgLyogZW1wdHkgKi9cbn07XG5cbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJzsgLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxuXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJyk7XG5cbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuXG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcblxuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcblxuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG5cbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7IC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcblxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuXG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07IiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG5cbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTsiLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuXG4gIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuXG4gIHJldHVybiBPO1xufTsiLCIndXNlIHN0cmljdCc7IC8vIEZvcmNlZCByZXBsYWNlbWVudCBwcm90b3R5cGUgYWNjZXNzb3JzIG1ldGhvZHNcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19saWJyYXJ5JykgfHwgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgSyA9IE1hdGgucmFuZG9tKCk7IC8vIEluIEZGIHRocm93cyBvbmx5IGRlZmluZSBtZXRob2RzXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZiwgbm8tdXNlbGVzcy1jYWxsXG5cbiAgX19kZWZpbmVTZXR0ZXJfXy5jYWxsKG51bGwsIEssIGZ1bmN0aW9uICgpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9KTtcblxuICBkZWxldGUgcmVxdWlyZSgnLi9fZ2xvYmFsJylbS107XG59KTsiLCJ2YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xuXG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcblxudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcblxudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTsiLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59OyIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG5cbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTsiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzOyIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcblxuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfVxuXG4gIHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTsiLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG5cbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcblxudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuXG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7IC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcblxuXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59OyIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcblxudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTsiLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTsiLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xuXG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICB2YXIgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIGZuKDEpO1xuICB9KSwgJ09iamVjdCcsIGV4cCk7XG59OyIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG5cbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxudmFyIGlzRW51bSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpc0VudHJpZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KGl0KTtcbiAgICB2YXIga2V5cyA9IGdldEtleXMoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGtleTtcblxuICAgIHdoaWxlIChsZW5ndGggPiBpKSB7XG4gICAgICBrZXkgPSBrZXlzW2krK107XG5cbiAgICAgIGlmICghREVTQ1JJUFRPUlMgfHwgaXNFbnVtLmNhbGwoTywga2V5KSkge1xuICAgICAgICByZXN1bHQucHVzaChpc0VudHJpZXMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufTsiLCIvLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJyk7XG5cbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBSZWZsZWN0ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdDtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0ICYmIFJlZmxlY3Qub3duS2V5cyB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ09QTi5mKGFuT2JqZWN0KGl0KSk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICByZXR1cm4gZ2V0U3ltYm9scyA/IGtleXMuY29uY2F0KGdldFN5bWJvbHMoaXQpKSA6IGtleXM7XG59OyIsInZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlRmxvYXQ7XG5cbnZhciAkdHJpbSA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcblxubW9kdWxlLmV4cG9ydHMgPSAxIC8gJHBhcnNlRmxvYXQocmVxdWlyZSgnLi9fc3RyaW5nLXdzJykgKyAnLTAnKSAhPT0gLUluZmluaXR5ID8gZnVuY3Rpb24gcGFyc2VGbG9hdChzdHIpIHtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKTtcbiAgdmFyIHJlc3VsdCA9ICRwYXJzZUZsb2F0KHN0cmluZyk7XG4gIHJldHVybiByZXN1bHQgPT09IDAgJiYgc3RyaW5nLmNoYXJBdCgwKSA9PSAnLScgPyAtMCA6IHJlc3VsdDtcbn0gOiAkcGFyc2VGbG9hdDsiLCJ2YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucGFyc2VJbnQ7XG5cbnZhciAkdHJpbSA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcblxudmFyIHdzID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJyk7XG5cbnZhciBoZXggPSAvXlstK10/MFt4WF0vO1xubW9kdWxlLmV4cG9ydHMgPSAkcGFyc2VJbnQod3MgKyAnMDgnKSAhPT0gOCB8fCAkcGFyc2VJbnQod3MgKyAnMHgxNicpICE9PSAyMiA/IGZ1bmN0aW9uIHBhcnNlSW50KHN0ciwgcmFkaXgpIHtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKTtcbiAgcmV0dXJuICRwYXJzZUludChzdHJpbmcsIHJhZGl4ID4+PiAwIHx8IChoZXgudGVzdChzdHJpbmcpID8gMTYgOiAxMCkpO1xufSA6ICRwYXJzZUludDsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGU6IGZhbHNlLFxuICAgICAgdjogZXhlYygpXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7XG4gICAgICBlOiB0cnVlLFxuICAgICAgdjogZVxuICAgIH07XG4gIH1cbn07IiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QoQyk7XG4gIGlmIChpc09iamVjdCh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTsiLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgc2FmZSkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSByZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIHNhZmUpO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59OyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5cbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcblxudmFyIFNSQyA9IHJlcXVpcmUoJy4vX3VpZCcpKCdzcmMnKTtcblxudmFyICR0b1N0cmluZyA9IHJlcXVpcmUoJy4vX2Z1bmN0aW9uLXRvLXN0cmluZycpO1xuXG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciBUUEwgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWwsIHNhZmUpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmIChPW2tleV0gPT09IHZhbCkgcmV0dXJuO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG5cbiAgaWYgKE8gPT09IGdsb2JhbCkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIGlmICghc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH0gZWxzZSBpZiAoT1trZXldKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9IC8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxuXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG5cbnZhciBidWlsdGluRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYzsgLy8gYFJlZ0V4cEV4ZWNgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwZXhlY1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChSLCBTKSB7XG4gIHZhciBleGVjID0gUi5leGVjO1xuXG4gIGlmICh0eXBlb2YgZXhlYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciByZXN1bHQgPSBleGVjLmNhbGwoUiwgUyk7XG5cbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZ0V4cCBleGVjIG1ldGhvZCByZXR1cm5lZCBzb21ldGhpbmcgb3RoZXIgdGhhbiBhbiBPYmplY3Qgb3IgbnVsbCcpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoY2xhc3NvZihSKSAhPT0gJ1JlZ0V4cCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWdFeHAjZXhlYyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyJyk7XG4gIH1cblxuICByZXR1cm4gYnVpbHRpbkV4ZWMuY2FsbChSLCBTKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVnZXhwRmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xuXG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYzsgLy8gVGhpcyBhbHdheXMgcmVmZXJzIHRvIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24sIGJlY2F1c2UgdGhlXG4vLyBTdHJpbmcjcmVwbGFjZSBwb2x5ZmlsbCB1c2VzIC4vZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYy5qcyxcbi8vIHdoaWNoIGxvYWRzIHRoaXMgZmlsZSBiZWZvcmUgcGF0Y2hpbmcgdGhlIG1ldGhvZC5cblxudmFyIG5hdGl2ZVJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG52YXIgcGF0Y2hlZEV4ZWMgPSBuYXRpdmVFeGVjO1xudmFyIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlMSA9IC9hLyxcbiAgICAgIHJlMiA9IC9iKi9nO1xuICBuYXRpdmVFeGVjLmNhbGwocmUxLCAnYScpO1xuICBuYXRpdmVFeGVjLmNhbGwocmUyLCAnYScpO1xuICByZXR1cm4gcmUxW0xBU1RfSU5ERVhdICE9PSAwIHx8IHJlMltMQVNUX0lOREVYXSAhPT0gMDtcbn0oKTsgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXAsIGNvcGllZCBmcm9tIGVzNS1zaGltJ3MgU3RyaW5nI3NwbGl0IHBhdGNoLlxuXG5cbnZhciBOUENHX0lOQ0xVREVEID0gLygpPz8vLmV4ZWMoJycpWzFdICE9PSB1bmRlZmluZWQ7XG52YXIgUEFUQ0ggPSBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgfHwgTlBDR19JTkNMVURFRDtcblxuaWYgKFBBVENIKSB7XG4gIHBhdGNoZWRFeGVjID0gZnVuY3Rpb24gZXhlYyhzdHIpIHtcbiAgICB2YXIgcmUgPSB0aGlzO1xuICAgIHZhciBsYXN0SW5kZXgsIHJlQ29weSwgbWF0Y2gsIGk7XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyByZS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIHJlZ2V4cEZsYWdzLmNhbGwocmUpKTtcbiAgICB9XG5cbiAgICBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HKSBsYXN0SW5kZXggPSByZVtMQVNUX0lOREVYXTtcbiAgICBtYXRjaCA9IG5hdGl2ZUV4ZWMuY2FsbChyZSwgc3RyKTtcblxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlW0xBU1RfSU5ERVhdID0gcmUuZ2xvYmFsID8gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggOiBsYXN0SW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKE5QQ0dfSU5DTFVERUQgJiYgbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAgIC8vIGZvciBOUENHLCBsaWtlIElFOC4gTk9URTogVGhpcyBkb2Vzbicgd29yayBmb3IgLyguPyk/L1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgbmF0aXZlUmVwbGFjZS5jYWxsKG1hdGNoWzBdLCByZUNvcHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpIG1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hlZEV4ZWM7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVnRXhwLCByZXBsYWNlKSB7XG4gIHZhciByZXBsYWNlciA9IHJlcGxhY2UgPT09IE9iamVjdChyZXBsYWNlKSA/IGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgcmV0dXJuIHJlcGxhY2VbcGFydF07XG4gIH0gOiByZXBsYWNlO1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIFN0cmluZyhpdCkucmVwbGFjZShyZWdFeHAsIHJlcGxhY2VyKTtcbiAgfTtcbn07IiwiLy8gNy4yLjkgU2FtZVZhbHVlKHgsIHkpXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XG59OyIsIid1c2Ugc3RyaWN0JzsgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG5cbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT0xMRUNUSU9OKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCBDT0xMRUNUSU9OLCB7XG4gICAgZnJvbTogZnVuY3Rpb24gZnJvbShzb3VyY2VcbiAgICAvKiAsIG1hcEZuLCB0aGlzQXJnICovXG4gICAgKSB7XG4gICAgICB2YXIgbWFwRm4gPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgbWFwcGluZywgQSwgbiwgY2I7XG4gICAgICBhRnVuY3Rpb24odGhpcyk7XG4gICAgICBtYXBwaW5nID0gbWFwRm4gIT09IHVuZGVmaW5lZDtcbiAgICAgIGlmIChtYXBwaW5nKSBhRnVuY3Rpb24obWFwRm4pO1xuICAgICAgaWYgKHNvdXJjZSA9PSB1bmRlZmluZWQpIHJldHVybiBuZXcgdGhpcygpO1xuICAgICAgQSA9IFtdO1xuXG4gICAgICBpZiAobWFwcGluZykge1xuICAgICAgICBuID0gMDtcbiAgICAgICAgY2IgPSBjdHgobWFwRm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIGZ1bmN0aW9uIChuZXh0SXRlbSkge1xuICAgICAgICAgIEEucHVzaChjYihuZXh0SXRlbSwgbisrKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT2Yoc291cmNlLCBmYWxzZSwgQS5wdXNoLCBBKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICAgIH1cbiAgfSk7XG59OyIsIid1c2Ugc3RyaWN0JzsgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT0xMRUNUSU9OKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCBDT0xMRUNUSU9OLCB7XG4gICAgb2Y6IGZ1bmN0aW9uIG9mKCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgQSA9IG5ldyBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIEFbbGVuZ3RoXSA9IGFyZ3VtZW50c1tsZW5ndGhdO1xuXG4gICAgICByZXR1cm4gbmV3IHRoaXMoQSk7XG4gICAgfVxuICB9KTtcbn07IiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHNldCA9IHJlcXVpcmUoJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBidWdneSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87ZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgcmV0dXJuIE87XG4gICAgfTtcbiAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcblxudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG59OyIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xuXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG5cbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHRhZ1xuICB9KTtcbn07IiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG5cbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59OyIsInZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiBjb3JlLnZlcnNpb24sXG4gIG1vZGU6IHJlcXVpcmUoJy4vX2xpYnJhcnknKSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE5IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xufSk7IiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBEKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsXG4gICAgYXJnID8gbWV0aG9kLmNhbGwobnVsbCwgZnVuY3Rpb24gKCkge1xuICAgICAgLyogZW1wdHkgKi9cbiAgICB9LCAxKSA6IG1ldGhvZC5jYWxsKG51bGwpO1xuICB9KTtcbn07IiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcblxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7IC8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTsiLCIvLyBoZWxwZXIgZm9yIFN0cmluZyN7c3RhcnRzV2l0aCwgZW5kc1dpdGgsIGluY2x1ZGVzfVxudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG5cbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBzZWFyY2hTdHJpbmcsIE5BTUUpIHtcbiAgaWYgKGlzUmVnRXhwKHNlYXJjaFN0cmluZykpIHRocm93IFR5cGVFcnJvcignU3RyaW5nIycgKyBOQU1FICsgXCIgZG9lc24ndCBhY2NlcHQgcmVnZXghXCIpO1xuICByZXR1cm4gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xufTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxudmFyIHF1b3QgPSAvXCIvZzsgLy8gQi4yLjMuMi4xIENyZWF0ZUhUTUwoc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpXG5cbnZhciBjcmVhdGVIVE1MID0gZnVuY3Rpb24gKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gIHZhciBTID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIHZhciBwMSA9ICc8JyArIHRhZztcbiAgaWYgKGF0dHJpYnV0ZSAhPT0gJycpIHAxICs9ICcgJyArIGF0dHJpYnV0ZSArICc9XCInICsgU3RyaW5nKHZhbHVlKS5yZXBsYWNlKHF1b3QsICcmcXVvdDsnKSArICdcIic7XG4gIHJldHVybiBwMSArICc+JyArIFMgKyAnPC8nICsgdGFnICsgJz4nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSwgZXhlYykge1xuICB2YXIgTyA9IHt9O1xuICBPW05BTUVdID0gZXhlYyhjcmVhdGVIVE1MKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRlc3QgPSAnJ1tOQU1FXSgnXCInKTtcbiAgICByZXR1cm4gdGVzdCAhPT0gdGVzdC50b0xvd2VyQ2FzZSgpIHx8IHRlc3Quc3BsaXQoJ1wiJykubGVuZ3RoID4gMztcbiAgfSksICdTdHJpbmcnLCBPKTtcbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG52YXIgcmVwZWF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpO1xuXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgbWF4TGVuZ3RoLCBmaWxsU3RyaW5nLCBsZWZ0KSB7XG4gIHZhciBTID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICB2YXIgc3RyaW5nTGVuZ3RoID0gUy5sZW5ndGg7XG4gIHZhciBmaWxsU3RyID0gZmlsbFN0cmluZyA9PT0gdW5kZWZpbmVkID8gJyAnIDogU3RyaW5nKGZpbGxTdHJpbmcpO1xuICB2YXIgaW50TWF4TGVuZ3RoID0gdG9MZW5ndGgobWF4TGVuZ3RoKTtcbiAgaWYgKGludE1heExlbmd0aCA8PSBzdHJpbmdMZW5ndGggfHwgZmlsbFN0ciA9PSAnJykgcmV0dXJuIFM7XG4gIHZhciBmaWxsTGVuID0gaW50TWF4TGVuZ3RoIC0gc3RyaW5nTGVuZ3RoO1xuICB2YXIgc3RyaW5nRmlsbGVyID0gcmVwZWF0LmNhbGwoZmlsbFN0ciwgTWF0aC5jZWlsKGZpbGxMZW4gLyBmaWxsU3RyLmxlbmd0aCkpO1xuICBpZiAoc3RyaW5nRmlsbGVyLmxlbmd0aCA+IGZpbGxMZW4pIHN0cmluZ0ZpbGxlciA9IHN0cmluZ0ZpbGxlci5zbGljZSgwLCBmaWxsTGVuKTtcbiAgcmV0dXJuIGxlZnQgPyBzdHJpbmdGaWxsZXIgKyBTIDogUyArIHN0cmluZ0ZpbGxlcjtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xuXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBlYXQoY291bnQpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyhkZWZpbmVkKHRoaXMpKTtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgbiA9IHRvSW50ZWdlcihjb3VudCk7XG4gIGlmIChuIDwgMCB8fCBuID09IEluZmluaXR5KSB0aHJvdyBSYW5nZUVycm9yKFwiQ291bnQgY2FuJ3QgYmUgbmVnYXRpdmVcIik7XG5cbiAgZm9yICg7IG4gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSkgaWYgKG4gJiAxKSByZXMgKz0gc3RyO1xuXG4gIHJldHVybiByZXM7XG59OyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG52YXIgc3BhY2VzID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJyk7XG5cbnZhciBzcGFjZSA9ICdbJyArIHNwYWNlcyArICddJztcbnZhciBub24gPSAnXFx1MjAwYlxcdTAwODUnO1xudmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHNwYWNlICsgc3BhY2UgKyAnKicpO1xudmFyIHJ0cmltID0gUmVnRXhwKHNwYWNlICsgc3BhY2UgKyAnKiQnKTtcblxudmFyIGV4cG9ydGVyID0gZnVuY3Rpb24gKEtFWSwgZXhlYywgQUxJQVMpIHtcbiAgdmFyIGV4cCA9IHt9O1xuICB2YXIgRk9SQ0UgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhc3BhY2VzW0tFWV0oKSB8fCBub25bS0VZXSgpICE9IG5vbjtcbiAgfSk7XG4gIHZhciBmbiA9IGV4cFtLRVldID0gRk9SQ0UgPyBleGVjKHRyaW0pIDogc3BhY2VzW0tFWV07XG4gIGlmIChBTElBUykgZXhwW0FMSUFTXSA9IGZuO1xuICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFLCAnU3RyaW5nJywgZXhwKTtcbn07IC8vIDEgLT4gU3RyaW5nI3RyaW1MZWZ0XG4vLyAyIC0+IFN0cmluZyN0cmltUmlnaHRcbi8vIDMgLT4gU3RyaW5nI3RyaW1cblxuXG52YXIgdHJpbSA9IGV4cG9ydGVyLnRyaW0gPSBmdW5jdGlvbiAoc3RyaW5nLCBUWVBFKSB7XG4gIHN0cmluZyA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpO1xuICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gIGlmIChUWVBFICYgMikgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZXI7IiwibW9kdWxlLmV4cG9ydHMgPSAnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICsgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkYnOyIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcblxudmFyIGludm9rZSA9IHJlcXVpcmUoJy4vX2ludm9rZScpO1xuXG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vX2h0bWwnKTtcblxudmFyIGNlbCA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKTtcblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHNldFRhc2sgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyVGFzayA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xuXG52YXIgcnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaWQgPSArdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuXG4gIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xuXG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59OyAvLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5cblxuaWYgKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spIHtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGkgPSAxO1xuXG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuXG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG5cbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcblxuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07IC8vIE5vZGUuanMgMC44LVxuXG5cbiAgaWYgKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTsgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG5cbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgRGlzcGF0Y2gubm93KGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTsgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuXG4gIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwpIHtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTsgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gICAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcblxuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTsgLy8gSUU4LVxuICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9OyAvLyBSZXN0IG9sZCBicm93c2Vyc1xuXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07IiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcblxudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59OyIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvaW5kZXhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gIHZhciBudW1iZXIgPSB0b0ludGVnZXIoaXQpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgobnVtYmVyKTtcbiAgaWYgKG51bWJlciAhPT0gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBsZW5ndGghJyk7XG4gIHJldHVybiBsZW5ndGg7XG59OyIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07IiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcblxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07IiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xuXG52YXIgbWluID0gTWF0aC5taW47XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59OyIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07IiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTsgLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykpIHtcbiAgdmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG5cbiAgdmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG4gIHZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbiAgdmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuICB2YXIgJHR5cGVkID0gcmVxdWlyZSgnLi9fdHlwZWQnKTtcblxuICB2YXIgJGJ1ZmZlciA9IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpO1xuXG4gIHZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcblxuICB2YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG5cbiAgdmFyIHByb3BlcnR5RGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxuICB2YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcblxuICB2YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcblxuICB2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xuXG4gIHZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG4gIHZhciB0b0luZGV4ID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcblxuICB2YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcblxuICB2YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuICB2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG5cbiAgdmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG5cbiAgdmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbiAgdmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbiAgdmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xuXG4gIHZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG5cbiAgdmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG4gIHZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xuXG4gIHZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4gIHZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcblxuICB2YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cbiAgdmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xuXG4gIHZhciBjcmVhdGVBcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKTtcblxuICB2YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG4gIHZhciBBcnJheUl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG5cbiAgdmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xuXG4gIHZhciAkaXRlckRldGVjdCA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0Jyk7XG5cbiAgdmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpO1xuXG4gIHZhciBhcnJheUZpbGwgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJyk7XG5cbiAgdmFyIGFycmF5Q29weVdpdGhpbiA9IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJyk7XG5cbiAgdmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG4gIHZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG5cbiAgdmFyIGRQID0gJERQLmY7XG4gIHZhciBnT1BEID0gJEdPUEQuZjtcbiAgdmFyIFJhbmdlRXJyb3IgPSBnbG9iYWwuUmFuZ2VFcnJvcjtcbiAgdmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG4gIHZhciBVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXk7XG4gIHZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xuICB2YXIgU0hBUkVEX0JVRkZFUiA9ICdTaGFyZWQnICsgQVJSQVlfQlVGRkVSO1xuICB2YXIgQllURVNfUEVSX0VMRU1FTlQgPSAnQllURVNfUEVSX0VMRU1FTlQnO1xuICB2YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXlbUFJPVE9UWVBFXTtcbiAgdmFyICRBcnJheUJ1ZmZlciA9ICRidWZmZXIuQXJyYXlCdWZmZXI7XG4gIHZhciAkRGF0YVZpZXcgPSAkYnVmZmVyLkRhdGFWaWV3O1xuICB2YXIgYXJyYXlGb3JFYWNoID0gY3JlYXRlQXJyYXlNZXRob2QoMCk7XG4gIHZhciBhcnJheUZpbHRlciA9IGNyZWF0ZUFycmF5TWV0aG9kKDIpO1xuICB2YXIgYXJyYXlTb21lID0gY3JlYXRlQXJyYXlNZXRob2QoMyk7XG4gIHZhciBhcnJheUV2ZXJ5ID0gY3JlYXRlQXJyYXlNZXRob2QoNCk7XG4gIHZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbiAgdmFyIGFycmF5RmluZEluZGV4ID0gY3JlYXRlQXJyYXlNZXRob2QoNik7XG4gIHZhciBhcnJheUluY2x1ZGVzID0gY3JlYXRlQXJyYXlJbmNsdWRlcyh0cnVlKTtcbiAgdmFyIGFycmF5SW5kZXhPZiA9IGNyZWF0ZUFycmF5SW5jbHVkZXMoZmFsc2UpO1xuICB2YXIgYXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9ycy52YWx1ZXM7XG4gIHZhciBhcnJheUtleXMgPSBBcnJheUl0ZXJhdG9ycy5rZXlzO1xuICB2YXIgYXJyYXlFbnRyaWVzID0gQXJyYXlJdGVyYXRvcnMuZW50cmllcztcbiAgdmFyIGFycmF5TGFzdEluZGV4T2YgPSBBcnJheVByb3RvLmxhc3RJbmRleE9mO1xuICB2YXIgYXJyYXlSZWR1Y2UgPSBBcnJheVByb3RvLnJlZHVjZTtcbiAgdmFyIGFycmF5UmVkdWNlUmlnaHQgPSBBcnJheVByb3RvLnJlZHVjZVJpZ2h0O1xuICB2YXIgYXJyYXlKb2luID0gQXJyYXlQcm90by5qb2luO1xuICB2YXIgYXJyYXlTb3J0ID0gQXJyYXlQcm90by5zb3J0O1xuICB2YXIgYXJyYXlTbGljZSA9IEFycmF5UHJvdG8uc2xpY2U7XG4gIHZhciBhcnJheVRvU3RyaW5nID0gQXJyYXlQcm90by50b1N0cmluZztcbiAgdmFyIGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBBcnJheVByb3RvLnRvTG9jYWxlU3RyaW5nO1xuICB2YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG4gIHZhciBUQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJyk7XG4gIHZhciBUWVBFRF9DT05TVFJVQ1RPUiA9IHVpZCgndHlwZWRfY29uc3RydWN0b3InKTtcbiAgdmFyIERFRl9DT05TVFJVQ1RPUiA9IHVpZCgnZGVmX2NvbnN0cnVjdG9yJyk7XG4gIHZhciBBTExfQ09OU1RSVUNUT1JTID0gJHR5cGVkLkNPTlNUUjtcbiAgdmFyIFRZUEVEX0FSUkFZID0gJHR5cGVkLlRZUEVEO1xuICB2YXIgVklFVyA9ICR0eXBlZC5WSUVXO1xuICB2YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCEnO1xuICB2YXIgJG1hcCA9IGNyZWF0ZUFycmF5TWV0aG9kKDEsIGZ1bmN0aW9uIChPLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gYWxsb2NhdGUoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxlbmd0aCk7XG4gIH0pO1xuICB2YXIgTElUVExFX0VORElBTiA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQxNkFycmF5KFsxXSkuYnVmZmVyKVswXSA9PT0gMTtcbiAgfSk7XG4gIHZhciBGT1JDRURfU0VUID0gISFVaW50OEFycmF5ICYmICEhVWludDhBcnJheVtQUk9UT1RZUEVdLnNldCAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IFVpbnQ4QXJyYXkoMSkuc2V0KHt9KTtcbiAgfSk7XG5cbiAgdmFyIHRvT2Zmc2V0ID0gZnVuY3Rpb24gKGl0LCBCWVRFUykge1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoaXQpO1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCAlIEJZVEVTKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfTtcblxuICB2YXIgdmFsaWRhdGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICBpZiAoaXNPYmplY3QoaXQpICYmIFRZUEVEX0FSUkFZIGluIGl0KSByZXR1cm4gaXQ7XG4gICAgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSB0eXBlZCBhcnJheSEnKTtcbiAgfTtcblxuICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbiAoQywgbGVuZ3RoKSB7XG4gICAgaWYgKCEoaXNPYmplY3QoQykgJiYgVFlQRURfQ09OU1RSVUNUT1IgaW4gQykpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSXQgaXMgbm90IGEgdHlwZWQgYXJyYXkgY29uc3RydWN0b3IhJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDKGxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIHNwZWNpZXNGcm9tTGlzdCA9IGZ1bmN0aW9uIChPLCBsaXN0KSB7XG4gICAgcmV0dXJuIGZyb21MaXN0KHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsaXN0KTtcbiAgfTtcblxuICB2YXIgZnJvbUxpc3QgPSBmdW5jdGlvbiAoQywgbGlzdCkge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBhbGxvY2F0ZShDLCBsZW5ndGgpO1xuXG4gICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uIChpdCwga2V5LCBpbnRlcm5hbCkge1xuICAgIGRQKGl0LCBrZXksIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZFtpbnRlcm5hbF07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyICRmcm9tID0gZnVuY3Rpb24gZnJvbShzb3VyY2VcbiAgLyogLCBtYXBmbiwgdGhpc0FyZyAqL1xuICApIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHNvdXJjZSk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKE8pO1xuICAgIHZhciBpLCBsZW5ndGgsIHZhbHVlcywgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcblxuICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICFpc0FycmF5SXRlcihpdGVyRm4pKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHZhbHVlcyA9IFtdLCBpID0gMDsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpKyspIHtcbiAgICAgICAgdmFsdWVzLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIE8gPSB2YWx1ZXM7XG4gICAgfVxuXG4gICAgaWYgKG1hcHBpbmcgJiYgYUxlbiA+IDIpIG1hcGZuID0gY3R4KG1hcGZuLCBhcmd1bWVudHNbMl0sIDIpO1xuXG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpLCByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpOyBsZW5ndGggPiBpOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1hcHBpbmcgPyBtYXBmbihPW2ldLCBpKSA6IE9baV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgJG9mID0gZnVuY3Rpb24gb2YoKVxuICAvKiAuLi5pdGVtcyAqL1xuICB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTtcblxuICAgIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07IC8vIGlPUyBTYWZhcmkgNi54IGZhaWxzIGhlcmVcblxuXG4gIHZhciBUT19MT0NBTEVfQlVHID0gISFVaW50OEFycmF5ICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBhcnJheVRvTG9jYWxlU3RyaW5nLmNhbGwobmV3IFVpbnQ4QXJyYXkoMSkpO1xuICB9KTtcblxuICB2YXIgJHRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoKSB7XG4gICAgcmV0dXJuIGFycmF5VG9Mb2NhbGVTdHJpbmcuYXBwbHkoVE9fTE9DQUxFX0JVRyA/IGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSkgOiB2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICB2YXIgcHJvdG8gPSB7XG4gICAgY29weVdpdGhpbjogZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0XG4gICAgLyogLCBlbmQgKi9cbiAgICApIHtcbiAgICAgIHJldHVybiBhcnJheUNvcHlXaXRoaW4uY2FsbCh2YWxpZGF0ZSh0aGlzKSwgdGFyZ2V0LCBzdGFydCwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm5cbiAgICAvKiAsIHRoaXNBcmcgKi9cbiAgICApIHtcbiAgICAgIHJldHVybiBhcnJheUV2ZXJ5KHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaWxsOiBmdW5jdGlvbiBmaWxsKHZhbHVlXG4gICAgLyogLCBzdGFydCwgZW5kICovXG4gICAgKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlGaWxsLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmblxuICAgIC8qICwgdGhpc0FyZyAqL1xuICAgICkge1xuICAgICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheUZpbHRlcih2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpKTtcbiAgICB9LFxuICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlXG4gICAgLyogLCB0aGlzQXJnICovXG4gICAgKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaW5kKHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZVxuICAgIC8qICwgdGhpc0FyZyAqL1xuICAgICkge1xuICAgICAgcmV0dXJuIGFycmF5RmluZEluZGV4KHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmblxuICAgIC8qICwgdGhpc0FyZyAqL1xuICAgICkge1xuICAgICAgYXJyYXlGb3JFYWNoKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnRcbiAgICAvKiAsIGZyb21JbmRleCAqL1xuICAgICkge1xuICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZih2YWxpZGF0ZSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaEVsZW1lbnRcbiAgICAvKiAsIGZyb21JbmRleCAqL1xuICAgICkge1xuICAgICAgcmV0dXJuIGFycmF5SW5jbHVkZXModmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlKb2luLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnRcbiAgICAvKiAsIGZyb21JbmRleCAqL1xuICAgICkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5TGFzdEluZGV4T2YuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBmblxuICAgIC8qICwgdGhpc0FyZyAqL1xuICAgICkge1xuICAgICAgcmV0dXJuICRtYXAodmFsaWRhdGUodGhpcyksIG1hcGZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuXG4gICAgLyogLCBpbml0aWFsVmFsdWUgKi9cbiAgICApIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZS5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuXG4gICAgLyogLCBpbml0aWFsVmFsdWUgKi9cbiAgICApIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZVJpZ2h0LmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBsZW5ndGggPSB2YWxpZGF0ZSh0aGF0KS5sZW5ndGg7XG4gICAgICB2YXIgbWlkZGxlID0gTWF0aC5mbG9vcihsZW5ndGggLyAyKTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgdmFsdWU7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IG1pZGRsZSkge1xuICAgICAgICB2YWx1ZSA9IHRoYXRbaW5kZXhdO1xuICAgICAgICB0aGF0W2luZGV4KytdID0gdGhhdFstLWxlbmd0aF07XG4gICAgICAgIHRoYXRbbGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhhdDtcbiAgICB9LFxuICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmblxuICAgIC8qICwgdGhpc0FyZyAqL1xuICAgICkge1xuICAgICAgcmV0dXJuIGFycmF5U29tZSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICAgIHJldHVybiBhcnJheVNvcnQuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgY29tcGFyZWZuKTtcbiAgICB9LFxuICAgIHN1YmFycmF5OiBmdW5jdGlvbiBzdWJhcnJheShiZWdpbiwgZW5kKSB7XG4gICAgICB2YXIgTyA9IHZhbGlkYXRlKHRoaXMpO1xuICAgICAgdmFyIGxlbmd0aCA9IE8ubGVuZ3RoO1xuICAgICAgdmFyICRiZWdpbiA9IHRvQWJzb2x1dGVJbmRleChiZWdpbiwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pKShPLmJ1ZmZlciwgTy5ieXRlT2Zmc2V0ICsgJGJlZ2luICogTy5CWVRFU19QRVJfRUxFTUVOVCwgdG9MZW5ndGgoKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKSkgLSAkYmVnaW4pKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyICRzbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5U2xpY2UuY2FsbCh2YWxpZGF0ZSh0aGlzKSwgc3RhcnQsIGVuZCkpO1xuICB9O1xuXG4gIHZhciAkc2V0ID0gZnVuY3Rpb24gc2V0KGFycmF5TGlrZVxuICAvKiAsIG9mZnNldCAqL1xuICApIHtcbiAgICB2YWxpZGF0ZSh0aGlzKTtcbiAgICB2YXIgb2Zmc2V0ID0gdG9PZmZzZXQoYXJndW1lbnRzWzFdLCAxKTtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgdmFyIHNyYyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKHNyYy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgaWYgKGxlbiArIG9mZnNldCA+IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuKSB0aGlzW29mZnNldCArIGluZGV4XSA9IHNyY1tpbmRleCsrXTtcbiAgfTtcblxuICB2YXIgJGl0ZXJhdG9ycyA9IHtcbiAgICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGFycmF5RW50cmllcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlLZXlzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gYXJyYXlWYWx1ZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc1RBSW5kZXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodGFyZ2V0KSAmJiB0YXJnZXRbVFlQRURfQVJSQVldICYmIHR5cGVvZiBrZXkgIT0gJ3N5bWJvbCcgJiYga2V5IGluIHRhcmdldCAmJiBTdHJpbmcoK2tleSkgPT0gU3RyaW5nKGtleSk7XG4gIH07XG5cbiAgdmFyICRnZXREZXNjID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpID8gcHJvcGVydHlEZXNjKDIsIHRhcmdldFtrZXldKSA6IGdPUEQodGFyZ2V0LCBrZXkpO1xuICB9O1xuXG4gIHZhciAkc2V0RGVzYyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgaWYgKGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpICYmIGlzT2JqZWN0KGRlc2MpICYmIGhhcyhkZXNjLCAndmFsdWUnKSAmJiAhaGFzKGRlc2MsICdnZXQnKSAmJiAhaGFzKGRlc2MsICdzZXQnKSAvLyBUT0RPOiBhZGQgdmFsaWRhdGlvbiBkZXNjcmlwdG9yIHcvbyBjYWxsaW5nIGFjY2Vzc29yc1xuICAgICYmICFkZXNjLmNvbmZpZ3VyYWJsZSAmJiAoIWhhcyhkZXNjLCAnd3JpdGFibGUnKSB8fCBkZXNjLndyaXRhYmxlKSAmJiAoIWhhcyhkZXNjLCAnZW51bWVyYWJsZScpIHx8IGRlc2MuZW51bWVyYWJsZSkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gZGVzYy52YWx1ZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRQKHRhcmdldCwga2V5LCBkZXNjKTtcbiAgfTtcblxuICBpZiAoIUFMTF9DT05TVFJVQ1RPUlMpIHtcbiAgICAkR09QRC5mID0gJGdldERlc2M7XG4gICAgJERQLmYgPSAkc2V0RGVzYztcbiAgfVxuXG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIUFMTF9DT05TVFJVQ1RPUlMsICdPYmplY3QnLCB7XG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0RGVzYyxcbiAgICBkZWZpbmVQcm9wZXJ0eTogJHNldERlc2NcbiAgfSk7XG5cbiAgaWYgKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBhcnJheVRvU3RyaW5nLmNhbGwoe30pO1xuICB9KSkge1xuICAgIGFycmF5VG9TdHJpbmcgPSBhcnJheVRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciAkVHlwZWRBcnJheVByb3RvdHlwZSQgPSByZWRlZmluZUFsbCh7fSwgcHJvdG8pO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsICRpdGVyYXRvcnMpO1xuICBoaWRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgSVRFUkFUT1IsICRpdGVyYXRvcnMudmFsdWVzKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCB7XG4gICAgc2xpY2U6ICRzbGljZSxcbiAgICBzZXQ6ICRzZXQsXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qIG5vb3AgKi9cbiAgICB9LFxuICAgIHRvU3RyaW5nOiBhcnJheVRvU3RyaW5nLFxuICAgIHRvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmdcbiAgfSk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdidWZmZXInLCAnYicpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZU9mZnNldCcsICdvJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlTGVuZ3RoJywgJ2wnKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2xlbmd0aCcsICdlJyk7XG4gIGRQKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgVEFHLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpc1tUWVBFRF9BUlJBWV07XG4gICAgfVxuICB9KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBCWVRFUywgd3JhcHBlciwgQ0xBTVBFRCkge1xuICAgIENMQU1QRUQgPSAhIUNMQU1QRUQ7XG4gICAgdmFyIE5BTUUgPSBLRVkgKyAoQ0xBTVBFRCA/ICdDbGFtcGVkJyA6ICcnKSArICdBcnJheSc7XG4gICAgdmFyIEdFVFRFUiA9ICdnZXQnICsgS0VZO1xuICAgIHZhciBTRVRURVIgPSAnc2V0JyArIEtFWTtcbiAgICB2YXIgVHlwZWRBcnJheSA9IGdsb2JhbFtOQU1FXTtcbiAgICB2YXIgQmFzZSA9IFR5cGVkQXJyYXkgfHwge307XG4gICAgdmFyIFRBQyA9IFR5cGVkQXJyYXkgJiYgZ2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheSk7XG4gICAgdmFyIEZPUkNFRCA9ICFUeXBlZEFycmF5IHx8ICEkdHlwZWQuQUJWO1xuICAgIHZhciBPID0ge307XG4gICAgdmFyIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5ICYmIFR5cGVkQXJyYXlbUFJPVE9UWVBFXTtcblxuICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIHJldHVybiBkYXRhLnZbR0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuXG4gICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIGlmIChDTEFNUEVEKSB2YWx1ZSA9ICh2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpKSA8IDAgPyAwIDogdmFsdWUgPiAweGZmID8gMHhmZiA6IHZhbHVlICYgMHhmZjtcbiAgICAgIGRhdGEudltTRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIHZhbHVlLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZEVsZW1lbnQgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIGRQKHRoYXQsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBnZXR0ZXIodGhpcywgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBzZXR0ZXIodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmIChGT1JDRUQpIHtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSwgJ19kJyk7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGgsIGtsYXNzO1xuXG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICBsZW5ndGggPSB0b0luZGV4KGRhdGEpO1xuICAgICAgICAgIGJ5dGVMZW5ndGggPSBsZW5ndGggKiBCWVRFUztcbiAgICAgICAgICBidWZmZXIgPSBuZXcgJEFycmF5QnVmZmVyKGJ5dGVMZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpIHtcbiAgICAgICAgICBidWZmZXIgPSBkYXRhO1xuICAgICAgICAgIG9mZnNldCA9IHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKTtcbiAgICAgICAgICB2YXIgJGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcblxuICAgICAgICAgIGlmICgkbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgkbGVuICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSAkbGVuIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPCAwKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSB0b0xlbmd0aCgkbGVuZ3RoKSAqIEJZVEVTO1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggKyBvZmZzZXQgPiAkbGVuKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xuICAgICAgICB9IGVsc2UgaWYgKFRZUEVEX0FSUkFZIGluIGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBoaWRlKHRoYXQsICdfZCcsIHtcbiAgICAgICAgICBiOiBidWZmZXIsXG4gICAgICAgICAgbzogb2Zmc2V0LFxuICAgICAgICAgIGw6IGJ5dGVMZW5ndGgsXG4gICAgICAgICAgZTogbGVuZ3RoLFxuICAgICAgICAgIHY6IG5ldyAkRGF0YVZpZXcoYnVmZmVyKVxuICAgICAgICB9KTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIGFkZEVsZW1lbnQodGhhdCwgaW5kZXgrKyk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBjcmVhdGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkKTtcbiAgICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheSk7XG4gICAgfSBlbHNlIGlmICghZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgVHlwZWRBcnJheSgxKTtcbiAgICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoLTEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0pIHx8ICEkaXRlckRldGVjdChmdW5jdGlvbiAoaXRlcikge1xuICAgICAgbmV3IFR5cGVkQXJyYXkoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcblxuICAgICAgbmV3IFR5cGVkQXJyYXkobnVsbCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG5cbiAgICAgIG5ldyBUeXBlZEFycmF5KDEuNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG5cbiAgICAgIG5ldyBUeXBlZEFycmF5KGl0ZXIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0sIHRydWUpKSB7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUpO1xuICAgICAgICB2YXIga2xhc3M7IC8vIGB3c2AgbW9kdWxlIGJ1ZywgdGVtcG9yYXJpbHkgcmVtb3ZlIHZhbGlkYXRpb24gbGVuZ3RoIGZvciBVaW50OEFycmF5XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL3B1bGwvNjQ1XG5cbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkgcmV0dXJuIG5ldyBCYXNlKHRvSW5kZXgoZGF0YSkpO1xuXG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKSB7XG4gICAgICAgICAgcmV0dXJuICRsZW5ndGggIT09IHVuZGVmaW5lZCA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSwgJGxlbmd0aCkgOiAkb2Zmc2V0ICE9PSB1bmRlZmluZWQgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUykpIDogbmV3IEJhc2UoZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVFlQRURfQVJSQVkgaW4gZGF0YSkgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgYXJyYXlGb3JFYWNoKFRBQyAhPT0gRnVuY3Rpb24ucHJvdG90eXBlID8gZ09QTihCYXNlKS5jb25jYXQoZ09QTihUQUMpKSA6IGdPUE4oQmFzZSksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIFR5cGVkQXJyYXkpKSBoaWRlKFR5cGVkQXJyYXksIGtleSwgQmFzZVtrZXldKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gVHlwZWRBcnJheVByb3RvdHlwZTtcbiAgICAgIGlmICghTElCUkFSWSkgVHlwZWRBcnJheVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFR5cGVkQXJyYXk7XG4gICAgfVxuXG4gICAgdmFyICRuYXRpdmVJdGVyYXRvciA9IFR5cGVkQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdO1xuICAgIHZhciBDT1JSRUNUX0lURVJfTkFNRSA9ICEhJG5hdGl2ZUl0ZXJhdG9yICYmICgkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSAndmFsdWVzJyB8fCAkbmF0aXZlSXRlcmF0b3IubmFtZSA9PSB1bmRlZmluZWQpO1xuICAgIHZhciAkaXRlcmF0b3IgPSAkaXRlcmF0b3JzLnZhbHVlcztcbiAgICBoaWRlKFR5cGVkQXJyYXksIFRZUEVEX0NPTlNUUlVDVE9SLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRZUEVEX0FSUkFZLCBOQU1FKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgREVGX0NPTlNUUlVDVE9SLCBUeXBlZEFycmF5KTtcblxuICAgIGlmIChDTEFNUEVEID8gbmV3IFR5cGVkQXJyYXkoMSlbVEFHXSAhPSBOQU1FIDogIShUQUcgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpIHtcbiAgICAgIGRQKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRBRywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gTkFNRTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgT1tOQU1FXSA9IFR5cGVkQXJyYXk7XG4gICAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoVHlwZWRBcnJheSAhPSBCYXNlKSwgTyk7XG4gICAgJGV4cG9ydCgkZXhwb3J0LlMsIE5BTUUsIHtcbiAgICAgIEJZVEVTX1BFUl9FTEVNRU5UOiBCWVRFU1xuICAgIH0pO1xuICAgICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgQmFzZS5vZi5jYWxsKFR5cGVkQXJyYXksIDEpO1xuICAgIH0pLCBOQU1FLCB7XG4gICAgICBmcm9tOiAkZnJvbSxcbiAgICAgIG9mOiAkb2ZcbiAgICB9KTtcbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSkgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuICAgICRleHBvcnQoJGV4cG9ydC5QLCBOQU1FLCBwcm90byk7XG4gICAgc2V0U3BlY2llcyhOQU1FKTtcbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFRF9TRVQsIE5BTUUsIHtcbiAgICAgIHNldDogJHNldFxuICAgIH0pO1xuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIUNPUlJFQ1RfSVRFUl9OQU1FLCBOQU1FLCAkaXRlcmF0b3JzKTtcbiAgICBpZiAoIUxJQlJBUlkgJiYgVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyAhPSBhcnJheVRvU3RyaW5nKSBUeXBlZEFycmF5UHJvdG90eXBlLnRvU3RyaW5nID0gYXJyYXlUb1N0cmluZztcbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5ldyBUeXBlZEFycmF5KDEpLnNsaWNlKCk7XG4gICAgfSksIE5BTUUsIHtcbiAgICAgIHNsaWNlOiAkc2xpY2VcbiAgICB9KTtcbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gWzEsIDJdLnRvTG9jYWxlU3RyaW5nKCkgIT0gbmV3IFR5cGVkQXJyYXkoWzEsIDJdKS50b0xvY2FsZVN0cmluZygpO1xuICAgIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nLmNhbGwoWzEsIDJdKTtcbiAgICB9KSksIE5BTUUsIHtcbiAgICAgIHRvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmdcbiAgICB9KTtcbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBDT1JSRUNUX0lURVJfTkFNRSA/ICRuYXRpdmVJdGVyYXRvciA6ICRpdGVyYXRvcjtcbiAgICBpZiAoIUxJQlJBUlkgJiYgIUNPUlJFQ1RfSVRFUl9OQU1FKSBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIElURVJBVE9SLCAkaXRlcmF0b3IpO1xuICB9O1xufSBlbHNlIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAvKiBlbXB0eSAqL1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcblxudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG5cbnZhciAkdHlwZWQgPSByZXF1aXJlKCcuL190eXBlZCcpO1xuXG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcblxudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG5cbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcblxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbnZhciB0b0luZGV4ID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcblxudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG5cbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5cbnZhciBhcnJheUZpbGwgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJyk7XG5cbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG5cbnZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xudmFyIERBVEFfVklFVyA9ICdEYXRhVmlldyc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCEnO1xudmFyIFdST05HX0lOREVYID0gJ1dyb25nIGluZGV4ISc7XG52YXIgJEFycmF5QnVmZmVyID0gZ2xvYmFsW0FSUkFZX0JVRkZFUl07XG52YXIgJERhdGFWaWV3ID0gZ2xvYmFsW0RBVEFfVklFV107XG52YXIgTWF0aCA9IGdsb2JhbC5NYXRoO1xudmFyIFJhbmdlRXJyb3IgPSBnbG9iYWwuUmFuZ2VFcnJvcjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvdy1yZXN0cmljdGVkLW5hbWVzXG5cbnZhciBJbmZpbml0eSA9IGdsb2JhbC5JbmZpbml0eTtcbnZhciBCYXNlQnVmZmVyID0gJEFycmF5QnVmZmVyO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBMTjIgPSBNYXRoLkxOMjtcbnZhciBCVUZGRVIgPSAnYnVmZmVyJztcbnZhciBCWVRFX0xFTkdUSCA9ICdieXRlTGVuZ3RoJztcbnZhciBCWVRFX09GRlNFVCA9ICdieXRlT2Zmc2V0JztcbnZhciAkQlVGRkVSID0gREVTQ1JJUFRPUlMgPyAnX2InIDogQlVGRkVSO1xudmFyICRMRU5HVEggPSBERVNDUklQVE9SUyA/ICdfbCcgOiBCWVRFX0xFTkdUSDtcbnZhciAkT0ZGU0VUID0gREVTQ1JJUFRPUlMgPyAnX28nIDogQllURV9PRkZTRVQ7IC8vIElFRUU3NTQgY29udmVyc2lvbnMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XG5cbmZ1bmN0aW9uIHBhY2tJRUVFNzU0KHZhbHVlLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShuQnl0ZXMpO1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIHJ0ID0gbUxlbiA9PT0gMjMgPyBwb3coMiwgLTI0KSAtIHBvdygyLCAtNzcpIDogMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gMSA6IDA7XG4gIHZhciBlLCBtLCBjO1xuICB2YWx1ZSA9IGFicyh2YWx1ZSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcblxuICBpZiAodmFsdWUgIT0gdmFsdWUgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIG0gPSB2YWx1ZSAhPSB2YWx1ZSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBmbG9vcihsb2codmFsdWUpIC8gTE4yKTtcblxuICAgIGlmICh2YWx1ZSAqIChjID0gcG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogcG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBwb3coMiwgZUJpYXMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltpKytdID0gbSAmIDI1NSwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IGUgPDwgbUxlbiB8IG07XG4gIGVMZW4gKz0gbUxlbjtcblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltpKytdID0gZSAmIDI1NSwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG5cbiAgYnVmZmVyWy0taV0gfD0gcyAqIDEyODtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gdW5wYWNrSUVFRTc1NChidWZmZXIsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIG5CaXRzID0gZUxlbiAtIDc7XG4gIHZhciBpID0gbkJ5dGVzIC0gMTtcbiAgdmFyIHMgPSBidWZmZXJbaS0tXTtcbiAgdmFyIGUgPSBzICYgMTI3O1xuICB2YXIgbTtcbiAgcyA+Pj0gNztcblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcblxuICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxO1xuICBlID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IG1MZW47XG5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6IHMgPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIHBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG5cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBwb3coMiwgZSAtIG1MZW4pO1xufVxuXG5mdW5jdGlvbiB1bnBhY2tJMzIoYnl0ZXMpIHtcbiAgcmV0dXJuIGJ5dGVzWzNdIDw8IDI0IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG59XG5cbmZ1bmN0aW9uIHBhY2tJOChpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZl07XG59XG5cbmZ1bmN0aW9uIHBhY2tJMTYoaXQpIHtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmXTtcbn1cblxuZnVuY3Rpb24gcGFja0kzMihpdCkge1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmYsIGl0ID4+IDE2ICYgMHhmZiwgaXQgPj4gMjQgJiAweGZmXTtcbn1cblxuZnVuY3Rpb24gcGFja0Y2NChpdCkge1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDUyLCA4KTtcbn1cblxuZnVuY3Rpb24gcGFja0YzMihpdCkge1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDIzLCA0KTtcbn1cblxuZnVuY3Rpb24gYWRkR2V0dGVyKEMsIGtleSwgaW50ZXJuYWwpIHtcbiAgZFAoQ1tQUk9UT1RZUEVdLCBrZXksIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzW2ludGVybmFsXTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXQodmlldywgYnl0ZXMsIGluZGV4LCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXg7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgobnVtSW5kZXgpO1xuICBpZiAoaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF07XG4gIHZhciBwYWNrID0gc3RvcmUuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpO1xuICByZXR1cm4gaXNMaXR0bGVFbmRpYW4gPyBwYWNrIDogcGFjay5yZXZlcnNlKCk7XG59XG5cbmZ1bmN0aW9uIHNldCh2aWV3LCBieXRlcywgaW5kZXgsIGNvbnZlcnNpb24sIHZhbHVlLCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXg7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgobnVtSW5kZXgpO1xuICBpZiAoaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF07XG4gIHZhciBwYWNrID0gY29udmVyc2lvbigrdmFsdWUpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXM7IGkrKykgc3RvcmVbc3RhcnQgKyBpXSA9IHBhY2tbaXNMaXR0bGVFbmRpYW4gPyBpIDogYnl0ZXMgLSBpIC0gMV07XG59XG5cbmlmICghJHR5cGVkLkFCVikge1xuICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRvSW5kZXgobGVuZ3RoKTtcbiAgICB0aGlzLl9iID0gYXJyYXlGaWxsLmNhbGwobmV3IEFycmF5KGJ5dGVMZW5ndGgpLCAwKTtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICAkRGF0YVZpZXcgPSBmdW5jdGlvbiBEYXRhVmlldyhidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICBhbkluc3RhbmNlKHRoaXMsICREYXRhVmlldywgREFUQV9WSUVXKTtcbiAgICBhbkluc3RhbmNlKGJ1ZmZlciwgJEFycmF5QnVmZmVyLCBEQVRBX1ZJRVcpO1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBidWZmZXJbJExFTkdUSF07XG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihieXRlT2Zmc2V0KTtcbiAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gYnVmZmVyTGVuZ3RoIC0gb2Zmc2V0IDogdG9MZW5ndGgoYnl0ZUxlbmd0aCk7XG4gICAgaWYgKG9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB0aGlzWyRCVUZGRVJdID0gYnVmZmVyO1xuICAgIHRoaXNbJE9GRlNFVF0gPSBvZmZzZXQ7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgaWYgKERFU0NSSVBUT1JTKSB7XG4gICAgYWRkR2V0dGVyKCRBcnJheUJ1ZmZlciwgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJVRkZFUiwgJ19iJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfT0ZGU0VULCAnX28nKTtcbiAgfVxuXG4gIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgZ2V0SW50ODogZnVuY3Rpb24gZ2V0SW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdIDw8IDI0ID4+IDI0O1xuICAgIH0sXG4gICAgZ2V0VWludDg6IGZ1bmN0aW9uIGdldFVpbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF07XG4gICAgfSxcbiAgICBnZXRJbnQxNjogZnVuY3Rpb24gZ2V0SW50MTYoYnl0ZU9mZnNldFxuICAgIC8qICwgbGl0dGxlRW5kaWFuICovXG4gICAgKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiAoYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdKSA8PCAxNiA+PiAxNjtcbiAgICB9LFxuICAgIGdldFVpbnQxNjogZnVuY3Rpb24gZ2V0VWludDE2KGJ5dGVPZmZzZXRcbiAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICkge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MzI6IGZ1bmN0aW9uIGdldEludDMyKGJ5dGVPZmZzZXRcbiAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICkge1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSk7XG4gICAgfSxcbiAgICBnZXRVaW50MzI6IGZ1bmN0aW9uIGdldFVpbnQzMihieXRlT2Zmc2V0XG4gICAgLyogLCBsaXR0bGVFbmRpYW4gKi9cbiAgICApIHtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpID4+PiAwO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0XG4gICAgLyogLCBsaXR0bGVFbmRpYW4gKi9cbiAgICApIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCAyMywgNCk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXRcbiAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICkge1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDUyLCA4KTtcbiAgICB9LFxuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0SW50MTY6IGZ1bmN0aW9uIHNldEludDE2KGJ5dGVPZmZzZXQsIHZhbHVlXG4gICAgLyogLCBsaXR0bGVFbmRpYW4gKi9cbiAgICApIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQxNjogZnVuY3Rpb24gc2V0VWludDE2KGJ5dGVPZmZzZXQsIHZhbHVlXG4gICAgLyogLCBsaXR0bGVFbmRpYW4gKi9cbiAgICApIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEludDMyOiBmdW5jdGlvbiBzZXRJbnQzMihieXRlT2Zmc2V0LCB2YWx1ZVxuICAgIC8qICwgbGl0dGxlRW5kaWFuICovXG4gICAgKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MzI6IGZ1bmN0aW9uIHNldFVpbnQzMihieXRlT2Zmc2V0LCB2YWx1ZVxuICAgIC8qICwgbGl0dGxlRW5kaWFuICovXG4gICAgKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDMyOiBmdW5jdGlvbiBzZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIHZhbHVlXG4gICAgLyogLCBsaXR0bGVFbmRpYW4gKi9cbiAgICApIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrRjMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0NjQ6IGZ1bmN0aW9uIHNldEZsb2F0NjQoYnl0ZU9mZnNldCwgdmFsdWVcbiAgICAvKiAsIGxpdHRsZUVuZGlhbiAqL1xuICAgICkge1xuICAgICAgc2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIHBhY2tGNjQsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBpZiAoIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAkQXJyYXlCdWZmZXIoMSk7XG4gIH0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3ICRBcnJheUJ1ZmZlcigtMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH0pIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgJEFycmF5QnVmZmVyKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG5cbiAgICBuZXcgJEFycmF5QnVmZmVyKDEuNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG5cbiAgICBuZXcgJEFycmF5QnVmZmVyKE5hTik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG5cbiAgICByZXR1cm4gJEFycmF5QnVmZmVyLm5hbWUgIT0gQVJSQVlfQlVGRkVSO1xuICB9KSkge1xuICAgICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgICAgYW5JbnN0YW5jZSh0aGlzLCAkQXJyYXlCdWZmZXIpO1xuICAgICAgcmV0dXJuIG5ldyBCYXNlQnVmZmVyKHRvSW5kZXgobGVuZ3RoKSk7XG4gICAgfTtcblxuICAgIHZhciBBcnJheUJ1ZmZlclByb3RvID0gJEFycmF5QnVmZmVyW1BST1RPVFlQRV0gPSBCYXNlQnVmZmVyW1BST1RPVFlQRV07XG5cbiAgICBmb3IgKHZhciBrZXlzID0gZ09QTihCYXNlQnVmZmVyKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOykge1xuICAgICAgaWYgKCEoKGtleSA9IGtleXNbaisrXSkgaW4gJEFycmF5QnVmZmVyKSkgaGlkZSgkQXJyYXlCdWZmZXIsIGtleSwgQmFzZUJ1ZmZlcltrZXldKTtcbiAgICB9XG5cbiAgICBpZiAoIUxJQlJBUlkpIEFycmF5QnVmZmVyUHJvdG8uY29uc3RydWN0b3IgPSAkQXJyYXlCdWZmZXI7XG4gIH0gLy8gaU9TIFNhZmFyaSA3LnggYnVnXG5cblxuICB2YXIgdmlldyA9IG5ldyAkRGF0YVZpZXcobmV3ICRBcnJheUJ1ZmZlcigyKSk7XG4gIHZhciAkc2V0SW50OCA9ICREYXRhVmlld1tQUk9UT1RZUEVdLnNldEludDg7XG4gIHZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgdmlldy5zZXRJbnQ4KDEsIDIxNDc0ODM2NDkpO1xuICBpZiAodmlldy5nZXRJbnQ4KDApIHx8ICF2aWV3LmdldEludDgoMSkpIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG59XG5cbnNldFRvU3RyaW5nVGFnKCRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbnNldFRvU3RyaW5nVGFnKCREYXRhVmlldywgREFUQV9WSUVXKTtcbmhpZGUoJERhdGFWaWV3W1BST1RPVFlQRV0sICR0eXBlZC5WSUVXLCB0cnVlKTtcbmV4cG9ydHNbQVJSQVlfQlVGRkVSXSA9ICRBcnJheUJ1ZmZlcjtcbmV4cG9ydHNbREFUQV9WSUVXXSA9ICREYXRhVmlldzsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xuXG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5cbnZhciBUWVBFRCA9IHVpZCgndHlwZWRfYXJyYXknKTtcbnZhciBWSUVXID0gdWlkKCd2aWV3Jyk7XG52YXIgQUJWID0gISEoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGdsb2JhbC5EYXRhVmlldyk7XG52YXIgQ09OU1RSID0gQUJWO1xudmFyIGkgPSAwO1xudmFyIGwgPSA5O1xudmFyIFR5cGVkO1xudmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMgPSAnSW50OEFycmF5LFVpbnQ4QXJyYXksVWludDhDbGFtcGVkQXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXknLnNwbGl0KCcsJyk7XG5cbndoaWxlIChpIDwgbCkge1xuICBpZiAoVHlwZWQgPSBnbG9iYWxbVHlwZWRBcnJheUNvbnN0cnVjdG9yc1tpKytdXSkge1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBUWVBFRCwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICB9IGVsc2UgQ09OU1RSID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBQlY6IEFCVixcbiAgQ09OU1RSOiBDT05TVFIsXG4gIFRZUEVEOiBUWVBFRCxcbiAgVklFVzogVklFV1xufTsiLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59OyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyIG5hdmlnYXRvciA9IGdsb2JhbC5uYXZpZ2F0b3I7XG5tb2R1bGUuZXhwb3J0cyA9IG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnOyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVFlQRSkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSB8fCBpdC5fdCAhPT0gVFlQRSkgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xuXG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcblxudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSkgZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwge1xuICAgIHZhbHVlOiB3a3NFeHQuZihuYW1lKVxuICB9KTtcbn07IiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7IiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xuXG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5cbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG5cbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPSBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTsiLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcblxudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG5cbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXSB8fCBpdFsnQEBpdGVyYXRvciddIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZW5qYW1pbmdyL1JleEV4cC5lc2NhcGVcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkcmUgPSByZXF1aXJlKCcuL19yZXBsYWNlcicpKC9bXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZ0V4cCcsIHtcbiAgZXNjYXBlOiBmdW5jdGlvbiBlc2NhcGUoaXQpIHtcbiAgICByZXR1cm4gJHJlKGl0KTtcbiAgfVxufSk7IiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBjb3B5V2l0aGluOiByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpXG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2NvcHlXaXRoaW4nKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkZXZlcnkgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNCk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5ldmVyeSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjUgLyAxNS40LjQuMTYgQXJyYXkucHJvdG90eXBlLmV2ZXJ5KGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuXG4gIC8qICwgdGhpc0FyZyAqL1xuICApIHtcbiAgICByZXR1cm4gJGV2ZXJ5KHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIi8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgZmlsbDogcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpXG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2ZpbGwnKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkZmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDIpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZmlsdGVyLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNyAvIDE1LjQuNC4yMCBBcnJheS5wcm90b3R5cGUuZmlsdGVyKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm5cbiAgLyogLCB0aGlzQXJnICovXG4gICkge1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gMjIuMS4zLjkgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkZmluZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg2KTtcblxudmFyIEtFWSA9ICdmaW5kSW5kZXgnO1xudmFyIGZvcmNlZCA9IHRydWU7IC8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5cbmlmIChLRVkgaW4gW10pIEFycmF5KDEpW0tFWV0oZnVuY3Rpb24gKCkge1xuICBmb3JjZWQgPSBmYWxzZTtcbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgoY2FsbGJhY2tmblxuICAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi9cbiAgKSB7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkZmluZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg1KTtcblxudmFyIEtFWSA9ICdmaW5kJztcbnZhciBmb3JjZWQgPSB0cnVlOyAvLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuXG5pZiAoS0VZIGluIFtdKSBBcnJheSgxKVtLRVldKGZ1bmN0aW9uICgpIHtcbiAgZm9yY2VkID0gZmFsc2U7XG59KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2tmblxuICAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi9cbiAgKSB7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJGZvckVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG5cbnZhciBTVFJJQ1QgPSByZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZm9yRWFjaCwgdHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIVNUUklDVCwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTAgLyAxNS40LjQuMTggQXJyYXkucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuXG4gIC8qICwgdGhpc0FyZyAqL1xuICApIHtcbiAgICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xuXG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcblxudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgQXJyYXkuZnJvbShpdGVyKTtcbn0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2VcbiAgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqL1xuICApIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gICAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5O1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbWFwZm4gPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgaXRlckZuID0gZ2V0SXRlckZuKE8pO1xuICAgIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYgKG1hcHBpbmcpIG1hcGZuID0gY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7IC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuXG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKSB7XG4gICAgICBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHJlc3VsdCA9IG5ldyBDKCk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gY2FsbChpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcblxuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJGluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcblxudmFyICRuYXRpdmUgPSBbXS5pbmRleE9mO1xudmFyIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5pbmRleE9mKDEsIC0wKSA8IDA7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMSAvIDE1LjQuNC4xNCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudFxuICAvKiAsIGZyb21JbmRleCA9IDAgKi9cbiAgKSB7XG4gICAgcmV0dXJuIE5FR0FUSVZFX1pFUk8gLy8gY29udmVydCAtMCB0byArMFxuICAgID8gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDAgOiAkaW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCIvLyAyMi4xLjIuMiAvIDE1LjQuMy4yIEFycmF5LmlzQXJyYXkoYXJnKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdBcnJheScsIHtcbiAgaXNBcnJheTogcmVxdWlyZSgnLi9faXMtYXJyYXknKVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xuXG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xuXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5cbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7IC8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG5cbiAgdGhpcy5faSA9IDA7IC8vIG5leHQgaW5kZXhcblxuICB0aGlzLl9rID0ga2luZDsgLy8ga2luZFxuICAvLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIga2luZCA9IHRoaXMuX2s7XG4gIHZhciBpbmRleCA9IHRoaXMuX2krKztcblxuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG5cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTsgLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7IiwiJ3VzZSBzdHJpY3QnOyAvLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmpvaW4oc2VwYXJhdG9yKVxuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG52YXIgYXJyYXlKb2luID0gW10uam9pbjsgLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIHN0cmluZ3NcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAocmVxdWlyZSgnLi9faW9iamVjdCcpICE9IE9iamVjdCB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKGFycmF5Sm9pbikpLCAnQXJyYXknLCB7XG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRvSU9iamVjdCh0aGlzKSwgc2VwYXJhdG9yID09PSB1bmRlZmluZWQgPyAnLCcgOiBzZXBhcmF0b3IpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG52YXIgJG5hdGl2ZSA9IFtdLmxhc3RJbmRleE9mO1xudmFyIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5sYXN0SW5kZXhPZigxLCAtMCkgPCAwO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTQgLyAxNS40LjQuMTUgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnRcbiAgLyogLCBmcm9tSW5kZXggPSBAWyotMV0gKi9cbiAgKSB7XG4gICAgLy8gY29udmVydCAtMCB0byArMFxuICAgIGlmIChORUdBVElWRV9aRVJPKSByZXR1cm4gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDA7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QodGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSkpO1xuICAgIGlmIChpbmRleCA8IDApIGluZGV4ID0gbGVuZ3RoICsgaW5kZXg7XG5cbiAgICBmb3IgKDsgaW5kZXggPj0gMDsgaW5kZXgtLSkgaWYgKGluZGV4IGluIE8pIGlmIChPW2luZGV4XSA9PT0gc2VhcmNoRWxlbWVudCkgcmV0dXJuIGluZGV4IHx8IDA7XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRtYXAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5tYXAsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNSAvIDE1LjQuNC4xOSBBcnJheS5wcm90b3R5cGUubWFwKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm5cbiAgLyogLCB0aGlzQXJnICovXG4gICkge1xuICAgIHJldHVybiAkbWFwKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7IC8vIFdlYktpdCBBcnJheS5vZiBpc24ndCBnZW5lcmljXG5cblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9XG5cbiAgcmV0dXJuICEoQXJyYXkub2YuY2FsbChGKSBpbnN0YW5jZW9mIEYpO1xufSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjMgQXJyYXkub2YoIC4uLml0ZW1zKVxuICBvZjogZnVuY3Rpb24gb2YoKVxuICAvKiAuLi5hcmdzICovXG4gIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gbmV3ICh0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5KShhTGVuKTtcblxuICAgIHdoaWxlIChhTGVuID4gaW5kZXgpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIGFyZ3VtZW50c1tpbmRleCsrXSk7XG5cbiAgICByZXN1bHQubGVuZ3RoID0gYUxlbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2VSaWdodCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE5IC8gMTUuNC40LjIyIEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodChjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuXG4gIC8qICwgaW5pdGlhbFZhbHVlICovXG4gICkge1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgdHJ1ZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE4IC8gMTUuNC40LjIxIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuXG4gIC8qICwgaW5pdGlhbFZhbHVlICovXG4gICkge1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgZmFsc2UpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBodG1sID0gcmVxdWlyZSgnLi9faHRtbCcpO1xuXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5cbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxudmFyIGFycmF5U2xpY2UgPSBbXS5zbGljZTsgLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmdzIGFuZCBET00gb2JqZWN0c1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICBpZiAoaHRtbCkgYXJyYXlTbGljZS5jYWxsKGh0bWwpO1xufSksICdBcnJheScsIHtcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKGJlZ2luLCBlbmQpIHtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgodGhpcy5sZW5ndGgpO1xuICAgIHZhciBrbGFzcyA9IGNvZih0aGlzKTtcbiAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZDtcbiAgICBpZiAoa2xhc3MgPT0gJ0FycmF5JykgcmV0dXJuIGFycmF5U2xpY2UuY2FsbCh0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB2YXIgc3RhcnQgPSB0b0Fic29sdXRlSW5kZXgoYmVnaW4sIGxlbik7XG4gICAgdmFyIHVwVG8gPSB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW4pO1xuICAgIHZhciBzaXplID0gdG9MZW5ndGgodXBUbyAtIHN0YXJ0KTtcbiAgICB2YXIgY2xvbmVkID0gbmV3IEFycmF5KHNpemUpO1xuICAgIHZhciBpID0gMDtcblxuICAgIGZvciAoOyBpIDwgc2l6ZTsgaSsrKSBjbG9uZWRbaV0gPSBrbGFzcyA9PSAnU3RyaW5nJyA/IHRoaXMuY2hhckF0KHN0YXJ0ICsgaSkgOiB0aGlzW3N0YXJ0ICsgaV07XG5cbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkc29tZSA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgzKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnNvbWUsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4yMyAvIDE1LjQuNC4xNyBBcnJheS5wcm90b3R5cGUuc29tZShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm5cbiAgLyogLCB0aGlzQXJnICovXG4gICkge1xuICAgIHJldHVybiAkc29tZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG52YXIgJHNvcnQgPSBbXS5zb3J0O1xudmFyIHRlc3QgPSBbMSwgMiwgM107XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIElFOC1cbiAgdGVzdC5zb3J0KHVuZGVmaW5lZCk7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBWOCBidWdcbiAgdGVzdC5zb3J0KG51bGwpOyAvLyBPbGQgV2ViS2l0XG59KSB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRzb3J0KSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjI1IEFycmF5LnByb3RvdHlwZS5zb3J0KGNvbXBhcmVmbilcbiAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICByZXR1cm4gY29tcGFyZWZuID09PSB1bmRlZmluZWQgPyAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpKSA6ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcyksIGFGdW5jdGlvbihjb21wYXJlZm4pKTtcbiAgfVxufSk7IiwicmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnQXJyYXknKTsiLCIvLyAyMC4zLjMuMSAvIDE1LjkuNC40IERhdGUubm93KClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRGF0ZScsIHtcbiAgbm93OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9XG59KTsiLCIvLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHRvSVNPU3RyaW5nID0gcmVxdWlyZSgnLi9fZGF0ZS10by1pc28tc3RyaW5nJyk7IC8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xuXG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICE9PSB0b0lTT1N0cmluZyksICdEYXRlJywge1xuICB0b0lTT1N0cmluZzogdG9JU09TdHJpbmdcbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IERhdGUoTmFOKS50b0pTT04oKSAhPT0gbnVsbCB8fCBEYXRlLnByb3RvdHlwZS50b0pTT04uY2FsbCh7XG4gICAgdG9JU09TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSkgIT09IDE7XG59KSwgJ0RhdGUnLCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTihrZXkpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBwdiA9IHRvUHJpbWl0aXZlKE8pO1xuICAgIHJldHVybiB0eXBlb2YgcHYgPT0gJ251bWJlcicgJiYgIWlzRmluaXRlKHB2KSA/IG51bGwgOiBPLnRvSVNPU3RyaW5nKCk7XG4gIH1cbn0pOyIsInZhciBUT19QUklNSVRJVkUgPSByZXF1aXJlKCcuL193a3MnKSgndG9QcmltaXRpdmUnKTtcblxudmFyIHByb3RvID0gRGF0ZS5wcm90b3R5cGU7XG5pZiAoIShUT19QUklNSVRJVkUgaW4gcHJvdG8pKSByZXF1aXJlKCcuL19oaWRlJykocHJvdG8sIFRPX1BSSU1JVElWRSwgcmVxdWlyZSgnLi9fZGF0ZS10by1wcmltaXRpdmUnKSk7IiwidmFyIERhdGVQcm90byA9IERhdGUucHJvdG90eXBlO1xudmFyIElOVkFMSURfREFURSA9ICdJbnZhbGlkIERhdGUnO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgJHRvU3RyaW5nID0gRGF0ZVByb3RvW1RPX1NUUklOR107XG52YXIgZ2V0VGltZSA9IERhdGVQcm90by5nZXRUaW1lO1xuXG5pZiAobmV3IERhdGUoTmFOKSArICcnICE9IElOVkFMSURfREFURSkge1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKERhdGVQcm90bywgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgdmFsdWUgPSBnZXRUaW1lLmNhbGwodGhpcyk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcblxuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyAkdG9TdHJpbmcuY2FsbCh0aGlzKSA6IElOVkFMSURfREFURTtcbiAgfSk7XG59IiwiLy8gMTkuMi4zLjIgLyAxNS4zLjQuNSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCh0aGlzQXJnLCBhcmdzLi4uKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdGdW5jdGlvbicsIHtcbiAgYmluZDogcmVxdWlyZSgnLi9fYmluZCcpXG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnZhciBIQVNfSU5TVEFOQ0UgPSByZXF1aXJlKCcuL193a3MnKSgnaGFzSW5zdGFuY2UnKTtcblxudmFyIEZ1bmN0aW9uUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7IC8vIDE5LjIuMy42IEZ1bmN0aW9uLnByb3RvdHlwZVtAQGhhc0luc3RhbmNlXShWKVxuXG5pZiAoIShIQVNfSU5TVEFOQ0UgaW4gRnVuY3Rpb25Qcm90bykpIHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoRnVuY3Rpb25Qcm90bywgSEFTX0lOU1RBTkNFLCB7XG4gIHZhbHVlOiBmdW5jdGlvbiAoTykge1xuICAgIGlmICh0eXBlb2YgdGhpcyAhPSAnZnVuY3Rpb24nIHx8ICFpc09iamVjdChPKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghaXNPYmplY3QodGhpcy5wcm90b3R5cGUpKSByZXR1cm4gTyBpbnN0YW5jZW9mIHRoaXM7IC8vIGZvciBlbnZpcm9ubWVudCB3L28gbmF0aXZlIGBAQGhhc0luc3RhbmNlYCBsb2dpYyBlbm91Z2ggYGluc3RhbmNlb2ZgLCBidXQgYWRkIHRoaXM6XG5cbiAgICB3aGlsZSAoTyA9IGdldFByb3RvdHlwZU9mKE8pKSBpZiAodGhpcy5wcm90b3R5cGUgPT09IE8pIHJldHVybiB0cnVlO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KTsiLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xuXG52YXIgRlByb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIG5hbWVSRSA9IC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopLztcbnZhciBOQU1FID0gJ25hbWUnOyAvLyAxOS4yLjQuMiBuYW1lXG5cbk5BTUUgaW4gRlByb3RvIHx8IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgZFAoRlByb3RvLCBOQU1FLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoJycgKyB0aGlzKS5tYXRjaChuYW1lUkUpWzFdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcblxudmFyIE1BUCA9ICdNYXAnOyAvLyAyMy4xIE1hcCBPYmplY3RzXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKE1BUCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCkge1xuICAgIHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgTUFQKSwga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcsIHRydWUpOyIsIi8vIDIwLjIuMi4zIE1hdGguYWNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBsb2cxcCA9IHJlcXVpcmUoJy4vX21hdGgtbG9nMXAnKTtcblxudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgJGFjb3NoID0gTWF0aC5hY29zaDtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYWNvc2ggLy8gVjggYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzUwOVxuJiYgTWF0aC5mbG9vcigkYWNvc2goTnVtYmVyLk1BWF9WQUxVRSkpID09IDcxMCAvLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYWNvc2goSW5maW5pdHkpIC0+IE5hTlxuJiYgJGFjb3NoKEluZmluaXR5KSA9PSBJbmZpbml0eSksICdNYXRoJywge1xuICBhY29zaDogZnVuY3Rpb24gYWNvc2goeCkge1xuICAgIHJldHVybiAoeCA9ICt4KSA8IDEgPyBOYU4gOiB4ID4gOTQ5MDYyNjUuNjI0MjUxNTYgPyBNYXRoLmxvZyh4KSArIE1hdGguTE4yIDogbG9nMXAoeCAtIDEgKyBzcXJ0KHggLSAxKSAqIHNxcnQoeCArIDEpKTtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjUgTWF0aC5hc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRhc2luaCA9IE1hdGguYXNpbmg7XG5cbmZ1bmN0aW9uIGFzaW5oKHgpIHtcbiAgcmV0dXJuICFpc0Zpbml0ZSh4ID0gK3gpIHx8IHggPT0gMCA/IHggOiB4IDwgMCA/IC1hc2luaCgteCkgOiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4ICsgMSkpO1xufSAvLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXNpbmgoMCkgLT4gLTBcblxuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFzaW5oICYmIDEgLyAkYXNpbmgoMCkgPiAwKSwgJ01hdGgnLCB7XG4gIGFzaW5oOiBhc2luaFxufSk7IiwiLy8gMjAuMi4yLjcgTWF0aC5hdGFuaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRhdGFuaCA9IE1hdGguYXRhbmg7IC8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hdGFuaCgtMCkgLT4gMFxuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGF0YW5oICYmIDEgLyAkYXRhbmgoLTApIDwgMCksICdNYXRoJywge1xuICBhdGFuaDogZnVuY3Rpb24gYXRhbmgoeCkge1xuICAgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IE1hdGgubG9nKCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi45IE1hdGguY2JydCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHNpZ24gPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjYnJ0OiBmdW5jdGlvbiBjYnJ0KHgpIHtcbiAgICByZXR1cm4gc2lnbih4ID0gK3gpICogTWF0aC5wb3coTWF0aC5hYnMoeCksIDEgLyAzKTtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjExIE1hdGguY2x6MzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2x6MzI6IGZ1bmN0aW9uIGNsejMyKHgpIHtcbiAgICByZXR1cm4gKHggPj4+PSAwKSA/IDMxIC0gTWF0aC5mbG9vcihNYXRoLmxvZyh4ICsgMC41KSAqIE1hdGguTE9HMkUpIDogMzI7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4xMiBNYXRoLmNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBleHAgPSBNYXRoLmV4cDtcbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY29zaDogZnVuY3Rpb24gY29zaCh4KSB7XG4gICAgcmV0dXJuIChleHAoeCA9ICt4KSArIGV4cCgteCkpIC8gMjtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkZXhwbTEgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCRleHBtMSAhPSBNYXRoLmV4cG0xKSwgJ01hdGgnLCB7XG4gIGV4cG0xOiAkZXhwbTFcbn0pOyIsIi8vIDIwLjIuMi4xNiBNYXRoLmZyb3VuZCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBmcm91bmQ6IHJlcXVpcmUoJy4vX21hdGgtZnJvdW5kJylcbn0pOyIsIi8vIDIwLjIuMi4xNyBNYXRoLmh5cG90KFt2YWx1ZTFbLCB2YWx1ZTJbLCDigKYgXV1dKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGFicyA9IE1hdGguYWJzO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBoeXBvdDogZnVuY3Rpb24gaHlwb3QodmFsdWUxLCB2YWx1ZTIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbGFyZyA9IDA7XG4gICAgdmFyIGFyZywgZGl2O1xuXG4gICAgd2hpbGUgKGkgPCBhTGVuKSB7XG4gICAgICBhcmcgPSBhYnMoYXJndW1lbnRzW2krK10pO1xuXG4gICAgICBpZiAobGFyZyA8IGFyZykge1xuICAgICAgICBkaXYgPSBsYXJnIC8gYXJnO1xuICAgICAgICBzdW0gPSBzdW0gKiBkaXYgKiBkaXYgKyAxO1xuICAgICAgICBsYXJnID0gYXJnO1xuICAgICAgfSBlbHNlIGlmIChhcmcgPiAwKSB7XG4gICAgICAgIGRpdiA9IGFyZyAvIGxhcmc7XG4gICAgICAgIHN1bSArPSBkaXYgKiBkaXY7XG4gICAgICB9IGVsc2Ugc3VtICs9IGFyZztcbiAgICB9XG5cbiAgICByZXR1cm4gbGFyZyA9PT0gSW5maW5pdHkgPyBJbmZpbml0eSA6IGxhcmcgKiBNYXRoLnNxcnQoc3VtKTtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjE4IE1hdGguaW11bCh4LCB5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRpbXVsID0gTWF0aC5pbXVsOyAvLyBzb21lIFdlYktpdCB2ZXJzaW9ucyBmYWlscyB3aXRoIGJpZyBudW1iZXJzLCBzb21lIGhhcyB3cm9uZyBhcml0eVxuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJGltdWwoMHhmZmZmZmZmZiwgNSkgIT0gLTUgfHwgJGltdWwubGVuZ3RoICE9IDI7XG59KSwgJ01hdGgnLCB7XG4gIGltdWw6IGZ1bmN0aW9uIGltdWwoeCwgeSkge1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmY7XG4gICAgdmFyIHhuID0gK3g7XG4gICAgdmFyIHluID0gK3k7XG4gICAgdmFyIHhsID0gVUlOVDE2ICYgeG47XG4gICAgdmFyIHlsID0gVUlOVDE2ICYgeW47XG4gICAgcmV0dXJuIDAgfCB4bCAqIHlsICsgKChVSU5UMTYgJiB4biA+Pj4gMTYpICogeWwgKyB4bCAqIChVSU5UMTYgJiB5biA+Pj4gMTYpIDw8IDE2ID4+PiAwKTtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjIxIE1hdGgubG9nMTAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMTA6IGZ1bmN0aW9uIGxvZzEwKHgpIHtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzEwRTtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMXA6IHJlcXVpcmUoJy4vX21hdGgtbG9nMXAnKVxufSk7IiwiLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cyOiBmdW5jdGlvbiBsb2cyKHgpIHtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMjtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBzaWduOiByZXF1aXJlKCcuL19tYXRoLXNpZ24nKVxufSk7IiwiLy8gMjAuMi4yLjMwIE1hdGguc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGV4cG0xID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xuXG52YXIgZXhwID0gTWF0aC5leHA7IC8vIFY4IG5lYXIgQ2hyb21pdW0gMzggaGFzIGEgcHJvYmxlbSB3aXRoIHZlcnkgc21hbGwgbnVtYmVyc1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIU1hdGguc2luaCgtMmUtMTcpICE9IC0yZS0xNztcbn0pLCAnTWF0aCcsIHtcbiAgc2luaDogZnVuY3Rpb24gc2luaCh4KSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggPSAreCkgPCAxID8gKGV4cG0xKHgpIC0gZXhwbTEoLXgpKSAvIDIgOiAoZXhwKHggLSAxKSAtIGV4cCgteCAtIDEpKSAqIChNYXRoLkUgLyAyKTtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjMzIE1hdGgudGFuaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGV4cG0xID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xuXG52YXIgZXhwID0gTWF0aC5leHA7XG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRhbmg6IGZ1bmN0aW9uIHRhbmgoeCkge1xuICAgIHZhciBhID0gZXhwbTEoeCA9ICt4KTtcbiAgICB2YXIgYiA9IGV4cG0xKC14KTtcbiAgICByZXR1cm4gYSA9PSBJbmZpbml0eSA/IDEgOiBiID09IEluZmluaXR5ID8gLTEgOiAoYSAtIGIpIC8gKGV4cCh4KSArIGV4cCgteCkpO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMzQgTWF0aC50cnVuYyh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0cnVuYzogZnVuY3Rpb24gdHJ1bmMoaXQpIHtcbiAgICByZXR1cm4gKGl0ID4gMCA/IE1hdGguZmxvb3IgOiBNYXRoLmNlaWwpKGl0KTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcblxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuXG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG5cbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcblxudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5cbnZhciAkdHJpbSA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcblxudmFyIE5VTUJFUiA9ICdOdW1iZXInO1xudmFyICROdW1iZXIgPSBnbG9iYWxbTlVNQkVSXTtcbnZhciBCYXNlID0gJE51bWJlcjtcbnZhciBwcm90byA9ICROdW1iZXIucHJvdG90eXBlOyAvLyBPcGVyYSB+MTIgaGFzIGJyb2tlbiBPYmplY3QjdG9TdHJpbmdcblxudmFyIEJST0tFTl9DT0YgPSBjb2YocmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpKHByb3RvKSkgPT0gTlVNQkVSO1xudmFyIFRSSU0gPSAoJ3RyaW0nIGluIFN0cmluZy5wcm90b3R5cGUpOyAvLyA3LjEuMyBUb051bWJlcihhcmd1bWVudClcblxudmFyIHRvTnVtYmVyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBpdCA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCBmYWxzZSk7XG5cbiAgaWYgKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyAmJiBpdC5sZW5ndGggPiAyKSB7XG4gICAgaXQgPSBUUklNID8gaXQudHJpbSgpIDogJHRyaW0oaXQsIDMpO1xuICAgIHZhciBmaXJzdCA9IGl0LmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIHRoaXJkLCByYWRpeCwgbWF4Q29kZTtcblxuICAgIGlmIChmaXJzdCA9PT0gNDMgfHwgZmlyc3QgPT09IDQ1KSB7XG4gICAgICB0aGlyZCA9IGl0LmNoYXJDb2RlQXQoMik7XG4gICAgICBpZiAodGhpcmQgPT09IDg4IHx8IHRoaXJkID09PSAxMjApIHJldHVybiBOYU47IC8vIE51bWJlcignKzB4MScpIHNob3VsZCBiZSBOYU4sIG9sZCBWOCBmaXhcbiAgICB9IGVsc2UgaWYgKGZpcnN0ID09PSA0OCkge1xuICAgICAgc3dpdGNoIChpdC5jaGFyQ29kZUF0KDEpKSB7XG4gICAgICAgIGNhc2UgNjY6XG4gICAgICAgIGNhc2UgOTg6XG4gICAgICAgICAgcmFkaXggPSAyO1xuICAgICAgICAgIG1heENvZGUgPSA0OTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gZmFzdCBlcXVhbCAvXjBiWzAxXSskL2lcblxuICAgICAgICBjYXNlIDc5OlxuICAgICAgICBjYXNlIDExMTpcbiAgICAgICAgICByYWRpeCA9IDg7XG4gICAgICAgICAgbWF4Q29kZSA9IDU1O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBmYXN0IGVxdWFsIC9eMG9bMC03XSskL2lcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAraXQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGRpZ2l0cyA9IGl0LnNsaWNlKDIpLCBpID0gMCwgbCA9IGRpZ2l0cy5sZW5ndGgsIGNvZGU7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29kZSA9IGRpZ2l0cy5jaGFyQ29kZUF0KGkpOyAvLyBwYXJzZUludCBwYXJzZXMgYSBzdHJpbmcgdG8gYSBmaXJzdCB1bmF2YWlsYWJsZSBzeW1ib2xcbiAgICAgICAgLy8gYnV0IFRvTnVtYmVyIHNob3VsZCByZXR1cm4gTmFOIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHVuYXZhaWxhYmxlIHN5bWJvbHNcblxuICAgICAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKSByZXR1cm4gTmFOO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VJbnQoZGlnaXRzLCByYWRpeCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICtpdDtcbn07XG5cbmlmICghJE51bWJlcignIDBvMScpIHx8ICEkTnVtYmVyKCcwYjEnKSB8fCAkTnVtYmVyKCcrMHgxJykpIHtcbiAgJE51bWJlciA9IGZ1bmN0aW9uIE51bWJlcih2YWx1ZSkge1xuICAgIHZhciBpdCA9IGFyZ3VtZW50cy5sZW5ndGggPCAxID8gMCA6IHZhbHVlO1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gdGhhdCBpbnN0YW5jZW9mICROdW1iZXIgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgJiYgKEJST0tFTl9DT0YgPyBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICBwcm90by52YWx1ZU9mLmNhbGwodGhhdCk7XG4gICAgfSkgOiBjb2YodGhhdCkgIT0gTlVNQkVSKSA/IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlKHRvTnVtYmVyKGl0KSksIHRoYXQsICROdW1iZXIpIDogdG9OdW1iZXIoaXQpO1xuICB9O1xuXG4gIGZvciAodmFyIGtleXMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QTihCYXNlKSA6ICggLy8gRVMzOlxuICAnTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFksJyArIC8vIEVTNiAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTNiBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAnRVBTSUxPTixpc0Zpbml0ZSxpc0ludGVnZXIsaXNOYU4saXNTYWZlSW50ZWdlcixNQVhfU0FGRV9JTlRFR0VSLCcgKyAnTUlOX1NBRkVfSU5URUdFUixwYXJzZUZsb2F0LHBhcnNlSW50LGlzSW50ZWdlcicpLnNwbGl0KCcsJyksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgaisrKSB7XG4gICAgaWYgKGhhcyhCYXNlLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzKCROdW1iZXIsIGtleSkpIHtcbiAgICAgIGRQKCROdW1iZXIsIGtleSwgZ09QRChCYXNlLCBrZXkpKTtcbiAgICB9XG4gIH1cblxuICAkTnVtYmVyLnByb3RvdHlwZSA9IHByb3RvO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICROdW1iZXI7XG5cbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShnbG9iYWwsIE5VTUJFUiwgJE51bWJlcik7XG59IiwiLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBFUFNJTE9OOiBNYXRoLnBvdygyLCAtNTIpXG59KTsiLCIvLyAyMC4xLjIuMiBOdW1iZXIuaXNGaW5pdGUobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIF9pc0Zpbml0ZSA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmlzRmluaXRlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNGaW5pdGU6IGZ1bmN0aW9uIGlzRmluaXRlKGl0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnbnVtYmVyJyAmJiBfaXNGaW5pdGUoaXQpO1xuICB9XG59KTsiLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc0ludGVnZXI6IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKVxufSk7IiwiLy8gMjAuMS4yLjQgTnVtYmVyLmlzTmFOKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc05hTjogZnVuY3Rpb24gaXNOYU4obnVtYmVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJldHVybiBudW1iZXIgIT0gbnVtYmVyO1xuICB9XG59KTsiLCIvLyAyMC4xLjIuNSBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpO1xuXG52YXIgYWJzID0gTWF0aC5hYnM7XG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNTYWZlSW50ZWdlcjogZnVuY3Rpb24gaXNTYWZlSW50ZWdlcihudW1iZXIpIHtcbiAgICByZXR1cm4gaXNJbnRlZ2VyKG51bWJlcikgJiYgYWJzKG51bWJlcikgPD0gMHgxZmZmZmZmZmZmZmZmZjtcbiAgfVxufSk7IiwiLy8gMjAuMS4yLjYgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBNQVhfU0FGRV9JTlRFR0VSOiAweDFmZmZmZmZmZmZmZmZmXG59KTsiLCIvLyAyMC4xLjIuMTAgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBNSU5fU0FGRV9JTlRFR0VSOiAtMHgxZmZmZmZmZmZmZmZmZlxufSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTsgLy8gMjAuMS4yLjEyIE51bWJlci5wYXJzZUZsb2F0KHN0cmluZylcblxuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksICdOdW1iZXInLCB7XG4gIHBhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0XG59KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7IC8vIDIwLjEuMi4xMyBOdW1iZXIucGFyc2VJbnQoc3RyaW5nLCByYWRpeClcblxuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VJbnQgIT0gJHBhcnNlSW50KSwgJ051bWJlcicsIHtcbiAgcGFyc2VJbnQ6ICRwYXJzZUludFxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xuXG52YXIgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKTtcblxudmFyIHJlcGVhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKTtcblxudmFyICR0b0ZpeGVkID0gMS4wLnRvRml4ZWQ7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIGRhdGEgPSBbMCwgMCwgMCwgMCwgMCwgMF07XG52YXIgRVJST1IgPSAnTnVtYmVyLnRvRml4ZWQ6IGluY29ycmVjdCBpbnZvY2F0aW9uISc7XG52YXIgWkVSTyA9ICcwJztcblxudmFyIG11bHRpcGx5ID0gZnVuY3Rpb24gKG4sIGMpIHtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIGMyID0gYztcblxuICB3aGlsZSAoKytpIDwgNikge1xuICAgIGMyICs9IG4gKiBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBjMiAlIDFlNztcbiAgICBjMiA9IGZsb29yKGMyIC8gMWU3KTtcbiAgfVxufTtcblxudmFyIGRpdmlkZSA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciBpID0gNjtcbiAgdmFyIGMgPSAwO1xuXG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIGMgKz0gZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gZmxvb3IoYyAvIG4pO1xuICAgIGMgPSBjICUgbiAqIDFlNztcbiAgfVxufTtcblxudmFyIG51bVRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaSA9IDY7XG4gIHZhciBzID0gJyc7XG5cbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgaWYgKHMgIT09ICcnIHx8IGkgPT09IDAgfHwgZGF0YVtpXSAhPT0gMCkge1xuICAgICAgdmFyIHQgPSBTdHJpbmcoZGF0YVtpXSk7XG4gICAgICBzID0gcyA9PT0gJycgPyB0IDogcyArIHJlcGVhdC5jYWxsKFpFUk8sIDcgLSB0Lmxlbmd0aCkgKyB0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzO1xufTtcblxudmFyIHBvdyA9IGZ1bmN0aW9uICh4LCBuLCBhY2MpIHtcbiAgcmV0dXJuIG4gPT09IDAgPyBhY2MgOiBuICUgMiA9PT0gMSA/IHBvdyh4LCBuIC0gMSwgYWNjICogeCkgOiBwb3coeCAqIHgsIG4gLyAyLCBhY2MpO1xufTtcblxudmFyIGxvZyA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBuID0gMDtcbiAgdmFyIHgyID0geDtcblxuICB3aGlsZSAoeDIgPj0gNDA5Nikge1xuICAgIG4gKz0gMTI7XG4gICAgeDIgLz0gNDA5NjtcbiAgfVxuXG4gIHdoaWxlICh4MiA+PSAyKSB7XG4gICAgbiArPSAxO1xuICAgIHgyIC89IDI7XG4gIH1cblxuICByZXR1cm4gbjtcbn07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKCEhJHRvRml4ZWQgJiYgKDAuMDAwMDgudG9GaXhlZCgzKSAhPT0gJzAuMDAwJyB8fCAwLjkudG9GaXhlZCgwKSAhPT0gJzEnIHx8IDEuMjU1LnRvRml4ZWQoMikgIT09ICcxLjI1JyB8fCAxMDAwMDAwMDAwMDAwMDAwMTI4LjAudG9GaXhlZCgwKSAhPT0gJzEwMDAwMDAwMDAwMDAwMDAxMjgnKSB8fCAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIC8vIFY4IH4gQW5kcm9pZCA0LjMtXG4gICR0b0ZpeGVkLmNhbGwoe30pO1xufSkpLCAnTnVtYmVyJywge1xuICB0b0ZpeGVkOiBmdW5jdGlvbiB0b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgdmFyIHggPSBhTnVtYmVyVmFsdWUodGhpcywgRVJST1IpO1xuICAgIHZhciBmID0gdG9JbnRlZ2VyKGZyYWN0aW9uRGlnaXRzKTtcbiAgICB2YXIgcyA9ICcnO1xuICAgIHZhciBtID0gWkVSTztcbiAgICB2YXIgZSwgeiwgaiwgaztcbiAgICBpZiAoZiA8IDAgfHwgZiA+IDIwKSB0aHJvdyBSYW5nZUVycm9yKEVSUk9SKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuXG4gICAgaWYgKHggIT0geCkgcmV0dXJuICdOYU4nO1xuICAgIGlmICh4IDw9IC0xZTIxIHx8IHggPj0gMWUyMSkgcmV0dXJuIFN0cmluZyh4KTtcblxuICAgIGlmICh4IDwgMCkge1xuICAgICAgcyA9ICctJztcbiAgICAgIHggPSAteDtcbiAgICB9XG5cbiAgICBpZiAoeCA+IDFlLTIxKSB7XG4gICAgICBlID0gbG9nKHggKiBwb3coMiwgNjksIDEpKSAtIDY5O1xuICAgICAgeiA9IGUgPCAwID8geCAqIHBvdygyLCAtZSwgMSkgOiB4IC8gcG93KDIsIGUsIDEpO1xuICAgICAgeiAqPSAweDEwMDAwMDAwMDAwMDAwO1xuICAgICAgZSA9IDUyIC0gZTtcblxuICAgICAgaWYgKGUgPiAwKSB7XG4gICAgICAgIG11bHRpcGx5KDAsIHopO1xuICAgICAgICBqID0gZjtcblxuICAgICAgICB3aGlsZSAoaiA+PSA3KSB7XG4gICAgICAgICAgbXVsdGlwbHkoMWU3LCAwKTtcbiAgICAgICAgICBqIC09IDc7XG4gICAgICAgIH1cblxuICAgICAgICBtdWx0aXBseShwb3coMTAsIGosIDEpLCAwKTtcbiAgICAgICAgaiA9IGUgLSAxO1xuXG4gICAgICAgIHdoaWxlIChqID49IDIzKSB7XG4gICAgICAgICAgZGl2aWRlKDEgPDwgMjMpO1xuICAgICAgICAgIGogLT0gMjM7XG4gICAgICAgIH1cblxuICAgICAgICBkaXZpZGUoMSA8PCBqKTtcbiAgICAgICAgbXVsdGlwbHkoMSwgMSk7XG4gICAgICAgIGRpdmlkZSgyKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgbXVsdGlwbHkoMSA8PCAtZSwgMCk7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpICsgcmVwZWF0LmNhbGwoWkVSTywgZik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGYgPiAwKSB7XG4gICAgICBrID0gbS5sZW5ndGg7XG4gICAgICBtID0gcyArIChrIDw9IGYgPyAnMC4nICsgcmVwZWF0LmNhbGwoWkVSTywgZiAtIGspICsgbSA6IG0uc2xpY2UoMCwgayAtIGYpICsgJy4nICsgbS5zbGljZShrIC0gZikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gcyArIG07XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbnZhciBhTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuL19hLW51bWJlci12YWx1ZScpO1xuXG52YXIgJHRvUHJlY2lzaW9uID0gMS4wLnRvUHJlY2lzaW9uO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gSUU3LVxuICByZXR1cm4gJHRvUHJlY2lzaW9uLmNhbGwoMSwgdW5kZWZpbmVkKSAhPT0gJzEnO1xufSkgfHwgISRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIFY4IH4gQW5kcm9pZCA0LjMtXG4gICR0b1ByZWNpc2lvbi5jYWxsKHt9KTtcbn0pKSwgJ051bWJlcicsIHtcbiAgdG9QcmVjaXNpb246IGZ1bmN0aW9uIHRvUHJlY2lzaW9uKHByZWNpc2lvbikge1xuICAgIHZhciB0aGF0ID0gYU51bWJlclZhbHVlKHRoaXMsICdOdW1iZXIjdG9QcmVjaXNpb246IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICAgIHJldHVybiBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQpIDogJHRvUHJlY2lzaW9uLmNhbGwodGhhdCwgcHJlY2lzaW9uKTtcbiAgfVxufSk7IiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0Jywge1xuICBhc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKVxufSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTsgLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG5cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGNyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG59KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpOyAvLyAxOS4xLjIuMyAvIDE1LjIuMy43IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG5cblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtcbiAgZGVmaW5lUHJvcGVydGllczogcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpXG59KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpOyAvLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuXG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7XG4gIGRlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG59KTsiLCIvLyAxOS4xLjIuNSBPYmplY3QuZnJlZXplKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZnJlZXplJywgZnVuY3Rpb24gKCRmcmVlemUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZyZWV6ZShpdCkge1xuICAgIHJldHVybiAkZnJlZXplICYmIGlzT2JqZWN0KGl0KSA/ICRmcmVlemUobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eU5hbWVzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JykuZjtcbn0pOyIsIi8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbnZhciAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCkge1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xMSBPYmplY3QuaXNFeHRlbnNpYmxlKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0V4dGVuc2libGUnLCBmdW5jdGlvbiAoJGlzRXh0ZW5zaWJsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaXNFeHRlbnNpYmxlKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKGl0KSA6IHRydWUgOiBmYWxzZTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xMiBPYmplY3QuaXNGcm96ZW4oTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRnJvemVuJywgZnVuY3Rpb24gKCRpc0Zyb3plbikge1xuICByZXR1cm4gZnVuY3Rpb24gaXNGcm96ZW4oaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRnJvemVuID8gJGlzRnJvemVuKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xMyBPYmplY3QuaXNTZWFsZWQoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzU2VhbGVkJywgZnVuY3Rpb24gKCRpc1NlYWxlZCkge1xuICByZXR1cm4gZnVuY3Rpb24gaXNTZWFsZWQoaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzU2VhbGVkID8gJGlzU2VhbGVkKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMy4xMCBPYmplY3QuaXModmFsdWUxLCB2YWx1ZTIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgaXM6IHJlcXVpcmUoJy4vX3NhbWUtdmFsdWUnKVxufSk7IiwiLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjE1IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3ByZXZlbnRFeHRlbnNpb25zJywgZnVuY3Rpb24gKCRwcmV2ZW50RXh0ZW5zaW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoaXQpIHtcbiAgICByZXR1cm4gJHByZXZlbnRFeHRlbnNpb25zICYmIGlzT2JqZWN0KGl0KSA/ICRwcmV2ZW50RXh0ZW5zaW9ucyhtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xNyBPYmplY3Quc2VhbChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3NlYWwnLCBmdW5jdGlvbiAoJHNlYWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlYWwoaXQpIHtcbiAgICByZXR1cm4gJHNlYWwgJiYgaXNPYmplY3QoaXQpID8gJHNlYWwobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTsiLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIHNldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXRcbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG5cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xuXG52YXIgdGVzdCA9IHt9O1xudGVzdFtyZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKV0gPSAneic7XG5cbmlmICh0ZXN0ICsgJycgIT0gJ1tvYmplY3Qgel0nKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xuICB9LCB0cnVlKTtcbn0iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19wYXJzZS1mbG9hdCcpOyAvLyAxOC4yLjQgcGFyc2VGbG9hdChzdHJpbmcpXG5cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYgKiAocGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksIHtcbiAgcGFyc2VGbG9hdDogJHBhcnNlRmxvYXRcbn0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTsgLy8gMTguMi41IHBhcnNlSW50KHN0cmluZywgcmFkaXgpXG5cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYgKiAocGFyc2VJbnQgIT0gJHBhcnNlSW50KSwge1xuICBwYXJzZUludDogJHBhcnNlSW50XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcblxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG5cbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG52YXIgdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG5cbnZhciBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpO1xuXG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xuXG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi9fdXNlci1hZ2VudCcpO1xuXG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcblxudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnM7XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52OCB8fCAnJztcbnZhciAkUHJvbWlzZSA9IGdsb2JhbFtQUk9NSVNFXTtcbnZhciBpc05vZGUgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxudmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAvKiBlbXB0eSAqL1xufTtcblxudmFyIEludGVybmFsLCBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIE93blByb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZjtcbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgPSAkUHJvbWlzZS5yZXNvbHZlKDEpO1xuXG4gICAgdmFyIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbiAoZXhlYykge1xuICAgICAgZXhlYyhlbXB0eSwgZW1wdHkpO1xuICAgIH07IC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcblxuXG4gICAgcmV0dXJuIChpc05vZGUgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKSAmJiBwcm9taXNlLnRoZW4oZW1wdHkpIGluc3RhbmNlb2YgRmFrZVByb21pc2UgLy8gdjggNi42IChOb2RlIDEwIGFuZCBDaHJvbWUgNjYpIGhhdmUgYSBidWcgd2l0aCByZXNvbHZpbmcgY3VzdG9tIHRoZW5hYmxlc1xuICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTgzMDU2NVxuICAgIC8vIHdlIGNhbid0IGRldGVjdCBpdCBzeW5jaHJvbm91c2x5LCBzbyBqdXN0IGNoZWNrIHZlcnNpb25zXG4gICAgJiYgdjguaW5kZXhPZignNi42JykgIT09IDAgJiYgdXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZS82NicpID09PSAtMTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cbn0oKTsgLy8gaGVscGVyc1xuXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcblxudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpc1JlamVjdCkge1xuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciBvayA9IHByb21pc2UuX3MgPT0gMTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHJlYWN0aW9uKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICAgICAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgICAgIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gICAgICB2YXIgcmVzdWx0LCB0aGVuLCBleGl0ZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2ggPT0gMikgb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7ZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpOyAvLyBtYXkgdGhyb3dcblxuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgICBleGl0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2UpIHtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGkpIHJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcblxuXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZiAoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpIG9uVW5oYW5kbGVkKHByb21pc2UpO1xuICB9KTtcbn07XG5cbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciB1bmhhbmRsZWQgPSBpc1VuaGFuZGxlZChwcm9taXNlKTtcbiAgICB2YXIgcmVzdWx0LCBoYW5kbGVyLCBjb25zb2xlO1xuXG4gICAgaWYgKHVuaGFuZGxlZCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKSB7XG4gICAgICAgICAgaGFuZGxlcih7XG4gICAgICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuICAgICAgICAgICAgcmVhc29uOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfVxuXG4gICAgcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodW5oYW5kbGVkICYmIHJlc3VsdC5lKSB0aHJvdyByZXN1bHQudjtcbiAgfSk7XG59O1xuXG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICByZXR1cm4gcHJvbWlzZS5faCAhPT0gMSAmJiAocHJvbWlzZS5fYSB8fCBwcm9taXNlLl9jKS5sZW5ndGggPT09IDA7XG59O1xuXG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZXI7XG5cbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKSB7XG4gICAgICBoYW5kbGVyKHtcbiAgICAgICAgcHJvbWlzZTogcHJvbWlzZSxcbiAgICAgICAgcmVhc29uOiBwcm9taXNlLl92XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyICRyZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG5cbiAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICBwcm9taXNlLl9zID0gMjtcbiAgaWYgKCFwcm9taXNlLl9hKSBwcm9taXNlLl9hID0gcHJvbWlzZS5fYy5zbGljZSgpO1xuICBub3RpZnkocHJvbWlzZSwgdHJ1ZSk7XG59O1xuXG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgdGhlbjtcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuXG4gIHRyeSB7XG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcblxuICAgIGlmICh0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpIHtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge1xuICAgICAgICAgIF93OiBwcm9taXNlLFxuICAgICAgICAgIF9kOiBmYWxzZVxuICAgICAgICB9OyAvLyB3cmFwXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLl92ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zID0gMTtcbiAgICAgIG5vdGlmeShwcm9taXNlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgJHJlamVjdC5jYWxsKHtcbiAgICAgIF93OiBwcm9taXNlLFxuICAgICAgX2Q6IGZhbHNlXG4gICAgfSwgZSk7IC8vIHdyYXBcbiAgfVxufTsgLy8gY29uc3RydWN0b3IgcG9seWZpbGxcblxuXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXG5cbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgdGhpcy5fYyA9IFtdOyAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcblxuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7IC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG5cbiAgICB0aGlzLl9zID0gMDsgLy8gPC0gc3RhdGVcblxuICAgIHRoaXMuX2QgPSBmYWxzZTsgLy8gPC0gZG9uZVxuXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgLy8gPC0gdmFsdWVcblxuICAgIHRoaXMuX2ggPSAwOyAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAvLyA8LSBub3RpZnlcbiAgfTtcblxuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcblxuICAgICAgaWYgKHRoaXMuX2EpIHRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fcykgbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGN0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG5cbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgICByZXR1cm4gQyA9PT0gJFByb21pc2UgfHwgQyA9PT0gV3JhcHBlciA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKSA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1xuICBQcm9taXNlOiAkUHJvbWlzZVxufSk7XG5cbnJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJykoJFByb21pc2UsIFBST01JU0UpO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKFBST01JU0UpO1xuXG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdOyAvLyBzdGF0aWNzXG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7XG4gICAgdmFyICQkcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChMSUJSQVJZIHx8ICFVU0VfTkFUSVZFKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKExJQlJBUlkgJiYgdGhpcyA9PT0gV3JhcHBlciA/ICRQcm9taXNlIDogdGhpcywgeCk7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbiAoaXRlcikge1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciAkaW5kZXggPSBpbmRleCsrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmIChyZXN1bHQuZSkgcmVqZWN0KHJlc3VsdC52KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7IiwiLy8gMjYuMS4xIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIHJBcHBseSA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5hcHBseTtcbnZhciBmQXBwbHkgPSBGdW5jdGlvbi5hcHBseTsgLy8gTVMgRWRnZSBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByQXBwbHkoZnVuY3Rpb24gKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH0pO1xufSksICdSZWZsZWN0Jywge1xuICBhcHBseTogZnVuY3Rpb24gYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICB2YXIgVCA9IGFGdW5jdGlvbih0YXJnZXQpO1xuICAgIHZhciBMID0gYW5PYmplY3QoYXJndW1lbnRzTGlzdCk7XG4gICAgcmV0dXJuIHJBcHBseSA/IHJBcHBseShULCB0aGlzQXJndW1lbnQsIEwpIDogZkFwcGx5LmNhbGwoVCwgdGhpc0FyZ3VtZW50LCBMKTtcbiAgfVxufSk7IiwiLy8gMjYuMS4yIFJlZmxlY3QuY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCBbLCBuZXdUYXJnZXRdKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcblxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJy4vX2JpbmQnKTtcblxudmFyIHJDb25zdHJ1Y3QgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuY29uc3RydWN0OyAvLyBNUyBFZGdlIHN1cHBvcnRzIG9ubHkgMiBhcmd1bWVudHMgYW5kIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbi8vIEZGIE5pZ2h0bHkgc2V0cyB0aGlyZCBhcmd1bWVudCBhcyBgbmV3LnRhcmdldGAsIGJ1dCBkb2VzIG5vdCBjcmVhdGUgYHRoaXNgIGZyb20gaXRcblxudmFyIE5FV19UQVJHRVRfQlVHID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkge1xuICAgIC8qIGVtcHR5ICovXG4gIH1cblxuICByZXR1cm4gIShyQ29uc3RydWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvKiBlbXB0eSAqL1xuICB9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTtcbn0pO1xudmFyIEFSR1NfQlVHID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgckNvbnN0cnVjdChmdW5jdGlvbiAoKSB7XG4gICAgLyogZW1wdHkgKi9cbiAgfSk7XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE5FV19UQVJHRVRfQlVHIHx8IEFSR1NfQlVHKSwgJ1JlZmxlY3QnLCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KFRhcmdldCwgYXJnc1xuICAvKiAsIG5ld1RhcmdldCAqL1xuICApIHtcbiAgICBhRnVuY3Rpb24oVGFyZ2V0KTtcbiAgICBhbk9iamVjdChhcmdzKTtcbiAgICB2YXIgbmV3VGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBUYXJnZXQgOiBhRnVuY3Rpb24oYXJndW1lbnRzWzJdKTtcbiAgICBpZiAoQVJHU19CVUcgJiYgIU5FV19UQVJHRVRfQlVHKSByZXR1cm4gckNvbnN0cnVjdChUYXJnZXQsIGFyZ3MsIG5ld1RhcmdldCk7XG5cbiAgICBpZiAoVGFyZ2V0ID09IG5ld1RhcmdldCkge1xuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBvcHRpbWl6YXRpb24gZm9yIDAtNCBhcmd1bWVudHNcbiAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KCk7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXQoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfSAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIGxvdCBvZiBhcmd1bWVudHMgY2FzZVxuXG5cbiAgICAgIHZhciAkYXJncyA9IFtudWxsXTtcbiAgICAgICRhcmdzLnB1c2guYXBwbHkoJGFyZ3MsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoYmluZC5hcHBseShUYXJnZXQsICRhcmdzKSkoKTtcbiAgICB9IC8vIHdpdGggYWx0ZXJlZCBuZXdUYXJnZXQsIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGNvbnN0cnVjdG9yc1xuXG5cbiAgICB2YXIgcHJvdG8gPSBuZXdUYXJnZXQucHJvdG90eXBlO1xuICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZShpc09iamVjdChwcm90bykgPyBwcm90byA6IE9iamVjdC5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBGdW5jdGlvbi5hcHBseS5jYWxsKFRhcmdldCwgaW5zdGFuY2UsIGFyZ3MpO1xuICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XG4gIH1cbn0pOyIsIi8vIDI2LjEuMyBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpXG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpOyAvLyBNUyBFZGdlIGhhcyBicm9rZW4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSAtIHRocm93aW5nIGluc3RlYWQgb2YgcmV0dXJuaW5nIGZhbHNlXG5cblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoZFAuZih7fSwgMSwge1xuICAgIHZhbHVlOiAxXG4gIH0pLCAxLCB7XG4gICAgdmFsdWU6IDJcbiAgfSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKSB7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICBwcm9wZXJ0eUtleSA9IHRvUHJpbWl0aXZlKHByb3BlcnR5S2V5LCB0cnVlKTtcbiAgICBhbk9iamVjdChhdHRyaWJ1dGVzKTtcblxuICAgIHRyeSB7XG4gICAgICBkUC5mKHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7IiwiLy8gMjYuMS40IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBnT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHZhciBkZXNjID0gZ09QRChhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyAyNi4xLjUgUmVmbGVjdC5lbnVtZXJhdGUodGFyZ2V0KVxuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIEVudW1lcmF0ZSA9IGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gYW5PYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcblxuICB0aGlzLl9pID0gMDsgLy8gbmV4dCBpbmRleFxuXG4gIHZhciBrZXlzID0gdGhpcy5fayA9IFtdOyAvLyBrZXlzXG5cbiAgdmFyIGtleTtcblxuICBmb3IgKGtleSBpbiBpdGVyYXRlZCkga2V5cy5wdXNoKGtleSk7XG59O1xuXG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKEVudW1lcmF0ZSwgJ09iamVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB2YXIga2V5cyA9IHRoYXQuX2s7XG4gIHZhciBrZXk7XG5cbiAgZG8ge1xuICAgIGlmICh0aGF0Ll9pID49IGtleXMubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGRvbmU6IHRydWVcbiAgICB9O1xuICB9IHdoaWxlICghKChrZXkgPSBrZXlzW3RoYXQuX2krK10pIGluIHRoYXQuX3QpKTtcblxuICByZXR1cm4ge1xuICAgIHZhbHVlOiBrZXksXG4gICAgZG9uZTogZmFsc2VcbiAgfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGVudW1lcmF0ZTogZnVuY3Rpb24gZW51bWVyYXRlKHRhcmdldCkge1xuICAgIHJldHVybiBuZXcgRW51bWVyYXRlKHRhcmdldCk7XG4gIH1cbn0pOyIsIi8vIDI2LjEuNyBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgcmV0dXJuIGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gIH1cbn0pOyIsIi8vIDI2LjEuOCBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBnZXRQcm90byA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKHRhcmdldCkge1xuICAgIHJldHVybiBnZXRQcm90byhhbk9iamVjdCh0YXJnZXQpKTtcbiAgfVxufSk7IiwiLy8gMjYuMS42IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgWywgcmVjZWl2ZXJdKVxudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xuXG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBnZXQodGFyZ2V0LCBwcm9wZXJ0eUtleVxuLyogLCByZWNlaXZlciAqL1xuKSB7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdO1xuICB2YXIgZGVzYywgcHJvdG87XG4gIGlmIChhbk9iamVjdCh0YXJnZXQpID09PSByZWNlaXZlcikgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIGlmIChkZXNjID0gZ09QRC5mKHRhcmdldCwgcHJvcGVydHlLZXkpKSByZXR1cm4gaGFzKGRlc2MsICd2YWx1ZScpID8gZGVzYy52YWx1ZSA6IGRlc2MuZ2V0ICE9PSB1bmRlZmluZWQgPyBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKSA6IHVuZGVmaW5lZDtcbiAgaWYgKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpIHJldHVybiBnZXQocHJvdG8sIHByb3BlcnR5S2V5LCByZWNlaXZlcik7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0OiBnZXRcbn0pOyIsIi8vIDI2LjEuOSBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBoYXM6IGZ1bmN0aW9uIGhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgcmV0dXJuIHByb3BlcnR5S2V5IGluIHRhcmdldDtcbiAgfVxufSk7IiwiLy8gMjYuMS4xMCBSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyICRpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZSh0YXJnZXQpIHtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHJldHVybiAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZSh0YXJnZXQpIDogdHJ1ZTtcbiAgfVxufSk7IiwiLy8gMjYuMS4xMSBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBvd25LZXlzOiByZXF1aXJlKCcuL19vd24ta2V5cycpXG59KTsiLCIvLyAyNi4xLjEyIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciAkcHJldmVudEV4dGVuc2lvbnMgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnM7XG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHByZXZlbnRFeHRlbnNpb25zOiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpIHtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICgkcHJldmVudEV4dGVuc2lvbnMpICRwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7IiwiLy8gMjYuMS4xNCBSZWZsZWN0LnNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgc2V0UHJvdG8gPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKTtcblxuaWYgKHNldFByb3RvKSAkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHNldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKSB7XG4gICAgc2V0UHJvdG8uY2hlY2sodGFyZ2V0LCBwcm90byk7XG5cbiAgICB0cnkge1xuICAgICAgc2V0UHJvdG8uc2V0KHRhcmdldCwgcHJvdG8pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7IiwiLy8gMjYuMS4xMyBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIFssIHJlY2VpdmVyXSlcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG52YXIgZ09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG5cbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgVlxuLyogLCByZWNlaXZlciAqL1xuKSB7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCA0ID8gdGFyZ2V0IDogYXJndW1lbnRzWzNdO1xuICB2YXIgb3duRGVzYyA9IGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gIHZhciBleGlzdGluZ0Rlc2NyaXB0b3IsIHByb3RvO1xuXG4gIGlmICghb3duRGVzYykge1xuICAgIGlmIChpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKSB7XG4gICAgICByZXR1cm4gc2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgViwgcmVjZWl2ZXIpO1xuICAgIH1cblxuICAgIG93bkRlc2MgPSBjcmVhdGVEZXNjKDApO1xuICB9XG5cbiAgaWYgKGhhcyhvd25EZXNjLCAndmFsdWUnKSkge1xuICAgIGlmIChvd25EZXNjLndyaXRhYmxlID09PSBmYWxzZSB8fCAhaXNPYmplY3QocmVjZWl2ZXIpKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoZXhpc3RpbmdEZXNjcmlwdG9yID0gZ09QRC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSkpIHtcbiAgICAgIGlmIChleGlzdGluZ0Rlc2NyaXB0b3IuZ2V0IHx8IGV4aXN0aW5nRGVzY3JpcHRvci5zZXQgfHwgZXhpc3RpbmdEZXNjcmlwdG9yLndyaXRhYmxlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZXhpc3RpbmdEZXNjcmlwdG9yLnZhbHVlID0gVjtcbiAgICAgIGRQLmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5LCBleGlzdGluZ0Rlc2NyaXB0b3IpO1xuICAgIH0gZWxzZSBkUC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgY3JlYXRlRGVzYygwLCBWKSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBvd25EZXNjLnNldCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAob3duRGVzYy5zZXQuY2FsbChyZWNlaXZlciwgViksIHRydWUpO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHNldDogc2V0XG59KTsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG5cbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcblxudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcblxudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG5cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpO1xuXG52YXIgJGZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcblxudmFyICRSZWdFeHAgPSBnbG9iYWwuUmVnRXhwO1xudmFyIEJhc2UgPSAkUmVnRXhwO1xudmFyIHByb3RvID0gJFJlZ0V4cC5wcm90b3R5cGU7XG52YXIgcmUxID0gL2EvZztcbnZhciByZTIgPSAvYS9nOyAvLyBcIm5ld1wiIGNyZWF0ZXMgYSBuZXcgb2JqZWN0LCBvbGQgd2Via2l0IGJ1Z2d5IGhlcmVcblxudmFyIENPUlJFQ1RfTkVXID0gbmV3ICRSZWdFeHAocmUxKSAhPT0gcmUxO1xuXG5pZiAocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAoIUNPUlJFQ1RfTkVXIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZTJbcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyldID0gZmFsc2U7IC8vIFJlZ0V4cCBjb25zdHJ1Y3RvciBjYW4gYWx0ZXIgZmxhZ3MgYW5kIElzUmVnRXhwIHdvcmtzIGNvcnJlY3Qgd2l0aCBAQG1hdGNoXG5cbiAgcmV0dXJuICRSZWdFeHAocmUxKSAhPSByZTEgfHwgJFJlZ0V4cChyZTIpID09IHJlMiB8fCAkUmVnRXhwKHJlMSwgJ2knKSAhPSAnL2EvaSc7XG59KSkpIHtcbiAgJFJlZ0V4cCA9IGZ1bmN0aW9uIFJlZ0V4cChwLCBmKSB7XG4gICAgdmFyIHRpUkUgPSB0aGlzIGluc3RhbmNlb2YgJFJlZ0V4cDtcbiAgICB2YXIgcGlSRSA9IGlzUmVnRXhwKHApO1xuICAgIHZhciBmaVUgPSBmID09PSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuICF0aVJFICYmIHBpUkUgJiYgcC5jb25zdHJ1Y3RvciA9PT0gJFJlZ0V4cCAmJiBmaVUgPyBwIDogaW5oZXJpdElmUmVxdWlyZWQoQ09SUkVDVF9ORVcgPyBuZXcgQmFzZShwaVJFICYmICFmaVUgPyBwLnNvdXJjZSA6IHAsIGYpIDogQmFzZSgocGlSRSA9IHAgaW5zdGFuY2VvZiAkUmVnRXhwKSA/IHAuc291cmNlIDogcCwgcGlSRSAmJiBmaVUgPyAkZmxhZ3MuY2FsbChwKSA6IGYpLCB0aVJFID8gdGhpcyA6IHByb3RvLCAkUmVnRXhwKTtcbiAgfTtcblxuICB2YXIgcHJveHkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAga2V5IGluICRSZWdFeHAgfHwgZFAoJFJlZ0V4cCwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEJhc2Vba2V5XTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChpdCkge1xuICAgICAgICBCYXNlW2tleV0gPSBpdDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBrZXlzID0gZ09QTihCYXNlKSwgaSA9IDA7IGtleXMubGVuZ3RoID4gaTspIHByb3h5KGtleXNbaSsrXSk7XG5cbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkUmVnRXhwO1xuICAkUmVnRXhwLnByb3RvdHlwZSA9IHByb3RvO1xuXG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCAnUmVnRXhwJywgJFJlZ0V4cCk7XG59XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ1JlZ0V4cCcpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYycpO1xuXG5yZXF1aXJlKCcuL19leHBvcnQnKSh7XG4gIHRhcmdldDogJ1JlZ0V4cCcsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6IHJlZ2V4cEV4ZWMgIT09IC8uLy5leGVjXG59LCB7XG4gIGV4ZWM6IHJlZ2V4cEV4ZWNcbn0pOyIsIi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbmlmIChyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIC8uL2cuZmxhZ3MgIT0gJ2cnKSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlcXVpcmUoJy4vX2ZsYWdzJylcbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi9fYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcblxudmFyIHJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYy1hYnN0cmFjdCcpOyAvLyBAQG1hdGNoIGxvZ2ljXG5cblxucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdtYXRjaCcsIDEsIGZ1bmN0aW9uIChkZWZpbmVkLCBNQVRDSCwgJG1hdGNoLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgcmV0dXJuIFsvLyBgU3RyaW5nLnByb3RvdHlwZS5tYXRjaGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUubWF0Y2hcbiAgZnVuY3Rpb24gbWF0Y2gocmVnZXhwKSB7XG4gICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgIHZhciBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuICB9LCAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBtYXRjaFxuICBmdW5jdGlvbiAocmVnZXhwKSB7XG4gICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZSgkbWF0Y2gsIHJlZ2V4cCwgdGhpcyk7XG4gICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG4gICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgaWYgKCFyeC5nbG9iYWwpIHJldHVybiByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgIHJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIEEgPSBbXTtcbiAgICB2YXIgbiA9IDA7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIHdoaWxlICgocmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUykpICE9PSBudWxsKSB7XG4gICAgICB2YXIgbWF0Y2hTdHIgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgIEFbbl0gPSBtYXRjaFN0cjtcbiAgICAgIGlmIChtYXRjaFN0ciA9PT0gJycpIHJ4Lmxhc3RJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCB0b0xlbmd0aChyeC5sYXN0SW5kZXgpLCBmdWxsVW5pY29kZSk7XG4gICAgICBuKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIG4gPT09IDAgPyBudWxsIDogQTtcbiAgfV07XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG5cbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuL19hZHZhbmNlLXN0cmluZy1pbmRleCcpO1xuXG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFMgPSAvXFwkKFskJmAnXXxcXGRcXGQ/fDxbXj5dKj4pL2c7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQgPSAvXFwkKFskJmAnXXxcXGRcXGQ/KS9nO1xuXG52YXIgbWF5YmVUb1N0cmluZyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcbn07IC8vIEBAcmVwbGFjZSBsb2dpY1xuXG5cbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgncmVwbGFjZScsIDIsIGZ1bmN0aW9uIChkZWZpbmVkLCBSRVBMQUNFLCAkcmVwbGFjZSwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHJldHVybiBbLy8gYFN0cmluZy5wcm90b3R5cGUucmVwbGFjZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucmVwbGFjZVxuICBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpIHtcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VhcmNoVmFsdWVbUkVQTEFDRV07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpIDogJHJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICB9LCAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHJlcGxhY2VcbiAgZnVuY3Rpb24gKHJlZ2V4cCwgcmVwbGFjZVZhbHVlKSB7XG4gICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZSgkcmVwbGFjZSwgcmVnZXhwLCB0aGlzLCByZXBsYWNlVmFsdWUpO1xuICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgIHZhciBmdW5jdGlvbmFsUmVwbGFjZSA9IHR5cGVvZiByZXBsYWNlVmFsdWUgPT09ICdmdW5jdGlvbic7XG4gICAgaWYgKCFmdW5jdGlvbmFsUmVwbGFjZSkgcmVwbGFjZVZhbHVlID0gU3RyaW5nKHJlcGxhY2VWYWx1ZSk7XG4gICAgdmFyIGdsb2JhbCA9IHJ4Lmdsb2JhbDtcblxuICAgIGlmIChnbG9iYWwpIHtcbiAgICAgIHZhciBmdWxsVW5pY29kZSA9IHJ4LnVuaWNvZGU7XG4gICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgIH1cblxuICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHJlZ0V4cEV4ZWMocngsIFMpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgIGlmICghZ2xvYmFsKSBicmVhaztcbiAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICB9XG5cbiAgICB2YXIgYWNjdW11bGF0ZWRSZXN1bHQgPSAnJztcbiAgICB2YXIgbmV4dFNvdXJjZVBvc2l0aW9uID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpXTtcbiAgICAgIHZhciBtYXRjaGVkID0gU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICB2YXIgcG9zaXRpb24gPSBtYXgobWluKHRvSW50ZWdlcihyZXN1bHQuaW5kZXgpLCBTLmxlbmd0aCksIDApO1xuICAgICAgdmFyIGNhcHR1cmVzID0gW107IC8vIE5PVEU6IFRoaXMgaXMgZXF1aXZhbGVudCB0b1xuICAgICAgLy8gICBjYXB0dXJlcyA9IHJlc3VsdC5zbGljZSgxKS5tYXAobWF5YmVUb1N0cmluZylcbiAgICAgIC8vIGJ1dCBmb3Igc29tZSByZWFzb24gYG5hdGl2ZVNsaWNlLmNhbGwocmVzdWx0LCAxLCByZXN1bHQubGVuZ3RoKWAgKGNhbGxlZCBpblxuICAgICAgLy8gdGhlIHNsaWNlIHBvbHlmaWxsIHdoZW4gc2xpY2luZyBuYXRpdmUgYXJyYXlzKSBcImRvZXNuJ3Qgd29ya1wiIGluIHNhZmFyaSA5IGFuZFxuICAgICAgLy8gY2F1c2VzIGEgY3Jhc2ggKGh0dHBzOi8vcGFzdGViaW4uY29tL04yMVF6ZVFBKSB3aGVuIHRyeWluZyB0byBkZWJ1ZyBpdC5cblxuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCByZXN1bHQubGVuZ3RoOyBqKyspIGNhcHR1cmVzLnB1c2gobWF5YmVUb1N0cmluZyhyZXN1bHRbal0pKTtcblxuICAgICAgdmFyIG5hbWVkQ2FwdHVyZXMgPSByZXN1bHQuZ3JvdXBzO1xuXG4gICAgICBpZiAoZnVuY3Rpb25hbFJlcGxhY2UpIHtcbiAgICAgICAgdmFyIHJlcGxhY2VyQXJncyA9IFttYXRjaGVkXS5jb25jYXQoY2FwdHVyZXMsIHBvc2l0aW9uLCBTKTtcbiAgICAgICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkgcmVwbGFjZXJBcmdzLnB1c2gobmFtZWRDYXB0dXJlcyk7XG4gICAgICAgIHZhciByZXBsYWNlbWVudCA9IFN0cmluZyhyZXBsYWNlVmFsdWUuYXBwbHkodW5kZWZpbmVkLCByZXBsYWNlckFyZ3MpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIFMsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZVZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc2l0aW9uID49IG5leHRTb3VyY2VQb3NpdGlvbikge1xuICAgICAgICBhY2N1bXVsYXRlZFJlc3VsdCArPSBTLnNsaWNlKG5leHRTb3VyY2VQb3NpdGlvbiwgcG9zaXRpb24pICsgcmVwbGFjZW1lbnQ7XG4gICAgICAgIG5leHRTb3VyY2VQb3NpdGlvbiA9IHBvc2l0aW9uICsgbWF0Y2hlZC5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY3VtdWxhdGVkUmVzdWx0ICsgUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24pO1xuICB9XTsgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2V0c3Vic3RpdHV0aW9uXG5cbiAgZnVuY3Rpb24gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIHN0ciwgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlbWVudCkge1xuICAgIHZhciB0YWlsUG9zID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICB2YXIgbSA9IGNhcHR1cmVzLmxlbmd0aDtcbiAgICB2YXIgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEO1xuXG4gICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbmFtZWRDYXB0dXJlcyA9IHRvT2JqZWN0KG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTO1xuICAgIH1cblxuICAgIHJldHVybiAkcmVwbGFjZS5jYWxsKHJlcGxhY2VtZW50LCBzeW1ib2xzLCBmdW5jdGlvbiAobWF0Y2gsIGNoKSB7XG4gICAgICB2YXIgY2FwdHVyZTtcblxuICAgICAgc3dpdGNoIChjaC5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSAnJCc6XG4gICAgICAgICAgcmV0dXJuICckJztcblxuICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICByZXR1cm4gbWF0Y2hlZDtcblxuICAgICAgICBjYXNlICdgJzpcbiAgICAgICAgICByZXR1cm4gc3RyLnNsaWNlKDAsIHBvc2l0aW9uKTtcblxuICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgIHJldHVybiBzdHIuc2xpY2UodGFpbFBvcyk7XG5cbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgY2FwdHVyZSA9IG5hbWVkQ2FwdHVyZXNbY2guc2xpY2UoMSwgLTEpXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIFxcZFxcZD9cbiAgICAgICAgICB2YXIgbiA9ICtjaDtcbiAgICAgICAgICBpZiAobiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuXG4gICAgICAgICAgaWYgKG4gPiBtKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGZsb29yKG4gLyAxMCk7XG4gICAgICAgICAgICBpZiAoZiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgaWYgKGYgPD0gbSkgcmV0dXJuIGNhcHR1cmVzW2YgLSAxXSA9PT0gdW5kZWZpbmVkID8gY2guY2hhckF0KDEpIDogY2FwdHVyZXNbZiAtIDFdICsgY2guY2hhckF0KDEpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhcHR1cmUgPSBjYXB0dXJlc1tuIC0gMV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYXB0dXJlID09PSB1bmRlZmluZWQgPyAnJyA6IGNhcHR1cmU7XG4gICAgfSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBzYW1lVmFsdWUgPSByZXF1aXJlKCcuL19zYW1lLXZhbHVlJyk7XG5cbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTsgLy8gQEBzZWFyY2ggbG9naWNcblxuXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NlYXJjaCcsIDEsIGZ1bmN0aW9uIChkZWZpbmVkLCBTRUFSQ0gsICRzZWFyY2gsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICByZXR1cm4gWy8vIGBTdHJpbmcucHJvdG90eXBlLnNlYXJjaGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuc2VhcmNoXG4gIGZ1bmN0aW9uIHNlYXJjaChyZWdleHApIHtcbiAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgdmFyIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtTRUFSQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW1NFQVJDSF0oU3RyaW5nKE8pKTtcbiAgfSwgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHNlYXJjaFxuICBmdW5jdGlvbiAocmVnZXhwKSB7XG4gICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZSgkc2VhcmNoLCByZWdleHAsIHRoaXMpO1xuICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgIHZhciBwcmV2aW91c0xhc3RJbmRleCA9IHJ4Lmxhc3RJbmRleDtcbiAgICBpZiAoIXNhbWVWYWx1ZShwcmV2aW91c0xhc3RJbmRleCwgMCkpIHJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IHJlZ0V4cEV4ZWMocngsIFMpO1xuICAgIGlmICghc2FtZVZhbHVlKHJ4Lmxhc3RJbmRleCwgcHJldmlvdXNMYXN0SW5kZXgpKSByeC5sYXN0SW5kZXggPSBwcmV2aW91c0xhc3RJbmRleDtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gLTEgOiByZXN1bHQuaW5kZXg7XG4gIH1dO1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuL19hZHZhbmNlLXN0cmluZy1pbmRleCcpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxudmFyIGNhbGxSZWdFeHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcblxudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYycpO1xuXG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG52YXIgJG1pbiA9IE1hdGgubWluO1xudmFyICRwdXNoID0gW10ucHVzaDtcbnZhciAkU1BMSVQgPSAnc3BsaXQnO1xudmFyIExFTkdUSCA9ICdsZW5ndGgnO1xudmFyIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcbnZhciBNQVhfVUlOVDMyID0gMHhmZmZmZmZmZjsgLy8gYmFiZWwtbWluaWZ5IHRyYW5zcGlsZXMgUmVnRXhwKCd4JywgJ3knKSAtPiAveC95IGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcblxudmFyIFNVUFBPUlRTX1kgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBSZWdFeHAoTUFYX1VJTlQzMiwgJ3knKTtcbn0pOyAvLyBAQHNwbGl0IGxvZ2ljXG5cbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc3BsaXQnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgU1BMSVQsICRzcGxpdCwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHZhciBpbnRlcm5hbFNwbGl0O1xuXG4gIGlmICgnYWJiYydbJFNQTElUXSgvKGIpKi8pWzFdID09ICdjJyB8fCAndGVzdCdbJFNQTElUXSgvKD86KS8sIC0xKVtMRU5HVEhdICE9IDQgfHwgJ2FiJ1skU1BMSVRdKC8oPzphYikqLylbTEVOR1RIXSAhPSAyIHx8ICcuJ1skU1BMSVRdKC8oLj8pKC4/KS8pW0xFTkdUSF0gIT0gNCB8fCAnLidbJFNQTElUXSgvKCkoKS8pW0xFTkdUSF0gPiAxIHx8ICcnWyRTUExJVF0oLy4/LylbTEVOR1RIXSkge1xuICAgIC8vIGJhc2VkIG9uIGVzNS1zaGltIGltcGxlbWVudGF0aW9uLCBuZWVkIHRvIHJld29yayBpdFxuICAgIGludGVybmFsU3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCkgcmV0dXJuIFtdOyAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuXG4gICAgICBpZiAoIWlzUmVnRXhwKHNlcGFyYXRvcikpIHJldHVybiAkc3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICsgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgKyAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgKyAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTtcbiAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBzcGxpdExpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDsgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcblxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobWF0Y2ggPSByZWdleHBFeGVjLmNhbGwoc2VwYXJhdG9yQ29weSwgc3RyaW5nKSkge1xuICAgICAgICBsYXN0SW5kZXggPSBzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdO1xuXG4gICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgaWYgKG1hdGNoW0xFTkdUSF0gPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nW0xFTkdUSF0pICRwdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgaWYgKG91dHB1dFtMRU5HVEhdID49IHNwbGl0TGltaXQpIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0gPT09IG1hdGNoLmluZGV4KSBzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdKys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cblxuICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZ1tMRU5HVEhdKSB7XG4gICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKSBvdXRwdXQucHVzaCgnJyk7XG4gICAgICB9IGVsc2Ugb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcblxuICAgICAgcmV0dXJuIG91dHB1dFtMRU5HVEhdID4gc3BsaXRMaW1pdCA/IG91dHB1dC5zbGljZSgwLCBzcGxpdExpbWl0KSA6IG91dHB1dDtcbiAgICB9OyAvLyBDaGFrcmEsIFY4XG5cbiAgfSBlbHNlIGlmICgnMCdbJFNQTElUXSh1bmRlZmluZWQsIDApW0xFTkdUSF0pIHtcbiAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogJHNwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBpbnRlcm5hbFNwbGl0ID0gJHNwbGl0O1xuICB9XG5cbiAgcmV0dXJuIFsvLyBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuc3BsaXRcbiAgZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgIHZhciBPID0gZGVmaW5lZCh0aGlzKTtcbiAgICB2YXIgc3BsaXR0ZXIgPSBzZXBhcmF0b3IgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VwYXJhdG9yW1NQTElUXTtcbiAgICByZXR1cm4gc3BsaXR0ZXIgIT09IHVuZGVmaW5lZCA/IHNwbGl0dGVyLmNhbGwoc2VwYXJhdG9yLCBPLCBsaW1pdCkgOiBpbnRlcm5hbFNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgfSwgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF1gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAc3BsaXRcbiAgLy9cbiAgLy8gTk9URTogVGhpcyBjYW5ub3QgYmUgcHJvcGVybHkgcG9seWZpbGxlZCBpbiBlbmdpbmVzIHRoYXQgZG9uJ3Qgc3VwcG9ydFxuICAvLyB0aGUgJ3knIGZsYWcuXG4gIGZ1bmN0aW9uIChyZWdleHAsIGxpbWl0KSB7XG4gICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZShpbnRlcm5hbFNwbGl0LCByZWdleHAsIHRoaXMsIGxpbWl0LCBpbnRlcm5hbFNwbGl0ICE9PSAkc3BsaXQpO1xuICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHJ4LCBSZWdFeHApO1xuICAgIHZhciB1bmljb2RlTWF0Y2hpbmcgPSByeC51bmljb2RlO1xuICAgIHZhciBmbGFncyA9IChyeC5pZ25vcmVDYXNlID8gJ2knIDogJycpICsgKHJ4Lm11bHRpbGluZSA/ICdtJyA6ICcnKSArIChyeC51bmljb2RlID8gJ3UnIDogJycpICsgKFNVUFBPUlRTX1kgPyAneScgOiAnZycpOyAvLyBeKD8gKyByeCArICkgaXMgbmVlZGVkLCBpbiBjb21iaW5hdGlvbiB3aXRoIHNvbWUgUyBzbGljaW5nLCB0b1xuICAgIC8vIHNpbXVsYXRlIHRoZSAneScgZmxhZy5cblxuICAgIHZhciBzcGxpdHRlciA9IG5ldyBDKFNVUFBPUlRTX1kgPyByeCA6ICdeKD86JyArIHJ4LnNvdXJjZSArICcpJywgZmxhZ3MpO1xuICAgIHZhciBsaW0gPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX1VJTlQzMiA6IGxpbWl0ID4+PiAwO1xuICAgIGlmIChsaW0gPT09IDApIHJldHVybiBbXTtcbiAgICBpZiAoUy5sZW5ndGggPT09IDApIHJldHVybiBjYWxsUmVnRXhwRXhlYyhzcGxpdHRlciwgUykgPT09IG51bGwgPyBbU10gOiBbXTtcbiAgICB2YXIgcCA9IDA7XG4gICAgdmFyIHEgPSAwO1xuICAgIHZhciBBID0gW107XG5cbiAgICB3aGlsZSAocSA8IFMubGVuZ3RoKSB7XG4gICAgICBzcGxpdHRlci5sYXN0SW5kZXggPSBTVVBQT1JUU19ZID8gcSA6IDA7XG4gICAgICB2YXIgeiA9IGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTVVBQT1JUU19ZID8gUyA6IFMuc2xpY2UocSkpO1xuICAgICAgdmFyIGU7XG5cbiAgICAgIGlmICh6ID09PSBudWxsIHx8IChlID0gJG1pbih0b0xlbmd0aChzcGxpdHRlci5sYXN0SW5kZXggKyAoU1VQUE9SVFNfWSA/IDAgOiBxKSksIFMubGVuZ3RoKSkgPT09IHApIHtcbiAgICAgICAgcSA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCBxLCB1bmljb2RlTWF0Y2hpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQS5wdXNoKFMuc2xpY2UocCwgcSkpO1xuICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gei5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICBBLnB1c2goeltpXSk7XG4gICAgICAgICAgaWYgKEEubGVuZ3RoID09PSBsaW0pIHJldHVybiBBO1xuICAgICAgICB9XG5cbiAgICAgICAgcSA9IHAgPSBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIEEucHVzaChTLnNsaWNlKHApKTtcbiAgICByZXR1cm4gQTtcbiAgfV07XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vZXM2LnJlZ2V4cC5mbGFncycpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyICRmbGFncyA9IHJlcXVpcmUoJy4vX2ZsYWdzJyk7XG5cbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG5cbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyICR0b1N0cmluZyA9IC8uL1tUT19TVFJJTkddO1xuXG52YXIgZGVmaW5lID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmbiwgdHJ1ZSk7XG59OyAvLyAyMS4yLjUuMTQgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZygpXG5cblxuaWYgKHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoe1xuICAgIHNvdXJjZTogJ2EnLFxuICAgIGZsYWdzOiAnYidcbiAgfSkgIT0gJy9hL2InO1xufSkpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgcmV0dXJuICcvJy5jb25jYXQoUi5zb3VyY2UsICcvJywgJ2ZsYWdzJyBpbiBSID8gUi5mbGFncyA6ICFERVNDUklQVE9SUyAmJiBSIGluc3RhbmNlb2YgUmVnRXhwID8gJGZsYWdzLmNhbGwoUikgOiB1bmRlZmluZWQpO1xuICB9KTsgLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbn0gZWxzZSBpZiAoJHRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HKSB7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJHRvU3RyaW5nLmNhbGwodGhpcyk7XG4gIH0pO1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcblxudmFyIFNFVCA9ICdTZXQnOyAvLyAyMy4yIFNldCBPYmplY3RzXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFNFVCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCkge1xuICAgIHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBTRVQpLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBCLjIuMy4yIFN0cmluZy5wcm90b3R5cGUuYW5jaG9yKG5hbWUpXG5cbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2FuY2hvcicsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBhbmNob3IobmFtZSkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ25hbWUnLCBuYW1lKTtcbiAgfTtcbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gQi4yLjMuMyBTdHJpbmcucHJvdG90eXBlLmJpZygpXG5cbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JpZycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBiaWcoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2JpZycsICcnLCAnJyk7XG4gIH07XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIEIuMi4zLjQgU3RyaW5nLnByb3RvdHlwZS5ibGluaygpXG5cbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JsaW5rJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJsaW5rKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdibGluaycsICcnLCAnJyk7XG4gIH07XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIEIuMi4zLjUgU3RyaW5nLnByb3RvdHlwZS5ib2xkKClcblxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYm9sZCcsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBib2xkKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdiJywgJycsICcnKTtcbiAgfTtcbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKGZhbHNlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4zIFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQocG9zKVxuICBjb2RlUG9pbnRBdDogZnVuY3Rpb24gY29kZVBvaW50QXQocG9zKSB7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTsiLCIvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKHNlYXJjaFN0cmluZyBbLCBlbmRQb3NpdGlvbl0pXG4ndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG5cbnZhciBFTkRTX1dJVEggPSAnZW5kc1dpdGgnO1xudmFyICRlbmRzV2l0aCA9ICcnW0VORFNfV0lUSF07XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKEVORFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIGVuZHNXaXRoOiBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmdcbiAgLyogLCBlbmRQb3NpdGlvbiA9IEBsZW5ndGggKi9cbiAgKSB7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgRU5EU19XSVRIKTtcbiAgICB2YXIgZW5kUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgodGhhdC5sZW5ndGgpO1xuICAgIHZhciBlbmQgPSBlbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gbGVuIDogTWF0aC5taW4odG9MZW5ndGgoZW5kUG9zaXRpb24pLCBsZW4pO1xuICAgIHZhciBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJGVuZHNXaXRoID8gJGVuZHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBlbmQpIDogdGhhdC5zbGljZShlbmQgLSBzZWFyY2gubGVuZ3RoLCBlbmQpID09PSBzZWFyY2g7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gQi4yLjMuNiBTdHJpbmcucHJvdG90eXBlLmZpeGVkKClcblxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZml4ZWQnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gZml4ZWQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3R0JywgJycsICcnKTtcbiAgfTtcbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gQi4yLjMuNyBTdHJpbmcucHJvdG90eXBlLmZvbnRjb2xvcihjb2xvcilcblxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZm9udGNvbG9yJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRjb2xvcihjb2xvcikge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdmb250JywgJ2NvbG9yJywgY29sb3IpO1xuICB9O1xufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBCLjIuMy44IFN0cmluZy5wcm90b3R5cGUuZm9udHNpemUoc2l6ZSlcblxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZm9udHNpemUnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9udHNpemUoc2l6ZSkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdmb250JywgJ3NpemUnLCBzaXplKTtcbiAgfTtcbn0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xuXG52YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbnZhciAkZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50OyAvLyBsZW5ndGggc2hvdWxkIGJlIDEsIG9sZCBGRiBwcm9ibGVtXG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCEhJGZyb21Db2RlUG9pbnQgJiYgJGZyb21Db2RlUG9pbnQubGVuZ3RoICE9IDEpLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxuICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KHgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGNvZGU7XG5cbiAgICB3aGlsZSAoYUxlbiA+IGkpIHtcbiAgICAgIGNvZGUgPSArYXJndW1lbnRzW2krK107XG4gICAgICBpZiAodG9BYnNvbHV0ZUluZGV4KGNvZGUsIDB4MTBmZmZmKSAhPT0gY29kZSkgdGhyb3cgUmFuZ2VFcnJvcihjb2RlICsgJyBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50Jyk7XG4gICAgICByZXMucHVzaChjb2RlIDwgMHgxMDAwMCA/IGZyb21DaGFyQ29kZShjb2RlKSA6IGZyb21DaGFyQ29kZSgoKGNvZGUgLT0gMHgxMDAwMCkgPj4gMTApICsgMHhkODAwLCBjb2RlICUgMHg0MDAgKyAweGRjMDApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTsiLCIvLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKVxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG5cbnZhciBJTkNMVURFUyA9ICdpbmNsdWRlcyc7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKElOQ0xVREVTKSwgJ1N0cmluZycsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZ1xuICAvKiAsIHBvc2l0aW9uID0gMCAqL1xuICApIHtcbiAgICByZXR1cm4gISF+Y29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIElOQ0xVREVTKS5pbmRleE9mKHNlYXJjaFN0cmluZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIEIuMi4zLjkgU3RyaW5nLnByb3RvdHlwZS5pdGFsaWNzKClcblxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnaXRhbGljcycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpdGFsaWNzKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdpJywgJycsICcnKTtcbiAgfTtcbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpOyAvLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5cblxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuXG4gIHRoaXMuX2kgPSAwOyAvLyBuZXh0IGluZGV4XG4gIC8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgIGRvbmU6IHRydWVcbiAgfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogcG9pbnQsXG4gICAgZG9uZTogZmFsc2VcbiAgfTtcbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gQi4yLjMuMTAgU3RyaW5nLnByb3RvdHlwZS5saW5rKHVybClcblxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnbGluaycsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBsaW5rKHVybCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ2hyZWYnLCB1cmwpO1xuICB9O1xufSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuNCBTdHJpbmcucmF3KGNhbGxTaXRlLCAuLi5zdWJzdGl0dXRpb25zKVxuICByYXc6IGZ1bmN0aW9uIHJhdyhjYWxsU2l0ZSkge1xuICAgIHZhciB0cGwgPSB0b0lPYmplY3QoY2FsbFNpdGUucmF3KTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgodHBsLmxlbmd0aCk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAobGVuID4gaSkge1xuICAgICAgcmVzLnB1c2goU3RyaW5nKHRwbFtpKytdKSk7XG4gICAgICBpZiAoaSA8IGFMZW4pIHJlcy5wdXNoKFN0cmluZyhhcmd1bWVudHNbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjEzIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KGNvdW50KVxuICByZXBlYXQ6IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBCLjIuMy4xMSBTdHJpbmcucHJvdG90eXBlLnNtYWxsKClcblxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc21hbGwnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc21hbGwoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3NtYWxsJywgJycsICcnKTtcbiAgfTtcbn0pOyIsIi8vIDIxLjEuMy4xOCBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIFssIHBvc2l0aW9uIF0pXG4ndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0Jyk7XG5cbnZhciBTVEFSVFNfV0lUSCA9ICdzdGFydHNXaXRoJztcbnZhciAkc3RhcnRzV2l0aCA9ICcnW1NUQVJUU19XSVRIXTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoU1RBUlRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBzdGFydHNXaXRoOiBmdW5jdGlvbiBzdGFydHNXaXRoKHNlYXJjaFN0cmluZ1xuICAvKiAsIHBvc2l0aW9uID0gMCAqL1xuICApIHtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBTVEFSVFNfV0lUSCk7XG4gICAgdmFyIGluZGV4ID0gdG9MZW5ndGgoTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRoYXQubGVuZ3RoKSk7XG4gICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkc3RhcnRzV2l0aCA/ICRzdGFydHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBpbmRleCkgOiB0aGF0LnNsaWNlKGluZGV4LCBpbmRleCArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gQi4yLjMuMTIgU3RyaW5nLnByb3RvdHlwZS5zdHJpa2UoKVxuXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdHJpa2UnLCBmdW5jdGlvbiAoY3JlYXRlSFRNTCkge1xuICByZXR1cm4gZnVuY3Rpb24gc3RyaWtlKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdHJpa2UnLCAnJywgJycpO1xuICB9O1xufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBCLjIuMy4xMyBTdHJpbmcucHJvdG90eXBlLnN1YigpXG5cbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N1YicsIGZ1bmN0aW9uIChjcmVhdGVIVE1MKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzdWIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N1YicsICcnLCAnJyk7XG4gIH07XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIEIuMi4zLjE0IFN0cmluZy5wcm90b3R5cGUuc3VwKClcblxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3VwJywgZnVuY3Rpb24gKGNyZWF0ZUhUTUwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1cCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3VwJywgJycsICcnKTtcbiAgfTtcbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gMjEuMS4zLjI1IFN0cmluZy5wcm90b3R5cGUudHJpbSgpXG5cbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW0nLCBmdW5jdGlvbiAoJHRyaW0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW0oKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDMpO1xuICB9O1xufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xuXG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xuXG52YXIgTUVUQSA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVk7XG5cbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJyk7XG5cbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG5cbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcblxudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xuXG52YXIgd2tzRGVmaW5lID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpO1xuXG52YXIgZW51bUtleXMgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKTtcblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbnZhciBfY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xuXG52YXIgZ09QTkV4dCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpO1xuXG52YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xuXG52YXIgJEdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xuXG52YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnZhciBnT1BEID0gJEdPUEQuZjtcbnZhciBkUCA9ICREUC5mO1xudmFyIGdPUE4gPSBnT1BORXh0LmY7XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgJEpTT04gPSBnbG9iYWwuSlNPTjtcblxudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG5cbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBISURERU4gPSB3a3MoJ19oaWRkZW4nKTtcbnZhciBUT19QUklNSVRJVkUgPSB3a3MoJ3RvUHJpbWl0aXZlJyk7XG52YXIgaXNFbnVtID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPUFN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyIFVTRV9OQVRJVkUgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nICYmICEhJEdPUFMuZjtcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7IC8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xuXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDsgLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG5cbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRQKHRoaXMsICdhJywge1xuICAgICAgICB2YWx1ZTogN1xuICAgICAgfSkuYTtcbiAgICB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZiAocHJvdG9EZXNjKSBkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmIChwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKSBkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcblxuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuXG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwge1xuICAgICAgICBlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH1cblxuICByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuXG4gIHdoaWxlIChsID4gaSkgJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG5cbiAgcmV0dXJuIGl0O1xufTtcblxudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcblxudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSkge1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgdmFyIG5hbWVzID0gZ09QTih0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG5cbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90bztcbiAgdmFyIG5hbWVzID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcblxuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTsgLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5cblxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcblxuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuXG4gICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBzZXQ6ICRzZXRcbiAgICB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuXG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgJEdPUFMuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5JykpIHtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7XG4gIFN5bWJvbDogJFN5bWJvbFxufSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJy5zcGxpdCgnLCcpLCBqID0gMDsgZXM2U3ltYm9scy5sZW5ndGggPiBqOykgd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJykgPyBTeW1ib2xSZWdpc3RyeVtrZXldIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICBzZXR0ZXIgPSB0cnVlO1xuICB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHtcbiAgICBzZXR0ZXIgPSBmYWxzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTsgLy8gQ2hyb21lIDM4IGFuZCAzOSBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgZmFpbHMgb24gcHJpbWl0aXZlc1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzQ0M1xuXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9ICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gICRHT1BTLmYoMSk7XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogRkFJTFNfT05fUFJJTUlUSVZFUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgICByZXR1cm4gJEdPUFMuZih0b09iamVjdChpdCkpO1xuICB9XG59KTsgLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG5cbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBTID0gJFN5bWJvbCgpOyAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcblxuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoe1xuICAgIGE6IFNcbiAgfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcblxuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcblxuICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG5cbiAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pOyAvLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG5cbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpOyAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTsgLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpOyAvLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkdHlwZWQgPSByZXF1aXJlKCcuL190eXBlZCcpO1xuXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcblxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5BcnJheUJ1ZmZlcjtcblxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcblxudmFyICRBcnJheUJ1ZmZlciA9IGJ1ZmZlci5BcnJheUJ1ZmZlcjtcbnZhciAkRGF0YVZpZXcgPSBidWZmZXIuRGF0YVZpZXc7XG52YXIgJGlzVmlldyA9ICR0eXBlZC5BQlYgJiYgQXJyYXlCdWZmZXIuaXNWaWV3O1xudmFyICRzbGljZSA9ICRBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG52YXIgVklFVyA9ICR0eXBlZC5WSUVXO1xudmFyIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChBcnJheUJ1ZmZlciAhPT0gJEFycmF5QnVmZmVyKSwge1xuICBBcnJheUJ1ZmZlcjogJEFycmF5QnVmZmVyXG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISR0eXBlZC5DT05TVFIsIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjMuMSBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKVxuICBpc1ZpZXc6IGZ1bmN0aW9uIGlzVmlldyhpdCkge1xuICAgIHJldHVybiAkaXNWaWV3ICYmICRpc1ZpZXcoaXQpIHx8IGlzT2JqZWN0KGl0KSAmJiBWSUVXIGluIGl0O1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5VICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhbmV3ICRBcnJheUJ1ZmZlcigyKS5zbGljZSgxLCB1bmRlZmluZWQpLmJ5dGVMZW5ndGg7XG59KSwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuNC4zIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZShzdGFydCwgZW5kKVxuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIGlmICgkc2xpY2UgIT09IHVuZGVmaW5lZCAmJiBlbmQgPT09IHVuZGVmaW5lZCkgcmV0dXJuICRzbGljZS5jYWxsKGFuT2JqZWN0KHRoaXMpLCBzdGFydCk7IC8vIEZGIGZpeFxuXG4gICAgdmFyIGxlbiA9IGFuT2JqZWN0KHRoaXMpLmJ5dGVMZW5ndGg7XG4gICAgdmFyIGZpcnN0ID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xuICAgIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQsIGxlbik7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRBcnJheUJ1ZmZlcikpKHRvTGVuZ3RoKGZpbiAtIGZpcnN0KSk7XG4gICAgdmFyIHZpZXdTID0gbmV3ICREYXRhVmlldyh0aGlzKTtcbiAgICB2YXIgdmlld1QgPSBuZXcgJERhdGFWaWV3KHJlc3VsdCk7XG4gICAgdmFyIGluZGV4ID0gMDtcblxuICAgIHdoaWxlIChmaXJzdCA8IGZpbikge1xuICAgICAgdmlld1Quc2V0VWludDgoaW5kZXgrKywgdmlld1MuZ2V0VWludDgoZmlyc3QrKykpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKEFSUkFZX0JVRkZFUik7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fdHlwZWQnKS5BQlYsIHtcbiAgRGF0YVZpZXc6IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpLkRhdGFWaWV3XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnRmxvYXQ2NCcsIDgsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDY0QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDE2JywgMiwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gSW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MTYnLCAyLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhDbGFtcGVkQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0sIHRydWUpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgZWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKTtcblxudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcblxudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJyk7XG5cbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG5cbnZhciBOQVRJVkVfV0VBS19NQVAgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG5cbnZhciBJU19JRTExID0gIWdsb2JhbC5BY3RpdmVYT2JqZWN0ICYmICdBY3RpdmVYT2JqZWN0JyBpbiBnbG9iYWw7XG52YXIgV0VBS19NQVAgPSAnV2Vha01hcCc7XG52YXIgZ2V0V2VhayA9IG1ldGEuZ2V0V2VhaztcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSB3ZWFrLnVmc3RvcmU7XG52YXIgSW50ZXJuYWxNYXA7XG5cbnZhciB3cmFwcGVyID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn07XG5cbnZhciBtZXRob2RzID0ge1xuICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgV0VBS19NQVApKS5nZXQoa2V5KTtcbiAgICAgIHJldHVybiBkYXRhID8gZGF0YVt0aGlzLl9pXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHZhbGlkYXRlKHRoaXMsIFdFQUtfTUFQKSwga2V5LCB2YWx1ZSk7XG4gIH1cbn07IC8vIDIzLjMgV2Vha01hcCBPYmplY3RzXG5cbnZhciAkV2Vha01hcCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFdFQUtfTUFQLCB3cmFwcGVyLCBtZXRob2RzLCB3ZWFrLCB0cnVlLCB0cnVlKTsgLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuXG5cbmlmIChOQVRJVkVfV0VBS19NQVAgJiYgSVNfSUUxMSkge1xuICBJbnRlcm5hbE1hcCA9IHdlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgV0VBS19NQVApO1xuICBhc3NpZ24oSW50ZXJuYWxNYXAucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgZWFjaChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHByb3RvID0gJFdlYWtNYXAucHJvdG90eXBlO1xuICAgIHZhciBtZXRob2QgPSBwcm90b1trZXldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBrZXksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAvLyBzdG9yZSBmcm96ZW4gb2JqZWN0cyBvbiBpbnRlcm5hbCB3ZWFrbWFwIHNoaW1cbiAgICAgIGlmIChpc09iamVjdChhKSAmJiAhaXNFeHRlbnNpYmxlKGEpKSB7XG4gICAgICAgIGlmICghdGhpcy5fZikgdGhpcy5fZiA9IG5ldyBJbnRlcm5hbE1hcCgpO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9mW2tleV0oYSwgYik7XG5cbiAgICAgICAgcmV0dXJuIGtleSA9PSAnc2V0JyA/IHRoaXMgOiByZXN1bHQ7IC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWV0aG9kLmNhbGwodGhpcywgYSwgYik7XG4gICAgfSk7XG4gIH0pO1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcblxudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xuXG52YXIgV0VBS19TRVQgPSAnV2Vha1NldCc7IC8vIDIzLjQgV2Vha1NldCBPYmplY3RzXG5cbnJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShXRUFLX1NFVCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha1NldCgpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn0sIHtcbiAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHJldHVybiB3ZWFrLmRlZih2YWxpZGF0ZSh0aGlzLCBXRUFLX1NFVCksIHZhbHVlLCB0cnVlKTtcbiAgfVxufSwgd2VhaywgZmFsc2UsIHRydWUpOyIsIid1c2Ugc3RyaWN0JzsgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1mbGF0TWFwLyNzZWMtQXJyYXkucHJvdG90eXBlLmZsYXRNYXBcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGZsYXR0ZW5JbnRvQXJyYXkgPSByZXF1aXJlKCcuL19mbGF0dGVuLWludG8tYXJyYXknKTtcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgZmxhdE1hcDogZnVuY3Rpb24gZmxhdE1hcChjYWxsYmFja2ZuXG4gIC8qICwgdGhpc0FyZyAqL1xuICApIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBzb3VyY2VMZW4sIEE7XG4gICAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICAgIHNvdXJjZUxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xuICAgIGZsYXR0ZW5JbnRvQXJyYXkoQSwgTywgTywgc291cmNlTGVuLCAwLCAxLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2ZsYXRNYXAnKTsiLCIndXNlIHN0cmljdCc7IC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtZmxhdE1hcC8jc2VjLUFycmF5LnByb3RvdHlwZS5mbGF0dGVuXG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBmbGF0dGVuSW50b0FycmF5ID0gcmVxdWlyZSgnLi9fZmxhdHRlbi1pbnRvLWFycmF5Jyk7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcblxudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGZsYXR0ZW46IGZ1bmN0aW9uIGZsYXR0ZW4oKVxuICAvKiBkZXB0aEFyZyA9IDEgKi9cbiAge1xuICAgIHZhciBkZXB0aEFyZyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBzb3VyY2VMZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7XG4gICAgZmxhdHRlbkludG9BcnJheShBLCBPLCBPLCBzb3VyY2VMZW4sIDAsIGRlcHRoQXJnID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoQXJnKSk7XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnZmxhdHRlbicpOyIsIid1c2Ugc3RyaWN0JzsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkaW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWxcbiAgLyogLCBmcm9tSW5kZXggPSAwICovXG4gICkge1xuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdpbmNsdWRlcycpOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yd2FsZHJvbi90YzM5LW5vdGVzL2Jsb2IvbWFzdGVyL2VzNi8yMDE0LTA5L3NlcHQtMjUubWQjNTEwLWdsb2JhbGFzYXAtZm9yLWVucXVldWluZy1hLW1pY3JvdGFza1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG5cbnZhciBwcm9jZXNzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucHJvY2VzcztcblxudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcbiRleHBvcnQoJGV4cG9ydC5HLCB7XG4gIGFzYXA6IGZ1bmN0aW9uIGFzYXAoZm4pIHtcbiAgICB2YXIgZG9tYWluID0gaXNOb2RlICYmIHByb2Nlc3MuZG9tYWluO1xuICAgIG1pY3JvdGFzayhkb21haW4gPyBkb21haW4uYmluZChmbikgOiBmbik7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvcHJvcG9zYWwtaXMtZXJyb3JcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdFcnJvcicsIHtcbiAgaXNFcnJvcjogZnVuY3Rpb24gaXNFcnJvcihpdCkge1xuICAgIHJldHVybiBjb2YoaXQpID09PSAnRXJyb3InO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7XG4gIGdsb2JhbDogcmVxdWlyZSgnLi9fZ2xvYmFsJylcbn0pOyIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLW1hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ01hcCcpOyIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLW1hcC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnTWFwJyk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdNYXAnLCB7XG4gIHRvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ01hcCcpXG59KTsiLCIvLyBodHRwczovL3J3YWxkcm9uLmdpdGh1Yi5pby9wcm9wb3NhbC1tYXRoLWV4dGVuc2lvbnMvXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNsYW1wOiBmdW5jdGlvbiBjbGFtcCh4LCBsb3dlciwgdXBwZXIpIHtcbiAgICByZXR1cm4gTWF0aC5taW4odXBwZXIsIE1hdGgubWF4KGxvd2VyLCB4KSk7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgREVHX1BFUl9SQUQ6IE1hdGguUEkgLyAxODBcbn0pOyIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBSQURfUEVSX0RFRyA9IDE4MCAvIE1hdGguUEk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGRlZ3JlZXM6IGZ1bmN0aW9uIGRlZ3JlZXMocmFkaWFucykge1xuICAgIHJldHVybiByYWRpYW5zICogUkFEX1BFUl9ERUc7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBzY2FsZSA9IHJlcXVpcmUoJy4vX21hdGgtc2NhbGUnKTtcblxudmFyIGZyb3VuZCA9IHJlcXVpcmUoJy4vX21hdGgtZnJvdW5kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgZnNjYWxlOiBmdW5jdGlvbiBmc2NhbGUoeCwgaW5Mb3csIGluSGlnaCwgb3V0TG93LCBvdXRIaWdoKSB7XG4gICAgcmV0dXJuIGZyb3VuZChzY2FsZSh4LCBpbkxvdywgaW5IaWdoLCBvdXRMb3csIG91dEhpZ2gpKTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaWFkZGg6IGZ1bmN0aW9uIGlhZGRoKHgwLCB4MSwgeTAsIHkxKSB7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwO1xuICAgIHZhciAkeDEgPSB4MSA+Pj4gMDtcbiAgICB2YXIgJHkwID0geTAgPj4+IDA7XG4gICAgcmV0dXJuICR4MSArICh5MSA+Pj4gMCkgKyAoKCR4MCAmICR5MCB8ICgkeDAgfCAkeTApICYgfigkeDAgKyAkeTAgPj4+IDApKSA+Pj4gMzEpIHwgMDtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaW11bGg6IGZ1bmN0aW9uIGltdWxoKHUsIHYpIHtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmO1xuICAgIHZhciAkdSA9ICt1O1xuICAgIHZhciAkdiA9ICt2O1xuICAgIHZhciB1MCA9ICR1ICYgVUlOVDE2O1xuICAgIHZhciB2MCA9ICR2ICYgVUlOVDE2O1xuICAgIHZhciB1MSA9ICR1ID4+IDE2O1xuICAgIHZhciB2MSA9ICR2ID4+IDE2O1xuICAgIHZhciB0ID0gKHUxICogdjAgPj4+IDApICsgKHUwICogdjAgPj4+IDE2KTtcbiAgICByZXR1cm4gdTEgKiB2MSArICh0ID4+IDE2KSArICgodTAgKiB2MSA+Pj4gMCkgKyAodCAmIFVJTlQxNikgPj4gMTYpO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpc3ViaDogZnVuY3Rpb24gaXN1YmgoeDAsIHgxLCB5MCwgeTEpIHtcbiAgICB2YXIgJHgwID0geDAgPj4+IDA7XG4gICAgdmFyICR4MSA9IHgxID4+PiAwO1xuICAgIHZhciAkeTAgPSB5MCA+Pj4gMDtcbiAgICByZXR1cm4gJHgxIC0gKHkxID4+PiAwKSAtICgofiR4MCAmICR5MCB8IH4oJHgwIF4gJHkwKSAmICR4MCAtICR5MCA+Pj4gMCkgPj4+IDMxKSB8IDA7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgUkFEX1BFUl9ERUc6IDE4MCAvIE1hdGguUElcbn0pOyIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBERUdfUEVSX1JBRCA9IE1hdGguUEkgLyAxODA7XG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHJhZGlhbnM6IGZ1bmN0aW9uIHJhZGlhbnMoZGVncmVlcykge1xuICAgIHJldHVybiBkZWdyZWVzICogREVHX1BFUl9SQUQ7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vcndhbGRyb24uZ2l0aHViLmlvL3Byb3Bvc2FsLW1hdGgtZXh0ZW5zaW9ucy9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgc2NhbGU6IHJlcXVpcmUoJy4vX21hdGgtc2NhbGUnKVxufSk7IiwiLy8gaHR0cDovL2pmYmFzdGllbi5naXRodWIuaW8vcGFwZXJzL01hdGguc2lnbmJpdC5odG1sXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHNpZ25iaXQ6IGZ1bmN0aW9uIHNpZ25iaXQoeCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByZXR1cm4gKHggPSAreCkgIT0geCA/IHggOiB4ID09IDAgPyAxIC8geCA9PSBJbmZpbml0eSA6IHggPiAwO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB1bXVsaDogZnVuY3Rpb24gdW11bGgodSwgdikge1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmY7XG4gICAgdmFyICR1ID0gK3U7XG4gICAgdmFyICR2ID0gK3Y7XG4gICAgdmFyIHUwID0gJHUgJiBVSU5UMTY7XG4gICAgdmFyIHYwID0gJHYgJiBVSU5UMTY7XG4gICAgdmFyIHUxID0gJHUgPj4+IDE2O1xuICAgIHZhciB2MSA9ICR2ID4+PiAxNjtcbiAgICB2YXIgdCA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+Pj4gMTYpICsgKCh1MCAqIHYxID4+PiAwKSArICh0ICYgVUlOVDE2KSA+Pj4gMTYpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7IC8vIEIuMi4yLjIgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKFAsIGdldHRlcilcblxuXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19kZWZpbmVHZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpIHtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwge1xuICAgICAgZ2V0OiBhRnVuY3Rpb24oZ2V0dGVyKSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcblxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpOyAvLyBCLjIuMi4zIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXyhQLCBzZXR0ZXIpXG5cblxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fZGVmaW5lU2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lU2V0dGVyX18oUCwgc2V0dGVyKSB7XG4gICAgJGRlZmluZVByb3BlcnR5LmYodG9PYmplY3QodGhpcyksIFAsIHtcbiAgICAgIHNldDogYUZ1bmN0aW9uKHNldHRlciksXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRlbnRyaWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKGl0KSB7XG4gICAgcmV0dXJuICRlbnRyaWVzKGl0KTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciBvd25LZXlzID0gcmVxdWlyZSgnLi9fb3duLWtleXMnKTtcblxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xuXG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqZWN0KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgICB2YXIgZ2V0RGVzYyA9IGdPUEQuZjtcbiAgICB2YXIga2V5cyA9IG93bktleXMoTyk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5LCBkZXNjO1xuXG4gICAgd2hpbGUgKGtleXMubGVuZ3RoID4gaSkge1xuICAgICAgZGVzYyA9IGdldERlc2MoTywga2V5ID0ga2V5c1tpKytdKTtcbiAgICAgIGlmIChkZXNjICE9PSB1bmRlZmluZWQpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5LCBkZXNjKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xuXG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mOyAvLyBCLjIuMi40IE9iamVjdC5wcm90b3R5cGUuX19sb29rdXBHZXR0ZXJfXyhQKVxuXG5cbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cEdldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cEdldHRlcl9fKFApIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gICAgdmFyIEQ7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoRCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBLKSkgcmV0dXJuIEQuZ2V0O1xuICAgIH0gd2hpbGUgKE8gPSBnZXRQcm90b3R5cGVPZihPKSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG5cbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7IC8vIEIuMi4yLjUgT2JqZWN0LnByb3RvdHlwZS5fX2xvb2t1cFNldHRlcl9fKFApXG5cblxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fbG9va3VwU2V0dGVyX186IGZ1bmN0aW9uIF9fbG9va3VwU2V0dGVyX18oUCkge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIEsgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgICB2YXIgRDtcblxuICAgIGRvIHtcbiAgICAgIGlmIChEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKSByZXR1cm4gRC5zZXQ7XG4gICAgfSB3aGlsZSAoTyA9IGdldFByb3RvdHlwZU9mKE8pKTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJHZhbHVlcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKGZhbHNlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKGl0KSB7XG4gICAgcmV0dXJuICR2YWx1ZXMoaXQpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcblxudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG5cbnZhciBPQlNFUlZBQkxFID0gcmVxdWlyZSgnLi9fd2tzJykoJ29ic2VydmFibGUnKTtcblxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcblxudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG5cbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xuXG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxudmFyIFJFVFVSTiA9IGZvck9mLlJFVFVSTjtcblxudmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFGdW5jdGlvbihmbik7XG59O1xuXG52YXIgY2xlYW51cFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgdmFyIGNsZWFudXAgPSBzdWJzY3JpcHRpb24uX2M7XG5cbiAgaWYgKGNsZWFudXApIHtcbiAgICBzdWJzY3JpcHRpb24uX2MgPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cCgpO1xuICB9XG59O1xuXG52YXIgc3Vic2NyaXB0aW9uQ2xvc2VkID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICByZXR1cm4gc3Vic2NyaXB0aW9uLl9vID09PSB1bmRlZmluZWQ7XG59O1xuXG52YXIgY2xvc2VTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gIGlmICghc3Vic2NyaXB0aW9uQ2xvc2VkKHN1YnNjcmlwdGlvbikpIHtcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICB9XG59O1xuXG52YXIgU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzdWJzY3JpYmVyKSB7XG4gIGFuT2JqZWN0KG9ic2VydmVyKTtcbiAgdGhpcy5fYyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fbyA9IG9ic2VydmVyO1xuICBvYnNlcnZlciA9IG5ldyBTdWJzY3JpcHRpb25PYnNlcnZlcih0aGlzKTtcblxuICB0cnkge1xuICAgIHZhciBjbGVhbnVwID0gc3Vic2NyaWJlcihvYnNlcnZlcik7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IGNsZWFudXA7XG5cbiAgICBpZiAoY2xlYW51cCAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIGNsZWFudXAudW5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbicpIGNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgfTtlbHNlIGFGdW5jdGlvbihjbGVhbnVwKTtcbiAgICAgIHRoaXMuX2MgPSBjbGVhbnVwO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdWJzY3JpcHRpb25DbG9zZWQodGhpcykpIGNsZWFudXBTdWJzY3JpcHRpb24odGhpcyk7XG59O1xuXG5TdWJzY3JpcHRpb24ucHJvdG90eXBlID0gcmVkZWZpbmVBbGwoe30sIHtcbiAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgIGNsb3NlU3Vic2NyaXB0aW9uKHRoaXMpO1xuICB9XG59KTtcblxudmFyIFN1YnNjcmlwdGlvbk9ic2VydmVyID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICB0aGlzLl9zID0gc3Vic2NyaXB0aW9uO1xufTtcblxuU3Vic2NyaXB0aW9uT2JzZXJ2ZXIucHJvdG90eXBlID0gcmVkZWZpbmVBbGwoe30sIHtcbiAgbmV4dDogZnVuY3Rpb24gbmV4dCh2YWx1ZSkge1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zO1xuXG4gICAgaWYgKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSkge1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5uZXh0KTtcbiAgICAgICAgaWYgKG0pIHJldHVybiBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjbG9zZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcih2YWx1ZSkge1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zO1xuICAgIGlmIChzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSkgdGhyb3cgdmFsdWU7XG4gICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5lcnJvcik7XG4gICAgICBpZiAoIW0pIHRocm93IHZhbHVlO1xuICAgICAgdmFsdWUgPSBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSh2YWx1ZSkge1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zO1xuXG4gICAgaWYgKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSkge1xuICAgICAgdmFyIG9ic2VydmVyID0gc3Vic2NyaXB0aW9uLl9vO1xuICAgICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5jb21wbGV0ZSk7XG4gICAgICAgIHZhbHVlID0gbSA/IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpIDogdW5kZWZpbmVkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgJE9ic2VydmFibGUgPSBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZXIpIHtcbiAgYW5JbnN0YW5jZSh0aGlzLCAkT2JzZXJ2YWJsZSwgJ09ic2VydmFibGUnLCAnX2YnKS5fZiA9IGFGdW5jdGlvbihzdWJzY3JpYmVyKTtcbn07XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLnByb3RvdHlwZSwge1xuICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKG9ic2VydmVyLCB0aGlzLl9mKTtcbiAgfSxcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IChjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGFGdW5jdGlvbihmbik7XG4gICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhhdC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgIGNvbXBsZXRlOiByZXNvbHZlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG5yZWRlZmluZUFsbCgkT2JzZXJ2YWJsZSwge1xuICBmcm9tOiBmdW5jdGlvbiBmcm9tKHgpIHtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6ICRPYnNlcnZhYmxlO1xuICAgIHZhciBtZXRob2QgPSBnZXRNZXRob2QoYW5PYmplY3QoeClbT0JTRVJWQUJMRV0pO1xuXG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgdmFyIG9ic2VydmFibGUgPSBhbk9iamVjdChtZXRob2QuY2FsbCh4KSk7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZS5jb25zdHJ1Y3RvciA9PT0gQyA/IG9ic2VydmFibGUgOiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGZvck9mKHgsIGZhbHNlLCBmdW5jdGlvbiAoaXQpIHtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChpdCk7XG4gICAgICAgICAgICAgIGlmIChkb25lKSByZXR1cm4gUkVUVVJOO1xuICAgICAgICAgICAgfSkgPT09IFJFVFVSTikgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChkb25lKSB0aHJvdyBlO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH0sXG4gIG9mOiBmdW5jdGlvbiBvZigpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KGwpOyBpIDwgbDspIGl0ZW1zW2ldID0gYXJndW1lbnRzW2krK107XG5cbiAgICByZXR1cm4gbmV3ICh0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiAkT2JzZXJ2YWJsZSkoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChpdGVtc1tqXSk7XG4gICAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59KTtcbmhpZGUoJE9ic2VydmFibGUucHJvdG90eXBlLCBPQlNFUlZBQkxFLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufSk7XG4kZXhwb3J0KCRleHBvcnQuRywge1xuICBPYnNlcnZhYmxlOiAkT2JzZXJ2YWJsZVxufSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ09ic2VydmFibGUnKTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcm9taXNlLWZpbmFsbHlcbid1c2Ugc3RyaWN0JztcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcblxudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnUHJvbWlzZScsIHtcbiAgJ2ZpbmFsbHknOiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gICAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgY29yZS5Qcm9taXNlIHx8IGdsb2JhbC5Qcm9taXNlKTtcbiAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBvbkZpbmFsbHkgPT0gJ2Z1bmN0aW9uJztcbiAgICByZXR1cm4gdGhpcy50aGVuKGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9KTtcbiAgICB9IDogb25GaW5hbGx5LCBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KTtcbiAgICB9IDogb25GaW5hbGx5KTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcm9taXNlLXRyeVxuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1Byb21pc2UnLCB7XG4gICd0cnknOiBmdW5jdGlvbiAoY2FsbGJhY2tmbikge1xuICAgIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYodGhpcyk7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oY2FsbGJhY2tmbik7XG4gICAgKHJlc3VsdC5lID8gcHJvbWlzZUNhcGFiaWxpdHkucmVqZWN0IDogcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZSkocmVzdWx0LnYpO1xuICAgIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTsiLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcbnZhciBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gbWV0YWRhdGEuc2V0O1xubWV0YWRhdGEuZXhwKHtcbiAgZGVmaW5lTWV0YWRhdGE6IGZ1bmN0aW9uIGRlZmluZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHRhcmdldEtleSkge1xuICAgIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIGFuT2JqZWN0KHRhcmdldCksIHRvTWV0YUtleSh0YXJnZXRLZXkpKTtcbiAgfVxufSk7IiwidmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG52YXIgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCA9IG1ldGFkYXRhLm1hcDtcbnZhciBzdG9yZSA9IG1ldGFkYXRhLnN0b3JlO1xubWV0YWRhdGEuZXhwKHtcbiAgZGVsZXRlTWV0YWRhdGE6IGZ1bmN0aW9uIGRlbGV0ZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXRcbiAgLyogLCB0YXJnZXRLZXkgKi9cbiAgKSB7XG4gICAgdmFyIHRhcmdldEtleSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSk7XG4gICAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChhbk9iamVjdCh0YXJnZXQpLCB0YXJnZXRLZXksIGZhbHNlKTtcbiAgICBpZiAobWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCB8fCAhbWV0YWRhdGFNYXBbJ2RlbGV0ZSddKG1ldGFkYXRhS2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChtZXRhZGF0YU1hcC5zaXplKSByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBzdG9yZS5nZXQodGFyZ2V0KTtcbiAgICB0YXJnZXRNZXRhZGF0YVsnZGVsZXRlJ10odGFyZ2V0S2V5KTtcbiAgICByZXR1cm4gISF0YXJnZXRNZXRhZGF0YS5zaXplIHx8IHN0b3JlWydkZWxldGUnXSh0YXJnZXQpO1xuICB9XG59KTsiLCJ2YXIgU2V0ID0gcmVxdWlyZSgnLi9lczYuc2V0Jyk7XG5cbnZhciBmcm9tID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xuXG52YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG52YXIgb3JkaW5hcnlPd25NZXRhZGF0YUtleXMgPSBtZXRhZGF0YS5rZXlzO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5TWV0YWRhdGFLZXlzID0gZnVuY3Rpb24gKE8sIFApIHtcbiAgdmFyIG9LZXlzID0gb3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUCk7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgaWYgKHBhcmVudCA9PT0gbnVsbCkgcmV0dXJuIG9LZXlzO1xuICB2YXIgcEtleXMgPSBvcmRpbmFyeU1ldGFkYXRhS2V5cyhwYXJlbnQsIFApO1xuICByZXR1cm4gcEtleXMubGVuZ3RoID8gb0tleXMubGVuZ3RoID8gZnJvbShuZXcgU2V0KG9LZXlzLmNvbmNhdChwS2V5cykpKSA6IHBLZXlzIDogb0tleXM7XG59O1xuXG5tZXRhZGF0YS5leHAoe1xuICBnZXRNZXRhZGF0YUtleXM6IGZ1bmN0aW9uIGdldE1ldGFkYXRhS2V5cyh0YXJnZXRcbiAgLyogLCB0YXJnZXRLZXkgKi9cbiAgKSB7XG4gICAgcmV0dXJuIG9yZGluYXJ5TWV0YWRhdGFLZXlzKGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1sxXSkpO1xuICB9XG59KTsiLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhcztcbnZhciBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gbWV0YWRhdGEuZ2V0O1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5R2V0TWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgdmFyIGhhc093biA9IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICBpZiAoaGFzT3duKSByZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IG9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCkgOiB1bmRlZmluZWQ7XG59O1xuXG5tZXRhZGF0YS5leHAoe1xuICBnZXRNZXRhZGF0YTogZnVuY3Rpb24gZ2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldFxuICAvKiAsIHRhcmdldEtleSAqL1xuICApIHtcbiAgICByZXR1cm4gb3JkaW5hcnlHZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG4gIH1cbn0pOyIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgb3JkaW5hcnlPd25NZXRhZGF0YUtleXMgPSBtZXRhZGF0YS5rZXlzO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcbm1ldGFkYXRhLmV4cCh7XG4gIGdldE93bk1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGFLZXlzKHRhcmdldFxuICAvKiAsIHRhcmdldEtleSAqL1xuICApIHtcbiAgICByZXR1cm4gb3JkaW5hcnlPd25NZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG4gIH1cbn0pOyIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmdldDtcbnZhciB0b01ldGFLZXkgPSBtZXRhZGF0YS5rZXk7XG5tZXRhZGF0YS5leHAoe1xuICBnZXRPd25NZXRhZGF0YTogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldFxuICAvKiAsIHRhcmdldEtleSAqL1xuICApIHtcbiAgICByZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG4gIH1cbn0pOyIsInZhciBtZXRhZGF0YSA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJyk7XG5cbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzO1xudmFyIHRvTWV0YUtleSA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5SGFzTWV0YWRhdGEgPSBmdW5jdGlvbiAoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgdmFyIGhhc093biA9IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICBpZiAoaGFzT3duKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gb3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKSA6IGZhbHNlO1xufTtcblxubWV0YWRhdGEuZXhwKHtcbiAgaGFzTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXRcbiAgLyogLCB0YXJnZXRLZXkgKi9cbiAgKSB7XG4gICAgcmV0dXJuIG9yZGluYXJ5SGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xuICB9XG59KTsiLCJ2YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXM7XG52YXIgdG9NZXRhS2V5ID0gbWV0YWRhdGEua2V5O1xubWV0YWRhdGEuZXhwKHtcbiAgaGFzT3duTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXRcbiAgLyogLCB0YXJnZXRLZXkgKi9cbiAgKSB7XG4gICAgcmV0dXJuIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xuICB9XG59KTsiLCJ2YXIgJG1ldGFkYXRhID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKTtcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbnZhciB0b01ldGFLZXkgPSAkbWV0YWRhdGEua2V5O1xudmFyIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSAkbWV0YWRhdGEuc2V0O1xuJG1ldGFkYXRhLmV4cCh7XG4gIG1ldGFkYXRhOiBmdW5jdGlvbiBtZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0LCB0YXJnZXRLZXkpIHtcbiAgICAgIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsICh0YXJnZXRLZXkgIT09IHVuZGVmaW5lZCA/IGFuT2JqZWN0IDogYUZ1bmN0aW9uKSh0YXJnZXQpLCB0b01ldGFLZXkodGFyZ2V0S2V5KSk7XG4gICAgfTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtc2V0LmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnU2V0Jyk7IiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtc2V0Lm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdTZXQnKTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1NldCcsIHtcbiAgdG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0Jylcbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBhdDogZnVuY3Rpb24gYXQocG9zKSB7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vU3RyaW5nLnByb3RvdHlwZS5tYXRjaEFsbC9cblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKTtcblxudmFyIGdldEZsYWdzID0gcmVxdWlyZSgnLi9fZmxhZ3MnKTtcblxudmFyIFJlZ0V4cFByb3RvID0gUmVnRXhwLnByb3RvdHlwZTtcblxudmFyICRSZWdFeHBTdHJpbmdJdGVyYXRvciA9IGZ1bmN0aW9uIChyZWdleHAsIHN0cmluZykge1xuICB0aGlzLl9yID0gcmVnZXhwO1xuICB0aGlzLl9zID0gc3RyaW5nO1xufTtcblxucmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKSgkUmVnRXhwU3RyaW5nSXRlcmF0b3IsICdSZWdFeHAgU3RyaW5nJywgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIG1hdGNoID0gdGhpcy5fci5leGVjKHRoaXMuX3MpO1xuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IG1hdGNoLFxuICAgIGRvbmU6IG1hdGNoID09PSBudWxsXG4gIH07XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIG1hdGNoQWxsOiBmdW5jdGlvbiBtYXRjaEFsbChyZWdleHApIHtcbiAgICBkZWZpbmVkKHRoaXMpO1xuICAgIGlmICghaXNSZWdFeHAocmVnZXhwKSkgdGhyb3cgVHlwZUVycm9yKHJlZ2V4cCArICcgaXMgbm90IGEgcmVnZXhwIScpO1xuICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgIHZhciBmbGFncyA9ICdmbGFncycgaW4gUmVnRXhwUHJvdG8gPyBTdHJpbmcocmVnZXhwLmZsYWdzKSA6IGdldEZsYWdzLmNhbGwocmVnZXhwKTtcbiAgICB2YXIgcnggPSBuZXcgUmVnRXhwKHJlZ2V4cC5zb3VyY2UsIH5mbGFncy5pbmRleE9mKCdnJykgPyBmbGFncyA6ICdnJyArIGZsYWdzKTtcbiAgICByeC5sYXN0SW5kZXggPSB0b0xlbmd0aChyZWdleHAubGFzdEluZGV4KTtcbiAgICByZXR1cm4gbmV3ICRSZWdFeHBTdHJpbmdJdGVyYXRvcihyeCwgUyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JzsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcblxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxudmFyICRwYWQgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG5cbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8yODBcblxuXG52YXIgV0VCS0lUX0JVRyA9IC9WZXJzaW9uXFwvMTBcXC5cXGQrKFxcLlxcZCspPyggTW9iaWxlXFwvXFx3Kyk/IFNhZmFyaVxcLy8udGVzdCh1c2VyQWdlbnQpO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBXRUJLSVRfQlVHLCAnU3RyaW5nJywge1xuICBwYWRFbmQ6IGZ1bmN0aW9uIHBhZEVuZChtYXhMZW5ndGhcbiAgLyogLCBmaWxsU3RyaW5nID0gJyAnICovXG4gICkge1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGZhbHNlKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgJHBhZCA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcblxudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4vX3VzZXItYWdlbnQnKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzI4MFxuXG5cbnZhciBXRUJLSVRfQlVHID0gL1ZlcnNpb25cXC8xMFxcLlxcZCsoXFwuXFxkKyk/KCBNb2JpbGVcXC9cXHcrKT8gU2FmYXJpXFwvLy50ZXN0KHVzZXJBZ2VudCk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIFdFQktJVF9CVUcsICdTdHJpbmcnLCB7XG4gIHBhZFN0YXJ0OiBmdW5jdGlvbiBwYWRTdGFydChtYXhMZW5ndGhcbiAgLyogLCBmaWxsU3RyaW5nID0gJyAnICovXG4gICkge1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRydWUpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWJtYXJrYmFnZS9lY21hc2NyaXB0LXN0cmluZy1sZWZ0LXJpZ2h0LXRyaW1cblxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbUxlZnQnLCBmdW5jdGlvbiAoJHRyaW0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW1MZWZ0KCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAxKTtcbiAgfTtcbn0sICd0cmltU3RhcnQnKTsiLCIndXNlIHN0cmljdCc7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWJtYXJrYmFnZS9lY21hc2NyaXB0LXN0cmluZy1sZWZ0LXJpZ2h0LXRyaW1cblxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbVJpZ2h0JywgZnVuY3Rpb24gKCR0cmltKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltUmlnaHQoKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDIpO1xuICB9O1xufSwgJ3RyaW1FbmQnKTsiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTsiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3lzdGVtJywge1xuICBnbG9iYWw6IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG59KTsiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrbWFwLmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnV2Vha01hcCcpOyIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWttYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1dlYWtNYXAnKTsiLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrc2V0LmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnV2Vha1NldCcpOyIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWtzZXQub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1dlYWtTZXQnKTsiLCJ2YXIgJGl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG5cbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcblxudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xuXG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdrcygnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gSXRlcmF0b3JzLkFycmF5O1xudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IHRydWUsXG4gIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgQ1NTVmFsdWVMaXN0OiBmYWxzZSxcbiAgQ2xpZW50UmVjdExpc3Q6IGZhbHNlLFxuICBET01SZWN0TGlzdDogZmFsc2UsXG4gIERPTVN0cmluZ0xpc3Q6IGZhbHNlLFxuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBmYWxzZSxcbiAgRmlsZUxpc3Q6IGZhbHNlLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IGZhbHNlLFxuICBNZWRpYUxpc3Q6IHRydWUsXG4gIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBNaW1lVHlwZUFycmF5OiBmYWxzZSxcbiAgTmFtZWROb2RlTWFwOiBmYWxzZSxcbiAgTm9kZUxpc3Q6IHRydWUsXG4gIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLFxuICBQbHVnaW46IGZhbHNlLFxuICBQbHVnaW5BcnJheTogZmFsc2UsXG4gIFNWR0xlbmd0aExpc3Q6IGZhbHNlLFxuICBTVkdOdW1iZXJMaXN0OiBmYWxzZSxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IGZhbHNlLFxuICBTVkdQb2ludExpc3Q6IGZhbHNlLFxuICBTVkdTdHJpbmdMaXN0OiBmYWxzZSxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogZmFsc2UsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLFxuICBTdHlsZVNoZWV0TGlzdDogdHJ1ZSxcbiAgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIFRleHRUcmFja0N1ZUxpc3Q6IGZhbHNlLFxuICBUZXh0VHJhY2tMaXN0OiBmYWxzZSxcbiAgVG91Y2hMaXN0OiBmYWxzZVxufTtcblxuZm9yICh2YXIgY29sbGVjdGlvbnMgPSBnZXRLZXlzKERPTUl0ZXJhYmxlcyksIGkgPSAwOyBpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBjb2xsZWN0aW9uc1tpXTtcbiAgdmFyIGV4cGxpY2l0ID0gRE9NSXRlcmFibGVzW05BTUVdO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGtleTtcblxuICBpZiAocHJvdG8pIHtcbiAgICBpZiAoIXByb3RvW0lURVJBVE9SXSkgaGlkZShwcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICBpZiAoIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBBcnJheVZhbHVlcztcbiAgICBpZiAoZXhwbGljaXQpIGZvciAoa2V5IGluICRpdGVyYXRvcnMpIGlmICghcHJvdG9ba2V5XSkgcmVkZWZpbmUocHJvdG8sIGtleSwgJGl0ZXJhdG9yc1trZXldLCB0cnVlKTtcbiAgfVxufSIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbnZhciAkdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKTtcblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIsIHtcbiAgc2V0SW1tZWRpYXRlOiAkdGFzay5zZXQsXG4gIGNsZWFySW1tZWRpYXRlOiAkdGFzay5jbGVhclxufSk7IiwiLy8gaWU5LSBzZXRUaW1lb3V0ICYgc2V0SW50ZXJ2YWwgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi9fdXNlci1hZ2VudCcpO1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcbnZhciBNU0lFID0gL01TSUUgLlxcLi8udGVzdCh1c2VyQWdlbnQpOyAvLyA8LSBkaXJ0eSBpZTktIGNoZWNrXG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHNldCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGZuLCB0aW1lXG4gIC8qICwgLi4uYXJncyAqL1xuICApIHtcbiAgICB2YXIgYm91bmRBcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgdmFyIGFyZ3MgPSBib3VuZEFyZ3MgPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMikgOiBmYWxzZTtcbiAgICByZXR1cm4gc2V0KGJvdW5kQXJncyA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbikpLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gOiBmbiwgdGltZSk7XG4gIH07XG59O1xuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiArICRleHBvcnQuRiAqIE1TSUUsIHtcbiAgc2V0VGltZW91dDogd3JhcChnbG9iYWwuc2V0VGltZW91dCksXG4gIHNldEludGVydmFsOiB3cmFwKGdsb2JhbC5zZXRJbnRlcnZhbClcbn0pOyIsInJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4nKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wYXJzZS1pbnQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3RvcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24nKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuZXBzaWxvbicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4nKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXInKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hc2luaCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXRhbmgnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNicnQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNsejMyJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jb3NoJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5leHBtMScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5oeXBvdCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguaW11bCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cyJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5zaWduJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5zaW5oJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC50YW5oJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC50cnVuYycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmF3Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0nKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGgnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5iaWcnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3InKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udHNpemUnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5saW5rJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdWInKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3VwJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS5ub3cnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24nKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXknKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkub2YnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5qb2luJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zb3J0Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2gnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5tYXAnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXInKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zb21lJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZXZlcnknKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbGwnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNwZWNpZXMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3RvcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5leGVjJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnByb21pc2UnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXAnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zZXQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLW1hcCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstc2V0Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXknKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXknKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuYXBwbHknKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHknKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmhhcycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaXMtZXh0ZW5zaWJsZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hcnJheS5mbGF0LW1hcCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFycmF5LmZsYXR0ZW4nKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcuYXQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXInKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlcicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWFwLnRvLWpzb24nKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zZXQudG8tanNvbicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC5vZicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC5vZicpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LndlYWstbWFwLm9mJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1zZXQub2YnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXAuZnJvbScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC5mcm9tJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LndlYWstc2V0LmZyb20nKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5nbG9iYWwnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeXN0ZW0uZ2xvYmFsJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3InKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmNsYW1wJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5kZWctcGVyLXJhZCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguZGVncmVlcycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguZnNjYWxlJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pYWRkaCcpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaXN1YmgnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmltdWxoJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5yYWQtcGVyLWRlZycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGgucmFkaWFucycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguc2NhbGUnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5zaWduYml0Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5Jyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucHJvbWlzZS50cnknKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEnKTtcblxucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hc2FwJyk7XG5cbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JzZXJ2YWJsZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLnRpbWVycycpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmltbWVkaWF0ZScpO1xuXG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbW9kdWxlcy9fY29yZScpOyIsIi8qXG4gSGlnaGNoYXJ0cyBKUyB2OC4wLjQgKDIwMjAtMDMtMTApXG5cbiAoYykgMjAwOS0yMDE4IFRvcnN0ZWluIEhvbnNpXG5cbiBMaWNlbnNlOiB3d3cuaGlnaGNoYXJ0cy5jb20vbGljZW5zZVxuKi9cbihmdW5jdGlvbiAoYWEsIFMpIHtcbiAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cyA/IChTW1wiZGVmYXVsdFwiXSA9IFMsIG1vZHVsZS5leHBvcnRzID0gYWEuZG9jdW1lbnQgPyBTKGFhKSA6IFMpIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoXCJoaWdoY2hhcnRzL2hpZ2hjaGFydHNcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBTKGFhKTtcbiAgfSkgOiAoYWEuSGlnaGNoYXJ0cyAmJiBhYS5IaWdoY2hhcnRzLmVycm9yKDE2LCAhMCksIGFhLkhpZ2hjaGFydHMgPSBTKGFhKSk7XG59KShcInVuZGVmaW5lZFwiICE9PSB0eXBlb2Ygd2luZG93ID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24gKGFhKSB7XG4gIGZ1bmN0aW9uIFMoZCwgZywgVywgdSkge1xuICAgIGQuaGFzT3duUHJvcGVydHkoZykgfHwgKGRbZ10gPSB1LmFwcGx5KG51bGwsIFcpKTtcbiAgfVxuXG4gIHZhciByID0ge307XG4gIFMociwgXCJwYXJ0cy9HbG9iYWxzLmpzXCIsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGQgPSBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYWEgPyBhYSA6IFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiB3aW5kb3cgPyB3aW5kb3cgOiB7fSxcbiAgICAgICAgZyA9IGQuZG9jdW1lbnQsXG4gICAgICAgIFcgPSBkLm5hdmlnYXRvciAmJiBkLm5hdmlnYXRvci51c2VyQWdlbnQgfHwgXCJcIixcbiAgICAgICAgdSA9IGcgJiYgZy5jcmVhdGVFbGVtZW50TlMgJiYgISFnLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpLmNyZWF0ZVNWR1JlY3QsXG4gICAgICAgIHIgPSAvKGVkZ2V8bXNpZXx0cmlkZW50KS9pLnRlc3QoVykgJiYgIWQub3BlcmEsXG4gICAgICAgIE0gPSAtMSAhPT0gVy5pbmRleE9mKFwiRmlyZWZveFwiKSxcbiAgICAgICAgRSA9IC0xICE9PSBXLmluZGV4T2YoXCJDaHJvbWVcIiksXG4gICAgICAgIEEgPSBNICYmIDQgPiBwYXJzZUludChXLnNwbGl0KFwiRmlyZWZveC9cIilbMV0sIDEwKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvZHVjdDogXCJIaWdoY2hhcnRzXCIsXG4gICAgICB2ZXJzaW9uOiBcIjguMC40XCIsXG4gICAgICBkZWcycmFkOiAyICogTWF0aC5QSSAvIDM2MCxcbiAgICAgIGRvYzogZyxcbiAgICAgIGhhc0JpZGlCdWc6IEEsXG4gICAgICBoYXNUb3VjaDogISFkLlRvdWNoRXZlbnQsXG4gICAgICBpc01TOiByLFxuICAgICAgaXNXZWJLaXQ6IC0xICE9PSBXLmluZGV4T2YoXCJBcHBsZVdlYktpdFwiKSxcbiAgICAgIGlzRmlyZWZveDogTSxcbiAgICAgIGlzQ2hyb21lOiBFLFxuICAgICAgaXNTYWZhcmk6ICFFICYmIC0xICE9PSBXLmluZGV4T2YoXCJTYWZhcmlcIiksXG4gICAgICBpc1RvdWNoRGV2aWNlOiAvKE1vYmlsZXxBbmRyb2lkfFdpbmRvd3MgUGhvbmUpLy50ZXN0KFcpLFxuICAgICAgU1ZHX05TOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICBjaGFydENvdW50OiAwLFxuICAgICAgc2VyaWVzVHlwZXM6IHt9LFxuICAgICAgc3ltYm9sU2l6ZXM6IHt9LFxuICAgICAgc3ZnOiB1LFxuICAgICAgd2luOiBkLFxuICAgICAgbWFyZ2luTmFtZXM6IFtcInBsb3RUb3BcIiwgXCJtYXJnaW5SaWdodFwiLCBcIm1hcmdpbkJvdHRvbVwiLCBcInBsb3RMZWZ0XCJdLFxuICAgICAgbm9vcDogZnVuY3Rpb24gKCkge30sXG4gICAgICBjaGFydHM6IFtdLFxuICAgICAgZGF0ZUZvcm1hdHM6IHt9XG4gICAgfTtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9VdGlsaXRpZXMuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdXSwgZnVuY3Rpb24gKGQpIHtcbiAgICBmdW5jdGlvbiBnKCkge1xuICAgICAgdmFyIGIsXG4gICAgICAgICAgYSA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBtID0ge30sXG4gICAgICAgICAgZiA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBiICYmIChiID0ge30pO1xuICAgICAgICBZKGEsIGZ1bmN0aW9uIChtLCBjKSB7XG4gICAgICAgICAgIWgobSwgITApIHx8IHEobSkgfHwgTihtKSA/IGJbY10gPSBhW2NdIDogYltjXSA9IGYoYltjXSB8fCB7fSwgbSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH07XG5cbiAgICAgICEwID09PSBhWzBdICYmIChtID0gYVsxXSwgYSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEsIDIpKTtcbiAgICAgIHZhciBjID0gYS5sZW5ndGg7XG5cbiAgICAgIGZvciAoYiA9IDA7IGIgPCBjOyBiKyspIG0gPSBmKG0sIGFbYl0pO1xuXG4gICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXKGIsIGEsIG0pIHtcbiAgICAgIHZhciBmO1xuICAgICAgdChhKSA/IGMobSkgPyBiLnNldEF0dHJpYnV0ZShhLCBtKSA6IGIgJiYgYi5nZXRBdHRyaWJ1dGUgJiYgKChmID0gYi5nZXRBdHRyaWJ1dGUoYSkpIHx8IFwiY2xhc3NcIiAhPT0gYSB8fCAoZiA9IGIuZ2V0QXR0cmlidXRlKGEgKyBcIk5hbWVcIikpKSA6IFkoYSwgZnVuY3Rpb24gKGEsIG0pIHtcbiAgICAgICAgYi5zZXRBdHRyaWJ1dGUobSwgYSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHUoKSB7XG4gICAgICBmb3IgKHZhciBiID0gYXJndW1lbnRzLCBhID0gYi5sZW5ndGgsIG0gPSAwOyBtIDwgYTsgbSsrKSB7XG4gICAgICAgIHZhciBmID0gYlttXTtcbiAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBmICYmIG51bGwgIT09IGYpIHJldHVybiBmO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHIoYiwgYSkge1xuICAgICAgaWYgKCFiKSByZXR1cm4gYTtcbiAgICAgIHZhciBtID0gYi5zcGxpdChcIi5cIikucmV2ZXJzZSgpO1xuICAgICAgaWYgKDEgPT09IG0ubGVuZ3RoKSByZXR1cm4gYVtiXTtcblxuICAgICAgZm9yIChiID0gbS5wb3AoKTsgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGIgJiYgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGEgJiYgbnVsbCAhPT0gYTspIGEgPSBhW2JdLCBiID0gbS5wb3AoKTtcblxuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZC50aW1lcnMgPSBbXTtcblxuICAgIHZhciBNID0gZC5jaGFydHMsXG4gICAgICAgIEUgPSBkLmRvYyxcbiAgICAgICAgQSA9IGQud2luLFxuICAgICAgICBHID0gZC5lcnJvciA9IGZ1bmN0aW9uIChiLCBhLCBtLCBmKSB7XG4gICAgICB2YXIgYyA9IFAoYiksXG4gICAgICAgICAgcCA9IGMgPyBcIkhpZ2hjaGFydHMgZXJyb3IgI1wiICsgYiArIFwiOiB3d3cuaGlnaGNoYXJ0cy5jb20vZXJyb3JzL1wiICsgYiArIFwiL1wiIDogYi50b1N0cmluZygpLFxuICAgICAgICAgIGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChhKSB0aHJvdyBFcnJvcihwKTtcbiAgICAgICAgQS5jb25zb2xlICYmIGNvbnNvbGUubG9nKHApO1xuICAgICAgfTtcblxuICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBmKSB7XG4gICAgICAgIHZhciB4ID0gXCJcIjtcbiAgICAgICAgYyAmJiAocCArPSBcIj9cIik7XG4gICAgICAgIGQub2JqZWN0RWFjaChmLCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIHggKz0gXCJcXG5cIiArIGEgKyBcIjogXCIgKyBiO1xuICAgICAgICAgIGMgJiYgKHAgKz0gZW5jb2RlVVJJKGEpICsgXCI9XCIgKyBlbmNvZGVVUkkoYikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcCArPSB4O1xuICAgICAgfVxuXG4gICAgICBtID8gZC5maXJlRXZlbnQobSwgXCJkaXNwbGF5RXJyb3JcIiwge1xuICAgICAgICBjb2RlOiBiLFxuICAgICAgICBtZXNzYWdlOiBwLFxuICAgICAgICBwYXJhbXM6IGZcbiAgICAgIH0sIGUpIDogZSgpO1xuICAgIH0sXG4gICAgICAgIEogPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBiKGIsIGEsIG0pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gYTtcbiAgICAgICAgdGhpcy5lbGVtID0gYjtcbiAgICAgICAgdGhpcy5wcm9wID0gbTtcbiAgICAgIH1cblxuICAgICAgYi5wcm90b3R5cGUuZFNldHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLnBhdGhzWzBdLFxuICAgICAgICAgICAgYSA9IHRoaXMucGF0aHNbMV0sXG4gICAgICAgICAgICBtID0gW10sXG4gICAgICAgICAgICBmID0gdGhpcy5ub3csXG4gICAgICAgICAgICBjID0gYi5sZW5ndGg7XG4gICAgICAgIGlmICgxID09PSBmKSBtID0gdGhpcy50b0Q7ZWxzZSBpZiAoYyA9PT0gYS5sZW5ndGggJiYgMSA+IGYpIGZvciAoOyBjLS07KSB7XG4gICAgICAgICAgdmFyIHAgPSBwYXJzZUZsb2F0KGJbY10pO1xuICAgICAgICAgIG1bY10gPSBpc05hTihwKSB8fCBcIkFcIiA9PT0gYVtjIC0gNF0gfHwgXCJBXCIgPT09IGFbYyAtIDVdID8gYVtjXSA6IGYgKiBwYXJzZUZsb2F0KFwiXCIgKyAoYVtjXSAtIHApKSArIHA7XG4gICAgICAgIH0gZWxzZSBtID0gYTtcbiAgICAgICAgdGhpcy5lbGVtLmF0dHIoXCJkXCIsIG0sIG51bGwsICEwKTtcbiAgICAgIH07XG5cbiAgICAgIGIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmVsZW0sXG4gICAgICAgICAgICBhID0gdGhpcy5wcm9wLFxuICAgICAgICAgICAgbSA9IHRoaXMubm93LFxuICAgICAgICAgICAgZiA9IHRoaXMub3B0aW9ucy5zdGVwO1xuICAgICAgICBpZiAodGhpc1thICsgXCJTZXR0ZXJcIl0pIHRoaXNbYSArIFwiU2V0dGVyXCJdKCk7ZWxzZSBiLmF0dHIgPyBiLmVsZW1lbnQgJiYgYi5hdHRyKGEsIG0sIG51bGwsICEwKSA6IGIuc3R5bGVbYV0gPSBtICsgdGhpcy51bml0O1xuICAgICAgICBmICYmIGYuY2FsbChiLCBtLCB0aGlzKTtcbiAgICAgIH07XG5cbiAgICAgIGIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChiLCBhLCBtKSB7XG4gICAgICAgIHZhciBmID0gdGhpcyxcbiAgICAgICAgICAgIGMgPSBmLm9wdGlvbnMsXG4gICAgICAgICAgICBwID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICByZXR1cm4gcC5zdG9wcGVkID8gITEgOiBmLnN0ZXAoYik7XG4gICAgICAgIH0sXG4gICAgICAgICAgICBlID0gQS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGIsIDEzKTtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIHggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBkLnRpbWVycy5sZW5ndGg7IGIrKykgZC50aW1lcnNbYl0oKSB8fCBkLnRpbWVycy5zcGxpY2UoYi0tLCAxKTtcblxuICAgICAgICAgIGQudGltZXJzLmxlbmd0aCAmJiBlKHgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGIgIT09IGEgfHwgdGhpcy5lbGVtW1wiZm9yY2VBbmltYXRlOlwiICsgdGhpcy5wcm9wXSA/ICh0aGlzLnN0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpLCB0aGlzLnN0YXJ0ID0gYiwgdGhpcy5lbmQgPSBhLCB0aGlzLnVuaXQgPSBtLCB0aGlzLm5vdyA9IHRoaXMuc3RhcnQsIHRoaXMucG9zID0gMCwgcC5lbGVtID0gdGhpcy5lbGVtLCBwLnByb3AgPSB0aGlzLnByb3AsIHAoKSAmJiAxID09PSBkLnRpbWVycy5wdXNoKHApICYmIGUoeCkpIDogKGRlbGV0ZSBjLmN1ckFuaW1bdGhpcy5wcm9wXSwgYy5jb21wbGV0ZSAmJiAwID09PSBPYmplY3Qua2V5cyhjLmN1ckFuaW0pLmxlbmd0aCAmJiBjLmNvbXBsZXRlLmNhbGwodGhpcy5lbGVtKSk7XG4gICAgICB9O1xuXG4gICAgICBiLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSArbmV3IERhdGUoKSxcbiAgICAgICAgICAgIG0gPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBmID0gdGhpcy5lbGVtLFxuICAgICAgICAgICAgYyA9IG0uY29tcGxldGUsXG4gICAgICAgICAgICBwID0gbS5kdXJhdGlvbixcbiAgICAgICAgICAgIGUgPSBtLmN1ckFuaW07XG4gICAgICAgIGlmIChmLmF0dHIgJiYgIWYuZWxlbWVudCkgYiA9ICExO2Vsc2UgaWYgKGIgfHwgYSA+PSBwICsgdGhpcy5zdGFydFRpbWUpIHtcbiAgICAgICAgICB0aGlzLm5vdyA9IHRoaXMuZW5kO1xuICAgICAgICAgIHRoaXMucG9zID0gMTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgIHZhciB4ID0gZVt0aGlzLnByb3BdID0gITA7XG4gICAgICAgICAgWShlLCBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgITAgIT09IGIgJiYgKHggPSAhMSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgeCAmJiBjICYmIGMuY2FsbChmKTtcbiAgICAgICAgICBiID0gITE7XG4gICAgICAgIH0gZWxzZSB0aGlzLnBvcyA9IG0uZWFzaW5nKChhIC0gdGhpcy5zdGFydFRpbWUpIC8gcCksIHRoaXMubm93ID0gdGhpcy5zdGFydCArICh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpICogdGhpcy5wb3MsIHRoaXMudXBkYXRlKCksIGIgPSAhMDtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9O1xuXG4gICAgICBiLnByb3RvdHlwZS5pbml0UGF0aCA9IGZ1bmN0aW9uIChiLCBhLCBtKSB7XG4gICAgICAgIGZ1bmN0aW9uIGYoYikge1xuICAgICAgICAgIGZvciAoQyA9IGIubGVuZ3RoOyBDLS07KSB7XG4gICAgICAgICAgICB2YXIgYSA9IFwiTVwiID09PSBiW0NdIHx8IFwiTFwiID09PSBiW0NdO1xuICAgICAgICAgICAgdmFyIG0gPSAvW2EtekEtWl0vLnRlc3QoYltDICsgM10pO1xuICAgICAgICAgICAgYSAmJiBtICYmIGIuc3BsaWNlKEMgKyAxLCAwLCBiW0MgKyAxXSwgYltDICsgMl0sIGJbQyArIDFdLCBiW0MgKyAyXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYyhiLCBhKSB7XG4gICAgICAgICAgZm9yICg7IGIubGVuZ3RoIDwgdjspIHtcbiAgICAgICAgICAgIGJbMF0gPSBhW3YgLSBiLmxlbmd0aF07XG4gICAgICAgICAgICB2YXIgbSA9IGIuc2xpY2UoMCwgVCk7XG4gICAgICAgICAgICBbXS5zcGxpY2UuYXBwbHkoYiwgWzAsIDBdLmNvbmNhdChtKSk7XG4gICAgICAgICAgICBrICYmIChtID0gYi5zbGljZShiLmxlbmd0aCAtIFQpLCBbXS5zcGxpY2UuYXBwbHkoYiwgW2IubGVuZ3RoLCAwXS5jb25jYXQobSkpLCBDLS0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJbMF0gPSBcIk1cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHAoYiwgYSkge1xuICAgICAgICAgIGZvciAodmFyIG0gPSAodiAtIGIubGVuZ3RoKSAvIFQ7IDAgPCBtICYmIG0tLTspIGwgPSBiLnNsaWNlKCkuc3BsaWNlKGIubGVuZ3RoIC8gbiAtIFQsIFQgKiBuKSwgbFswXSA9IGFbdiAtIFQgLSBtICogVF0sIEYgJiYgKGxbVCAtIDZdID0gbFtUIC0gMl0sIGxbVCAtIDVdID0gbFtUIC0gMV0pLCBbXS5zcGxpY2UuYXBwbHkoYiwgW2IubGVuZ3RoIC8gbiwgMF0uY29uY2F0KGwpKSwgayAmJiBtLS07XG4gICAgICAgIH1cblxuICAgICAgICBhID0gYSB8fCBcIlwiO1xuICAgICAgICB2YXIgZSA9IGIuc3RhcnRYLFxuICAgICAgICAgICAgeCA9IGIuZW5kWCxcbiAgICAgICAgICAgIEYgPSAtMSA8IGEuaW5kZXhPZihcIkNcIiksXG4gICAgICAgICAgICBUID0gRiA/IDcgOiAzLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIEM7XG4gICAgICAgIGEgPSBhLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgbSA9IG0uc2xpY2UoKTtcbiAgICAgICAgdmFyIGsgPSBiLmlzQXJlYSxcbiAgICAgICAgICAgIG4gPSBrID8gMiA6IDE7XG4gICAgICAgIEYgJiYgKGYoYSksIGYobSkpO1xuXG4gICAgICAgIGlmIChlICYmIHgpIHtcbiAgICAgICAgICBmb3IgKEMgPSAwOyBDIDwgZS5sZW5ndGg7IEMrKykgaWYgKGVbQ10gPT09IHhbMF0pIHtcbiAgICAgICAgICAgIHZhciBWID0gQztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZVswXSA9PT0geFt4Lmxlbmd0aCAtIGUubGVuZ3RoICsgQ10pIHtcbiAgICAgICAgICAgIFYgPSBDO1xuICAgICAgICAgICAgdmFyIHcgPSAhMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZVtlLmxlbmd0aCAtIDFdID09PSB4W3gubGVuZ3RoIC0gZS5sZW5ndGggKyBDXSkge1xuICAgICAgICAgICAgViA9IGUubGVuZ3RoIC0gQztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBWICYmIChhID0gW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEubGVuZ3RoICYmIFAoVikpIHtcbiAgICAgICAgICB2YXIgdiA9IG0ubGVuZ3RoICsgViAqIG4gKiBUO1xuICAgICAgICAgIHcgPyAoYyhhLCBtKSwgcChtLCBhKSkgOiAoYyhtLCBhKSwgcChhLCBtKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2EsIG1dO1xuICAgICAgfTtcblxuICAgICAgYi5wcm90b3R5cGUuZmlsbFNldHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZC5GeC5wcm90b3R5cGUuc3Ryb2tlU2V0dGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgICBiLnByb3RvdHlwZS5zdHJva2VTZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZWxlbS5hdHRyKHRoaXMucHJvcCwgZC5jb2xvcih0aGlzLnN0YXJ0KS50d2VlblRvKGQuY29sb3IodGhpcy5lbmQpLCB0aGlzLnBvcyksIG51bGwsICEwKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBiO1xuICAgIH0oKTtcblxuICAgIGQuRnggPSBKO1xuICAgIGQubWVyZ2UgPSBnO1xuXG4gICAgdmFyIHkgPSBkLnBJbnQgPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KGIsIGEgfHwgMTApO1xuICAgIH0sXG4gICAgICAgIHQgPSBkLmlzU3RyaW5nID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiID09PSB0eXBlb2YgYjtcbiAgICB9LFxuICAgICAgICBEID0gZC5pc0FycmF5ID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIGIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYik7XG4gICAgICByZXR1cm4gXCJbb2JqZWN0IEFycmF5XVwiID09PSBiIHx8IFwiW29iamVjdCBBcnJheSBJdGVyYXRvcl1cIiA9PT0gYjtcbiAgICB9LFxuICAgICAgICBoID0gZC5pc09iamVjdCA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICByZXR1cm4gISFiICYmIFwib2JqZWN0XCIgPT09IHR5cGVvZiBiICYmICghYSB8fCAhRChiKSk7XG4gICAgfSxcbiAgICAgICAgTiA9IGQuaXNET01FbGVtZW50ID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIHJldHVybiBoKGIpICYmIFwibnVtYmVyXCIgPT09IHR5cGVvZiBiLm5vZGVUeXBlO1xuICAgIH0sXG4gICAgICAgIHEgPSBkLmlzQ2xhc3MgPSBmdW5jdGlvbiAoYikge1xuICAgICAgdmFyIGEgPSBiICYmIGIuY29uc3RydWN0b3I7XG4gICAgICByZXR1cm4gISghaChiLCAhMCkgfHwgTihiKSB8fCAhYSB8fCAhYS5uYW1lIHx8IFwiT2JqZWN0XCIgPT09IGEubmFtZSk7XG4gICAgfSxcbiAgICAgICAgUCA9IGQuaXNOdW1iZXIgPSBmdW5jdGlvbiAoYikge1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCIgPT09IHR5cGVvZiBiICYmICFpc05hTihiKSAmJiBJbmZpbml0eSA+IGIgJiYgLUluZmluaXR5IDwgYjtcbiAgICB9LFxuICAgICAgICBlID0gZC5lcmFzZSA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICBmb3IgKHZhciBtID0gYi5sZW5ndGg7IG0tLTspIGlmIChiW21dID09PSBhKSB7XG4gICAgICAgIGIuc3BsaWNlKG0sIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICBjID0gZC5kZWZpbmVkID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYiAmJiBudWxsICE9PSBiO1xuICAgIH07XG5cbiAgICBkLmF0dHIgPSBXO1xuXG4gICAgdmFyIGsgPSBkLnNwbGF0ID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIHJldHVybiBEKGIpID8gYiA6IFtiXTtcbiAgICB9LFxuICAgICAgICBuID0gZC5zeW5jVGltZW91dCA9IGZ1bmN0aW9uIChiLCBhLCBtKSB7XG4gICAgICBpZiAoMCA8IGEpIHJldHVybiBzZXRUaW1lb3V0KGIsIGEsIG0pO1xuICAgICAgYi5jYWxsKDAsIG0pO1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG4gICAgICAgIGYgPSBkLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICBjKGIpICYmIGNsZWFyVGltZW91dChiKTtcbiAgICB9LFxuICAgICAgICBhID0gZC5leHRlbmQgPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgdmFyIG07XG4gICAgICBiIHx8IChiID0ge30pO1xuXG4gICAgICBmb3IgKG0gaW4gYSkgYlttXSA9IGFbbV07XG5cbiAgICAgIHJldHVybiBiO1xuICAgIH07XG5cbiAgICBkLnBpY2sgPSB1O1xuXG4gICAgdmFyIGwgPSBkLmNzcyA9IGZ1bmN0aW9uIChiLCBtKSB7XG4gICAgICBkLmlzTVMgJiYgIWQuc3ZnICYmIG0gJiYgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIG0ub3BhY2l0eSAmJiAobS5maWx0ZXIgPSBcImFscGhhKG9wYWNpdHk9XCIgKyAxMDAgKiBtLm9wYWNpdHkgKyBcIilcIik7XG4gICAgICBhKGIuc3R5bGUsIG0pO1xuICAgIH0sXG4gICAgICAgIHYgPSBkLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYiwgbSwgZiwgYywgcCkge1xuICAgICAgYiA9IEUuY3JlYXRlRWxlbWVudChiKTtcbiAgICAgIG0gJiYgYShiLCBtKTtcbiAgICAgIHAgJiYgbChiLCB7XG4gICAgICAgIHBhZGRpbmc6IFwiMFwiLFxuICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICBtYXJnaW46IFwiMFwiXG4gICAgICB9KTtcbiAgICAgIGYgJiYgbChiLCBmKTtcbiAgICAgIGMgJiYgYy5hcHBlbmRDaGlsZChiKTtcbiAgICAgIHJldHVybiBiO1xuICAgIH0sXG4gICAgICAgIHogPSBkLmV4dGVuZENsYXNzID0gZnVuY3Rpb24gKGIsIG0pIHtcbiAgICAgIHZhciBmID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgIGYucHJvdG90eXBlID0gbmV3IGIoKTtcbiAgICAgIGEoZi5wcm90b3R5cGUsIG0pO1xuICAgICAgcmV0dXJuIGY7XG4gICAgfSxcbiAgICAgICAgdyA9IGQucGFkID0gZnVuY3Rpb24gKGIsIGEsIG0pIHtcbiAgICAgIHJldHVybiBBcnJheSgoYSB8fCAyKSArIDEgLSBTdHJpbmcoYikucmVwbGFjZShcIi1cIiwgXCJcIikubGVuZ3RoKS5qb2luKG0gfHwgXCIwXCIpICsgYjtcbiAgICB9LFxuICAgICAgICBCID0gZC5yZWxhdGl2ZUxlbmd0aCA9IGZ1bmN0aW9uIChiLCBhLCBtKSB7XG4gICAgICByZXR1cm4gLyUkLy50ZXN0KGIpID8gYSAqIHBhcnNlRmxvYXQoYikgLyAxMDAgKyAobSB8fCAwKSA6IHBhcnNlRmxvYXQoYik7XG4gICAgfSxcbiAgICAgICAgTCA9IGQud3JhcCA9IGZ1bmN0aW9uIChiLCBhLCBtKSB7XG4gICAgICB2YXIgZiA9IGJbYV07XG5cbiAgICAgIGJbYV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGEgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBjID0gdGhpcztcblxuICAgICAgICBjLnByb2NlZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZi5hcHBseShjLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzIDogYSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYi51bnNoaWZ0KGYpO1xuICAgICAgICBiID0gbS5hcHBseSh0aGlzLCBiKTtcbiAgICAgICAgYy5wcm9jZWVkID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9O1xuICAgIH0sXG4gICAgICAgIFEgPSBkLmZvcm1hdCA9IGZ1bmN0aW9uIChiLCBhLCBtKSB7XG4gICAgICB2YXIgZiA9IFwie1wiLFxuICAgICAgICAgIGMgPSAhMSxcbiAgICAgICAgICBwID0gW10sXG4gICAgICAgICAgZSA9IC9mJC8sXG4gICAgICAgICAgeCA9IC9cXC4oWzAtOV0pLyxcbiAgICAgICAgICBGID0gZC5kZWZhdWx0T3B0aW9ucy5sYW5nLFxuICAgICAgICAgIEMgPSBtICYmIG0udGltZSB8fCBkLnRpbWU7XG5cbiAgICAgIGZvciAobSA9IG0gJiYgbS5udW1iZXJGb3JtYXR0ZXIgfHwgVDsgYjspIHtcbiAgICAgICAgdmFyIGwgPSBiLmluZGV4T2YoZik7XG4gICAgICAgIGlmICgtMSA9PT0gbCkgYnJlYWs7XG4gICAgICAgIHZhciBrID0gYi5zbGljZSgwLCBsKTtcblxuICAgICAgICBpZiAoYykge1xuICAgICAgICAgIGsgPSBrLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICBmID0gcihrLnNoaWZ0KCkgfHwgXCJcIiwgYSk7XG4gICAgICAgICAgaWYgKGsubGVuZ3RoICYmIFwibnVtYmVyXCIgPT09IHR5cGVvZiBmKSBpZiAoayA9IGsuam9pbihcIjpcIiksIGUudGVzdChrKSkge1xuICAgICAgICAgICAgdmFyIG4gPSBwYXJzZUludCgoay5tYXRjaCh4KSB8fCBbXCJcIiwgXCItMVwiXSlbMV0sIDEwKTtcbiAgICAgICAgICAgIG51bGwgIT09IGYgJiYgKGYgPSBtKGYsIG4sIEYuZGVjaW1hbFBvaW50LCAtMSA8IGsuaW5kZXhPZihcIixcIikgPyBGLnRob3VzYW5kc1NlcCA6IFwiXCIpKTtcbiAgICAgICAgICB9IGVsc2UgZiA9IEMuZGF0ZUZvcm1hdChrLCBmKTtcbiAgICAgICAgICBwLnB1c2goZik7XG4gICAgICAgIH0gZWxzZSBwLnB1c2goayk7XG5cbiAgICAgICAgYiA9IGIuc2xpY2UobCArIDEpO1xuICAgICAgICBmID0gKGMgPSAhYykgPyBcIn1cIiA6IFwie1wiO1xuICAgICAgfVxuXG4gICAgICBwLnB1c2goYik7XG4gICAgICByZXR1cm4gcC5qb2luKFwiXCIpO1xuICAgIH0sXG4gICAgICAgIEggPSBkLmdldE1hZ25pdHVkZSA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coYikgLyBNYXRoLkxOMTApKTtcbiAgICB9LFxuICAgICAgICBLID0gZC5ub3JtYWxpemVUaWNrSW50ZXJ2YWwgPSBmdW5jdGlvbiAoYiwgYSwgbSwgZiwgYykge1xuICAgICAgdmFyIHAgPSBiO1xuICAgICAgbSA9IHUobSwgMSk7XG4gICAgICB2YXIgZSA9IGIgLyBtO1xuICAgICAgYSB8fCAoYSA9IGMgPyBbMSwgMS4yLCAxLjUsIDIsIDIuNSwgMywgNCwgNSwgNiwgOCwgMTBdIDogWzEsIDIsIDIuNSwgNSwgMTBdLCAhMSA9PT0gZiAmJiAoMSA9PT0gbSA/IGEgPSBhLmZpbHRlcihmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gMCA9PT0gYiAlIDE7XG4gICAgICB9KSA6IC4xID49IG0gJiYgKGEgPSBbMSAvIG1dKSkpO1xuXG4gICAgICBmb3IgKGYgPSAwOyBmIDwgYS5sZW5ndGggJiYgIShwID0gYVtmXSwgYyAmJiBwICogbSA+PSBiIHx8ICFjICYmIGUgPD0gKGFbZl0gKyAoYVtmICsgMV0gfHwgYVtmXSkpIC8gMik7IGYrKyk7XG5cbiAgICAgIHJldHVybiBwID0gTyhwICogbSwgLU1hdGgucm91bmQoTWF0aC5sb2coLjAwMSkgLyBNYXRoLkxOMTApKTtcbiAgICB9LFxuICAgICAgICBwID0gZC5zdGFibGVTb3J0ID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgIHZhciBtID0gYi5sZW5ndGgsXG4gICAgICAgICAgZixcbiAgICAgICAgICBjO1xuXG4gICAgICBmb3IgKGMgPSAwOyBjIDwgbTsgYysrKSBiW2NdLnNhZmVJID0gYztcblxuICAgICAgYi5zb3J0KGZ1bmN0aW9uIChiLCBtKSB7XG4gICAgICAgIGYgPSBhKGIsIG0pO1xuICAgICAgICByZXR1cm4gMCA9PT0gZiA/IGIuc2FmZUkgLSBtLnNhZmVJIDogZjtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKGMgPSAwOyBjIDwgbTsgYysrKSBkZWxldGUgYltjXS5zYWZlSTtcbiAgICB9LFxuICAgICAgICBiID0gZC5hcnJheU1pbiA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICBmb3IgKHZhciBhID0gYi5sZW5ndGgsIG0gPSBiWzBdOyBhLS07KSBiW2FdIDwgbSAmJiAobSA9IGJbYV0pO1xuXG4gICAgICByZXR1cm4gbTtcbiAgICB9LFxuICAgICAgICBDID0gZC5hcnJheU1heCA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICBmb3IgKHZhciBhID0gYi5sZW5ndGgsIG0gPSBiWzBdOyBhLS07KSBiW2FdID4gbSAmJiAobSA9IGJbYV0pO1xuXG4gICAgICByZXR1cm4gbTtcbiAgICB9LFxuICAgICAgICB4ID0gZC5kZXN0cm95T2JqZWN0UHJvcGVydGllcyA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICBZKGIsIGZ1bmN0aW9uIChtLCBmKSB7XG4gICAgICAgIG0gJiYgbSAhPT0gYSAmJiBtLmRlc3Ryb3kgJiYgbS5kZXN0cm95KCk7XG4gICAgICAgIGRlbGV0ZSBiW2ZdO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAgICAgUiA9IGQuZGlzY2FyZEVsZW1lbnQgPSBmdW5jdGlvbiAoYikge1xuICAgICAgdmFyIGEgPSBkLmdhcmJhZ2VCaW47XG4gICAgICBhIHx8IChhID0gdihcImRpdlwiKSk7XG4gICAgICBiICYmIGEuYXBwZW5kQ2hpbGQoYik7XG4gICAgICBhLmlubmVySFRNTCA9IFwiXCI7XG4gICAgfSxcbiAgICAgICAgTyA9IGQuY29ycmVjdEZsb2F0ID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KGIudG9QcmVjaXNpb24oYSB8fCAxNCkpO1xuICAgIH0sXG4gICAgICAgIFggPSBkLnNldEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICBhLnJlbmRlcmVyLmdsb2JhbEFuaW1hdGlvbiA9IHUoYiwgYS5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbiwgITApO1xuICAgIH0sXG4gICAgICAgIFUgPSBkLmFuaW1PYmplY3QgPSBmdW5jdGlvbiAoYikge1xuICAgICAgcmV0dXJuIGgoYikgPyBnKGIpIDoge1xuICAgICAgICBkdXJhdGlvbjogYiA/IDUwMCA6IDBcbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgbSA9IGQudGltZVVuaXRzID0ge1xuICAgICAgbWlsbGlzZWNvbmQ6IDEsXG4gICAgICBzZWNvbmQ6IDFFMyxcbiAgICAgIG1pbnV0ZTogNkU0LFxuICAgICAgaG91cjogMzZFNSxcbiAgICAgIGRheTogODY0RTUsXG4gICAgICB3ZWVrOiA2MDQ4RTUsXG4gICAgICBtb250aDogMjQxOTJFNSxcbiAgICAgIHllYXI6IDMxNDQ5NkU1XG4gICAgfSxcbiAgICAgICAgVCA9IGQubnVtYmVyRm9ybWF0ID0gZnVuY3Rpb24gKGIsIGEsIG0sIGYpIHtcbiAgICAgIGIgPSArYiB8fCAwO1xuICAgICAgYSA9ICthO1xuICAgICAgdmFyIGMgPSBkLmRlZmF1bHRPcHRpb25zLmxhbmcsXG4gICAgICAgICAgcCA9IChiLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLnNwbGl0KFwiZVwiKVswXS5sZW5ndGgsXG4gICAgICAgICAgZSA9IGIudG9TdHJpbmcoKS5zcGxpdChcImVcIik7XG4gICAgICBpZiAoLTEgPT09IGEpIGEgPSBNYXRoLm1pbihwLCAyMCk7ZWxzZSBpZiAoIVAoYSkpIGEgPSAyO2Vsc2UgaWYgKGEgJiYgZVsxXSAmJiAwID4gZVsxXSkge1xuICAgICAgICB2YXIgeCA9IGEgKyArZVsxXTtcbiAgICAgICAgMCA8PSB4ID8gKGVbMF0gPSAoK2VbMF0pLnRvRXhwb25lbnRpYWwoeCkuc3BsaXQoXCJlXCIpWzBdLCBhID0geCkgOiAoZVswXSA9IGVbMF0uc3BsaXQoXCIuXCIpWzBdIHx8IDAsIGIgPSAyMCA+IGEgPyAoZVswXSAqIE1hdGgucG93KDEwLCBlWzFdKSkudG9GaXhlZChhKSA6IDAsIGVbMV0gPSAwKTtcbiAgICAgIH1cbiAgICAgIHZhciBGID0gKE1hdGguYWJzKGVbMV0gPyBlWzBdIDogYikgKyBNYXRoLnBvdygxMCwgLU1hdGgubWF4KGEsIHApIC0gMSkpLnRvRml4ZWQoYSk7XG4gICAgICBwID0gU3RyaW5nKHkoRikpO1xuICAgICAgeCA9IDMgPCBwLmxlbmd0aCA/IHAubGVuZ3RoICUgMyA6IDA7XG4gICAgICBtID0gdShtLCBjLmRlY2ltYWxQb2ludCk7XG4gICAgICBmID0gdShmLCBjLnRob3VzYW5kc1NlcCk7XG4gICAgICBiID0gKDAgPiBiID8gXCItXCIgOiBcIlwiKSArICh4ID8gcC5zdWJzdHIoMCwgeCkgKyBmIDogXCJcIik7XG4gICAgICBiICs9IHAuc3Vic3RyKHgpLnJlcGxhY2UoLyhcXGR7M30pKD89XFxkKS9nLCBcIiQxXCIgKyBmKTtcbiAgICAgIGEgJiYgKGIgKz0gbSArIEYuc2xpY2UoLWEpKTtcbiAgICAgIGVbMV0gJiYgMCAhPT0gK2IgJiYgKGIgKz0gXCJlXCIgKyBlWzFdKTtcbiAgICAgIHJldHVybiBiO1xuICAgIH07XG5cbiAgICBNYXRoLmVhc2VJbk91dFNpbmUgPSBmdW5jdGlvbiAoYikge1xuICAgICAgcmV0dXJuIC0uNSAqIChNYXRoLmNvcyhNYXRoLlBJICogYikgLSAxKTtcbiAgICB9O1xuXG4gICAgdmFyIFogPSBkLmdldFN0eWxlID0gZnVuY3Rpb24gKGIsIGEsIG0pIHtcbiAgICAgIGlmIChcIndpZHRoXCIgPT09IGEpIHJldHVybiBhID0gTWF0aC5taW4oYi5vZmZzZXRXaWR0aCwgYi5zY3JvbGxXaWR0aCksIG0gPSBiLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiBiLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoLCBtIDwgYSAmJiBtID49IGEgLSAxICYmIChhID0gTWF0aC5mbG9vcihtKSksIE1hdGgubWF4KDAsIGEgLSBkLmdldFN0eWxlKGIsIFwicGFkZGluZy1sZWZ0XCIpIC0gZC5nZXRTdHlsZShiLCBcInBhZGRpbmctcmlnaHRcIikpO1xuICAgICAgaWYgKFwiaGVpZ2h0XCIgPT09IGEpIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihiLm9mZnNldEhlaWdodCwgYi5zY3JvbGxIZWlnaHQpIC0gZC5nZXRTdHlsZShiLCBcInBhZGRpbmctdG9wXCIpIC0gZC5nZXRTdHlsZShiLCBcInBhZGRpbmctYm90dG9tXCIpKTtcbiAgICAgIEEuZ2V0Q29tcHV0ZWRTdHlsZSB8fCBHKDI3LCAhMCk7XG4gICAgICBpZiAoYiA9IEEuZ2V0Q29tcHV0ZWRTdHlsZShiLCB2b2lkIDApKSBiID0gYi5nZXRQcm9wZXJ0eVZhbHVlKGEpLCB1KG0sIFwib3BhY2l0eVwiICE9PSBhKSAmJiAoYiA9IHkoYikpO1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSxcbiAgICAgICAgY2EgPSBkLmluQXJyYXkgPSBmdW5jdGlvbiAoYiwgYSwgbSkge1xuICAgICAgcmV0dXJuIGEuaW5kZXhPZihiLCBtKTtcbiAgICB9LFxuICAgICAgICBGID0gZC5maW5kID0gQXJyYXkucHJvdG90eXBlLmZpbmQgPyBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgcmV0dXJuIGIuZmluZChhKTtcbiAgICB9IDogZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgIHZhciBtLFxuICAgICAgICAgIGYgPSBiLmxlbmd0aDtcblxuICAgICAgZm9yIChtID0gMDsgbSA8IGY7IG0rKykgaWYgKGEoYlttXSwgbSkpIHJldHVybiBiW21dO1xuICAgIH07XG5cbiAgICBkLmtleXMgPSBPYmplY3Qua2V5cztcblxuICAgIHZhciBWID0gZC5vZmZzZXQgPSBmdW5jdGlvbiAoYikge1xuICAgICAgdmFyIGEgPSBFLmRvY3VtZW50RWxlbWVudDtcbiAgICAgIGIgPSBiLnBhcmVudEVsZW1lbnQgfHwgYi5wYXJlbnROb2RlID8gYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHtcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBiLnRvcCArIChBLnBhZ2VZT2Zmc2V0IHx8IGEuc2Nyb2xsVG9wKSAtIChhLmNsaWVudFRvcCB8fCAwKSxcbiAgICAgICAgbGVmdDogYi5sZWZ0ICsgKEEucGFnZVhPZmZzZXQgfHwgYS5zY3JvbGxMZWZ0KSAtIChhLmNsaWVudExlZnQgfHwgMClcbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgYmEgPSBkLnN0b3AgPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgZm9yICh2YXIgbSA9IGQudGltZXJzLmxlbmd0aDsgbS0tOykgZC50aW1lcnNbbV0uZWxlbSAhPT0gYiB8fCBhICYmIGEgIT09IGQudGltZXJzW21dLnByb3AgfHwgKGQudGltZXJzW21dLnN0b3BwZWQgPSAhMCk7XG4gICAgfSxcbiAgICAgICAgWSA9IGQub2JqZWN0RWFjaCA9IGZ1bmN0aW9uIChiLCBhLCBtKSB7XG4gICAgICBmb3IgKHZhciBmIGluIGIpIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGYpICYmIGEuY2FsbChtIHx8IGJbZl0sIGJbZl0sIGYsIGIpO1xuICAgIH07XG5cbiAgICBZKHtcbiAgICAgIG1hcDogXCJtYXBcIixcbiAgICAgIGVhY2g6IFwiZm9yRWFjaFwiLFxuICAgICAgZ3JlcDogXCJmaWx0ZXJcIixcbiAgICAgIHJlZHVjZTogXCJyZWR1Y2VcIixcbiAgICAgIHNvbWU6IFwic29tZVwiXG4gICAgfSwgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgIGRbYV0gPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlW2JdLmFwcGx5KGEsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgdmFyIGZhID0gZC5hZGRFdmVudCA9IGZ1bmN0aW9uIChiLCBhLCBtLCBmKSB7XG4gICAgICB2b2lkIDAgPT09IGYgJiYgKGYgPSB7fSk7XG4gICAgICB2YXIgYyA9IGIuYWRkRXZlbnRMaXN0ZW5lciB8fCBkLmFkZEV2ZW50TGlzdGVuZXJQb2x5ZmlsbDtcbiAgICAgIHZhciBwID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYiAmJiBiLnByb3RvdHlwZSA/IGIucHJvdG90eXBlLnByb3RvRXZlbnRzID0gYi5wcm90b3R5cGUucHJvdG9FdmVudHMgfHwge30gOiBiLmhjRXZlbnRzID0gYi5oY0V2ZW50cyB8fCB7fTtcbiAgICAgIGQuUG9pbnQgJiYgYiBpbnN0YW5jZW9mIGQuUG9pbnQgJiYgYi5zZXJpZXMgJiYgYi5zZXJpZXMuY2hhcnQgJiYgKGIuc2VyaWVzLmNoYXJ0LnJ1blRyYWNrZXJDbGljayA9ICEwKTtcbiAgICAgIGMgJiYgYy5jYWxsKGIsIGEsIG0sICExKTtcbiAgICAgIHBbYV0gfHwgKHBbYV0gPSBbXSk7XG4gICAgICBwW2FdLnB1c2goe1xuICAgICAgICBmbjogbSxcbiAgICAgICAgb3JkZXI6IFwibnVtYmVyXCIgPT09IHR5cGVvZiBmLm9yZGVyID8gZi5vcmRlciA6IEluZmluaXR5XG4gICAgICB9KTtcbiAgICAgIHBbYV0uc29ydChmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICByZXR1cm4gYi5vcmRlciAtIGEub3JkZXI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRhKGIsIGEsIG0pO1xuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBkYSA9IGQucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAoYiwgYSwgbSkge1xuICAgICAgZnVuY3Rpb24gZihhLCBtKSB7XG4gICAgICAgIHZhciBmID0gYi5yZW1vdmVFdmVudExpc3RlbmVyIHx8IGQucmVtb3ZlRXZlbnRMaXN0ZW5lclBvbHlmaWxsO1xuICAgICAgICBmICYmIGYuY2FsbChiLCBhLCBtLCAhMSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGMobSkge1xuICAgICAgICB2YXIgYztcblxuICAgICAgICBpZiAoYi5ub2RlTmFtZSkge1xuICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHt9O1xuICAgICAgICAgICAgcFthXSA9ICEwO1xuICAgICAgICAgIH0gZWxzZSBwID0gbTtcblxuICAgICAgICAgIFkocCwgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICAgIGlmIChtW2FdKSBmb3IgKGMgPSBtW2FdLmxlbmd0aDsgYy0tOykgZihhLCBtW2FdW2NdLmZuKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcDtcbiAgICAgIFtcInByb3RvRXZlbnRzXCIsIFwiaGNFdmVudHNcIl0uZm9yRWFjaChmdW5jdGlvbiAoZSwgeCkge1xuICAgICAgICB2YXIgRiA9ICh4ID0geCA/IGIgOiBiLnByb3RvdHlwZSkgJiYgeFtlXTtcbiAgICAgICAgRiAmJiAoYSA/IChwID0gRlthXSB8fCBbXSwgbSA/IChGW2FdID0gcC5maWx0ZXIoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICByZXR1cm4gbSAhPT0gYi5mbjtcbiAgICAgICAgfSksIGYoYSwgbSkpIDogKGMoRiksIEZbYV0gPSBbXSkpIDogKGMoRiksIHhbZV0gPSB7fSkpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAgICAgaGEgPSBkLmZpcmVFdmVudCA9IGZ1bmN0aW9uIChiLCBtLCBmLCBjKSB7XG4gICAgICB2YXIgcDtcbiAgICAgIGYgPSBmIHx8IHt9O1xuXG4gICAgICBpZiAoRS5jcmVhdGVFdmVudCAmJiAoYi5kaXNwYXRjaEV2ZW50IHx8IGIuZmlyZUV2ZW50KSkge1xuICAgICAgICB2YXIgZSA9IEUuY3JlYXRlRXZlbnQoXCJFdmVudHNcIik7XG4gICAgICAgIGUuaW5pdEV2ZW50KG0sICEwLCAhMCk7XG4gICAgICAgIGEoZSwgZik7XG4gICAgICAgIGIuZGlzcGF0Y2hFdmVudCA/IGIuZGlzcGF0Y2hFdmVudChlKSA6IGIuZmlyZUV2ZW50KG0sIGUpO1xuICAgICAgfSBlbHNlIGYudGFyZ2V0IHx8IGEoZiwge1xuICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGYuZGVmYXVsdFByZXZlbnRlZCA9ICEwO1xuICAgICAgICB9LFxuICAgICAgICB0YXJnZXQ6IGIsXG4gICAgICAgIHR5cGU6IG1cbiAgICAgIH0pLCBmdW5jdGlvbiAoYSwgbSkge1xuICAgICAgICB2b2lkIDAgPT09IGEgJiYgKGEgPSBbXSk7XG4gICAgICAgIHZvaWQgMCA9PT0gbSAmJiAobSA9IFtdKTtcbiAgICAgICAgdmFyIGMgPSAwLFxuICAgICAgICAgICAgZSA9IDAsXG4gICAgICAgICAgICB4ID0gYS5sZW5ndGggKyBtLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHAgPSAwOyBwIDwgeDsgcCsrKSAhMSA9PT0gKGFbY10gPyBtW2VdID8gYVtjXS5vcmRlciA8PSBtW2VdLm9yZGVyID8gYVtjKytdIDogbVtlKytdIDogYVtjKytdIDogbVtlKytdKS5mbi5jYWxsKGIsIGYpICYmIGYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0oYi5wcm90b0V2ZW50cyAmJiBiLnByb3RvRXZlbnRzW21dLCBiLmhjRXZlbnRzICYmIGIuaGNFdmVudHNbbV0pO1xuXG4gICAgICBjICYmICFmLmRlZmF1bHRQcmV2ZW50ZWQgJiYgYy5jYWxsKGIsIGYpO1xuICAgIH0sXG4gICAgICAgIGlhID0gZC5hbmltYXRlID0gZnVuY3Rpb24gKGIsIGEsIG0pIHtcbiAgICAgIHZhciBmLFxuICAgICAgICAgIGMgPSBcIlwiLFxuICAgICAgICAgIHAsXG4gICAgICAgICAgZTtcblxuICAgICAgaWYgKCFoKG0pKSB7XG4gICAgICAgIHZhciB4ID0gYXJndW1lbnRzO1xuICAgICAgICBtID0ge1xuICAgICAgICAgIGR1cmF0aW9uOiB4WzJdLFxuICAgICAgICAgIGVhc2luZzogeFszXSxcbiAgICAgICAgICBjb21wbGV0ZTogeFs0XVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBQKG0uZHVyYXRpb24pIHx8IChtLmR1cmF0aW9uID0gNDAwKTtcbiAgICAgIG0uZWFzaW5nID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbS5lYXNpbmcgPyBtLmVhc2luZyA6IE1hdGhbbS5lYXNpbmddIHx8IE1hdGguZWFzZUluT3V0U2luZTtcbiAgICAgIG0uY3VyQW5pbSA9IGcoYSk7XG4gICAgICBZKGEsIGZ1bmN0aW9uICh4LCBGKSB7XG4gICAgICAgIGJhKGIsIEYpO1xuICAgICAgICBlID0gbmV3IEooYiwgbSwgRik7XG4gICAgICAgIHAgPSBudWxsO1xuICAgICAgICBcImRcIiA9PT0gRiA/IChlLnBhdGhzID0gZS5pbml0UGF0aChiLCBiLmQsIGEuZCksIGUudG9EID0gYS5kLCBmID0gMCwgcCA9IDEpIDogYi5hdHRyID8gZiA9IGIuYXR0cihGKSA6IChmID0gcGFyc2VGbG9hdChaKGIsIEYpKSB8fCAwLCBcIm9wYWNpdHlcIiAhPT0gRiAmJiAoYyA9IFwicHhcIikpO1xuICAgICAgICBwIHx8IChwID0geCk7XG4gICAgICAgIHAgJiYgcC5tYXRjaCAmJiBwLm1hdGNoKFwicHhcIikgJiYgKHAgPSBwLnJlcGxhY2UoL3B4L2csIFwiXCIpKTtcbiAgICAgICAgZS5ydW4oZiwgcCwgYyk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgICAgICBqYSA9IGQuc2VyaWVzVHlwZSA9IGZ1bmN0aW9uIChiLCBhLCBtLCBmLCBjKSB7XG4gICAgICB2YXIgcCA9IGQuZ2V0T3B0aW9ucygpLFxuICAgICAgICAgIGUgPSBkLnNlcmllc1R5cGVzO1xuICAgICAgcC5wbG90T3B0aW9uc1tiXSA9IGcocC5wbG90T3B0aW9uc1thXSwgbSk7XG4gICAgICBlW2JdID0geihlW2FdIHx8IGZ1bmN0aW9uICgpIHt9LCBmKTtcbiAgICAgIGVbYl0ucHJvdG90eXBlLnR5cGUgPSBiO1xuICAgICAgYyAmJiAoZVtiXS5wcm90b3R5cGUucG9pbnRDbGFzcyA9IHooZC5Qb2ludCwgYykpO1xuICAgICAgcmV0dXJuIGVbYl07XG4gICAgfSxcbiAgICAgICAgZWEgPSBkLnVuaXF1ZUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBiID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDkpLFxuICAgICAgICAgIGEgPSAwO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiaGlnaGNoYXJ0cy1cIiArIGIgKyBcIi1cIiArIGErKztcbiAgICAgIH07XG4gICAgfSgpLFxuICAgICAgICBrYSA9IGQuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYjtcbiAgICB9O1xuXG4gICAgQS5qUXVlcnkgJiYgKEEualF1ZXJ5LmZuLmhpZ2hjaGFydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYiA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzWzBdKSByZXR1cm4gYlswXSA/IChuZXcgZFt0KGJbMF0pID8gYi5zaGlmdCgpIDogXCJDaGFydFwiXSh0aGlzWzBdLCBiWzBdLCBiWzFdKSwgdGhpcykgOiBNW1codGhpc1swXSwgXCJkYXRhLWhpZ2hjaGFydHMtY2hhcnRcIildO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBGeDogSixcbiAgICAgIGFkZEV2ZW50OiBmYSxcbiAgICAgIGFuaW1hdGU6IGlhLFxuICAgICAgYW5pbU9iamVjdDogVSxcbiAgICAgIGFycmF5TWF4OiBDLFxuICAgICAgYXJyYXlNaW46IGIsXG4gICAgICBhdHRyOiBXLFxuICAgICAgY2xhbXA6IGZ1bmN0aW9uIChiLCBhLCBtKSB7XG4gICAgICAgIHJldHVybiBiID4gYSA/IGIgPCBtID8gYiA6IG0gOiBhO1xuICAgICAgfSxcbiAgICAgIGNsZWFyVGltZW91dDogZixcbiAgICAgIGNvcnJlY3RGbG9hdDogTyxcbiAgICAgIGNyZWF0ZUVsZW1lbnQ6IHYsXG4gICAgICBjc3M6IGwsXG4gICAgICBkZWZpbmVkOiBjLFxuICAgICAgZGVzdHJveU9iamVjdFByb3BlcnRpZXM6IHgsXG4gICAgICBkaXNjYXJkRWxlbWVudDogUixcbiAgICAgIGVyYXNlOiBlLFxuICAgICAgZXJyb3I6IEcsXG4gICAgICBleHRlbmQ6IGEsXG4gICAgICBleHRlbmRDbGFzczogeixcbiAgICAgIGZpbmQ6IEYsXG4gICAgICBmaXJlRXZlbnQ6IGhhLFxuICAgICAgZm9ybWF0OiBRLFxuICAgICAgZ2V0TWFnbml0dWRlOiBILFxuICAgICAgZ2V0TmVzdGVkUHJvcGVydHk6IHIsXG4gICAgICBnZXRTdHlsZTogWixcbiAgICAgIGluQXJyYXk6IGNhLFxuICAgICAgaXNBcnJheTogRCxcbiAgICAgIGlzQ2xhc3M6IHEsXG4gICAgICBpc0RPTUVsZW1lbnQ6IE4sXG4gICAgICBpc0Z1bmN0aW9uOiBrYSxcbiAgICAgIGlzTnVtYmVyOiBQLFxuICAgICAgaXNPYmplY3Q6IGgsXG4gICAgICBpc1N0cmluZzogdCxcbiAgICAgIG1lcmdlOiBnLFxuICAgICAgbm9ybWFsaXplVGlja0ludGVydmFsOiBLLFxuICAgICAgbnVtYmVyRm9ybWF0OiBULFxuICAgICAgb2JqZWN0RWFjaDogWSxcbiAgICAgIG9mZnNldDogVixcbiAgICAgIHBhZDogdyxcbiAgICAgIHBpY2s6IHUsXG4gICAgICBwSW50OiB5LFxuICAgICAgcmVsYXRpdmVMZW5ndGg6IEIsXG4gICAgICByZW1vdmVFdmVudDogZGEsXG4gICAgICBzZXJpZXNUeXBlOiBqYSxcbiAgICAgIHNldEFuaW1hdGlvbjogWCxcbiAgICAgIHNwbGF0OiBrLFxuICAgICAgc3RhYmxlU29ydDogcCxcbiAgICAgIHN0b3A6IGJhLFxuICAgICAgc3luY1RpbWVvdXQ6IG4sXG4gICAgICB0aW1lVW5pdHM6IG0sXG4gICAgICB1bmlxdWVLZXk6IGVhLFxuICAgICAgd3JhcDogTFxuICAgIH07XG4gIH0pO1xuICBTKHIsIFwicGFydHMvQ29sb3IuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcpIHtcbiAgICB2YXIgVyA9IGcuaXNOdW1iZXIsXG4gICAgICAgIHUgPSBnLm1lcmdlLFxuICAgICAgICByID0gZy5wSW50O1xuXG4gICAgZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIGQoZykge1xuICAgICAgICB0aGlzLnBhcnNlcnMgPSBbe1xuICAgICAgICAgIHJlZ2V4OiAvcmdiYVxcKFxccyooWzAtOV17MSwzfSlcXHMqLFxccyooWzAtOV17MSwzfSlcXHMqLFxccyooWzAtOV17MSwzfSlcXHMqLFxccyooWzAtOV0/KD86XFwuWzAtOV0rKT8pXFxzKlxcKS8sXG4gICAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gW3IoZFsxXSksIHIoZFsyXSksIHIoZFszXSksIHBhcnNlRmxvYXQoZFs0XSwgMTApXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICByZWdleDogL3JnYlxcKFxccyooWzAtOV17MSwzfSlcXHMqLFxccyooWzAtOV17MSwzfSlcXHMqLFxccyooWzAtOV17MSwzfSlcXHMqXFwpLyxcbiAgICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBbcihkWzFdKSwgcihkWzJdKSwgcihkWzNdKSwgMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XTtcbiAgICAgICAgdGhpcy5yZ2JhID0gW107XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBkKSkgcmV0dXJuIG5ldyBkKGcpO1xuICAgICAgICB0aGlzLmluaXQoZyk7XG4gICAgICB9XG5cbiAgICAgIGQucGFyc2UgPSBmdW5jdGlvbiAoZykge1xuICAgICAgICByZXR1cm4gbmV3IGQoZyk7XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgdmFyIEEsIEc7XG4gICAgICAgIGlmICgodGhpcy5pbnB1dCA9IGcgPSBkLm5hbWVzW2cgJiYgZy50b0xvd2VyQ2FzZSA/IGcudG9Mb3dlckNhc2UoKSA6IFwiXCJdIHx8IGcpICYmIGcuc3RvcHMpIHRoaXMuc3RvcHMgPSBnLnN0b3BzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBuZXcgZCh0WzFdKTtcbiAgICAgICAgfSk7ZWxzZSB7XG4gICAgICAgICAgaWYgKGcgJiYgZy5jaGFyQXQgJiYgXCIjXCIgPT09IGcuY2hhckF0KCkpIHtcbiAgICAgICAgICAgIHZhciB1ID0gZy5sZW5ndGg7XG4gICAgICAgICAgICBnID0gcGFyc2VJbnQoZy5zdWJzdHIoMSksIDE2KTtcbiAgICAgICAgICAgIDcgPT09IHUgPyBBID0gWyhnICYgMTY3MTE2ODApID4+IDE2LCAoZyAmIDY1MjgwKSA+PiA4LCBnICYgMjU1LCAxXSA6IDQgPT09IHUgJiYgKEEgPSBbKGcgJiAzODQwKSA+PiA0IHwgKGcgJiAzODQwKSA+PiA4LCAoZyAmIDI0MCkgPj4gNCB8IGcgJiAyNDAsIChnICYgMTUpIDw8IDQgfCBnICYgMTUsIDFdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIUEpIGZvciAoRyA9IHRoaXMucGFyc2Vycy5sZW5ndGg7IEctLSAmJiAhQTspIHtcbiAgICAgICAgICAgIHZhciB5ID0gdGhpcy5wYXJzZXJzW0ddO1xuICAgICAgICAgICAgKHUgPSB5LnJlZ2V4LmV4ZWMoZykpICYmIChBID0geS5wYXJzZSh1KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmdiYSA9IEEgfHwgW107XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgZyA9IHRoaXMuaW5wdXQsXG4gICAgICAgICAgICBHID0gdGhpcy5yZ2JhO1xuXG4gICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgdGhpcy5zdG9wcykge1xuICAgICAgICAgIHZhciBFID0gdShnKTtcbiAgICAgICAgICBFLnN0b3BzID0gW10uY29uY2F0KEUuc3RvcHMpO1xuICAgICAgICAgIHRoaXMuc3RvcHMuZm9yRWFjaChmdW5jdGlvbiAoZywgdCkge1xuICAgICAgICAgICAgRS5zdG9wc1t0XSA9IFtFLnN0b3BzW3RdWzBdLCBnLmdldChkKV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBFID0gRyAmJiBXKEdbMF0pID8gXCJyZ2JcIiA9PT0gZCB8fCAhZCAmJiAxID09PSBHWzNdID8gXCJyZ2IoXCIgKyBHWzBdICsgXCIsXCIgKyBHWzFdICsgXCIsXCIgKyBHWzJdICsgXCIpXCIgOiBcImFcIiA9PT0gZCA/IEdbM10gOiBcInJnYmEoXCIgKyBHLmpvaW4oXCIsXCIpICsgXCIpXCIgOiBnO1xuXG4gICAgICAgIHJldHVybiBFO1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUuYnJpZ2h0ZW4gPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgZyxcbiAgICAgICAgICAgIHUgPSB0aGlzLnJnYmE7XG4gICAgICAgIGlmICh0aGlzLnN0b3BzKSB0aGlzLnN0b3BzLmZvckVhY2goZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgICBnLmJyaWdodGVuKGQpO1xuICAgICAgICB9KTtlbHNlIGlmIChXKGQpICYmIDAgIT09IGQpIGZvciAoZyA9IDA7IDMgPiBnOyBnKyspIHVbZ10gKz0gcigyNTUgKiBkKSwgMCA+IHVbZ10gJiYgKHVbZ10gPSAwKSwgMjU1IDwgdVtnXSAmJiAodVtnXSA9IDI1NSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUuc2V0T3BhY2l0eSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHRoaXMucmdiYVszXSA9IGQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUudHdlZW5UbyA9IGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgICAgIHZhciB1ID0gdGhpcy5yZ2JhLFxuICAgICAgICAgICAgQSA9IGQucmdiYTtcbiAgICAgICAgQS5sZW5ndGggJiYgdSAmJiB1Lmxlbmd0aCA/IChkID0gMSAhPT0gQVszXSB8fCAxICE9PSB1WzNdLCBnID0gKGQgPyBcInJnYmEoXCIgOiBcInJnYihcIikgKyBNYXRoLnJvdW5kKEFbMF0gKyAodVswXSAtIEFbMF0pICogKDEgLSBnKSkgKyBcIixcIiArIE1hdGgucm91bmQoQVsxXSArICh1WzFdIC0gQVsxXSkgKiAoMSAtIGcpKSArIFwiLFwiICsgTWF0aC5yb3VuZChBWzJdICsgKHVbMl0gLSBBWzJdKSAqICgxIC0gZykpICsgKGQgPyBcIixcIiArIChBWzNdICsgKHVbM10gLSBBWzNdKSAqICgxIC0gZykpIDogXCJcIikgKyBcIilcIikgOiBnID0gZC5pbnB1dCB8fCBcIm5vbmVcIjtcbiAgICAgICAgcmV0dXJuIGc7XG4gICAgICB9O1xuXG4gICAgICBkLm5hbWVzID0ge1xuICAgICAgICB3aGl0ZTogXCIjZmZmZmZmXCIsXG4gICAgICAgIGJsYWNrOiBcIiMwMDAwMDBcIlxuICAgICAgfTtcbiAgICAgIHJldHVybiBkO1xuICAgIH0oKTtcblxuICAgIGQuQ29sb3IgPSBnO1xuICAgIGQuY29sb3IgPSBnLnBhcnNlO1xuICAgIHJldHVybiBkLkNvbG9yO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL1N2Z1JlbmRlcmVyLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL0NvbG9yLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcsIHIpIHtcbiAgICB2YXIgdSA9IGcucGFyc2UsXG4gICAgICAgIEkgPSByLmFkZEV2ZW50LFxuICAgICAgICBNID0gci5hbmltYXRlLFxuICAgICAgICBFID0gci5hbmltT2JqZWN0LFxuICAgICAgICBBID0gci5hdHRyLFxuICAgICAgICBHID0gci5jcmVhdGVFbGVtZW50LFxuICAgICAgICBKID0gci5jc3MsXG4gICAgICAgIHkgPSByLmRlZmluZWQsXG4gICAgICAgIHQgPSByLmRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzLFxuICAgICAgICBEID0gci5lcmFzZSxcbiAgICAgICAgaCA9IHIuZXh0ZW5kLFxuICAgICAgICBOID0gci5pbkFycmF5LFxuICAgICAgICBxID0gci5pc0FycmF5LFxuICAgICAgICBQID0gci5pc051bWJlcixcbiAgICAgICAgZSA9IHIuaXNPYmplY3QsXG4gICAgICAgIGMgPSByLmlzU3RyaW5nLFxuICAgICAgICBrID0gci5tZXJnZSxcbiAgICAgICAgbiA9IHIub2JqZWN0RWFjaCxcbiAgICAgICAgZiA9IHIucGljayxcbiAgICAgICAgYSA9IHIucEludCxcbiAgICAgICAgbCA9IHIucmVtb3ZlRXZlbnQsXG4gICAgICAgIHYgPSByLnNwbGF0LFxuICAgICAgICB6ID0gci5zdG9wLFxuICAgICAgICB3ID0gci51bmlxdWVLZXksXG4gICAgICAgIEIgPSBkLmNoYXJ0cyxcbiAgICAgICAgTCA9IGQuZGVnMnJhZCxcbiAgICAgICAgUSA9IGQuZG9jLFxuICAgICAgICBIID0gZC5oYXNUb3VjaCxcbiAgICAgICAgSyA9IGQuaXNGaXJlZm94LFxuICAgICAgICBwID0gZC5pc01TLFxuICAgICAgICBiID0gZC5pc1dlYktpdCxcbiAgICAgICAgQyA9IGQubm9vcCxcbiAgICAgICAgeCA9IGQuc3ZnLFxuICAgICAgICBSID0gZC5TVkdfTlMsXG4gICAgICAgIE8gPSBkLnN5bWJvbFNpemVzLFxuICAgICAgICBYID0gZC53aW47XG5cbiAgICB2YXIgVSA9IGQuU1ZHRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBoKFUucHJvdG90eXBlLCB7XG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgU1ZHX05TOiBSLFxuICAgICAgdGV4dFByb3BzOiBcImRpcmVjdGlvbiBmb250U2l6ZSBmb250V2VpZ2h0IGZvbnRGYW1pbHkgZm9udFN0eWxlIGNvbG9yIGxpbmVIZWlnaHQgd2lkdGggdGV4dEFsaWduIHRleHREZWNvcmF0aW9uIHRleHRPdmVyZmxvdyB0ZXh0T3V0bGluZSBjdXJzb3JcIi5zcGxpdChcIiBcIiksXG4gICAgICBpbml0OiBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBcInNwYW5cIiA9PT0gYSA/IEcoYSkgOiBRLmNyZWF0ZUVsZW1lbnROUyh0aGlzLlNWR19OUywgYSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBiO1xuICAgICAgICBkLmZpcmVFdmVudCh0aGlzLCBcImFmdGVySW5pdFwiKTtcbiAgICAgIH0sXG4gICAgICBhbmltYXRlOiBmdW5jdGlvbiAoYiwgYSwgYykge1xuICAgICAgICB2YXIgbSA9IEUoZihhLCB0aGlzLnJlbmRlcmVyLmdsb2JhbEFuaW1hdGlvbiwgITApKTtcbiAgICAgICAgZihRLmhpZGRlbiwgUS5tc0hpZGRlbiwgUS53ZWJraXRIaWRkZW4sICExKSAmJiAobS5kdXJhdGlvbiA9IDApO1xuICAgICAgICAwICE9PSBtLmR1cmF0aW9uID8gKGMgJiYgKG0uY29tcGxldGUgPSBjKSwgTSh0aGlzLCBiLCBtKSkgOiAodGhpcy5hdHRyKGIsIHZvaWQgMCwgYyksIG4oYiwgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBtLnN0ZXAgJiYgbS5zdGVwLmNhbGwodGhpcywgYiwge1xuICAgICAgICAgICAgcHJvcDogYSxcbiAgICAgICAgICAgIHBvczogMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGNvbXBsZXhDb2xvcjogZnVuY3Rpb24gKGIsIGEsIGYpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLnJlbmRlcmVyLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIHAsXG4gICAgICAgICAgICBlLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIFQsXG4gICAgICAgICAgICBDLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHYsXG4gICAgICAgICAgICB6LFxuICAgICAgICAgICAgWixcbiAgICAgICAgICAgIE8sXG4gICAgICAgICAgICBSID0gW10sXG4gICAgICAgICAgICBCO1xuICAgICAgICBkLmZpcmVFdmVudCh0aGlzLnJlbmRlcmVyLCBcImNvbXBsZXhDb2xvclwiLCB7XG4gICAgICAgICAgYXJnczogYXJndW1lbnRzXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBiLnJhZGlhbEdyYWRpZW50ID8gcCA9IFwicmFkaWFsR3JhZGllbnRcIiA6IGIubGluZWFyR3JhZGllbnQgJiYgKHAgPSBcImxpbmVhckdyYWRpZW50XCIpO1xuICAgICAgICAgIHAgJiYgKGUgPSBiW3BdLCBUID0gbS5ncmFkaWVudHMsIGwgPSBiLnN0b3BzLCBaID0gZi5yYWRpYWxSZWZlcmVuY2UsIHEoZSkgJiYgKGJbcF0gPSBlID0ge1xuICAgICAgICAgICAgeDE6IGVbMF0sXG4gICAgICAgICAgICB5MTogZVsxXSxcbiAgICAgICAgICAgIHgyOiBlWzJdLFxuICAgICAgICAgICAgeTI6IGVbM10sXG4gICAgICAgICAgICBncmFkaWVudFVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCJcbiAgICAgICAgICB9KSwgXCJyYWRpYWxHcmFkaWVudFwiID09PSBwICYmIFogJiYgIXkoZS5ncmFkaWVudFVuaXRzKSAmJiAoeCA9IGUsIGUgPSBrKGUsIG0uZ2V0UmFkaWFsQXR0cihaLCB4KSwge1xuICAgICAgICAgICAgZ3JhZGllbnRVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiXG4gICAgICAgICAgfSkpLCBuKGUsIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgICBcImlkXCIgIT09IGEgJiYgUi5wdXNoKGEsIGIpO1xuICAgICAgICAgIH0pLCBuKGwsIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICBSLnB1c2goYik7XG4gICAgICAgICAgfSksIFIgPSBSLmpvaW4oXCIsXCIpLCBUW1JdID8gTyA9IFRbUl0uYXR0cihcImlkXCIpIDogKGUuaWQgPSBPID0gdygpLCBUW1JdID0gQyA9IG0uY3JlYXRlRWxlbWVudChwKS5hdHRyKGUpLmFkZChtLmRlZnMpLCBDLnJhZEF0dHIgPSB4LCBDLnN0b3BzID0gW10sIGwuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgMCA9PT0gYlsxXS5pbmRleE9mKFwicmdiYVwiKSA/IChjID0gdShiWzFdKSwgdiA9IGMuZ2V0KFwicmdiXCIpLCB6ID0gYy5nZXQoXCJhXCIpKSA6ICh2ID0gYlsxXSwgeiA9IDEpO1xuICAgICAgICAgICAgYiA9IG0uY3JlYXRlRWxlbWVudChcInN0b3BcIikuYXR0cih7XG4gICAgICAgICAgICAgIG9mZnNldDogYlswXSxcbiAgICAgICAgICAgICAgXCJzdG9wLWNvbG9yXCI6IHYsXG4gICAgICAgICAgICAgIFwic3RvcC1vcGFjaXR5XCI6IHpcbiAgICAgICAgICAgIH0pLmFkZChDKTtcbiAgICAgICAgICAgIEMuc3RvcHMucHVzaChiKTtcbiAgICAgICAgICB9KSksIEIgPSBcInVybChcIiArIG0udXJsICsgXCIjXCIgKyBPICsgXCIpXCIsIGYuc2V0QXR0cmlidXRlKGEsIEIpLCBmLmdyYWRpZW50ID0gUiwgYi50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBCO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBhcHBseVRleHRPdXRsaW5lOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgIG07XG4gICAgICAgIC0xICE9PSBiLmluZGV4T2YoXCJjb250cmFzdFwiKSAmJiAoYiA9IGIucmVwbGFjZSgvY29udHJhc3QvZywgdGhpcy5yZW5kZXJlci5nZXRDb250cmFzdChhLnN0eWxlLmZpbGwpKSk7XG4gICAgICAgIGIgPSBiLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgdmFyIGYgPSBiW2IubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKChtID0gYlswXSkgJiYgXCJub25lXCIgIT09IG0gJiYgZC5zdmcpIHtcbiAgICAgICAgICB0aGlzLmZha2VUUyA9ICEwO1xuICAgICAgICAgIGIgPSBbXS5zbGljZS5jYWxsKGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0c3BhblwiKSk7XG4gICAgICAgICAgdGhpcy55U2V0dGVyID0gdGhpcy54U2V0dGVyO1xuICAgICAgICAgIG0gPSBtLnJlcGxhY2UoLyheW1xcZFxcLl0rKSguKj8pJC9nLCBmdW5jdGlvbiAoYiwgYSwgbSkge1xuICAgICAgICAgICAgcmV0dXJuIDIgKiBhICsgbTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnJlbW92ZVRleHRPdXRsaW5lKGIpO1xuICAgICAgICAgIHZhciBjID0gYS50ZXh0Q29udGVudCA/IC9eW1xcdTA1OTEtXFx1MDY1RlxcdTA2NkEtXFx1MDdGRlxcdUZCMUQtXFx1RkRGRFxcdUZFNzAtXFx1RkVGQ10vLnRlc3QoYS50ZXh0Q29udGVudCkgOiAhMTtcbiAgICAgICAgICB2YXIgcCA9IGEuZmlyc3RDaGlsZDtcbiAgICAgICAgICBiLmZvckVhY2goZnVuY3Rpb24gKGIsIGUpIHtcbiAgICAgICAgICAgIDAgPT09IGUgJiYgKGIuc2V0QXR0cmlidXRlKFwieFwiLCBhLmdldEF0dHJpYnV0ZShcInhcIikpLCBlID0gYS5nZXRBdHRyaWJ1dGUoXCJ5XCIpLCBiLnNldEF0dHJpYnV0ZShcInlcIiwgZSB8fCAwKSwgbnVsbCA9PT0gZSAmJiBhLnNldEF0dHJpYnV0ZShcInlcIiwgMCkpO1xuICAgICAgICAgICAgZSA9IGIuY2xvbmVOb2RlKCEwKTtcbiAgICAgICAgICAgIEEoYyAmJiAhSyA/IGIgOiBlLCB7XG4gICAgICAgICAgICAgIFwiY2xhc3NcIjogXCJoaWdoY2hhcnRzLXRleHQtb3V0bGluZVwiLFxuICAgICAgICAgICAgICBmaWxsOiBmLFxuICAgICAgICAgICAgICBzdHJva2U6IGYsXG4gICAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IG0sXG4gICAgICAgICAgICAgIFwic3Ryb2tlLWxpbmVqb2luXCI6IFwicm91bmRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhLmluc2VydEJlZm9yZShlLCBwKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjICYmIEsgJiYgYlswXSAmJiAoYiA9IGJbMF0uY2xvbmVOb2RlKCEwKSwgYi50ZXh0Q29udGVudCA9IFwiIFwiLCBhLmluc2VydEJlZm9yZShiLCBwKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW1vdmVUZXh0T3V0bGluZTogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgZm9yICh2YXIgYSA9IGIubGVuZ3RoLCBtOyBhLS07KSBtID0gYlthXSwgXCJoaWdoY2hhcnRzLXRleHQtb3V0bGluZVwiID09PSBtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpICYmIEQoYiwgdGhpcy5lbGVtZW50LnJlbW92ZUNoaWxkKG0pKTtcbiAgICAgIH0sXG4gICAgICBzeW1ib2xDdXN0b21BdHRyaWJzOiBcInggeSB3aWR0aCBoZWlnaHQgciBzdGFydCBlbmQgaW5uZXJSIGFuY2hvclggYW5jaG9yWSByb3VuZGVkXCIuc3BsaXQoXCIgXCIpLFxuICAgICAgYXR0cjogZnVuY3Rpb24gKGIsIGEsIGYsIGMpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgICBwLFxuICAgICAgICAgICAgZSA9IHRoaXMsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgQyxcbiAgICAgICAgICAgIGwgPSB0aGlzLnN5bWJvbEN1c3RvbUF0dHJpYnM7XG5cbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBiICYmIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBhKSB7XG4gICAgICAgICAgdmFyIFQgPSBiO1xuICAgICAgICAgIGIgPSB7fTtcbiAgICAgICAgICBiW1RdID0gYTtcbiAgICAgICAgfVxuXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBiID8gZSA9ICh0aGlzW2IgKyBcIkdldHRlclwiXSB8fCB0aGlzLl9kZWZhdWx0R2V0dGVyKS5jYWxsKHRoaXMsIGIsIG0pIDogKG4oYiwgZnVuY3Rpb24gKGEsIGYpIHtcbiAgICAgICAgICB4ID0gITE7XG4gICAgICAgICAgYyB8fCB6KHRoaXMsIGYpO1xuICAgICAgICAgIHRoaXMuc3ltYm9sTmFtZSAmJiAtMSAhPT0gTihmLCBsKSAmJiAocCB8fCAodGhpcy5zeW1ib2xBdHRyKGIpLCBwID0gITApLCB4ID0gITApO1xuICAgICAgICAgICF0aGlzLnJvdGF0aW9uIHx8IFwieFwiICE9PSBmICYmIFwieVwiICE9PSBmIHx8ICh0aGlzLmRvVHJhbnNmb3JtID0gITApO1xuICAgICAgICAgIHggfHwgKEMgPSB0aGlzW2YgKyBcIlNldHRlclwiXSB8fCB0aGlzLl9kZWZhdWx0U2V0dGVyLCBDLmNhbGwodGhpcywgYSwgZiwgbSksICF0aGlzLnN0eWxlZE1vZGUgJiYgdGhpcy5zaGFkb3dzICYmIC9eKHdpZHRofGhlaWdodHx2aXNpYmlsaXR5fHh8eXxkfHRyYW5zZm9ybXxjeHxjeXxyKSQvLnRlc3QoZikgJiYgdGhpcy51cGRhdGVTaGFkb3dzKGYsIGEsIEMpKTtcbiAgICAgICAgfSwgdGhpcyksIHRoaXMuYWZ0ZXJTZXR0ZXJzKCkpO1xuICAgICAgICBmICYmIGYuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9LFxuICAgICAgYWZ0ZXJTZXR0ZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZG9UcmFuc2Zvcm0gJiYgKHRoaXMudXBkYXRlVHJhbnNmb3JtKCksIHRoaXMuZG9UcmFuc2Zvcm0gPSAhMSk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlU2hhZG93czogZnVuY3Rpb24gKGIsIGEsIGYpIHtcbiAgICAgICAgZm9yICh2YXIgbSA9IHRoaXMuc2hhZG93cywgYyA9IG0ubGVuZ3RoOyBjLS07KSBmLmNhbGwobVtjXSwgXCJoZWlnaHRcIiA9PT0gYiA/IE1hdGgubWF4KGEgLSAobVtjXS5jdXRIZWlnaHQgfHwgMCksIDApIDogXCJkXCIgPT09IGIgPyB0aGlzLmQgOiBhLCBiLCBtW2NdKTtcbiAgICAgIH0sXG4gICAgICBhZGRDbGFzczogZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgdmFyIG0gPSBhID8gXCJcIiA6IHRoaXMuYXR0cihcImNsYXNzXCIpIHx8IFwiXCI7XG4gICAgICAgIGIgPSAoYiB8fCBcIlwiKS5zcGxpdCgvIC9nKS5yZWR1Y2UoZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICAtMSA9PT0gbS5pbmRleE9mKGEpICYmIGIucHVzaChhKTtcbiAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfSwgbSA/IFttXSA6IFtdKS5qb2luKFwiIFwiKTtcbiAgICAgICAgYiAhPT0gbSAmJiB0aGlzLmF0dHIoXCJjbGFzc1wiLCBiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgaGFzQ2xhc3M6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHJldHVybiAtMSAhPT0gKHRoaXMuYXR0cihcImNsYXNzXCIpIHx8IFwiXCIpLnNwbGl0KFwiIFwiKS5pbmRleE9mKGIpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKFwiY2xhc3NcIiwgKHRoaXMuYXR0cihcImNsYXNzXCIpIHx8IFwiXCIpLnJlcGxhY2UoYyhiKSA/IG5ldyBSZWdFeHAoXCIgP1wiICsgYiArIFwiID9cIikgOiBiLCBcIlwiKSk7XG4gICAgICB9LFxuICAgICAgc3ltYm9sQXR0cjogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICBcInggeSByIHN0YXJ0IGVuZCB3aWR0aCBoZWlnaHQgaW5uZXJSIGFuY2hvclggYW5jaG9yWSBjbG9ja3dpc2VcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgICAgIGFbbV0gPSBmKGJbbV0sIGFbbV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYS5hdHRyKHtcbiAgICAgICAgICBkOiBhLnJlbmRlcmVyLnN5bWJvbHNbYS5zeW1ib2xOYW1lXShhLngsIGEueSwgYS53aWR0aCwgYS5oZWlnaHQsIGEpXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGNsaXA6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoXCJjbGlwLXBhdGhcIiwgYiA/IFwidXJsKFwiICsgdGhpcy5yZW5kZXJlci51cmwgKyBcIiNcIiArIGIuaWQgKyBcIilcIiA6IFwibm9uZVwiKTtcbiAgICAgIH0sXG4gICAgICBjcmlzcDogZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgYSA9IGEgfHwgYi5zdHJva2VXaWR0aCB8fCAwO1xuICAgICAgICB2YXIgbSA9IE1hdGgucm91bmQoYSkgJSAyIC8gMjtcbiAgICAgICAgYi54ID0gTWF0aC5mbG9vcihiLnggfHwgdGhpcy54IHx8IDApICsgbTtcbiAgICAgICAgYi55ID0gTWF0aC5mbG9vcihiLnkgfHwgdGhpcy55IHx8IDApICsgbTtcbiAgICAgICAgYi53aWR0aCA9IE1hdGguZmxvb3IoKGIud2lkdGggfHwgdGhpcy53aWR0aCB8fCAwKSAtIDIgKiBtKTtcbiAgICAgICAgYi5oZWlnaHQgPSBNYXRoLmZsb29yKChiLmhlaWdodCB8fCB0aGlzLmhlaWdodCB8fCAwKSAtIDIgKiBtKTtcbiAgICAgICAgeShiLnN0cm9rZVdpZHRoKSAmJiAoYi5zdHJva2VXaWR0aCA9IGEpO1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0sXG4gICAgICBjc3M6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5zdHlsZXMsXG4gICAgICAgICAgICBmID0ge30sXG4gICAgICAgICAgICBjID0gdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgcCA9IFwiXCIsXG4gICAgICAgICAgICBlID0gIW0sXG4gICAgICAgICAgICBDID0gW1widGV4dE91dGxpbmVcIiwgXCJ0ZXh0T3ZlcmZsb3dcIiwgXCJ3aWR0aFwiXTtcbiAgICAgICAgYiAmJiBiLmNvbG9yICYmIChiLmZpbGwgPSBiLmNvbG9yKTtcbiAgICAgICAgbSAmJiBuKGIsIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgYiAhPT0gbVthXSAmJiAoZlthXSA9IGIsIGUgPSAhMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgbSAmJiAoYiA9IGgobSwgZikpO1xuICAgICAgICAgIGlmIChiKSBpZiAobnVsbCA9PT0gYi53aWR0aCB8fCBcImF1dG9cIiA9PT0gYi53aWR0aCkgZGVsZXRlIHRoaXMudGV4dFdpZHRoO2Vsc2UgaWYgKFwidGV4dFwiID09PSBjLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgJiYgYi53aWR0aCkgdmFyIGwgPSB0aGlzLnRleHRXaWR0aCA9IGEoYi53aWR0aCk7XG4gICAgICAgICAgdGhpcy5zdHlsZXMgPSBiO1xuICAgICAgICAgIGwgJiYgIXggJiYgdGhpcy5yZW5kZXJlci5mb3JFeHBvcnQgJiYgZGVsZXRlIGIud2lkdGg7XG5cbiAgICAgICAgICBpZiAoYy5uYW1lc3BhY2VVUkkgPT09IHRoaXMuU1ZHX05TKSB7XG4gICAgICAgICAgICB2YXIgayA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIi1cIiArIGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG4oYiwgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICAgICAgLTEgPT09IEMuaW5kZXhPZihhKSAmJiAocCArPSBhLnJlcGxhY2UoLyhbQS1aXSkvZywgaykgKyBcIjpcIiArIGIgKyBcIjtcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHAgJiYgQShjLCBcInN0eWxlXCIsIHApO1xuICAgICAgICAgIH0gZWxzZSBKKGMsIGIpO1xuXG4gICAgICAgICAgdGhpcy5hZGRlZCAmJiAoXCJ0ZXh0XCIgPT09IHRoaXMuZWxlbWVudC5ub2RlTmFtZSAmJiB0aGlzLnJlbmRlcmVyLmJ1aWxkVGV4dCh0aGlzKSwgYiAmJiBiLnRleHRPdXRsaW5lICYmIHRoaXMuYXBwbHlUZXh0T3V0bGluZShiLnRleHRPdXRsaW5lKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBnZXRTdHlsZTogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIFguZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsZW1lbnQgfHwgdGhpcywgXCJcIikuZ2V0UHJvcGVydHlWYWx1ZShiKTtcbiAgICAgIH0sXG4gICAgICBzdHJva2VXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVuZGVyZXIuc3R5bGVkTW9kZSkgcmV0dXJuIHRoaXNbXCJzdHJva2Utd2lkdGhcIl0gfHwgMDtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmdldFN0eWxlKFwic3Ryb2tlLXdpZHRoXCIpLFxuICAgICAgICAgICAgZiA9IDA7XG4gICAgICAgIGlmIChiLmluZGV4T2YoXCJweFwiKSA9PT0gYi5sZW5ndGggLSAyKSBmID0gYShiKTtlbHNlIGlmIChcIlwiICE9PSBiKSB7XG4gICAgICAgICAgdmFyIGMgPSBRLmNyZWF0ZUVsZW1lbnROUyhSLCBcInJlY3RcIik7XG4gICAgICAgICAgQShjLCB7XG4gICAgICAgICAgICB3aWR0aDogYixcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChjKTtcbiAgICAgICAgICBmID0gYy5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgICAgYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfSxcbiAgICAgIG9uOiBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICB2YXIgbSxcbiAgICAgICAgICAgIGYsXG4gICAgICAgICAgICBjID0gdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgcDtcbiAgICAgICAgSCAmJiBcImNsaWNrXCIgPT09IGIgPyAoYy5vbnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIG0gPSBiLnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgICAgICBmID0gYi50b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICAgIH0sIGMub250b3VjaGVuZCA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgbSAmJiA0IDw9IE1hdGguc3FydChNYXRoLnBvdyhtIC0gYi5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYLCAyKSArIE1hdGgucG93KGYgLSBiLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFksIDIpKSB8fCBhLmNhbGwoYywgYik7XG4gICAgICAgICAgcCA9ICEwO1xuICAgICAgICAgIGIucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSwgYy5vbmNsaWNrID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBwIHx8IGEuY2FsbChjLCBiKTtcbiAgICAgICAgfSkgOiBjW1wib25cIiArIGJdID0gYTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgc2V0UmFkaWFsUmVmZXJlbmNlOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXMucmVuZGVyZXIuZ3JhZGllbnRzW3RoaXMuZWxlbWVudC5ncmFkaWVudF07XG4gICAgICAgIHRoaXMuZWxlbWVudC5yYWRpYWxSZWZlcmVuY2UgPSBiO1xuICAgICAgICBhICYmIGEucmFkQXR0ciAmJiBhLmFuaW1hdGUodGhpcy5yZW5kZXJlci5nZXRSYWRpYWxBdHRyKGIsIGEucmFkQXR0cikpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoe1xuICAgICAgICAgIHRyYW5zbGF0ZVg6IGIsXG4gICAgICAgICAgdHJhbnNsYXRlWTogYVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBpbnZlcnQ6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHRoaXMuaW52ZXJ0ZWQgPSBiO1xuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICB1cGRhdGVUcmFuc2Zvcm06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLnRyYW5zbGF0ZVggfHwgMCxcbiAgICAgICAgICAgIGEgPSB0aGlzLnRyYW5zbGF0ZVkgfHwgMCxcbiAgICAgICAgICAgIGMgPSB0aGlzLnNjYWxlWCxcbiAgICAgICAgICAgIHAgPSB0aGlzLnNjYWxlWSxcbiAgICAgICAgICAgIGUgPSB0aGlzLmludmVydGVkLFxuICAgICAgICAgICAgeCA9IHRoaXMucm90YXRpb24sXG4gICAgICAgICAgICBDID0gdGhpcy5tYXRyaXgsXG4gICAgICAgICAgICBsID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBlICYmIChiICs9IHRoaXMud2lkdGgsIGEgKz0gdGhpcy5oZWlnaHQpO1xuICAgICAgICBiID0gW1widHJhbnNsYXRlKFwiICsgYiArIFwiLFwiICsgYSArIFwiKVwiXTtcbiAgICAgICAgeShDKSAmJiBiLnB1c2goXCJtYXRyaXgoXCIgKyBDLmpvaW4oXCIsXCIpICsgXCIpXCIpO1xuICAgICAgICBlID8gYi5wdXNoKFwicm90YXRlKDkwKSBzY2FsZSgtMSwxKVwiKSA6IHggJiYgYi5wdXNoKFwicm90YXRlKFwiICsgeCArIFwiIFwiICsgZih0aGlzLnJvdGF0aW9uT3JpZ2luWCwgbC5nZXRBdHRyaWJ1dGUoXCJ4XCIpLCAwKSArIFwiIFwiICsgZih0aGlzLnJvdGF0aW9uT3JpZ2luWSwgbC5nZXRBdHRyaWJ1dGUoXCJ5XCIpIHx8IDApICsgXCIpXCIpO1xuICAgICAgICAoeShjKSB8fCB5KHApKSAmJiBiLnB1c2goXCJzY2FsZShcIiArIGYoYywgMSkgKyBcIiBcIiArIGYocCwgMSkgKyBcIilcIik7XG4gICAgICAgIGIubGVuZ3RoICYmIGwuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIGIuam9pbihcIiBcIikpO1xuICAgICAgfSxcbiAgICAgIHRvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIGIucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgYWxpZ246IGZ1bmN0aW9uIChiLCBhLCBwKSB7XG4gICAgICAgIHZhciBtLFxuICAgICAgICAgICAgZSA9IHt9O1xuICAgICAgICB2YXIgeCA9IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIHZhciBDID0geC5hbGlnbmVkT2JqZWN0cztcbiAgICAgICAgdmFyIGwsIGs7XG5cbiAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICBpZiAodGhpcy5hbGlnbk9wdGlvbnMgPSBiLCB0aGlzLmFsaWduQnlUcmFuc2xhdGUgPSBhLCAhcCB8fCBjKHApKSB0aGlzLmFsaWduVG8gPSBtID0gcCB8fCBcInJlbmRlcmVyXCIsIEQoQywgdGhpcyksIEMucHVzaCh0aGlzKSwgcCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBiID0gdGhpcy5hbGlnbk9wdGlvbnMsIGEgPSB0aGlzLmFsaWduQnlUcmFuc2xhdGUsIG0gPSB0aGlzLmFsaWduVG87XG5cbiAgICAgICAgcCA9IGYocCwgeFttXSwgeCk7XG4gICAgICAgIG0gPSBiLmFsaWduO1xuICAgICAgICB4ID0gYi52ZXJ0aWNhbEFsaWduO1xuICAgICAgICBDID0gKHAueCB8fCAwKSArIChiLnggfHwgMCk7XG4gICAgICAgIHZhciBUID0gKHAueSB8fCAwKSArIChiLnkgfHwgMCk7XG4gICAgICAgIFwicmlnaHRcIiA9PT0gbSA/IGwgPSAxIDogXCJjZW50ZXJcIiA9PT0gbSAmJiAobCA9IDIpO1xuICAgICAgICBsICYmIChDICs9IChwLndpZHRoIC0gKGIud2lkdGggfHwgMCkpIC8gbCk7XG4gICAgICAgIGVbYSA/IFwidHJhbnNsYXRlWFwiIDogXCJ4XCJdID0gTWF0aC5yb3VuZChDKTtcbiAgICAgICAgXCJib3R0b21cIiA9PT0geCA/IGsgPSAxIDogXCJtaWRkbGVcIiA9PT0geCAmJiAoayA9IDIpO1xuICAgICAgICBrICYmIChUICs9IChwLmhlaWdodCAtIChiLmhlaWdodCB8fCAwKSkgLyBrKTtcbiAgICAgICAgZVthID8gXCJ0cmFuc2xhdGVZXCIgOiBcInlcIl0gPSBNYXRoLnJvdW5kKFQpO1xuICAgICAgICB0aGlzW3RoaXMucGxhY2VkID8gXCJhbmltYXRlXCIgOiBcImF0dHJcIl0oZSk7XG4gICAgICAgIHRoaXMucGxhY2VkID0gITA7XG4gICAgICAgIHRoaXMuYWxpZ25BdHRyID0gZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZ2V0QkJveDogZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgdmFyIG0sXG4gICAgICAgICAgICBjID0gdGhpcy5yZW5kZXJlcixcbiAgICAgICAgICAgIHAgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgICBlID0gdGhpcy5zdHlsZXMsXG4gICAgICAgICAgICB4ID0gdGhpcy50ZXh0U3RyLFxuICAgICAgICAgICAgQyxcbiAgICAgICAgICAgIGwgPSBjLmNhY2hlLFxuICAgICAgICAgICAgayA9IGMuY2FjaGVLZXlzLFxuICAgICAgICAgICAgVCA9IHAubmFtZXNwYWNlVVJJID09PSB0aGlzLlNWR19OUztcbiAgICAgICAgYSA9IGYoYSwgdGhpcy5yb3RhdGlvbiwgMCk7XG4gICAgICAgIHZhciBuID0gYy5zdHlsZWRNb2RlID8gcCAmJiBVLnByb3RvdHlwZS5nZXRTdHlsZS5jYWxsKHAsIFwiZm9udC1zaXplXCIpIDogZSAmJiBlLmZvbnRTaXplO1xuXG4gICAgICAgIGlmICh5KHgpKSB7XG4gICAgICAgICAgdmFyIHYgPSB4LnRvU3RyaW5nKCk7XG4gICAgICAgICAgLTEgPT09IHYuaW5kZXhPZihcIjxcIikgJiYgKHYgPSB2LnJlcGxhY2UoL1swLTldL2csIFwiMFwiKSk7XG4gICAgICAgICAgdiArPSBbXCJcIiwgYSwgbiwgdGhpcy50ZXh0V2lkdGgsIGUgJiYgZS50ZXh0T3ZlcmZsb3ddLmpvaW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHYgJiYgIWIgJiYgKG0gPSBsW3ZdKTtcblxuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICBpZiAoVCB8fCBjLmZvckV4cG9ydCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgKEMgPSB0aGlzLmZha2VUUyAmJiBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgICAgIFtdLmZvckVhY2guY2FsbChwLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuaGlnaGNoYXJ0cy10ZXh0LW91dGxpbmVcIiksIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICBhLnN0eWxlLmRpc3BsYXkgPSBiO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KSAmJiBDKFwibm9uZVwiKSwgbSA9IHAuZ2V0QkJveCA/IGgoe30sIHAuZ2V0QkJveCgpKSA6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogcC5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHAub2Zmc2V0SGVpZ2h0XG4gICAgICAgICAgICAgIH0sIEMgJiYgQyhcIlwiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVhKSB7XG4gICAgICAgICAgICAgIFwiXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbSB8fCAwID4gbS53aWR0aCkgbSA9IHtcbiAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgbSA9IHRoaXMuaHRtbEdldEJCb3goKTtcblxuICAgICAgICAgIGMuaXNTVkcgJiYgKGIgPSBtLndpZHRoLCBjID0gbS5oZWlnaHQsIFQgJiYgKG0uaGVpZ2h0ID0gYyA9IHtcbiAgICAgICAgICAgIFwiMTFweCwxN1wiOiAxNCxcbiAgICAgICAgICAgIFwiMTNweCwyMFwiOiAxNlxuICAgICAgICAgIH1bZSAmJiBlLmZvbnRTaXplICsgXCIsXCIgKyBNYXRoLnJvdW5kKGMpXSB8fCBjKSwgYSAmJiAoZSA9IGEgKiBMLCBtLndpZHRoID0gTWF0aC5hYnMoYyAqIE1hdGguc2luKGUpKSArIE1hdGguYWJzKGIgKiBNYXRoLmNvcyhlKSksIG0uaGVpZ2h0ID0gTWF0aC5hYnMoYyAqIE1hdGguY29zKGUpKSArIE1hdGguYWJzKGIgKiBNYXRoLnNpbihlKSkpKTtcblxuICAgICAgICAgIGlmICh2ICYmIDAgPCBtLmhlaWdodCkge1xuICAgICAgICAgICAgZm9yICg7IDI1MCA8IGsubGVuZ3RoOykgZGVsZXRlIGxbay5zaGlmdCgpXTtcblxuICAgICAgICAgICAgbFt2XSB8fCBrLnB1c2godik7XG4gICAgICAgICAgICBsW3ZdID0gbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICAgIH0sXG4gICAgICBzaG93OiBmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKHtcbiAgICAgICAgICB2aXNpYmlsaXR5OiBiID8gXCJpbmhlcml0XCIgOiBcInZpc2libGVcIlxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBoaWRlOiBmdW5jdGlvbiAoYikge1xuICAgICAgICBiID8gdGhpcy5hdHRyKHtcbiAgICAgICAgICB5OiAtOTk5OVxuICAgICAgICB9KSA6IHRoaXMuYXR0cih7XG4gICAgICAgICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZmFkZU91dDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICBhLmFuaW1hdGUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiBiIHx8IDE1MCxcbiAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYS5hdHRyKHtcbiAgICAgICAgICAgICAgeTogLTk5OTlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgYWRkOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXMucmVuZGVyZXIsXG4gICAgICAgICAgICBtID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBiICYmICh0aGlzLnBhcmVudEdyb3VwID0gYik7XG4gICAgICAgIHRoaXMucGFyZW50SW52ZXJ0ZWQgPSBiICYmIGIuaW52ZXJ0ZWQ7XG4gICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiB0aGlzLnRleHRTdHIgJiYgYS5idWlsZFRleHQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkZWQgPSAhMDtcbiAgICAgICAgaWYgKCFiIHx8IGIuaGFuZGxlWiB8fCB0aGlzLnpJbmRleCkgdmFyIGYgPSB0aGlzLnpJbmRleFNldHRlcigpO1xuICAgICAgICBmIHx8IChiID8gYi5lbGVtZW50IDogYS5ib3gpLmFwcGVuZENoaWxkKG0pO1xuICAgICAgICBpZiAodGhpcy5vbkFkZCkgdGhpcy5vbkFkZCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBzYWZlUmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gYi5wYXJlbnROb2RlO1xuICAgICAgICBhICYmIGEucmVtb3ZlQ2hpbGQoYik7XG4gICAgICB9LFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgICAgICBhID0gYi5lbGVtZW50IHx8IHt9LFxuICAgICAgICAgICAgZiA9IGIucmVuZGVyZXIsXG4gICAgICAgICAgICBjID0gZi5pc1NWRyAmJiBcIlNQQU5cIiA9PT0gYS5ub2RlTmFtZSAmJiBiLnBhcmVudEdyb3VwLFxuICAgICAgICAgICAgcCA9IGEub3duZXJTVkdFbGVtZW50LFxuICAgICAgICAgICAgZSA9IGIuY2xpcFBhdGg7XG4gICAgICAgIGEub25jbGljayA9IGEub25tb3VzZW91dCA9IGEub25tb3VzZW92ZXIgPSBhLm9ubW91c2Vtb3ZlID0gYS5wb2ludCA9IG51bGw7XG4gICAgICAgIHooYik7XG4gICAgICAgIGUgJiYgcCAmJiAoW10uZm9yRWFjaC5jYWxsKHAucXVlcnlTZWxlY3RvckFsbChcIltjbGlwLXBhdGhdLFtDTElQLVBBVEhdXCIpLCBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIC0xIDwgYi5nZXRBdHRyaWJ1dGUoXCJjbGlwLXBhdGhcIikuaW5kZXhPZihlLmVsZW1lbnQuaWQpICYmIGIucmVtb3ZlQXR0cmlidXRlKFwiY2xpcC1wYXRoXCIpO1xuICAgICAgICB9KSwgYi5jbGlwUGF0aCA9IGUuZGVzdHJveSgpKTtcblxuICAgICAgICBpZiAoYi5zdG9wcykge1xuICAgICAgICAgIGZvciAocCA9IDA7IHAgPCBiLnN0b3BzLmxlbmd0aDsgcCsrKSBiLnN0b3BzW3BdID0gYi5zdG9wc1twXS5kZXN0cm95KCk7XG5cbiAgICAgICAgICBiLnN0b3BzID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGIuc2FmZVJlbW92ZUNoaWxkKGEpO1xuXG4gICAgICAgIGZvciAoZi5zdHlsZWRNb2RlIHx8IGIuZGVzdHJveVNoYWRvd3MoKTsgYyAmJiBjLmRpdiAmJiAwID09PSBjLmRpdi5jaGlsZE5vZGVzLmxlbmd0aDspIGEgPSBjLnBhcmVudEdyb3VwLCBiLnNhZmVSZW1vdmVDaGlsZChjLmRpdiksIGRlbGV0ZSBjLmRpdiwgYyA9IGE7XG5cbiAgICAgICAgYi5hbGlnblRvICYmIEQoZi5hbGlnbmVkT2JqZWN0cywgYik7XG4gICAgICAgIG4oYiwgZnVuY3Rpb24gKGEsIG0pIHtcbiAgICAgICAgICBiW21dICYmIGJbbV0ucGFyZW50R3JvdXAgPT09IGIgJiYgYlttXS5kZXN0cm95ICYmIGJbbV0uZGVzdHJveSgpO1xuICAgICAgICAgIGRlbGV0ZSBiW21dO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzaGFkb3c6IGZ1bmN0aW9uIChiLCBhLCBjKSB7XG4gICAgICAgIHZhciBtID0gW10sXG4gICAgICAgICAgICBwLFxuICAgICAgICAgICAgZSA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgaWYgKCFiKSB0aGlzLmRlc3Ryb3lTaGFkb3dzKCk7ZWxzZSBpZiAoIXRoaXMuc2hhZG93cykge1xuICAgICAgICAgIHZhciB4ID0gZihiLndpZHRoLCAzKTtcbiAgICAgICAgICB2YXIgQyA9IChiLm9wYWNpdHkgfHwgLjE1KSAvIHg7XG4gICAgICAgICAgdmFyIGwgPSB0aGlzLnBhcmVudEludmVydGVkID8gXCIoLTEsLTEpXCIgOiBcIihcIiArIGYoYi5vZmZzZXRYLCAxKSArIFwiLCBcIiArIGYoYi5vZmZzZXRZLCAxKSArIFwiKVwiO1xuXG4gICAgICAgICAgZm9yIChwID0gMTsgcCA8PSB4OyBwKyspIHtcbiAgICAgICAgICAgIHZhciBrID0gZS5jbG9uZU5vZGUoMCk7XG4gICAgICAgICAgICB2YXIgbiA9IDIgKiB4ICsgMSAtIDIgKiBwO1xuICAgICAgICAgICAgQShrLCB7XG4gICAgICAgICAgICAgIHN0cm9rZTogYi5jb2xvciB8fCBcIiMwMDAwMDBcIixcbiAgICAgICAgICAgICAgXCJzdHJva2Utb3BhY2l0eVwiOiBDICogcCxcbiAgICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogbixcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVwiICsgbCxcbiAgICAgICAgICAgICAgZmlsbDogXCJub25lXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgay5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCAoay5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKSArIFwiIGhpZ2hjaGFydHMtc2hhZG93XCIpO1xuICAgICAgICAgICAgYyAmJiAoQShrLCBcImhlaWdodFwiLCBNYXRoLm1heChBKGssIFwiaGVpZ2h0XCIpIC0gbiwgMCkpLCBrLmN1dEhlaWdodCA9IG4pO1xuICAgICAgICAgICAgYSA/IGEuZWxlbWVudC5hcHBlbmRDaGlsZChrKSA6IGUucGFyZW50Tm9kZSAmJiBlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGssIGUpO1xuICAgICAgICAgICAgbS5wdXNoKGspO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc2hhZG93cyA9IG07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZGVzdHJveVNoYWRvd3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgKHRoaXMuc2hhZG93cyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHRoaXMuc2FmZVJlbW92ZUNoaWxkKGIpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdGhpcy5zaGFkb3dzID0gdm9pZCAwO1xuICAgICAgfSxcbiAgICAgIHhHZXR0ZXI6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIFwiY2lyY2xlXCIgPT09IHRoaXMuZWxlbWVudC5ub2RlTmFtZSAmJiAoXCJ4XCIgPT09IGIgPyBiID0gXCJjeFwiIDogXCJ5XCIgPT09IGIgJiYgKGIgPSBcImN5XCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRHZXR0ZXIoYik7XG4gICAgICB9LFxuICAgICAgX2RlZmF1bHRHZXR0ZXI6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIGIgPSBmKHRoaXNbYiArIFwiVmFsdWVcIl0sIHRoaXNbYl0sIHRoaXMuZWxlbWVudCA/IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoYikgOiBudWxsLCAwKTtcbiAgICAgICAgL15bXFwtMC05XFwuXSskLy50ZXN0KGIpICYmIChiID0gcGFyc2VGbG9hdChiKSk7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSxcbiAgICAgIGRTZXR0ZXI6IGZ1bmN0aW9uIChiLCBhLCBmKSB7XG4gICAgICAgIGIgJiYgYi5qb2luICYmIChiID0gYi5qb2luKFwiIFwiKSk7XG4gICAgICAgIC8oTmFOfCB7Mn18XiQpLy50ZXN0KGIpICYmIChiID0gXCJNIDAgMFwiKTtcbiAgICAgICAgdGhpc1thXSAhPT0gYiAmJiAoZi5zZXRBdHRyaWJ1dGUoYSwgYiksIHRoaXNbYV0gPSBiKTtcbiAgICAgIH0sXG4gICAgICBkYXNoc3R5bGVTZXR0ZXI6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBmLFxuICAgICAgICAgICAgYyA9IHRoaXNbXCJzdHJva2Utd2lkdGhcIl07XG4gICAgICAgIFwiaW5oZXJpdFwiID09PSBjICYmIChjID0gMSk7XG5cbiAgICAgICAgaWYgKGIgPSBiICYmIGIudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIGIgPSBiLnJlcGxhY2UoXCJzaG9ydGRhc2hkb3Rkb3RcIiwgXCIzLDEsMSwxLDEsMSxcIikucmVwbGFjZShcInNob3J0ZGFzaGRvdFwiLCBcIjMsMSwxLDFcIikucmVwbGFjZShcInNob3J0ZG90XCIsIFwiMSwxLFwiKS5yZXBsYWNlKFwic2hvcnRkYXNoXCIsIFwiMywxLFwiKS5yZXBsYWNlKFwibG9uZ2Rhc2hcIiwgXCI4LDMsXCIpLnJlcGxhY2UoL2RvdC9nLCBcIjEsMyxcIikucmVwbGFjZShcImRhc2hcIiwgXCI0LDMsXCIpLnJlcGxhY2UoLywkLywgXCJcIikuc3BsaXQoXCIsXCIpO1xuXG4gICAgICAgICAgZm9yIChmID0gYi5sZW5ndGg7IGYtLTspIGJbZl0gPSBhKGJbZl0pICogYztcblxuICAgICAgICAgIGIgPSBiLmpvaW4oXCIsXCIpLnJlcGxhY2UoL05hTi9nLCBcIm5vbmVcIik7XG4gICAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgYik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhbGlnblNldHRlcjogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB7XG4gICAgICAgICAgbGVmdDogXCJzdGFydFwiLFxuICAgICAgICAgIGNlbnRlcjogXCJtaWRkbGVcIixcbiAgICAgICAgICByaWdodDogXCJlbmRcIlxuICAgICAgICB9O1xuICAgICAgICBhW2JdICYmICh0aGlzLmFsaWduVmFsdWUgPSBiLCB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwidGV4dC1hbmNob3JcIiwgYVtiXSkpO1xuICAgICAgfSxcbiAgICAgIG9wYWNpdHlTZXR0ZXI6IGZ1bmN0aW9uIChiLCBhLCBmKSB7XG4gICAgICAgIHRoaXNbYV0gPSBiO1xuICAgICAgICBmLnNldEF0dHJpYnV0ZShhLCBiKTtcbiAgICAgIH0sXG4gICAgICB0aXRsZVNldHRlcjogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0aXRsZVwiKVswXTtcbiAgICAgICAgYSB8fCAoYSA9IFEuY3JlYXRlRWxlbWVudE5TKHRoaXMuU1ZHX05TLCBcInRpdGxlXCIpLCB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoYSkpO1xuICAgICAgICBhLmZpcnN0Q2hpbGQgJiYgYS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpO1xuICAgICAgICBhLmFwcGVuZENoaWxkKFEuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGYoYiwgXCJcIikpLnJlcGxhY2UoLzxbXj5dKj4vZywgXCJcIikucmVwbGFjZSgvJmx0Oy9nLCBcIjxcIikucmVwbGFjZSgvJmd0Oy9nLCBcIj5cIikpKTtcbiAgICAgIH0sXG4gICAgICB0ZXh0U2V0dGVyOiBmdW5jdGlvbiAoYikge1xuICAgICAgICBiICE9PSB0aGlzLnRleHRTdHIgJiYgKGRlbGV0ZSB0aGlzLmJCb3gsIGRlbGV0ZSB0aGlzLnRleHRQeExlbmd0aCwgdGhpcy50ZXh0U3RyID0gYiwgdGhpcy5hZGRlZCAmJiB0aGlzLnJlbmRlcmVyLmJ1aWxkVGV4dCh0aGlzKSk7XG4gICAgICB9LFxuICAgICAgc2V0VGV4dFBhdGg6IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIHZhciBmID0gdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgYyA9IHtcbiAgICAgICAgICB0ZXh0QW5jaG9yOiBcInRleHQtYW5jaG9yXCJcbiAgICAgICAgfSxcbiAgICAgICAgICAgIG0gPSAhMSxcbiAgICAgICAgICAgIHAgPSB0aGlzLnRleHRQYXRoV3JhcHBlcixcbiAgICAgICAgICAgIGUgPSAhcDtcbiAgICAgICAgYSA9IGsoITAsIHtcbiAgICAgICAgICBlbmFibGVkOiAhMCxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBkeTogLTUsXG4gICAgICAgICAgICBzdGFydE9mZnNldDogXCI1MCVcIixcbiAgICAgICAgICAgIHRleHRBbmNob3I6IFwibWlkZGxlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGEpO1xuICAgICAgICB2YXIgeCA9IGEuYXR0cmlidXRlcztcblxuICAgICAgICBpZiAoYiAmJiBhICYmIGEuZW5hYmxlZCkge1xuICAgICAgICAgIHAgJiYgbnVsbCA9PT0gcC5lbGVtZW50LnBhcmVudE5vZGUgPyAoZSA9ICEwLCBwID0gcC5kZXN0cm95KCkpIDogcCAmJiB0aGlzLnJlbW92ZVRleHRPdXRsaW5lLmNhbGwocC5wYXJlbnRHcm91cCwgW10uc2xpY2UuY2FsbChmLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidHNwYW5cIikpKTtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnBhZGRpbmcgJiYgKHguZHggPSAtdGhpcy5vcHRpb25zLnBhZGRpbmcpO1xuICAgICAgICAgIHAgfHwgKHRoaXMudGV4dFBhdGhXcmFwcGVyID0gcCA9IHRoaXMucmVuZGVyZXIuY3JlYXRlRWxlbWVudChcInRleHRQYXRoXCIpLCBtID0gITApO1xuICAgICAgICAgIHZhciBsID0gcC5lbGVtZW50O1xuICAgICAgICAgIChhID0gYi5lbGVtZW50LmdldEF0dHJpYnV0ZShcImlkXCIpKSB8fCBiLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaWRcIiwgYSA9IHcoKSk7XG4gICAgICAgICAgaWYgKGUpIGZvciAoYiA9IGYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0c3BhblwiKTsgYi5sZW5ndGg7KSBiWzBdLnNldEF0dHJpYnV0ZShcInlcIiwgMCksIFAoeC5keCkgJiYgYlswXS5zZXRBdHRyaWJ1dGUoXCJ4XCIsIC14LmR4KSwgbC5hcHBlbmRDaGlsZChiWzBdKTtcbiAgICAgICAgICBtICYmIHAuYWRkKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMudGV4dCA/IHRoaXMudGV4dC5lbGVtZW50IDogZlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGwuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsIFwiaHJlZlwiLCB0aGlzLnJlbmRlcmVyLnVybCArIFwiI1wiICsgYSk7XG4gICAgICAgICAgeSh4LmR5KSAmJiAobC5wYXJlbnROb2RlLnNldEF0dHJpYnV0ZShcImR5XCIsIHguZHkpLCBkZWxldGUgeC5keSk7XG4gICAgICAgICAgeSh4LmR4KSAmJiAobC5wYXJlbnROb2RlLnNldEF0dHJpYnV0ZShcImR4XCIsIHguZHgpLCBkZWxldGUgeC5keCk7XG4gICAgICAgICAgbih4LCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgICAgbC5zZXRBdHRyaWJ1dGUoY1thXSB8fCBhLCBiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmLnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICAgICAgICB0aGlzLnJlbW92ZVRleHRPdXRsaW5lLmNhbGwocCwgW10uc2xpY2UuY2FsbChmLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidHNwYW5cIikpKTtcbiAgICAgICAgICB0aGlzLnRleHQgJiYgIXRoaXMucmVuZGVyZXIuc3R5bGVkTW9kZSAmJiB0aGlzLmF0dHIoe1xuICAgICAgICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5hcHBseVRleHRPdXRsaW5lID0gdGhpcy51cGRhdGVUcmFuc2Zvcm0gPSBDO1xuICAgICAgICB9IGVsc2UgcCAmJiAoZGVsZXRlIHRoaXMudXBkYXRlVHJhbnNmb3JtLCBkZWxldGUgdGhpcy5hcHBseVRleHRPdXRsaW5lLCB0aGlzLmRlc3Ryb3lUZXh0UGF0aChmLCBiKSwgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKSwgdGhpcy5vcHRpb25zLnJvdGF0aW9uICYmIHRoaXMuYXBwbHlUZXh0T3V0bGluZSh0aGlzLm9wdGlvbnMuc3R5bGUudGV4dE91dGxpbmUpKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBkZXN0cm95VGV4dFBhdGg6IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIHZhciBmID0gYi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRleHRcIilbMF07XG5cbiAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICBpZiAoZi5yZW1vdmVBdHRyaWJ1dGUoXCJkeFwiKSwgZi5yZW1vdmVBdHRyaWJ1dGUoXCJkeVwiKSwgYS5lbGVtZW50LnNldEF0dHJpYnV0ZShcImlkXCIsIFwiXCIpLCBmLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGV4dFBhdGhcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGIgPSB0aGlzLnRleHRQYXRoV3JhcHBlci5lbGVtZW50LmNoaWxkTm9kZXM7IGIubGVuZ3RoOykgZi5hcHBlbmRDaGlsZChiWzBdKTtcblxuICAgICAgICAgICAgZi5yZW1vdmVDaGlsZCh0aGlzLnRleHRQYXRoV3JhcHBlci5lbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYi5nZXRBdHRyaWJ1dGUoXCJkeFwiKSB8fCBiLmdldEF0dHJpYnV0ZShcImR5XCIpKSBiLnJlbW92ZUF0dHJpYnV0ZShcImR4XCIpLCBiLnJlbW92ZUF0dHJpYnV0ZShcImR5XCIpO1xuXG4gICAgICAgIHRoaXMudGV4dFBhdGhXcmFwcGVyID0gdGhpcy50ZXh0UGF0aFdyYXBwZXIuZGVzdHJveSgpO1xuICAgICAgfSxcbiAgICAgIGZpbGxTZXR0ZXI6IGZ1bmN0aW9uIChiLCBhLCBmKSB7XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBiID8gZi5zZXRBdHRyaWJ1dGUoYSwgYikgOiBiICYmIHRoaXMuY29tcGxleENvbG9yKGIsIGEsIGYpO1xuICAgICAgfSxcbiAgICAgIHZpc2liaWxpdHlTZXR0ZXI6IGZ1bmN0aW9uIChiLCBhLCBmKSB7XG4gICAgICAgIFwiaW5oZXJpdFwiID09PSBiID8gZi5yZW1vdmVBdHRyaWJ1dGUoYSkgOiB0aGlzW2FdICE9PSBiICYmIGYuc2V0QXR0cmlidXRlKGEsIGIpO1xuICAgICAgICB0aGlzW2FdID0gYjtcbiAgICAgIH0sXG4gICAgICB6SW5kZXhTZXR0ZXI6IGZ1bmN0aW9uIChiLCBmKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5yZW5kZXJlcixcbiAgICAgICAgICAgIG0gPSB0aGlzLnBhcmVudEdyb3VwLFxuICAgICAgICAgICAgcCA9IChtIHx8IGMpLmVsZW1lbnQgfHwgYy5ib3gsXG4gICAgICAgICAgICBlID0gdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgeCA9ICExO1xuICAgICAgICBjID0gcCA9PT0gYy5ib3g7XG4gICAgICAgIHZhciBDID0gdGhpcy5hZGRlZDtcbiAgICAgICAgdmFyIGw7XG4gICAgICAgIHkoYikgPyAoZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXotaW5kZXhcIiwgYiksIGIgPSArYiwgdGhpc1tmXSA9PT0gYiAmJiAoQyA9ICExKSkgOiB5KHRoaXNbZl0pICYmIGUucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS16LWluZGV4XCIpO1xuICAgICAgICB0aGlzW2ZdID0gYjtcblxuICAgICAgICBpZiAoQykge1xuICAgICAgICAgIChiID0gdGhpcy56SW5kZXgpICYmIG0gJiYgKG0uaGFuZGxlWiA9ICEwKTtcbiAgICAgICAgICBmID0gcC5jaGlsZE5vZGVzO1xuXG4gICAgICAgICAgZm9yIChsID0gZi5sZW5ndGggLSAxOyAwIDw9IGwgJiYgIXg7IGwtLSkge1xuICAgICAgICAgICAgbSA9IGZbbF07XG4gICAgICAgICAgICBDID0gbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXotaW5kZXhcIik7XG4gICAgICAgICAgICB2YXIgayA9ICF5KEMpO1xuICAgICAgICAgICAgaWYgKG0gIT09IGUpIGlmICgwID4gYiAmJiBrICYmICFjICYmICFsKSBwLmluc2VydEJlZm9yZShlLCBmW2xdKSwgeCA9ICEwO2Vsc2UgaWYgKGEoQykgPD0gYiB8fCBrICYmICgheShiKSB8fCAwIDw9IGIpKSBwLmluc2VydEJlZm9yZShlLCBmW2wgKyAxXSB8fCBudWxsKSwgeCA9ICEwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHggfHwgKHAuaW5zZXJ0QmVmb3JlKGUsIGZbYyA/IDMgOiAwXSB8fCBudWxsKSwgeCA9ICEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfSxcbiAgICAgIF9kZWZhdWx0U2V0dGVyOiBmdW5jdGlvbiAoYiwgYSwgZikge1xuICAgICAgICBmLnNldEF0dHJpYnV0ZShhLCBiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBVLnByb3RvdHlwZS55R2V0dGVyID0gVS5wcm90b3R5cGUueEdldHRlcjtcblxuICAgIFUucHJvdG90eXBlLnRyYW5zbGF0ZVhTZXR0ZXIgPSBVLnByb3RvdHlwZS50cmFuc2xhdGVZU2V0dGVyID0gVS5wcm90b3R5cGUucm90YXRpb25TZXR0ZXIgPSBVLnByb3RvdHlwZS52ZXJ0aWNhbEFsaWduU2V0dGVyID0gVS5wcm90b3R5cGUucm90YXRpb25PcmlnaW5YU2V0dGVyID0gVS5wcm90b3R5cGUucm90YXRpb25PcmlnaW5ZU2V0dGVyID0gVS5wcm90b3R5cGUuc2NhbGVYU2V0dGVyID0gVS5wcm90b3R5cGUuc2NhbGVZU2V0dGVyID0gVS5wcm90b3R5cGUubWF0cml4U2V0dGVyID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgIHRoaXNbYV0gPSBiO1xuICAgICAgdGhpcy5kb1RyYW5zZm9ybSA9ICEwO1xuICAgIH07XG5cbiAgICBVLnByb3RvdHlwZVtcInN0cm9rZS13aWR0aFNldHRlclwiXSA9IFUucHJvdG90eXBlLnN0cm9rZVNldHRlciA9IGZ1bmN0aW9uIChiLCBhLCBmKSB7XG4gICAgICB0aGlzW2FdID0gYjtcbiAgICAgIHRoaXMuc3Ryb2tlICYmIHRoaXNbXCJzdHJva2Utd2lkdGhcIl0gPyAoVS5wcm90b3R5cGUuZmlsbFNldHRlci5jYWxsKHRoaXMsIHRoaXMuc3Ryb2tlLCBcInN0cm9rZVwiLCBmKSwgZi5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgdGhpc1tcInN0cm9rZS13aWR0aFwiXSksIHRoaXMuaGFzU3Ryb2tlID0gITApIDogXCJzdHJva2Utd2lkdGhcIiA9PT0gYSAmJiAwID09PSBiICYmIHRoaXMuaGFzU3Ryb2tlID8gKGYucmVtb3ZlQXR0cmlidXRlKFwic3Ryb2tlXCIpLCB0aGlzLmhhc1N0cm9rZSA9ICExKSA6IHRoaXMucmVuZGVyZXIuc3R5bGVkTW9kZSAmJiB0aGlzW1wic3Ryb2tlLXdpZHRoXCJdICYmIChmLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCB0aGlzW1wic3Ryb2tlLXdpZHRoXCJdKSwgdGhpcy5oYXNTdHJva2UgPSAhMCk7XG4gICAgfTtcblxuICAgIGcgPSBkLlNWR1JlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGgoZy5wcm90b3R5cGUsIHtcbiAgICAgIEVsZW1lbnQ6IFUsXG4gICAgICBTVkdfTlM6IFIsXG4gICAgICBpbml0OiBmdW5jdGlvbiAoYSwgZiwgYywgcCwgZSwgeCwgQykge1xuICAgICAgICB2YXIgbSA9IHRoaXMuY3JlYXRlRWxlbWVudChcInN2Z1wiKS5hdHRyKHtcbiAgICAgICAgICB2ZXJzaW9uOiBcIjEuMVwiLFxuICAgICAgICAgIFwiY2xhc3NcIjogXCJoaWdoY2hhcnRzLXJvb3RcIlxuICAgICAgICB9KTtcbiAgICAgICAgQyB8fCBtLmNzcyh0aGlzLmdldFN0eWxlKHApKTtcbiAgICAgICAgcCA9IG0uZWxlbWVudDtcbiAgICAgICAgYS5hcHBlbmRDaGlsZChwKTtcbiAgICAgICAgQShhLCBcImRpclwiLCBcImx0clwiKTtcbiAgICAgICAgLTEgPT09IGEuaW5uZXJIVE1MLmluZGV4T2YoXCJ4bWxuc1wiKSAmJiBBKHAsIFwieG1sbnNcIiwgdGhpcy5TVkdfTlMpO1xuICAgICAgICB0aGlzLmlzU1ZHID0gITA7XG4gICAgICAgIHRoaXMuYm94ID0gcDtcbiAgICAgICAgdGhpcy5ib3hXcmFwcGVyID0gbTtcbiAgICAgICAgdGhpcy5hbGlnbmVkT2JqZWN0cyA9IFtdO1xuICAgICAgICB0aGlzLnVybCA9IChLIHx8IGIpICYmIFEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJiYXNlXCIpLmxlbmd0aCA/IFgubG9jYXRpb24uaHJlZi5zcGxpdChcIiNcIilbMF0ucmVwbGFjZSgvPFtePl0qPi9nLCBcIlwiKS5yZXBsYWNlKC8oW1xcKCdcXCldKS9nLCBcIlxcXFwkMVwiKS5yZXBsYWNlKC8gL2csIFwiJTIwXCIpIDogXCJcIjtcbiAgICAgICAgdGhpcy5jcmVhdGVFbGVtZW50KFwiZGVzY1wiKS5hZGQoKS5lbGVtZW50LmFwcGVuZENoaWxkKFEuY3JlYXRlVGV4dE5vZGUoXCJDcmVhdGVkIHdpdGggSGlnaGNoYXJ0cyA4LjAuNFwiKSk7XG4gICAgICAgIHRoaXMuZGVmcyA9IHRoaXMuY3JlYXRlRWxlbWVudChcImRlZnNcIikuYWRkKCk7XG4gICAgICAgIHRoaXMuYWxsb3dIVE1MID0geDtcbiAgICAgICAgdGhpcy5mb3JFeHBvcnQgPSBlO1xuICAgICAgICB0aGlzLnN0eWxlZE1vZGUgPSBDO1xuICAgICAgICB0aGlzLmdyYWRpZW50cyA9IHt9O1xuICAgICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgICAgIHRoaXMuY2FjaGVLZXlzID0gW107XG4gICAgICAgIHRoaXMuaW1nQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnNldFNpemUoZiwgYywgITEpO1xuICAgICAgICB2YXIgbDtcbiAgICAgICAgSyAmJiBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiAoZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBKKGEsIHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsID0gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBKKGEsIHtcbiAgICAgICAgICAgIGxlZnQ6IE1hdGguY2VpbChsLmxlZnQpIC0gbC5sZWZ0ICsgXCJweFwiLFxuICAgICAgICAgICAgdG9wOiBNYXRoLmNlaWwobC50b3ApIC0gbC50b3AgKyBcInB4XCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZigpLCB0aGlzLnVuU3ViUGl4ZWxGaXggPSBJKFgsIFwicmVzaXplXCIsIGYpKTtcbiAgICAgIH0sXG4gICAgICBkZWZpbml0aW9uOiBmdW5jdGlvbiAoYikge1xuICAgICAgICBmdW5jdGlvbiBhKGIsIGMpIHtcbiAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICB2KGIpLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIHZhciBtID0gZi5jcmVhdGVFbGVtZW50KGIudGFnTmFtZSksXG4gICAgICAgICAgICAgICAgZSA9IHt9O1xuICAgICAgICAgICAgbihiLCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgICAgICBcInRhZ05hbWVcIiAhPT0gYSAmJiBcImNoaWxkcmVuXCIgIT09IGEgJiYgXCJ0ZXh0Q29udGVudFwiICE9PSBhICYmIChlW2FdID0gYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG0uYXR0cihlKTtcbiAgICAgICAgICAgIG0uYWRkKGMgfHwgZi5kZWZzKTtcbiAgICAgICAgICAgIGIudGV4dENvbnRlbnQgJiYgbS5lbGVtZW50LmFwcGVuZENoaWxkKFEuY3JlYXRlVGV4dE5vZGUoYi50ZXh0Q29udGVudCkpO1xuICAgICAgICAgICAgYShiLmNoaWxkcmVuIHx8IFtdLCBtKTtcbiAgICAgICAgICAgIHAgPSBtO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gYShiKTtcbiAgICAgIH0sXG4gICAgICBnZXRTdHlsZTogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUgPSBoKHtcbiAgICAgICAgICBmb250RmFtaWx5OiAnXCJMdWNpZGEgR3JhbmRlXCIsIFwiTHVjaWRhIFNhbnMgVW5pY29kZVwiLCBBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgICBmb250U2l6ZTogXCIxMnB4XCJcbiAgICAgICAgfSwgYik7XG4gICAgICB9LFxuICAgICAgc2V0U3R5bGU6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHRoaXMuYm94V3JhcHBlci5jc3ModGhpcy5nZXRTdHlsZShiKSk7XG4gICAgICB9LFxuICAgICAgaXNIaWRkZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmJveFdyYXBwZXIuZ2V0QkJveCgpLndpZHRoO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmRlZnM7XG4gICAgICAgIHRoaXMuYm94ID0gbnVsbDtcbiAgICAgICAgdGhpcy5ib3hXcmFwcGVyID0gdGhpcy5ib3hXcmFwcGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdCh0aGlzLmdyYWRpZW50cyB8fCB7fSk7XG4gICAgICAgIHRoaXMuZ3JhZGllbnRzID0gbnVsbDtcbiAgICAgICAgYiAmJiAodGhpcy5kZWZzID0gYi5kZXN0cm95KCkpO1xuICAgICAgICB0aGlzLnVuU3ViUGl4ZWxGaXggJiYgdGhpcy51blN1YlBpeGVsRml4KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmFsaWduZWRPYmplY3RzID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IG5ldyB0aGlzLkVsZW1lbnQoKTtcbiAgICAgICAgYS5pbml0KHRoaXMsIGIpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sXG4gICAgICBkcmF3OiBDLFxuICAgICAgZ2V0UmFkaWFsQXR0cjogZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjeDogYlswXSAtIGJbMl0gLyAyICsgYS5jeCAqIGJbMl0sXG4gICAgICAgICAgY3k6IGJbMV0gLSBiWzJdIC8gMiArIGEuY3kgKiBiWzJdLFxuICAgICAgICAgIHI6IGEuciAqIGJbMl1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB0cnVuY2F0ZTogZnVuY3Rpb24gKGIsIGEsIGYsIGMsIHAsIGUsIHgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLFxuICAgICAgICAgICAgQyA9IGIucm90YXRpb24sXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgayA9IGMgPyAxIDogMCxcbiAgICAgICAgICAgIEYgPSAoZiB8fCBjKS5sZW5ndGgsXG4gICAgICAgICAgICBuID0gRixcbiAgICAgICAgICAgIHYgPSBbXSxcbiAgICAgICAgICAgIHcgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGEuZmlyc3RDaGlsZCAmJiBhLnJlbW92ZUNoaWxkKGEuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgYiAmJiBhLmFwcGVuZENoaWxkKFEuY3JlYXRlVGV4dE5vZGUoYikpO1xuICAgICAgICB9LFxuICAgICAgICAgICAgeiA9IGZ1bmN0aW9uIChlLCBsKSB7XG4gICAgICAgICAgbCA9IGwgfHwgZTtcbiAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHZbbF0pIGlmIChhLmdldFN1YlN0cmluZ0xlbmd0aCkgdHJ5IHtcbiAgICAgICAgICAgIHZbbF0gPSBwICsgYS5nZXRTdWJTdHJpbmdMZW5ndGgoMCwgYyA/IGwgKyAxIDogbCk7XG4gICAgICAgICAgfSBjYXRjaCAobGEpIHtcbiAgICAgICAgICAgIFwiXCI7XG4gICAgICAgICAgfSBlbHNlIG0uZ2V0U3BhbldpZHRoICYmICh3KHgoZiB8fCBjLCBlKSksIHZbbF0gPSBwICsgbS5nZXRTcGFuV2lkdGgoYiwgYSkpO1xuICAgICAgICAgIHJldHVybiB2W2xdO1xuICAgICAgICB9LFxuICAgICAgICAgICAgTztcblxuICAgICAgICBiLnJvdGF0aW9uID0gMDtcbiAgICAgICAgdmFyIFQgPSB6KGEudGV4dENvbnRlbnQubGVuZ3RoKTtcblxuICAgICAgICBpZiAoTyA9IHAgKyBUID4gZSkge1xuICAgICAgICAgIGZvciAoOyBrIDw9IEY7KSBuID0gTWF0aC5jZWlsKChrICsgRikgLyAyKSwgYyAmJiAobCA9IHgoYywgbikpLCBUID0geihuLCBsICYmIGwubGVuZ3RoIC0gMSksIGsgPT09IEYgPyBrID0gRiArIDEgOiBUID4gZSA/IEYgPSBuIC0gMSA6IGsgPSBuO1xuXG4gICAgICAgICAgMCA9PT0gRiA/IHcoXCJcIikgOiBmICYmIEYgPT09IGYubGVuZ3RoIC0gMSB8fCB3KGwgfHwgeChmIHx8IGMsIG4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMgJiYgYy5zcGxpY2UoMCwgbik7XG4gICAgICAgIGIuYWN0dWFsV2lkdGggPSBUO1xuICAgICAgICBiLnJvdGF0aW9uID0gQztcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9LFxuICAgICAgZXNjYXBlczoge1xuICAgICAgICBcIiZcIjogXCImYW1wO1wiLFxuICAgICAgICBcIjxcIjogXCImbHQ7XCIsXG4gICAgICAgIFwiPlwiOiBcIiZndDtcIixcbiAgICAgICAgXCInXCI6IFwiJiMzOTtcIixcbiAgICAgICAgJ1wiJzogXCImcXVvdDtcIlxuICAgICAgfSxcbiAgICAgIGJ1aWxkVGV4dDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGMgPSBiLmVsZW1lbnQsXG4gICAgICAgICAgICBwID0gdGhpcyxcbiAgICAgICAgICAgIGUgPSBwLmZvckV4cG9ydCxcbiAgICAgICAgICAgIG0gPSBmKGIudGV4dFN0ciwgXCJcIikudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGwgPSAtMSAhPT0gbS5pbmRleE9mKFwiPFwiKSxcbiAgICAgICAgICAgIEMgPSBjLmNoaWxkTm9kZXMsXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgdiA9IEEoYywgXCJ4XCIpLFxuICAgICAgICAgICAgdyA9IGIuc3R5bGVzLFxuICAgICAgICAgICAgeiA9IGIudGV4dFdpZHRoLFxuICAgICAgICAgICAgTyA9IHcgJiYgdy5saW5lSGVpZ2h0LFxuICAgICAgICAgICAgcSA9IHcgJiYgdy50ZXh0T3V0bGluZSxcbiAgICAgICAgICAgIEIgPSB3ICYmIFwiZWxsaXBzaXNcIiA9PT0gdy50ZXh0T3ZlcmZsb3csXG4gICAgICAgICAgICBkID0gdyAmJiBcIm5vd3JhcFwiID09PSB3LndoaXRlU3BhY2UsXG4gICAgICAgICAgICBOID0gdyAmJiB3LmZvbnRTaXplLFxuICAgICAgICAgICAgWCxcbiAgICAgICAgICAgIGggPSBDLmxlbmd0aDtcbiAgICAgICAgdyA9IHogJiYgIWIuYWRkZWQgJiYgdGhpcy5ib3g7XG5cbiAgICAgICAgdmFyIEwgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHZhciBmO1xuICAgICAgICAgIHAuc3R5bGVkTW9kZSB8fCAoZiA9IC8ocHh8ZW0pJC8udGVzdChiICYmIGIuc3R5bGUuZm9udFNpemUpID8gYi5zdHlsZS5mb250U2l6ZSA6IE4gfHwgcC5zdHlsZS5mb250U2l6ZSB8fCAxMik7XG4gICAgICAgICAgcmV0dXJuIE8gPyBhKE8pIDogcC5mb250TWV0cmljcyhmLCBiLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpID8gYiA6IGMpLmg7XG4gICAgICAgIH0sXG4gICAgICAgICAgICB0ID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBuKHAuZXNjYXBlcywgZnVuY3Rpb24gKGYsIGMpIHtcbiAgICAgICAgICAgIGEgJiYgLTEgIT09IGEuaW5kZXhPZihmKSB8fCAoYiA9IGIudG9TdHJpbmcoKS5yZXBsYWNlKG5ldyBSZWdFeHAoZiwgXCJnXCIpLCBjKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH0sXG4gICAgICAgICAgICBVID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICB2YXIgZiA9IGIuaW5kZXhPZihcIjxcIik7XG4gICAgICAgICAgYiA9IGIuc3Vic3RyaW5nKGYsIGIuaW5kZXhPZihcIj5cIikgLSBmKTtcbiAgICAgICAgICBmID0gYi5pbmRleE9mKGEgKyBcIj1cIik7XG4gICAgICAgICAgaWYgKC0xICE9PSBmICYmIChmID0gZiArIGEubGVuZ3RoICsgMSwgYSA9IGIuY2hhckF0KGYpLCAnXCInID09PSBhIHx8IFwiJ1wiID09PSBhKSkgcmV0dXJuIGIgPSBiLnN1YnN0cmluZyhmICsgMSksIGIuc3Vic3RyaW5nKDAsIGIuaW5kZXhPZihhKSk7XG4gICAgICAgIH0sXG4gICAgICAgICAgICBQID0gLzxici4qPz4vZztcblxuICAgICAgICB2YXIgZyA9IFttLCBCLCBkLCBPLCBxLCBOLCB6XS5qb2luKCk7XG5cbiAgICAgICAgaWYgKGcgIT09IGIudGV4dENhY2hlKSB7XG4gICAgICAgICAgZm9yIChiLnRleHRDYWNoZSA9IGc7IGgtLTspIGMucmVtb3ZlQ2hpbGQoQ1toXSk7XG5cbiAgICAgICAgICBsIHx8IHEgfHwgQiB8fCB6IHx8IC0xICE9PSBtLmluZGV4T2YoXCIgXCIpICYmICghZCB8fCBQLnRlc3QobSkpID8gKHcgJiYgdy5hcHBlbmRDaGlsZChjKSwgbCA/IChtID0gcC5zdHlsZWRNb2RlID8gbS5yZXBsYWNlKC88KGJ8c3Ryb25nKT4vZywgJzxzcGFuIGNsYXNzPVwiaGlnaGNoYXJ0cy1zdHJvbmdcIj4nKS5yZXBsYWNlKC88KGl8ZW0pPi9nLCAnPHNwYW4gY2xhc3M9XCJoaWdoY2hhcnRzLWVtcGhhc2l6ZWRcIj4nKSA6IG0ucmVwbGFjZSgvPChifHN0cm9uZyk+L2csICc8c3BhbiBzdHlsZT1cImZvbnQtd2VpZ2h0OmJvbGRcIj4nKS5yZXBsYWNlKC88KGl8ZW0pPi9nLCAnPHNwYW4gc3R5bGU9XCJmb250LXN0eWxlOml0YWxpY1wiPicpLCBtID0gbS5yZXBsYWNlKC88YS9nLCBcIjxzcGFuXCIpLnJlcGxhY2UoLzxcXC8oYnxzdHJvbmd8aXxlbXxhKT4vZywgXCI8L3NwYW4+XCIpLnNwbGl0KFApKSA6IG0gPSBbbV0sIG0gPSBtLmZpbHRlcihmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgIT09IGI7XG4gICAgICAgICAgfSksIG0uZm9yRWFjaChmdW5jdGlvbiAoYSwgZikge1xuICAgICAgICAgICAgdmFyIG0gPSAwLFxuICAgICAgICAgICAgICAgIGwgPSAwO1xuICAgICAgICAgICAgYSA9IGEucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIikucmVwbGFjZSgvPHNwYW4vZywgXCJ8fHw8c3BhblwiKS5yZXBsYWNlKC88XFwvc3Bhbj4vZywgXCI8L3NwYW4+fHx8XCIpO1xuICAgICAgICAgICAgdmFyIEMgPSBhLnNwbGl0KFwifHx8XCIpO1xuICAgICAgICAgICAgQy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgIGlmIChcIlwiICE9PSBhIHx8IDEgPT09IEMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgRiA9IFEuY3JlYXRlRWxlbWVudE5TKHAuU1ZHX05TLCBcInRzcGFuXCIpLFxuICAgICAgICAgICAgICAgICAgICB3LFxuICAgICAgICAgICAgICAgICAgICBPO1xuICAgICAgICAgICAgICAgICh3ID0gVShhLCBcImNsYXNzXCIpKSAmJiBBKEYsIFwiY2xhc3NcIiwgdyk7XG4gICAgICAgICAgICAgICAgaWYgKHcgPSBVKGEsIFwic3R5bGVcIikpIHcgPSB3LnJlcGxhY2UoLyg7fCB8Xiljb2xvcihbIDpdKS8sIFwiJDFmaWxsJDJcIiksIEEoRiwgXCJzdHlsZVwiLCB3KTtcbiAgICAgICAgICAgICAgICAoTyA9IFUoYSwgXCJocmVmXCIpKSAmJiAhZSAmJiAoQShGLCBcIm9uY2xpY2tcIiwgJ2xvY2F0aW9uLmhyZWY9XCInICsgTyArICdcIicpLCBBKEYsIFwiY2xhc3NcIiwgXCJoaWdoY2hhcnRzLWFuY2hvclwiKSwgcC5zdHlsZWRNb2RlIHx8IEooRiwge1xuICAgICAgICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBhID0gdChhLnJlcGxhY2UoLzxbYS16QS1aXFwvXSgufFxcbikqPz4vZywgXCJcIikgfHwgXCIgXCIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKFwiIFwiICE9PSBhKSB7XG4gICAgICAgICAgICAgICAgICBGLmFwcGVuZENoaWxkKFEuY3JlYXRlVGV4dE5vZGUoYSkpO1xuICAgICAgICAgICAgICAgICAgbSA/IG4uZHggPSAwIDogZiAmJiBudWxsICE9PSB2ICYmIChuLnggPSB2KTtcbiAgICAgICAgICAgICAgICAgIEEoRiwgbik7XG4gICAgICAgICAgICAgICAgICBjLmFwcGVuZENoaWxkKEYpO1xuICAgICAgICAgICAgICAgICAgIW0gJiYgWCAmJiAoIXggJiYgZSAmJiBKKEYsIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgICAgICAgICAgICAgICB9KSwgQShGLCBcImR5XCIsIEwoRikpKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHopIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBhLnJlcGxhY2UoLyhbXlxcXl0pLS9nLCBcIiQxLSBcIikuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICBuID0gIWQgJiYgKDEgPCBDLmxlbmd0aCB8fCBmIHx8IDEgPCBxLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIE8gPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgVCA9IEwoRik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChCKSBrID0gcC50cnVuY2F0ZShiLCBGLCBhLCB2b2lkIDAsIDAsIE1hdGgubWF4KDAsIHogLSBwYXJzZUludChOIHx8IDEyLCAxMCkpLCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiLnN1YnN0cmluZygwLCBhKSArIFwiXFx1MjAyNlwiO1xuICAgICAgICAgICAgICAgICAgICB9KTtlbHNlIGlmIChuKSBmb3IgKDsgcS5sZW5ndGg7KSBxLmxlbmd0aCAmJiAhZCAmJiAwIDwgTyAmJiAoRiA9IFEuY3JlYXRlRWxlbWVudE5TKFIsIFwidHNwYW5cIiksIEEoRiwge1xuICAgICAgICAgICAgICAgICAgICAgIGR5OiBULFxuICAgICAgICAgICAgICAgICAgICAgIHg6IHZcbiAgICAgICAgICAgICAgICAgICAgfSksIHcgJiYgQShGLCBcInN0eWxlXCIsIHcpLCBGLmFwcGVuZENoaWxkKFEuY3JlYXRlVGV4dE5vZGUocS5qb2luKFwiIFwiKS5yZXBsYWNlKC8tIC9nLCBcIi1cIikpKSwgYy5hcHBlbmRDaGlsZChGKSksIHAudHJ1bmNhdGUoYiwgRiwgbnVsbCwgcSwgMCA9PT0gTyA/IGwgOiAwLCB6LCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBxLnNsaWNlKDAsIGEpLmpvaW4oXCIgXCIpLnJlcGxhY2UoLy0gL2csIFwiLVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSksIGwgPSBiLmFjdHVhbFdpZHRoLCBPKys7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIG0rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgWCA9IFggfHwgYy5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICB9KSwgQiAmJiBrICYmIGIuYXR0cihcInRpdGxlXCIsIHQoYi50ZXh0U3RyLCBbXCImbHQ7XCIsIFwiJmd0O1wiXSkpLCB3ICYmIHcucmVtb3ZlQ2hpbGQoYyksIHEgJiYgYi5hcHBseVRleHRPdXRsaW5lICYmIGIuYXBwbHlUZXh0T3V0bGluZShxKSkgOiBjLmFwcGVuZENoaWxkKFEuY3JlYXRlVGV4dE5vZGUodChtKSkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0Q29udHJhc3Q6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIGIgPSB1KGIpLnJnYmE7XG4gICAgICAgIGJbMF0gKj0gMTtcbiAgICAgICAgYlsxXSAqPSAxLjI7XG4gICAgICAgIGJbMl0gKj0gLjU7XG4gICAgICAgIHJldHVybiA0NTkgPCBiWzBdICsgYlsxXSArIGJbMl0gPyBcIiMwMDAwMDBcIiA6IFwiI0ZGRkZGRlwiO1xuICAgICAgfSxcbiAgICAgIGJ1dHRvbjogZnVuY3Rpb24gKGIsIGEsIGYsIGMsIGUsIHgsIGwsIEMsIG4sIHcpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLmxhYmVsKGIsIGEsIGYsIG4sIG51bGwsIG51bGwsIHcsIG51bGwsIFwiYnV0dG9uXCIpLFxuICAgICAgICAgICAgRiA9IDAsXG4gICAgICAgICAgICB2ID0gdGhpcy5zdHlsZWRNb2RlO1xuICAgICAgICBtLmF0dHIoayh7XG4gICAgICAgICAgcGFkZGluZzogOCxcbiAgICAgICAgICByOiAyXG4gICAgICAgIH0sIGUpKTtcblxuICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICBlID0gayh7XG4gICAgICAgICAgICBmaWxsOiBcIiNmN2Y3ZjdcIixcbiAgICAgICAgICAgIHN0cm9rZTogXCIjY2NjY2NjXCIsXG4gICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiAxLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgY29sb3I6IFwiIzMzMzMzM1wiLFxuICAgICAgICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgICAgICAgICAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZSk7XG4gICAgICAgICAgdmFyIHogPSBlLnN0eWxlO1xuICAgICAgICAgIGRlbGV0ZSBlLnN0eWxlO1xuICAgICAgICAgIHggPSBrKGUsIHtcbiAgICAgICAgICAgIGZpbGw6IFwiI2U2ZTZlNlwiXG4gICAgICAgICAgfSwgeCk7XG4gICAgICAgICAgdmFyIE8gPSB4LnN0eWxlO1xuICAgICAgICAgIGRlbGV0ZSB4LnN0eWxlO1xuICAgICAgICAgIGwgPSBrKGUsIHtcbiAgICAgICAgICAgIGZpbGw6IFwiI2U2ZWJmNVwiLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgY29sb3I6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGwpO1xuICAgICAgICAgIHZhciBxID0gbC5zdHlsZTtcbiAgICAgICAgICBkZWxldGUgbC5zdHlsZTtcbiAgICAgICAgICBDID0gayhlLCB7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBjb2xvcjogXCIjY2NjY2NjXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBDKTtcbiAgICAgICAgICB2YXIgUiA9IEMuc3R5bGU7XG4gICAgICAgICAgZGVsZXRlIEMuc3R5bGU7XG4gICAgICAgIH1cblxuICAgICAgICBJKG0uZWxlbWVudCwgcCA/IFwibW91c2VvdmVyXCIgOiBcIm1vdXNlZW50ZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIDMgIT09IEYgJiYgbS5zZXRTdGF0ZSgxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIEkobS5lbGVtZW50LCBwID8gXCJtb3VzZW91dFwiIDogXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAzICE9PSBGICYmIG0uc2V0U3RhdGUoRik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG0uc2V0U3RhdGUgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIDEgIT09IGIgJiYgKG0uc3RhdGUgPSBGID0gYik7XG4gICAgICAgICAgbS5yZW1vdmVDbGFzcygvaGlnaGNoYXJ0cy1idXR0b24tKG5vcm1hbHxob3ZlcnxwcmVzc2VkfGRpc2FibGVkKS8pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1idXR0b24tXCIgKyBbXCJub3JtYWxcIiwgXCJob3ZlclwiLCBcInByZXNzZWRcIiwgXCJkaXNhYmxlZFwiXVtiIHx8IDBdKTtcbiAgICAgICAgICB2IHx8IG0uYXR0cihbZSwgeCwgbCwgQ11bYiB8fCAwXSkuY3NzKFt6LCBPLCBxLCBSXVtiIHx8IDBdKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2IHx8IG0uYXR0cihlKS5jc3MoaCh7XG4gICAgICAgICAgY3Vyc29yOiBcImRlZmF1bHRcIlxuICAgICAgICB9LCB6KSk7XG4gICAgICAgIHJldHVybiBtLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAzICE9PSBGICYmIGMuY2FsbChtLCBiKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgY3Jpc3BMaW5lOiBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICBiWzFdID09PSBiWzRdICYmIChiWzFdID0gYls0XSA9IE1hdGgucm91bmQoYlsxXSkgLSBhICUgMiAvIDIpO1xuICAgICAgICBiWzJdID09PSBiWzVdICYmIChiWzJdID0gYls1XSA9IE1hdGgucm91bmQoYlsyXSkgKyBhICUgMiAvIDIpO1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0sXG4gICAgICBwYXRoOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuc3R5bGVkTW9kZSA/IHt9IDoge1xuICAgICAgICAgIGZpbGw6IFwibm9uZVwiXG4gICAgICAgIH07XG4gICAgICAgIHEoYikgPyBhLmQgPSBiIDogZShiKSAmJiBoKGEsIGIpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFbGVtZW50KFwicGF0aFwiKS5hdHRyKGEpO1xuICAgICAgfSxcbiAgICAgIGNpcmNsZTogZnVuY3Rpb24gKGIsIGEsIGYpIHtcbiAgICAgICAgYiA9IGUoYikgPyBiIDogXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGIgPyB7fSA6IHtcbiAgICAgICAgICB4OiBiLFxuICAgICAgICAgIHk6IGEsXG4gICAgICAgICAgcjogZlxuICAgICAgICB9O1xuICAgICAgICBhID0gdGhpcy5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIpO1xuXG4gICAgICAgIGEueFNldHRlciA9IGEueVNldHRlciA9IGZ1bmN0aW9uIChiLCBhLCBmKSB7XG4gICAgICAgICAgZi5zZXRBdHRyaWJ1dGUoXCJjXCIgKyBhLCBiKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYS5hdHRyKGIpO1xuICAgICAgfSxcbiAgICAgIGFyYzogZnVuY3Rpb24gKGIsIGEsIGYsIGMsIHAsIHgpIHtcbiAgICAgICAgZShiKSA/IChjID0gYiwgYSA9IGMueSwgZiA9IGMuciwgYiA9IGMueCkgOiBjID0ge1xuICAgICAgICAgIGlubmVyUjogYyxcbiAgICAgICAgICBzdGFydDogcCxcbiAgICAgICAgICBlbmQ6IHhcbiAgICAgICAgfTtcbiAgICAgICAgYiA9IHRoaXMuc3ltYm9sKFwiYXJjXCIsIGIsIGEsIGYsIGYsIGMpO1xuICAgICAgICBiLnIgPSBmO1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0sXG4gICAgICByZWN0OiBmdW5jdGlvbiAoYiwgYSwgZiwgYywgcCwgeCkge1xuICAgICAgICBwID0gZShiKSA/IGIuciA6IHA7XG4gICAgICAgIHZhciBtID0gdGhpcy5jcmVhdGVFbGVtZW50KFwicmVjdFwiKTtcbiAgICAgICAgYiA9IGUoYikgPyBiIDogXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGIgPyB7fSA6IHtcbiAgICAgICAgICB4OiBiLFxuICAgICAgICAgIHk6IGEsXG4gICAgICAgICAgd2lkdGg6IE1hdGgubWF4KGYsIDApLFxuICAgICAgICAgIGhlaWdodDogTWF0aC5tYXgoYywgMClcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdHlsZWRNb2RlIHx8IChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgeCAmJiAoYi5zdHJva2VXaWR0aCA9IHgsIGIgPSBtLmNyaXNwKGIpKSwgYi5maWxsID0gXCJub25lXCIpO1xuICAgICAgICBwICYmIChiLnIgPSBwKTtcblxuICAgICAgICBtLnJTZXR0ZXIgPSBmdW5jdGlvbiAoYiwgYSwgZikge1xuICAgICAgICAgIG0uciA9IGI7XG4gICAgICAgICAgQShmLCB7XG4gICAgICAgICAgICByeDogYixcbiAgICAgICAgICAgIHJ5OiBiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgbS5yR2V0dGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBtLnI7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG0uYXR0cihiKTtcbiAgICAgIH0sXG4gICAgICBzZXRTaXplOiBmdW5jdGlvbiAoYiwgYSwgYykge1xuICAgICAgICB2YXIgcCA9IHRoaXMuYWxpZ25lZE9iamVjdHMsXG4gICAgICAgICAgICBlID0gcC5sZW5ndGg7XG4gICAgICAgIHRoaXMud2lkdGggPSBiO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGE7XG5cbiAgICAgICAgZm9yICh0aGlzLmJveFdyYXBwZXIuYW5pbWF0ZSh7XG4gICAgICAgICAgd2lkdGg6IGIsXG4gICAgICAgICAgaGVpZ2h0OiBhXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBzdGVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHIoe1xuICAgICAgICAgICAgICB2aWV3Qm94OiBcIjAgMCBcIiArIHRoaXMuYXR0cihcIndpZHRoXCIpICsgXCIgXCIgKyB0aGlzLmF0dHIoXCJoZWlnaHRcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IGYoYywgITApID8gdm9pZCAwIDogMFxuICAgICAgICB9KTsgZS0tOykgcFtlXS5hbGlnbigpO1xuICAgICAgfSxcbiAgICAgIGc6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jcmVhdGVFbGVtZW50KFwiZ1wiKTtcbiAgICAgICAgcmV0dXJuIGIgPyBhLmF0dHIoe1xuICAgICAgICAgIFwiY2xhc3NcIjogXCJoaWdoY2hhcnRzLVwiICsgYlxuICAgICAgICB9KSA6IGE7XG4gICAgICB9LFxuICAgICAgaW1hZ2U6IGZ1bmN0aW9uIChiLCBhLCBmLCBjLCBwLCBlKSB7XG4gICAgICAgIHZhciB4ID0ge1xuICAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IFwibm9uZVwiXG4gICAgICAgIH0sXG4gICAgICAgICAgICBtID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBiLnNldEF0dHJpYnV0ZU5TID8gYi5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwgXCJocmVmXCIsIGEpIDogYi5zZXRBdHRyaWJ1dGUoXCJoYy1zdmctaHJlZlwiLCBhKTtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIGwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIG0oQy5lbGVtZW50LCBiKTtcbiAgICAgICAgICBlLmNhbGwoQywgYSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgMSA8IGFyZ3VtZW50cy5sZW5ndGggJiYgaCh4LCB7XG4gICAgICAgICAgeDogYSxcbiAgICAgICAgICB5OiBmLFxuICAgICAgICAgIHdpZHRoOiBjLFxuICAgICAgICAgIGhlaWdodDogcFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIEMgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoXCJpbWFnZVwiKS5hdHRyKHgpO1xuICAgICAgICBlID8gKG0oQy5lbGVtZW50LCBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUFBQUNINUJBRUtBQUVBTEFBQUFBQUJBQUVBQUFJQ1RBRUFPdz09XCIpLCB4ID0gbmV3IFguSW1hZ2UoKSwgSSh4LCBcImxvYWRcIiwgbCksIHguc3JjID0gYiwgeC5jb21wbGV0ZSAmJiBsKHt9KSkgOiBtKEMuZWxlbWVudCwgYik7XG4gICAgICAgIHJldHVybiBDO1xuICAgICAgfSxcbiAgICAgIHN5bWJvbDogZnVuY3Rpb24gKGIsIGEsIGMsIHAsIGUsIHgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLFxuICAgICAgICAgICAgbCA9IC9edXJsXFwoKC4qPylcXCkkLyxcbiAgICAgICAgICAgIEMgPSBsLnRlc3QoYiksXG4gICAgICAgICAgICBrID0gIUMgJiYgKHRoaXMuc3ltYm9sc1tiXSA/IGIgOiBcImNpcmNsZVwiKSxcbiAgICAgICAgICAgIG4gPSBrICYmIHRoaXMuc3ltYm9sc1trXSxcbiAgICAgICAgICAgIEYgPSB5KGEpICYmIG4gJiYgbi5jYWxsKHRoaXMuc3ltYm9scywgTWF0aC5yb3VuZChhKSwgTWF0aC5yb3VuZChjKSwgcCwgZSwgeCk7XG5cbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICB2YXIgdyA9IHRoaXMucGF0aChGKTtcbiAgICAgICAgICBtLnN0eWxlZE1vZGUgfHwgdy5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICAgICAgaCh3LCB7XG4gICAgICAgICAgICBzeW1ib2xOYW1lOiBrLFxuICAgICAgICAgICAgeDogYSxcbiAgICAgICAgICAgIHk6IGMsXG4gICAgICAgICAgICB3aWR0aDogcCxcbiAgICAgICAgICAgIGhlaWdodDogZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHggJiYgaCh3LCB4KTtcbiAgICAgICAgfSBlbHNlIGlmIChDKSB7XG4gICAgICAgICAgdmFyIHYgPSBiLm1hdGNoKGwpWzFdO1xuICAgICAgICAgIHcgPSB0aGlzLmltYWdlKHYpO1xuICAgICAgICAgIHcuaW1nd2lkdGggPSBmKE9bdl0gJiYgT1t2XS53aWR0aCwgeCAmJiB4LndpZHRoKTtcbiAgICAgICAgICB3LmltZ2hlaWdodCA9IGYoT1t2XSAmJiBPW3ZdLmhlaWdodCwgeCAmJiB4LmhlaWdodCk7XG5cbiAgICAgICAgICB2YXIgeiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHcuYXR0cih7XG4gICAgICAgICAgICAgIHdpZHRoOiB3LndpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IHcuaGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgW1wid2lkdGhcIiwgXCJoZWlnaHRcIl0uZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgd1tiICsgXCJTZXR0ZXJcIl0gPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgICAgICB2YXIgZiA9IHt9LFxuICAgICAgICAgICAgICAgICAgYyA9IHRoaXNbXCJpbWdcIiArIGFdLFxuICAgICAgICAgICAgICAgICAgcCA9IFwid2lkdGhcIiA9PT0gYSA/IFwidHJhbnNsYXRlWFwiIDogXCJ0cmFuc2xhdGVZXCI7XG4gICAgICAgICAgICAgIHRoaXNbYV0gPSBiO1xuICAgICAgICAgICAgICB5KGMpICYmICh4ICYmIFwid2l0aGluXCIgPT09IHguYmFja2dyb3VuZFNpemUgJiYgdGhpcy53aWR0aCAmJiB0aGlzLmhlaWdodCAmJiAoYyA9IE1hdGgucm91bmQoYyAqIE1hdGgubWluKHRoaXMud2lkdGggLyB0aGlzLmltZ3dpZHRoLCB0aGlzLmhlaWdodCAvIHRoaXMuaW1naGVpZ2h0KSkpLCB0aGlzLmVsZW1lbnQgJiYgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShhLCBjKSwgdGhpcy5hbGlnbkJ5VHJhbnNsYXRlIHx8IChmW3BdID0gKCh0aGlzW2FdIHx8IDApIC0gYykgLyAyLCB0aGlzLmF0dHIoZikpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgeShhKSAmJiB3LmF0dHIoe1xuICAgICAgICAgICAgeDogYSxcbiAgICAgICAgICAgIHk6IGNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB3LmlzSW1nID0gITA7XG4gICAgICAgICAgeSh3LmltZ3dpZHRoKSAmJiB5KHcuaW1naGVpZ2h0KSA/IHooKSA6ICh3LmF0dHIoe1xuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgICB9KSwgRyhcImltZ1wiLCB7XG4gICAgICAgICAgICBvbmxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGIgPSBCW20uY2hhcnRJbmRleF07XG4gICAgICAgICAgICAgIDAgPT09IHRoaXMud2lkdGggJiYgKEoodGhpcywge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICAgICAgdG9wOiBcIi05OTllbVwiXG4gICAgICAgICAgICAgIH0pLCBRLmJvZHkuYXBwZW5kQ2hpbGQodGhpcykpO1xuICAgICAgICAgICAgICBPW3ZdID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdy5pbWd3aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgICAgICAgIHcuaW1naGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICAgIHcuZWxlbWVudCAmJiB6KCk7XG4gICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgICAgICAgIG0uaW1nQ291bnQtLTtcbiAgICAgICAgICAgICAgaWYgKCFtLmltZ0NvdW50ICYmIGIgJiYgIWIuaGFzTG9hZGVkKSBiLm9ubG9hZCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNyYzogdlxuICAgICAgICAgIH0pLCB0aGlzLmltZ0NvdW50KyspO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHc7XG4gICAgICB9LFxuICAgICAgc3ltYm9sczoge1xuICAgICAgICBjaXJjbGU6IGZ1bmN0aW9uIChiLCBhLCBmLCBjKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXJjKGIgKyBmIC8gMiwgYSArIGMgLyAyLCBmIC8gMiwgYyAvIDIsIHtcbiAgICAgICAgICAgIHN0YXJ0OiAuNSAqIE1hdGguUEksXG4gICAgICAgICAgICBlbmQ6IDIuNSAqIE1hdGguUEksXG4gICAgICAgICAgICBvcGVuOiAhMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzcXVhcmU6IGZ1bmN0aW9uIChiLCBhLCBmLCBjKSB7XG4gICAgICAgICAgcmV0dXJuIFtcIk1cIiwgYiwgYSwgXCJMXCIsIGIgKyBmLCBhLCBiICsgZiwgYSArIGMsIGIsIGEgKyBjLCBcIlpcIl07XG4gICAgICAgIH0sXG4gICAgICAgIHRyaWFuZ2xlOiBmdW5jdGlvbiAoYiwgYSwgZiwgYykge1xuICAgICAgICAgIHJldHVybiBbXCJNXCIsIGIgKyBmIC8gMiwgYSwgXCJMXCIsIGIgKyBmLCBhICsgYywgYiwgYSArIGMsIFwiWlwiXTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0cmlhbmdsZS1kb3duXCI6IGZ1bmN0aW9uIChiLCBhLCBmLCBjKSB7XG4gICAgICAgICAgcmV0dXJuIFtcIk1cIiwgYiwgYSwgXCJMXCIsIGIgKyBmLCBhLCBiICsgZiAvIDIsIGEgKyBjLCBcIlpcIl07XG4gICAgICAgIH0sXG4gICAgICAgIGRpYW1vbmQ6IGZ1bmN0aW9uIChiLCBhLCBmLCBjKSB7XG4gICAgICAgICAgcmV0dXJuIFtcIk1cIiwgYiArIGYgLyAyLCBhLCBcIkxcIiwgYiArIGYsIGEgKyBjIC8gMiwgYiArIGYgLyAyLCBhICsgYywgYiwgYSArIGMgLyAyLCBcIlpcIl07XG4gICAgICAgIH0sXG4gICAgICAgIGFyYzogZnVuY3Rpb24gKGIsIGEsIGMsIHAsIGUpIHtcbiAgICAgICAgICB2YXIgeCA9IGUuc3RhcnQsXG4gICAgICAgICAgICAgIG0gPSBlLnIgfHwgYyxcbiAgICAgICAgICAgICAgbCA9IGUuciB8fCBwIHx8IGMsXG4gICAgICAgICAgICAgIEMgPSBlLmVuZCAtIC4wMDE7XG4gICAgICAgICAgYyA9IGUuaW5uZXJSO1xuICAgICAgICAgIHAgPSBmKGUub3BlbiwgLjAwMSA+IE1hdGguYWJzKGUuZW5kIC0gZS5zdGFydCAtIDIgKiBNYXRoLlBJKSk7XG4gICAgICAgICAgdmFyIGsgPSBNYXRoLmNvcyh4KSxcbiAgICAgICAgICAgICAgbiA9IE1hdGguc2luKHgpLFxuICAgICAgICAgICAgICB3ID0gTWF0aC5jb3MoQyk7XG4gICAgICAgICAgQyA9IE1hdGguc2luKEMpO1xuICAgICAgICAgIHggPSBmKGUubG9uZ0FyYywgLjAwMSA+IGUuZW5kIC0geCAtIE1hdGguUEkgPyAwIDogMSk7XG4gICAgICAgICAgbSA9IFtcIk1cIiwgYiArIG0gKiBrLCBhICsgbCAqIG4sIFwiQVwiLCBtLCBsLCAwLCB4LCBmKGUuY2xvY2t3aXNlLCAxKSwgYiArIG0gKiB3LCBhICsgbCAqIENdO1xuICAgICAgICAgIHkoYykgJiYgbS5wdXNoKHAgPyBcIk1cIiA6IFwiTFwiLCBiICsgYyAqIHcsIGEgKyBjICogQywgXCJBXCIsIGMsIGMsIDAsIHgsIHkoZS5jbG9ja3dpc2UpID8gMSAtIGUuY2xvY2t3aXNlIDogMCwgYiArIGMgKiBrLCBhICsgYyAqIG4pO1xuICAgICAgICAgIG0ucHVzaChwID8gXCJcIiA6IFwiWlwiKTtcbiAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FsbG91dDogZnVuY3Rpb24gKGIsIGEsIGYsIGMsIHApIHtcbiAgICAgICAgICB2YXIgZSA9IE1hdGgubWluKHAgJiYgcC5yIHx8IDAsIGYsIGMpLFxuICAgICAgICAgICAgICB4ID0gZSArIDYsXG4gICAgICAgICAgICAgIGwgPSBwICYmIHAuYW5jaG9yWDtcbiAgICAgICAgICBwID0gcCAmJiBwLmFuY2hvclk7XG4gICAgICAgICAgdmFyIG0gPSBbXCJNXCIsIGIgKyBlLCBhLCBcIkxcIiwgYiArIGYgLSBlLCBhLCBcIkNcIiwgYiArIGYsIGEsIGIgKyBmLCBhLCBiICsgZiwgYSArIGUsIFwiTFwiLCBiICsgZiwgYSArIGMgLSBlLCBcIkNcIiwgYiArIGYsIGEgKyBjLCBiICsgZiwgYSArIGMsIGIgKyBmIC0gZSwgYSArIGMsIFwiTFwiLCBiICsgZSwgYSArIGMsIFwiQ1wiLCBiLCBhICsgYywgYiwgYSArIGMsIGIsIGEgKyBjIC0gZSwgXCJMXCIsIGIsIGEgKyBlLCBcIkNcIiwgYiwgYSwgYiwgYSwgYiArIGUsIGFdO1xuICAgICAgICAgIGwgJiYgbCA+IGYgPyBwID4gYSArIHggJiYgcCA8IGEgKyBjIC0geCA/IG0uc3BsaWNlKDEzLCAzLCBcIkxcIiwgYiArIGYsIHAgLSA2LCBiICsgZiArIDYsIHAsIGIgKyBmLCBwICsgNiwgYiArIGYsIGEgKyBjIC0gZSkgOiBtLnNwbGljZSgxMywgMywgXCJMXCIsIGIgKyBmLCBjIC8gMiwgbCwgcCwgYiArIGYsIGMgLyAyLCBiICsgZiwgYSArIGMgLSBlKSA6IGwgJiYgMCA+IGwgPyBwID4gYSArIHggJiYgcCA8IGEgKyBjIC0geCA/IG0uc3BsaWNlKDMzLCAzLCBcIkxcIiwgYiwgcCArIDYsIGIgLSA2LCBwLCBiLCBwIC0gNiwgYiwgYSArIGUpIDogbS5zcGxpY2UoMzMsIDMsIFwiTFwiLCBiLCBjIC8gMiwgbCwgcCwgYiwgYyAvIDIsIGIsIGEgKyBlKSA6IHAgJiYgcCA+IGMgJiYgbCA+IGIgKyB4ICYmIGwgPCBiICsgZiAtIHggPyBtLnNwbGljZSgyMywgMywgXCJMXCIsIGwgKyA2LCBhICsgYywgbCwgYSArIGMgKyA2LCBsIC0gNiwgYSArIGMsIGIgKyBlLCBhICsgYykgOiBwICYmIDAgPiBwICYmIGwgPiBiICsgeCAmJiBsIDwgYiArIGYgLSB4ICYmIG0uc3BsaWNlKDMsIDMsIFwiTFwiLCBsIC0gNiwgYSwgbCwgYSAtIDYsIGwgKyA2LCBhLCBmIC0gZSwgYSk7XG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjbGlwUmVjdDogZnVuY3Rpb24gKGIsIGEsIGYsIGMpIHtcbiAgICAgICAgdmFyIHAgPSB3KCkgKyBcIi1cIixcbiAgICAgICAgICAgIGUgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiKS5hdHRyKHtcbiAgICAgICAgICBpZDogcFxuICAgICAgICB9KS5hZGQodGhpcy5kZWZzKTtcbiAgICAgICAgYiA9IHRoaXMucmVjdChiLCBhLCBmLCBjLCAwKS5hZGQoZSk7XG4gICAgICAgIGIuaWQgPSBwO1xuICAgICAgICBiLmNsaXBQYXRoID0gZTtcbiAgICAgICAgYi5jb3VudCA9IDA7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSxcbiAgICAgIHRleHQ6IGZ1bmN0aW9uIChiLCBhLCBmLCBjKSB7XG4gICAgICAgIHZhciBwID0ge307XG4gICAgICAgIGlmIChjICYmICh0aGlzLmFsbG93SFRNTCB8fCAhdGhpcy5mb3JFeHBvcnQpKSByZXR1cm4gdGhpcy5odG1sKGIsIGEsIGYpO1xuICAgICAgICBwLnggPSBNYXRoLnJvdW5kKGEgfHwgMCk7XG4gICAgICAgIGYgJiYgKHAueSA9IE1hdGgucm91bmQoZikpO1xuICAgICAgICB5KGIpICYmIChwLnRleHQgPSBiKTtcbiAgICAgICAgYiA9IHRoaXMuY3JlYXRlRWxlbWVudChcInRleHRcIikuYXR0cihwKTtcbiAgICAgICAgYyB8fCAoYi54U2V0dGVyID0gZnVuY3Rpb24gKGIsIGEsIGYpIHtcbiAgICAgICAgICB2YXIgYyA9IGYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0c3BhblwiKSxcbiAgICAgICAgICAgICAgcCA9IGYuZ2V0QXR0cmlidXRlKGEpLFxuICAgICAgICAgICAgICBlO1xuXG4gICAgICAgICAgZm9yIChlID0gMDsgZSA8IGMubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgICAgIHZhciB4ID0gY1tlXTtcbiAgICAgICAgICAgIHguZ2V0QXR0cmlidXRlKGEpID09PSBwICYmIHguc2V0QXR0cmlidXRlKGEsIGIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGYuc2V0QXR0cmlidXRlKGEsIGIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9LFxuICAgICAgZm9udE1ldHJpY3M6IGZ1bmN0aW9uIChiLCBmKSB7XG4gICAgICAgIGIgPSAhdGhpcy5zdHlsZWRNb2RlICYmIC9weC8udGVzdChiKSB8fCAhWC5nZXRDb21wdXRlZFN0eWxlID8gYiB8fCBmICYmIGYuc3R5bGUgJiYgZi5zdHlsZS5mb250U2l6ZSB8fCB0aGlzLnN0eWxlICYmIHRoaXMuc3R5bGUuZm9udFNpemUgOiBmICYmIFUucHJvdG90eXBlLmdldFN0eWxlLmNhbGwoZiwgXCJmb250LXNpemVcIik7XG4gICAgICAgIGIgPSAvcHgvLnRlc3QoYikgPyBhKGIpIDogMTI7XG4gICAgICAgIGYgPSAyNCA+IGIgPyBiICsgMyA6IE1hdGgucm91bmQoMS4yICogYik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaDogZixcbiAgICAgICAgICBiOiBNYXRoLnJvdW5kKC44ICogZiksXG4gICAgICAgICAgZjogYlxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJvdENvcnI6IGZ1bmN0aW9uIChiLCBhLCBmKSB7XG4gICAgICAgIHZhciBjID0gYjtcbiAgICAgICAgYSAmJiBmICYmIChjID0gTWF0aC5tYXgoYyAqIE1hdGguY29zKGEgKiBMKSwgNCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IC1iIC8gMyAqIE1hdGguc2luKGEgKiBMKSxcbiAgICAgICAgICB5OiBjXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgbGFiZWw6IGZ1bmN0aW9uIChiLCBhLCBmLCBjLCBwLCBlLCB4LCBDLCBuKSB7XG4gICAgICAgIHZhciBtID0gdGhpcyxcbiAgICAgICAgICAgIHcgPSBtLnN0eWxlZE1vZGUsXG4gICAgICAgICAgICB2ID0gbS5nKFwiYnV0dG9uXCIgIT09IG4gJiYgXCJsYWJlbFwiKSxcbiAgICAgICAgICAgIEYgPSB2LnRleHQgPSBtLnRleHQoXCJcIiwgMCwgMCwgeCkuYXR0cih7XG4gICAgICAgICAgekluZGV4OiAxXG4gICAgICAgIH0pLFxuICAgICAgICAgICAgeixcbiAgICAgICAgICAgIE8sXG4gICAgICAgICAgICBxID0gMCxcbiAgICAgICAgICAgIFIgPSAzLFxuICAgICAgICAgICAgQiA9IDAsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgTixcbiAgICAgICAgICAgIFgsXG4gICAgICAgICAgICBWLFxuICAgICAgICAgICAgTCxcbiAgICAgICAgICAgIHQgPSB7fSxcbiAgICAgICAgICAgIFQsXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgUSA9IC9edXJsXFwoKC4qPylcXCkkLy50ZXN0KGMpLFxuICAgICAgICAgICAgSCA9IHcgfHwgUSxcbiAgICAgICAgICAgIEsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHcgPyB6LnN0cm9rZVdpZHRoKCkgJSAyIC8gMiA6IChUID8gcGFyc2VJbnQoVCwgMTApIDogMCkgJSAyIC8gMjtcbiAgICAgICAgfTtcblxuICAgICAgICBuICYmIHYuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLVwiICsgbik7XG5cbiAgICAgICAgdmFyIGJhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBiID0gRi5lbGVtZW50LnN0eWxlLFxuICAgICAgICAgICAgICBhID0ge307XG4gICAgICAgICAgTyA9IChcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgZCB8fCBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgTiB8fCBMKSAmJiB5KEYudGV4dFN0cikgJiYgRi5nZXRCQm94KCk7XG4gICAgICAgICAgdi53aWR0aCA9IChkIHx8IE8ud2lkdGggfHwgMCkgKyAyICogUiArIEI7XG4gICAgICAgICAgdi5oZWlnaHQgPSAoTiB8fCBPLmhlaWdodCB8fCAwKSArIDIgKiBSO1xuICAgICAgICAgIGcgPSBSICsgTWF0aC5taW4obS5mb250TWV0cmljcyhiICYmIGIuZm9udFNpemUsIEYpLmIsIE8gPyBPLmhlaWdodCA6IEluZmluaXR5KTtcbiAgICAgICAgICBIICYmICh6IHx8ICh2LmJveCA9IHogPSBtLnN5bWJvbHNbY10gfHwgUSA/IG0uc3ltYm9sKGMpIDogbS5yZWN0KCksIHouYWRkQ2xhc3MoKFwiYnV0dG9uXCIgPT09IG4gPyBcIlwiIDogXCJoaWdoY2hhcnRzLWxhYmVsLWJveFwiKSArIChuID8gXCIgaGlnaGNoYXJ0cy1cIiArIG4gKyBcIi1ib3hcIiA6IFwiXCIpKSwgei5hZGQodiksIGIgPSBLKCksIGEueCA9IGIsIGEueSA9IChDID8gLWcgOiAwKSArIGIpLCBhLndpZHRoID0gTWF0aC5yb3VuZCh2LndpZHRoKSwgYS5oZWlnaHQgPSBNYXRoLnJvdW5kKHYuaGVpZ2h0KSwgei5hdHRyKGgoYSwgdCkpLCB0ID0ge30pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB1ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBiID0gQiArIFI7XG4gICAgICAgICAgdmFyIGEgPSBDID8gMCA6IGc7XG4gICAgICAgICAgeShkKSAmJiBPICYmIChcImNlbnRlclwiID09PSBMIHx8IFwicmlnaHRcIiA9PT0gTCkgJiYgKGIgKz0ge1xuICAgICAgICAgICAgY2VudGVyOiAuNSxcbiAgICAgICAgICAgIHJpZ2h0OiAxXG4gICAgICAgICAgfVtMXSAqIChkIC0gTy53aWR0aCkpO1xuICAgICAgICAgIGlmIChiICE9PSBGLnggfHwgYSAhPT0gRi55KSBGLmF0dHIoXCJ4XCIsIGIpLCBGLmhhc0JveFdpZHRoQ2hhbmdlZCAmJiAoTyA9IEYuZ2V0QkJveCghMCksIGJhKCkpLCBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYSAmJiBGLmF0dHIoXCJ5XCIsIGEpO1xuICAgICAgICAgIEYueCA9IGI7XG4gICAgICAgICAgRi55ID0gYTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgWSA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgeiA/IHouYXR0cihiLCBhKSA6IHRbYl0gPSBhO1xuICAgICAgICB9O1xuXG4gICAgICAgIHYub25BZGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgRi5hZGQodik7XG4gICAgICAgICAgdi5hdHRyKHtcbiAgICAgICAgICAgIHRleHQ6IGIgfHwgMCA9PT0gYiA/IGIgOiBcIlwiLFxuICAgICAgICAgICAgeDogYSxcbiAgICAgICAgICAgIHk6IGZcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB6ICYmIHkocCkgJiYgdi5hdHRyKHtcbiAgICAgICAgICAgIGFuY2hvclg6IHAsXG4gICAgICAgICAgICBhbmNob3JZOiBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdi53aWR0aFNldHRlciA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgZCA9IFAoYikgPyBiIDogbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICB2LmhlaWdodFNldHRlciA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgTiA9IGI7XG4gICAgICAgIH07XG5cbiAgICAgICAgdltcInRleHQtYWxpZ25TZXR0ZXJcIl0gPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIEwgPSBiO1xuICAgICAgICB9O1xuXG4gICAgICAgIHYucGFkZGluZ1NldHRlciA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgeShiKSAmJiBiICE9PSBSICYmIChSID0gdi5wYWRkaW5nID0gYiwgdSgpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2LnBhZGRpbmdMZWZ0U2V0dGVyID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICB5KGIpICYmIGIgIT09IEIgJiYgKEIgPSBiLCB1KCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHYuYWxpZ25TZXR0ZXIgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGIgPSB7XG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgY2VudGVyOiAuNSxcbiAgICAgICAgICAgIHJpZ2h0OiAxXG4gICAgICAgICAgfVtiXTtcbiAgICAgICAgICBiICE9PSBxICYmIChxID0gYiwgTyAmJiB2LmF0dHIoe1xuICAgICAgICAgICAgeDogWFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2LnRleHRTZXR0ZXIgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBiICYmIEYuYXR0cih7XG4gICAgICAgICAgICB0ZXh0OiBiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYmEoKTtcbiAgICAgICAgICB1KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdltcInN0cm9rZS13aWR0aFNldHRlclwiXSA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgYiAmJiAoSCA9ICEwKTtcbiAgICAgICAgICBUID0gdGhpc1tcInN0cm9rZS13aWR0aFwiXSA9IGI7XG4gICAgICAgICAgWShhLCBiKTtcbiAgICAgICAgfTtcblxuICAgICAgICB3ID8gdi5yU2V0dGVyID0gZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBZKGEsIGIpO1xuICAgICAgICB9IDogdi5zdHJva2VTZXR0ZXIgPSB2LmZpbGxTZXR0ZXIgPSB2LnJTZXR0ZXIgPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIFwiclwiICE9PSBhICYmIChcImZpbGxcIiA9PT0gYSAmJiBiICYmIChIID0gITApLCB2W2FdID0gYik7XG4gICAgICAgICAgWShhLCBiKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2LmFuY2hvclhTZXR0ZXIgPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIHAgPSB2LmFuY2hvclggPSBiO1xuICAgICAgICAgIFkoYSwgTWF0aC5yb3VuZChiKSAtIEsoKSAtIFgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHYuYW5jaG9yWVNldHRlciA9IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgZSA9IHYuYW5jaG9yWSA9IGI7XG4gICAgICAgICAgWShhLCBiIC0gVik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdi54U2V0dGVyID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICB2LnggPSBiO1xuICAgICAgICAgIHEgJiYgKGIgLT0gcSAqICgoZCB8fCBPLndpZHRoKSArIDIgKiBSKSwgdltcImZvcmNlQW5pbWF0ZTp4XCJdID0gITApO1xuICAgICAgICAgIFggPSBNYXRoLnJvdW5kKGIpO1xuICAgICAgICAgIHYuYXR0cihcInRyYW5zbGF0ZVhcIiwgWCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdi55U2V0dGVyID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBWID0gdi55ID0gTWF0aC5yb3VuZChiKTtcbiAgICAgICAgICB2LmF0dHIoXCJ0cmFuc2xhdGVZXCIsIFYpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBEID0gdi5jc3M7XG4gICAgICAgIHggPSB7XG4gICAgICAgICAgY3NzOiBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICAgICAgdmFyIGEgPSB7fTtcbiAgICAgICAgICAgICAgYiA9IGsoYik7XG4gICAgICAgICAgICAgIHYudGV4dFByb3BzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYltmXSAmJiAoYVtmXSA9IGJbZl0sIGRlbGV0ZSBiW2ZdKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIEYuY3NzKGEpO1xuICAgICAgICAgICAgICBcIndpZHRoXCIgaW4gYSAmJiBiYSgpO1xuICAgICAgICAgICAgICBcImZvbnRTaXplXCIgaW4gYSAmJiAoYmEoKSwgdSgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIEQuY2FsbCh2LCBiKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldEJCb3g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHdpZHRoOiBPLndpZHRoICsgMiAqIFIsXG4gICAgICAgICAgICAgIGhlaWdodDogTy5oZWlnaHQgKyAyICogUixcbiAgICAgICAgICAgICAgeDogTy54IC0gUixcbiAgICAgICAgICAgICAgeTogTy55IC0gUlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGwodi5lbGVtZW50LCBcIm1vdXNlZW50ZXJcIik7XG4gICAgICAgICAgICBsKHYuZWxlbWVudCwgXCJtb3VzZWxlYXZlXCIpO1xuICAgICAgICAgICAgRiAmJiAoRiA9IEYuZGVzdHJveSgpKTtcbiAgICAgICAgICAgIHogJiYgKHogPSB6LmRlc3Ryb3koKSk7XG4gICAgICAgICAgICBVLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodik7XG4gICAgICAgICAgICB2ID0gbSA9IGJhID0gdSA9IFkgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdyB8fCAoeC5zaGFkb3cgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGIgJiYgKGJhKCksIHogJiYgei5zaGFkb3coYikpO1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGgodiwgeCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZC5SZW5kZXJlciA9IGc7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvSHRtbC5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZykge1xuICAgIHZhciByID0gZy5hdHRyLFxuICAgICAgICB1ID0gZy5jcmVhdGVFbGVtZW50LFxuICAgICAgICBJID0gZy5jc3MsXG4gICAgICAgIE0gPSBnLmRlZmluZWQsXG4gICAgICAgIEUgPSBnLmV4dGVuZCxcbiAgICAgICAgQSA9IGcucGljayxcbiAgICAgICAgRyA9IGcucEludCxcbiAgICAgICAgSiA9IGQuaXNGaXJlZm94LFxuICAgICAgICB5ID0gZC5pc01TLFxuICAgICAgICB0ID0gZC5pc1dlYktpdCxcbiAgICAgICAgRCA9IGQuU1ZHRWxlbWVudDtcbiAgICBnID0gZC5TVkdSZW5kZXJlcjtcbiAgICB2YXIgaCA9IGQud2luO1xuICAgIEUoRC5wcm90b3R5cGUsIHtcbiAgICAgIGh0bWxDc3M6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBxID0gXCJTUEFOXCIgPT09IHRoaXMuZWxlbWVudC50YWdOYW1lICYmIGQgJiYgXCJ3aWR0aFwiIGluIGQsXG4gICAgICAgICAgICBOID0gQShxICYmIGQud2lkdGgsIHZvaWQgMCk7XG5cbiAgICAgICAgaWYgKHEpIHtcbiAgICAgICAgICBkZWxldGUgZC53aWR0aDtcbiAgICAgICAgICB0aGlzLnRleHRXaWR0aCA9IE47XG4gICAgICAgICAgdmFyIGUgPSAhMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGQgJiYgXCJlbGxpcHNpc1wiID09PSBkLnRleHRPdmVyZmxvdyAmJiAoZC53aGl0ZVNwYWNlID0gXCJub3dyYXBcIiwgZC5vdmVyZmxvdyA9IFwiaGlkZGVuXCIpO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IEUodGhpcy5zdHlsZXMsIGQpO1xuICAgICAgICBJKHRoaXMuZWxlbWVudCwgZCk7XG4gICAgICAgIGUgJiYgdGhpcy5odG1sVXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGh0bWxHZXRCQm94OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkID0gdGhpcy5lbGVtZW50O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGQub2Zmc2V0TGVmdCxcbiAgICAgICAgICB5OiBkLm9mZnNldFRvcCxcbiAgICAgICAgICB3aWR0aDogZC5vZmZzZXRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGQub2Zmc2V0SGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgaHRtbFVwZGF0ZVRyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hZGRlZCkge1xuICAgICAgICAgIHZhciBkID0gdGhpcy5yZW5kZXJlcixcbiAgICAgICAgICAgICAgcSA9IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgICAgaCA9IHRoaXMudHJhbnNsYXRlWCB8fCAwLFxuICAgICAgICAgICAgICBlID0gdGhpcy50cmFuc2xhdGVZIHx8IDAsXG4gICAgICAgICAgICAgIGMgPSB0aGlzLnggfHwgMCxcbiAgICAgICAgICAgICAgayA9IHRoaXMueSB8fCAwLFxuICAgICAgICAgICAgICBuID0gdGhpcy50ZXh0QWxpZ24gfHwgXCJsZWZ0XCIsXG4gICAgICAgICAgICAgIGYgPSB7XG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgY2VudGVyOiAuNSxcbiAgICAgICAgICAgIHJpZ2h0OiAxXG4gICAgICAgICAgfVtuXSxcbiAgICAgICAgICAgICAgYSA9IHRoaXMuc3R5bGVzLFxuICAgICAgICAgICAgICBsID0gYSAmJiBhLndoaXRlU3BhY2U7XG4gICAgICAgICAgSShxLCB7XG4gICAgICAgICAgICBtYXJnaW5MZWZ0OiBoLFxuICAgICAgICAgICAgbWFyZ2luVG9wOiBlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgIWQuc3R5bGVkTW9kZSAmJiB0aGlzLnNoYWRvd3MgJiYgdGhpcy5zaGFkb3dzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIEkoYSwge1xuICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiBoICsgMSxcbiAgICAgICAgICAgICAgbWFyZ2luVG9wOiBlICsgMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5pbnZlcnRlZCAmJiBbXS5mb3JFYWNoLmNhbGwocS5jaGlsZE5vZGVzLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgZC5pbnZlcnRDaGlsZChhLCBxKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChcIlNQQU5cIiA9PT0gcS50YWdOYW1lKSB7XG4gICAgICAgICAgICBhID0gdGhpcy5yb3RhdGlvbjtcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy50ZXh0V2lkdGggJiYgRyh0aGlzLnRleHRXaWR0aCksXG4gICAgICAgICAgICAgICAgeiA9IFthLCBuLCBxLmlubmVySFRNTCwgdGhpcy50ZXh0V2lkdGgsIHRoaXMudGV4dEFsaWduXS5qb2luKCksXG4gICAgICAgICAgICAgICAgdztcbiAgICAgICAgICAgICh3ID0gdiAhPT0gdGhpcy5vbGRUZXh0V2lkdGgpICYmICEodyA9IHYgPiB0aGlzLm9sZFRleHRXaWR0aCkgJiYgKCh3ID0gdGhpcy50ZXh0UHhMZW5ndGgpIHx8IChJKHEsIHtcbiAgICAgICAgICAgICAgd2lkdGg6IFwiXCIsXG4gICAgICAgICAgICAgIHdoaXRlU3BhY2U6IGwgfHwgXCJub3dyYXBcIlxuICAgICAgICAgICAgfSksIHcgPSBxLm9mZnNldFdpZHRoKSwgdyA9IHcgPiB2KTtcbiAgICAgICAgICAgIHcgJiYgKC9bIFxcLV0vLnRlc3QocS50ZXh0Q29udGVudCB8fCBxLmlubmVyVGV4dCkgfHwgXCJlbGxpcHNpc1wiID09PSBxLnN0eWxlLnRleHRPdmVyZmxvdykgPyAoSShxLCB7XG4gICAgICAgICAgICAgIHdpZHRoOiB2ICsgXCJweFwiLFxuICAgICAgICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgICAgICAgIHdoaXRlU3BhY2U6IGwgfHwgXCJub3JtYWxcIlxuICAgICAgICAgICAgfSksIHRoaXMub2xkVGV4dFdpZHRoID0gdiwgdGhpcy5oYXNCb3hXaWR0aENoYW5nZWQgPSAhMCkgOiB0aGlzLmhhc0JveFdpZHRoQ2hhbmdlZCA9ICExO1xuICAgICAgICAgICAgeiAhPT0gdGhpcy5jVFQgJiYgKGwgPSBkLmZvbnRNZXRyaWNzKHEuc3R5bGUuZm9udFNpemUsIHEpLmIsICFNKGEpIHx8IGEgPT09ICh0aGlzLm9sZFJvdGF0aW9uIHx8IDApICYmIG4gPT09IHRoaXMub2xkQWxpZ24gfHwgdGhpcy5zZXRTcGFuUm90YXRpb24oYSwgZiwgbCksIHRoaXMuZ2V0U3BhbkNvcnJlY3Rpb24oIU0oYSkgJiYgdGhpcy50ZXh0UHhMZW5ndGggfHwgcS5vZmZzZXRXaWR0aCwgbCwgZiwgYSwgbikpO1xuICAgICAgICAgICAgSShxLCB7XG4gICAgICAgICAgICAgIGxlZnQ6IGMgKyAodGhpcy54Q29yciB8fCAwKSArIFwicHhcIixcbiAgICAgICAgICAgICAgdG9wOiBrICsgKHRoaXMueUNvcnIgfHwgMCkgKyBcInB4XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jVFQgPSB6O1xuICAgICAgICAgICAgdGhpcy5vbGRSb3RhdGlvbiA9IGE7XG4gICAgICAgICAgICB0aGlzLm9sZEFsaWduID0gbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB0aGlzLmFsaWduT25BZGQgPSAhMDtcbiAgICAgIH0sXG4gICAgICBzZXRTcGFuUm90YXRpb246IGZ1bmN0aW9uIChkLCBxLCBoKSB7XG4gICAgICAgIHZhciBlID0ge30sXG4gICAgICAgICAgICBjID0gdGhpcy5yZW5kZXJlci5nZXRUcmFuc2Zvcm1LZXkoKTtcbiAgICAgICAgZVtjXSA9IGUudHJhbnNmb3JtID0gXCJyb3RhdGUoXCIgKyBkICsgXCJkZWcpXCI7XG4gICAgICAgIGVbYyArIChKID8gXCJPcmlnaW5cIiA6IFwiLW9yaWdpblwiKV0gPSBlLnRyYW5zZm9ybU9yaWdpbiA9IDEwMCAqIHEgKyBcIiUgXCIgKyBoICsgXCJweFwiO1xuICAgICAgICBJKHRoaXMuZWxlbWVudCwgZSk7XG4gICAgICB9LFxuICAgICAgZ2V0U3BhbkNvcnJlY3Rpb246IGZ1bmN0aW9uIChkLCBxLCBoKSB7XG4gICAgICAgIHRoaXMueENvcnIgPSAtZCAqIGg7XG4gICAgICAgIHRoaXMueUNvcnIgPSAtcTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBFKGcucHJvdG90eXBlLCB7XG4gICAgICBnZXRUcmFuc2Zvcm1LZXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHkgJiYgIS9FZGdlLy50ZXN0KGgubmF2aWdhdG9yLnVzZXJBZ2VudCkgPyBcIi1tcy10cmFuc2Zvcm1cIiA6IHQgPyBcIi13ZWJraXQtdHJhbnNmb3JtXCIgOiBKID8gXCJNb3pUcmFuc2Zvcm1cIiA6IGgub3BlcmEgPyBcIi1vLXRyYW5zZm9ybVwiIDogXCJcIjtcbiAgICAgIH0sXG4gICAgICBodG1sOiBmdW5jdGlvbiAoZCwgcSwgaCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuY3JlYXRlRWxlbWVudChcInNwYW5cIiksXG4gICAgICAgICAgICBjID0gZS5lbGVtZW50LFxuICAgICAgICAgICAgayA9IGUucmVuZGVyZXIsXG4gICAgICAgICAgICBuID0gay5pc1NWRyxcbiAgICAgICAgICAgIGYgPSBmdW5jdGlvbiAoYSwgZikge1xuICAgICAgICAgIFtcIm9wYWNpdHlcIiwgXCJ2aXNpYmlsaXR5XCJdLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGFbYyArIFwiU2V0dGVyXCJdID0gZnVuY3Rpb24gKGUsIGwsIGspIHtcbiAgICAgICAgICAgICAgdmFyIHYgPSBhLmRpdiA/IGEuZGl2LnN0eWxlIDogZjtcbiAgICAgICAgICAgICAgRC5wcm90b3R5cGVbYyArIFwiU2V0dGVyXCJdLmNhbGwodGhpcywgZSwgbCwgayk7XG4gICAgICAgICAgICAgIHYgJiYgKHZbbF0gPSBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYS5hZGRlZFNldHRlcnMgPSAhMDtcbiAgICAgICAgfTtcblxuICAgICAgICBlLnRleHRTZXR0ZXIgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEgIT09IGMuaW5uZXJIVE1MICYmIChkZWxldGUgdGhpcy5iQm94LCBkZWxldGUgdGhpcy5vbGRUZXh0V2lkdGgpO1xuICAgICAgICAgIHRoaXMudGV4dFN0ciA9IGE7XG4gICAgICAgICAgYy5pbm5lckhUTUwgPSBBKGEsIFwiXCIpO1xuICAgICAgICAgIGUuZG9UcmFuc2Zvcm0gPSAhMDtcbiAgICAgICAgfTtcblxuICAgICAgICBuICYmIGYoZSwgZS5lbGVtZW50LnN0eWxlKTtcblxuICAgICAgICBlLnhTZXR0ZXIgPSBlLnlTZXR0ZXIgPSBlLmFsaWduU2V0dGVyID0gZS5yb3RhdGlvblNldHRlciA9IGZ1bmN0aW9uIChhLCBmKSB7XG4gICAgICAgICAgXCJhbGlnblwiID09PSBmICYmIChmID0gXCJ0ZXh0QWxpZ25cIik7XG4gICAgICAgICAgZVtmXSA9IGE7XG4gICAgICAgICAgZS5kb1RyYW5zZm9ybSA9ICEwO1xuICAgICAgICB9O1xuXG4gICAgICAgIGUuYWZ0ZXJTZXR0ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuZG9UcmFuc2Zvcm0gJiYgKHRoaXMuaHRtbFVwZGF0ZVRyYW5zZm9ybSgpLCB0aGlzLmRvVHJhbnNmb3JtID0gITEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGUuYXR0cih7XG4gICAgICAgICAgdGV4dDogZCxcbiAgICAgICAgICB4OiBNYXRoLnJvdW5kKHEpLFxuICAgICAgICAgIHk6IE1hdGgucm91bmQoaClcbiAgICAgICAgfSkuY3NzKHtcbiAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBrLnN0eWxlZE1vZGUgfHwgZS5jc3Moe1xuICAgICAgICAgIGZvbnRGYW1pbHk6IHRoaXMuc3R5bGUuZm9udEZhbWlseSxcbiAgICAgICAgICBmb250U2l6ZTogdGhpcy5zdHlsZS5mb250U2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgYy5zdHlsZS53aGl0ZVNwYWNlID0gXCJub3dyYXBcIjtcbiAgICAgICAgZS5jc3MgPSBlLmh0bWxDc3M7XG4gICAgICAgIG4gJiYgKGUuYWRkID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICB2YXIgbCA9IGsuYm94LnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgIHYgPSBbXTtcblxuICAgICAgICAgIGlmICh0aGlzLnBhcmVudEdyb3VwID0gYSkge1xuICAgICAgICAgICAgdmFyIG4gPSBhLmRpdjtcblxuICAgICAgICAgICAgaWYgKCFuKSB7XG4gICAgICAgICAgICAgIGZvciAoOyBhOykgdi5wdXNoKGEpLCBhID0gYS5wYXJlbnRHcm91cDtcblxuICAgICAgICAgICAgICB2LnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYyhmLCBjKSB7XG4gICAgICAgICAgICAgICAgICBhW2NdID0gZjtcbiAgICAgICAgICAgICAgICAgIFwidHJhbnNsYXRlWFwiID09PSBjID8gdy5sZWZ0ID0gZiArIFwicHhcIiA6IHcudG9wID0gZiArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgIGEuZG9UcmFuc2Zvcm0gPSAhMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgayA9IHIoYS5lbGVtZW50LCBcImNsYXNzXCIpO1xuICAgICAgICAgICAgICAgIG4gPSBhLmRpdiA9IGEuZGl2IHx8IHUoXCJkaXZcIiwgayA/IHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZToga1xuICAgICAgICAgICAgICAgIH0gOiB2b2lkIDAsIHtcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICAgICAgICBsZWZ0OiAoYS50cmFuc2xhdGVYIHx8IDApICsgXCJweFwiLFxuICAgICAgICAgICAgICAgICAgdG9wOiAoYS50cmFuc2xhdGVZIHx8IDApICsgXCJweFwiLFxuICAgICAgICAgICAgICAgICAgZGlzcGxheTogYS5kaXNwbGF5LFxuICAgICAgICAgICAgICAgICAgb3BhY2l0eTogYS5vcGFjaXR5LFxuICAgICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogYS5zdHlsZXMgJiYgYS5zdHlsZXMucG9pbnRlckV2ZW50c1xuICAgICAgICAgICAgICAgIH0sIG4gfHwgbCk7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSBuLnN0eWxlO1xuICAgICAgICAgICAgICAgIEUoYSwge1xuICAgICAgICAgICAgICAgICAgY2xhc3NTZXR0ZXI6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBmKTtcbiAgICAgICAgICAgICAgICAgICAgICBhLmNsYXNzTmFtZSA9IGY7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9KG4pLFxuICAgICAgICAgICAgICAgICAgb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdlswXS5kaXYgJiYgZS5vbi5hcHBseSh7XG4gICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogdlswXS5kaXZcbiAgICAgICAgICAgICAgICAgICAgfSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWFNldHRlcjogYyxcbiAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVlTZXR0ZXI6IGNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhLmFkZGVkU2V0dGVycyB8fCBmKGEpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgbiA9IGw7XG5cbiAgICAgICAgICBuLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgIGUuYWRkZWQgPSAhMDtcbiAgICAgICAgICBlLmFsaWduT25BZGQgJiYgZS5odG1sVXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9UaWNrLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgdmFyIHIgPSBnLmNsYW1wLFxuICAgICAgICB1ID0gZy5jb3JyZWN0RmxvYXQsXG4gICAgICAgIEkgPSBnLmRlZmluZWQsXG4gICAgICAgIE0gPSBnLmRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzLFxuICAgICAgICBFID0gZy5leHRlbmQsXG4gICAgICAgIEEgPSBnLmlzTnVtYmVyLFxuICAgICAgICBHID0gZy5tZXJnZSxcbiAgICAgICAgSiA9IGcub2JqZWN0RWFjaCxcbiAgICAgICAgeSA9IGcucGljayxcbiAgICAgICAgdCA9IGQuZmlyZUV2ZW50LFxuICAgICAgICBEID0gZC5kZWcycmFkO1xuXG4gICAgZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIGgoZCwgcSwgaCwgZSwgYykge1xuICAgICAgICB0aGlzLmlzTmV3TGFiZWwgPSB0aGlzLmlzTmV3ID0gITA7XG4gICAgICAgIHRoaXMuYXhpcyA9IGQ7XG4gICAgICAgIHRoaXMucG9zID0gcTtcbiAgICAgICAgdGhpcy50eXBlID0gaCB8fCBcIlwiO1xuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBjIHx8IHt9O1xuICAgICAgICB0aGlzLnRpY2ttYXJrT2Zmc2V0ID0gdGhpcy5wYXJhbWV0ZXJzLnRpY2ttYXJrT2Zmc2V0O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLnBhcmFtZXRlcnMub3B0aW9ucztcbiAgICAgICAgaCB8fCBlIHx8IHRoaXMuYWRkTGFiZWwoKTtcbiAgICAgIH1cblxuICAgICAgaC5wcm90b3R5cGUuYWRkTGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICAgIHEgPSBkLmF4aXMsXG4gICAgICAgICAgICBoID0gcS5vcHRpb25zLFxuICAgICAgICAgICAgZSA9IHEuY2hhcnQsXG4gICAgICAgICAgICBjID0gcS5jYXRlZ29yaWVzLFxuICAgICAgICAgICAgayA9IHEubmFtZXMsXG4gICAgICAgICAgICBuID0gZC5wb3MsXG4gICAgICAgICAgICBmID0geShkLm9wdGlvbnMgJiYgZC5vcHRpb25zLmxhYmVscywgaC5sYWJlbHMpLFxuICAgICAgICAgICAgYSA9IHEudGlja1Bvc2l0aW9ucyxcbiAgICAgICAgICAgIGwgPSBuID09PSBhWzBdLFxuICAgICAgICAgICAgdiA9IG4gPT09IGFbYS5sZW5ndGggLSAxXTtcbiAgICAgICAgayA9IHRoaXMucGFyYW1ldGVycy5jYXRlZ29yeSB8fCAoYyA/IHkoY1tuXSwga1tuXSwgbikgOiBuKTtcbiAgICAgICAgdmFyIHogPSBkLmxhYmVsO1xuICAgICAgICBjID0gKCFmLnN0ZXAgfHwgMSA9PT0gZi5zdGVwKSAmJiAxID09PSBxLnRpY2tJbnRlcnZhbDtcbiAgICAgICAgYSA9IGEuaW5mbztcbiAgICAgICAgdmFyIHcsIEI7XG5cbiAgICAgICAgaWYgKHEuaXNEYXRldGltZUF4aXMgJiYgYSkge1xuICAgICAgICAgIHZhciBMID0gZS50aW1lLnJlc29sdmVEVExGb3JtYXQoaC5kYXRlVGltZUxhYmVsRm9ybWF0c1shaC5ncmlkICYmIGEuaGlnaGVyUmFua3Nbbl0gfHwgYS51bml0TmFtZV0pO1xuICAgICAgICAgIHZhciB0ID0gTC5tYWluO1xuICAgICAgICB9XG5cbiAgICAgICAgZC5pc0ZpcnN0ID0gbDtcbiAgICAgICAgZC5pc0xhc3QgPSB2O1xuICAgICAgICBkLmZvcm1hdEN0eCA9IHtcbiAgICAgICAgICBheGlzOiBxLFxuICAgICAgICAgIGNoYXJ0OiBlLFxuICAgICAgICAgIGlzRmlyc3Q6IGwsXG4gICAgICAgICAgaXNMYXN0OiB2LFxuICAgICAgICAgIGRhdGVUaW1lTGFiZWxGb3JtYXQ6IHQsXG4gICAgICAgICAgdGlja1Bvc2l0aW9uSW5mbzogYSxcbiAgICAgICAgICB2YWx1ZTogcS5pc0xvZyA/IHUocS5saW4ybG9nKGspKSA6IGssXG4gICAgICAgICAgcG9zOiBuXG4gICAgICAgIH07XG4gICAgICAgIGggPSBxLmxhYmVsRm9ybWF0dGVyLmNhbGwoZC5mb3JtYXRDdHgsIHRoaXMuZm9ybWF0Q3R4KTtcbiAgICAgICAgaWYgKEIgPSBMICYmIEwubGlzdCkgZC5zaG9ydGVuTGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZm9yICh3ID0gMDsgdyA8IEIubGVuZ3RoOyB3KyspIGlmICh6LmF0dHIoe1xuICAgICAgICAgICAgdGV4dDogcS5sYWJlbEZvcm1hdHRlci5jYWxsKEUoZC5mb3JtYXRDdHgsIHtcbiAgICAgICAgICAgICAgZGF0ZVRpbWVMYWJlbEZvcm1hdDogQlt3XVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgfSksIHouZ2V0QkJveCgpLndpZHRoIDwgcS5nZXRTbG90V2lkdGgoZCkgLSAyICogeShmLnBhZGRpbmcsIDUpKSByZXR1cm47XG5cbiAgICAgICAgICB6LmF0dHIoe1xuICAgICAgICAgICAgdGV4dDogXCJcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjICYmIHEuX2FkZGVkUGxvdExCICYmIHEuaXNYQXhpcyAmJiBkLm1vdmVMYWJlbChoLCBmKTtcbiAgICAgICAgSSh6KSB8fCBkLm1vdmVkTGFiZWwgPyB6ICYmIHoudGV4dFN0ciAhPT0gaCAmJiAhYyAmJiAoIXoudGV4dFdpZHRoIHx8IGYuc3R5bGUgJiYgZi5zdHlsZS53aWR0aCB8fCB6LnN0eWxlcy53aWR0aCB8fCB6LmNzcyh7XG4gICAgICAgICAgd2lkdGg6IG51bGxcbiAgICAgICAgfSksIHouYXR0cih7XG4gICAgICAgICAgdGV4dDogaFxuICAgICAgICB9KSwgei50ZXh0UHhMZW5ndGggPSB6LmdldEJCb3goKS53aWR0aCkgOiAoZC5sYWJlbCA9IHogPSBkLmNyZWF0ZUxhYmVsKHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSwgaCwgZiksIGQucm90YXRpb24gPSAwKTtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLmNyZWF0ZUxhYmVsID0gZnVuY3Rpb24gKGQsIHEsIGgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmF4aXMsXG4gICAgICAgICAgICBjID0gZS5jaGFydDtcbiAgICAgICAgaWYgKGQgPSBJKHEpICYmIGguZW5hYmxlZCA/IGMucmVuZGVyZXIudGV4dChxLCBkLngsIGQueSwgaC51c2VIVE1MKS5hZGQoZS5sYWJlbEdyb3VwKSA6IG51bGwpIGMuc3R5bGVkTW9kZSB8fCBkLmNzcyhHKGguc3R5bGUpKSwgZC50ZXh0UHhMZW5ndGggPSBkLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBNKHRoaXMsIHRoaXMuYXhpcyk7XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChkLCBxLCBoLCBlKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5heGlzLFxuICAgICAgICAgICAgayA9IGMuY2hhcnQsXG4gICAgICAgICAgICBuID0gZSAmJiBrLm9sZENoYXJ0SGVpZ2h0IHx8IGsuY2hhcnRIZWlnaHQ7XG4gICAgICAgIGQgPSB7XG4gICAgICAgICAgeDogZCA/IHUoYy50cmFuc2xhdGUocSArIGgsIG51bGwsIG51bGwsIGUpICsgYy50cmFuc0IpIDogYy5sZWZ0ICsgYy5vZmZzZXQgKyAoYy5vcHBvc2l0ZSA/IChlICYmIGsub2xkQ2hhcnRXaWR0aCB8fCBrLmNoYXJ0V2lkdGgpIC0gYy5yaWdodCAtIGMubGVmdCA6IDApLFxuICAgICAgICAgIHk6IGQgPyBuIC0gYy5ib3R0b20gKyBjLm9mZnNldCAtIChjLm9wcG9zaXRlID8gYy5oZWlnaHQgOiAwKSA6IHUobiAtIGMudHJhbnNsYXRlKHEgKyBoLCBudWxsLCBudWxsLCBlKSAtIGMudHJhbnNCKVxuICAgICAgICB9O1xuICAgICAgICBkLnkgPSByKGQueSwgLTFFNSwgMUU1KTtcbiAgICAgICAgdCh0aGlzLCBcImFmdGVyR2V0UG9zaXRpb25cIiwge1xuICAgICAgICAgIHBvczogZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5nZXRMYWJlbFBvc2l0aW9uID0gZnVuY3Rpb24gKGQsIHEsIGgsIGUsIGMsIGssIG4sIGYpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmF4aXMsXG4gICAgICAgICAgICBsID0gYS50cmFuc0EsXG4gICAgICAgICAgICB2ID0gYS5pc0xpbmtlZCAmJiBhLmxpbmtlZFBhcmVudCA/IGEubGlua2VkUGFyZW50LnJldmVyc2VkIDogYS5yZXZlcnNlZCxcbiAgICAgICAgICAgIHogPSBhLnN0YWdnZXJMaW5lcyxcbiAgICAgICAgICAgIHcgPSBhLnRpY2tSb3RDb3JyIHx8IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSxcbiAgICAgICAgICAgIEIgPSBjLnksXG4gICAgICAgICAgICBMID0gZSB8fCBhLnJlc2VydmVTcGFjZURlZmF1bHQgPyAwIDogLWEubGFiZWxPZmZzZXQgKiAoXCJjZW50ZXJcIiA9PT0gYS5sYWJlbEFsaWduID8gLjUgOiAxKSxcbiAgICAgICAgICAgIE4gPSB7fTtcbiAgICAgICAgSShCKSB8fCAoQiA9IDAgPT09IGEuc2lkZSA/IGgucm90YXRpb24gPyAtOCA6IC1oLmdldEJCb3goKS5oZWlnaHQgOiAyID09PSBhLnNpZGUgPyB3LnkgKyA4IDogTWF0aC5jb3MoaC5yb3RhdGlvbiAqIEQpICogKHcueSAtIGguZ2V0QkJveCghMSwgMCkuaGVpZ2h0IC8gMikpO1xuICAgICAgICBkID0gZCArIGMueCArIEwgKyB3LnggLSAoayAmJiBlID8gayAqIGwgKiAodiA/IC0xIDogMSkgOiAwKTtcbiAgICAgICAgcSA9IHEgKyBCIC0gKGsgJiYgIWUgPyBrICogbCAqICh2ID8gMSA6IC0xKSA6IDApO1xuICAgICAgICB6ICYmIChoID0gbiAvIChmIHx8IDEpICUgeiwgYS5vcHBvc2l0ZSAmJiAoaCA9IHogLSBoIC0gMSksIHEgKz0gYS5sYWJlbE9mZnNldCAvIHogKiBoKTtcbiAgICAgICAgTi54ID0gZDtcbiAgICAgICAgTi55ID0gTWF0aC5yb3VuZChxKTtcbiAgICAgICAgdCh0aGlzLCBcImFmdGVyR2V0TGFiZWxQb3NpdGlvblwiLCB7XG4gICAgICAgICAgcG9zOiBOLFxuICAgICAgICAgIHRpY2ttYXJrT2Zmc2V0OiBrLFxuICAgICAgICAgIGluZGV4OiBuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gTjtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLmdldExhYmVsU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWwgPyB0aGlzLmxhYmVsLmdldEJCb3goKVt0aGlzLmF4aXMuaG9yaXogPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiXSA6IDA7XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5nZXRNYXJrUGF0aCA9IGZ1bmN0aW9uIChkLCBxLCBoLCBlLCBjLCBrKSB7XG4gICAgICAgIHJldHVybiBrLmNyaXNwTGluZShbXCJNXCIsIGQsIHEsIFwiTFwiLCBkICsgKGMgPyAwIDogLWgpLCBxICsgKGMgPyBoIDogMCldLCBlKTtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLmhhbmRsZU92ZXJmbG93ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIHEgPSB0aGlzLmF4aXMsXG4gICAgICAgICAgICBoID0gcS5vcHRpb25zLmxhYmVscyxcbiAgICAgICAgICAgIGUgPSBkLngsXG4gICAgICAgICAgICBjID0gcS5jaGFydC5jaGFydFdpZHRoLFxuICAgICAgICAgICAgayA9IHEuY2hhcnQuc3BhY2luZyxcbiAgICAgICAgICAgIG4gPSB5KHEubGFiZWxMZWZ0LCBNYXRoLm1pbihxLnBvcywga1szXSkpO1xuICAgICAgICBrID0geShxLmxhYmVsUmlnaHQsIE1hdGgubWF4KHEuaXNSYWRpYWwgPyAwIDogcS5wb3MgKyBxLmxlbiwgYyAtIGtbMV0pKTtcbiAgICAgICAgdmFyIGYgPSB0aGlzLmxhYmVsLFxuICAgICAgICAgICAgYSA9IHRoaXMucm90YXRpb24sXG4gICAgICAgICAgICBsID0ge1xuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgY2VudGVyOiAuNSxcbiAgICAgICAgICByaWdodDogMVxuICAgICAgICB9W3EubGFiZWxBbGlnbiB8fCBmLmF0dHIoXCJhbGlnblwiKV0sXG4gICAgICAgICAgICB2ID0gZi5nZXRCQm94KCkud2lkdGgsXG4gICAgICAgICAgICB6ID0gcS5nZXRTbG90V2lkdGgodGhpcyksXG4gICAgICAgICAgICB3ID0geixcbiAgICAgICAgICAgIEIgPSAxLFxuICAgICAgICAgICAgTCxcbiAgICAgICAgICAgIHQgPSB7fTtcbiAgICAgICAgaWYgKGEgfHwgXCJqdXN0aWZ5XCIgIT09IHkoaC5vdmVyZmxvdywgXCJqdXN0aWZ5XCIpKSAwID4gYSAmJiBlIC0gbCAqIHYgPCBuID8gTCA9IE1hdGgucm91bmQoZSAvIE1hdGguY29zKGEgKiBEKSAtIG4pIDogMCA8IGEgJiYgZSArIGwgKiB2ID4gayAmJiAoTCA9IE1hdGgucm91bmQoKGMgLSBlKSAvIE1hdGguY29zKGEgKiBEKSkpO2Vsc2UgaWYgKGMgPSBlICsgKDEgLSBsKSAqIHYsIGUgLSBsICogdiA8IG4gPyB3ID0gZC54ICsgdyAqICgxIC0gbCkgLSBuIDogYyA+IGsgJiYgKHcgPSBrIC0gZC54ICsgdyAqIGwsIEIgPSAtMSksIHcgPSBNYXRoLm1pbih6LCB3KSwgdyA8IHogJiYgXCJjZW50ZXJcIiA9PT0gcS5sYWJlbEFsaWduICYmIChkLnggKz0gQiAqICh6IC0gdyAtIGwgKiAoeiAtIE1hdGgubWluKHYsIHcpKSkpLCB2ID4gdyB8fCBxLmF1dG9Sb3RhdGlvbiAmJiAoZi5zdHlsZXMgfHwge30pLndpZHRoKSBMID0gdztcbiAgICAgICAgTCAmJiAodGhpcy5zaG9ydGVuTGFiZWwgPyB0aGlzLnNob3J0ZW5MYWJlbCgpIDogKHQud2lkdGggPSBNYXRoLmZsb29yKEwpLCAoaC5zdHlsZSB8fCB7fSkudGV4dE92ZXJmbG93IHx8ICh0LnRleHRPdmVyZmxvdyA9IFwiZWxsaXBzaXNcIiksIGYuY3NzKHQpKSk7XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5tb3ZlTGFiZWwgPSBmdW5jdGlvbiAoZCwgcSkge1xuICAgICAgICB2YXIgaCA9IHRoaXMsXG4gICAgICAgICAgICBlID0gaC5sYWJlbCxcbiAgICAgICAgICAgIGMgPSAhMSxcbiAgICAgICAgICAgIGsgPSBoLmF4aXMsXG4gICAgICAgICAgICBuID0gay5yZXZlcnNlZCxcbiAgICAgICAgICAgIGYgPSBrLmNoYXJ0LmludmVydGVkO1xuICAgICAgICBlICYmIGUudGV4dFN0ciA9PT0gZCA/IChoLm1vdmVkTGFiZWwgPSBlLCBjID0gITAsIGRlbGV0ZSBoLmxhYmVsKSA6IEooay50aWNrcywgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBjIHx8IGEuaXNOZXcgfHwgYSA9PT0gaCB8fCAhYS5sYWJlbCB8fCBhLmxhYmVsLnRleHRTdHIgIT09IGQgfHwgKGgubW92ZWRMYWJlbCA9IGEubGFiZWwsIGMgPSAhMCwgYS5sYWJlbFBvcyA9IGgubW92ZWRMYWJlbC54eSwgZGVsZXRlIGEubGFiZWwpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWMgJiYgKGgubGFiZWxQb3MgfHwgZSkpIHtcbiAgICAgICAgICB2YXIgYSA9IGgubGFiZWxQb3MgfHwgZS54eTtcbiAgICAgICAgICBlID0gZiA/IGEueCA6IG4gPyAwIDogay53aWR0aCArIGsubGVmdDtcbiAgICAgICAgICBrID0gZiA/IG4gPyBrLndpZHRoICsgay5sZWZ0IDogMCA6IGEueTtcbiAgICAgICAgICBoLm1vdmVkTGFiZWwgPSBoLmNyZWF0ZUxhYmVsKHtcbiAgICAgICAgICAgIHg6IGUsXG4gICAgICAgICAgICB5OiBrXG4gICAgICAgICAgfSwgZCwgcSk7XG4gICAgICAgICAgaC5tb3ZlZExhYmVsICYmIGgubW92ZWRMYWJlbC5hdHRyKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGgsIHEsIHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmF4aXMsXG4gICAgICAgICAgICBjID0gZS5ob3JpeixcbiAgICAgICAgICAgIGsgPSB0aGlzLnBvcyxcbiAgICAgICAgICAgIG4gPSB5KHRoaXMudGlja21hcmtPZmZzZXQsIGUudGlja21hcmtPZmZzZXQpO1xuICAgICAgICBrID0gdGhpcy5nZXRQb3NpdGlvbihjLCBrLCBuLCBxKTtcbiAgICAgICAgbiA9IGsueDtcbiAgICAgICAgdmFyIGYgPSBrLnk7XG4gICAgICAgIGUgPSBjICYmIG4gPT09IGUucG9zICsgZS5sZW4gfHwgIWMgJiYgZiA9PT0gZS5wb3MgPyAtMSA6IDE7XG4gICAgICAgIHQgPSB5KHQsIDEpO1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gITA7XG4gICAgICAgIHRoaXMucmVuZGVyR3JpZExpbmUocSwgdCwgZSk7XG4gICAgICAgIHRoaXMucmVuZGVyTWFyayhrLCB0LCBlKTtcbiAgICAgICAgdGhpcy5yZW5kZXJMYWJlbChrLCBxLCB0LCBoKTtcbiAgICAgICAgdGhpcy5pc05ldyA9ICExO1xuICAgICAgICBkLmZpcmVFdmVudCh0aGlzLCBcImFmdGVyUmVuZGVyXCIpO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUucmVuZGVyR3JpZExpbmUgPSBmdW5jdGlvbiAoZCwgcSwgaCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuYXhpcyxcbiAgICAgICAgICAgIGMgPSBlLm9wdGlvbnMsXG4gICAgICAgICAgICBrID0gdGhpcy5ncmlkTGluZSxcbiAgICAgICAgICAgIG4gPSB7fSxcbiAgICAgICAgICAgIGYgPSB0aGlzLnBvcyxcbiAgICAgICAgICAgIGEgPSB0aGlzLnR5cGUsXG4gICAgICAgICAgICBsID0geSh0aGlzLnRpY2ttYXJrT2Zmc2V0LCBlLnRpY2ttYXJrT2Zmc2V0KSxcbiAgICAgICAgICAgIHYgPSBlLmNoYXJ0LnJlbmRlcmVyLFxuICAgICAgICAgICAgeiA9IGEgPyBhICsgXCJHcmlkXCIgOiBcImdyaWRcIixcbiAgICAgICAgICAgIHcgPSBjW3ogKyBcIkxpbmVXaWR0aFwiXSxcbiAgICAgICAgICAgIEIgPSBjW3ogKyBcIkxpbmVDb2xvclwiXTtcbiAgICAgICAgYyA9IGNbeiArIFwiTGluZURhc2hTdHlsZVwiXTtcbiAgICAgICAgayB8fCAoZS5jaGFydC5zdHlsZWRNb2RlIHx8IChuLnN0cm9rZSA9IEIsIG5bXCJzdHJva2Utd2lkdGhcIl0gPSB3LCBjICYmIChuLmRhc2hzdHlsZSA9IGMpKSwgYSB8fCAobi56SW5kZXggPSAxKSwgZCAmJiAocSA9IDApLCB0aGlzLmdyaWRMaW5lID0gayA9IHYucGF0aCgpLmF0dHIobikuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLVwiICsgKGEgPyBhICsgXCItXCIgOiBcIlwiKSArIFwiZ3JpZC1saW5lXCIpLmFkZChlLmdyaWRHcm91cCkpO1xuICAgICAgICBpZiAoayAmJiAoaCA9IGUuZ2V0UGxvdExpbmVQYXRoKHtcbiAgICAgICAgICB2YWx1ZTogZiArIGwsXG4gICAgICAgICAgbGluZVdpZHRoOiBrLnN0cm9rZVdpZHRoKCkgKiBoLFxuICAgICAgICAgIGZvcmNlOiBcInBhc3NcIixcbiAgICAgICAgICBvbGQ6IGRcbiAgICAgICAgfSkpKSBrW2QgfHwgdGhpcy5pc05ldyA/IFwiYXR0clwiIDogXCJhbmltYXRlXCJdKHtcbiAgICAgICAgICBkOiBoLFxuICAgICAgICAgIG9wYWNpdHk6IHFcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5yZW5kZXJNYXJrID0gZnVuY3Rpb24gKGQsIHEsIGgpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmF4aXMsXG4gICAgICAgICAgICBjID0gZS5vcHRpb25zLFxuICAgICAgICAgICAgayA9IGUuY2hhcnQucmVuZGVyZXIsXG4gICAgICAgICAgICBuID0gdGhpcy50eXBlLFxuICAgICAgICAgICAgZiA9IG4gPyBuICsgXCJUaWNrXCIgOiBcInRpY2tcIixcbiAgICAgICAgICAgIGEgPSBlLnRpY2tTaXplKGYpLFxuICAgICAgICAgICAgbCA9IHRoaXMubWFyayxcbiAgICAgICAgICAgIHYgPSAhbCxcbiAgICAgICAgICAgIHogPSBkLng7XG4gICAgICAgIGQgPSBkLnk7XG4gICAgICAgIHZhciB3ID0geShjW2YgKyBcIldpZHRoXCJdLCAhbiAmJiBlLmlzWEF4aXMgPyAxIDogMCk7XG4gICAgICAgIGMgPSBjW2YgKyBcIkNvbG9yXCJdO1xuICAgICAgICBhICYmIChlLm9wcG9zaXRlICYmIChhWzBdID0gLWFbMF0pLCB2ICYmICh0aGlzLm1hcmsgPSBsID0gay5wYXRoKCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLVwiICsgKG4gPyBuICsgXCItXCIgOiBcIlwiKSArIFwidGlja1wiKS5hZGQoZS5heGlzR3JvdXApLCBlLmNoYXJ0LnN0eWxlZE1vZGUgfHwgbC5hdHRyKHtcbiAgICAgICAgICBzdHJva2U6IGMsXG4gICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogd1xuICAgICAgICB9KSksIGxbdiA/IFwiYXR0clwiIDogXCJhbmltYXRlXCJdKHtcbiAgICAgICAgICBkOiB0aGlzLmdldE1hcmtQYXRoKHosIGQsIGFbMF0sIGwuc3Ryb2tlV2lkdGgoKSAqIGgsIGUuaG9yaXosIGspLFxuICAgICAgICAgIG9wYWNpdHk6IHFcbiAgICAgICAgfSkpO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUucmVuZGVyTGFiZWwgPSBmdW5jdGlvbiAoZCwgcSwgaCwgZSkge1xuICAgICAgICB2YXIgYyA9IHRoaXMuYXhpcyxcbiAgICAgICAgICAgIGsgPSBjLmhvcml6LFxuICAgICAgICAgICAgbiA9IGMub3B0aW9ucyxcbiAgICAgICAgICAgIGYgPSB0aGlzLmxhYmVsLFxuICAgICAgICAgICAgYSA9IG4ubGFiZWxzLFxuICAgICAgICAgICAgbCA9IGEuc3RlcDtcbiAgICAgICAgYyA9IHkodGhpcy50aWNrbWFya09mZnNldCwgYy50aWNrbWFya09mZnNldCk7XG4gICAgICAgIHZhciB2ID0gITAsXG4gICAgICAgICAgICB6ID0gZC54O1xuICAgICAgICBkID0gZC55O1xuICAgICAgICBmICYmIEEoeikgJiYgKGYueHkgPSBkID0gdGhpcy5nZXRMYWJlbFBvc2l0aW9uKHosIGQsIGYsIGssIGEsIGMsIGUsIGwpLCB0aGlzLmlzRmlyc3QgJiYgIXRoaXMuaXNMYXN0ICYmICF5KG4uc2hvd0ZpcnN0TGFiZWwsIDEpIHx8IHRoaXMuaXNMYXN0ICYmICF0aGlzLmlzRmlyc3QgJiYgIXkobi5zaG93TGFzdExhYmVsLCAxKSA/IHYgPSAhMSA6ICFrIHx8IGEuc3RlcCB8fCBhLnJvdGF0aW9uIHx8IHEgfHwgMCA9PT0gaCB8fCB0aGlzLmhhbmRsZU92ZXJmbG93KGQpLCBsICYmIGUgJSBsICYmICh2ID0gITEpLCB2ICYmIEEoZC55KSA/IChkLm9wYWNpdHkgPSBoLCBmW3RoaXMuaXNOZXdMYWJlbCA/IFwiYXR0clwiIDogXCJhbmltYXRlXCJdKGQpLCB0aGlzLmlzTmV3TGFiZWwgPSAhMSkgOiAoZi5hdHRyKFwieVwiLCAtOTk5OSksIHRoaXMuaXNOZXdMYWJlbCA9ICEwKSk7XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5yZXBsYWNlTW92ZWRMYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLmxhYmVsLFxuICAgICAgICAgICAgcSA9IHRoaXMuYXhpcyxcbiAgICAgICAgICAgIGggPSBxLnJldmVyc2VkLFxuICAgICAgICAgICAgZSA9IHRoaXMuYXhpcy5jaGFydC5pbnZlcnRlZDtcblxuICAgICAgICBpZiAoZCAmJiAhdGhpcy5pc05ldykge1xuICAgICAgICAgIHZhciBjID0gZSA/IGQueHkueCA6IGggPyBxLmxlZnQgOiBxLndpZHRoICsgcS5sZWZ0O1xuICAgICAgICAgIGggPSBlID8gaCA/IHEud2lkdGggKyBxLnRvcCA6IHEudG9wIDogZC54eS55O1xuICAgICAgICAgIGQuYW5pbWF0ZSh7XG4gICAgICAgICAgICB4OiBjLFxuICAgICAgICAgICAgeTogaCxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LCB2b2lkIDAsIGQuZGVzdHJveSk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMubGFiZWw7XG4gICAgICAgIH1cblxuICAgICAgICBxLmlzRGlydHkgPSAhMDtcbiAgICAgICAgdGhpcy5sYWJlbCA9IHRoaXMubW92ZWRMYWJlbDtcbiAgICAgICAgZGVsZXRlIHRoaXMubW92ZWRMYWJlbDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBoO1xuICAgIH0oKTtcblxuICAgIGQuVGljayA9IGc7XG4gICAgcmV0dXJuIGQuVGljaztcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9UaW1lLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgdmFyIHIgPSBnLmRlZmluZWQsXG4gICAgICAgIHUgPSBnLmVycm9yLFxuICAgICAgICBJID0gZy5leHRlbmQsXG4gICAgICAgIE0gPSBnLmlzT2JqZWN0LFxuICAgICAgICBFID0gZy5tZXJnZSxcbiAgICAgICAgQSA9IGcub2JqZWN0RWFjaCxcbiAgICAgICAgRyA9IGcucGFkLFxuICAgICAgICBKID0gZy5waWNrLFxuICAgICAgICB5ID0gZy5zcGxhdCxcbiAgICAgICAgdCA9IGcudGltZVVuaXRzLFxuICAgICAgICBEID0gZC53aW47XG5cbiAgICBnID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gaChkKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLnZhcmlhYmxlVGltZXpvbmUgPSB0aGlzLnVzZVVUQyA9ICExO1xuICAgICAgICB0aGlzLkRhdGUgPSBELkRhdGU7XG4gICAgICAgIHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQgPSB0aGlzLnRpbWV6b25lT2Zmc2V0RnVuY3Rpb24oKTtcbiAgICAgICAgdGhpcy51cGRhdGUoZCk7XG4gICAgICB9XG5cbiAgICAgIGgucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChkLCBxKSB7XG4gICAgICAgIGlmICh0aGlzLnZhcmlhYmxlVGltZXpvbmUgfHwgdGhpcy50aW1lem9uZU9mZnNldCkge1xuICAgICAgICAgIHZhciBoID0gcS5nZXRUaW1lKCksXG4gICAgICAgICAgICAgIGUgPSBoIC0gdGhpcy5nZXRUaW1lem9uZU9mZnNldChxKTtcbiAgICAgICAgICBxLnNldFRpbWUoZSk7XG4gICAgICAgICAgZCA9IHFbXCJnZXRVVENcIiArIGRdKCk7XG4gICAgICAgICAgcS5zZXRUaW1lKGgpO1xuICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXNlVVRDID8gcVtcImdldFVUQ1wiICsgZF0oKSA6IHFbXCJnZXRcIiArIGRdKCk7XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoZCwgcSwgaCkge1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZVRpbWV6b25lIHx8IHRoaXMudGltZXpvbmVPZmZzZXQpIHtcbiAgICAgICAgICBpZiAoXCJNaWxsaXNlY29uZHNcIiA9PT0gZCB8fCBcIlNlY29uZHNcIiA9PT0gZCB8fCBcIk1pbnV0ZXNcIiA9PT0gZCkgcmV0dXJuIHFbXCJzZXRVVENcIiArIGRdKGgpO1xuICAgICAgICAgIHZhciBlID0gdGhpcy5nZXRUaW1lem9uZU9mZnNldChxKTtcbiAgICAgICAgICBlID0gcS5nZXRUaW1lKCkgLSBlO1xuICAgICAgICAgIHEuc2V0VGltZShlKTtcbiAgICAgICAgICBxW1wic2V0VVRDXCIgKyBkXShoKTtcbiAgICAgICAgICBkID0gdGhpcy5nZXRUaW1lem9uZU9mZnNldChxKTtcbiAgICAgICAgICBlID0gcS5nZXRUaW1lKCkgKyBkO1xuICAgICAgICAgIHJldHVybiBxLnNldFRpbWUoZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy51c2VVVEMgPyBxW1wic2V0VVRDXCIgKyBkXShoKSA6IHFbXCJzZXRcIiArIGRdKGgpO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIHEgPSBKKGQgJiYgZC51c2VVVEMsICEwKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZCA9IEUoITAsIHRoaXMub3B0aW9ucyB8fCB7fSwgZCk7XG4gICAgICAgIHRoaXMuRGF0ZSA9IGQuRGF0ZSB8fCBELkRhdGUgfHwgRGF0ZTtcbiAgICAgICAgdGhpcy50aW1lem9uZU9mZnNldCA9ICh0aGlzLnVzZVVUQyA9IHEpICYmIGQudGltZXpvbmVPZmZzZXQ7XG4gICAgICAgIHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQgPSB0aGlzLnRpbWV6b25lT2Zmc2V0RnVuY3Rpb24oKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZVRpbWV6b25lID0gIShxICYmICFkLmdldFRpbWV6b25lT2Zmc2V0ICYmICFkLnRpbWV6b25lKTtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLm1ha2VUaW1lID0gZnVuY3Rpb24gKGgsIHEsIHQsIGUsIGMsIGspIHtcbiAgICAgICAgaWYgKHRoaXMudXNlVVRDKSB7XG4gICAgICAgICAgdmFyIG4gPSB0aGlzLkRhdGUuVVRDLmFwcGx5KDAsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgdmFyIGYgPSB0aGlzLmdldFRpbWV6b25lT2Zmc2V0KG4pO1xuICAgICAgICAgIG4gKz0gZjtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQobik7XG4gICAgICAgICAgZiAhPT0gYSA/IG4gKz0gYSAtIGYgOiBmIC0gMzZFNSAhPT0gdGhpcy5nZXRUaW1lem9uZU9mZnNldChuIC0gMzZFNSkgfHwgZC5pc1NhZmFyaSB8fCAobiAtPSAzNkU1KTtcbiAgICAgICAgfSBlbHNlIG4gPSBuZXcgdGhpcy5EYXRlKGgsIHEsIEoodCwgMSksIEooZSwgMCksIEooYywgMCksIEooaywgMCkpLmdldFRpbWUoKTtcblxuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLnRpbWV6b25lT2Zmc2V0RnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICAgIHEgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBoID0gRC5tb21lbnQ7XG4gICAgICAgIGlmICghdGhpcy51c2VVVEMpIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiA2RTQgKiBuZXcgRGF0ZShlLnRvU3RyaW5nKCkpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHEudGltZXpvbmUpIHtcbiAgICAgICAgICBpZiAoaCkgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gNkU0ICogLWgudHooZSwgcS50aW1lem9uZSkudXRjT2Zmc2V0KCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB1KDI1KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnVzZVVUQyAmJiBxLmdldFRpbWV6b25lT2Zmc2V0ID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gNkU0ICogcS5nZXRUaW1lem9uZU9mZnNldChlLnZhbHVlT2YoKSk7XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIDZFNCAqIChkLnRpbWV6b25lT2Zmc2V0IHx8IDApO1xuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUuZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIChoLCBxLCB0KSB7XG4gICAgICAgIHZhciBlO1xuICAgICAgICBpZiAoIXIocSkgfHwgaXNOYU4ocSkpIHJldHVybiAobnVsbCA9PT0gKGUgPSBkLmRlZmF1bHRPcHRpb25zLmxhbmcpIHx8IHZvaWQgMCA9PT0gZSA/IHZvaWQgMCA6IGUuaW52YWxpZERhdGUpIHx8IFwiXCI7XG4gICAgICAgIGggPSBKKGgsIFwiJVktJW0tJWQgJUg6JU06JVNcIik7XG4gICAgICAgIHZhciBjID0gdGhpcztcbiAgICAgICAgZSA9IG5ldyB0aGlzLkRhdGUocSk7XG4gICAgICAgIHZhciBrID0gdGhpcy5nZXQoXCJIb3Vyc1wiLCBlKSxcbiAgICAgICAgICAgIG4gPSB0aGlzLmdldChcIkRheVwiLCBlKSxcbiAgICAgICAgICAgIGYgPSB0aGlzLmdldChcIkRhdGVcIiwgZSksXG4gICAgICAgICAgICBhID0gdGhpcy5nZXQoXCJNb250aFwiLCBlKSxcbiAgICAgICAgICAgIGwgPSB0aGlzLmdldChcIkZ1bGxZZWFyXCIsIGUpLFxuICAgICAgICAgICAgdiA9IGQuZGVmYXVsdE9wdGlvbnMubGFuZyxcbiAgICAgICAgICAgIHogPSBudWxsID09PSB2IHx8IHZvaWQgMCA9PT0gdiA/IHZvaWQgMCA6IHYud2Vla2RheXMsXG4gICAgICAgICAgICB3ID0gbnVsbCA9PT0gdiB8fCB2b2lkIDAgPT09IHYgPyB2b2lkIDAgOiB2LnNob3J0V2Vla2RheXM7XG4gICAgICAgIGUgPSBJKHtcbiAgICAgICAgICBhOiB3ID8gd1tuXSA6IHpbbl0uc3Vic3RyKDAsIDMpLFxuICAgICAgICAgIEE6IHpbbl0sXG4gICAgICAgICAgZDogRyhmKSxcbiAgICAgICAgICBlOiBHKGYsIDIsIFwiIFwiKSxcbiAgICAgICAgICB3OiBuLFxuICAgICAgICAgIGI6IHYuc2hvcnRNb250aHNbYV0sXG4gICAgICAgICAgQjogdi5tb250aHNbYV0sXG4gICAgICAgICAgbTogRyhhICsgMSksXG4gICAgICAgICAgbzogYSArIDEsXG4gICAgICAgICAgeTogbC50b1N0cmluZygpLnN1YnN0cigyLCAyKSxcbiAgICAgICAgICBZOiBsLFxuICAgICAgICAgIEg6IEcoayksXG4gICAgICAgICAgazogayxcbiAgICAgICAgICBJOiBHKGsgJSAxMiB8fCAxMiksXG4gICAgICAgICAgbDogayAlIDEyIHx8IDEyLFxuICAgICAgICAgIE06IEcodGhpcy5nZXQoXCJNaW51dGVzXCIsIGUpKSxcbiAgICAgICAgICBwOiAxMiA+IGsgPyBcIkFNXCIgOiBcIlBNXCIsXG4gICAgICAgICAgUDogMTIgPiBrID8gXCJhbVwiIDogXCJwbVwiLFxuICAgICAgICAgIFM6IEcoZS5nZXRTZWNvbmRzKCkpLFxuICAgICAgICAgIEw6IEcoTWF0aC5mbG9vcihxICUgMUUzKSwgMylcbiAgICAgICAgfSwgZC5kYXRlRm9ybWF0cyk7XG4gICAgICAgIEEoZSwgZnVuY3Rpb24gKGEsIGYpIHtcbiAgICAgICAgICBmb3IgKDsgLTEgIT09IGguaW5kZXhPZihcIiVcIiArIGYpOykgaCA9IGgucmVwbGFjZShcIiVcIiArIGYsIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGEgPyBhLmNhbGwoYywgcSkgOiBhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0ID8gaC5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSArIGguc3Vic3RyKDEpIDogaDtcbiAgICAgIH07XG5cbiAgICAgIGgucHJvdG90eXBlLnJlc29sdmVEVExGb3JtYXQgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gTShkLCAhMCkgPyBkIDogKGQgPSB5KGQpLCB7XG4gICAgICAgICAgbWFpbjogZFswXSxcbiAgICAgICAgICBmcm9tOiBkWzFdLFxuICAgICAgICAgIHRvOiBkWzJdXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUuZ2V0VGltZVRpY2tzID0gZnVuY3Rpb24gKGQsIGgsIGcsIGUpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLFxuICAgICAgICAgICAgayA9IFtdLFxuICAgICAgICAgICAgbiA9IHt9O1xuICAgICAgICB2YXIgZiA9IG5ldyBjLkRhdGUoaCk7XG4gICAgICAgIHZhciBhID0gZC51bml0UmFuZ2UsXG4gICAgICAgICAgICBsID0gZC5jb3VudCB8fCAxLFxuICAgICAgICAgICAgdjtcbiAgICAgICAgZSA9IEooZSwgMSk7XG5cbiAgICAgICAgaWYgKHIoaCkpIHtcbiAgICAgICAgICBjLnNldChcIk1pbGxpc2Vjb25kc1wiLCBmLCBhID49IHQuc2Vjb25kID8gMCA6IGwgKiBNYXRoLmZsb29yKGMuZ2V0KFwiTWlsbGlzZWNvbmRzXCIsIGYpIC8gbCkpO1xuICAgICAgICAgIGEgPj0gdC5zZWNvbmQgJiYgYy5zZXQoXCJTZWNvbmRzXCIsIGYsIGEgPj0gdC5taW51dGUgPyAwIDogbCAqIE1hdGguZmxvb3IoYy5nZXQoXCJTZWNvbmRzXCIsIGYpIC8gbCkpO1xuICAgICAgICAgIGEgPj0gdC5taW51dGUgJiYgYy5zZXQoXCJNaW51dGVzXCIsIGYsIGEgPj0gdC5ob3VyID8gMCA6IGwgKiBNYXRoLmZsb29yKGMuZ2V0KFwiTWludXRlc1wiLCBmKSAvIGwpKTtcbiAgICAgICAgICBhID49IHQuaG91ciAmJiBjLnNldChcIkhvdXJzXCIsIGYsIGEgPj0gdC5kYXkgPyAwIDogbCAqIE1hdGguZmxvb3IoYy5nZXQoXCJIb3Vyc1wiLCBmKSAvIGwpKTtcbiAgICAgICAgICBhID49IHQuZGF5ICYmIGMuc2V0KFwiRGF0ZVwiLCBmLCBhID49IHQubW9udGggPyAxIDogTWF0aC5tYXgoMSwgbCAqIE1hdGguZmxvb3IoYy5nZXQoXCJEYXRlXCIsIGYpIC8gbCkpKTtcblxuICAgICAgICAgIGlmIChhID49IHQubW9udGgpIHtcbiAgICAgICAgICAgIGMuc2V0KFwiTW9udGhcIiwgZiwgYSA+PSB0LnllYXIgPyAwIDogbCAqIE1hdGguZmxvb3IoYy5nZXQoXCJNb250aFwiLCBmKSAvIGwpKTtcbiAgICAgICAgICAgIHZhciB6ID0gYy5nZXQoXCJGdWxsWWVhclwiLCBmKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhID49IHQueWVhciAmJiBjLnNldChcIkZ1bGxZZWFyXCIsIGYsIHogLSB6ICUgbCk7XG4gICAgICAgICAgYSA9PT0gdC53ZWVrICYmICh6ID0gYy5nZXQoXCJEYXlcIiwgZiksIGMuc2V0KFwiRGF0ZVwiLCBmLCBjLmdldChcIkRhdGVcIiwgZikgLSB6ICsgZSArICh6IDwgZSA/IC03IDogMCkpKTtcbiAgICAgICAgICB6ID0gYy5nZXQoXCJGdWxsWWVhclwiLCBmKTtcbiAgICAgICAgICBlID0gYy5nZXQoXCJNb250aFwiLCBmKTtcbiAgICAgICAgICB2YXIgdyA9IGMuZ2V0KFwiRGF0ZVwiLCBmKSxcbiAgICAgICAgICAgICAgcSA9IGMuZ2V0KFwiSG91cnNcIiwgZik7XG4gICAgICAgICAgaCA9IGYuZ2V0VGltZSgpO1xuICAgICAgICAgIGMudmFyaWFibGVUaW1lem9uZSAmJiAodiA9IGcgLSBoID4gNCAqIHQubW9udGggfHwgYy5nZXRUaW1lem9uZU9mZnNldChoKSAhPT0gYy5nZXRUaW1lem9uZU9mZnNldChnKSk7XG4gICAgICAgICAgaCA9IGYuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgZm9yIChmID0gMTsgaCA8IGc7KSBrLnB1c2goaCksIGggPSBhID09PSB0LnllYXIgPyBjLm1ha2VUaW1lKHogKyBmICogbCwgMCkgOiBhID09PSB0Lm1vbnRoID8gYy5tYWtlVGltZSh6LCBlICsgZiAqIGwpIDogIXYgfHwgYSAhPT0gdC5kYXkgJiYgYSAhPT0gdC53ZWVrID8gdiAmJiBhID09PSB0LmhvdXIgJiYgMSA8IGwgPyBjLm1ha2VUaW1lKHosIGUsIHcsIHEgKyBmICogbCkgOiBoICsgYSAqIGwgOiBjLm1ha2VUaW1lKHosIGUsIHcgKyBmICogbCAqIChhID09PSB0LmRheSA/IDEgOiA3KSksIGYrKztcblxuICAgICAgICAgIGsucHVzaChoKTtcbiAgICAgICAgICBhIDw9IHQuaG91ciAmJiAxRTQgPiBrLmxlbmd0aCAmJiBrLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIDAgPT09IGEgJSAxOEU1ICYmIFwiMDAwMDAwMDAwXCIgPT09IGMuZGF0ZUZvcm1hdChcIiVIJU0lUyVMXCIsIGEpICYmIChuW2FdID0gXCJkYXlcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBrLmluZm8gPSBJKGQsIHtcbiAgICAgICAgICBoaWdoZXJSYW5rczogbixcbiAgICAgICAgICB0b3RhbFJhbmdlOiBhICogbFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGs7XG4gICAgICB9O1xuXG4gICAgICBoLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICBEYXRlOiB2b2lkIDAsXG4gICAgICAgIGdldFRpbWV6b25lT2Zmc2V0OiB2b2lkIDAsXG4gICAgICAgIHRpbWV6b25lOiB2b2lkIDAsXG4gICAgICAgIHRpbWV6b25lT2Zmc2V0OiAwLFxuICAgICAgICB1c2VVVEM6ICEwXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGg7XG4gICAgfSgpO1xuXG4gICAgZC5UaW1lID0gZztcbiAgICByZXR1cm4gZC5UaW1lO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL09wdGlvbnMuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvVGltZS5qc1wiXSwgcltcInBhcnRzL0NvbG9yLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcsIHIsIHUpIHtcbiAgICByID0gci5wYXJzZTtcbiAgICB2YXIgSSA9IHUubWVyZ2U7XG4gICAgZC5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGNvbG9yczogXCIjN2NiNWVjICM0MzQzNDggIzkwZWQ3ZCAjZjdhMzVjICM4MDg1ZTkgI2YxNWM4MCAjZTRkMzU0ICMyYjkwOGYgI2Y0NWI1YiAjOTFlOGUxXCIuc3BsaXQoXCIgXCIpLFxuICAgICAgc3ltYm9sczogW1wiY2lyY2xlXCIsIFwiZGlhbW9uZFwiLCBcInNxdWFyZVwiLCBcInRyaWFuZ2xlXCIsIFwidHJpYW5nbGUtZG93blwiXSxcbiAgICAgIGxhbmc6IHtcbiAgICAgICAgbG9hZGluZzogXCJMb2FkaW5nLi4uXCIsXG4gICAgICAgIG1vbnRoczogXCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpLFxuICAgICAgICBzaG9ydE1vbnRoczogXCJKYW4gRmViIE1hciBBcHIgTWF5IEp1biBKdWwgQXVnIFNlcCBPY3QgTm92IERlY1wiLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgd2Vla2RheXM6IFwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksXG4gICAgICAgIGRlY2ltYWxQb2ludDogXCIuXCIsXG4gICAgICAgIG51bWVyaWNTeW1ib2xzOiBcImtNR1RQRVwiLnNwbGl0KFwiXCIpLFxuICAgICAgICByZXNldFpvb206IFwiUmVzZXQgem9vbVwiLFxuICAgICAgICByZXNldFpvb21UaXRsZTogXCJSZXNldCB6b29tIGxldmVsIDE6MVwiLFxuICAgICAgICB0aG91c2FuZHNTZXA6IFwiIFwiXG4gICAgICB9LFxuICAgICAgZ2xvYmFsOiB7fSxcbiAgICAgIHRpbWU6IGcuZGVmYXVsdE9wdGlvbnMsXG4gICAgICBjaGFydDoge1xuICAgICAgICBzdHlsZWRNb2RlOiAhMSxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgICBjb2xvckNvdW50OiAxMCxcbiAgICAgICAgZGVmYXVsdFNlcmllc1R5cGU6IFwibGluZVwiLFxuICAgICAgICBpZ25vcmVIaWRkZW5TZXJpZXM6ICEwLFxuICAgICAgICBzcGFjaW5nOiBbMTAsIDEwLCAxNSwgMTBdLFxuICAgICAgICByZXNldFpvb21CdXR0b246IHtcbiAgICAgICAgICB0aGVtZToge1xuICAgICAgICAgICAgekluZGV4OiA2XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgYWxpZ246IFwicmlnaHRcIixcbiAgICAgICAgICAgIHg6IC0xMCxcbiAgICAgICAgICAgIHk6IDEwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3aWR0aDogbnVsbCxcbiAgICAgICAgaGVpZ2h0OiBudWxsLFxuICAgICAgICBib3JkZXJDb2xvcjogXCIjMzM1Y2FkXCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZmZmZmZmXCIsXG4gICAgICAgIHBsb3RCb3JkZXJDb2xvcjogXCIjY2NjY2NjXCJcbiAgICAgIH0sXG4gICAgICB0aXRsZToge1xuICAgICAgICB0ZXh0OiBcIkNoYXJ0IHRpdGxlXCIsXG4gICAgICAgIGFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICBtYXJnaW46IDE1LFxuICAgICAgICB3aWR0aEFkanVzdDogLTQ0XG4gICAgICB9LFxuICAgICAgc3VidGl0bGU6IHtcbiAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgYWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgIHdpZHRoQWRqdXN0OiAtNDRcbiAgICAgIH0sXG4gICAgICBjYXB0aW9uOiB7XG4gICAgICAgIG1hcmdpbjogMTUsXG4gICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgIGFsaWduOiBcImxlZnRcIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJib3R0b21cIlxuICAgICAgfSxcbiAgICAgIHBsb3RPcHRpb25zOiB7fSxcbiAgICAgIGxhYmVsczoge1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgY29sb3I6IFwiIzMzMzMzM1wiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZW5hYmxlZDogITAsXG4gICAgICAgIGFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICBhbGlnbkNvbHVtbnM6ICEwLFxuICAgICAgICBsYXlvdXQ6IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgICBsYWJlbEZvcm1hdHRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGJvcmRlckNvbG9yOiBcIiM5OTk5OTlcIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgICBuYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgYWN0aXZlQ29sb3I6IFwiIzAwMzM5OVwiLFxuICAgICAgICAgIGluYWN0aXZlQ29sb3I6IFwiI2NjY2NjY1wiXG4gICAgICAgIH0sXG4gICAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICAgIGNvbG9yOiBcIiMzMzMzMzNcIixcbiAgICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgICAgICAgIGZvbnRTaXplOiBcIjEycHhcIixcbiAgICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIixcbiAgICAgICAgICB0ZXh0T3ZlcmZsb3c6IFwiZWxsaXBzaXNcIlxuICAgICAgICB9LFxuICAgICAgICBpdGVtSG92ZXJTdHlsZToge1xuICAgICAgICAgIGNvbG9yOiBcIiMwMDAwMDBcIlxuICAgICAgICB9LFxuICAgICAgICBpdGVtSGlkZGVuU3R5bGU6IHtcbiAgICAgICAgICBjb2xvcjogXCIjY2NjY2NjXCJcbiAgICAgICAgfSxcbiAgICAgICAgc2hhZG93OiAhMSxcbiAgICAgICAgaXRlbUNoZWNrYm94U3R5bGU6IHtcbiAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgIHdpZHRoOiBcIjEzcHhcIixcbiAgICAgICAgICBoZWlnaHQ6IFwiMTNweFwiXG4gICAgICAgIH0sXG4gICAgICAgIHNxdWFyZVN5bWJvbDogITAsXG4gICAgICAgIHN5bWJvbFBhZGRpbmc6IDUsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwiYm90dG9tXCIsXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbG9hZGluZzoge1xuICAgICAgICBsYWJlbFN0eWxlOiB7XG4gICAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIsXG4gICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgICB0b3A6IFwiNDUlXCJcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZmZmZmZmXCIsXG4gICAgICAgICAgb3BhY2l0eTogLjUsXG4gICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b29sdGlwOiB7XG4gICAgICAgIGVuYWJsZWQ6ICEwLFxuICAgICAgICBhbmltYXRpb246IGQuc3ZnLFxuICAgICAgICBib3JkZXJSYWRpdXM6IDMsXG4gICAgICAgIGRhdGVUaW1lTGFiZWxGb3JtYXRzOiB7XG4gICAgICAgICAgbWlsbGlzZWNvbmQ6IFwiJUEsICViICVlLCAlSDolTTolUy4lTFwiLFxuICAgICAgICAgIHNlY29uZDogXCIlQSwgJWIgJWUsICVIOiVNOiVTXCIsXG4gICAgICAgICAgbWludXRlOiBcIiVBLCAlYiAlZSwgJUg6JU1cIixcbiAgICAgICAgICBob3VyOiBcIiVBLCAlYiAlZSwgJUg6JU1cIixcbiAgICAgICAgICBkYXk6IFwiJUEsICViICVlLCAlWVwiLFxuICAgICAgICAgIHdlZWs6IFwiV2VlayBmcm9tICVBLCAlYiAlZSwgJVlcIixcbiAgICAgICAgICBtb250aDogXCIlQiAlWVwiLFxuICAgICAgICAgIHllYXI6IFwiJVlcIlxuICAgICAgICB9LFxuICAgICAgICBmb290ZXJGb3JtYXQ6IFwiXCIsXG4gICAgICAgIHBhZGRpbmc6IDgsXG4gICAgICAgIHNuYXA6IGQuaXNUb3VjaERldmljZSA/IDI1IDogMTAsXG4gICAgICAgIGhlYWRlckZvcm1hdDogJzxzcGFuIHN0eWxlPVwiZm9udC1zaXplOiAxMHB4XCI+e3BvaW50LmtleX08L3NwYW4+PGJyLz4nLFxuICAgICAgICBwb2ludEZvcm1hdDogJzxzcGFuIHN0eWxlPVwiY29sb3I6e3BvaW50LmNvbG9yfVwiPlxcdTI1Y2Y8L3NwYW4+IHtzZXJpZXMubmFtZX06IDxiPntwb2ludC55fTwvYj48YnIvPicsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogcihcIiNmN2Y3ZjdcIikuc2V0T3BhY2l0eSguODUpLmdldCgpLFxuICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgc2hhZG93OiAhMCxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBjb2xvcjogXCIjMzMzMzMzXCIsXG4gICAgICAgICAgY3Vyc29yOiBcImRlZmF1bHRcIixcbiAgICAgICAgICBmb250U2l6ZTogXCIxMnB4XCIsXG4gICAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3JlZGl0czoge1xuICAgICAgICBlbmFibGVkOiAhMCxcbiAgICAgICAgaHJlZjogXCJodHRwczovL3d3dy5oaWdoY2hhcnRzLmNvbT9jcmVkaXRzXCIsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgYWxpZ246IFwicmlnaHRcIixcbiAgICAgICAgICB4OiAtMTAsXG4gICAgICAgICAgdmVydGljYWxBbGlnbjogXCJib3R0b21cIixcbiAgICAgICAgICB5OiAtNVxuICAgICAgICB9LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgICAgICAgY29sb3I6IFwiIzk5OTk5OVwiLFxuICAgICAgICAgIGZvbnRTaXplOiBcIjlweFwiXG4gICAgICAgIH0sXG4gICAgICAgIHRleHQ6IFwiSGlnaGNoYXJ0cy5jb21cIlxuICAgICAgfVxuICAgIH07XG5cbiAgICBkLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAoZykge1xuICAgICAgZC5kZWZhdWx0T3B0aW9ucyA9IEkoITAsIGQuZGVmYXVsdE9wdGlvbnMsIGcpO1xuICAgICAgKGcudGltZSB8fCBnLmdsb2JhbCkgJiYgZC50aW1lLnVwZGF0ZShJKGQuZGVmYXVsdE9wdGlvbnMuZ2xvYmFsLCBkLmRlZmF1bHRPcHRpb25zLnRpbWUsIGcuZ2xvYmFsLCBnLnRpbWUpKTtcbiAgICAgIHJldHVybiBkLmRlZmF1bHRPcHRpb25zO1xuICAgIH07XG5cbiAgICBkLmdldE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZC5kZWZhdWx0T3B0aW9ucztcbiAgICB9O1xuXG4gICAgZC5kZWZhdWx0UGxvdE9wdGlvbnMgPSBkLmRlZmF1bHRPcHRpb25zLnBsb3RPcHRpb25zO1xuICAgIGQudGltZSA9IG5ldyBnKEkoZC5kZWZhdWx0T3B0aW9ucy5nbG9iYWwsIGQuZGVmYXVsdE9wdGlvbnMudGltZSkpO1xuXG4gICAgZC5kYXRlRm9ybWF0ID0gZnVuY3Rpb24gKGcsIHUsIEEpIHtcbiAgICAgIHJldHVybiBkLnRpbWUuZGF0ZUZvcm1hdChnLCB1LCBBKTtcbiAgICB9O1xuXG4gICAgXCJcIjtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9BeGlzLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL0NvbG9yLmpzXCJdLCByW1wicGFydHMvVGljay5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnLCByLCB1KSB7XG4gICAgdmFyIEkgPSBnLnBhcnNlLFxuICAgICAgICBNID0gdS5hZGRFdmVudCxcbiAgICAgICAgRSA9IHUuYW5pbU9iamVjdCxcbiAgICAgICAgQSA9IHUuYXJyYXlNYXgsXG4gICAgICAgIEcgPSB1LmFycmF5TWluLFxuICAgICAgICBKID0gdS5jbGFtcCxcbiAgICAgICAgeSA9IHUuY29ycmVjdEZsb2F0LFxuICAgICAgICB0ID0gdS5kZWZpbmVkLFxuICAgICAgICBEID0gdS5kZXN0cm95T2JqZWN0UHJvcGVydGllcyxcbiAgICAgICAgaCA9IHUuZXJyb3IsXG4gICAgICAgIE4gPSB1LmV4dGVuZCxcbiAgICAgICAgcSA9IHUuZmlyZUV2ZW50LFxuICAgICAgICBQID0gdS5mb3JtYXQsXG4gICAgICAgIGUgPSB1LmdldE1hZ25pdHVkZSxcbiAgICAgICAgYyA9IHUuaXNBcnJheSxcbiAgICAgICAgayA9IHUuaXNGdW5jdGlvbixcbiAgICAgICAgbiA9IHUuaXNOdW1iZXIsXG4gICAgICAgIGYgPSB1LmlzU3RyaW5nLFxuICAgICAgICBhID0gdS5tZXJnZSxcbiAgICAgICAgbCA9IHUubm9ybWFsaXplVGlja0ludGVydmFsLFxuICAgICAgICB2ID0gdS5vYmplY3RFYWNoLFxuICAgICAgICB6ID0gdS5waWNrLFxuICAgICAgICB3ID0gdS5yZWxhdGl2ZUxlbmd0aCxcbiAgICAgICAgQiA9IHUucmVtb3ZlRXZlbnQsXG4gICAgICAgIEwgPSB1LnNwbGF0LFxuICAgICAgICBRID0gdS5zeW5jVGltZW91dCxcbiAgICAgICAgSCA9IGQuZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgIEsgPSBkLmRlZzJyYWQ7XG5cbiAgICBnID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIE4oZy5wcm90b3R5cGUsIHtcbiAgICAgIGRlZmF1bHRPcHRpb25zOiB7XG4gICAgICAgIGRhdGVUaW1lTGFiZWxGb3JtYXRzOiB7XG4gICAgICAgICAgbWlsbGlzZWNvbmQ6IHtcbiAgICAgICAgICAgIG1haW46IFwiJUg6JU06JVMuJUxcIixcbiAgICAgICAgICAgIHJhbmdlOiAhMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2Vjb25kOiB7XG4gICAgICAgICAgICBtYWluOiBcIiVIOiVNOiVTXCIsXG4gICAgICAgICAgICByYW5nZTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1pbnV0ZToge1xuICAgICAgICAgICAgbWFpbjogXCIlSDolTVwiLFxuICAgICAgICAgICAgcmFuZ2U6ICExXG4gICAgICAgICAgfSxcbiAgICAgICAgICBob3VyOiB7XG4gICAgICAgICAgICBtYWluOiBcIiVIOiVNXCIsXG4gICAgICAgICAgICByYW5nZTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRheToge1xuICAgICAgICAgICAgbWFpbjogXCIlZS4gJWJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgd2Vlazoge1xuICAgICAgICAgICAgbWFpbjogXCIlZS4gJWJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgbW9udGg6IHtcbiAgICAgICAgICAgIG1haW46IFwiJWIgJyV5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHllYXI6IHtcbiAgICAgICAgICAgIG1haW46IFwiJVlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW5kT25UaWNrOiAhMSxcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgZW5hYmxlZDogITAsXG4gICAgICAgICAgaW5kZW50YXRpb246IDEwLFxuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGNvbG9yOiBcIiM2NjY2NjZcIixcbiAgICAgICAgICAgIGN1cnNvcjogXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICBmb250U2l6ZTogXCIxMXB4XCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1heFBhZGRpbmc6IC4wMSxcbiAgICAgICAgbWlub3JUaWNrTGVuZ3RoOiAyLFxuICAgICAgICBtaW5vclRpY2tQb3NpdGlvbjogXCJvdXRzaWRlXCIsXG4gICAgICAgIG1pblBhZGRpbmc6IC4wMSxcbiAgICAgICAgc2hvd0VtcHR5OiAhMCxcbiAgICAgICAgc3RhcnRPZldlZWs6IDEsXG4gICAgICAgIHN0YXJ0T25UaWNrOiAhMSxcbiAgICAgICAgdGlja0xlbmd0aDogMTAsXG4gICAgICAgIHRpY2tQaXhlbEludGVydmFsOiAxMDAsXG4gICAgICAgIHRpY2ttYXJrUGxhY2VtZW50OiBcImJldHdlZW5cIixcbiAgICAgICAgdGlja1Bvc2l0aW9uOiBcIm91dHNpZGVcIixcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICBhbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgY29sb3I6IFwiIzY2NjY2NlwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiBcImxpbmVhclwiLFxuICAgICAgICBtaW5vckdyaWRMaW5lQ29sb3I6IFwiI2YyZjJmMlwiLFxuICAgICAgICBtaW5vckdyaWRMaW5lV2lkdGg6IDEsXG4gICAgICAgIG1pbm9yVGlja0NvbG9yOiBcIiM5OTk5OTlcIixcbiAgICAgICAgbGluZUNvbG9yOiBcIiNjY2Q2ZWJcIixcbiAgICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgICBncmlkTGluZUNvbG9yOiBcIiNlNmU2ZTZcIixcbiAgICAgICAgdGlja0NvbG9yOiBcIiNjY2Q2ZWJcIlxuICAgICAgfSxcbiAgICAgIGRlZmF1bHRZQXhpc09wdGlvbnM6IHtcbiAgICAgICAgZW5kT25UaWNrOiAhMCxcbiAgICAgICAgbWF4UGFkZGluZzogLjA1LFxuICAgICAgICBtaW5QYWRkaW5nOiAuMDUsXG4gICAgICAgIHRpY2tQaXhlbEludGVydmFsOiA3MixcbiAgICAgICAgc2hvd0xhc3RMYWJlbDogITAsXG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgIHg6IC04XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0T25UaWNrOiAhMCxcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICByb3RhdGlvbjogMjcwLFxuICAgICAgICAgIHRleHQ6IFwiVmFsdWVzXCJcbiAgICAgICAgfSxcbiAgICAgICAgc3RhY2tMYWJlbHM6IHtcbiAgICAgICAgICBhbGxvd092ZXJsYXA6ICExLFxuICAgICAgICAgIGVuYWJsZWQ6ICExLFxuICAgICAgICAgIGNyb3A6ICEwLFxuICAgICAgICAgIG92ZXJmbG93OiBcImp1c3RpZnlcIixcbiAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5heGlzLmNoYXJ0Lm51bWJlckZvcm1hdHRlcjtcbiAgICAgICAgICAgIHJldHVybiBhKHRoaXMudG90YWwsIC0xKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBjb2xvcjogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgICBmb250U2l6ZTogXCIxMXB4XCIsXG4gICAgICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIixcbiAgICAgICAgICAgIHRleHRPdXRsaW5lOiBcIjFweCBjb250cmFzdFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBncmlkTGluZVdpZHRoOiAxLFxuICAgICAgICBsaW5lV2lkdGg6IDBcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0TGVmdEF4aXNPcHRpb25zOiB7XG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgIHg6IC0xNVxuICAgICAgICB9LFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgIHJvdGF0aW9uOiAyNzBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlZmF1bHRSaWdodEF4aXNPcHRpb25zOiB7XG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgIHg6IDE1XG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgcm90YXRpb246IDkwXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZWZhdWx0Qm90dG9tQXhpc09wdGlvbnM6IHtcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgYXV0b1JvdGF0aW9uOiBbLTQ1XSxcbiAgICAgICAgICB4OiAwXG4gICAgICAgIH0sXG4gICAgICAgIG1hcmdpbjogMTUsXG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgcm90YXRpb246IDBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlZmF1bHRUb3BBeGlzT3B0aW9uczoge1xuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICBhdXRvUm90YXRpb246IFstNDVdLFxuICAgICAgICAgIHg6IDBcbiAgICAgICAgfSxcbiAgICAgICAgbWFyZ2luOiAxNSxcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICByb3RhdGlvbjogMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW5pdDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGYgPSBiLmlzWCxcbiAgICAgICAgICAgIGMgPSB0aGlzO1xuICAgICAgICBjLmNoYXJ0ID0gYTtcbiAgICAgICAgYy5ob3JpeiA9IGEuaW52ZXJ0ZWQgJiYgIWMuaXNaQXhpcyA/ICFmIDogZjtcbiAgICAgICAgYy5pc1hBeGlzID0gZjtcbiAgICAgICAgYy5jb2xsID0gYy5jb2xsIHx8IChmID8gXCJ4QXhpc1wiIDogXCJ5QXhpc1wiKTtcbiAgICAgICAgcSh0aGlzLCBcImluaXRcIiwge1xuICAgICAgICAgIHVzZXJPcHRpb25zOiBiXG4gICAgICAgIH0pO1xuICAgICAgICBjLm9wcG9zaXRlID0gYi5vcHBvc2l0ZTtcbiAgICAgICAgYy5zaWRlID0gYi5zaWRlIHx8IChjLmhvcml6ID8gYy5vcHBvc2l0ZSA/IDAgOiAyIDogYy5vcHBvc2l0ZSA/IDEgOiAzKTtcbiAgICAgICAgYy5zZXRPcHRpb25zKGIpO1xuICAgICAgICB2YXIgcCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGUgPSBwLnR5cGU7XG4gICAgICAgIGMubGFiZWxGb3JtYXR0ZXIgPSBwLmxhYmVscy5mb3JtYXR0ZXIgfHwgYy5kZWZhdWx0TGFiZWxGb3JtYXR0ZXI7XG4gICAgICAgIGMudXNlck9wdGlvbnMgPSBiO1xuICAgICAgICBjLm1pblBpeGVsUGFkZGluZyA9IDA7XG4gICAgICAgIGMucmV2ZXJzZWQgPSBwLnJldmVyc2VkO1xuICAgICAgICBjLnZpc2libGUgPSAhMSAhPT0gcC52aXNpYmxlO1xuICAgICAgICBjLnpvb21FbmFibGVkID0gITEgIT09IHAuem9vbUVuYWJsZWQ7XG4gICAgICAgIGMuaGFzTmFtZXMgPSBcImNhdGVnb3J5XCIgPT09IGUgfHwgITAgPT09IHAuY2F0ZWdvcmllcztcbiAgICAgICAgYy5jYXRlZ29yaWVzID0gcC5jYXRlZ29yaWVzIHx8IGMuaGFzTmFtZXM7XG4gICAgICAgIGMubmFtZXMgfHwgKGMubmFtZXMgPSBbXSwgYy5uYW1lcy5rZXlzID0ge30pO1xuICAgICAgICBjLnBsb3RMaW5lc0FuZEJhbmRzR3JvdXBzID0ge307XG4gICAgICAgIGMuaXNMb2cgPSBcImxvZ2FyaXRobWljXCIgPT09IGU7XG4gICAgICAgIGMuaXNEYXRldGltZUF4aXMgPSBcImRhdGV0aW1lXCIgPT09IGU7XG4gICAgICAgIGMucG9zaXRpdmVWYWx1ZXNPbmx5ID0gYy5pc0xvZyAmJiAhYy5hbGxvd05lZ2F0aXZlTG9nO1xuICAgICAgICBjLmlzTGlua2VkID0gdChwLmxpbmtlZFRvKTtcbiAgICAgICAgYy50aWNrcyA9IHt9O1xuICAgICAgICBjLmxhYmVsRWRnZSA9IFtdO1xuICAgICAgICBjLm1pbm9yVGlja3MgPSB7fTtcbiAgICAgICAgYy5wbG90TGluZXNBbmRCYW5kcyA9IFtdO1xuICAgICAgICBjLmFsdGVybmF0ZUJhbmRzID0ge307XG4gICAgICAgIGMubGVuID0gMDtcbiAgICAgICAgYy5taW5SYW5nZSA9IGMudXNlck1pblJhbmdlID0gcC5taW5SYW5nZSB8fCBwLm1heFpvb207XG4gICAgICAgIGMucmFuZ2UgPSBwLnJhbmdlO1xuICAgICAgICBjLm9mZnNldCA9IHAub2Zmc2V0IHx8IDA7XG4gICAgICAgIGMuc3RhY2tzID0ge307XG4gICAgICAgIGMub2xkU3RhY2tzID0ge307XG4gICAgICAgIGMuc3RhY2tzVG91Y2hlZCA9IDA7XG4gICAgICAgIGMubWF4ID0gbnVsbDtcbiAgICAgICAgYy5taW4gPSBudWxsO1xuICAgICAgICBjLmNyb3NzaGFpciA9IHoocC5jcm9zc2hhaXIsIEwoYS5vcHRpb25zLnRvb2x0aXAuY3Jvc3NoYWlycylbZiA/IDAgOiAxXSwgITEpO1xuICAgICAgICBiID0gYy5vcHRpb25zLmV2ZW50cztcbiAgICAgICAgLTEgPT09IGEuYXhlcy5pbmRleE9mKGMpICYmIChmID8gYS5heGVzLnNwbGljZShhLnhBeGlzLmxlbmd0aCwgMCwgYykgOiBhLmF4ZXMucHVzaChjKSwgYVtjLmNvbGxdLnB1c2goYykpO1xuICAgICAgICBjLnNlcmllcyA9IGMuc2VyaWVzIHx8IFtdO1xuICAgICAgICBhLmludmVydGVkICYmICFjLmlzWkF4aXMgJiYgZiAmJiBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgYy5yZXZlcnNlZCAmJiAoYy5yZXZlcnNlZCA9ICEwKTtcbiAgICAgICAgdihiLCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIGsoYikgJiYgTShjLCBhLCBiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGMubGluMmxvZyA9IHAubGluZWFyVG9Mb2dDb252ZXJ0ZXIgfHwgYy5saW4ybG9nO1xuICAgICAgICBjLmlzTG9nICYmIChjLnZhbDJsaW4gPSBjLmxvZzJsaW4sIGMubGluMnZhbCA9IGMubGluMmxvZyk7XG4gICAgICAgIHEodGhpcywgXCJhZnRlckluaXRcIik7XG4gICAgICB9LFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gYSh0aGlzLmRlZmF1bHRPcHRpb25zLCBcInlBeGlzXCIgPT09IHRoaXMuY29sbCAmJiB0aGlzLmRlZmF1bHRZQXhpc09wdGlvbnMsIFt0aGlzLmRlZmF1bHRUb3BBeGlzT3B0aW9ucywgdGhpcy5kZWZhdWx0UmlnaHRBeGlzT3B0aW9ucywgdGhpcy5kZWZhdWx0Qm90dG9tQXhpc09wdGlvbnMsIHRoaXMuZGVmYXVsdExlZnRBeGlzT3B0aW9uc11bdGhpcy5zaWRlXSwgYShIW3RoaXMuY29sbF0sIGMpKTtcbiAgICAgICAgcSh0aGlzLCBcImFmdGVyU2V0T3B0aW9uc1wiLCB7XG4gICAgICAgICAgdXNlck9wdGlvbnM6IGNcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZGVmYXVsdExhYmVsRm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5heGlzLFxuICAgICAgICAgICAgYiA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgICBjID0gYS5jaGFydC50aW1lLFxuICAgICAgICAgICAgZiA9IGEuY2F0ZWdvcmllcyxcbiAgICAgICAgICAgIGUgPSB0aGlzLmRhdGVUaW1lTGFiZWxGb3JtYXQsXG4gICAgICAgICAgICBsID0gSC5sYW5nLFxuICAgICAgICAgICAgayA9IGwubnVtZXJpY1N5bWJvbHM7XG4gICAgICAgIGwgPSBsLm51bWVyaWNTeW1ib2xNYWduaXR1ZGUgfHwgMUUzO1xuICAgICAgICB2YXIgdiA9IGsgJiYgay5sZW5ndGgsXG4gICAgICAgICAgICBtID0gYS5vcHRpb25zLmxhYmVscy5mb3JtYXQ7XG4gICAgICAgIGEgPSBhLmlzTG9nID8gTWF0aC5hYnMoYikgOiBhLnRpY2tJbnRlcnZhbDtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZCA9IG4ubnVtYmVyRm9ybWF0dGVyO1xuICAgICAgICBpZiAobSkgdmFyIHcgPSBQKG0sIHRoaXMsIG4pO2Vsc2UgaWYgKGYpIHcgPSBiO2Vsc2UgaWYgKGUpIHcgPSBjLmRhdGVGb3JtYXQoZSwgYik7ZWxzZSBpZiAodiAmJiAxRTMgPD0gYSkgZm9yICg7IHYtLSAmJiBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgdzspIGMgPSBNYXRoLnBvdyhsLCB2ICsgMSksIGEgPj0gYyAmJiAwID09PSAxMCAqIGIgJSBjICYmIG51bGwgIT09IGtbdl0gJiYgMCAhPT0gYiAmJiAodyA9IGQoYiAvIGMsIC0xKSArIGtbdl0pO1xuICAgICAgICBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgdyAmJiAodyA9IDFFNCA8PSBNYXRoLmFicyhiKSA/IGQoYiwgLTEpIDogZChiLCAtMSwgdm9pZCAwLCBcIlwiKSk7XG4gICAgICAgIHJldHVybiB3O1xuICAgICAgfSxcbiAgICAgIGdldFNlcmllc0V4dHJlbWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIGIgPSBhLmNoYXJ0LFxuICAgICAgICAgICAgYztcbiAgICAgICAgcSh0aGlzLCBcImdldFNlcmllc0V4dHJlbWVzXCIsIG51bGwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhLmhhc1Zpc2libGVTZXJpZXMgPSAhMTtcbiAgICAgICAgICBhLmRhdGFNaW4gPSBhLmRhdGFNYXggPSBhLnRocmVzaG9sZCA9IG51bGw7XG4gICAgICAgICAgYS5zb2Z0VGhyZXNob2xkID0gIWEuaXNYQXhpcztcbiAgICAgICAgICBhLmJ1aWxkU3RhY2tzICYmIGEuYnVpbGRTdGFja3MoKTtcbiAgICAgICAgICBhLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICBpZiAoZi52aXNpYmxlIHx8ICFiLm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzKSB7XG4gICAgICAgICAgICAgIHZhciBlID0gZi5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgcCA9IGUudGhyZXNob2xkO1xuICAgICAgICAgICAgICBhLmhhc1Zpc2libGVTZXJpZXMgPSAhMDtcbiAgICAgICAgICAgICAgYS5wb3NpdGl2ZVZhbHVlc09ubHkgJiYgMCA+PSBwICYmIChwID0gbnVsbCk7XG5cbiAgICAgICAgICAgICAgaWYgKGEuaXNYQXhpcykge1xuICAgICAgICAgICAgICAgIGlmIChlID0gZi54RGF0YSwgZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGMgPSBmLmdldFhFeHRyZW1lcyhlKTtcbiAgICAgICAgICAgICAgICAgIHZhciB4ID0gYy5taW47XG4gICAgICAgICAgICAgICAgICB2YXIgbCA9IGMubWF4O1xuICAgICAgICAgICAgICAgICAgbih4KSB8fCB4IGluc3RhbmNlb2YgRGF0ZSB8fCAoZSA9IGUuZmlsdGVyKG4pLCBjID0gZi5nZXRYRXh0cmVtZXMoZSksIHggPSBjLm1pbiwgbCA9IGMubWF4KTtcbiAgICAgICAgICAgICAgICAgIGUubGVuZ3RoICYmIChhLmRhdGFNaW4gPSBNYXRoLm1pbih6KGEuZGF0YU1pbiwgeCksIHgpLCBhLmRhdGFNYXggPSBNYXRoLm1heCh6KGEuZGF0YU1heCwgbCksIGwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZi5nZXRFeHRyZW1lcygpLCBsID0gZi5kYXRhTWF4LCB4ID0gZi5kYXRhTWluLCB0KHgpICYmIHQobCkgJiYgKGEuZGF0YU1pbiA9IE1hdGgubWluKHooYS5kYXRhTWluLCB4KSwgeCksIGEuZGF0YU1heCA9IE1hdGgubWF4KHooYS5kYXRhTWF4LCBsKSwgbCkpLCB0KHApICYmIChhLnRocmVzaG9sZCA9IHApLCAhZS5zb2Z0VGhyZXNob2xkIHx8IGEucG9zaXRpdmVWYWx1ZXNPbmx5KSBhLnNvZnRUaHJlc2hvbGQgPSAhMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHEodGhpcywgXCJhZnRlckdldFNlcmllc0V4dHJlbWVzXCIpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gKGEsIGIsIGMsIGYsIGUsIGwpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLmxpbmtlZFBhcmVudCB8fCB0aGlzLFxuICAgICAgICAgICAgeCA9IDEsXG4gICAgICAgICAgICBtID0gMCxcbiAgICAgICAgICAgIEMgPSBmID8gcC5vbGRUcmFuc0EgOiBwLnRyYW5zQTtcbiAgICAgICAgZiA9IGYgPyBwLm9sZE1pbiA6IHAubWluO1xuICAgICAgICB2YXIgayA9IHAubWluUGl4ZWxQYWRkaW5nO1xuICAgICAgICBlID0gKHAuaXNPcmRpbmFsIHx8IHAuaXNCcm9rZW4gfHwgcC5pc0xvZyAmJiBlKSAmJiBwLmxpbjJ2YWw7XG4gICAgICAgIEMgfHwgKEMgPSBwLnRyYW5zQSk7XG4gICAgICAgIGMgJiYgKHggKj0gLTEsIG0gPSBwLmxlbik7XG4gICAgICAgIHAucmV2ZXJzZWQgJiYgKHggKj0gLTEsIG0gLT0geCAqIChwLnNlY3RvciB8fCBwLmxlbikpO1xuICAgICAgICBiID8gKGEgPSAoYSAqIHggKyBtIC0gaykgLyBDICsgZiwgZSAmJiAoYSA9IHAubGluMnZhbChhKSkpIDogKGUgJiYgKGEgPSBwLnZhbDJsaW4oYSkpLCBhID0gbihmKSA/IHggKiAoYSAtIGYpICogQyArIG0gKyB4ICogayArIChuKGwpID8gQyAqIGwgOiAwKSA6IHZvaWQgMCk7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSxcbiAgICAgIHRvUGl4ZWxzOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGUoYSwgITEsICF0aGlzLmhvcml6LCBudWxsLCAhMCkgKyAoYiA/IDAgOiB0aGlzLnBvcyk7XG4gICAgICB9LFxuICAgICAgdG9WYWx1ZTogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlKGEgLSAoYiA/IDAgOiB0aGlzLnBvcyksICEwLCAhdGhpcy5ob3JpeiwgbnVsbCwgITApO1xuICAgICAgfSxcbiAgICAgIGdldFBsb3RMaW5lUGF0aDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICAgICAgYyA9IGIuY2hhcnQsXG4gICAgICAgICAgICBmID0gYi5sZWZ0LFxuICAgICAgICAgICAgZSA9IGIudG9wLFxuICAgICAgICAgICAgcCA9IGEub2xkLFxuICAgICAgICAgICAgbCA9IGEudmFsdWUsXG4gICAgICAgICAgICBrID0gYS50cmFuc2xhdGVkVmFsdWUsXG4gICAgICAgICAgICBtID0gYS5saW5lV2lkdGgsXG4gICAgICAgICAgICB2ID0gYS5mb3JjZSxcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICB3LFxuICAgICAgICAgICAgRixcbiAgICAgICAgICAgIGgsXG4gICAgICAgICAgICBCID0gcCAmJiBjLm9sZENoYXJ0SGVpZ2h0IHx8IGMuY2hhcnRIZWlnaHQsXG4gICAgICAgICAgICBMID0gcCAmJiBjLm9sZENoYXJ0V2lkdGggfHwgYy5jaGFydFdpZHRoLFxuICAgICAgICAgICAgdCxcbiAgICAgICAgICAgIGcgPSBiLnRyYW5zQixcbiAgICAgICAgICAgIEggPSBmdW5jdGlvbiAoYiwgYSwgYykge1xuICAgICAgICAgIGlmIChcInBhc3NcIiAhPT0gdiAmJiBiIDwgYSB8fCBiID4gYykgdiA/IGIgPSBKKGIsIGEsIGMpIDogdCA9ICEwO1xuICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9O1xuXG4gICAgICAgIGEgPSB7XG4gICAgICAgICAgdmFsdWU6IGwsXG4gICAgICAgICAgbGluZVdpZHRoOiBtLFxuICAgICAgICAgIG9sZDogcCxcbiAgICAgICAgICBmb3JjZTogdixcbiAgICAgICAgICBhY3Jvc3NQYW5lczogYS5hY3Jvc3NQYW5lcyxcbiAgICAgICAgICB0cmFuc2xhdGVkVmFsdWU6IGtcbiAgICAgICAgfTtcbiAgICAgICAgcSh0aGlzLCBcImdldFBsb3RMaW5lUGF0aFwiLCBhLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGsgPSB6KGssIGIudHJhbnNsYXRlKGwsIG51bGwsIG51bGwsIHApKTtcbiAgICAgICAgICBrID0gSihrLCAtMUU1LCAxRTUpO1xuICAgICAgICAgIGQgPSBGID0gTWF0aC5yb3VuZChrICsgZyk7XG4gICAgICAgICAgdyA9IGggPSBNYXRoLnJvdW5kKEIgLSBrIC0gZyk7XG4gICAgICAgICAgbihrKSA/IGIuaG9yaXogPyAodyA9IGUsIGggPSBCIC0gYi5ib3R0b20sIGQgPSBGID0gSChkLCBmLCBmICsgYi53aWR0aCkpIDogKGQgPSBmLCBGID0gTCAtIGIucmlnaHQsIHcgPSBoID0gSCh3LCBlLCBlICsgYi5oZWlnaHQpKSA6ICh0ID0gITAsIHYgPSAhMSk7XG4gICAgICAgICAgYS5wYXRoID0gdCAmJiAhdiA/IG51bGwgOiBjLnJlbmRlcmVyLmNyaXNwTGluZShbXCJNXCIsIGQsIHcsIFwiTFwiLCBGLCBoXSwgbSB8fCAxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhLnBhdGg7XG4gICAgICB9LFxuICAgICAgZ2V0TGluZWFyVGlja1Bvc2l0aW9uczogZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgdmFyIGYgPSB5KE1hdGguZmxvb3IoYiAvIGEpICogYSk7XG4gICAgICAgIGMgPSB5KE1hdGguY2VpbChjIC8gYSkgKiBhKTtcbiAgICAgICAgdmFyIGUgPSBbXSxcbiAgICAgICAgICAgIHA7XG4gICAgICAgIHkoZiArIGEpID09PSBmICYmIChwID0gMjApO1xuICAgICAgICBpZiAodGhpcy5zaW5nbGUpIHJldHVybiBbYl07XG5cbiAgICAgICAgZm9yIChiID0gZjsgYiA8PSBjOykge1xuICAgICAgICAgIGUucHVzaChiKTtcbiAgICAgICAgICBiID0geShiICsgYSwgcCk7XG4gICAgICAgICAgaWYgKGIgPT09IGwpIGJyZWFrO1xuICAgICAgICAgIHZhciBsID0gYjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfSxcbiAgICAgIGdldE1pbm9yVGlja0ludGVydmFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5vcHRpb25zO1xuICAgICAgICByZXR1cm4gITAgPT09IGEubWlub3JUaWNrcyA/IHooYS5taW5vclRpY2tJbnRlcnZhbCwgXCJhdXRvXCIpIDogITEgPT09IGEubWlub3JUaWNrcyA/IG51bGwgOiBhLm1pbm9yVGlja0ludGVydmFsO1xuICAgICAgfSxcbiAgICAgIGdldE1pbm9yVGlja1Bvc2l0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICBiID0gYS5vcHRpb25zLFxuICAgICAgICAgICAgYyA9IGEudGlja1Bvc2l0aW9ucyxcbiAgICAgICAgICAgIGYgPSBhLm1pbm9yVGlja0ludGVydmFsLFxuICAgICAgICAgICAgZSA9IFtdLFxuICAgICAgICAgICAgbCA9IGEucG9pbnRSYW5nZVBhZGRpbmcgfHwgMCxcbiAgICAgICAgICAgIGsgPSBhLm1pbiAtIGw7XG4gICAgICAgIGwgPSBhLm1heCArIGw7XG4gICAgICAgIHZhciB2ID0gbCAtIGs7XG4gICAgICAgIGlmICh2ICYmIHYgLyBmIDwgYS5sZW4gLyAzKSBpZiAoYS5pc0xvZykgdGhpcy5wYWRkZWRUaWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChiLCBjLCBwKSB7XG4gICAgICAgICAgYyAmJiBlLnB1c2guYXBwbHkoZSwgYS5nZXRMb2dUaWNrUG9zaXRpb25zKGYsIHBbYyAtIDFdLCBwW2NdLCAhMCkpO1xuICAgICAgICB9KTtlbHNlIGlmIChhLmlzRGF0ZXRpbWVBeGlzICYmIFwiYXV0b1wiID09PSB0aGlzLmdldE1pbm9yVGlja0ludGVydmFsKCkpIGUgPSBlLmNvbmNhdChhLmdldFRpbWVUaWNrcyhhLm5vcm1hbGl6ZVRpbWVUaWNrSW50ZXJ2YWwoZiksIGssIGwsIGIuc3RhcnRPZldlZWspKTtlbHNlIGZvciAoYiA9IGsgKyAoY1swXSAtIGspICUgZjsgYiA8PSBsICYmIGIgIT09IGVbMF07IGIgKz0gZikgZS5wdXNoKGIpO1xuICAgICAgICAwICE9PSBlLmxlbmd0aCAmJiBhLnRyaW1UaWNrcyhlKTtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9LFxuICAgICAgYWRqdXN0Rm9yTWluUmFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBiID0gdGhpcy5taW4sXG4gICAgICAgICAgICBjID0gdGhpcy5tYXgsXG4gICAgICAgICAgICBmLFxuICAgICAgICAgICAgZSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgdjtcbiAgICAgICAgdGhpcy5pc1hBeGlzICYmIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiB0aGlzLm1pblJhbmdlICYmICF0aGlzLmlzTG9nICYmICh0KGEubWluKSB8fCB0KGEubWF4KSA/IHRoaXMubWluUmFuZ2UgPSBudWxsIDogKHRoaXMuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBrID0gYi54RGF0YTtcblxuICAgICAgICAgIGZvciAoZSA9IHYgPSBiLnhJbmNyZW1lbnQgPyAxIDogay5sZW5ndGggLSAxOyAwIDwgZTsgZS0tKSBpZiAobCA9IGtbZV0gLSBrW2UgLSAxXSwgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGYgfHwgbCA8IGYpIGYgPSBsO1xuICAgICAgICB9KSwgdGhpcy5taW5SYW5nZSA9IE1hdGgubWluKDUgKiBmLCB0aGlzLmRhdGFNYXggLSB0aGlzLmRhdGFNaW4pKSk7XG5cbiAgICAgICAgaWYgKGMgLSBiIDwgdGhpcy5taW5SYW5nZSkge1xuICAgICAgICAgIHZhciBtID0gdGhpcy5kYXRhTWF4IC0gdGhpcy5kYXRhTWluID49IHRoaXMubWluUmFuZ2U7XG4gICAgICAgICAgdmFyIG4gPSB0aGlzLm1pblJhbmdlO1xuICAgICAgICAgIHZhciBkID0gKG4gLSBjICsgYikgLyAyO1xuICAgICAgICAgIGQgPSBbYiAtIGQsIHooYS5taW4sIGIgLSBkKV07XG4gICAgICAgICAgbSAmJiAoZFsyXSA9IHRoaXMuaXNMb2cgPyB0aGlzLmxvZzJsaW4odGhpcy5kYXRhTWluKSA6IHRoaXMuZGF0YU1pbik7XG4gICAgICAgICAgYiA9IEEoZCk7XG4gICAgICAgICAgYyA9IFtiICsgbiwgeihhLm1heCwgYiArIG4pXTtcbiAgICAgICAgICBtICYmIChjWzJdID0gdGhpcy5pc0xvZyA/IHRoaXMubG9nMmxpbih0aGlzLmRhdGFNYXgpIDogdGhpcy5kYXRhTWF4KTtcbiAgICAgICAgICBjID0gRyhjKTtcbiAgICAgICAgICBjIC0gYiA8IG4gJiYgKGRbMF0gPSBjIC0gbiwgZFsxXSA9IHooYS5taW4sIGMgLSBuKSwgYiA9IEEoZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5taW4gPSBiO1xuICAgICAgICB0aGlzLm1heCA9IGM7XG4gICAgICB9LFxuICAgICAgZ2V0Q2xvc2VzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYTtcbiAgICAgICAgdGhpcy5jYXRlZ29yaWVzID8gYSA9IDEgOiB0aGlzLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgdmFyIGMgPSBiLmNsb3Nlc3RQb2ludFJhbmdlLFxuICAgICAgICAgICAgICBmID0gYi52aXNpYmxlIHx8ICFiLmNoYXJ0Lm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzO1xuICAgICAgICAgICFiLm5vU2hhcmVkVG9vbHRpcCAmJiB0KGMpICYmIGYgJiYgKGEgPSB0KGEpID8gTWF0aC5taW4oYSwgYykgOiBjKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSxcbiAgICAgIG5hbWVUb1g6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBiID0gYyh0aGlzLmNhdGVnb3JpZXMpLFxuICAgICAgICAgICAgZiA9IGIgPyB0aGlzLmNhdGVnb3JpZXMgOiB0aGlzLm5hbWVzLFxuICAgICAgICAgICAgZSA9IGEub3B0aW9ucy54O1xuICAgICAgICBhLnNlcmllcy5yZXF1aXJlU29ydGluZyA9ICExO1xuICAgICAgICB0KGUpIHx8IChlID0gITEgPT09IHRoaXMub3B0aW9ucy51bmlxdWVOYW1lcyA/IGEuc2VyaWVzLmF1dG9JbmNyZW1lbnQoKSA6IGIgPyBmLmluZGV4T2YoYS5uYW1lKSA6IHooZi5rZXlzW2EubmFtZV0sIC0xKSk7XG5cbiAgICAgICAgaWYgKC0xID09PSBlKSB7XG4gICAgICAgICAgaWYgKCFiKSB2YXIgcCA9IGYubGVuZ3RoO1xuICAgICAgICB9IGVsc2UgcCA9IGU7XG5cbiAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHAgJiYgKHRoaXMubmFtZXNbcF0gPSBhLm5hbWUsIHRoaXMubmFtZXMua2V5c1thLm5hbWVdID0gcCk7XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZU5hbWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIGIgPSB0aGlzLm5hbWVzO1xuICAgICAgICAwIDwgYi5sZW5ndGggJiYgKE9iamVjdC5rZXlzKGIua2V5cykuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGRlbGV0ZSBiLmtleXNbYV07XG4gICAgICAgIH0pLCBiLmxlbmd0aCA9IDAsIHRoaXMubWluUmFuZ2UgPSB0aGlzLnVzZXJNaW5SYW5nZSwgKHRoaXMuc2VyaWVzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYi54SW5jcmVtZW50ID0gbnVsbDtcbiAgICAgICAgICBpZiAoIWIucG9pbnRzIHx8IGIuaXNEaXJ0eURhdGEpIGEubWF4ID0gTWF0aC5tYXgoYS5tYXgsIGIueERhdGEubGVuZ3RoIC0gMSksIGIucHJvY2Vzc0RhdGEoKSwgYi5nZW5lcmF0ZVBvaW50cygpO1xuICAgICAgICAgIGIuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChjLCBmKSB7XG4gICAgICAgICAgICBpZiAoYyAmJiBjLm9wdGlvbnMgJiYgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGMubmFtZSkge1xuICAgICAgICAgICAgICB2YXIgZSA9IGEubmFtZVRvWChjKTtcbiAgICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGUgJiYgZSAhPT0gYy54ICYmIChjLnggPSBlLCBiLnhEYXRhW2ZdID0gZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICBzZXRBeGlzVHJhbnNsYXRpb246IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBiID0gdGhpcyxcbiAgICAgICAgICAgIGMgPSBiLm1heCAtIGIubWluLFxuICAgICAgICAgICAgZSA9IGIuYXhpc1BvaW50UmFuZ2UgfHwgMCxcbiAgICAgICAgICAgIHAgPSAwLFxuICAgICAgICAgICAgbCA9IDAsXG4gICAgICAgICAgICBrID0gYi5saW5rZWRQYXJlbnQsXG4gICAgICAgICAgICB2ID0gISFiLmNhdGVnb3JpZXMsXG4gICAgICAgICAgICBtID0gYi50cmFuc0EsXG4gICAgICAgICAgICBkID0gYi5pc1hBeGlzO1xuXG4gICAgICAgIGlmIChkIHx8IHYgfHwgZSkge1xuICAgICAgICAgIHZhciBuID0gYi5nZXRDbG9zZXN0KCk7XG4gICAgICAgICAgayA/IChwID0gay5taW5Qb2ludE9mZnNldCwgbCA9IGsucG9pbnRSYW5nZVBhZGRpbmcpIDogYi5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgdmFyIGMgPSB2ID8gMSA6IGQgPyB6KGEub3B0aW9ucy5wb2ludFJhbmdlLCBuLCAwKSA6IGIuYXhpc1BvaW50UmFuZ2UgfHwgMCxcbiAgICAgICAgICAgICAgICB4ID0gYS5vcHRpb25zLnBvaW50UGxhY2VtZW50O1xuICAgICAgICAgICAgZSA9IE1hdGgubWF4KGUsIGMpO1xuICAgICAgICAgICAgaWYgKCFiLnNpbmdsZSB8fCB2KSBhID0gYS5pcyhcInhyYW5nZVwiKSA/ICFkIDogZCwgcCA9IE1hdGgubWF4KHAsIGEgJiYgZih4KSA/IDAgOiBjIC8gMiksIGwgPSBNYXRoLm1heChsLCBhICYmIFwib25cIiA9PT0geCA/IDAgOiBjKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBrID0gYi5vcmRpbmFsU2xvcGUgJiYgbiA/IGIub3JkaW5hbFNsb3BlIC8gbiA6IDE7XG4gICAgICAgICAgYi5taW5Qb2ludE9mZnNldCA9IHAgKj0gaztcbiAgICAgICAgICBiLnBvaW50UmFuZ2VQYWRkaW5nID0gbCAqPSBrO1xuICAgICAgICAgIGIucG9pbnRSYW5nZSA9IE1hdGgubWluKGUsIGIuc2luZ2xlICYmIHYgPyAxIDogYyk7XG4gICAgICAgICAgZCAmJiAoYi5jbG9zZXN0UG9pbnRSYW5nZSA9IG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgYSAmJiAoYi5vbGRUcmFuc0EgPSBtKTtcbiAgICAgICAgYi50cmFuc2xhdGlvblNsb3BlID0gYi50cmFuc0EgPSBtID0gYi5zdGF0aWNTY2FsZSB8fCBiLmxlbiAvIChjICsgbCB8fCAxKTtcbiAgICAgICAgYi50cmFuc0IgPSBiLmhvcml6ID8gYi5sZWZ0IDogYi5ib3R0b207XG4gICAgICAgIGIubWluUGl4ZWxQYWRkaW5nID0gbSAqIHA7XG4gICAgICAgIHEodGhpcywgXCJhZnRlclNldEF4aXNUcmFuc2xhdGlvblwiKTtcbiAgICAgIH0sXG4gICAgICBtaW5Gcm9tUmFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4IC0gdGhpcy5yYW5nZTtcbiAgICAgIH0sXG4gICAgICBzZXRUaWNrSW50ZXJ2YWw6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBiID0gdGhpcyxcbiAgICAgICAgICAgIGMgPSBiLmNoYXJ0LFxuICAgICAgICAgICAgZiA9IGIub3B0aW9ucyxcbiAgICAgICAgICAgIHAgPSBiLmlzTG9nLFxuICAgICAgICAgICAgayA9IGIuaXNEYXRldGltZUF4aXMsXG4gICAgICAgICAgICB2ID0gYi5pc1hBeGlzLFxuICAgICAgICAgICAgZCA9IGIuaXNMaW5rZWQsXG4gICAgICAgICAgICBtID0gZi5tYXhQYWRkaW5nLFxuICAgICAgICAgICAgdyA9IGYubWluUGFkZGluZyxcbiAgICAgICAgICAgIEIgPSBmLnRpY2tJbnRlcnZhbCxcbiAgICAgICAgICAgIEwgPSBmLnRpY2tQaXhlbEludGVydmFsLFxuICAgICAgICAgICAgRiA9IGIuY2F0ZWdvcmllcyxcbiAgICAgICAgICAgIFYgPSBuKGIudGhyZXNob2xkKSA/IGIudGhyZXNob2xkIDogbnVsbCxcbiAgICAgICAgICAgIGcgPSBiLnNvZnRUaHJlc2hvbGQ7XG4gICAgICAgIGsgfHwgRiB8fCBkIHx8IHRoaXMuZ2V0VGlja0Ftb3VudCgpO1xuICAgICAgICB2YXIgSCA9IHooYi51c2VyTWluLCBmLm1pbik7XG4gICAgICAgIHZhciBLID0geihiLnVzZXJNYXgsIGYubWF4KTtcblxuICAgICAgICBpZiAoZCkge1xuICAgICAgICAgIGIubGlua2VkUGFyZW50ID0gY1tiLmNvbGxdW2YubGlua2VkVG9dO1xuICAgICAgICAgIHZhciBRID0gYi5saW5rZWRQYXJlbnQuZ2V0RXh0cmVtZXMoKTtcbiAgICAgICAgICBiLm1pbiA9IHooUS5taW4sIFEuZGF0YU1pbik7XG4gICAgICAgICAgYi5tYXggPSB6KFEubWF4LCBRLmRhdGFNYXgpO1xuICAgICAgICAgIGYudHlwZSAhPT0gYi5saW5rZWRQYXJlbnQub3B0aW9ucy50eXBlICYmIGgoMTEsIDEsIGMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghZyAmJiB0KFYpKSBpZiAoYi5kYXRhTWluID49IFYpIFEgPSBWLCB3ID0gMDtlbHNlIGlmIChiLmRhdGFNYXggPD0gVikge1xuICAgICAgICAgICAgdmFyIHUgPSBWO1xuICAgICAgICAgICAgbSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGIubWluID0geihILCBRLCBiLmRhdGFNaW4pO1xuICAgICAgICAgIGIubWF4ID0geihLLCB1LCBiLmRhdGFNYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcCAmJiAoYi5wb3NpdGl2ZVZhbHVlc09ubHkgJiYgIWEgJiYgMCA+PSBNYXRoLm1pbihiLm1pbiwgeihiLmRhdGFNaW4sIGIubWluKSkgJiYgaCgxMCwgMSwgYyksIGIubWluID0geShiLmxvZzJsaW4oYi5taW4pLCAxNiksIGIubWF4ID0geShiLmxvZzJsaW4oYi5tYXgpLCAxNikpO1xuICAgICAgICBiLnJhbmdlICYmIHQoYi5tYXgpICYmIChiLnVzZXJNaW4gPSBiLm1pbiA9IEggPSBNYXRoLm1heChiLmRhdGFNaW4sIGIubWluRnJvbVJhbmdlKCkpLCBiLnVzZXJNYXggPSBLID0gYi5tYXgsIGIucmFuZ2UgPSBudWxsKTtcbiAgICAgICAgcShiLCBcImZvdW5kRXh0cmVtZXNcIik7XG4gICAgICAgIGIuYmVmb3JlUGFkZGluZyAmJiBiLmJlZm9yZVBhZGRpbmcoKTtcbiAgICAgICAgYi5hZGp1c3RGb3JNaW5SYW5nZSgpO1xuICAgICAgICAhKEYgfHwgYi5heGlzUG9pbnRSYW5nZSB8fCBiLnVzZVBlcmNlbnRhZ2UgfHwgZCkgJiYgdChiLm1pbikgJiYgdChiLm1heCkgJiYgKGMgPSBiLm1heCAtIGIubWluKSAmJiAoIXQoSCkgJiYgdyAmJiAoYi5taW4gLT0gYyAqIHcpLCAhdChLKSAmJiBtICYmIChiLm1heCArPSBjICogbSkpO1xuICAgICAgICBuKGIudXNlck1pbikgfHwgKG4oZi5zb2Z0TWluKSAmJiBmLnNvZnRNaW4gPCBiLm1pbiAmJiAoYi5taW4gPSBIID0gZi5zb2Z0TWluKSwgbihmLmZsb29yKSAmJiAoYi5taW4gPSBNYXRoLm1heChiLm1pbiwgZi5mbG9vcikpKTtcbiAgICAgICAgbihiLnVzZXJNYXgpIHx8IChuKGYuc29mdE1heCkgJiYgZi5zb2Z0TWF4ID4gYi5tYXggJiYgKGIubWF4ID0gSyA9IGYuc29mdE1heCksIG4oZi5jZWlsaW5nKSAmJiAoYi5tYXggPSBNYXRoLm1pbihiLm1heCwgZi5jZWlsaW5nKSkpO1xuICAgICAgICBnICYmIHQoYi5kYXRhTWluKSAmJiAoViA9IFYgfHwgMCwgIXQoSCkgJiYgYi5taW4gPCBWICYmIGIuZGF0YU1pbiA+PSBWID8gYi5taW4gPSBiLm9wdGlvbnMubWluUmFuZ2UgPyBNYXRoLm1pbihWLCBiLm1heCAtIGIubWluUmFuZ2UpIDogViA6ICF0KEspICYmIGIubWF4ID4gViAmJiBiLmRhdGFNYXggPD0gViAmJiAoYi5tYXggPSBiLm9wdGlvbnMubWluUmFuZ2UgPyBNYXRoLm1heChWLCBiLm1pbiArIGIubWluUmFuZ2UpIDogVikpO1xuICAgICAgICBiLnRpY2tJbnRlcnZhbCA9IGIubWluID09PSBiLm1heCB8fCBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgYi5taW4gfHwgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGIubWF4ID8gMSA6IGQgJiYgIUIgJiYgTCA9PT0gYi5saW5rZWRQYXJlbnQub3B0aW9ucy50aWNrUGl4ZWxJbnRlcnZhbCA/IEIgPSBiLmxpbmtlZFBhcmVudC50aWNrSW50ZXJ2YWwgOiB6KEIsIHRoaXMudGlja0Ftb3VudCA/IChiLm1heCAtIGIubWluKSAvIE1hdGgubWF4KHRoaXMudGlja0Ftb3VudCAtIDEsIDEpIDogdm9pZCAwLCBGID8gMSA6IChiLm1heCAtIGIubWluKSAqIEwgLyBNYXRoLm1heChiLmxlbiwgTCkpO1xuICAgICAgICB2ICYmICFhICYmIGIuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhLnByb2Nlc3NEYXRhKGIubWluICE9PSBiLm9sZE1pbiB8fCBiLm1heCAhPT0gYi5vbGRNYXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgYi5zZXRBeGlzVHJhbnNsYXRpb24oITApO1xuICAgICAgICBiLmJlZm9yZVNldFRpY2tQb3NpdGlvbnMgJiYgYi5iZWZvcmVTZXRUaWNrUG9zaXRpb25zKCk7XG4gICAgICAgIGIucG9zdFByb2Nlc3NUaWNrSW50ZXJ2YWwgJiYgKGIudGlja0ludGVydmFsID0gYi5wb3N0UHJvY2Vzc1RpY2tJbnRlcnZhbChiLnRpY2tJbnRlcnZhbCkpO1xuICAgICAgICBiLnBvaW50UmFuZ2UgJiYgIUIgJiYgKGIudGlja0ludGVydmFsID0gTWF0aC5tYXgoYi5wb2ludFJhbmdlLCBiLnRpY2tJbnRlcnZhbCkpO1xuICAgICAgICBhID0geihmLm1pblRpY2tJbnRlcnZhbCwgYi5pc0RhdGV0aW1lQXhpcyAmJiBiLmNsb3Nlc3RQb2ludFJhbmdlKTtcbiAgICAgICAgIUIgJiYgYi50aWNrSW50ZXJ2YWwgPCBhICYmIChiLnRpY2tJbnRlcnZhbCA9IGEpO1xuICAgICAgICBrIHx8IHAgfHwgQiB8fCAoYi50aWNrSW50ZXJ2YWwgPSBsKGIudGlja0ludGVydmFsLCBudWxsLCBlKGIudGlja0ludGVydmFsKSwgeihmLmFsbG93RGVjaW1hbHMsICEoLjUgPCBiLnRpY2tJbnRlcnZhbCAmJiA1ID4gYi50aWNrSW50ZXJ2YWwgJiYgMUUzIDwgYi5tYXggJiYgOTk5OSA+IGIubWF4KSksICEhdGhpcy50aWNrQW1vdW50KSk7XG4gICAgICAgIHRoaXMudGlja0Ftb3VudCB8fCAoYi50aWNrSW50ZXJ2YWwgPSBiLnVuc3F1aXNoKCkpO1xuICAgICAgICB0aGlzLnNldFRpY2tQb3NpdGlvbnMoKTtcbiAgICAgIH0sXG4gICAgICBzZXRUaWNrUG9zaXRpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgYiA9IGEudGlja1Bvc2l0aW9ucztcbiAgICAgICAgdmFyIGMgPSB0aGlzLmdldE1pbm9yVGlja0ludGVydmFsKCk7XG4gICAgICAgIHZhciBmID0gYS50aWNrUG9zaXRpb25lcixcbiAgICAgICAgICAgIGUgPSBhLnN0YXJ0T25UaWNrLFxuICAgICAgICAgICAgbCA9IGEuZW5kT25UaWNrO1xuICAgICAgICB0aGlzLnRpY2ttYXJrT2Zmc2V0ID0gdGhpcy5jYXRlZ29yaWVzICYmIFwiYmV0d2VlblwiID09PSBhLnRpY2ttYXJrUGxhY2VtZW50ICYmIDEgPT09IHRoaXMudGlja0ludGVydmFsID8gLjUgOiAwO1xuICAgICAgICB0aGlzLm1pbm9yVGlja0ludGVydmFsID0gXCJhdXRvXCIgPT09IGMgJiYgdGhpcy50aWNrSW50ZXJ2YWwgPyB0aGlzLnRpY2tJbnRlcnZhbCAvIDUgOiBjO1xuICAgICAgICB0aGlzLnNpbmdsZSA9IHRoaXMubWluID09PSB0aGlzLm1heCAmJiB0KHRoaXMubWluKSAmJiAhdGhpcy50aWNrQW1vdW50ICYmIChwYXJzZUludCh0aGlzLm1pbiwgMTApID09PSB0aGlzLm1pbiB8fCAhMSAhPT0gYS5hbGxvd0RlY2ltYWxzKTtcbiAgICAgICAgdGhpcy50aWNrUG9zaXRpb25zID0gYyA9IGIgJiYgYi5zbGljZSgpO1xuICAgICAgICAhYyAmJiAoIXRoaXMub3JkaW5hbFBvc2l0aW9ucyAmJiAodGhpcy5tYXggLSB0aGlzLm1pbikgLyB0aGlzLnRpY2tJbnRlcnZhbCA+IE1hdGgubWF4KDIgKiB0aGlzLmxlbiwgMjAwKSA/IChjID0gW3RoaXMubWluLCB0aGlzLm1heF0sIGgoMTksICExLCB0aGlzLmNoYXJ0KSkgOiBjID0gdGhpcy5pc0RhdGV0aW1lQXhpcyA/IHRoaXMuZ2V0VGltZVRpY2tzKHRoaXMubm9ybWFsaXplVGltZVRpY2tJbnRlcnZhbCh0aGlzLnRpY2tJbnRlcnZhbCwgYS51bml0cyksIHRoaXMubWluLCB0aGlzLm1heCwgYS5zdGFydE9mV2VlaywgdGhpcy5vcmRpbmFsUG9zaXRpb25zLCB0aGlzLmNsb3Nlc3RQb2ludFJhbmdlLCAhMCkgOiB0aGlzLmlzTG9nID8gdGhpcy5nZXRMb2dUaWNrUG9zaXRpb25zKHRoaXMudGlja0ludGVydmFsLCB0aGlzLm1pbiwgdGhpcy5tYXgpIDogdGhpcy5nZXRMaW5lYXJUaWNrUG9zaXRpb25zKHRoaXMudGlja0ludGVydmFsLCB0aGlzLm1pbiwgdGhpcy5tYXgpLCBjLmxlbmd0aCA+IHRoaXMubGVuICYmIChjID0gW2NbMF0sIGMucG9wKCldLCBjWzBdID09PSBjWzFdICYmIChjLmxlbmd0aCA9IDEpKSwgdGhpcy50aWNrUG9zaXRpb25zID0gYywgZiAmJiAoZiA9IGYuYXBwbHkodGhpcywgW3RoaXMubWluLCB0aGlzLm1heF0pKSkgJiYgKHRoaXMudGlja1Bvc2l0aW9ucyA9IGMgPSBmKTtcbiAgICAgICAgdGhpcy5wYWRkZWRUaWNrcyA9IGMuc2xpY2UoMCk7XG4gICAgICAgIHRoaXMudHJpbVRpY2tzKGMsIGUsIGwpO1xuICAgICAgICB0aGlzLmlzTGlua2VkIHx8ICh0aGlzLnNpbmdsZSAmJiAyID4gYy5sZW5ndGggJiYgIXRoaXMuY2F0ZWdvcmllcyAmJiAhdGhpcy5zZXJpZXMuc29tZShmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHJldHVybiBiLmlzKFwiaGVhdG1hcFwiKSAmJiBcImJldHdlZW5cIiA9PT0gYi5vcHRpb25zLnBvaW50UGxhY2VtZW50O1xuICAgICAgICB9KSAmJiAodGhpcy5taW4gLT0gLjUsIHRoaXMubWF4ICs9IC41KSwgYiB8fCBmIHx8IHRoaXMuYWRqdXN0VGlja0Ftb3VudCgpKTtcbiAgICAgICAgcSh0aGlzLCBcImFmdGVyU2V0VGlja1Bvc2l0aW9uc1wiKTtcbiAgICAgIH0sXG4gICAgICB0cmltVGlja3M6IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgIHZhciBmID0gYVswXSxcbiAgICAgICAgICAgIGUgPSBhW2EubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwID0gIXRoaXMuaXNPcmRpbmFsICYmIHRoaXMubWluUG9pbnRPZmZzZXQgfHwgMDtcbiAgICAgICAgcSh0aGlzLCBcInRyaW1UaWNrc1wiKTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNMaW5rZWQpIHtcbiAgICAgICAgICBpZiAoYiAmJiAtSW5maW5pdHkgIT09IGYpIHRoaXMubWluID0gZjtlbHNlIGZvciAoOyB0aGlzLm1pbiAtIHAgPiBhWzBdOykgYS5zaGlmdCgpO1xuICAgICAgICAgIGlmIChjKSB0aGlzLm1heCA9IGU7ZWxzZSBmb3IgKDsgdGhpcy5tYXggKyBwIDwgYVthLmxlbmd0aCAtIDFdOykgYS5wb3AoKTtcbiAgICAgICAgICAwID09PSBhLmxlbmd0aCAmJiB0KGYpICYmICF0aGlzLm9wdGlvbnMudGlja1Bvc2l0aW9ucyAmJiBhLnB1c2goKGUgKyBmKSAvIDIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWxpZ25Ub090aGVyczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHt9LFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICExID09PSB0aGlzLmNoYXJ0Lm9wdGlvbnMuY2hhcnQuYWxpZ25UaWNrcyB8fCAhMSA9PT0gYy5hbGlnblRpY2tzIHx8ICExID09PSBjLnN0YXJ0T25UaWNrIHx8ICExID09PSBjLmVuZE9uVGljayB8fCB0aGlzLmlzTG9nIHx8IHRoaXMuY2hhcnRbdGhpcy5jb2xsXS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgdmFyIGYgPSBjLm9wdGlvbnM7XG4gICAgICAgICAgZiA9IFtjLmhvcml6ID8gZi5sZWZ0IDogZi50b3AsIGYud2lkdGgsIGYuaGVpZ2h0LCBmLnBhbmVdLmpvaW4oKTtcbiAgICAgICAgICBjLnNlcmllcy5sZW5ndGggJiYgKGFbZl0gPyBiID0gITAgOiBhW2ZdID0gMSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0sXG4gICAgICBnZXRUaWNrQW1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgYiA9IGEudGlja0Ftb3VudCxcbiAgICAgICAgICAgIGMgPSBhLnRpY2tQaXhlbEludGVydmFsO1xuICAgICAgICAhdChhLnRpY2tJbnRlcnZhbCkgJiYgdGhpcy5sZW4gPCBjICYmICF0aGlzLmlzUmFkaWFsICYmICF0aGlzLmlzTG9nICYmIGEuc3RhcnRPblRpY2sgJiYgYS5lbmRPblRpY2sgJiYgKGIgPSAyKTtcbiAgICAgICAgIWIgJiYgdGhpcy5hbGlnblRvT3RoZXJzKCkgJiYgKGIgPSBNYXRoLmNlaWwodGhpcy5sZW4gLyBjKSArIDEpO1xuICAgICAgICA0ID4gYiAmJiAodGhpcy5maW5hbFRpY2tBbXQgPSBiLCBiID0gNSk7XG4gICAgICAgIHRoaXMudGlja0Ftb3VudCA9IGI7XG4gICAgICB9LFxuICAgICAgYWRqdXN0VGlja0Ftb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGIgPSB0aGlzLnRpY2tJbnRlcnZhbCxcbiAgICAgICAgICAgIGMgPSB0aGlzLnRpY2tQb3NpdGlvbnMsXG4gICAgICAgICAgICBmID0gdGhpcy50aWNrQW1vdW50LFxuICAgICAgICAgICAgZSA9IHRoaXMuZmluYWxUaWNrQW10LFxuICAgICAgICAgICAgbCA9IGMgJiYgYy5sZW5ndGgsXG4gICAgICAgICAgICBrID0geih0aGlzLnRocmVzaG9sZCwgdGhpcy5zb2Z0VGhyZXNob2xkID8gMCA6IG51bGwpLFxuICAgICAgICAgICAgdjtcblxuICAgICAgICBpZiAodGhpcy5oYXNEYXRhKCkpIHtcbiAgICAgICAgICBpZiAobCA8IGYpIHtcbiAgICAgICAgICAgIGZvciAodiA9IHRoaXMubWluOyBjLmxlbmd0aCA8IGY7KSBjLmxlbmd0aCAlIDIgfHwgdiA9PT0gayA/IGMucHVzaCh5KGNbYy5sZW5ndGggLSAxXSArIGIpKSA6IGMudW5zaGlmdCh5KGNbMF0gLSBiKSk7XG5cbiAgICAgICAgICAgIHRoaXMudHJhbnNBICo9IChsIC0gMSkgLyAoZiAtIDEpO1xuICAgICAgICAgICAgdGhpcy5taW4gPSBhLnN0YXJ0T25UaWNrID8gY1swXSA6IE1hdGgubWluKHRoaXMubWluLCBjWzBdKTtcbiAgICAgICAgICAgIHRoaXMubWF4ID0gYS5lbmRPblRpY2sgPyBjW2MubGVuZ3RoIC0gMV0gOiBNYXRoLm1heCh0aGlzLm1heCwgY1tjLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICB9IGVsc2UgbCA+IGYgJiYgKHRoaXMudGlja0ludGVydmFsICo9IDIsIHRoaXMuc2V0VGlja1Bvc2l0aW9ucygpKTtcblxuICAgICAgICAgIGlmICh0KGUpKSB7XG4gICAgICAgICAgICBmb3IgKGIgPSBhID0gYy5sZW5ndGg7IGItLTspICgzID09PSBlICYmIDEgPT09IGIgJSAyIHx8IDIgPj0gZSAmJiAwIDwgYiAmJiBiIDwgYSAtIDEpICYmIGMuc3BsaWNlKGIsIDEpO1xuXG4gICAgICAgICAgICB0aGlzLmZpbmFsVGlja0FtdCA9IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXRTY2FsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuc2VyaWVzLnNvbWUoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICByZXR1cm4gYi5pc0RpcnR5RGF0YSB8fCBiLmlzRGlydHkgfHwgYi54QXhpcyAmJiBiLnhBeGlzLmlzRGlydHk7XG4gICAgICAgIH0pLFxuICAgICAgICAgICAgYjtcbiAgICAgICAgdGhpcy5vbGRNaW4gPSB0aGlzLm1pbjtcbiAgICAgICAgdGhpcy5vbGRNYXggPSB0aGlzLm1heDtcbiAgICAgICAgdGhpcy5vbGRBeGlzTGVuZ3RoID0gdGhpcy5sZW47XG4gICAgICAgIHRoaXMuc2V0QXhpc1NpemUoKTtcbiAgICAgICAgKGIgPSB0aGlzLmxlbiAhPT0gdGhpcy5vbGRBeGlzTGVuZ3RoKSB8fCBhIHx8IHRoaXMuaXNMaW5rZWQgfHwgdGhpcy5mb3JjZVJlZHJhdyB8fCB0aGlzLnVzZXJNaW4gIT09IHRoaXMub2xkVXNlck1pbiB8fCB0aGlzLnVzZXJNYXggIT09IHRoaXMub2xkVXNlck1heCB8fCB0aGlzLmFsaWduVG9PdGhlcnMoKSA/ICh0aGlzLnJlc2V0U3RhY2tzICYmIHRoaXMucmVzZXRTdGFja3MoKSwgdGhpcy5mb3JjZVJlZHJhdyA9ICExLCB0aGlzLmdldFNlcmllc0V4dHJlbWVzKCksIHRoaXMuc2V0VGlja0ludGVydmFsKCksIHRoaXMub2xkVXNlck1pbiA9IHRoaXMudXNlck1pbiwgdGhpcy5vbGRVc2VyTWF4ID0gdGhpcy51c2VyTWF4LCB0aGlzLmlzRGlydHkgfHwgKHRoaXMuaXNEaXJ0eSA9IGIgfHwgdGhpcy5taW4gIT09IHRoaXMub2xkTWluIHx8IHRoaXMubWF4ICE9PSB0aGlzLm9sZE1heCkpIDogdGhpcy5jbGVhblN0YWNrcyAmJiB0aGlzLmNsZWFuU3RhY2tzKCk7XG4gICAgICAgIHEodGhpcywgXCJhZnRlclNldFNjYWxlXCIpO1xuICAgICAgfSxcbiAgICAgIHNldEV4dHJlbWVzOiBmdW5jdGlvbiAoYSwgYiwgYywgZiwgZSkge1xuICAgICAgICB2YXIgcCA9IHRoaXMsXG4gICAgICAgICAgICBsID0gcC5jaGFydDtcbiAgICAgICAgYyA9IHooYywgITApO1xuICAgICAgICBwLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgZGVsZXRlIGIua2RUcmVlO1xuICAgICAgICB9KTtcbiAgICAgICAgZSA9IE4oZSwge1xuICAgICAgICAgIG1pbjogYSxcbiAgICAgICAgICBtYXg6IGJcbiAgICAgICAgfSk7XG4gICAgICAgIHEocCwgXCJzZXRFeHRyZW1lc1wiLCBlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcC51c2VyTWluID0gYTtcbiAgICAgICAgICBwLnVzZXJNYXggPSBiO1xuICAgICAgICAgIHAuZXZlbnRBcmdzID0gZTtcbiAgICAgICAgICBjICYmIGwucmVkcmF3KGYpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB6b29tOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgYyA9IHRoaXMuZGF0YU1pbixcbiAgICAgICAgICAgIGYgPSB0aGlzLmRhdGFNYXgsXG4gICAgICAgICAgICBlID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgcCA9IE1hdGgubWluKGMsIHooZS5taW4sIGMpKSxcbiAgICAgICAgICAgIGwgPSBNYXRoLm1heChmLCB6KGUubWF4LCBmKSk7XG4gICAgICAgIGEgPSB7XG4gICAgICAgICAgbmV3TWluOiBhLFxuICAgICAgICAgIG5ld01heDogYlxuICAgICAgICB9O1xuICAgICAgICBxKHRoaXMsIFwiem9vbVwiLCBhLCBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHZhciBhID0gYi5uZXdNaW4sXG4gICAgICAgICAgICAgIGUgPSBiLm5ld01heDtcbiAgICAgICAgICBpZiAoYSAhPT0gdGhpcy5taW4gfHwgZSAhPT0gdGhpcy5tYXgpIHRoaXMuYWxsb3dab29tT3V0c2lkZSB8fCAodChjKSAmJiAoYSA8IHAgJiYgKGEgPSBwKSwgYSA+IGwgJiYgKGEgPSBsKSksIHQoZikgJiYgKGUgPCBwICYmIChlID0gcCksIGUgPiBsICYmIChlID0gbCkpKSwgdGhpcy5kaXNwbGF5QnRuID0gXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGEgfHwgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGUsIHRoaXMuc2V0RXh0cmVtZXMoYSwgZSwgITEsIHZvaWQgMCwge1xuICAgICAgICAgICAgdHJpZ2dlcjogXCJ6b29tXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBiLnpvb21lZCA9ICEwO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGEuem9vbWVkO1xuICAgICAgfSxcbiAgICAgIHNldEF4aXNTaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGIgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBjID0gYi5vZmZzZXRzIHx8IFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgIGYgPSB0aGlzLmhvcml6LFxuICAgICAgICAgICAgZSA9IHRoaXMud2lkdGggPSBNYXRoLnJvdW5kKHcoeihiLndpZHRoLCBhLnBsb3RXaWR0aCAtIGNbM10gKyBjWzFdKSwgYS5wbG90V2lkdGgpKSxcbiAgICAgICAgICAgIGwgPSB0aGlzLmhlaWdodCA9IE1hdGgucm91bmQodyh6KGIuaGVpZ2h0LCBhLnBsb3RIZWlnaHQgLSBjWzBdICsgY1syXSksIGEucGxvdEhlaWdodCkpLFxuICAgICAgICAgICAgayA9IHRoaXMudG9wID0gTWF0aC5yb3VuZCh3KHooYi50b3AsIGEucGxvdFRvcCArIGNbMF0pLCBhLnBsb3RIZWlnaHQsIGEucGxvdFRvcCkpO1xuICAgICAgICBiID0gdGhpcy5sZWZ0ID0gTWF0aC5yb3VuZCh3KHooYi5sZWZ0LCBhLnBsb3RMZWZ0ICsgY1szXSksIGEucGxvdFdpZHRoLCBhLnBsb3RMZWZ0KSk7XG4gICAgICAgIHRoaXMuYm90dG9tID0gYS5jaGFydEhlaWdodCAtIGwgLSBrO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gYS5jaGFydFdpZHRoIC0gZSAtIGI7XG4gICAgICAgIHRoaXMubGVuID0gTWF0aC5tYXgoZiA/IGUgOiBsLCAwKTtcbiAgICAgICAgdGhpcy5wb3MgPSBmID8gYiA6IGs7XG4gICAgICB9LFxuICAgICAgZ2V0RXh0cmVtZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmlzTG9nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1pbjogYSA/IHkodGhpcy5saW4ybG9nKHRoaXMubWluKSkgOiB0aGlzLm1pbixcbiAgICAgICAgICBtYXg6IGEgPyB5KHRoaXMubGluMmxvZyh0aGlzLm1heCkpIDogdGhpcy5tYXgsXG4gICAgICAgICAgZGF0YU1pbjogdGhpcy5kYXRhTWluLFxuICAgICAgICAgIGRhdGFNYXg6IHRoaXMuZGF0YU1heCxcbiAgICAgICAgICB1c2VyTWluOiB0aGlzLnVzZXJNaW4sXG4gICAgICAgICAgdXNlck1heDogdGhpcy51c2VyTWF4XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZ2V0VGhyZXNob2xkOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYiA9IHRoaXMuaXNMb2csXG4gICAgICAgICAgICBjID0gYiA/IHRoaXMubGluMmxvZyh0aGlzLm1pbikgOiB0aGlzLm1pbjtcbiAgICAgICAgYiA9IGIgPyB0aGlzLmxpbjJsb2codGhpcy5tYXgpIDogdGhpcy5tYXg7XG4gICAgICAgIG51bGwgPT09IGEgfHwgLUluZmluaXR5ID09PSBhID8gYSA9IGMgOiBJbmZpbml0eSA9PT0gYSA/IGEgPSBiIDogYyA+IGEgPyBhID0gYyA6IGIgPCBhICYmIChhID0gYik7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZShhLCAwLCAxLCAwLCAxKTtcbiAgICAgIH0sXG4gICAgICBhdXRvTGFiZWxBbGlnbjogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGIgPSAoeihhLCAwKSAtIDkwICogdGhpcy5zaWRlICsgNzIwKSAlIDM2MDtcbiAgICAgICAgYSA9IHtcbiAgICAgICAgICBhbGlnbjogXCJjZW50ZXJcIlxuICAgICAgICB9O1xuICAgICAgICBxKHRoaXMsIFwiYXV0b0xhYmVsQWxpZ25cIiwgYSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAxNSA8IGIgJiYgMTY1ID4gYiA/IGEuYWxpZ24gPSBcInJpZ2h0XCIgOiAxOTUgPCBiICYmIDM0NSA+IGIgJiYgKGEuYWxpZ24gPSBcImxlZnRcIik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYS5hbGlnbjtcbiAgICAgIH0sXG4gICAgICB0aWNrU2l6ZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBjID0gYlthICsgXCJMZW5ndGhcIl0sXG4gICAgICAgICAgICBmID0geihiW2EgKyBcIldpZHRoXCJdLCBcInRpY2tcIiA9PT0gYSAmJiB0aGlzLmlzWEF4aXMgJiYgIXRoaXMuY2F0ZWdvcmllcyA/IDEgOiAwKTtcblxuICAgICAgICBpZiAoZiAmJiBjKSB7XG4gICAgICAgICAgXCJpbnNpZGVcIiA9PT0gYlthICsgXCJQb3NpdGlvblwiXSAmJiAoYyA9IC1jKTtcbiAgICAgICAgICB2YXIgZSA9IFtjLCBmXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGEgPSB7XG4gICAgICAgICAgdGlja1NpemU6IGVcbiAgICAgICAgfTtcbiAgICAgICAgcSh0aGlzLCBcImFmdGVyVGlja1NpemVcIiwgYSk7XG4gICAgICAgIHJldHVybiBhLnRpY2tTaXplO1xuICAgICAgfSxcbiAgICAgIGxhYmVsTWV0cmljczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMudGlja1Bvc2l0aW9ucyAmJiB0aGlzLnRpY2tQb3NpdGlvbnNbMF0gfHwgMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhcnQucmVuZGVyZXIuZm9udE1ldHJpY3ModGhpcy5vcHRpb25zLmxhYmVscy5zdHlsZSAmJiB0aGlzLm9wdGlvbnMubGFiZWxzLnN0eWxlLmZvbnRTaXplLCB0aGlzLnRpY2tzW2FdICYmIHRoaXMudGlja3NbYV0ubGFiZWwpO1xuICAgICAgfSxcbiAgICAgIHVuc3F1aXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5vcHRpb25zLmxhYmVscyxcbiAgICAgICAgICAgIGIgPSB0aGlzLmhvcml6LFxuICAgICAgICAgICAgYyA9IHRoaXMudGlja0ludGVydmFsLFxuICAgICAgICAgICAgZiA9IGMsXG4gICAgICAgICAgICBlID0gdGhpcy5sZW4gLyAoKCh0aGlzLmNhdGVnb3JpZXMgPyAxIDogMCkgKyB0aGlzLm1heCAtIHRoaXMubWluKSAvIGMpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGsgPSBhLnJvdGF0aW9uLFxuICAgICAgICAgICAgdiA9IHRoaXMubGFiZWxNZXRyaWNzKCksXG4gICAgICAgICAgICBtLFxuICAgICAgICAgICAgZCA9IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBuLFxuICAgICAgICAgICAgdyA9IHRoaXMubWF4IC0gdGhpcy5taW4sXG4gICAgICAgICAgICBGID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICB2YXIgYSA9IGIgLyAoZSB8fCAxKTtcbiAgICAgICAgICBhID0gMSA8IGEgPyBNYXRoLmNlaWwoYSkgOiAxO1xuICAgICAgICAgIGEgKiBjID4gdyAmJiBJbmZpbml0eSAhPT0gYiAmJiBJbmZpbml0eSAhPT0gZSAmJiB3ICYmIChhID0gTWF0aC5jZWlsKHcgLyBjKSk7XG4gICAgICAgICAgcmV0dXJuIHkoYSAqIGMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGIgPyAobiA9ICFhLnN0YWdnZXJMaW5lcyAmJiAhYS5zdGVwICYmICh0KGspID8gW2tdIDogZSA8IHooYS5hdXRvUm90YXRpb25MaW1pdCwgODApICYmIGEuYXV0b1JvdGF0aW9uKSkgJiYgbi5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgaWYgKGIgPT09IGsgfHwgYiAmJiAtOTAgPD0gYiAmJiA5MCA+PSBiKSB7XG4gICAgICAgICAgICBtID0gRihNYXRoLmFicyh2LmggLyBNYXRoLnNpbihLICogYikpKTtcbiAgICAgICAgICAgIHZhciBhID0gbSArIE1hdGguYWJzKGIgLyAzNjApO1xuICAgICAgICAgICAgYSA8IGQgJiYgKGQgPSBhLCBsID0gYiwgZiA9IG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkgOiBhLnN0ZXAgfHwgKGYgPSBGKHYuaCkpO1xuICAgICAgICB0aGlzLmF1dG9Sb3RhdGlvbiA9IG47XG4gICAgICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IHoobCwgayk7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfSxcbiAgICAgIGdldFNsb3RXaWR0aDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgYyA9IHRoaXMuaG9yaXosXG4gICAgICAgICAgICBmID0gdGhpcy5vcHRpb25zLmxhYmVscyxcbiAgICAgICAgICAgIGUgPSBNYXRoLm1heCh0aGlzLnRpY2tQb3NpdGlvbnMubGVuZ3RoIC0gKHRoaXMuY2F0ZWdvcmllcyA/IDAgOiAxKSwgMSksXG4gICAgICAgICAgICBsID0gYi5tYXJnaW5bM107XG4gICAgICAgIHJldHVybiBhICYmIGEuc2xvdFdpZHRoIHx8IGMgJiYgMiA+IChmLnN0ZXAgfHwgMCkgJiYgIWYucm90YXRpb24gJiYgKHRoaXMuc3RhZ2dlckxpbmVzIHx8IDEpICogdGhpcy5sZW4gLyBlIHx8ICFjICYmIChmLnN0eWxlICYmIHBhcnNlSW50KGYuc3R5bGUud2lkdGgsIDEwKSB8fCBsICYmIGwgLSBiLnNwYWNpbmdbM10gfHwgLjMzICogYi5jaGFydFdpZHRoKTtcbiAgICAgIH0sXG4gICAgICByZW5kZXJVbnNxdWlzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBiID0gYS5yZW5kZXJlcixcbiAgICAgICAgICAgIGMgPSB0aGlzLnRpY2tQb3NpdGlvbnMsXG4gICAgICAgICAgICBlID0gdGhpcy50aWNrcyxcbiAgICAgICAgICAgIGwgPSB0aGlzLm9wdGlvbnMubGFiZWxzLFxuICAgICAgICAgICAgayA9IGwgJiYgbC5zdHlsZSB8fCB7fSxcbiAgICAgICAgICAgIHYgPSB0aGlzLmhvcml6LFxuICAgICAgICAgICAgZCA9IHRoaXMuZ2V0U2xvdFdpZHRoKCksXG4gICAgICAgICAgICBtID0gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChkIC0gMiAqIChsLnBhZGRpbmcgfHwgNSkpKSxcbiAgICAgICAgICAgIG4gPSB7fSxcbiAgICAgICAgICAgIHcgPSB0aGlzLmxhYmVsTWV0cmljcygpLFxuICAgICAgICAgICAgaCA9IGwuc3R5bGUgJiYgbC5zdHlsZS50ZXh0T3ZlcmZsb3csXG4gICAgICAgICAgICBGID0gMDtcbiAgICAgICAgZihsLnJvdGF0aW9uKSB8fCAobi5yb3RhdGlvbiA9IGwucm90YXRpb24gfHwgMCk7XG4gICAgICAgIGMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGIgPSBlW2JdO1xuICAgICAgICAgIGIubW92ZWRMYWJlbCAmJiBiLnJlcGxhY2VNb3ZlZExhYmVsKCk7XG4gICAgICAgICAgYiAmJiBiLmxhYmVsICYmIGIubGFiZWwudGV4dFB4TGVuZ3RoID4gRiAmJiAoRiA9IGIubGFiZWwudGV4dFB4TGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4TGFiZWxMZW5ndGggPSBGO1xuICAgICAgICBpZiAodGhpcy5hdXRvUm90YXRpb24pIEYgPiBtICYmIEYgPiB3LmggPyBuLnJvdGF0aW9uID0gdGhpcy5sYWJlbFJvdGF0aW9uIDogdGhpcy5sYWJlbFJvdGF0aW9uID0gMDtlbHNlIGlmIChkKSB7XG4gICAgICAgICAgdmFyIHogPSBtO1xuXG4gICAgICAgICAgaWYgKCFoKSB7XG4gICAgICAgICAgICB2YXIgcSA9IFwiY2xpcFwiO1xuXG4gICAgICAgICAgICBmb3IgKG0gPSBjLmxlbmd0aDsgIXYgJiYgbS0tOykge1xuICAgICAgICAgICAgICB2YXIgQiA9IGNbbV07XG4gICAgICAgICAgICAgIGlmIChCID0gZVtCXS5sYWJlbCkgQi5zdHlsZXMgJiYgXCJlbGxpcHNpc1wiID09PSBCLnN0eWxlcy50ZXh0T3ZlcmZsb3cgPyBCLmNzcyh7XG4gICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiBcImNsaXBcIlxuICAgICAgICAgICAgICB9KSA6IEIudGV4dFB4TGVuZ3RoID4gZCAmJiBCLmNzcyh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGQgKyBcInB4XCJcbiAgICAgICAgICAgICAgfSksIEIuZ2V0QkJveCgpLmhlaWdodCA+IHRoaXMubGVuIC8gYy5sZW5ndGggLSAody5oIC0gdy5mKSAmJiAoQi5zcGVjaWZpY1RleHRPdmVyZmxvdyA9IFwiZWxsaXBzaXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG4ucm90YXRpb24gJiYgKHogPSBGID4gLjUgKiBhLmNoYXJ0SGVpZ2h0ID8gLjMzICogYS5jaGFydEhlaWdodCA6IEYsIGggfHwgKHEgPSBcImVsbGlwc2lzXCIpKTtcbiAgICAgICAgaWYgKHRoaXMubGFiZWxBbGlnbiA9IGwuYWxpZ24gfHwgdGhpcy5hdXRvTGFiZWxBbGlnbih0aGlzLmxhYmVsUm90YXRpb24pKSBuLmFsaWduID0gdGhpcy5sYWJlbEFsaWduO1xuICAgICAgICBjLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICB2YXIgYSA9IChiID0gZVtiXSkgJiYgYi5sYWJlbCxcbiAgICAgICAgICAgICAgYyA9IGsud2lkdGgsXG4gICAgICAgICAgICAgIGYgPSB7fTtcbiAgICAgICAgICBhICYmIChhLmF0dHIobiksIGIuc2hvcnRlbkxhYmVsID8gYi5zaG9ydGVuTGFiZWwoKSA6IHogJiYgIWMgJiYgXCJub3dyYXBcIiAhPT0gay53aGl0ZVNwYWNlICYmICh6IDwgYS50ZXh0UHhMZW5ndGggfHwgXCJTUEFOXCIgPT09IGEuZWxlbWVudC50YWdOYW1lKSA/IChmLndpZHRoID0geiwgaCB8fCAoZi50ZXh0T3ZlcmZsb3cgPSBhLnNwZWNpZmljVGV4dE92ZXJmbG93IHx8IHEpLCBhLmNzcyhmKSkgOiBhLnN0eWxlcyAmJiBhLnN0eWxlcy53aWR0aCAmJiAhZi53aWR0aCAmJiAhYyAmJiBhLmNzcyh7XG4gICAgICAgICAgICB3aWR0aDogbnVsbFxuICAgICAgICAgIH0pLCBkZWxldGUgYS5zcGVjaWZpY1RleHRPdmVyZmxvdywgYi5yb3RhdGlvbiA9IG4ucm90YXRpb24pO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdGhpcy50aWNrUm90Q29yciA9IGIucm90Q29ycih3LmIsIHRoaXMubGFiZWxSb3RhdGlvbiB8fCAwLCAwICE9PSB0aGlzLnNpZGUpO1xuICAgICAgfSxcbiAgICAgIGhhc0RhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWVzLnNvbWUoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICByZXR1cm4gYS5oYXNEYXRhKCk7XG4gICAgICAgIH0pIHx8IHRoaXMub3B0aW9ucy5zaG93RW1wdHkgJiYgdCh0aGlzLm1pbikgJiYgdCh0aGlzLm1heCk7XG4gICAgICB9LFxuICAgICAgYWRkVGl0bGU6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5jaGFydC5yZW5kZXJlcixcbiAgICAgICAgICAgIGYgPSB0aGlzLmhvcml6LFxuICAgICAgICAgICAgZSA9IHRoaXMub3Bwb3NpdGUsXG4gICAgICAgICAgICBsID0gdGhpcy5vcHRpb25zLnRpdGxlLFxuICAgICAgICAgICAgcCxcbiAgICAgICAgICAgIGsgPSB0aGlzLmNoYXJ0LnN0eWxlZE1vZGU7XG4gICAgICAgIHRoaXMuYXhpc1RpdGxlIHx8ICgocCA9IGwudGV4dEFsaWduKSB8fCAocCA9IChmID8ge1xuICAgICAgICAgIGxvdzogXCJsZWZ0XCIsXG4gICAgICAgICAgbWlkZGxlOiBcImNlbnRlclwiLFxuICAgICAgICAgIGhpZ2g6IFwicmlnaHRcIlxuICAgICAgICB9IDoge1xuICAgICAgICAgIGxvdzogZSA/IFwicmlnaHRcIiA6IFwibGVmdFwiLFxuICAgICAgICAgIG1pZGRsZTogXCJjZW50ZXJcIixcbiAgICAgICAgICBoaWdoOiBlID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCJcbiAgICAgICAgfSlbbC5hbGlnbl0pLCB0aGlzLmF4aXNUaXRsZSA9IGIudGV4dChsLnRleHQsIDAsIDAsIGwudXNlSFRNTCkuYXR0cih7XG4gICAgICAgICAgekluZGV4OiA3LFxuICAgICAgICAgIHJvdGF0aW9uOiBsLnJvdGF0aW9uIHx8IDAsXG4gICAgICAgICAgYWxpZ246IHBcbiAgICAgICAgfSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWF4aXMtdGl0bGVcIiksIGsgfHwgdGhpcy5heGlzVGl0bGUuY3NzKGEobC5zdHlsZSkpLCB0aGlzLmF4aXNUaXRsZS5hZGQodGhpcy5heGlzR3JvdXApLCB0aGlzLmF4aXNUaXRsZS5pc05ldyA9ICEwKTtcbiAgICAgICAgayB8fCBsLnN0eWxlLndpZHRoIHx8IHRoaXMuaXNSYWRpYWwgfHwgdGhpcy5heGlzVGl0bGUuY3NzKHtcbiAgICAgICAgICB3aWR0aDogdGhpcy5sZW5cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXhpc1RpdGxlW2MgPyBcInNob3dcIiA6IFwiaGlkZVwiXShjKTtcbiAgICAgIH0sXG4gICAgICBnZW5lcmF0ZVRpY2s6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy50aWNrcztcbiAgICAgICAgYlthXSA/IGJbYV0uYWRkTGFiZWwoKSA6IGJbYV0gPSBuZXcgcih0aGlzLCBhKTtcbiAgICAgIH0sXG4gICAgICBnZXRPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgYiA9IGEuY2hhcnQsXG4gICAgICAgICAgICBjID0gYi5yZW5kZXJlcixcbiAgICAgICAgICAgIGYgPSBhLm9wdGlvbnMsXG4gICAgICAgICAgICBlID0gYS50aWNrUG9zaXRpb25zLFxuICAgICAgICAgICAgbCA9IGEudGlja3MsXG4gICAgICAgICAgICBrID0gYS5ob3JpeixcbiAgICAgICAgICAgIGQgPSBhLnNpZGUsXG4gICAgICAgICAgICBtID0gYi5pbnZlcnRlZCAmJiAhYS5pc1pBeGlzID8gWzEsIDAsIDMsIDJdW2RdIDogZCxcbiAgICAgICAgICAgIG4sXG4gICAgICAgICAgICB3ID0gMCxcbiAgICAgICAgICAgIGggPSAwLFxuICAgICAgICAgICAgRiA9IGYudGl0bGUsXG4gICAgICAgICAgICBCID0gZi5sYWJlbHMsXG4gICAgICAgICAgICBMID0gMCxcbiAgICAgICAgICAgIGcgPSBiLmF4aXNPZmZzZXQ7XG4gICAgICAgIGIgPSBiLmNsaXBPZmZzZXQ7XG4gICAgICAgIHZhciBIID0gWy0xLCAxLCAxLCAtMV1bZF0sXG4gICAgICAgICAgICBLID0gZi5jbGFzc05hbWUsXG4gICAgICAgICAgICBRID0gYS5heGlzUGFyZW50O1xuICAgICAgICB2YXIgeSA9IGEuaGFzRGF0YSgpO1xuICAgICAgICBhLnNob3dBeGlzID0gbiA9IHkgfHwgeihmLnNob3dFbXB0eSwgITApO1xuICAgICAgICBhLnN0YWdnZXJMaW5lcyA9IGEuaG9yaXogJiYgQi5zdGFnZ2VyTGluZXM7XG4gICAgICAgIGEuYXhpc0dyb3VwIHx8IChhLmdyaWRHcm91cCA9IGMuZyhcImdyaWRcIikuYXR0cih7XG4gICAgICAgICAgekluZGV4OiBmLmdyaWRaSW5kZXggfHwgMVxuICAgICAgICB9KS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtXCIgKyB0aGlzLmNvbGwudG9Mb3dlckNhc2UoKSArIFwiLWdyaWQgXCIgKyAoSyB8fCBcIlwiKSkuYWRkKFEpLCBhLmF4aXNHcm91cCA9IGMuZyhcImF4aXNcIikuYXR0cih7XG4gICAgICAgICAgekluZGV4OiBmLnpJbmRleCB8fCAyXG4gICAgICAgIH0pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIiArIHRoaXMuY29sbC50b0xvd2VyQ2FzZSgpICsgXCIgXCIgKyAoSyB8fCBcIlwiKSkuYWRkKFEpLCBhLmxhYmVsR3JvdXAgPSBjLmcoXCJheGlzLWxhYmVsc1wiKS5hdHRyKHtcbiAgICAgICAgICB6SW5kZXg6IEIuekluZGV4IHx8IDdcbiAgICAgICAgfSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLVwiICsgYS5jb2xsLnRvTG93ZXJDYXNlKCkgKyBcIi1sYWJlbHMgXCIgKyAoSyB8fCBcIlwiKSkuYWRkKFEpKTtcbiAgICAgICAgeSB8fCBhLmlzTGlua2VkID8gKGUuZm9yRWFjaChmdW5jdGlvbiAoYiwgYykge1xuICAgICAgICAgIGEuZ2VuZXJhdGVUaWNrKGIsIGMpO1xuICAgICAgICB9KSwgYS5yZW5kZXJVbnNxdWlzaCgpLCBhLnJlc2VydmVTcGFjZURlZmF1bHQgPSAwID09PSBkIHx8IDIgPT09IGQgfHwge1xuICAgICAgICAgIDE6IFwibGVmdFwiLFxuICAgICAgICAgIDM6IFwicmlnaHRcIlxuICAgICAgICB9W2RdID09PSBhLmxhYmVsQWxpZ24sIHooQi5yZXNlcnZlU3BhY2UsIFwiY2VudGVyXCIgPT09IGEubGFiZWxBbGlnbiA/ICEwIDogbnVsbCwgYS5yZXNlcnZlU3BhY2VEZWZhdWx0KSAmJiBlLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBMID0gTWF0aC5tYXgobFtiXS5nZXRMYWJlbFNpemUoKSwgTCk7XG4gICAgICAgIH0pLCBhLnN0YWdnZXJMaW5lcyAmJiAoTCAqPSBhLnN0YWdnZXJMaW5lcyksIGEubGFiZWxPZmZzZXQgPSBMICogKGEub3Bwb3NpdGUgPyAtMSA6IDEpKSA6IHYobCwgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBiLmRlc3Ryb3koKTtcbiAgICAgICAgICBkZWxldGUgbFthXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKEYgJiYgRi50ZXh0ICYmICExICE9PSBGLmVuYWJsZWQgJiYgKGEuYWRkVGl0bGUobiksIG4gJiYgITEgIT09IEYucmVzZXJ2ZVNwYWNlKSkge1xuICAgICAgICAgIGEudGl0bGVPZmZzZXQgPSB3ID0gYS5heGlzVGl0bGUuZ2V0QkJveCgpW2sgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiXTtcbiAgICAgICAgICB2YXIgdSA9IEYub2Zmc2V0O1xuICAgICAgICAgIGggPSB0KHUpID8gMCA6IHooRi5tYXJnaW4sIGsgPyA1IDogMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgYS5yZW5kZXJMaW5lKCk7XG4gICAgICAgIGEub2Zmc2V0ID0gSCAqIHooZi5vZmZzZXQsIGdbZF0gPyBnW2RdICsgKGYubWFyZ2luIHx8IDApIDogMCk7XG4gICAgICAgIGEudGlja1JvdENvcnIgPSBhLnRpY2tSb3RDb3JyIHx8IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgYyA9IDAgPT09IGQgPyAtYS5sYWJlbE1ldHJpY3MoKS5oIDogMiA9PT0gZCA/IGEudGlja1JvdENvcnIueSA6IDA7XG4gICAgICAgIGggPSBNYXRoLmFicyhMKSArIGg7XG4gICAgICAgIEwgJiYgKGggPSBoIC0gYyArIEggKiAoayA/IHooQi55LCBhLnRpY2tSb3RDb3JyLnkgKyA4ICogSCkgOiBCLngpKTtcbiAgICAgICAgYS5heGlzVGl0bGVNYXJnaW4gPSB6KHUsIGgpO1xuICAgICAgICBhLmdldE1heExhYmVsRGltZW5zaW9ucyAmJiAoYS5tYXhMYWJlbERpbWVuc2lvbnMgPSBhLmdldE1heExhYmVsRGltZW5zaW9ucyhsLCBlKSk7XG4gICAgICAgIGsgPSB0aGlzLnRpY2tTaXplKFwidGlja1wiKTtcbiAgICAgICAgZ1tkXSA9IE1hdGgubWF4KGdbZF0sIGEuYXhpc1RpdGxlTWFyZ2luICsgdyArIEggKiBhLm9mZnNldCwgaCwgZSAmJiBlLmxlbmd0aCAmJiBrID8ga1swXSArIEggKiBhLm9mZnNldCA6IDApO1xuICAgICAgICBmID0gZi5vZmZzZXQgPyAwIDogMiAqIE1hdGguZmxvb3IoYS5heGlzTGluZS5zdHJva2VXaWR0aCgpIC8gMik7XG4gICAgICAgIGJbbV0gPSBNYXRoLm1heChiW21dLCBmKTtcbiAgICAgICAgcSh0aGlzLCBcImFmdGVyR2V0T2Zmc2V0XCIpO1xuICAgICAgfSxcbiAgICAgIGdldExpbmVQYXRoOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYiA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBjID0gdGhpcy5vcHBvc2l0ZSxcbiAgICAgICAgICAgIGYgPSB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIGUgPSB0aGlzLmhvcml6LFxuICAgICAgICAgICAgbCA9IHRoaXMubGVmdCArIChjID8gdGhpcy53aWR0aCA6IDApICsgZjtcbiAgICAgICAgZiA9IGIuY2hhcnRIZWlnaHQgLSB0aGlzLmJvdHRvbSAtIChjID8gdGhpcy5oZWlnaHQgOiAwKSArIGY7XG4gICAgICAgIGMgJiYgKGEgKj0gLTEpO1xuICAgICAgICByZXR1cm4gYi5yZW5kZXJlci5jcmlzcExpbmUoW1wiTVwiLCBlID8gdGhpcy5sZWZ0IDogbCwgZSA/IGYgOiB0aGlzLnRvcCwgXCJMXCIsIGUgPyBiLmNoYXJ0V2lkdGggLSB0aGlzLnJpZ2h0IDogbCwgZSA/IGYgOiBiLmNoYXJ0SGVpZ2h0IC0gdGhpcy5ib3R0b21dLCBhKTtcbiAgICAgIH0sXG4gICAgICByZW5kZXJMaW5lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYXhpc0xpbmUgfHwgKHRoaXMuYXhpc0xpbmUgPSB0aGlzLmNoYXJ0LnJlbmRlcmVyLnBhdGgoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtYXhpcy1saW5lXCIpLmFkZCh0aGlzLmF4aXNHcm91cCksIHRoaXMuY2hhcnQuc3R5bGVkTW9kZSB8fCB0aGlzLmF4aXNMaW5lLmF0dHIoe1xuICAgICAgICAgIHN0cm9rZTogdGhpcy5vcHRpb25zLmxpbmVDb2xvcixcbiAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiB0aGlzLm9wdGlvbnMubGluZVdpZHRoLFxuICAgICAgICAgIHpJbmRleDogN1xuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgICAgZ2V0VGl0bGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuaG9yaXosXG4gICAgICAgICAgICBiID0gdGhpcy5sZWZ0LFxuICAgICAgICAgICAgYyA9IHRoaXMudG9wLFxuICAgICAgICAgICAgZiA9IHRoaXMubGVuLFxuICAgICAgICAgICAgZSA9IHRoaXMub3B0aW9ucy50aXRsZSxcbiAgICAgICAgICAgIGwgPSBhID8gYiA6IGMsXG4gICAgICAgICAgICBrID0gdGhpcy5vcHBvc2l0ZSxcbiAgICAgICAgICAgIGQgPSB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIG0gPSBlLnggfHwgMCxcbiAgICAgICAgICAgIHYgPSBlLnkgfHwgMCxcbiAgICAgICAgICAgIG4gPSB0aGlzLmF4aXNUaXRsZSxcbiAgICAgICAgICAgIHcgPSB0aGlzLmNoYXJ0LnJlbmRlcmVyLmZvbnRNZXRyaWNzKGUuc3R5bGUgJiYgZS5zdHlsZS5mb250U2l6ZSwgbik7XG4gICAgICAgIG4gPSBNYXRoLm1heChuLmdldEJCb3gobnVsbCwgMCkuaGVpZ2h0IC0gdy5oIC0gMSwgMCk7XG4gICAgICAgIGYgPSB7XG4gICAgICAgICAgbG93OiBsICsgKGEgPyAwIDogZiksXG4gICAgICAgICAgbWlkZGxlOiBsICsgZiAvIDIsXG4gICAgICAgICAgaGlnaDogbCArIChhID8gZiA6IDApXG4gICAgICAgIH1bZS5hbGlnbl07XG4gICAgICAgIGIgPSAoYSA/IGMgKyB0aGlzLmhlaWdodCA6IGIpICsgKGEgPyAxIDogLTEpICogKGsgPyAtMSA6IDEpICogdGhpcy5heGlzVGl0bGVNYXJnaW4gKyBbLW4sIG4sIHcuZiwgLW5dW3RoaXMuc2lkZV07XG4gICAgICAgIGEgPSB7XG4gICAgICAgICAgeDogYSA/IGYgKyBtIDogYiArIChrID8gdGhpcy53aWR0aCA6IDApICsgZCArIG0sXG4gICAgICAgICAgeTogYSA/IGIgKyB2IC0gKGsgPyB0aGlzLmhlaWdodCA6IDApICsgZCA6IGYgKyB2XG4gICAgICAgIH07XG4gICAgICAgIHEodGhpcywgXCJhZnRlckdldFRpdGxlUG9zaXRpb25cIiwge1xuICAgICAgICAgIHRpdGxlUG9zaXRpb246IGFcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSxcbiAgICAgIHJlbmRlck1pbm9yVGljazogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmNoYXJ0Lmhhc1JlbmRlcmVkICYmIG4odGhpcy5vbGRNaW4pLFxuICAgICAgICAgICAgYyA9IHRoaXMubWlub3JUaWNrcztcbiAgICAgICAgY1thXSB8fCAoY1thXSA9IG5ldyByKHRoaXMsIGEsIFwibWlub3JcIikpO1xuICAgICAgICBiICYmIGNbYV0uaXNOZXcgJiYgY1thXS5yZW5kZXIobnVsbCwgITApO1xuICAgICAgICBjW2FdLnJlbmRlcihudWxsLCAhMSwgMSk7XG4gICAgICB9LFxuICAgICAgcmVuZGVyVGljazogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmlzTGlua2VkLFxuICAgICAgICAgICAgZiA9IHRoaXMudGlja3MsXG4gICAgICAgICAgICBlID0gdGhpcy5jaGFydC5oYXNSZW5kZXJlZCAmJiBuKHRoaXMub2xkTWluKTtcbiAgICAgICAgaWYgKCFjIHx8IGEgPj0gdGhpcy5taW4gJiYgYSA8PSB0aGlzLm1heCkgZlthXSB8fCAoZlthXSA9IG5ldyByKHRoaXMsIGEpKSwgZSAmJiBmW2FdLmlzTmV3ICYmIGZbYV0ucmVuZGVyKGIsICEwLCAtMSksIGZbYV0ucmVuZGVyKGIpO1xuICAgICAgfSxcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICBiID0gYS5jaGFydCxcbiAgICAgICAgICAgIGMgPSBhLm9wdGlvbnMsXG4gICAgICAgICAgICBmID0gYS5pc0xvZyxcbiAgICAgICAgICAgIGUgPSBhLmlzTGlua2VkLFxuICAgICAgICAgICAgbCA9IGEudGlja1Bvc2l0aW9ucyxcbiAgICAgICAgICAgIGsgPSBhLmF4aXNUaXRsZSxcbiAgICAgICAgICAgIHcgPSBhLnRpY2tzLFxuICAgICAgICAgICAgbSA9IGEubWlub3JUaWNrcyxcbiAgICAgICAgICAgIGggPSBhLmFsdGVybmF0ZUJhbmRzLFxuICAgICAgICAgICAgeiA9IGMuc3RhY2tMYWJlbHMsXG4gICAgICAgICAgICBCID0gYy5hbHRlcm5hdGVHcmlkQ29sb3IsXG4gICAgICAgICAgICBGID0gYS50aWNrbWFya09mZnNldCxcbiAgICAgICAgICAgIEwgPSBhLmF4aXNMaW5lLFxuICAgICAgICAgICAgdCA9IGEuc2hvd0F4aXMsXG4gICAgICAgICAgICBnID0gRShiLnJlbmRlcmVyLmdsb2JhbEFuaW1hdGlvbiksXG4gICAgICAgICAgICBILFxuICAgICAgICAgICAgSztcbiAgICAgICAgYS5sYWJlbEVkZ2UubGVuZ3RoID0gMDtcbiAgICAgICAgYS5vdmVybGFwID0gITE7XG4gICAgICAgIFt3LCBtLCBoXS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgdihiLCBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgYi5pc0FjdGl2ZSA9ICExO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGEuaGFzRGF0YSgpIHx8IGUpIGEubWlub3JUaWNrSW50ZXJ2YWwgJiYgIWEuY2F0ZWdvcmllcyAmJiBhLmdldE1pbm9yVGlja1Bvc2l0aW9ucygpLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBhLnJlbmRlck1pbm9yVGljayhiKTtcbiAgICAgICAgfSksIGwubGVuZ3RoICYmIChsLmZvckVhY2goZnVuY3Rpb24gKGIsIGMpIHtcbiAgICAgICAgICBhLnJlbmRlclRpY2soYiwgYyk7XG4gICAgICAgIH0pLCBGICYmICgwID09PSBhLm1pbiB8fCBhLnNpbmdsZSkgJiYgKHdbLTFdIHx8ICh3Wy0xXSA9IG5ldyByKGEsIC0xLCBudWxsLCAhMCkpLCB3Wy0xXS5yZW5kZXIoLTEpKSksIEIgJiYgbC5mb3JFYWNoKGZ1bmN0aW9uIChjLCBlKSB7XG4gICAgICAgICAgSyA9IFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBsW2UgKyAxXSA/IGxbZSArIDFdICsgRiA6IGEubWF4IC0gRjtcbiAgICAgICAgICAwID09PSBlICUgMiAmJiBjIDwgYS5tYXggJiYgSyA8PSBhLm1heCArIChiLnBvbGFyID8gLUYgOiBGKSAmJiAoaFtjXSB8fCAoaFtjXSA9IG5ldyBkLlBsb3RMaW5lT3JCYW5kKGEpKSwgSCA9IGMgKyBGLCBoW2NdLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBmcm9tOiBmID8gYS5saW4ybG9nKEgpIDogSCxcbiAgICAgICAgICAgIHRvOiBmID8gYS5saW4ybG9nKEspIDogSyxcbiAgICAgICAgICAgIGNvbG9yOiBCXG4gICAgICAgICAgfSwgaFtjXS5yZW5kZXIoKSwgaFtjXS5pc0FjdGl2ZSA9ICEwKTtcbiAgICAgICAgfSksIGEuX2FkZGVkUGxvdExCIHx8ICgoYy5wbG90TGluZXMgfHwgW10pLmNvbmNhdChjLnBsb3RCYW5kcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGEuYWRkUGxvdEJhbmRPckxpbmUoYik7XG4gICAgICAgIH0pLCBhLl9hZGRlZFBsb3RMQiA9ICEwKTtcbiAgICAgICAgW3csIG0sIGhdLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICB2YXIgYyxcbiAgICAgICAgICAgICAgZiA9IFtdLFxuICAgICAgICAgICAgICBlID0gZy5kdXJhdGlvbjtcbiAgICAgICAgICB2KGEsIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgICBiLmlzQWN0aXZlIHx8IChiLnJlbmRlcihhLCAhMSwgMCksIGIuaXNBY3RpdmUgPSAhMSwgZi5wdXNoKGEpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBRKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAoYyA9IGYubGVuZ3RoOyBjLS07KSBhW2ZbY11dICYmICFhW2ZbY11dLmlzQWN0aXZlICYmIChhW2ZbY11dLmRlc3Ryb3koKSwgZGVsZXRlIGFbZltjXV0pO1xuICAgICAgICAgIH0sIGEgIT09IGggJiYgYi5oYXNSZW5kZXJlZCAmJiBlID8gZSA6IDApO1xuICAgICAgICB9KTtcbiAgICAgICAgTCAmJiAoTFtMLmlzUGxhY2VkID8gXCJhbmltYXRlXCIgOiBcImF0dHJcIl0oe1xuICAgICAgICAgIGQ6IHRoaXMuZ2V0TGluZVBhdGgoTC5zdHJva2VXaWR0aCgpKVxuICAgICAgICB9KSwgTC5pc1BsYWNlZCA9ICEwLCBMW3QgPyBcInNob3dcIiA6IFwiaGlkZVwiXSh0KSk7XG4gICAgICAgIGsgJiYgdCAmJiAoYyA9IGEuZ2V0VGl0bGVQb3NpdGlvbigpLCBuKGMueSkgPyAoa1trLmlzTmV3ID8gXCJhdHRyXCIgOiBcImFuaW1hdGVcIl0oYyksIGsuaXNOZXcgPSAhMSkgOiAoay5hdHRyKFwieVwiLCAtOTk5OSksIGsuaXNOZXcgPSAhMCkpO1xuICAgICAgICB6ICYmIHouZW5hYmxlZCAmJiBhLnJlbmRlclN0YWNrVG90YWxzKCk7XG4gICAgICAgIGEuaXNEaXJ0eSA9ICExO1xuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJSZW5kZXJcIik7XG4gICAgICB9LFxuICAgICAgcmVkcmF3OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlzaWJsZSAmJiAodGhpcy5yZW5kZXIoKSwgdGhpcy5wbG90TGluZXNBbmRCYW5kcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYS5yZW5kZXIoKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYS5pc0RpcnR5ID0gITA7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGtlZXBQcm9wczogXCJleHRLZXkgaGNFdmVudHMgbmFtZXMgc2VyaWVzIHVzZXJNYXggdXNlck1pblwiLnNwbGl0KFwiIFwiKSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBiID0gdGhpcyxcbiAgICAgICAgICAgIGMgPSBiLnN0YWNrcyxcbiAgICAgICAgICAgIGYgPSBiLnBsb3RMaW5lc0FuZEJhbmRzLFxuICAgICAgICAgICAgZTtcbiAgICAgICAgcSh0aGlzLCBcImRlc3Ryb3lcIiwge1xuICAgICAgICAgIGtlZXBFdmVudHM6IGFcbiAgICAgICAgfSk7XG4gICAgICAgIGEgfHwgQihiKTtcbiAgICAgICAgdihjLCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIEQoYik7XG4gICAgICAgICAgY1thXSA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICBbYi50aWNrcywgYi5taW5vclRpY2tzLCBiLmFsdGVybmF0ZUJhbmRzXS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgRChiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmKSBmb3IgKGEgPSBmLmxlbmd0aDsgYS0tOykgZlthXS5kZXN0cm95KCk7XG4gICAgICAgIFwic3RhY2tUb3RhbEdyb3VwIGF4aXNMaW5lIGF4aXNUaXRsZSBheGlzR3JvdXAgZ3JpZEdyb3VwIGxhYmVsR3JvdXAgY3Jvc3Mgc2Nyb2xsYmFyXCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBiW2FdICYmIChiW2FdID0gYlthXS5kZXN0cm95KCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKGUgaW4gYi5wbG90TGluZXNBbmRCYW5kc0dyb3VwcykgYi5wbG90TGluZXNBbmRCYW5kc0dyb3Vwc1tlXSA9IGIucGxvdExpbmVzQW5kQmFuZHNHcm91cHNbZV0uZGVzdHJveSgpO1xuXG4gICAgICAgIHYoYiwgZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgICAtMSA9PT0gYi5rZWVwUHJvcHMuaW5kZXhPZihjKSAmJiBkZWxldGUgYltjXTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZHJhd0Nyb3NzaGFpcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNyb3NzaGFpcixcbiAgICAgICAgICAgIGYgPSB6KGMuc25hcCwgITApLFxuICAgICAgICAgICAgZSxcbiAgICAgICAgICAgIGwgPSB0aGlzLmNyb3NzLFxuICAgICAgICAgICAgayA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIHEodGhpcywgXCJkcmF3Q3Jvc3NoYWlyXCIsIHtcbiAgICAgICAgICBlOiBhLFxuICAgICAgICAgIHBvaW50OiBiXG4gICAgICAgIH0pO1xuICAgICAgICBhIHx8IChhID0gdGhpcy5jcm9zcyAmJiB0aGlzLmNyb3NzLmUpO1xuXG4gICAgICAgIGlmICh0aGlzLmNyb3NzaGFpciAmJiAhMSAhPT0gKHQoYikgfHwgIWYpKSB7XG4gICAgICAgICAgZiA/IHQoYikgJiYgKGUgPSB6KFwiY29sb3JBeGlzXCIgIT09IHRoaXMuY29sbCA/IGIuY3Jvc3NoYWlyUG9zIDogbnVsbCwgdGhpcy5pc1hBeGlzID8gYi5wbG90WCA6IHRoaXMubGVuIC0gYi5wbG90WSkpIDogZSA9IGEgJiYgKHRoaXMuaG9yaXogPyBhLmNoYXJ0WCAtIHRoaXMucG9zIDogdGhpcy5sZW4gLSBhLmNoYXJ0WSArIHRoaXMucG9zKTtcblxuICAgICAgICAgIGlmICh0KGUpKSB7XG4gICAgICAgICAgICB2YXIgZCA9IHtcbiAgICAgICAgICAgICAgdmFsdWU6IGIgJiYgKHRoaXMuaXNYQXhpcyA/IGIueCA6IHooYi5zdGFja1ksIGIueSkpLFxuICAgICAgICAgICAgICB0cmFuc2xhdGVkVmFsdWU6IGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBrLnBvbGFyICYmIE4oZCwge1xuICAgICAgICAgICAgICBpc0Nyb3NzaGFpcjogITAsXG4gICAgICAgICAgICAgIGNoYXJ0WDogYSAmJiBhLmNoYXJ0WCxcbiAgICAgICAgICAgICAgY2hhcnRZOiBhICYmIGEuY2hhcnRZLFxuICAgICAgICAgICAgICBwb2ludDogYlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkID0gdGhpcy5nZXRQbG90TGluZVBhdGgoZCkgfHwgbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXQoZCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZUNyb3NzaGFpcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGYgPSB0aGlzLmNhdGVnb3JpZXMgJiYgIXRoaXMuaXNSYWRpYWw7XG4gICAgICAgICAgbCB8fCAodGhpcy5jcm9zcyA9IGwgPSBrLnJlbmRlcmVyLnBhdGgoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtY3Jvc3NoYWlyIGhpZ2hjaGFydHMtY3Jvc3NoYWlyLVwiICsgKGYgPyBcImNhdGVnb3J5IFwiIDogXCJ0aGluIFwiKSArIGMuY2xhc3NOYW1lKS5hdHRyKHtcbiAgICAgICAgICAgIHpJbmRleDogeihjLnpJbmRleCwgMilcbiAgICAgICAgICB9KS5hZGQoKSwgay5zdHlsZWRNb2RlIHx8IChsLmF0dHIoe1xuICAgICAgICAgICAgc3Ryb2tlOiBjLmNvbG9yIHx8IChmID8gSShcIiNjY2Q2ZWJcIikuc2V0T3BhY2l0eSguMjUpLmdldCgpIDogXCIjY2NjY2NjXCIpLFxuICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogeihjLndpZHRoLCAxKVxuICAgICAgICAgIH0pLmNzcyh7XG4gICAgICAgICAgICBcInBvaW50ZXItZXZlbnRzXCI6IFwibm9uZVwiXG4gICAgICAgICAgfSksIGMuZGFzaFN0eWxlICYmIGwuYXR0cih7XG4gICAgICAgICAgICBkYXNoc3R5bGU6IGMuZGFzaFN0eWxlXG4gICAgICAgICAgfSkpKTtcbiAgICAgICAgICBsLnNob3coKS5hdHRyKHtcbiAgICAgICAgICAgIGQ6IGRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmICYmICFjLndpZHRoICYmIGwuYXR0cih7XG4gICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiB0aGlzLnRyYW5zQVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuY3Jvc3MuZSA9IGE7XG4gICAgICAgIH0gZWxzZSB0aGlzLmhpZGVDcm9zc2hhaXIoKTtcblxuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJEcmF3Q3Jvc3NoYWlyXCIsIHtcbiAgICAgICAgICBlOiBhLFxuICAgICAgICAgIHBvaW50OiBiXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGhpZGVDcm9zc2hhaXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jcm9zcyAmJiB0aGlzLmNyb3NzLmhpZGUoKTtcbiAgICAgICAgcSh0aGlzLCBcImFmdGVySGlkZUNyb3NzaGFpclwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZC5BeGlzID0gZztcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9EYXRlVGltZUF4aXMuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcpIHtcbiAgICB2YXIgciA9IGcuZ2V0TWFnbml0dWRlLFxuICAgICAgICB1ID0gZy5ub3JtYWxpemVUaWNrSW50ZXJ2YWwsXG4gICAgICAgIEkgPSBnLnRpbWVVbml0cztcbiAgICBkID0gZC5BeGlzO1xuXG4gICAgZC5wcm90b3R5cGUuZ2V0VGltZVRpY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhcnQudGltZS5nZXRUaW1lVGlja3MuYXBwbHkodGhpcy5jaGFydC50aW1lLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBkLnByb3RvdHlwZS5ub3JtYWxpemVUaW1lVGlja0ludGVydmFsID0gZnVuY3Rpb24gKGQsIGcpIHtcbiAgICAgIHZhciBBID0gZyB8fCBbW1wibWlsbGlzZWNvbmRcIiwgWzEsIDIsIDUsIDEwLCAyMCwgMjUsIDUwLCAxMDAsIDIwMCwgNTAwXV0sIFtcInNlY29uZFwiLCBbMSwgMiwgNSwgMTAsIDE1LCAzMF1dLCBbXCJtaW51dGVcIiwgWzEsIDIsIDUsIDEwLCAxNSwgMzBdXSwgW1wiaG91clwiLCBbMSwgMiwgMywgNCwgNiwgOCwgMTJdXSwgW1wiZGF5XCIsIFsxLCAyXV0sIFtcIndlZWtcIiwgWzEsIDJdXSwgW1wibW9udGhcIiwgWzEsIDIsIDMsIDQsIDZdXSwgW1wieWVhclwiLCBudWxsXV07XG4gICAgICBnID0gQVtBLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIEcgPSBJW2dbMF1dLFxuICAgICAgICAgIEUgPSBnWzFdLFxuICAgICAgICAgIHk7XG5cbiAgICAgIGZvciAoeSA9IDA7IHkgPCBBLmxlbmd0aCAmJiAhKGcgPSBBW3ldLCBHID0gSVtnWzBdXSwgRSA9IGdbMV0sIEFbeSArIDFdICYmIGQgPD0gKEcgKiBFW0UubGVuZ3RoIC0gMV0gKyBJW0FbeSArIDFdWzBdXSkgLyAyKTsgeSsrKTtcblxuICAgICAgRyA9PT0gSS55ZWFyICYmIGQgPCA1ICogRyAmJiAoRSA9IFsxLCAyLCA1XSk7XG4gICAgICBkID0gdShkIC8gRywgRSwgXCJ5ZWFyXCIgPT09IGdbMF0gPyBNYXRoLm1heChyKGQgLyBHKSwgMSkgOiAxKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVuaXRSYW5nZTogRyxcbiAgICAgICAgY291bnQ6IGQsXG4gICAgICAgIHVuaXROYW1lOiBnWzBdXG4gICAgICB9O1xuICAgIH07XG4gIH0pO1xuICBTKHIsIFwicGFydHMvTG9nYXJpdGhtaWNBeGlzLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgdmFyIHIgPSBnLmdldE1hZ25pdHVkZSxcbiAgICAgICAgdSA9IGcubm9ybWFsaXplVGlja0ludGVydmFsLFxuICAgICAgICBJID0gZy5waWNrO1xuICAgIGQgPSBkLkF4aXM7XG5cbiAgICBkLnByb3RvdHlwZS5nZXRMb2dUaWNrUG9zaXRpb25zID0gZnVuY3Rpb24gKGQsIGcsIEEsIEcpIHtcbiAgICAgIHZhciBFID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIHkgPSB0aGlzLmxlbixcbiAgICAgICAgICB0ID0gW107XG4gICAgICBHIHx8ICh0aGlzLl9taW5vckF1dG9JbnRlcnZhbCA9IG51bGwpO1xuICAgICAgaWYgKC41IDw9IGQpIGQgPSBNYXRoLnJvdW5kKGQpLCB0ID0gdGhpcy5nZXRMaW5lYXJUaWNrUG9zaXRpb25zKGQsIGcsIEEpO2Vsc2UgaWYgKC4wOCA8PSBkKSB7XG4gICAgICAgIHkgPSBNYXRoLmZsb29yKGcpO1xuICAgICAgICB2YXIgRCwgaDtcblxuICAgICAgICBmb3IgKEUgPSAuMyA8IGQgPyBbMSwgMiwgNF0gOiAuMTUgPCBkID8gWzEsIDIsIDQsIDYsIDhdIDogWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDldOyB5IDwgQSArIDEgJiYgIWg7IHkrKykge1xuICAgICAgICAgIHZhciBOID0gRS5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKEQgPSAwOyBEIDwgTiAmJiAhaDsgRCsrKSB7XG4gICAgICAgICAgICB2YXIgcSA9IHRoaXMubG9nMmxpbih0aGlzLmxpbjJsb2coeSkgKiBFW0RdKTtcbiAgICAgICAgICAgIHEgPiBnICYmICghRyB8fCBQIDw9IEEpICYmIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBQICYmIHQucHVzaChQKTtcbiAgICAgICAgICAgIFAgPiBBICYmIChoID0gITApO1xuICAgICAgICAgICAgdmFyIFAgPSBxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGcgPSB0aGlzLmxpbjJsb2coZyksIEEgPSB0aGlzLmxpbjJsb2coQSksIGQgPSBHID8gdGhpcy5nZXRNaW5vclRpY2tJbnRlcnZhbCgpIDogRS50aWNrSW50ZXJ2YWwsIGQgPSBJKFwiYXV0b1wiID09PSBkID8gbnVsbCA6IGQsIHRoaXMuX21pbm9yQXV0b0ludGVydmFsLCBFLnRpY2tQaXhlbEludGVydmFsIC8gKEcgPyA1IDogMSkgKiAoQSAtIGcpIC8gKChHID8geSAvIHRoaXMudGlja1Bvc2l0aW9ucy5sZW5ndGggOiB5KSB8fCAxKSksIGQgPSB1KGQsIG51bGwsIHIoZCkpLCB0ID0gdGhpcy5nZXRMaW5lYXJUaWNrUG9zaXRpb25zKGQsIGcsIEEpLm1hcCh0aGlzLmxvZzJsaW4pLCBHIHx8ICh0aGlzLl9taW5vckF1dG9JbnRlcnZhbCA9IGQgLyA1KTtcbiAgICAgIEcgfHwgKHRoaXMudGlja0ludGVydmFsID0gZCk7XG4gICAgICByZXR1cm4gdDtcbiAgICB9O1xuXG4gICAgZC5wcm90b3R5cGUubG9nMmxpbiA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gTWF0aC5sb2coZCkgLyBNYXRoLkxOMTA7XG4gICAgfTtcblxuICAgIGQucHJvdG90eXBlLmxpbjJsb2cgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIE1hdGgucG93KDEwLCBkKTtcbiAgICB9O1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL1Bsb3RMaW5lT3JCYW5kLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL0F4aXMuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZywgcikge1xuICAgIHZhciB1ID0gci5hcnJheU1heCxcbiAgICAgICAgSSA9IHIuYXJyYXlNaW4sXG4gICAgICAgIE0gPSByLmRlZmluZWQsXG4gICAgICAgIEUgPSByLmRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzLFxuICAgICAgICBBID0gci5lcmFzZSxcbiAgICAgICAgRyA9IHIuZXh0ZW5kLFxuICAgICAgICBKID0gci5tZXJnZSxcbiAgICAgICAgeSA9IHIub2JqZWN0RWFjaCxcbiAgICAgICAgdCA9IHIucGljayxcbiAgICAgICAgRCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIGgoZCwgaCkge1xuICAgICAgICB0aGlzLmF4aXMgPSBkO1xuICAgICAgICBoICYmICh0aGlzLm9wdGlvbnMgPSBoLCB0aGlzLmlkID0gaC5pZCk7XG4gICAgICB9XG5cbiAgICAgIGgucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZC5maXJlRXZlbnQodGhpcywgXCJyZW5kZXJcIik7XG4gICAgICAgIHZhciBoID0gdGhpcyxcbiAgICAgICAgICAgIHEgPSBoLmF4aXMsXG4gICAgICAgICAgICBnID0gcS5ob3JpeixcbiAgICAgICAgICAgIGUgPSBoLm9wdGlvbnMsXG4gICAgICAgICAgICBjID0gZS5sYWJlbCxcbiAgICAgICAgICAgIGsgPSBoLmxhYmVsLFxuICAgICAgICAgICAgbiA9IGUudG8sXG4gICAgICAgICAgICBmID0gZS5mcm9tLFxuICAgICAgICAgICAgYSA9IGUudmFsdWUsXG4gICAgICAgICAgICBsID0gTShmKSAmJiBNKG4pLFxuICAgICAgICAgICAgdiA9IE0oYSksXG4gICAgICAgICAgICB6ID0gaC5zdmdFbGVtLFxuICAgICAgICAgICAgdyA9ICF6LFxuICAgICAgICAgICAgQiA9IFtdLFxuICAgICAgICAgICAgTCA9IGUuY29sb3IsXG4gICAgICAgICAgICBRID0gdChlLnpJbmRleCwgMCksXG4gICAgICAgICAgICBIID0gZS5ldmVudHM7XG4gICAgICAgIEIgPSB7XG4gICAgICAgICAgXCJjbGFzc1wiOiBcImhpZ2hjaGFydHMtcGxvdC1cIiArIChsID8gXCJiYW5kIFwiIDogXCJsaW5lIFwiKSArIChlLmNsYXNzTmFtZSB8fCBcIlwiKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgSyA9IHt9LFxuICAgICAgICAgICAgcCA9IHEuY2hhcnQucmVuZGVyZXIsXG4gICAgICAgICAgICBiID0gbCA/IFwiYmFuZHNcIiA6IFwibGluZXNcIjtcbiAgICAgICAgcS5pc0xvZyAmJiAoZiA9IHEubG9nMmxpbihmKSwgbiA9IHEubG9nMmxpbihuKSwgYSA9IHEubG9nMmxpbihhKSk7XG4gICAgICAgIHEuY2hhcnQuc3R5bGVkTW9kZSB8fCAodiA/IChCLnN0cm9rZSA9IEwgfHwgXCIjOTk5OTk5XCIsIEJbXCJzdHJva2Utd2lkdGhcIl0gPSB0KGUud2lkdGgsIDEpLCBlLmRhc2hTdHlsZSAmJiAoQi5kYXNoc3R5bGUgPSBlLmRhc2hTdHlsZSkpIDogbCAmJiAoQi5maWxsID0gTCB8fCBcIiNlNmViZjVcIiwgZS5ib3JkZXJXaWR0aCAmJiAoQi5zdHJva2UgPSBlLmJvcmRlckNvbG9yLCBCW1wic3Ryb2tlLXdpZHRoXCJdID0gZS5ib3JkZXJXaWR0aCkpKTtcbiAgICAgICAgSy56SW5kZXggPSBRO1xuICAgICAgICBiICs9IFwiLVwiICsgUTtcbiAgICAgICAgKEwgPSBxLnBsb3RMaW5lc0FuZEJhbmRzR3JvdXBzW2JdKSB8fCAocS5wbG90TGluZXNBbmRCYW5kc0dyb3Vwc1tiXSA9IEwgPSBwLmcoXCJwbG90LVwiICsgYikuYXR0cihLKS5hZGQoKSk7XG4gICAgICAgIHcgJiYgKGguc3ZnRWxlbSA9IHogPSBwLnBhdGgoKS5hdHRyKEIpLmFkZChMKSk7XG4gICAgICAgIGlmICh2KSBCID0gcS5nZXRQbG90TGluZVBhdGgoe1xuICAgICAgICAgIHZhbHVlOiBhLFxuICAgICAgICAgIGxpbmVXaWR0aDogei5zdHJva2VXaWR0aCgpLFxuICAgICAgICAgIGFjcm9zc1BhbmVzOiBlLmFjcm9zc1BhbmVzXG4gICAgICAgIH0pO2Vsc2UgaWYgKGwpIEIgPSBxLmdldFBsb3RCYW5kUGF0aChmLCBuLCBlKTtlbHNlIHJldHVybjtcbiAgICAgICAgKHcgfHwgIXouZCkgJiYgQiAmJiBCLmxlbmd0aCA/ICh6LmF0dHIoe1xuICAgICAgICAgIGQ6IEJcbiAgICAgICAgfSksIEggJiYgeShILCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIHoub24oYSwgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIEhbYV0uYXBwbHkoaCwgW2JdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpIDogeiAmJiAoQiA/ICh6LnNob3coITApLCB6LmFuaW1hdGUoe1xuICAgICAgICAgIGQ6IEJcbiAgICAgICAgfSkpIDogei5kICYmICh6LmhpZGUoKSwgayAmJiAoaC5sYWJlbCA9IGsgPSBrLmRlc3Ryb3koKSkpKTtcbiAgICAgICAgYyAmJiAoTShjLnRleHQpIHx8IE0oYy5mb3JtYXR0ZXIpKSAmJiBCICYmIEIubGVuZ3RoICYmIDAgPCBxLndpZHRoICYmIDAgPCBxLmhlaWdodCAmJiAhQi5pc0ZsYXQgPyAoYyA9IEooe1xuICAgICAgICAgIGFsaWduOiBnICYmIGwgJiYgXCJjZW50ZXJcIixcbiAgICAgICAgICB4OiBnID8gIWwgJiYgNCA6IDEwLFxuICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICFnICYmIGwgJiYgXCJtaWRkbGVcIixcbiAgICAgICAgICB5OiBnID8gbCA/IDE2IDogMTAgOiBsID8gNiA6IC00LFxuICAgICAgICAgIHJvdGF0aW9uOiBnICYmICFsICYmIDkwXG4gICAgICAgIH0sIGMpLCB0aGlzLnJlbmRlckxhYmVsKGMsIEIsIGwsIFEpKSA6IGsgJiYgay5oaWRlKCk7XG4gICAgICAgIHJldHVybiBoO1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUucmVuZGVyTGFiZWwgPSBmdW5jdGlvbiAoZCwgaCwgZywgZSkge1xuICAgICAgICB2YXIgYyA9IHRoaXMubGFiZWwsXG4gICAgICAgICAgICBrID0gdGhpcy5heGlzLmNoYXJ0LnJlbmRlcmVyO1xuICAgICAgICBjIHx8IChjID0ge1xuICAgICAgICAgIGFsaWduOiBkLnRleHRBbGlnbiB8fCBkLmFsaWduLFxuICAgICAgICAgIHJvdGF0aW9uOiBkLnJvdGF0aW9uLFxuICAgICAgICAgIFwiY2xhc3NcIjogXCJoaWdoY2hhcnRzLXBsb3QtXCIgKyAoZyA/IFwiYmFuZFwiIDogXCJsaW5lXCIpICsgXCItbGFiZWwgXCIgKyAoZC5jbGFzc05hbWUgfHwgXCJcIilcbiAgICAgICAgfSwgYy56SW5kZXggPSBlLCBlID0gdGhpcy5nZXRMYWJlbFRleHQoZCksIHRoaXMubGFiZWwgPSBjID0gay50ZXh0KGUsIDAsIDAsIGQudXNlSFRNTCkuYXR0cihjKS5hZGQoKSwgdGhpcy5heGlzLmNoYXJ0LnN0eWxlZE1vZGUgfHwgYy5jc3MoZC5zdHlsZSkpO1xuICAgICAgICBrID0gaC54Qm91bmRzIHx8IFtoWzFdLCBoWzRdLCBnID8gaFs2XSA6IGhbMV1dO1xuICAgICAgICBoID0gaC55Qm91bmRzIHx8IFtoWzJdLCBoWzVdLCBnID8gaFs3XSA6IGhbMl1dO1xuICAgICAgICBnID0gSShrKTtcbiAgICAgICAgZSA9IEkoaCk7XG4gICAgICAgIGMuYWxpZ24oZCwgITEsIHtcbiAgICAgICAgICB4OiBnLFxuICAgICAgICAgIHk6IGUsXG4gICAgICAgICAgd2lkdGg6IHUoaykgLSBnLFxuICAgICAgICAgIGhlaWdodDogdShoKSAtIGVcbiAgICAgICAgfSk7XG4gICAgICAgIGMuc2hvdyghMCk7XG4gICAgICB9O1xuXG4gICAgICBoLnByb3RvdHlwZS5nZXRMYWJlbFRleHQgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gTShkLmZvcm1hdHRlcikgPyBkLmZvcm1hdHRlci5jYWxsKHRoaXMpIDogZC50ZXh0O1xuICAgICAgfTtcblxuICAgICAgaC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQSh0aGlzLmF4aXMucGxvdExpbmVzQW5kQmFuZHMsIHRoaXMpO1xuICAgICAgICBkZWxldGUgdGhpcy5heGlzO1xuICAgICAgICBFKHRoaXMpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGg7XG4gICAgfSgpO1xuXG4gICAgRyhnLnByb3RvdHlwZSwge1xuICAgICAgZ2V0UGxvdEJhbmRQYXRoOiBmdW5jdGlvbiAoZCwgZykge1xuICAgICAgICB2YXIgaCA9IHRoaXMuZ2V0UGxvdExpbmVQYXRoKHtcbiAgICAgICAgICB2YWx1ZTogZyxcbiAgICAgICAgICBmb3JjZTogITAsXG4gICAgICAgICAgYWNyb3NzUGFuZXM6IHRoaXMub3B0aW9ucy5hY3Jvc3NQYW5lc1xuICAgICAgICB9KSxcbiAgICAgICAgICAgIHQgPSB0aGlzLmdldFBsb3RMaW5lUGF0aCh7XG4gICAgICAgICAgdmFsdWU6IGQsXG4gICAgICAgICAgZm9yY2U6ICEwLFxuICAgICAgICAgIGFjcm9zc1BhbmVzOiB0aGlzLm9wdGlvbnMuYWNyb3NzUGFuZXNcbiAgICAgICAgfSksXG4gICAgICAgICAgICBlID0gW10sXG4gICAgICAgICAgICBjID0gdGhpcy5ob3JpeixcbiAgICAgICAgICAgIGsgPSAxO1xuICAgICAgICBkID0gZCA8IHRoaXMubWluICYmIGcgPCB0aGlzLm1pbiB8fCBkID4gdGhpcy5tYXggJiYgZyA+IHRoaXMubWF4O1xuXG4gICAgICAgIGlmICh0ICYmIGgpIHtcbiAgICAgICAgICBpZiAoZCkge1xuICAgICAgICAgICAgdmFyIG4gPSB0LnRvU3RyaW5nKCkgPT09IGgudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoZCA9IDA7IGQgPCB0Lmxlbmd0aDsgZCArPSA2KSBjICYmIGhbZCArIDFdID09PSB0W2QgKyAxXSA/IChoW2QgKyAxXSArPSBrLCBoW2QgKyA0XSArPSBrKSA6IGMgfHwgaFtkICsgMl0gIT09IHRbZCArIDJdIHx8IChoW2QgKyAyXSArPSBrLCBoW2QgKyA1XSArPSBrKSwgZS5wdXNoKFwiTVwiLCB0W2QgKyAxXSwgdFtkICsgMl0sIFwiTFwiLCB0W2QgKyA0XSwgdFtkICsgNV0sIGhbZCArIDRdLCBoW2QgKyA1XSwgaFtkICsgMV0sIGhbZCArIDJdLCBcInpcIiksIGUuaXNGbGF0ID0gbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfSxcbiAgICAgIGFkZFBsb3RCYW5kOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRQbG90QmFuZE9yTGluZShkLCBcInBsb3RCYW5kc1wiKTtcbiAgICAgIH0sXG4gICAgICBhZGRQbG90TGluZTogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkUGxvdEJhbmRPckxpbmUoZCwgXCJwbG90TGluZXNcIik7XG4gICAgICB9LFxuICAgICAgYWRkUGxvdEJhbmRPckxpbmU6IGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgICAgIHZhciBoID0gbmV3IEQodGhpcywgZCkucmVuZGVyKCksXG4gICAgICAgICAgICB0ID0gdGhpcy51c2VyT3B0aW9ucztcblxuICAgICAgICBpZiAoaCkge1xuICAgICAgICAgIGlmIChnKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRbZ10gfHwgW107XG4gICAgICAgICAgICBlLnB1c2goZCk7XG4gICAgICAgICAgICB0W2ddID0gZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnBsb3RMaW5lc0FuZEJhbmRzLnB1c2goaCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaDtcbiAgICAgIH0sXG4gICAgICByZW1vdmVQbG90QmFuZE9yTGluZTogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgZm9yICh2YXIgaCA9IHRoaXMucGxvdExpbmVzQW5kQmFuZHMsIHEgPSB0aGlzLm9wdGlvbnMsIGcgPSB0aGlzLnVzZXJPcHRpb25zLCBlID0gaC5sZW5ndGg7IGUtLTspIGhbZV0uaWQgPT09IGQgJiYgaFtlXS5kZXN0cm95KCk7XG5cbiAgICAgICAgW3EucGxvdExpbmVzIHx8IFtdLCBnLnBsb3RMaW5lcyB8fCBbXSwgcS5wbG90QmFuZHMgfHwgW10sIGcucGxvdEJhbmRzIHx8IFtdXS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgZm9yIChlID0gYy5sZW5ndGg7IGUtLTspIGNbZV0uaWQgPT09IGQgJiYgQShjLCBjW2VdKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlUGxvdEJhbmQ6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUGxvdEJhbmRPckxpbmUoZCk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlUGxvdExpbmU6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUGxvdEJhbmRPckxpbmUoZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZC5QbG90TGluZU9yQmFuZCA9IEQ7XG4gICAgcmV0dXJuIGQuUGxvdExpbmVPckJhbmQ7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvVG9vbHRpcC5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZykge1xuICAgIHZhciByID0gZy5jbGFtcCxcbiAgICAgICAgdSA9IGcuY3NzLFxuICAgICAgICBJID0gZy5kZWZpbmVkLFxuICAgICAgICBNID0gZy5kaXNjYXJkRWxlbWVudCxcbiAgICAgICAgRSA9IGcuZXh0ZW5kLFxuICAgICAgICBBID0gZy5mb3JtYXQsXG4gICAgICAgIEcgPSBnLmlzTnVtYmVyLFxuICAgICAgICBKID0gZy5pc1N0cmluZyxcbiAgICAgICAgeSA9IGcubWVyZ2UsXG4gICAgICAgIHQgPSBnLnBpY2ssXG4gICAgICAgIEQgPSBnLnNwbGF0LFxuICAgICAgICBoID0gZy5zeW5jVGltZW91dCxcbiAgICAgICAgTiA9IGcudGltZVVuaXRzO1xuICAgIFwiXCI7XG5cbiAgICB2YXIgcSA9IGQuZG9jLFxuICAgICAgICBQID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gZShjLCBlKSB7XG4gICAgICAgIHRoaXMuY3Jvc3NoYWlycyA9IFtdO1xuICAgICAgICB0aGlzLmRpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5pc0hpZGRlbiA9ICEwO1xuICAgICAgICB0aGlzLmlzU3RpY2t5ID0gITE7XG4gICAgICAgIHRoaXMubm93ID0ge307XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLm91dHNpZGUgPSAhMTtcbiAgICAgICAgdGhpcy5jaGFydCA9IGM7XG4gICAgICAgIHRoaXMuaW5pdChjLCBlKTtcbiAgICAgIH1cblxuICAgICAgZS5wcm90b3R5cGUuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5jaGFydDtcbiAgICAgICAgYy5yZW5kZXJlci5kZWZpbml0aW9uKHtcbiAgICAgICAgICB0YWdOYW1lOiBcImZpbHRlclwiLFxuICAgICAgICAgIGlkOiBcImRyb3Atc2hhZG93LVwiICsgYy5pbmRleCxcbiAgICAgICAgICBvcGFjaXR5OiAuNSxcbiAgICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICAgIHRhZ05hbWU6IFwiZmVHYXVzc2lhbkJsdXJcIixcbiAgICAgICAgICAgIFwiaW5cIjogXCJTb3VyY2VBbHBoYVwiLFxuICAgICAgICAgICAgc3RkRGV2aWF0aW9uOiAxXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgdGFnTmFtZTogXCJmZU9mZnNldFwiLFxuICAgICAgICAgICAgZHg6IDEsXG4gICAgICAgICAgICBkeTogMVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRhZ05hbWU6IFwiZmVDb21wb25lbnRUcmFuc2ZlclwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgICAgIHRhZ05hbWU6IFwiZmVGdW5jQVwiLFxuICAgICAgICAgICAgICB0eXBlOiBcImxpbmVhclwiLFxuICAgICAgICAgICAgICBzbG9wZTogLjNcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgdGFnTmFtZTogXCJmZU1lcmdlXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICAgICAgdGFnTmFtZTogXCJmZU1lcmdlTm9kZVwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIHRhZ05hbWU6IFwiZmVNZXJnZU5vZGVcIixcbiAgICAgICAgICAgICAgXCJpblwiOiBcIlNvdXJjZUdyYXBoaWNcIlxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9XVxuICAgICAgICB9KTtcbiAgICAgICAgYy5yZW5kZXJlci5kZWZpbml0aW9uKHtcbiAgICAgICAgICB0YWdOYW1lOiBcInN0eWxlXCIsXG4gICAgICAgICAgdGV4dENvbnRlbnQ6IFwiLmhpZ2hjaGFydHMtdG9vbHRpcC1cIiArIGMuaW5kZXggKyBcIntmaWx0ZXI6dXJsKCNkcm9wLXNoYWRvdy1cIiArIGMuaW5kZXggKyBcIil9XCJcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS5ib2R5Rm9ybWF0dGVyID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgdmFyIGUgPSBjLnNlcmllcy50b29sdGlwT3B0aW9ucztcbiAgICAgICAgICByZXR1cm4gKGVbKGMucG9pbnQuZm9ybWF0UHJlZml4IHx8IFwicG9pbnRcIikgKyBcIkZvcm1hdHRlclwiXSB8fCBjLnBvaW50LnRvb2x0aXBGb3JtYXR0ZXIpLmNhbGwoYy5wb2ludCwgZVsoYy5wb2ludC5mb3JtYXRQcmVmaXggfHwgXCJwb2ludFwiKSArIFwiRm9ybWF0XCJdIHx8IFwiXCIpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLmNsZWFuU3BsaXQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB0aGlzLmNoYXJ0LnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIGQgPSBlICYmIGUudHQ7XG4gICAgICAgICAgZCAmJiAoIWQuaXNBY3RpdmUgfHwgYyA/IGUudHQgPSBkLmRlc3Ryb3koKSA6IGQuaXNBY3RpdmUgPSAhMSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUuZGVmYXVsdEZvcm1hdHRlciA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5wb2ludHMgfHwgRCh0aGlzKTtcbiAgICAgICAgdmFyIGQgPSBbYy50b29sdGlwRm9vdGVySGVhZGVyRm9ybWF0dGVyKGVbMF0pXTtcbiAgICAgICAgZCA9IGQuY29uY2F0KGMuYm9keUZvcm1hdHRlcihlKSk7XG4gICAgICAgIGQucHVzaChjLnRvb2x0aXBGb290ZXJIZWFkZXJGb3JtYXR0ZXIoZVswXSwgITApKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxhYmVsICYmICh0aGlzLmxhYmVsID0gdGhpcy5sYWJlbC5kZXN0cm95KCkpO1xuICAgICAgICB0aGlzLnNwbGl0ICYmIHRoaXMudHQgJiYgKHRoaXMuY2xlYW5TcGxpdCh0aGlzLmNoYXJ0LCAhMCksIHRoaXMudHQgPSB0aGlzLnR0LmRlc3Ryb3koKSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgJiYgKHRoaXMucmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLmRlc3Ryb3koKSwgTSh0aGlzLmNvbnRhaW5lcikpO1xuICAgICAgICBnLmNsZWFyVGltZW91dCh0aGlzLmhpZGVUaW1lcik7XG4gICAgICAgIGcuY2xlYXJUaW1lb3V0KHRoaXMudG9vbHRpcFRpbWVvdXQpO1xuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUuZ2V0QW5jaG9yID0gZnVuY3Rpb24gKGMsIGUpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZiA9IGQucG9pbnRlcixcbiAgICAgICAgICAgIGEgPSBkLmludmVydGVkLFxuICAgICAgICAgICAgbCA9IGQucGxvdFRvcCxcbiAgICAgICAgICAgIGsgPSBkLnBsb3RMZWZ0LFxuICAgICAgICAgICAgaCA9IDAsXG4gICAgICAgICAgICB3ID0gMCxcbiAgICAgICAgICAgIEIsXG4gICAgICAgICAgICBxO1xuICAgICAgICBjID0gRChjKTtcbiAgICAgICAgdGhpcy5mb2xsb3dQb2ludGVyICYmIGUgPyAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGUuY2hhcnRYICYmIChlID0gZi5ub3JtYWxpemUoZSkpLCBjID0gW2UuY2hhcnRYIC0gaywgZS5jaGFydFkgLSBsXSkgOiBjWzBdLnRvb2x0aXBQb3MgPyBjID0gY1swXS50b29sdGlwUG9zIDogKGMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIEIgPSBjLnNlcmllcy55QXhpcztcbiAgICAgICAgICBxID0gYy5zZXJpZXMueEF4aXM7XG4gICAgICAgICAgaCArPSBjLnBsb3RYICsgKCFhICYmIHEgPyBxLmxlZnQgLSBrIDogMCk7XG4gICAgICAgICAgdyArPSAoYy5wbG90TG93ID8gKGMucGxvdExvdyArIGMucGxvdEhpZ2gpIC8gMiA6IGMucGxvdFkpICsgKCFhICYmIEIgPyBCLnRvcCAtIGwgOiAwKTtcbiAgICAgICAgfSksIGggLz0gYy5sZW5ndGgsIHcgLz0gYy5sZW5ndGgsIGMgPSBbYSA/IGQucGxvdFdpZHRoIC0gdyA6IGgsIHRoaXMuc2hhcmVkICYmICFhICYmIDEgPCBjLmxlbmd0aCAmJiBlID8gZS5jaGFydFkgLSBsIDogYSA/IGQucGxvdEhlaWdodCAtIGggOiB3XSk7XG4gICAgICAgIHJldHVybiBjLm1hcChNYXRoLnJvdW5kKTtcbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLmdldERhdGVGb3JtYXQgPSBmdW5jdGlvbiAoYywgZSwgZCwgZikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2hhcnQudGltZSxcbiAgICAgICAgICAgIGwgPSBhLmRhdGVGb3JtYXQoXCIlbS0lZCAlSDolTTolUy4lTFwiLCBlKSxcbiAgICAgICAgICAgIGsgPSB7XG4gICAgICAgICAgbWlsbGlzZWNvbmQ6IDE1LFxuICAgICAgICAgIHNlY29uZDogMTIsXG4gICAgICAgICAgbWludXRlOiA5LFxuICAgICAgICAgIGhvdXI6IDYsXG4gICAgICAgICAgZGF5OiAzXG4gICAgICAgIH0sXG4gICAgICAgICAgICBuID0gXCJtaWxsaXNlY29uZFwiO1xuXG4gICAgICAgIGZvciAodyBpbiBOKSB7XG4gICAgICAgICAgaWYgKGMgPT09IE4ud2VlayAmJiArYS5kYXRlRm9ybWF0KFwiJXdcIiwgZSkgPT09IGQgJiYgXCIwMDowMDowMC4wMDBcIiA9PT0gbC5zdWJzdHIoNikpIHtcbiAgICAgICAgICAgIHZhciB3ID0gXCJ3ZWVrXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoTlt3XSA+IGMpIHtcbiAgICAgICAgICAgIHcgPSBuO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGtbd10gJiYgbC5zdWJzdHIoa1t3XSkgIT09IFwiMDEtMDEgMDA6MDA6MDAuMDAwXCIuc3Vic3RyKGtbd10pKSBicmVhaztcbiAgICAgICAgICBcIndlZWtcIiAhPT0gdyAmJiAobiA9IHcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHcpIHZhciBoID0gYS5yZXNvbHZlRFRMRm9ybWF0KGZbd10pLm1haW47XG4gICAgICAgIHJldHVybiBoO1xuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUuZ2V0TGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjLFxuICAgICAgICAgICAgZSA9IHRoaXMsXG4gICAgICAgICAgICBuID0gdGhpcy5jaGFydC5yZW5kZXJlcixcbiAgICAgICAgICAgIGYgPSB0aGlzLmNoYXJ0LnN0eWxlZE1vZGUsXG4gICAgICAgICAgICBhID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgbCA9IFwidG9vbHRpcFwiICsgKEkoYS5jbGFzc05hbWUpID8gXCIgXCIgKyBhLmNsYXNzTmFtZSA6IFwiXCIpLFxuICAgICAgICAgICAgdiA9IChudWxsID09PSAoYyA9IGEuc3R5bGUpIHx8IHZvaWQgMCA9PT0gYyA/IHZvaWQgMCA6IGMucG9pbnRlckV2ZW50cykgfHwgKCF0aGlzLmZvbGxvd1BvaW50ZXIgJiYgYS5zdGlja09uQ29udGFjdCA/IFwiYXV0b1wiIDogXCJub25lXCIpLFxuICAgICAgICAgICAgaDtcblxuICAgICAgICBjID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGUuaW5Db250YWN0ID0gITA7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGEgPSBlLmNoYXJ0LmhvdmVyU2VyaWVzO1xuICAgICAgICAgIGUuaW5Db250YWN0ID0gITE7XG4gICAgICAgICAgaWYgKGEgJiYgYS5vbk1vdXNlT3V0KSBhLm9uTW91c2VPdXQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIXRoaXMubGFiZWwpIHtcbiAgICAgICAgICB0aGlzLm91dHNpZGUgJiYgKHRoaXMuY29udGFpbmVyID0gaCA9IGQuZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGguY2xhc3NOYW1lID0gXCJoaWdoY2hhcnRzLXRvb2x0aXAtY29udGFpbmVyXCIsIHUoaCwge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHRvcDogXCIxcHhcIixcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IHYsXG4gICAgICAgICAgICB6SW5kZXg6IDNcbiAgICAgICAgICB9KSwgZC5kb2MuYm9keS5hcHBlbmRDaGlsZChoKSwgdGhpcy5yZW5kZXJlciA9IG4gPSBuZXcgZC5SZW5kZXJlcihoLCAwLCAwLCB7fSwgdm9pZCAwLCB2b2lkIDAsIG4uc3R5bGVkTW9kZSkpO1xuICAgICAgICAgIHRoaXMuc3BsaXQgPyB0aGlzLmxhYmVsID0gbi5nKGwpIDogKHRoaXMubGFiZWwgPSBuLmxhYmVsKFwiXCIsIDAsIDAsIGEuc2hhcGUgfHwgXCJjYWxsb3V0XCIsIG51bGwsIG51bGwsIGEudXNlSFRNTCwgbnVsbCwgbCkuYXR0cih7XG4gICAgICAgICAgICBwYWRkaW5nOiBhLnBhZGRpbmcsXG4gICAgICAgICAgICByOiBhLmJvcmRlclJhZGl1c1xuICAgICAgICAgIH0pLCBmIHx8IHRoaXMubGFiZWwuYXR0cih7XG4gICAgICAgICAgICBmaWxsOiBhLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IGEuYm9yZGVyV2lkdGhcbiAgICAgICAgICB9KS5jc3MoYS5zdHlsZSkuY3NzKHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IHZcbiAgICAgICAgICB9KS5zaGFkb3coYS5zaGFkb3cpKTtcbiAgICAgICAgICBmICYmICh0aGlzLmFwcGx5RmlsdGVyKCksIHRoaXMubGFiZWwuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXRvb2x0aXAtXCIgKyB0aGlzLmNoYXJ0LmluZGV4KSk7XG5cbiAgICAgICAgICBpZiAoZS5vdXRzaWRlICYmICFlLnNwbGl0KSB7XG4gICAgICAgICAgICB2YXIgQiA9IHtcbiAgICAgICAgICAgICAgeDogdGhpcy5sYWJlbC54U2V0dGVyLFxuICAgICAgICAgICAgICB5OiB0aGlzLmxhYmVsLnlTZXR0ZXJcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMubGFiZWwueFNldHRlciA9IGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgICAgICAgIEJbY10uY2FsbCh0aGlzLmxhYmVsLCBlLmRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgaC5zdHlsZS5sZWZ0ID0gYSArIFwicHhcIjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMubGFiZWwueVNldHRlciA9IGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgICAgICAgIEJbY10uY2FsbCh0aGlzLmxhYmVsLCBlLmRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgaC5zdHlsZS50b3AgPSBhICsgXCJweFwiO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmxhYmVsLm9uKFwibW91c2VlbnRlclwiLCBjKS5vbihcIm1vdXNlbGVhdmVcIiwgdykuYXR0cih7XG4gICAgICAgICAgICB6SW5kZXg6IDhcbiAgICAgICAgICB9KS5hZGQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsO1xuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoYywgZSwgZCkge1xuICAgICAgICB2YXIgZiA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBhID0gdGhpcy5kaXN0YW5jZSxcbiAgICAgICAgICAgIGwgPSB7fSxcbiAgICAgICAgICAgIGsgPSBmLmludmVydGVkICYmIGQuaCB8fCAwLFxuICAgICAgICAgICAgbixcbiAgICAgICAgICAgIHcgPSB0aGlzLm91dHNpZGUsXG4gICAgICAgICAgICBoID0gdyA/IHEuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC0gMiAqIGEgOiBmLmNoYXJ0V2lkdGgsXG4gICAgICAgICAgICBnID0gdyA/IE1hdGgubWF4KHEuYm9keS5zY3JvbGxIZWlnaHQsIHEuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCwgcS5ib2R5Lm9mZnNldEhlaWdodCwgcS5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0LCBxLmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpIDogZi5jaGFydEhlaWdodCxcbiAgICAgICAgICAgIFEgPSBmLnBvaW50ZXIuZ2V0Q2hhcnRQb3NpdGlvbigpLFxuICAgICAgICAgICAgSCA9IGYuY29udGFpbmVyU2NhbGluZyxcbiAgICAgICAgICAgIEsgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHJldHVybiBIID8gYiAqIEguc2NhbGVYIDogYjtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIHAgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHJldHVybiBIID8gYiAqIEguc2NhbGVZIDogYjtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIGIgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHZhciBsID0gXCJ4XCIgPT09IGI7XG4gICAgICAgICAgcmV0dXJuIFtiLCBsID8gaCA6IGcsIGwgPyBjIDogZV0uY29uY2F0KHcgPyBbbCA/IEsoYykgOiBwKGUpLCBsID8gUS5sZWZ0IC0gYSArIEsoZC5wbG90WCArIGYucGxvdExlZnQpIDogUS50b3AgLSBhICsgcChkLnBsb3RZICsgZi5wbG90VG9wKSwgMCwgbCA/IGggOiBnXSA6IFtsID8gYyA6IGUsIGwgPyBkLnBsb3RYICsgZi5wbG90TGVmdCA6IGQucGxvdFkgKyBmLnBsb3RUb3AsIGwgPyBmLnBsb3RMZWZ0IDogZi5wbG90VG9wLCBsID8gZi5wbG90TGVmdCArIGYucGxvdFdpZHRoIDogZi5wbG90VG9wICsgZi5wbG90SGVpZ2h0XSk7XG4gICAgICAgIH0sXG4gICAgICAgICAgICBDID0gYihcInlcIiksXG4gICAgICAgICAgICB4ID0gYihcInhcIiksXG4gICAgICAgICAgICBSID0gIXRoaXMuZm9sbG93UG9pbnRlciAmJiB0KGQudHRCZWxvdywgIWYuaW52ZXJ0ZWQgPT09ICEhZC5uZWdhdGl2ZSksXG4gICAgICAgICAgICBPID0gZnVuY3Rpb24gKGIsIGMsIGYsIGUsIGQsIG0sIHYpIHtcbiAgICAgICAgICB2YXIgbiA9IFwieVwiID09PSBiID8gcChhKSA6IEsoYSksXG4gICAgICAgICAgICAgIHcgPSAoZiAtIGUpIC8gMixcbiAgICAgICAgICAgICAgeCA9IGUgPCBkIC0gYSxcbiAgICAgICAgICAgICAgaCA9IGQgKyBhICsgZSA8IGMsXG4gICAgICAgICAgICAgIEYgPSBkIC0gbiAtIGYgKyB3O1xuICAgICAgICAgIGQgPSBkICsgbiAtIHc7XG4gICAgICAgICAgaWYgKFIgJiYgaCkgbFtiXSA9IGQ7ZWxzZSBpZiAoIVIgJiYgeCkgbFtiXSA9IEY7ZWxzZSBpZiAoeCkgbFtiXSA9IE1hdGgubWluKHYgLSBlLCAwID4gRiAtIGsgPyBGIDogRiAtIGspO2Vsc2UgaWYgKGgpIGxbYl0gPSBNYXRoLm1heChtLCBkICsgayArIGYgPiBjID8gZCA6IGQgKyBrKTtlbHNlIHJldHVybiAhMTtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIHkgPSBmdW5jdGlvbiAoYiwgYywgZiwgZSwgZCkge1xuICAgICAgICAgIHZhciBrO1xuICAgICAgICAgIGQgPCBhIHx8IGQgPiBjIC0gYSA/IGsgPSAhMSA6IGxbYl0gPSBkIDwgZiAvIDIgPyAxIDogZCA+IGMgLSBlIC8gMiA/IGMgLSBlIC0gMiA6IGQgLSBmIC8gMjtcbiAgICAgICAgICByZXR1cm4gaztcbiAgICAgICAgfSxcbiAgICAgICAgICAgIHUgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHZhciBhID0gQztcbiAgICAgICAgICBDID0geDtcbiAgICAgICAgICB4ID0gYTtcbiAgICAgICAgICBuID0gYjtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIG0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgITEgIT09IE8uYXBwbHkoMCwgQykgPyAhMSAhPT0geS5hcHBseSgwLCB4KSB8fCBuIHx8ICh1KCEwKSwgbSgpKSA6IG4gPyBsLnggPSBsLnkgPSAwIDogKHUoITApLCBtKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIChmLmludmVydGVkIHx8IDEgPCB0aGlzLmxlbikgJiYgdSgpO1xuICAgICAgICBtKCk7XG4gICAgICAgIHJldHVybiBsO1xuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUuZ2V0WERhdGVGb3JtYXQgPSBmdW5jdGlvbiAoYywgZSwgZCkge1xuICAgICAgICBlID0gZS5kYXRlVGltZUxhYmVsRm9ybWF0cztcbiAgICAgICAgdmFyIGYgPSBkICYmIGQuY2xvc2VzdFBvaW50UmFuZ2U7XG4gICAgICAgIHJldHVybiAoZiA/IHRoaXMuZ2V0RGF0ZUZvcm1hdChmLCBjLngsIGQub3B0aW9ucy5zdGFydE9mV2VlaywgZSkgOiBlLmRheSkgfHwgZS55ZWFyO1xuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgZy5jbGVhclRpbWVvdXQodGhpcy5oaWRlVGltZXIpO1xuICAgICAgICBjID0gdChjLCB0aGlzLm9wdGlvbnMuaGlkZURlbGF5LCA1MDApO1xuICAgICAgICB0aGlzLmlzSGlkZGVuIHx8ICh0aGlzLmhpZGVUaW1lciA9IGgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGUuZ2V0TGFiZWwoKVtjID8gXCJmYWRlT3V0XCIgOiBcImhpZGVcIl0oKTtcbiAgICAgICAgICBlLmlzSGlkZGVuID0gITA7XG4gICAgICAgIH0sIGMpKTtcbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoYywgZSkge1xuICAgICAgICB0aGlzLmNoYXJ0ID0gYztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZTtcbiAgICAgICAgdGhpcy5jcm9zc2hhaXJzID0gW107XG4gICAgICAgIHRoaXMubm93ID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzSGlkZGVuID0gITA7XG4gICAgICAgIHRoaXMuc3BsaXQgPSBlLnNwbGl0ICYmICFjLmludmVydGVkICYmICFjLnBvbGFyO1xuICAgICAgICB0aGlzLnNoYXJlZCA9IGUuc2hhcmVkIHx8IHRoaXMuc3BsaXQ7XG4gICAgICAgIHRoaXMub3V0c2lkZSA9IHQoZS5vdXRzaWRlLCAhKCFjLnNjcm9sbGFibGVQaXhlbHNYICYmICFjLnNjcm9sbGFibGVQaXhlbHNZKSk7XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS5pc1N0aWNreU9uQ29udGFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEodGhpcy5mb2xsb3dQb2ludGVyIHx8ICF0aGlzLm9wdGlvbnMuc3RpY2tPbkNvbnRhY3QgfHwgIXRoaXMuaW5Db250YWN0KTtcbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoYywgZSwgZCwgZikge1xuICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICBsID0gYS5ub3csXG4gICAgICAgICAgICBrID0gITEgIT09IGEub3B0aW9ucy5hbmltYXRpb24gJiYgIWEuaXNIaWRkZW4gJiYgKDEgPCBNYXRoLmFicyhjIC0gbC54KSB8fCAxIDwgTWF0aC5hYnMoZSAtIGwueSkpLFxuICAgICAgICAgICAgbiA9IGEuZm9sbG93UG9pbnRlciB8fCAxIDwgYS5sZW47XG4gICAgICAgIEUobCwge1xuICAgICAgICAgIHg6IGsgPyAoMiAqIGwueCArIGMpIC8gMyA6IGMsXG4gICAgICAgICAgeTogayA/IChsLnkgKyBlKSAvIDIgOiBlLFxuICAgICAgICAgIGFuY2hvclg6IG4gPyB2b2lkIDAgOiBrID8gKDIgKiBsLmFuY2hvclggKyBkKSAvIDMgOiBkLFxuICAgICAgICAgIGFuY2hvclk6IG4gPyB2b2lkIDAgOiBrID8gKGwuYW5jaG9yWSArIGYpIC8gMiA6IGZcbiAgICAgICAgfSk7XG4gICAgICAgIGEuZ2V0TGFiZWwoKS5hdHRyKGwpO1xuICAgICAgICBhLmRyYXdUcmFja2VyKCk7XG4gICAgICAgIGsgJiYgKGcuY2xlYXJUaW1lb3V0KHRoaXMudG9vbHRpcFRpbWVvdXQpLCB0aGlzLnRvb2x0aXBUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYSAmJiBhLm1vdmUoYywgZSwgZCwgZik7XG4gICAgICAgIH0sIDMyKSk7XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKGMsIGUpIHtcbiAgICAgICAgdmFyIGsgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGEgPSBjLFxuICAgICAgICAgICAgbCA9IHt9LFxuICAgICAgICAgICAgdiA9IFtdLFxuICAgICAgICAgICAgaCA9IGYuZm9ybWF0dGVyIHx8IHRoaXMuZGVmYXVsdEZvcm1hdHRlcjtcbiAgICAgICAgbCA9IHRoaXMuc2hhcmVkO1xuICAgICAgICB2YXIgdyA9IGsuc3R5bGVkTW9kZTtcblxuICAgICAgICBpZiAoZi5lbmFibGVkKSB7XG4gICAgICAgICAgZy5jbGVhclRpbWVvdXQodGhpcy5oaWRlVGltZXIpO1xuICAgICAgICAgIHRoaXMuZm9sbG93UG9pbnRlciA9IEQoYSlbMF0uc2VyaWVzLnRvb2x0aXBPcHRpb25zLmZvbGxvd1BvaW50ZXI7XG4gICAgICAgICAgdmFyIEIgPSB0aGlzLmdldEFuY2hvcihhLCBlKTtcbiAgICAgICAgICBlID0gQlswXTtcbiAgICAgICAgICB2YXIgcSA9IEJbMV07XG4gICAgICAgICAgIWwgfHwgYS5zZXJpZXMgJiYgYS5zZXJpZXMubm9TaGFyZWRUb29sdGlwID8gbCA9IGEuZ2V0TGFiZWxDb25maWcoKSA6IChrLnBvaW50ZXIuYXBwbHlJbmFjdGl2ZVN0YXRlKGEpLCBhLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGEuc2V0U3RhdGUoXCJob3ZlclwiKTtcbiAgICAgICAgICAgIHYucHVzaChhLmdldExhYmVsQ29uZmlnKCkpO1xuICAgICAgICAgIH0pLCBsID0ge1xuICAgICAgICAgICAgeDogYVswXS5jYXRlZ29yeSxcbiAgICAgICAgICAgIHk6IGFbMF0ueVxuICAgICAgICAgIH0sIGwucG9pbnRzID0gdiwgYSA9IGFbMF0pO1xuICAgICAgICAgIHRoaXMubGVuID0gdi5sZW5ndGg7XG4gICAgICAgICAgayA9IGguY2FsbChsLCB0aGlzKTtcbiAgICAgICAgICBoID0gYS5zZXJpZXM7XG4gICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IHQoaC50b29sdGlwT3B0aW9ucy5kaXN0YW5jZSwgMTYpO1xuICAgICAgICAgICExID09PSBrID8gdGhpcy5oaWRlKCkgOiAodGhpcy5zcGxpdCA/IHRoaXMucmVuZGVyU3BsaXQoaywgRChjKSkgOiAoYyA9IHRoaXMuZ2V0TGFiZWwoKSwgZi5zdHlsZS53aWR0aCAmJiAhdyB8fCBjLmNzcyh7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5jaGFydC5zcGFjaW5nQm94LndpZHRoXG4gICAgICAgICAgfSksIGMuYXR0cih7XG4gICAgICAgICAgICB0ZXh0OiBrICYmIGsuam9pbiA/IGsuam9pbihcIlwiKSA6IGtcbiAgICAgICAgICB9KSwgYy5yZW1vdmVDbGFzcygvaGlnaGNoYXJ0cy1jb2xvci1bXFxkXSsvZykuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWNvbG9yLVwiICsgdChhLmNvbG9ySW5kZXgsIGguY29sb3JJbmRleCkpLCB3IHx8IGMuYXR0cih7XG4gICAgICAgICAgICBzdHJva2U6IGYuYm9yZGVyQ29sb3IgfHwgYS5jb2xvciB8fCBoLmNvbG9yIHx8IFwiIzY2NjY2NlwiXG4gICAgICAgICAgfSksIHRoaXMudXBkYXRlUG9zaXRpb24oe1xuICAgICAgICAgICAgcGxvdFg6IGUsXG4gICAgICAgICAgICBwbG90WTogcSxcbiAgICAgICAgICAgIG5lZ2F0aXZlOiBhLm5lZ2F0aXZlLFxuICAgICAgICAgICAgdHRCZWxvdzogYS50dEJlbG93LFxuICAgICAgICAgICAgaDogQlsyXSB8fCAwXG4gICAgICAgICAgfSkpLCB0aGlzLmlzSGlkZGVuICYmIHRoaXMubGFiZWwgJiYgdGhpcy5sYWJlbC5hdHRyKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9KS5zaG93KCksIHRoaXMuaXNIaWRkZW4gPSAhMSk7XG4gICAgICAgICAgZC5maXJlRXZlbnQodGhpcywgXCJyZWZyZXNoXCIpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS5yZW5kZXJTcGxpdCA9IGZ1bmN0aW9uIChjLCBlKSB7XG4gICAgICAgIGZ1bmN0aW9uIGsoYiwgYSwgYywgZiwgZSkge1xuICAgICAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9ICEwKTtcbiAgICAgICAgICBjID8gKGEgPSB1ID8gMCA6IEEsIGIgPSByKGIgLSBmIC8gMiwgTy5sZWZ0LCBPLnJpZ2h0IC0gZikpIDogKGEgLT0gbSwgYiA9IGUgPyBiIC0gZiAtIEMgOiBiICsgQywgYiA9IHIoYiwgZSA/IGIgOiBPLmxlZnQsIE8ucmlnaHQpKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogYixcbiAgICAgICAgICAgIHk6IGFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGYgPSB0aGlzLFxuICAgICAgICAgICAgYSA9IGYuY2hhcnQsXG4gICAgICAgICAgICBsID0gZi5jaGFydCxcbiAgICAgICAgICAgIHYgPSBsLnBsb3RIZWlnaHQsXG4gICAgICAgICAgICBoID0gbC5wbG90TGVmdCxcbiAgICAgICAgICAgIHcgPSBsLnBsb3RUb3AsXG4gICAgICAgICAgICBCID0gbC5wb2ludGVyLFxuICAgICAgICAgICAgcSA9IGwucmVuZGVyZXIsXG4gICAgICAgICAgICBnID0gbC5zY3JvbGxhYmxlUGl4ZWxzWSxcbiAgICAgICAgICAgIEggPSB2b2lkIDAgPT09IGcgPyAwIDogZztcbiAgICAgICAgZyA9IGwuc2Nyb2xsaW5nQ29udGFpbmVyO1xuICAgICAgICBnID0gdm9pZCAwID09PSBnID8ge1xuICAgICAgICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgICAgICAgc2Nyb2xsVG9wOiAwXG4gICAgICAgIH0gOiBnO1xuICAgICAgICB2YXIgSyA9IGcuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHAgPSBnLnNjcm9sbFRvcCxcbiAgICAgICAgICAgIGIgPSBsLnN0eWxlZE1vZGUsXG4gICAgICAgICAgICBDID0gZi5kaXN0YW5jZSxcbiAgICAgICAgICAgIHggPSBmLm9wdGlvbnMsXG4gICAgICAgICAgICBSID0gZi5vcHRpb25zLnBvc2l0aW9uZXIsXG4gICAgICAgICAgICBPID0ge1xuICAgICAgICAgIGxlZnQ6IEssXG4gICAgICAgICAgcmlnaHQ6IEsgKyBsLmNoYXJ0V2lkdGgsXG4gICAgICAgICAgdG9wOiBwLFxuICAgICAgICAgIGJvdHRvbTogcCArIGwuY2hhcnRIZWlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgICAgIHkgPSBmLmdldExhYmVsKCksXG4gICAgICAgICAgICB1ID0gISghYS54QXhpc1swXSB8fCAhYS54QXhpc1swXS5vcHBvc2l0ZSksXG4gICAgICAgICAgICBtID0gdyArIHAsXG4gICAgICAgICAgICBEID0gMCxcbiAgICAgICAgICAgIEEgPSB2IC0gSDtcbiAgICAgICAgSihjKSAmJiAoYyA9IFshMSwgY10pO1xuICAgICAgICBjID0gYy5zbGljZSgwLCBlLmxlbmd0aCArIDEpLnJlZHVjZShmdW5jdGlvbiAoYSwgYywgbCkge1xuICAgICAgICAgIGlmICghMSAhPT0gYyAmJiBcIlwiICE9PSBjKSB7XG4gICAgICAgICAgICBsID0gZVtsIC0gMV0gfHwge1xuICAgICAgICAgICAgICBpc0hlYWRlcjogITAsXG4gICAgICAgICAgICAgIHBsb3RYOiBlWzBdLnBsb3RYLFxuICAgICAgICAgICAgICBwbG90WTogdixcbiAgICAgICAgICAgICAgc2VyaWVzOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkID0gbC5pc0hlYWRlcixcbiAgICAgICAgICAgICAgICBuID0gZCA/IGYgOiBsLnNlcmllcyxcbiAgICAgICAgICAgICAgICBGID0gbi50dCxcbiAgICAgICAgICAgICAgICB6ID0gbC5pc0hlYWRlcjtcbiAgICAgICAgICAgIHZhciBCID0gbC5zZXJpZXM7XG4gICAgICAgICAgICB2YXIgZyA9IFwiaGlnaGNoYXJ0cy1jb2xvci1cIiArIHQobC5jb2xvckluZGV4LCBCLmNvbG9ySW5kZXgsIFwibm9uZVwiKTtcbiAgICAgICAgICAgIEYgfHwgKEYgPSB7XG4gICAgICAgICAgICAgIHBhZGRpbmc6IHgucGFkZGluZyxcbiAgICAgICAgICAgICAgcjogeC5ib3JkZXJSYWRpdXNcbiAgICAgICAgICAgIH0sIGIgfHwgKEYuZmlsbCA9IHguYmFja2dyb3VuZENvbG9yLCBGW1wic3Ryb2tlLXdpZHRoXCJdID0geC5ib3JkZXJXaWR0aCksIEYgPSBxLmxhYmVsKFwiXCIsIDAsIDAsIHhbeiA/IFwiaGVhZGVyU2hhcGVcIiA6IFwic2hhcGVcIl0gfHwgXCJjYWxsb3V0XCIsIHZvaWQgMCwgdm9pZCAwLCB4LnVzZUhUTUwpLmFkZENsYXNzKCh6ID8gXCJoaWdoY2hhcnRzLXRvb2x0aXAtaGVhZGVyIFwiIDogXCJcIikgKyBcImhpZ2hjaGFydHMtdG9vbHRpcC1ib3ggXCIgKyBnKS5hdHRyKEYpLmFkZCh5KSk7XG4gICAgICAgICAgICBGLmlzQWN0aXZlID0gITA7XG4gICAgICAgICAgICBGLmF0dHIoe1xuICAgICAgICAgICAgICB0ZXh0OiBjXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGIgfHwgRi5jc3MoeC5zdHlsZSkuc2hhZG93KHguc2hhZG93KS5hdHRyKHtcbiAgICAgICAgICAgICAgc3Ryb2tlOiB4LmJvcmRlckNvbG9yIHx8IGwuY29sb3IgfHwgQi5jb2xvciB8fCBcIiMzMzMzMzNcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjID0gbi50dCA9IEY7XG4gICAgICAgICAgICB6ID0gYy5nZXRCQm94KCk7XG4gICAgICAgICAgICBuID0gei53aWR0aCArIGMuc3Ryb2tlV2lkdGgoKTtcbiAgICAgICAgICAgIGQgJiYgKEQgPSB6LmhlaWdodCwgQSArPSBELCB1ICYmIChtIC09IEQpKTtcbiAgICAgICAgICAgIEIgPSBsLnBsb3RYO1xuICAgICAgICAgICAgQiA9IHZvaWQgMCA9PT0gQiA/IDAgOiBCO1xuICAgICAgICAgICAgZyA9IGwucGxvdFk7XG4gICAgICAgICAgICBnID0gdm9pZCAwID09PSBnID8gMCA6IGc7XG4gICAgICAgICAgICB2YXIgTCA9IGwuc2VyaWVzO1xuXG4gICAgICAgICAgICBpZiAobC5pc0hlYWRlcikge1xuICAgICAgICAgICAgICBCID0gaCArIEI7XG4gICAgICAgICAgICAgIHZhciBLID0gdyArIHYgLyAyO1xuICAgICAgICAgICAgfSBlbHNlIEYgPSBMLnhBeGlzLCBMID0gTC55QXhpcywgQiA9IEYucG9zICsgcihCLCAtQywgRi5sZW4gKyBDKSwgTC5wb3MgKyBnID49IHAgKyB3ICYmIEwucG9zICsgZyA8PSBwICsgdyArIHYgLSBIICYmIChLID0gTC5wb3MgKyBnKTtcblxuICAgICAgICAgICAgQiA9IHIoQiwgTy5sZWZ0IC0gQywgTy5yaWdodCArIEMpO1xuICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIEsgPyAoeiA9IHouaGVpZ2h0ICsgMSwgZyA9IFIgPyBSLmNhbGwoZiwgbiwgeiwgbCkgOiBrKEIsIEssIGQsIG4pLCBhLnB1c2goe1xuICAgICAgICAgICAgICBhbGlnbjogUiA/IDAgOiB2b2lkIDAsXG4gICAgICAgICAgICAgIGFuY2hvclg6IEIsXG4gICAgICAgICAgICAgIGFuY2hvclk6IEssXG4gICAgICAgICAgICAgIGJveFdpZHRoOiBuLFxuICAgICAgICAgICAgICBwb2ludDogbCxcbiAgICAgICAgICAgICAgcmFuazogdChnLnJhbmssIGQgPyAxIDogMCksXG4gICAgICAgICAgICAgIHNpemU6IHosXG4gICAgICAgICAgICAgIHRhcmdldDogZy55LFxuICAgICAgICAgICAgICB0dDogYyxcbiAgICAgICAgICAgICAgeDogZy54XG4gICAgICAgICAgICB9KSkgOiBjLmlzQWN0aXZlID0gITE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgIVIgJiYgYy5zb21lKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgcmV0dXJuIGIueCA8IE8ubGVmdDtcbiAgICAgICAgfSkgJiYgKGMgPSBjLm1hcChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHZhciBhID0gayhiLmFuY2hvclgsIGIuYW5jaG9yWSwgYi5wb2ludC5pc0hlYWRlciwgYi5ib3hXaWR0aCwgITEpO1xuICAgICAgICAgIHJldHVybiBFKGIsIHtcbiAgICAgICAgICAgIHRhcmdldDogYS55LFxuICAgICAgICAgICAgeDogYS54XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgZi5jbGVhblNwbGl0KCk7XG4gICAgICAgIGQuZGlzdHJpYnV0ZShjLCBBKTtcbiAgICAgICAgYy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgdmFyIGEgPSBiLnBvcztcbiAgICAgICAgICBiLnR0LmF0dHIoe1xuICAgICAgICAgICAgdmlzaWJpbGl0eTogXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGEgPyBcImhpZGRlblwiIDogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICB4OiBiLngsXG4gICAgICAgICAgICB5OiBhICsgbSxcbiAgICAgICAgICAgIGFuY2hvclg6IGIuYW5jaG9yWCxcbiAgICAgICAgICAgIGFuY2hvclk6IGIuYW5jaG9yWVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYyA9IGYuY29udGFpbmVyO1xuICAgICAgICBhID0gZi5yZW5kZXJlcjtcbiAgICAgICAgZi5vdXRzaWRlICYmIGMgJiYgYSAmJiAobCA9IHkuZ2V0QkJveCgpLCBhLnNldFNpemUobC53aWR0aCArIGwueCwgbC5oZWlnaHQgKyBsLnksICExKSwgQiA9IEIuZ2V0Q2hhcnRQb3NpdGlvbigpLCBjLnN0eWxlLmxlZnQgPSBCLmxlZnQgKyBcInB4XCIsIGMuc3R5bGUudG9wID0gQi50b3AgKyBcInB4XCIpO1xuICAgICAgfTtcblxuICAgICAgZS5wcm90b3R5cGUuZHJhd1RyYWNrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmZvbGxvd1BvaW50ZXIgfHwgIXRoaXMub3B0aW9ucy5zdGlja09uQ29udGFjdCkgdGhpcy50cmFja2VyICYmIHRoaXMudHJhY2tlci5kZXN0cm95KCk7ZWxzZSB7XG4gICAgICAgICAgdmFyIGMgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgICBlID0gdGhpcy5sYWJlbCxcbiAgICAgICAgICAgICAgZCA9IGMuaG92ZXJQb2ludDtcblxuICAgICAgICAgIGlmIChlICYmIGQpIHtcbiAgICAgICAgICAgIHZhciBmID0ge1xuICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZCA9IHRoaXMuZ2V0QW5jaG9yKGQpO1xuICAgICAgICAgICAgdmFyIGEgPSBlLmdldEJCb3goKTtcbiAgICAgICAgICAgIGRbMF0gKz0gYy5wbG90TGVmdCAtIGUudHJhbnNsYXRlWDtcbiAgICAgICAgICAgIGRbMV0gKz0gYy5wbG90VG9wIC0gZS50cmFuc2xhdGVZO1xuICAgICAgICAgICAgZi54ID0gTWF0aC5taW4oMCwgZFswXSk7XG4gICAgICAgICAgICBmLnkgPSBNYXRoLm1pbigwLCBkWzFdKTtcbiAgICAgICAgICAgIGYud2lkdGggPSAwID4gZFswXSA/IE1hdGgubWF4KE1hdGguYWJzKGRbMF0pLCBhLndpZHRoIC0gZFswXSkgOiBNYXRoLm1heChNYXRoLmFicyhkWzBdKSwgYS53aWR0aCk7XG4gICAgICAgICAgICBmLmhlaWdodCA9IDAgPiBkWzFdID8gTWF0aC5tYXgoTWF0aC5hYnMoZFsxXSksIGEuaGVpZ2h0IC0gTWF0aC5hYnMoZFsxXSkpIDogTWF0aC5tYXgoTWF0aC5hYnMoZFsxXSksIGEuaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tlciA/IHRoaXMudHJhY2tlci5hdHRyKGYpIDogKHRoaXMudHJhY2tlciA9IGUucmVuZGVyZXIucmVjdChmKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtdHJhY2tlclwiKS5hZGQoZSksIGMuc3R5bGVkTW9kZSB8fCB0aGlzLnRyYWNrZXIuYXR0cih7XG4gICAgICAgICAgICAgIGZpbGw6IFwicmdiYSgwLDAsMCwwKVwiXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBlLnByb3RvdHlwZS5zdHlsZWRNb2RlRm9ybWF0ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMucmVwbGFjZSgnc3R5bGU9XCJmb250LXNpemU6IDEwcHhcIicsICdjbGFzcz1cImhpZ2hjaGFydHMtaGVhZGVyXCInKS5yZXBsYWNlKC9zdHlsZT1cImNvbG9yOnsocG9pbnR8c2VyaWVzKVxcLmNvbG9yfVwiL2csICdjbGFzcz1cImhpZ2hjaGFydHMtY29sb3IteyQxLmNvbG9ySW5kZXh9XCInKTtcbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLnRvb2x0aXBGb290ZXJIZWFkZXJGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoYywgZSkge1xuICAgICAgICB2YXIgayA9IGUgPyBcImZvb3RlclwiIDogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIGYgPSBjLnNlcmllcyxcbiAgICAgICAgICAgIGEgPSBmLnRvb2x0aXBPcHRpb25zLFxuICAgICAgICAgICAgbCA9IGEueERhdGVGb3JtYXQsXG4gICAgICAgICAgICB2ID0gZi54QXhpcyxcbiAgICAgICAgICAgIGggPSB2ICYmIFwiZGF0ZXRpbWVcIiA9PT0gdi5vcHRpb25zLnR5cGUgJiYgRyhjLmtleSksXG4gICAgICAgICAgICB3ID0gYVtrICsgXCJGb3JtYXRcIl07XG4gICAgICAgIGUgPSB7XG4gICAgICAgICAgaXNGb290ZXI6IGUsXG4gICAgICAgICAgbGFiZWxDb25maWc6IGNcbiAgICAgICAgfTtcbiAgICAgICAgZC5maXJlRXZlbnQodGhpcywgXCJoZWFkZXJGb3JtYXR0ZXJcIiwgZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBoICYmICFsICYmIChsID0gdGhpcy5nZXRYRGF0ZUZvcm1hdChjLCBhLCB2KSk7XG4gICAgICAgICAgaCAmJiBsICYmIChjLnBvaW50ICYmIGMucG9pbnQudG9vbHRpcERhdGVLZXlzIHx8IFtcImtleVwiXSkuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgdyA9IHcucmVwbGFjZShcIntwb2ludC5cIiArIGEgKyBcIn1cIiwgXCJ7cG9pbnQuXCIgKyBhICsgXCI6XCIgKyBsICsgXCJ9XCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGYuY2hhcnQuc3R5bGVkTW9kZSAmJiAodyA9IHRoaXMuc3R5bGVkTW9kZUZvcm1hdCh3KSk7XG4gICAgICAgICAgZS50ZXh0ID0gQSh3LCB7XG4gICAgICAgICAgICBwb2ludDogYyxcbiAgICAgICAgICAgIHNlcmllczogZlxuICAgICAgICAgIH0sIHRoaXMuY2hhcnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGUudGV4dDtcbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICB5KCEwLCB0aGlzLmNoYXJ0Lm9wdGlvbnMudG9vbHRpcC51c2VyT3B0aW9ucywgYyk7XG4gICAgICAgIHRoaXMuaW5pdCh0aGlzLmNoYXJ0LCB5KCEwLCB0aGlzLm9wdGlvbnMsIGMpKTtcbiAgICAgIH07XG5cbiAgICAgIGUucHJvdG90eXBlLnVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZCA9IGUucG9pbnRlcixcbiAgICAgICAgICAgIGYgPSB0aGlzLmdldExhYmVsKCksXG4gICAgICAgICAgICBhID0gYy5wbG90WCArIGUucGxvdExlZnQsXG4gICAgICAgICAgICBsID0gYy5wbG90WSArIGUucGxvdFRvcDtcbiAgICAgICAgZCA9IGQuZ2V0Q2hhcnRQb3NpdGlvbigpO1xuICAgICAgICBjID0gKHRoaXMub3B0aW9ucy5wb3NpdGlvbmVyIHx8IHRoaXMuZ2V0UG9zaXRpb24pLmNhbGwodGhpcywgZi53aWR0aCwgZi5oZWlnaHQsIGMpO1xuXG4gICAgICAgIGlmICh0aGlzLm91dHNpZGUpIHtcbiAgICAgICAgICB2YXIgdiA9ICh0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMCkgKyAyICogdGhpcy5kaXN0YW5jZTtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUoZi53aWR0aCArIHYsIGYuaGVpZ2h0ICsgdiwgITEpO1xuICAgICAgICAgIGlmIChlID0gZS5jb250YWluZXJTY2FsaW5nKSB1KHRoaXMuY29udGFpbmVyLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGUoXCIgKyBlLnNjYWxlWCArIFwiLCBcIiArIGUuc2NhbGVZICsgXCIpXCJcbiAgICAgICAgICB9KSwgYSAqPSBlLnNjYWxlWCwgbCAqPSBlLnNjYWxlWTtcbiAgICAgICAgICBhICs9IGQubGVmdCAtIGMueDtcbiAgICAgICAgICBsICs9IGQudG9wIC0gYy55O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb3ZlKE1hdGgucm91bmQoYy54KSwgTWF0aC5yb3VuZChjLnkgfHwgMCksIGEsIGwpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGU7XG4gICAgfSgpO1xuXG4gICAgZC5Ub29sdGlwID0gUDtcbiAgICByZXR1cm4gZC5Ub29sdGlwO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL1BvaW50ZXIuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdLCByW1wicGFydHMvVG9vbHRpcC5qc1wiXSwgcltcInBhcnRzL0NvbG9yLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcsIHIsIHUpIHtcbiAgICB2YXIgSSA9IGcuYWRkRXZlbnQsXG4gICAgICAgIE0gPSBnLmF0dHIsXG4gICAgICAgIEUgPSBnLmNzcyxcbiAgICAgICAgQSA9IGcuZGVmaW5lZCxcbiAgICAgICAgRyA9IGcuZXh0ZW5kLFxuICAgICAgICBKID0gZy5maW5kLFxuICAgICAgICB5ID0gZy5maXJlRXZlbnQsXG4gICAgICAgIHQgPSBnLmlzTnVtYmVyLFxuICAgICAgICBEID0gZy5pc09iamVjdCxcbiAgICAgICAgaCA9IGcub2JqZWN0RWFjaCxcbiAgICAgICAgTiA9IGcub2Zmc2V0LFxuICAgICAgICBxID0gZy5waWNrLFxuICAgICAgICBQID0gZy5zcGxhdCxcbiAgICAgICAgZSA9IHUucGFyc2UsXG4gICAgICAgIGMgPSBkLmNoYXJ0cyxcbiAgICAgICAgayA9IGQubm9vcDtcblxuICAgIGcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBuKGMsIGEpIHtcbiAgICAgICAgdGhpcy5sYXN0VmFsaWRUb3VjaCA9IHt9O1xuICAgICAgICB0aGlzLnBpbmNoRG93biA9IFtdO1xuICAgICAgICB0aGlzLnJ1bkNoYXJ0Q2xpY2sgPSAhMTtcbiAgICAgICAgdGhpcy5jaGFydCA9IGM7XG4gICAgICAgIHRoaXMuaGFzRHJhZ2dlZCA9ICExO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBhO1xuXG4gICAgICAgIHRoaXMudW5iaW5kQ29udGFpbmVyTW91c2VMZWF2ZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgIHRoaXMuaW5pdChjLCBhKTtcbiAgICAgIH1cblxuICAgICAgbi5wcm90b3R5cGUuYXBwbHlJbmFjdGl2ZVN0YXRlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGEgPSBbXSxcbiAgICAgICAgICAgIGY7XG4gICAgICAgIChjIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgZiA9IGMuc2VyaWVzO1xuICAgICAgICAgIGEucHVzaChmKTtcbiAgICAgICAgICBmLmxpbmtlZFBhcmVudCAmJiBhLnB1c2goZi5saW5rZWRQYXJlbnQpO1xuICAgICAgICAgIGYubGlua2VkU2VyaWVzICYmIChhID0gYS5jb25jYXQoZi5saW5rZWRTZXJpZXMpKTtcbiAgICAgICAgICBmLm5hdmlnYXRvclNlcmllcyAmJiBhLnB1c2goZi5uYXZpZ2F0b3JTZXJpZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jaGFydC5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIC0xID09PSBhLmluZGV4T2YoYykgPyBjLnNldFN0YXRlKFwiaW5hY3RpdmVcIiwgITApIDogYy5vcHRpb25zLmluYWN0aXZlT3RoZXJQb2ludHMgJiYgYy5zZXRBbGxQb2ludHNUb1N0YXRlKFwiaW5hY3RpdmVcIik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzO1xuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYy51bkRvY01vdXNlTW92ZSAmJiBjLnVuRG9jTW91c2VNb3ZlKCk7XG4gICAgICAgIHRoaXMudW5iaW5kQ29udGFpbmVyTW91c2VMZWF2ZSgpO1xuICAgICAgICBkLmNoYXJ0Q291bnQgfHwgKGQudW5iaW5kRG9jdW1lbnRNb3VzZVVwICYmIChkLnVuYmluZERvY3VtZW50TW91c2VVcCA9IGQudW5iaW5kRG9jdW1lbnRNb3VzZVVwKCkpLCBkLnVuYmluZERvY3VtZW50VG91Y2hFbmQgJiYgKGQudW5iaW5kRG9jdW1lbnRUb3VjaEVuZCA9IGQudW5iaW5kRG9jdW1lbnRUb3VjaEVuZCgpKSk7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoYy50b29sdGlwVGltZW91dCk7XG4gICAgICAgIGgoYywgZnVuY3Rpb24gKGEsIGYpIHtcbiAgICAgICAgICBjW2ZdID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5kcmFnID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZiA9IGEub3B0aW9ucy5jaGFydCxcbiAgICAgICAgICAgIGQgPSBjLmNoYXJ0WCxcbiAgICAgICAgICAgIGsgPSBjLmNoYXJ0WSxcbiAgICAgICAgICAgIHcgPSB0aGlzLnpvb21Ib3IsXG4gICAgICAgICAgICBuID0gdGhpcy56b29tVmVydCxcbiAgICAgICAgICAgIGggPSBhLnBsb3RMZWZ0LFxuICAgICAgICAgICAgcSA9IGEucGxvdFRvcCxcbiAgICAgICAgICAgIGcgPSBhLnBsb3RXaWR0aCxcbiAgICAgICAgICAgIHQgPSBhLnBsb3RIZWlnaHQsXG4gICAgICAgICAgICBwID0gdGhpcy5zZWxlY3Rpb25NYXJrZXIsXG4gICAgICAgICAgICBiID0gdGhpcy5tb3VzZURvd25YIHx8IDAsXG4gICAgICAgICAgICBDID0gdGhpcy5tb3VzZURvd25ZIHx8IDAsXG4gICAgICAgICAgICB4ID0gRChmLnBhbm5pbmcpID8gZi5wYW5uaW5nICYmIGYucGFubmluZy5lbmFibGVkIDogZi5wYW5uaW5nLFxuICAgICAgICAgICAgeSA9IGYucGFuS2V5ICYmIGNbZi5wYW5LZXkgKyBcIktleVwiXTtcbiAgICAgICAgaWYgKCFwIHx8ICFwLnRvdWNoKSBpZiAoZCA8IGggPyBkID0gaCA6IGQgPiBoICsgZyAmJiAoZCA9IGggKyBnKSwgayA8IHEgPyBrID0gcSA6IGsgPiBxICsgdCAmJiAoayA9IHEgKyB0KSwgdGhpcy5oYXNEcmFnZ2VkID0gTWF0aC5zcXJ0KE1hdGgucG93KGIgLSBkLCAyKSArIE1hdGgucG93KEMgLSBrLCAyKSksIDEwIDwgdGhpcy5oYXNEcmFnZ2VkKSB7XG4gICAgICAgICAgdmFyIE8gPSBhLmlzSW5zaWRlUGxvdChiIC0gaCwgQyAtIHEpO1xuICAgICAgICAgIGEuaGFzQ2FydGVzaWFuU2VyaWVzICYmICh0aGlzLnpvb21YIHx8IHRoaXMuem9vbVkpICYmIE8gJiYgIXkgJiYgIXAgJiYgKHRoaXMuc2VsZWN0aW9uTWFya2VyID0gcCA9IGEucmVuZGVyZXIucmVjdChoLCBxLCB3ID8gMSA6IGcsIG4gPyAxIDogdCwgMCkuYXR0cih7XG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiaGlnaGNoYXJ0cy1zZWxlY3Rpb24tbWFya2VyXCIsXG4gICAgICAgICAgICB6SW5kZXg6IDdcbiAgICAgICAgICB9KS5hZGQoKSwgYS5zdHlsZWRNb2RlIHx8IHAuYXR0cih7XG4gICAgICAgICAgICBmaWxsOiBmLnNlbGVjdGlvbk1hcmtlckZpbGwgfHwgZShcIiMzMzVjYWRcIikuc2V0T3BhY2l0eSguMjUpLmdldCgpXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHAgJiYgdyAmJiAoZCAtPSBiLCBwLmF0dHIoe1xuICAgICAgICAgICAgd2lkdGg6IE1hdGguYWJzKGQpLFxuICAgICAgICAgICAgeDogKDAgPCBkID8gMCA6IGQpICsgYlxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBwICYmIG4gJiYgKGQgPSBrIC0gQywgcC5hdHRyKHtcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5hYnMoZCksXG4gICAgICAgICAgICB5OiAoMCA8IGQgPyAwIDogZCkgKyBDXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIE8gJiYgIXAgJiYgeCAmJiBhLnBhbihjLCBmLnBhbm5pbmcpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5kcmFnU3RhcnQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIGEubW91c2VJc0Rvd24gPSBjLnR5cGU7XG4gICAgICAgIGEuY2FuY2VsQ2xpY2sgPSAhMTtcbiAgICAgICAgYS5tb3VzZURvd25YID0gdGhpcy5tb3VzZURvd25YID0gYy5jaGFydFg7XG4gICAgICAgIGEubW91c2VEb3duWSA9IHRoaXMubW91c2VEb3duWSA9IGMuY2hhcnRZO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUuZHJvcCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIGYgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZSA9IHRoaXMuaGFzUGluY2hlZDtcblxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25NYXJrZXIpIHtcbiAgICAgICAgICB2YXIgZCA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGMsXG4gICAgICAgICAgICB4QXhpczogW10sXG4gICAgICAgICAgICB5QXhpczogW11cbiAgICAgICAgICB9LFxuICAgICAgICAgICAgICBrID0gdGhpcy5zZWxlY3Rpb25NYXJrZXIsXG4gICAgICAgICAgICAgIG4gPSBrLmF0dHIgPyBrLmF0dHIoXCJ4XCIpIDogay54LFxuICAgICAgICAgICAgICBoID0gay5hdHRyID8gay5hdHRyKFwieVwiKSA6IGsueSxcbiAgICAgICAgICAgICAgcSA9IGsuYXR0ciA/IGsuYXR0cihcIndpZHRoXCIpIDogay53aWR0aCxcbiAgICAgICAgICAgICAgZyA9IGsuYXR0ciA/IGsuYXR0cihcImhlaWdodFwiKSA6IGsuaGVpZ2h0LFxuICAgICAgICAgICAgICBLO1xuICAgICAgICAgIGlmICh0aGlzLmhhc0RyYWdnZWQgfHwgZSkgZi5heGVzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIGlmIChmLnpvb21FbmFibGVkICYmIEEoZi5taW4pICYmIChlIHx8IGFbe1xuICAgICAgICAgICAgICB4QXhpczogXCJ6b29tWFwiLFxuICAgICAgICAgICAgICB5QXhpczogXCJ6b29tWVwiXG4gICAgICAgICAgICB9W2YuY29sbF1dKSkge1xuICAgICAgICAgICAgICB2YXIgYiA9IGYuaG9yaXosXG4gICAgICAgICAgICAgICAgICBsID0gXCJ0b3VjaGVuZFwiID09PSBjLnR5cGUgPyBmLm1pblBpeGVsUGFkZGluZyA6IDAsXG4gICAgICAgICAgICAgICAgICBrID0gZi50b1ZhbHVlKChiID8gbiA6IGgpICsgbCk7XG4gICAgICAgICAgICAgIGIgPSBmLnRvVmFsdWUoKGIgPyBuICsgcSA6IGggKyBnKSAtIGwpO1xuICAgICAgICAgICAgICBkW2YuY29sbF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgYXhpczogZixcbiAgICAgICAgICAgICAgICBtaW46IE1hdGgubWluKGssIGIpLFxuICAgICAgICAgICAgICAgIG1heDogTWF0aC5tYXgoaywgYilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIEsgPSAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgSyAmJiB5KGYsIFwic2VsZWN0aW9uXCIsIGQsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBmLnpvb20oRyhhLCBlID8ge1xuICAgICAgICAgICAgICBhbmltYXRpb246ICExXG4gICAgICAgICAgICB9IDogbnVsbCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHQoZi5pbmRleCkgJiYgKHRoaXMuc2VsZWN0aW9uTWFya2VyID0gdGhpcy5zZWxlY3Rpb25NYXJrZXIuZGVzdHJveSgpKTtcbiAgICAgICAgICBlICYmIHRoaXMuc2NhbGVHcm91cHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGYgJiYgdChmLmluZGV4KSAmJiAoRShmLmNvbnRhaW5lciwge1xuICAgICAgICAgIGN1cnNvcjogZi5fY3Vyc29yXG4gICAgICAgIH0pLCBmLmNhbmNlbENsaWNrID0gMTAgPCB0aGlzLmhhc0RyYWdnZWQsIGYubW91c2VJc0Rvd24gPSB0aGlzLmhhc0RyYWdnZWQgPSB0aGlzLmhhc1BpbmNoZWQgPSAhMSwgdGhpcy5waW5jaERvd24gPSBbXSk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5maW5kTmVhcmVzdEtEUG9pbnQgPSBmdW5jdGlvbiAoYywgYSwgZSkge1xuICAgICAgICB2YXIgZiA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBkID0gZi5ob3ZlclBvaW50O1xuICAgICAgICBmID0gZi50b29sdGlwO1xuICAgICAgICBpZiAoZCAmJiBmICYmIGYuaXNTdGlja3lPbkNvbnRhY3QoKSkgcmV0dXJuIGQ7XG4gICAgICAgIHZhciBsO1xuICAgICAgICBjLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICB2YXIgZiA9ICEoYy5ub1NoYXJlZFRvb2x0aXAgJiYgYSkgJiYgMCA+IGMub3B0aW9ucy5maW5kTmVhcmVzdFBvaW50QnkuaW5kZXhPZihcInlcIik7XG4gICAgICAgICAgYyA9IGMuc2VhcmNoUG9pbnQoZSwgZik7XG5cbiAgICAgICAgICBpZiAoKGYgPSBEKGMsICEwKSkgJiYgIShmID0gIUQobCwgITApKSkge1xuICAgICAgICAgICAgZiA9IGwuZGlzdFggLSBjLmRpc3RYO1xuICAgICAgICAgICAgdmFyIGQgPSBsLmRpc3QgLSBjLmRpc3QsXG4gICAgICAgICAgICAgICAgayA9IChjLnNlcmllcy5ncm91cCAmJiBjLnNlcmllcy5ncm91cC56SW5kZXgpIC0gKGwuc2VyaWVzLmdyb3VwICYmIGwuc2VyaWVzLmdyb3VwLnpJbmRleCk7XG4gICAgICAgICAgICBmID0gMCA8ICgwICE9PSBmICYmIGEgPyBmIDogMCAhPT0gZCA/IGQgOiAwICE9PSBrID8gayA6IGwuc2VyaWVzLmluZGV4ID4gYy5zZXJpZXMuaW5kZXggPyAtMSA6IDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGYgJiYgKGwgPSBjKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUuZ2V0Q2hhcnRDb29yZGluYXRlc0Zyb21Qb2ludCA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIHZhciBmID0gYy5zZXJpZXMsXG4gICAgICAgICAgICBlID0gZi54QXhpcztcbiAgICAgICAgZiA9IGYueUF4aXM7XG4gICAgICAgIHZhciBkID0gcShjLmNsaWVudFgsIGMucGxvdFgpLFxuICAgICAgICAgICAgayA9IGMuc2hhcGVBcmdzO1xuICAgICAgICBpZiAoZSAmJiBmKSByZXR1cm4gYSA/IHtcbiAgICAgICAgICBjaGFydFg6IGUubGVuICsgZS5wb3MgLSBkLFxuICAgICAgICAgIGNoYXJ0WTogZi5sZW4gKyBmLnBvcyAtIGMucGxvdFlcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBjaGFydFg6IGQgKyBlLnBvcyxcbiAgICAgICAgICBjaGFydFk6IGMucGxvdFkgKyBmLnBvc1xuICAgICAgICB9O1xuICAgICAgICBpZiAoayAmJiBrLnggJiYgay55KSByZXR1cm4ge1xuICAgICAgICAgIGNoYXJ0WDogay54LFxuICAgICAgICAgIGNoYXJ0WTogay55XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5nZXRDaGFydFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFydFBvc2l0aW9uIHx8ICh0aGlzLmNoYXJ0UG9zaXRpb24gPSBOKHRoaXMuY2hhcnQuY29udGFpbmVyKSk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBhID0ge1xuICAgICAgICAgIHhBeGlzOiBbXSxcbiAgICAgICAgICB5QXhpczogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jaGFydC5heGVzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICBhW2YuaXNYQXhpcyA/IFwieEF4aXNcIiA6IFwieUF4aXNcIl0ucHVzaCh7XG4gICAgICAgICAgICBheGlzOiBmLFxuICAgICAgICAgICAgdmFsdWU6IGYudG9WYWx1ZShjW2YuaG9yaXogPyBcImNoYXJ0WFwiIDogXCJjaGFydFlcIl0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLmdldEhvdmVyRGF0YSA9IGZ1bmN0aW9uIChjLCBhLCBlLCBkLCBrLCBuKSB7XG4gICAgICAgIHZhciBmLFxuICAgICAgICAgICAgbCA9IFtdO1xuICAgICAgICBkID0gISghZCB8fCAhYyk7XG4gICAgICAgIHZhciB2ID0gYSAmJiAhYS5zdGlja3lUcmFja2luZyxcbiAgICAgICAgICAgIGggPSB7XG4gICAgICAgICAgY2hhcnRYOiBuID8gbi5jaGFydFggOiB2b2lkIDAsXG4gICAgICAgICAgY2hhcnRZOiBuID8gbi5jaGFydFkgOiB2b2lkIDAsXG4gICAgICAgICAgc2hhcmVkOiBrXG4gICAgICAgIH07XG4gICAgICAgIHkodGhpcywgXCJiZWZvcmVHZXRIb3ZlckRhdGFcIiwgaCk7XG4gICAgICAgIHYgPSB2ID8gW2FdIDogZS5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICByZXR1cm4gaC5maWx0ZXIgPyBoLmZpbHRlcihhKSA6IGEudmlzaWJsZSAmJiAhKCFrICYmIGEuZGlyZWN0VG91Y2gpICYmIHEoYS5vcHRpb25zLmVuYWJsZU1vdXNlVHJhY2tpbmcsICEwKSAmJiBhLnN0aWNreVRyYWNraW5nO1xuICAgICAgICB9KTtcbiAgICAgICAgYSA9IChmID0gZCB8fCAhbiA/IGMgOiB0aGlzLmZpbmROZWFyZXN0S0RQb2ludCh2LCBrLCBuKSkgJiYgZi5zZXJpZXM7XG4gICAgICAgIGYgJiYgKGsgJiYgIWEubm9TaGFyZWRUb29sdGlwID8gKHYgPSBlLmZpbHRlcihmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHJldHVybiBoLmZpbHRlciA/IGguZmlsdGVyKGEpIDogYS52aXNpYmxlICYmICEoIWsgJiYgYS5kaXJlY3RUb3VjaCkgJiYgcShhLm9wdGlvbnMuZW5hYmxlTW91c2VUcmFja2luZywgITApICYmICFhLm5vU2hhcmVkVG9vbHRpcDtcbiAgICAgICAgfSksIHYuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHZhciBjID0gSihhLnBvaW50cywgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLnggPT09IGYueCAmJiAhYi5pc051bGw7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgRChjKSAmJiAoYS5jaGFydC5pc0Jvb3N0aW5nICYmIChjID0gYS5nZXRQb2ludChjKSksIGwucHVzaChjKSk7XG4gICAgICAgIH0pKSA6IGwucHVzaChmKSk7XG4gICAgICAgIGggPSB7XG4gICAgICAgICAgaG92ZXJQb2ludDogZlxuICAgICAgICB9O1xuICAgICAgICB5KHRoaXMsIFwiYWZ0ZXJHZXRIb3ZlckRhdGFcIiwgaCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaG92ZXJQb2ludDogaC5ob3ZlclBvaW50LFxuICAgICAgICAgIGhvdmVyU2VyaWVzOiBhLFxuICAgICAgICAgIGhvdmVyUG9pbnRzOiBsXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5nZXRQb2ludEZyb21FdmVudCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGMgPSBjLnRhcmdldDtcblxuICAgICAgICBmb3IgKHZhciBhOyBjICYmICFhOykgYSA9IGMucG9pbnQsIGMgPSBjLnBhcmVudE5vZGU7XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5vblRyYWNrZXJNb3VzZU91dCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jaGFydC5ob3ZlclNlcmllcztcbiAgICAgICAgYyA9IGMucmVsYXRlZFRhcmdldCB8fCBjLnRvRWxlbWVudDtcbiAgICAgICAgdGhpcy5pc0RpcmVjdFRvdWNoID0gITE7XG4gICAgICAgIGlmICghKCFhIHx8ICFjIHx8IGEuc3RpY2t5VHJhY2tpbmcgfHwgdGhpcy5pbkNsYXNzKGMsIFwiaGlnaGNoYXJ0cy10b29sdGlwXCIpIHx8IHRoaXMuaW5DbGFzcyhjLCBcImhpZ2hjaGFydHMtc2VyaWVzLVwiICsgYS5pbmRleCkgJiYgdGhpcy5pbkNsYXNzKGMsIFwiaGlnaGNoYXJ0cy10cmFja2VyXCIpKSkgYS5vbk1vdXNlT3V0KCk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5pbkNsYXNzID0gZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgZm9yICh2YXIgZjsgYzspIHtcbiAgICAgICAgICBpZiAoZiA9IE0oYywgXCJjbGFzc1wiKSkge1xuICAgICAgICAgICAgaWYgKC0xICE9PSBmLmluZGV4T2YoYSkpIHJldHVybiAhMDtcbiAgICAgICAgICAgIGlmICgtMSAhPT0gZi5pbmRleE9mKFwiaGlnaGNoYXJ0cy1jb250YWluZXJcIikpIHJldHVybiAhMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjID0gYy5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gYTtcbiAgICAgICAgdGhpcy5jaGFydCA9IGM7XG4gICAgICAgIHRoaXMucnVuQ2hhcnRDbGljayA9IGEuY2hhcnQuZXZlbnRzICYmICEhYS5jaGFydC5ldmVudHMuY2xpY2s7XG4gICAgICAgIHRoaXMucGluY2hEb3duID0gW107XG4gICAgICAgIHRoaXMubGFzdFZhbGlkVG91Y2ggPSB7fTtcbiAgICAgICAgciAmJiAoYy50b29sdGlwID0gbmV3IHIoYywgYS50b29sdGlwKSwgdGhpcy5mb2xsb3dUb3VjaE1vdmUgPSBxKGEudG9vbHRpcC5mb2xsb3dUb3VjaE1vdmUsICEwKSk7XG4gICAgICAgIHRoaXMuc2V0RE9NRXZlbnRzKCk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICB2YXIgZiA9IGMudG91Y2hlcyxcbiAgICAgICAgICAgIGUgPSBmID8gZi5sZW5ndGggPyBmLml0ZW0oMCkgOiBmLmNoYW5nZWRUb3VjaGVzWzBdIDogYztcbiAgICAgICAgYSB8fCAoYSA9IHRoaXMuZ2V0Q2hhcnRQb3NpdGlvbigpKTtcbiAgICAgICAgZiA9IGUucGFnZVggLSBhLmxlZnQ7XG4gICAgICAgIGEgPSBlLnBhZ2VZIC0gYS50b3A7XG4gICAgICAgIGlmIChlID0gdGhpcy5jaGFydC5jb250YWluZXJTY2FsaW5nKSBmIC89IGUuc2NhbGVYLCBhIC89IGUuc2NhbGVZO1xuICAgICAgICByZXR1cm4gRyhjLCB7XG4gICAgICAgICAgY2hhcnRYOiBNYXRoLnJvdW5kKGYpLFxuICAgICAgICAgIGNoYXJ0WTogTWF0aC5yb3VuZChhKVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLm9uQ29udGFpbmVyQ2xpY2sgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBmID0gYS5ob3ZlclBvaW50LFxuICAgICAgICAgICAgZSA9IGEucGxvdExlZnQsXG4gICAgICAgICAgICBkID0gYS5wbG90VG9wO1xuICAgICAgICBjID0gdGhpcy5ub3JtYWxpemUoYyk7XG4gICAgICAgIGEuY2FuY2VsQ2xpY2sgfHwgKGYgJiYgdGhpcy5pbkNsYXNzKGMudGFyZ2V0LCBcImhpZ2hjaGFydHMtdHJhY2tlclwiKSA/ICh5KGYuc2VyaWVzLCBcImNsaWNrXCIsIEcoYywge1xuICAgICAgICAgIHBvaW50OiBmXG4gICAgICAgIH0pKSwgYS5ob3ZlclBvaW50ICYmIGYuZmlyZVBvaW50RXZlbnQoXCJjbGlja1wiLCBjKSkgOiAoRyhjLCB0aGlzLmdldENvb3JkaW5hdGVzKGMpKSwgYS5pc0luc2lkZVBsb3QoYy5jaGFydFggLSBlLCBjLmNoYXJ0WSAtIGQpICYmIHkoYSwgXCJjbGlja1wiLCBjKSkpO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUub25Db250YWluZXJNb3VzZURvd24gPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBjID0gdGhpcy5ub3JtYWxpemUoYyk7XG4gICAgICAgIDIgIT09IGMuYnV0dG9uICYmICh0aGlzLnpvb21PcHRpb24oYyksIGMucHJldmVudERlZmF1bHQgJiYgYy5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLmRyYWdTdGFydChjKSk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5vbkNvbnRhaW5lck1vdXNlTGVhdmUgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICB2YXIgYSA9IGNbZC5ob3ZlckNoYXJ0SW5kZXhdO1xuICAgICAgICBhICYmIChmLnJlbGF0ZWRUYXJnZXQgfHwgZi50b0VsZW1lbnQpICYmIChhLnBvaW50ZXIucmVzZXQoKSwgYS5wb2ludGVyLmNoYXJ0UG9zaXRpb24gPSB2b2lkIDApO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUub25Db250YWluZXJNb3VzZU1vdmUgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIEEoZC5ob3ZlckNoYXJ0SW5kZXgpICYmIGNbZC5ob3ZlckNoYXJ0SW5kZXhdICYmIGNbZC5ob3ZlckNoYXJ0SW5kZXhdLm1vdXNlSXNEb3duIHx8IChkLmhvdmVyQ2hhcnRJbmRleCA9IGEuaW5kZXgpO1xuICAgICAgICBmID0gdGhpcy5ub3JtYWxpemUoZik7XG4gICAgICAgIGYucHJldmVudERlZmF1bHQgfHwgKGYucmV0dXJuVmFsdWUgPSAhMSk7XG4gICAgICAgIFwibW91c2Vkb3duXCIgPT09IGEubW91c2VJc0Rvd24gJiYgdGhpcy5kcmFnKGYpO1xuICAgICAgICBhLm9wZW5NZW51IHx8ICF0aGlzLmluQ2xhc3MoZi50YXJnZXQsIFwiaGlnaGNoYXJ0cy10cmFja2VyXCIpICYmICFhLmlzSW5zaWRlUGxvdChmLmNoYXJ0WCAtIGEucGxvdExlZnQsIGYuY2hhcnRZIC0gYS5wbG90VG9wKSB8fCB0aGlzLnJ1blBvaW50QWN0aW9ucyhmKTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLm9uRG9jdW1lbnRUb3VjaEVuZCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIGNbZC5ob3ZlckNoYXJ0SW5kZXhdICYmIGNbZC5ob3ZlckNoYXJ0SW5kZXhdLnBvaW50ZXIuZHJvcChmKTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLm9uQ29udGFpbmVyVG91Y2hNb3ZlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdGhpcy50b3VjaChjKTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLm9uQ29udGFpbmVyVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHRoaXMuem9vbU9wdGlvbihjKTtcbiAgICAgICAgdGhpcy50b3VjaChjLCAhMCk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5vbkRvY3VtZW50TW91c2VNb3ZlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZiA9IHRoaXMuY2hhcnRQb3NpdGlvbixcbiAgICAgICAgICAgIGUgPSBhLnRvb2x0aXA7XG4gICAgICAgIGMgPSB0aGlzLm5vcm1hbGl6ZShjLCBmKTtcbiAgICAgICAgIWYgfHwgZSAmJiBlLmlzU3RpY2t5T25Db250YWN0KCkgfHwgYS5pc0luc2lkZVBsb3QoYy5jaGFydFggLSBhLnBsb3RMZWZ0LCBjLmNoYXJ0WSAtIGEucGxvdFRvcCkgfHwgdGhpcy5pbkNsYXNzKGMudGFyZ2V0LCBcImhpZ2hjaGFydHMtdHJhY2tlclwiKSB8fCB0aGlzLnJlc2V0KCk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5vbkRvY3VtZW50TW91c2VVcCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIGNbZC5ob3ZlckNoYXJ0SW5kZXhdICYmIGNbZC5ob3ZlckNoYXJ0SW5kZXhdLnBvaW50ZXIuZHJvcChmKTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLnBpbmNoID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgZiA9IGEuY2hhcnQsXG4gICAgICAgICAgICBlID0gYS5waW5jaERvd24sXG4gICAgICAgICAgICBkID0gYy50b3VjaGVzIHx8IFtdLFxuICAgICAgICAgICAgbiA9IGQubGVuZ3RoLFxuICAgICAgICAgICAgaCA9IGEubGFzdFZhbGlkVG91Y2gsXG4gICAgICAgICAgICBnID0gYS5oYXNab29tLFxuICAgICAgICAgICAgdCA9IGEuc2VsZWN0aW9uTWFya2VyLFxuICAgICAgICAgICAgSCA9IHt9LFxuICAgICAgICAgICAgSyA9IDEgPT09IG4gJiYgKGEuaW5DbGFzcyhjLnRhcmdldCwgXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikgJiYgZi5ydW5UcmFja2VyQ2xpY2sgfHwgYS5ydW5DaGFydENsaWNrKSxcbiAgICAgICAgICAgIHAgPSB7fTtcbiAgICAgICAgMSA8IG4gJiYgKGEuaW5pdGlhdGVkID0gITApO1xuICAgICAgICBnICYmIGEuaW5pdGlhdGVkICYmICFLICYmIGMucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgW10ubWFwLmNhbGwoZCwgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICByZXR1cm4gYS5ub3JtYWxpemUoYik7XG4gICAgICAgIH0pO1xuICAgICAgICBcInRvdWNoc3RhcnRcIiA9PT0gYy50eXBlID8gKFtdLmZvckVhY2guY2FsbChkLCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIGVbYV0gPSB7XG4gICAgICAgICAgICBjaGFydFg6IGIuY2hhcnRYLFxuICAgICAgICAgICAgY2hhcnRZOiBiLmNoYXJ0WVxuICAgICAgICAgIH07XG4gICAgICAgIH0pLCBoLnggPSBbZVswXS5jaGFydFgsIGVbMV0gJiYgZVsxXS5jaGFydFhdLCBoLnkgPSBbZVswXS5jaGFydFksIGVbMV0gJiYgZVsxXS5jaGFydFldLCBmLmF4ZXMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGlmIChiLnpvb21FbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGYuYm91bmRzW2IuaG9yaXogPyBcImhcIiA6IFwidlwiXSxcbiAgICAgICAgICAgICAgICBjID0gYi5taW5QaXhlbFBhZGRpbmcsXG4gICAgICAgICAgICAgICAgZSA9IGIudG9QaXhlbHMoTWF0aC5taW4ocShiLm9wdGlvbnMubWluLCBiLmRhdGFNaW4pLCBiLmRhdGFNaW4pKSxcbiAgICAgICAgICAgICAgICBkID0gYi50b1BpeGVscyhNYXRoLm1heChxKGIub3B0aW9ucy5tYXgsIGIuZGF0YU1heCksIGIuZGF0YU1heCkpLFxuICAgICAgICAgICAgICAgIGwgPSBNYXRoLm1heChlLCBkKTtcbiAgICAgICAgICAgIGEubWluID0gTWF0aC5taW4oYi5wb3MsIE1hdGgubWluKGUsIGQpIC0gYyk7XG4gICAgICAgICAgICBhLm1heCA9IE1hdGgubWF4KGIucG9zICsgYi5sZW4sIGwgKyBjKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBhLnJlcyA9ICEwKSA6IGEuZm9sbG93VG91Y2hNb3ZlICYmIDEgPT09IG4gPyB0aGlzLnJ1blBvaW50QWN0aW9ucyhhLm5vcm1hbGl6ZShjKSkgOiBlLmxlbmd0aCAmJiAodCB8fCAoYS5zZWxlY3Rpb25NYXJrZXIgPSB0ID0gRyh7XG4gICAgICAgICAgZGVzdHJveTogayxcbiAgICAgICAgICB0b3VjaDogITBcbiAgICAgICAgfSwgZi5wbG90Qm94KSksIGEucGluY2hUcmFuc2xhdGUoZSwgZCwgSCwgdCwgcCwgaCksIGEuaGFzUGluY2hlZCA9IGcsIGEuc2NhbGVHcm91cHMoSCwgcCksIGEucmVzICYmIChhLnJlcyA9ICExLCB0aGlzLnJlc2V0KCExLCAwKSkpO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUucGluY2hUcmFuc2xhdGUgPSBmdW5jdGlvbiAoYywgYSwgZSwgZCwgaywgbikge1xuICAgICAgICB0aGlzLnpvb21Ib3IgJiYgdGhpcy5waW5jaFRyYW5zbGF0ZURpcmVjdGlvbighMCwgYywgYSwgZSwgZCwgaywgbik7XG4gICAgICAgIHRoaXMuem9vbVZlcnQgJiYgdGhpcy5waW5jaFRyYW5zbGF0ZURpcmVjdGlvbighMSwgYywgYSwgZSwgZCwgaywgbik7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5waW5jaFRyYW5zbGF0ZURpcmVjdGlvbiA9IGZ1bmN0aW9uIChjLCBhLCBlLCBkLCBrLCBuLCBoLCBxKSB7XG4gICAgICAgIHZhciBmID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGwgPSBjID8gXCJ4XCIgOiBcInlcIixcbiAgICAgICAgICAgIHYgPSBjID8gXCJYXCIgOiBcIllcIixcbiAgICAgICAgICAgIHAgPSBcImNoYXJ0XCIgKyB2LFxuICAgICAgICAgICAgYiA9IGMgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiLFxuICAgICAgICAgICAgdyA9IGZbXCJwbG90XCIgKyAoYyA/IFwiTGVmdFwiIDogXCJUb3BcIildLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIEIsXG4gICAgICAgICAgICBnID0gcSB8fCAxLFxuICAgICAgICAgICAgeiA9IGYuaW52ZXJ0ZWQsXG4gICAgICAgICAgICB0ID0gZi5ib3VuZHNbYyA/IFwiaFwiIDogXCJ2XCJdLFxuICAgICAgICAgICAgbSA9IDEgPT09IGEubGVuZ3RoLFxuICAgICAgICAgICAgTCA9IGFbMF1bcF0sXG4gICAgICAgICAgICB5ID0gZVswXVtwXSxcbiAgICAgICAgICAgIHUgPSAhbSAmJiBhWzFdW3BdLFxuICAgICAgICAgICAgRiA9ICFtICYmIGVbMV1bcF07XG5cbiAgICAgICAgZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgRiAmJiAyMCA8IE1hdGguYWJzKEwgLSB1KSAmJiAoZyA9IHEgfHwgTWF0aC5hYnMoeSAtIEYpIC8gTWF0aC5hYnMoTCAtIHUpKTtcbiAgICAgICAgICBCID0gKHcgLSB5KSAvIGcgKyBMO1xuICAgICAgICAgIHggPSBmW1wicGxvdFwiICsgKGMgPyBcIldpZHRoXCIgOiBcIkhlaWdodFwiKV0gLyBnO1xuICAgICAgICB9O1xuXG4gICAgICAgIGUoKTtcbiAgICAgICAgYSA9IEI7XG5cbiAgICAgICAgaWYgKGEgPCB0Lm1pbikge1xuICAgICAgICAgIGEgPSB0Lm1pbjtcbiAgICAgICAgICB2YXIgViA9ICEwO1xuICAgICAgICB9IGVsc2UgYSArIHggPiB0Lm1heCAmJiAoYSA9IHQubWF4IC0geCwgViA9ICEwKTtcblxuICAgICAgICBWID8gKHkgLT0gLjggKiAoeSAtIGhbbF1bMF0pLCBcIm51bWJlclwiID09PSB0eXBlb2YgRiAmJiAoRiAtPSAuOCAqIChGIC0gaFtsXVsxXSkpLCBlKCkpIDogaFtsXSA9IFt5LCBGXTtcbiAgICAgICAgeiB8fCAobltsXSA9IEIgLSB3LCBuW2JdID0geCk7XG4gICAgICAgIG4gPSB6ID8gMSAvIGcgOiBnO1xuICAgICAgICBrW2JdID0geDtcbiAgICAgICAga1tsXSA9IGE7XG4gICAgICAgIGRbeiA/IGMgPyBcInNjYWxlWVwiIDogXCJzY2FsZVhcIiA6IFwic2NhbGVcIiArIHZdID0gZztcbiAgICAgICAgZFtcInRyYW5zbGF0ZVwiICsgdl0gPSBuICogdyArICh5IC0gbiAqIEwpO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICB2YXIgZiA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBlID0gZi5ob3ZlclNlcmllcyxcbiAgICAgICAgICAgIGQgPSBmLmhvdmVyUG9pbnQsXG4gICAgICAgICAgICBrID0gZi5ob3ZlclBvaW50cyxcbiAgICAgICAgICAgIG4gPSBmLnRvb2x0aXAsXG4gICAgICAgICAgICBoID0gbiAmJiBuLnNoYXJlZCA/IGsgOiBkO1xuICAgICAgICBjICYmIGggJiYgUChoKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYS5zZXJpZXMuaXNDYXJ0ZXNpYW4gJiYgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGEucGxvdFggJiYgKGMgPSAhMSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYykgbiAmJiBoICYmIFAoaCkubGVuZ3RoICYmIChuLnJlZnJlc2goaCksIG4uc2hhcmVkICYmIGsgPyBrLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhLnNldFN0YXRlKGEuc3RhdGUsICEwKTtcbiAgICAgICAgICBhLnNlcmllcy5pc0NhcnRlc2lhbiAmJiAoYS5zZXJpZXMueEF4aXMuY3Jvc3NoYWlyICYmIGEuc2VyaWVzLnhBeGlzLmRyYXdDcm9zc2hhaXIobnVsbCwgYSksIGEuc2VyaWVzLnlBeGlzLmNyb3NzaGFpciAmJiBhLnNlcmllcy55QXhpcy5kcmF3Q3Jvc3NoYWlyKG51bGwsIGEpKTtcbiAgICAgICAgfSkgOiBkICYmIChkLnNldFN0YXRlKGQuc3RhdGUsICEwKSwgZi5heGVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhLmNyb3NzaGFpciAmJiBkLnNlcmllc1thLmNvbGxdID09PSBhICYmIGEuZHJhd0Nyb3NzaGFpcihudWxsLCBkKTtcbiAgICAgICAgfSkpKTtlbHNlIHtcbiAgICAgICAgICBpZiAoZCkgZC5vbk1vdXNlT3V0KCk7XG4gICAgICAgICAgayAmJiBrLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGEuc2V0U3RhdGUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoZSkgZS5vbk1vdXNlT3V0KCk7XG4gICAgICAgICAgbiAmJiBuLmhpZGUoYSk7XG4gICAgICAgICAgdGhpcy51bkRvY01vdXNlTW92ZSAmJiAodGhpcy51bkRvY01vdXNlTW92ZSA9IHRoaXMudW5Eb2NNb3VzZU1vdmUoKSk7XG4gICAgICAgICAgZi5heGVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGEuaGlkZUNyb3NzaGFpcigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuaG92ZXJYID0gZi5ob3ZlclBvaW50cyA9IGYuaG92ZXJQb2ludCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLnJ1blBvaW50QWN0aW9ucyA9IGZ1bmN0aW9uIChmLCBhKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGsgPSBlLnRvb2x0aXAgJiYgZS50b29sdGlwLm9wdGlvbnMuZW5hYmxlZCA/IGUudG9vbHRpcCA6IHZvaWQgMCxcbiAgICAgICAgICAgIG4gPSBrID8gay5zaGFyZWQgOiAhMSxcbiAgICAgICAgICAgIGggPSBhIHx8IGUuaG92ZXJQb2ludCxcbiAgICAgICAgICAgIGcgPSBoICYmIGguc2VyaWVzIHx8IGUuaG92ZXJTZXJpZXM7XG4gICAgICAgIGcgPSB0aGlzLmdldEhvdmVyRGF0YShoLCBnLCBlLnNlcmllcywgKCFmIHx8IFwidG91Y2htb3ZlXCIgIT09IGYudHlwZSkgJiYgKCEhYSB8fCBnICYmIGcuZGlyZWN0VG91Y2ggJiYgdGhpcy5pc0RpcmVjdFRvdWNoKSwgbiwgZik7XG4gICAgICAgIGggPSBnLmhvdmVyUG9pbnQ7XG4gICAgICAgIHZhciB0ID0gZy5ob3ZlclBvaW50cztcbiAgICAgICAgYSA9IChnID0gZy5ob3ZlclNlcmllcykgJiYgZy50b29sdGlwT3B0aW9ucy5mb2xsb3dQb2ludGVyO1xuICAgICAgICBuID0gbiAmJiBnICYmICFnLm5vU2hhcmVkVG9vbHRpcDtcblxuICAgICAgICBpZiAoaCAmJiAoaCAhPT0gZS5ob3ZlclBvaW50IHx8IGsgJiYgay5pc0hpZGRlbikpIHtcbiAgICAgICAgICAoZS5ob3ZlclBvaW50cyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgLTEgPT09IHQuaW5kZXhPZihhKSAmJiBhLnNldFN0YXRlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGUuaG92ZXJTZXJpZXMgIT09IGcpIGcub25Nb3VzZU92ZXIoKTtcbiAgICAgICAgICB0aGlzLmFwcGx5SW5hY3RpdmVTdGF0ZSh0KTtcbiAgICAgICAgICAodCB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYS5zZXRTdGF0ZShcImhvdmVyXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGUuaG92ZXJQb2ludCAmJiBlLmhvdmVyUG9pbnQuZmlyZVBvaW50RXZlbnQoXCJtb3VzZU91dFwiKTtcbiAgICAgICAgICBpZiAoIWguc2VyaWVzKSByZXR1cm47XG4gICAgICAgICAgaC5maXJlUG9pbnRFdmVudChcIm1vdXNlT3ZlclwiKTtcbiAgICAgICAgICBlLmhvdmVyUG9pbnRzID0gdDtcbiAgICAgICAgICBlLmhvdmVyUG9pbnQgPSBoO1xuICAgICAgICAgIGsgJiYgay5yZWZyZXNoKG4gPyB0IDogaCwgZik7XG4gICAgICAgIH0gZWxzZSBhICYmIGsgJiYgIWsuaXNIaWRkZW4gJiYgKGggPSBrLmdldEFuY2hvcihbe31dLCBmKSwgay51cGRhdGVQb3NpdGlvbih7XG4gICAgICAgICAgcGxvdFg6IGhbMF0sXG4gICAgICAgICAgcGxvdFk6IGhbMV1cbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHRoaXMudW5Eb2NNb3VzZU1vdmUgfHwgKHRoaXMudW5Eb2NNb3VzZU1vdmUgPSBJKGUuY29udGFpbmVyLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgdmFyIGYgPSBjW2QuaG92ZXJDaGFydEluZGV4XTtcbiAgICAgICAgICBpZiAoZikgZi5wb2ludGVyLm9uRG9jdW1lbnRNb3VzZU1vdmUoYSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgZS5heGVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICB2YXIgYyA9IHEoYS5jcm9zc2hhaXIuc25hcCwgITApLFxuICAgICAgICAgICAgICBlID0gYyA/IEoodCwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiBjLnNlcmllc1thLmNvbGxdID09PSBhO1xuICAgICAgICAgIH0pIDogdm9pZCAwO1xuICAgICAgICAgIGUgfHwgIWMgPyBhLmRyYXdDcm9zc2hhaXIoZiwgZSkgOiBhLmhpZGVDcm9zc2hhaXIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS5zY2FsZUdyb3VwcyA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIHZhciBmID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGU7XG4gICAgICAgIGYuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBlID0gYyB8fCBkLmdldFBsb3RCb3goKTtcbiAgICAgICAgICBkLnhBeGlzICYmIGQueEF4aXMuem9vbUVuYWJsZWQgJiYgZC5ncm91cCAmJiAoZC5ncm91cC5hdHRyKGUpLCBkLm1hcmtlckdyb3VwICYmIChkLm1hcmtlckdyb3VwLmF0dHIoZSksIGQubWFya2VyR3JvdXAuY2xpcChhID8gZi5jbGlwUmVjdCA6IG51bGwpKSwgZC5kYXRhTGFiZWxzR3JvdXAgJiYgZC5kYXRhTGFiZWxzR3JvdXAuYXR0cihlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmLmNsaXBSZWN0LmF0dHIoYSB8fCBmLmNsaXBCb3gpO1xuICAgICAgfTtcblxuICAgICAgbi5wcm90b3R5cGUuc2V0RE9NRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYyA9IHRoaXMsXG4gICAgICAgICAgICBhID0gYy5jaGFydC5jb250YWluZXIsXG4gICAgICAgICAgICBlID0gYS5vd25lckRvY3VtZW50O1xuXG4gICAgICAgIGEub25tb3VzZWRvd24gPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGMub25Db250YWluZXJNb3VzZURvd24oYSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYS5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYy5vbkNvbnRhaW5lck1vdXNlTW92ZShhKTtcbiAgICAgICAgfTtcblxuICAgICAgICBhLm9uY2xpY2sgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGMub25Db250YWluZXJDbGljayhhKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnVuYmluZENvbnRhaW5lck1vdXNlTGVhdmUgPSBJKGEsIFwibW91c2VsZWF2ZVwiLCBjLm9uQ29udGFpbmVyTW91c2VMZWF2ZSk7XG4gICAgICAgIGQudW5iaW5kRG9jdW1lbnRNb3VzZVVwIHx8IChkLnVuYmluZERvY3VtZW50TW91c2VVcCA9IEkoZSwgXCJtb3VzZXVwXCIsIGMub25Eb2N1bWVudE1vdXNlVXApKTtcbiAgICAgICAgZC5oYXNUb3VjaCAmJiAoSShhLCBcInRvdWNoc3RhcnRcIiwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBjLm9uQ29udGFpbmVyVG91Y2hTdGFydChhKTtcbiAgICAgICAgfSksIEkoYSwgXCJ0b3VjaG1vdmVcIiwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBjLm9uQ29udGFpbmVyVG91Y2hNb3ZlKGEpO1xuICAgICAgICB9KSwgZC51bmJpbmREb2N1bWVudFRvdWNoRW5kIHx8IChkLnVuYmluZERvY3VtZW50VG91Y2hFbmQgPSBJKGUsIFwidG91Y2hlbmRcIiwgYy5vbkRvY3VtZW50VG91Y2hFbmQpKSk7XG4gICAgICB9O1xuXG4gICAgICBuLnByb3RvdHlwZS50b3VjaCA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIHZhciBmID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGU7XG4gICAgICAgIGlmIChmLmluZGV4ICE9PSBkLmhvdmVyQ2hhcnRJbmRleCkgdGhpcy5vbkNvbnRhaW5lck1vdXNlTGVhdmUoe1xuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6ICEwXG4gICAgICAgIH0pO1xuICAgICAgICBkLmhvdmVyQ2hhcnRJbmRleCA9IGYuaW5kZXg7XG4gICAgICAgIGlmICgxID09PSBjLnRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGMgPSB0aGlzLm5vcm1hbGl6ZShjKSwgKGUgPSBmLmlzSW5zaWRlUGxvdChjLmNoYXJ0WCAtIGYucGxvdExlZnQsIGMuY2hhcnRZIC0gZi5wbG90VG9wKSkgJiYgIWYub3Blbk1lbnUpIHtcbiAgICAgICAgICAgIGEgJiYgdGhpcy5ydW5Qb2ludEFjdGlvbnMoYyk7XG5cbiAgICAgICAgICAgIGlmIChcInRvdWNobW92ZVwiID09PSBjLnR5cGUpIHtcbiAgICAgICAgICAgICAgYSA9IHRoaXMucGluY2hEb3duO1xuICAgICAgICAgICAgICB2YXIgayA9IGFbMF0gPyA0IDw9IE1hdGguc3FydChNYXRoLnBvdyhhWzBdLmNoYXJ0WCAtIGMuY2hhcnRYLCAyKSArIE1hdGgucG93KGFbMF0uY2hhcnRZIC0gYy5jaGFydFksIDIpKSA6ICExO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBxKGssICEwKSAmJiB0aGlzLnBpbmNoKGMpO1xuICAgICAgICAgIH0gZWxzZSBhICYmIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfSBlbHNlIDIgPT09IGMudG91Y2hlcy5sZW5ndGggJiYgdGhpcy5waW5jaChjKTtcbiAgICAgIH07XG5cbiAgICAgIG4ucHJvdG90eXBlLnpvb21PcHRpb24gPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBmID0gYS5vcHRpb25zLmNoYXJ0LFxuICAgICAgICAgICAgZSA9IGYuem9vbVR5cGUgfHwgXCJcIjtcbiAgICAgICAgYSA9IGEuaW52ZXJ0ZWQ7XG4gICAgICAgIC90b3VjaC8udGVzdChjLnR5cGUpICYmIChlID0gcShmLnBpbmNoVHlwZSwgZSkpO1xuICAgICAgICB0aGlzLnpvb21YID0gYyA9IC94Ly50ZXN0KGUpO1xuICAgICAgICB0aGlzLnpvb21ZID0gZSA9IC95Ly50ZXN0KGUpO1xuICAgICAgICB0aGlzLnpvb21Ib3IgPSBjICYmICFhIHx8IGUgJiYgYTtcbiAgICAgICAgdGhpcy56b29tVmVydCA9IGUgJiYgIWEgfHwgYyAmJiBhO1xuICAgICAgICB0aGlzLmhhc1pvb20gPSBjIHx8IGU7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbjtcbiAgICB9KCk7XG5cbiAgICBkLlBvaW50ZXIgPSBnO1xuICAgIHJldHVybiBkLlBvaW50ZXI7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvTVNQb2ludGVyLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1BvaW50ZXIuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZywgcikge1xuICAgIGZ1bmN0aW9uIHUoKSB7XG4gICAgICB2YXIgZCA9IFtdO1xuXG4gICAgICBkLml0ZW0gPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gdGhpc1tkXTtcbiAgICAgIH07XG5cbiAgICAgIEcoaCwgZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgZC5wdXNoKHtcbiAgICAgICAgICBwYWdlWDogaC5wYWdlWCxcbiAgICAgICAgICBwYWdlWTogaC5wYWdlWSxcbiAgICAgICAgICB0YXJnZXQ6IGgudGFyZ2V0XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJKGgsIGcsIGUsIGMpIHtcbiAgICAgIFwidG91Y2hcIiAhPT0gaC5wb2ludGVyVHlwZSAmJiBoLnBvaW50ZXJUeXBlICE9PSBoLk1TUE9JTlRFUl9UWVBFX1RPVUNIIHx8ICF5W2QuaG92ZXJDaGFydEluZGV4XSB8fCAoYyhoKSwgYyA9IHlbZC5ob3ZlckNoYXJ0SW5kZXhdLnBvaW50ZXIsIGNbZ10oe1xuICAgICAgICB0eXBlOiBlLFxuICAgICAgICB0YXJnZXQ6IGguY3VycmVudFRhcmdldCxcbiAgICAgICAgcHJldmVudERlZmF1bHQ6IEQsXG4gICAgICAgIHRvdWNoZXM6IHUoKVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHZhciBNID0gdGhpcyAmJiB0aGlzLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZCA9IGZ1bmN0aW9uIChoLCBlKSB7XG4gICAgICAgIGQgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgICAgICAgIF9fcHJvdG9fXzogW11cbiAgICAgICAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChjLCBlKSB7XG4gICAgICAgICAgYy5fX3Byb3RvX18gPSBlO1xuICAgICAgICB9IHx8IGZ1bmN0aW9uIChjLCBlKSB7XG4gICAgICAgICAgZm9yICh2YXIgZCBpbiBlKSBlLmhhc093blByb3BlcnR5KGQpICYmIChjW2RdID0gZVtkXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGQoaCwgZSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGgsIGUpIHtcbiAgICAgICAgZnVuY3Rpb24gYygpIHtcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGQoaCwgZSk7XG4gICAgICAgIGgucHJvdG90eXBlID0gbnVsbCA9PT0gZSA/IE9iamVjdC5jcmVhdGUoZSkgOiAoYy5wcm90b3R5cGUgPSBlLnByb3RvdHlwZSwgbmV3IGMoKSk7XG4gICAgICB9O1xuICAgIH0oKSxcbiAgICAgICAgRSA9IHIuYWRkRXZlbnQsXG4gICAgICAgIEEgPSByLmNzcyxcbiAgICAgICAgRyA9IHIub2JqZWN0RWFjaCxcbiAgICAgICAgSiA9IHIucmVtb3ZlRXZlbnQsXG4gICAgICAgIHkgPSBkLmNoYXJ0cyxcbiAgICAgICAgdCA9IGQuZG9jLFxuICAgICAgICBEID0gZC5ub29wLFxuICAgICAgICBoID0ge30sXG4gICAgICAgIE4gPSAhIWQud2luLlBvaW50ZXJFdmVudDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgICAgZnVuY3Rpb24gZygpIHtcbiAgICAgICAgcmV0dXJuIG51bGwgIT09IGQgJiYgZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICB9XG5cbiAgICAgIE0oZywgZCk7XG5cbiAgICAgIGcucHJvdG90eXBlLmJhdGNoTVNFdmVudHMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlKHRoaXMuY2hhcnQuY29udGFpbmVyLCBOID8gXCJwb2ludGVyZG93blwiIDogXCJNU1BvaW50ZXJEb3duXCIsIHRoaXMub25Db250YWluZXJQb2ludGVyRG93bik7XG4gICAgICAgIGUodGhpcy5jaGFydC5jb250YWluZXIsIE4gPyBcInBvaW50ZXJtb3ZlXCIgOiBcIk1TUG9pbnRlck1vdmVcIiwgdGhpcy5vbkNvbnRhaW5lclBvaW50ZXJNb3ZlKTtcbiAgICAgICAgZSh0LCBOID8gXCJwb2ludGVydXBcIiA6IFwiTVNQb2ludGVyVXBcIiwgdGhpcy5vbkRvY3VtZW50UG9pbnRlclVwKTtcbiAgICAgIH07XG5cbiAgICAgIGcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYmF0Y2hNU0V2ZW50cyhKKTtcbiAgICAgICAgZC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgICAgfTtcblxuICAgICAgZy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChlLCBjKSB7XG4gICAgICAgIGQucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBlLCBjKTtcbiAgICAgICAgdGhpcy5oYXNab29tICYmIEEoZS5jb250YWluZXIsIHtcbiAgICAgICAgICBcIi1tcy10b3VjaC1hY3Rpb25cIjogXCJub25lXCIsXG4gICAgICAgICAgXCJ0b3VjaC1hY3Rpb25cIjogXCJub25lXCJcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBnLnByb3RvdHlwZS5vbkNvbnRhaW5lclBvaW50ZXJEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgSShlLCBcIm9uQ29udGFpbmVyVG91Y2hTdGFydFwiLCBcInRvdWNoc3RhcnRcIiwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBoW2MucG9pbnRlcklkXSA9IHtcbiAgICAgICAgICAgIHBhZ2VYOiBjLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGMucGFnZVksXG4gICAgICAgICAgICB0YXJnZXQ6IGMuY3VycmVudFRhcmdldFxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZy5wcm90b3R5cGUub25Db250YWluZXJQb2ludGVyTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIEkoZSwgXCJvbkNvbnRhaW5lclRvdWNoTW92ZVwiLCBcInRvdWNobW92ZVwiLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGhbYy5wb2ludGVySWRdID0ge1xuICAgICAgICAgICAgcGFnZVg6IGMucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogYy5wYWdlWVxuICAgICAgICAgIH07XG4gICAgICAgICAgaFtjLnBvaW50ZXJJZF0udGFyZ2V0IHx8IChoW2MucG9pbnRlcklkXS50YXJnZXQgPSBjLmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGcucHJvdG90eXBlLm9uRG9jdW1lbnRQb2ludGVyVXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBJKGUsIFwib25Eb2N1bWVudFRvdWNoRW5kXCIsIFwidG91Y2hlbmRcIiwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBkZWxldGUgaFtjLnBvaW50ZXJJZF07XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZy5wcm90b3R5cGUuc2V0RE9NRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkLnByb3RvdHlwZS5zZXRET01FdmVudHMuY2FsbCh0aGlzKTtcbiAgICAgICAgKHRoaXMuaGFzWm9vbSB8fCB0aGlzLmZvbGxvd1RvdWNoTW92ZSkgJiYgdGhpcy5iYXRjaE1TRXZlbnRzKEUpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGc7XG4gICAgfShnKTtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9MZWdlbmQuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcpIHtcbiAgICB2YXIgciA9IGcuYWRkRXZlbnQsXG4gICAgICAgIHUgPSBnLmNzcyxcbiAgICAgICAgSSA9IGcuZGVmaW5lZCxcbiAgICAgICAgTSA9IGcuZGlzY2FyZEVsZW1lbnQsXG4gICAgICAgIEUgPSBnLmZpbmQsXG4gICAgICAgIEEgPSBnLmZpcmVFdmVudCxcbiAgICAgICAgRyA9IGcuZm9ybWF0LFxuICAgICAgICBKID0gZy5pc051bWJlcixcbiAgICAgICAgeSA9IGcubWVyZ2UsXG4gICAgICAgIHQgPSBnLnBpY2ssXG4gICAgICAgIEQgPSBnLnJlbGF0aXZlTGVuZ3RoLFxuICAgICAgICBoID0gZy5zZXRBbmltYXRpb24sXG4gICAgICAgIE4gPSBnLnN0YWJsZVNvcnQsXG4gICAgICAgIHEgPSBnLnN5bmNUaW1lb3V0O1xuICAgIGcgPSBnLndyYXA7XG5cbiAgICB2YXIgUCA9IGQuaXNGaXJlZm94LFxuICAgICAgICBlID0gZC5tYXJnaW5OYW1lcyxcbiAgICAgICAgYyA9IGQud2luLFxuICAgICAgICBrID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gYyhjLCBhKSB7XG4gICAgICAgIHRoaXMuYWxsSXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5jb250ZW50R3JvdXAgPSB0aGlzLmJveCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5kaXNwbGF5ID0gITE7XG4gICAgICAgIHRoaXMuZ3JvdXAgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub2Zmc2V0V2lkdGggPSB0aGlzLm1heExlZ2VuZFdpZHRoID0gdGhpcy5tYXhJdGVtV2lkdGggPSB0aGlzLmxlZ2VuZFdpZHRoID0gdGhpcy5sZWdlbmRIZWlnaHQgPSB0aGlzLmxhc3RMaW5lSGVpZ2h0ID0gdGhpcy5sYXN0SXRlbVkgPSB0aGlzLml0ZW1ZID0gdGhpcy5pdGVtWCA9IHRoaXMuaXRlbU1hcmdpblRvcCA9IHRoaXMuaXRlbU1hcmdpbkJvdHRvbSA9IHRoaXMuaXRlbUhlaWdodCA9IHRoaXMuaW5pdGlhbEl0ZW1ZID0gMDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIHRoaXMucGFkZGluZyA9IDA7XG4gICAgICAgIHRoaXMucGFnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5wcm94aW1hdGUgPSAhMTtcbiAgICAgICAgdGhpcy5zY3JvbGxHcm91cCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy53aWR0aE9wdGlvbiA9IHRoaXMudG90YWxJdGVtV2lkdGggPSB0aGlzLnRpdGxlSGVpZ2h0ID0gdGhpcy5zeW1ib2xXaWR0aCA9IHRoaXMuc3ltYm9sSGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5jaGFydCA9IGM7XG4gICAgICAgIHRoaXMuaW5pdChjLCBhKTtcbiAgICAgIH1cblxuICAgICAgYy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIHRoaXMuY2hhcnQgPSBjO1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMoYSk7XG4gICAgICAgIGEuZW5hYmxlZCAmJiAodGhpcy5yZW5kZXIoKSwgcih0aGlzLmNoYXJ0LCBcImVuZFJlc2l6ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5sZWdlbmQucG9zaXRpb25DaGVja2JveGVzKCk7XG4gICAgICAgIH0pLCB0aGlzLnByb3hpbWF0ZSA/IHRoaXMudW5jaGFydHJlbmRlciA9IHIodGhpcy5jaGFydCwgXCJyZW5kZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMubGVnZW5kLnByb3hpbWF0ZVBvc2l0aW9ucygpO1xuICAgICAgICAgIHRoaXMubGVnZW5kLnBvc2l0aW9uSXRlbXMoKTtcbiAgICAgICAgfSkgOiB0aGlzLnVuY2hhcnRyZW5kZXIgJiYgdGhpcy51bmNoYXJ0cmVuZGVyKCkpO1xuICAgICAgfTtcblxuICAgICAgYy5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBhID0gdChjLnBhZGRpbmcsIDgpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBjO1xuICAgICAgICB0aGlzLmNoYXJ0LnN0eWxlZE1vZGUgfHwgKHRoaXMuaXRlbVN0eWxlID0gYy5pdGVtU3R5bGUsIHRoaXMuaXRlbUhpZGRlblN0eWxlID0geSh0aGlzLml0ZW1TdHlsZSwgYy5pdGVtSGlkZGVuU3R5bGUpKTtcbiAgICAgICAgdGhpcy5pdGVtTWFyZ2luVG9wID0gYy5pdGVtTWFyZ2luVG9wIHx8IDA7XG4gICAgICAgIHRoaXMuaXRlbU1hcmdpbkJvdHRvbSA9IGMuaXRlbU1hcmdpbkJvdHRvbSB8fCAwO1xuICAgICAgICB0aGlzLnBhZGRpbmcgPSBhO1xuICAgICAgICB0aGlzLmluaXRpYWxJdGVtWSA9IGEgLSA1O1xuICAgICAgICB0aGlzLnN5bWJvbFdpZHRoID0gdChjLnN5bWJvbFdpZHRoLCAxNik7XG4gICAgICAgIHRoaXMucGFnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5wcm94aW1hdGUgPSBcInByb3hpbWF0ZVwiID09PSBjLmxheW91dCAmJiAhdGhpcy5jaGFydC5pbnZlcnRlZDtcbiAgICAgICAgdGhpcy5iYXNlbGluZSA9IHZvaWQgMDtcbiAgICAgIH07XG5cbiAgICAgIGMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIHZhciBmID0gdGhpcy5jaGFydDtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKHkoITAsIHRoaXMub3B0aW9ucywgYykpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgZi5pc0RpcnR5TGVnZW5kID0gZi5pc0RpcnR5Qm94ID0gITA7XG4gICAgICAgIHQoYSwgITApICYmIGYucmVkcmF3KCk7XG4gICAgICAgIEEodGhpcywgXCJhZnRlclVwZGF0ZVwiKTtcbiAgICAgIH07XG5cbiAgICAgIGMucHJvdG90eXBlLmNvbG9yaXplSXRlbSA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIGMubGVnZW5kR3JvdXBbYSA/IFwicmVtb3ZlQ2xhc3NcIiA6IFwiYWRkQ2xhc3NcIl0oXCJoaWdoY2hhcnRzLWxlZ2VuZC1pdGVtLWhpZGRlblwiKTtcblxuICAgICAgICBpZiAoIXRoaXMuY2hhcnQuc3R5bGVkTW9kZSkge1xuICAgICAgICAgIHZhciBmID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICBlID0gYy5sZWdlbmRJdGVtLFxuICAgICAgICAgICAgICBkID0gYy5sZWdlbmRMaW5lLFxuICAgICAgICAgICAgICBrID0gYy5sZWdlbmRTeW1ib2wsXG4gICAgICAgICAgICAgIGggPSB0aGlzLml0ZW1IaWRkZW5TdHlsZS5jb2xvcjtcbiAgICAgICAgICBmID0gYSA/IGYuaXRlbVN0eWxlLmNvbG9yIDogaDtcbiAgICAgICAgICB2YXIgbiA9IGEgPyBjLmNvbG9yIHx8IGggOiBoLFxuICAgICAgICAgICAgICBnID0gYy5vcHRpb25zICYmIGMub3B0aW9ucy5tYXJrZXIsXG4gICAgICAgICAgICAgIHEgPSB7XG4gICAgICAgICAgICBmaWxsOiBuXG4gICAgICAgICAgfTtcbiAgICAgICAgICBlICYmIGUuY3NzKHtcbiAgICAgICAgICAgIGZpbGw6IGYsXG4gICAgICAgICAgICBjb2xvcjogZlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGQgJiYgZC5hdHRyKHtcbiAgICAgICAgICAgIHN0cm9rZTogblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGsgJiYgKGcgJiYgay5pc01hcmtlciAmJiAocSA9IGMucG9pbnRBdHRyaWJzKCksIGEgfHwgKHEuc3Ryb2tlID0gcS5maWxsID0gaCkpLCBrLmF0dHIocSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgQSh0aGlzLCBcImFmdGVyQ29sb3JpemVJdGVtXCIsIHtcbiAgICAgICAgICBpdGVtOiBjLFxuICAgICAgICAgIHZpc2libGU6IGFcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZS5wb3NpdGlvbkl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFsbEl0ZW1zLmZvckVhY2godGhpcy5wb3NpdGlvbkl0ZW0sIHRoaXMpO1xuICAgICAgICB0aGlzLmNoYXJ0LmlzUmVzaXppbmcgfHwgdGhpcy5wb3NpdGlvbkNoZWNrYm94ZXMoKTtcbiAgICAgIH07XG5cbiAgICAgIGMucHJvdG90eXBlLnBvc2l0aW9uSXRlbSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgZiA9IGEuc3ltYm9sUGFkZGluZztcbiAgICAgICAgYSA9ICFhLnJ0bDtcbiAgICAgICAgdmFyIGUgPSBjLl9sZWdlbmRJdGVtUG9zLFxuICAgICAgICAgICAgZCA9IGVbMF07XG4gICAgICAgIGUgPSBlWzFdO1xuICAgICAgICB2YXIgayA9IGMuY2hlY2tib3g7XG4gICAgICAgIGlmICgoYyA9IGMubGVnZW5kR3JvdXApICYmIGMuZWxlbWVudCkgY1tJKGMudHJhbnNsYXRlWSkgPyBcImFuaW1hdGVcIiA6IFwiYXR0clwiXSh7XG4gICAgICAgICAgdHJhbnNsYXRlWDogYSA/IGQgOiB0aGlzLmxlZ2VuZFdpZHRoIC0gZCAtIDIgKiBmIC0gNCxcbiAgICAgICAgICB0cmFuc2xhdGVZOiBlXG4gICAgICAgIH0pO1xuICAgICAgICBrICYmIChrLnggPSBkLCBrLnkgPSBlKTtcbiAgICAgIH07XG5cbiAgICAgIGMucHJvdG90eXBlLmRlc3Ryb3lJdGVtID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGEgPSBjLmNoZWNrYm94O1xuICAgICAgICBbXCJsZWdlbmRJdGVtXCIsIFwibGVnZW5kTGluZVwiLCBcImxlZ2VuZFN5bWJvbFwiLCBcImxlZ2VuZEdyb3VwXCJdLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBjW2FdICYmIChjW2FdID0gY1thXS5kZXN0cm95KCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgYSAmJiBNKGMuY2hlY2tib3gpO1xuICAgICAgfTtcblxuICAgICAgYy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gYyhhKSB7XG4gICAgICAgICAgdGhpc1thXSAmJiAodGhpc1thXSA9IHRoaXNbYV0uZGVzdHJveSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2V0QWxsSXRlbXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgW1wibGVnZW5kSXRlbVwiLCBcImxlZ2VuZEdyb3VwXCJdLmZvckVhY2goYywgYSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcImNsaXBSZWN0IHVwIGRvd24gcGFnZXIgbmF2IGJveCB0aXRsZSBncm91cFwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGMsIHRoaXMpO1xuICAgICAgICB0aGlzLmRpc3BsYXkgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgYy5wcm90b3R5cGUucG9zaXRpb25DaGVja2JveGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYyA9IHRoaXMuZ3JvdXAgJiYgdGhpcy5ncm91cC5hbGlnbkF0dHIsXG4gICAgICAgICAgICBhID0gdGhpcy5jbGlwSGVpZ2h0IHx8IHRoaXMubGVnZW5kSGVpZ2h0LFxuICAgICAgICAgICAgZSA9IHRoaXMudGl0bGVIZWlnaHQ7XG5cbiAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICB2YXIgZCA9IGMudHJhbnNsYXRlWTtcbiAgICAgICAgICB0aGlzLmFsbEl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIHZhciBrID0gZi5jaGVja2JveDtcblxuICAgICAgICAgICAgaWYgKGspIHtcbiAgICAgICAgICAgICAgdmFyIGwgPSBkICsgZSArIGsueSArICh0aGlzLnNjcm9sbE9mZnNldCB8fCAwKSArIDM7XG4gICAgICAgICAgICAgIHUoaywge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGMudHJhbnNsYXRlWCArIGYuY2hlY2tib3hPZmZzZXQgKyBrLnggLSAyMCArIFwicHhcIixcbiAgICAgICAgICAgICAgICB0b3A6IGwgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgZGlzcGxheTogdGhpcy5wcm94aW1hdGUgfHwgbCA+IGQgLSA2ICYmIGwgPCBkICsgYSAtIDYgPyBcIlwiIDogXCJub25lXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGMucHJvdG90eXBlLnJlbmRlclRpdGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGEgPSB0aGlzLnBhZGRpbmcsXG4gICAgICAgICAgICBlID0gYy50aXRsZSxcbiAgICAgICAgICAgIGQgPSAwO1xuICAgICAgICBlLnRleHQgJiYgKHRoaXMudGl0bGUgfHwgKHRoaXMudGl0bGUgPSB0aGlzLmNoYXJ0LnJlbmRlcmVyLmxhYmVsKGUudGV4dCwgYSAtIDMsIGEgLSA0LCBudWxsLCBudWxsLCBudWxsLCBjLnVzZUhUTUwsIG51bGwsIFwibGVnZW5kLXRpdGxlXCIpLmF0dHIoe1xuICAgICAgICAgIHpJbmRleDogMVxuICAgICAgICB9KSwgdGhpcy5jaGFydC5zdHlsZWRNb2RlIHx8IHRoaXMudGl0bGUuY3NzKGUuc3R5bGUpLCB0aGlzLnRpdGxlLmFkZCh0aGlzLmdyb3VwKSksIGUud2lkdGggfHwgdGhpcy50aXRsZS5jc3Moe1xuICAgICAgICAgIHdpZHRoOiB0aGlzLm1heExlZ2VuZFdpZHRoICsgXCJweFwiXG4gICAgICAgIH0pLCBjID0gdGhpcy50aXRsZS5nZXRCQm94KCksIGQgPSBjLmhlaWdodCwgdGhpcy5vZmZzZXRXaWR0aCA9IGMud2lkdGgsIHRoaXMuY29udGVudEdyb3VwLmF0dHIoe1xuICAgICAgICAgIHRyYW5zbGF0ZVk6IGRcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnRpdGxlSGVpZ2h0ID0gZDtcbiAgICAgIH07XG5cbiAgICAgIGMucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgYSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgYy5sZWdlbmRJdGVtLmF0dHIoe1xuICAgICAgICAgIHRleHQ6IGEubGFiZWxGb3JtYXQgPyBHKGEubGFiZWxGb3JtYXQsIGMsIHRoaXMuY2hhcnQpIDogYS5sYWJlbEZvcm1hdHRlci5jYWxsKGMpXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgYy5wcm90b3R5cGUucmVuZGVySXRlbSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGUgPSBhLnJlbmRlcmVyLFxuICAgICAgICAgICAgZiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGQgPSB0aGlzLnN5bWJvbFdpZHRoLFxuICAgICAgICAgICAgayA9IGYuc3ltYm9sUGFkZGluZyxcbiAgICAgICAgICAgIGggPSB0aGlzLml0ZW1TdHlsZSxcbiAgICAgICAgICAgIG4gPSB0aGlzLml0ZW1IaWRkZW5TdHlsZSxcbiAgICAgICAgICAgIGcgPSBcImhvcml6b250YWxcIiA9PT0gZi5sYXlvdXQgPyB0KGYuaXRlbURpc3RhbmNlLCAyMCkgOiAwLFxuICAgICAgICAgICAgcSA9ICFmLnJ0bCxcbiAgICAgICAgICAgIEsgPSBjLmxlZ2VuZEl0ZW0sXG4gICAgICAgICAgICBwID0gIWMuc2VyaWVzLFxuICAgICAgICAgICAgYiA9ICFwICYmIGMuc2VyaWVzLmRyYXdMZWdlbmRTeW1ib2wgPyBjLnNlcmllcyA6IGMsXG4gICAgICAgICAgICBDID0gYi5vcHRpb25zO1xuICAgICAgICBDID0gdGhpcy5jcmVhdGVDaGVja2JveEZvckl0ZW0gJiYgQyAmJiBDLnNob3dDaGVja2JveDtcbiAgICAgICAgZyA9IGQgKyBrICsgZyArIChDID8gMjAgOiAwKTtcbiAgICAgICAgdmFyIHggPSBmLnVzZUhUTUwsXG4gICAgICAgICAgICBSID0gYy5vcHRpb25zLmNsYXNzTmFtZTtcbiAgICAgICAgSyB8fCAoYy5sZWdlbmRHcm91cCA9IGUuZyhcImxlZ2VuZC1pdGVtXCIpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIiArIGIudHlwZSArIFwiLXNlcmllcyBoaWdoY2hhcnRzLWNvbG9yLVwiICsgYy5jb2xvckluZGV4ICsgKFIgPyBcIiBcIiArIFIgOiBcIlwiKSArIChwID8gXCIgaGlnaGNoYXJ0cy1zZXJpZXMtXCIgKyBjLmluZGV4IDogXCJcIikpLmF0dHIoe1xuICAgICAgICAgIHpJbmRleDogMVxuICAgICAgICB9KS5hZGQodGhpcy5zY3JvbGxHcm91cCksIGMubGVnZW5kSXRlbSA9IEsgPSBlLnRleHQoXCJcIiwgcSA/IGQgKyBrIDogLWssIHRoaXMuYmFzZWxpbmUgfHwgMCwgeCksIGEuc3R5bGVkTW9kZSB8fCBLLmNzcyh5KGMudmlzaWJsZSA/IGggOiBuKSksIEsuYXR0cih7XG4gICAgICAgICAgYWxpZ246IHEgPyBcImxlZnRcIiA6IFwicmlnaHRcIixcbiAgICAgICAgICB6SW5kZXg6IDJcbiAgICAgICAgfSkuYWRkKGMubGVnZW5kR3JvdXApLCB0aGlzLmJhc2VsaW5lIHx8ICh0aGlzLmZvbnRNZXRyaWNzID0gZS5mb250TWV0cmljcyhhLnN0eWxlZE1vZGUgPyAxMiA6IGguZm9udFNpemUsIEspLCB0aGlzLmJhc2VsaW5lID0gdGhpcy5mb250TWV0cmljcy5mICsgMyArIHRoaXMuaXRlbU1hcmdpblRvcCwgSy5hdHRyKFwieVwiLCB0aGlzLmJhc2VsaW5lKSksIHRoaXMuc3ltYm9sSGVpZ2h0ID0gZi5zeW1ib2xIZWlnaHQgfHwgdGhpcy5mb250TWV0cmljcy5mLCBiLmRyYXdMZWdlbmRTeW1ib2wodGhpcywgYyksIHRoaXMuc2V0SXRlbUV2ZW50cyAmJiB0aGlzLnNldEl0ZW1FdmVudHMoYywgSywgeCkpO1xuICAgICAgICBDICYmICFjLmNoZWNrYm94ICYmIHRoaXMuY3JlYXRlQ2hlY2tib3hGb3JJdGVtICYmIHRoaXMuY3JlYXRlQ2hlY2tib3hGb3JJdGVtKGMpO1xuICAgICAgICB0aGlzLmNvbG9yaXplSXRlbShjLCBjLnZpc2libGUpO1xuICAgICAgICAhYS5zdHlsZWRNb2RlICYmIGgud2lkdGggfHwgSy5jc3Moe1xuICAgICAgICAgIHdpZHRoOiAoZi5pdGVtV2lkdGggfHwgdGhpcy53aWR0aE9wdGlvbiB8fCBhLnNwYWNpbmdCb3gud2lkdGgpIC0gZ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRUZXh0KGMpO1xuICAgICAgICBhID0gSy5nZXRCQm94KCk7XG4gICAgICAgIGMuaXRlbVdpZHRoID0gYy5jaGVja2JveE9mZnNldCA9IGYuaXRlbVdpZHRoIHx8IGMubGVnZW5kSXRlbVdpZHRoIHx8IGEud2lkdGggKyBnO1xuICAgICAgICB0aGlzLm1heEl0ZW1XaWR0aCA9IE1hdGgubWF4KHRoaXMubWF4SXRlbVdpZHRoLCBjLml0ZW1XaWR0aCk7XG4gICAgICAgIHRoaXMudG90YWxJdGVtV2lkdGggKz0gYy5pdGVtV2lkdGg7XG4gICAgICAgIHRoaXMuaXRlbUhlaWdodCA9IGMuaXRlbUhlaWdodCA9IE1hdGgucm91bmQoYy5sZWdlbmRJdGVtSGVpZ2h0IHx8IGEuaGVpZ2h0IHx8IHRoaXMuc3ltYm9sSGVpZ2h0KTtcbiAgICAgIH07XG5cbiAgICAgIGMucHJvdG90eXBlLmxheW91dEl0ZW0gPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgYSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGUgPSB0aGlzLnBhZGRpbmcsXG4gICAgICAgICAgICBmID0gXCJob3Jpem9udGFsXCIgPT09IGEubGF5b3V0LFxuICAgICAgICAgICAgZCA9IGMuaXRlbUhlaWdodCxcbiAgICAgICAgICAgIGsgPSB0aGlzLml0ZW1NYXJnaW5Cb3R0b20sXG4gICAgICAgICAgICBoID0gdGhpcy5pdGVtTWFyZ2luVG9wLFxuICAgICAgICAgICAgbiA9IGYgPyB0KGEuaXRlbURpc3RhbmNlLCAyMCkgOiAwLFxuICAgICAgICAgICAgZyA9IHRoaXMubWF4TGVnZW5kV2lkdGg7XG4gICAgICAgIGEgPSBhLmFsaWduQ29sdW1ucyAmJiB0aGlzLnRvdGFsSXRlbVdpZHRoID4gZyA/IHRoaXMubWF4SXRlbVdpZHRoIDogYy5pdGVtV2lkdGg7XG4gICAgICAgIGYgJiYgdGhpcy5pdGVtWCAtIGUgKyBhID4gZyAmJiAodGhpcy5pdGVtWCA9IGUsIHRoaXMubGFzdExpbmVIZWlnaHQgJiYgKHRoaXMuaXRlbVkgKz0gaCArIHRoaXMubGFzdExpbmVIZWlnaHQgKyBrKSwgdGhpcy5sYXN0TGluZUhlaWdodCA9IDApO1xuICAgICAgICB0aGlzLmxhc3RJdGVtWSA9IGggKyB0aGlzLml0ZW1ZICsgaztcbiAgICAgICAgdGhpcy5sYXN0TGluZUhlaWdodCA9IE1hdGgubWF4KGQsIHRoaXMubGFzdExpbmVIZWlnaHQpO1xuICAgICAgICBjLl9sZWdlbmRJdGVtUG9zID0gW3RoaXMuaXRlbVgsIHRoaXMuaXRlbVldO1xuICAgICAgICBmID8gdGhpcy5pdGVtWCArPSBhIDogKHRoaXMuaXRlbVkgKz0gaCArIGQgKyBrLCB0aGlzLmxhc3RMaW5lSGVpZ2h0ID0gZCk7XG4gICAgICAgIHRoaXMub2Zmc2V0V2lkdGggPSB0aGlzLndpZHRoT3B0aW9uIHx8IE1hdGgubWF4KChmID8gdGhpcy5pdGVtWCAtIGUgLSAoYy5jaGVja2JveCA/IDAgOiBuKSA6IGEpICsgZSwgdGhpcy5vZmZzZXRXaWR0aCk7XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZS5nZXRBbGxJdGVtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGMgPSBbXTtcbiAgICAgICAgdGhpcy5jaGFydC5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHZhciBlID0gYSAmJiBhLm9wdGlvbnM7XG4gICAgICAgICAgYSAmJiB0KGUuc2hvd0luTGVnZW5kLCBJKGUubGlua2VkVG8pID8gITEgOiB2b2lkIDAsICEwKSAmJiAoYyA9IGMuY29uY2F0KGEubGVnZW5kSXRlbXMgfHwgKFwicG9pbnRcIiA9PT0gZS5sZWdlbmRUeXBlID8gYS5kYXRhIDogYSkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIEEodGhpcywgXCJhZnRlckdldEFsbEl0ZW1zXCIsIHtcbiAgICAgICAgICBhbGxJdGVtczogY1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZS5nZXRBbGlnbm1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5vcHRpb25zO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm94aW1hdGUgPyBjLmFsaWduLmNoYXJBdCgwKSArIFwidHZcIiA6IGMuZmxvYXRpbmcgPyBcIlwiIDogYy5hbGlnbi5jaGFyQXQoMCkgKyBjLnZlcnRpY2FsQWxpZ24uY2hhckF0KDApICsgYy5sYXlvdXQuY2hhckF0KDApO1xuICAgICAgfTtcblxuICAgICAgYy5wcm90b3R5cGUuYWRqdXN0TWFyZ2lucyA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIHZhciBmID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGQgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBrID0gdGhpcy5nZXRBbGlnbm1lbnQoKTtcbiAgICAgICAgayAmJiBbLyhsdGh8Y3R8cnRoKS8sIC8ocnR2fHJtfHJidikvLCAvKHJiaHxjYnxsYmgpLywgLyhsYnZ8bG18bHR2KS9dLmZvckVhY2goZnVuY3Rpb24gKGwsIGgpIHtcbiAgICAgICAgICBsLnRlc3QoaykgJiYgIUkoY1toXSkgJiYgKGZbZVtoXV0gPSBNYXRoLm1heChmW2VbaF1dLCBmLmxlZ2VuZFsoaCArIDEpICUgMiA/IFwibGVnZW5kSGVpZ2h0XCIgOiBcImxlZ2VuZFdpZHRoXCJdICsgWzEsIC0xLCAtMSwgMV1baF0gKiBkW2ggJSAyID8gXCJ4XCIgOiBcInlcIl0gKyB0KGQubWFyZ2luLCAxMikgKyBhW2hdICsgKGYudGl0bGVPZmZzZXRbaF0gfHwgMCkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZS5wcm94aW1hdGVQb3NpdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGEgPSBbXSxcbiAgICAgICAgICAgIGUgPSBcImxlZnRcIiA9PT0gdGhpcy5vcHRpb25zLmFsaWduO1xuICAgICAgICB0aGlzLmFsbEl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICB2YXIgZCA9IGU7XG5cbiAgICAgICAgICBpZiAoZi55QXhpcyAmJiBmLnBvaW50cykge1xuICAgICAgICAgICAgZi54QXhpcy5vcHRpb25zLnJldmVyc2VkICYmIChkID0gIWQpO1xuICAgICAgICAgICAgdmFyIGsgPSBFKGQgPyBmLnBvaW50cyA6IGYucG9pbnRzLnNsaWNlKDApLnJldmVyc2UoKSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEooYS5wbG90WSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGQgPSB0aGlzLml0ZW1NYXJnaW5Ub3AgKyBmLmxlZ2VuZEl0ZW0uZ2V0QkJveCgpLmhlaWdodCArIHRoaXMuaXRlbU1hcmdpbkJvdHRvbTtcbiAgICAgICAgICAgIHZhciBsID0gZi55QXhpcy50b3AgLSBjLnBsb3RUb3A7XG4gICAgICAgICAgICBmLnZpc2libGUgPyAoayA9IGsgPyBrLnBsb3RZIDogZi55QXhpcy5oZWlnaHQsIGsgKz0gbCAtIC4zICogZCkgOiBrID0gbCArIGYueUF4aXMuaGVpZ2h0O1xuICAgICAgICAgICAgYS5wdXNoKHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBrLFxuICAgICAgICAgICAgICBzaXplOiBkLFxuICAgICAgICAgICAgICBpdGVtOiBmXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBkLmRpc3RyaWJ1dGUoYSwgYy5wbG90SGVpZ2h0KTtcbiAgICAgICAgYS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYS5pdGVtLl9sZWdlbmRJdGVtUG9zWzFdID0gYy5wbG90VG9wIC0gYy5zcGFjaW5nWzBdICsgYS5wb3M7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgYy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYyA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBhID0gYy5yZW5kZXJlcixcbiAgICAgICAgICAgIGUgPSB0aGlzLmdyb3VwLFxuICAgICAgICAgICAgZCxcbiAgICAgICAgICAgIGsgPSB0aGlzLmJveCxcbiAgICAgICAgICAgIGggPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBuID0gdGhpcy5wYWRkaW5nO1xuICAgICAgICB0aGlzLml0ZW1YID0gbjtcbiAgICAgICAgdGhpcy5pdGVtWSA9IHRoaXMuaW5pdGlhbEl0ZW1ZO1xuICAgICAgICB0aGlzLmxhc3RJdGVtWSA9IHRoaXMub2Zmc2V0V2lkdGggPSAwO1xuICAgICAgICB0aGlzLndpZHRoT3B0aW9uID0gRChoLndpZHRoLCBjLnNwYWNpbmdCb3gud2lkdGggLSBuKTtcbiAgICAgICAgdmFyIGcgPSBjLnNwYWNpbmdCb3gud2lkdGggLSAyICogbiAtIGgueDtcbiAgICAgICAgLTEgPCBbXCJybVwiLCBcImxtXCJdLmluZGV4T2YodGhpcy5nZXRBbGlnbm1lbnQoKS5zdWJzdHJpbmcoMCwgMikpICYmIChnIC89IDIpO1xuICAgICAgICB0aGlzLm1heExlZ2VuZFdpZHRoID0gdGhpcy53aWR0aE9wdGlvbiB8fCBnO1xuICAgICAgICBlIHx8ICh0aGlzLmdyb3VwID0gZSA9IGEuZyhcImxlZ2VuZFwiKS5hdHRyKHtcbiAgICAgICAgICB6SW5kZXg6IDdcbiAgICAgICAgfSkuYWRkKCksIHRoaXMuY29udGVudEdyb3VwID0gYS5nKCkuYXR0cih7XG4gICAgICAgICAgekluZGV4OiAxXG4gICAgICAgIH0pLmFkZChlKSwgdGhpcy5zY3JvbGxHcm91cCA9IGEuZygpLmFkZCh0aGlzLmNvbnRlbnRHcm91cCkpO1xuICAgICAgICB0aGlzLnJlbmRlclRpdGxlKCk7XG4gICAgICAgIGcgPSB0aGlzLmdldEFsbEl0ZW1zKCk7XG4gICAgICAgIE4oZywgZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgICByZXR1cm4gKGEub3B0aW9ucyAmJiBhLm9wdGlvbnMubGVnZW5kSW5kZXggfHwgMCkgLSAoYy5vcHRpb25zICYmIGMub3B0aW9ucy5sZWdlbmRJbmRleCB8fCAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGgucmV2ZXJzZWQgJiYgZy5yZXZlcnNlKCk7XG4gICAgICAgIHRoaXMuYWxsSXRlbXMgPSBnO1xuICAgICAgICB0aGlzLmRpc3BsYXkgPSBkID0gISFnLmxlbmd0aDtcbiAgICAgICAgdGhpcy5pdGVtSGVpZ2h0ID0gdGhpcy50b3RhbEl0ZW1XaWR0aCA9IHRoaXMubWF4SXRlbVdpZHRoID0gdGhpcy5sYXN0TGluZUhlaWdodCA9IDA7XG4gICAgICAgIGcuZm9yRWFjaCh0aGlzLnJlbmRlckl0ZW0sIHRoaXMpO1xuICAgICAgICBnLmZvckVhY2godGhpcy5sYXlvdXRJdGVtLCB0aGlzKTtcbiAgICAgICAgZyA9ICh0aGlzLndpZHRoT3B0aW9uIHx8IHRoaXMub2Zmc2V0V2lkdGgpICsgbjtcbiAgICAgICAgdmFyIHEgPSB0aGlzLmxhc3RJdGVtWSArIHRoaXMubGFzdExpbmVIZWlnaHQgKyB0aGlzLnRpdGxlSGVpZ2h0O1xuICAgICAgICBxID0gdGhpcy5oYW5kbGVPdmVyZmxvdyhxKTtcbiAgICAgICAgcSArPSBuO1xuICAgICAgICBrIHx8ICh0aGlzLmJveCA9IGsgPSBhLnJlY3QoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtbGVnZW5kLWJveFwiKS5hdHRyKHtcbiAgICAgICAgICByOiBoLmJvcmRlclJhZGl1c1xuICAgICAgICB9KS5hZGQoZSksIGsuaXNOZXcgPSAhMCk7XG4gICAgICAgIGMuc3R5bGVkTW9kZSB8fCBrLmF0dHIoe1xuICAgICAgICAgIHN0cm9rZTogaC5ib3JkZXJDb2xvcixcbiAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBoLmJvcmRlcldpZHRoIHx8IDAsXG4gICAgICAgICAgZmlsbDogaC5iYWNrZ3JvdW5kQ29sb3IgfHwgXCJub25lXCJcbiAgICAgICAgfSkuc2hhZG93KGguc2hhZG93KTtcbiAgICAgICAgMCA8IGcgJiYgMCA8IHEgJiYgKGtbay5pc05ldyA/IFwiYXR0clwiIDogXCJhbmltYXRlXCJdKGsuY3Jpc3AuY2FsbCh7fSwge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3aWR0aDogZyxcbiAgICAgICAgICBoZWlnaHQ6IHFcbiAgICAgICAgfSwgay5zdHJva2VXaWR0aCgpKSksIGsuaXNOZXcgPSAhMSk7XG4gICAgICAgIGtbZCA/IFwic2hvd1wiIDogXCJoaWRlXCJdKCk7XG4gICAgICAgIGMuc3R5bGVkTW9kZSAmJiBcIm5vbmVcIiA9PT0gZS5nZXRTdHlsZShcImRpc3BsYXlcIikgJiYgKGcgPSBxID0gMCk7XG4gICAgICAgIHRoaXMubGVnZW5kV2lkdGggPSBnO1xuICAgICAgICB0aGlzLmxlZ2VuZEhlaWdodCA9IHE7XG4gICAgICAgIGQgJiYgKGEgPSBjLnNwYWNpbmdCb3gsIGsgPSBhLnksIC8obHRofGN0fHJ0aCkvLnRlc3QodGhpcy5nZXRBbGlnbm1lbnQoKSkgJiYgMCA8IGMudGl0bGVPZmZzZXRbMF0gPyBrICs9IGMudGl0bGVPZmZzZXRbMF0gOiAvKGxiaHxjYnxyYmgpLy50ZXN0KHRoaXMuZ2V0QWxpZ25tZW50KCkpICYmIDAgPCBjLnRpdGxlT2Zmc2V0WzJdICYmIChrIC09IGMudGl0bGVPZmZzZXRbMl0pLCBrICE9PSBhLnkgJiYgKGEgPSB5KGEsIHtcbiAgICAgICAgICB5OiBrXG4gICAgICAgIH0pKSwgZS5hbGlnbih5KGgsIHtcbiAgICAgICAgICB3aWR0aDogZyxcbiAgICAgICAgICBoZWlnaHQ6IHEsXG4gICAgICAgICAgdmVydGljYWxBbGlnbjogdGhpcy5wcm94aW1hdGUgPyBcInRvcFwiIDogaC52ZXJ0aWNhbEFsaWduXG4gICAgICAgIH0pLCAhMCwgYSkpO1xuICAgICAgICB0aGlzLnByb3hpbWF0ZSB8fCB0aGlzLnBvc2l0aW9uSXRlbXMoKTtcbiAgICAgICAgQSh0aGlzLCBcImFmdGVyUmVuZGVyXCIpO1xuICAgICAgfTtcblxuICAgICAgYy5wcm90b3R5cGUuaGFuZGxlT3ZlcmZsb3cgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICBlID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGYgPSBlLnJlbmRlcmVyLFxuICAgICAgICAgICAgZCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGsgPSBkLnksXG4gICAgICAgICAgICBoID0gdGhpcy5wYWRkaW5nO1xuICAgICAgICBrID0gZS5zcGFjaW5nQm94LmhlaWdodCArIChcInRvcFwiID09PSBkLnZlcnRpY2FsQWxpZ24gPyAtayA6IGspIC0gaDtcblxuICAgICAgICB2YXIgbiA9IGQubWF4SGVpZ2h0LFxuICAgICAgICAgICAgZyxcbiAgICAgICAgICAgIHEgPSB0aGlzLmNsaXBSZWN0LFxuICAgICAgICAgICAgeSA9IGQubmF2aWdhdGlvbixcbiAgICAgICAgICAgIHAgPSB0KHkuYW5pbWF0aW9uLCAhMCksXG4gICAgICAgICAgICBiID0geS5hcnJvd1NpemUgfHwgMTIsXG4gICAgICAgICAgICBDID0gdGhpcy5uYXYsXG4gICAgICAgICAgICB4ID0gdGhpcy5wYWdlcyxcbiAgICAgICAgICAgIFIsXG4gICAgICAgICAgICBPID0gdGhpcy5hbGxJdGVtcyxcbiAgICAgICAgICAgIHUgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBiID8gcS5hdHRyKHtcbiAgICAgICAgICAgIGhlaWdodDogYlxuICAgICAgICAgIH0pIDogcSAmJiAoYS5jbGlwUmVjdCA9IHEuZGVzdHJveSgpLCBhLmNvbnRlbnRHcm91cC5jbGlwKCkpO1xuICAgICAgICAgIGEuY29udGVudEdyb3VwLmRpdiAmJiAoYS5jb250ZW50R3JvdXAuZGl2LnN0eWxlLmNsaXAgPSBiID8gXCJyZWN0KFwiICsgaCArIFwicHgsOTk5OXB4LFwiICsgKGggKyBiKSArIFwicHgsMClcIiA6IFwiYXV0b1wiKTtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIEQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGFbY10gPSBmLmNpcmNsZSgwLCAwLCAxLjMgKiBiKS50cmFuc2xhdGUoYiAvIDIsIGIgLyAyKS5hZGQoQyk7XG4gICAgICAgICAgZS5zdHlsZWRNb2RlIHx8IGFbY10uYXR0cihcImZpbGxcIiwgXCJyZ2JhKDAsMCwwLDAuMDAwMSlcIik7XG4gICAgICAgICAgcmV0dXJuIGFbY107XG4gICAgICAgIH07XG5cbiAgICAgICAgXCJob3Jpem9udGFsXCIgIT09IGQubGF5b3V0IHx8IFwibWlkZGxlXCIgPT09IGQudmVydGljYWxBbGlnbiB8fCBkLmZsb2F0aW5nIHx8IChrIC89IDIpO1xuICAgICAgICBuICYmIChrID0gTWF0aC5taW4oaywgbikpO1xuICAgICAgICB4Lmxlbmd0aCA9IDA7XG4gICAgICAgIGMgPiBrICYmICExICE9PSB5LmVuYWJsZWQgPyAodGhpcy5jbGlwSGVpZ2h0ID0gZyA9IE1hdGgubWF4KGsgLSAyMCAtIHRoaXMudGl0bGVIZWlnaHQgLSBoLCAwKSwgdGhpcy5jdXJyZW50UGFnZSA9IHQodGhpcy5jdXJyZW50UGFnZSwgMSksIHRoaXMuZnVsbEhlaWdodCA9IGMsIE8uZm9yRWFjaChmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIHZhciBjID0gYi5fbGVnZW5kSXRlbVBvc1sxXSxcbiAgICAgICAgICAgICAgZSA9IE1hdGgucm91bmQoYi5sZWdlbmRJdGVtLmdldEJCb3goKS5oZWlnaHQpLFxuICAgICAgICAgICAgICBmID0geC5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFmIHx8IGMgLSB4W2YgLSAxXSA+IGcgJiYgKFIgfHwgYykgIT09IHhbZiAtIDFdKSB4LnB1c2goUiB8fCBjKSwgZisrO1xuICAgICAgICAgIGIucGFnZUl4ID0gZiAtIDE7XG4gICAgICAgICAgUiAmJiAoT1thIC0gMV0ucGFnZUl4ID0gZiAtIDEpO1xuICAgICAgICAgIGEgPT09IE8ubGVuZ3RoIC0gMSAmJiBjICsgZSAtIHhbZiAtIDFdID4gZyAmJiBjICE9PSBSICYmICh4LnB1c2goYyksIGIucGFnZUl4ID0gZik7XG4gICAgICAgICAgYyAhPT0gUiAmJiAoUiA9IGMpO1xuICAgICAgICB9KSwgcSB8fCAocSA9IGEuY2xpcFJlY3QgPSBmLmNsaXBSZWN0KDAsIGgsIDk5OTksIDApLCBhLmNvbnRlbnRHcm91cC5jbGlwKHEpKSwgdShnKSwgQyB8fCAodGhpcy5uYXYgPSBDID0gZi5nKCkuYXR0cih7XG4gICAgICAgICAgekluZGV4OiAxXG4gICAgICAgIH0pLmFkZCh0aGlzLmdyb3VwKSwgdGhpcy51cCA9IGYuc3ltYm9sKFwidHJpYW5nbGVcIiwgMCwgMCwgYiwgYikuYWRkKEMpLCBEKFwidXBUcmFja2VyXCIpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGEuc2Nyb2xsKC0xLCBwKTtcbiAgICAgICAgfSksIHRoaXMucGFnZXIgPSBmLnRleHQoXCJcIiwgMTUsIDEwKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtbGVnZW5kLW5hdmlnYXRpb25cIiksIGUuc3R5bGVkTW9kZSB8fCB0aGlzLnBhZ2VyLmNzcyh5LnN0eWxlKSwgdGhpcy5wYWdlci5hZGQoQyksIHRoaXMuZG93biA9IGYuc3ltYm9sKFwidHJpYW5nbGUtZG93blwiLCAwLCAwLCBiLCBiKS5hZGQoQyksIEQoXCJkb3duVHJhY2tlclwiKS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhLnNjcm9sbCgxLCBwKTtcbiAgICAgICAgfSkpLCBhLnNjcm9sbCgwKSwgYyA9IGspIDogQyAmJiAodSgpLCB0aGlzLm5hdiA9IEMuZGVzdHJveSgpLCB0aGlzLnNjcm9sbEdyb3VwLmF0dHIoe1xuICAgICAgICAgIHRyYW5zbGF0ZVk6IDFcbiAgICAgICAgfSksIHRoaXMuY2xpcEhlaWdodCA9IDApO1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH07XG5cbiAgICAgIGMucHJvdG90eXBlLnNjcm9sbCA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgICAgIGYgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgayA9IHRoaXMucGFnZXMsXG4gICAgICAgICAgICBuID0gay5sZW5ndGgsXG4gICAgICAgICAgICBnID0gdGhpcy5jdXJyZW50UGFnZSArIGM7XG4gICAgICAgIGMgPSB0aGlzLmNsaXBIZWlnaHQ7XG4gICAgICAgIHZhciB5ID0gdGhpcy5vcHRpb25zLm5hdmlnYXRpb24sXG4gICAgICAgICAgICB1ID0gdGhpcy5wYWdlcixcbiAgICAgICAgICAgIEggPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgIGcgPiBuICYmIChnID0gbik7XG4gICAgICAgIDAgPCBnICYmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYSAmJiBoKGEsIGYpLCB0aGlzLm5hdi5hdHRyKHtcbiAgICAgICAgICB0cmFuc2xhdGVYOiBILFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IGMgKyB0aGlzLnBhZGRpbmcgKyA3ICsgdGhpcy50aXRsZUhlaWdodCxcbiAgICAgICAgICB2aXNpYmlsaXR5OiBcInZpc2libGVcIlxuICAgICAgICB9KSwgW3RoaXMudXAsIHRoaXMudXBUcmFja2VyXS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYS5hdHRyKHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogMSA9PT0gZyA/IFwiaGlnaGNoYXJ0cy1sZWdlbmQtbmF2LWluYWN0aXZlXCIgOiBcImhpZ2hjaGFydHMtbGVnZW5kLW5hdi1hY3RpdmVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9KSwgdS5hdHRyKHtcbiAgICAgICAgICB0ZXh0OiBnICsgXCIvXCIgKyBuXG4gICAgICAgIH0pLCBbdGhpcy5kb3duLCB0aGlzLmRvd25UcmFja2VyXS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYS5hdHRyKHtcbiAgICAgICAgICAgIHg6IDE4ICsgdGhpcy5wYWdlci5nZXRCQm94KCkud2lkdGgsXG4gICAgICAgICAgICBcImNsYXNzXCI6IGcgPT09IG4gPyBcImhpZ2hjaGFydHMtbGVnZW5kLW5hdi1pbmFjdGl2ZVwiIDogXCJoaWdoY2hhcnRzLWxlZ2VuZC1uYXYtYWN0aXZlXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdGhpcyksIGYuc3R5bGVkTW9kZSB8fCAodGhpcy51cC5hdHRyKHtcbiAgICAgICAgICBmaWxsOiAxID09PSBnID8geS5pbmFjdGl2ZUNvbG9yIDogeS5hY3RpdmVDb2xvclxuICAgICAgICB9KSwgdGhpcy51cFRyYWNrZXIuY3NzKHtcbiAgICAgICAgICBjdXJzb3I6IDEgPT09IGcgPyBcImRlZmF1bHRcIiA6IFwicG9pbnRlclwiXG4gICAgICAgIH0pLCB0aGlzLmRvd24uYXR0cih7XG4gICAgICAgICAgZmlsbDogZyA9PT0gbiA/IHkuaW5hY3RpdmVDb2xvciA6IHkuYWN0aXZlQ29sb3JcbiAgICAgICAgfSksIHRoaXMuZG93blRyYWNrZXIuY3NzKHtcbiAgICAgICAgICBjdXJzb3I6IGcgPT09IG4gPyBcImRlZmF1bHRcIiA6IFwicG9pbnRlclwiXG4gICAgICAgIH0pKSwgdGhpcy5zY3JvbGxPZmZzZXQgPSAta1tnIC0gMV0gKyB0aGlzLmluaXRpYWxJdGVtWSwgdGhpcy5zY3JvbGxHcm91cC5hbmltYXRlKHtcbiAgICAgICAgICB0cmFuc2xhdGVZOiB0aGlzLnNjcm9sbE9mZnNldFxuICAgICAgICB9KSwgdGhpcy5jdXJyZW50UGFnZSA9IGcsIHRoaXMucG9zaXRpb25DaGVja2JveGVzKCksIGEgPSBkLmFuaW1PYmplY3QodChhLCBmLnJlbmRlcmVyLmdsb2JhbEFuaW1hdGlvbiwgITApKSwgcShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgQShlLCBcImFmdGVyU2Nyb2xsXCIsIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlOiBnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGEuZHVyYXRpb24gfHwgMCkpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGM7XG4gICAgfSgpO1xuXG4gICAgKC9UcmlkZW50XFwvN1xcLjAvLnRlc3QoYy5uYXZpZ2F0b3IgJiYgYy5uYXZpZ2F0b3IudXNlckFnZW50KSB8fCBQKSAmJiBnKGsucHJvdG90eXBlLCBcInBvc2l0aW9uSXRlbVwiLCBmdW5jdGlvbiAoYywgZSkge1xuICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGUuX2xlZ2VuZEl0ZW1Qb3MgJiYgYy5jYWxsKGEsIGUpO1xuICAgICAgfTtcblxuICAgICAgZigpO1xuICAgICAgYS5idWJibGVMZWdlbmQgfHwgc2V0VGltZW91dChmKTtcbiAgICB9KTtcbiAgICBkLkxlZ2VuZCA9IGs7XG4gICAgcmV0dXJuIGQuTGVnZW5kO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL0NoYXJ0LmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL0xlZ2VuZC5qc1wiXSwgcltcInBhcnRzL01TUG9pbnRlci5qc1wiXSwgcltcInBhcnRzL1BvaW50ZXIuanNcIl0sIHJbXCJwYXJ0cy9UaW1lLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcsIHIsIHUsIEksIE0pIHtcbiAgICB2YXIgRSA9IE0uYWRkRXZlbnQsXG4gICAgICAgIEEgPSBNLmFuaW1hdGUsXG4gICAgICAgIEcgPSBNLmFuaW1PYmplY3QsXG4gICAgICAgIEogPSBNLmF0dHIsXG4gICAgICAgIHkgPSBNLmNyZWF0ZUVsZW1lbnQsXG4gICAgICAgIHQgPSBNLmNzcyxcbiAgICAgICAgRCA9IE0uZGVmaW5lZCxcbiAgICAgICAgaCA9IE0uZGlzY2FyZEVsZW1lbnQsXG4gICAgICAgIE4gPSBNLmVyYXNlLFxuICAgICAgICBxID0gTS5lcnJvcixcbiAgICAgICAgUCA9IE0uZXh0ZW5kLFxuICAgICAgICBlID0gTS5maW5kLFxuICAgICAgICBjID0gTS5maXJlRXZlbnQsXG4gICAgICAgIGsgPSBNLmdldFN0eWxlLFxuICAgICAgICBuID0gTS5pc0FycmF5LFxuICAgICAgICBmID0gTS5pc0Z1bmN0aW9uLFxuICAgICAgICBhID0gTS5pc051bWJlcixcbiAgICAgICAgbCA9IE0uaXNPYmplY3QsXG4gICAgICAgIHYgPSBNLmlzU3RyaW5nLFxuICAgICAgICB6ID0gTS5tZXJnZSxcbiAgICAgICAgdyA9IE0ubnVtYmVyRm9ybWF0LFxuICAgICAgICBCID0gTS5vYmplY3RFYWNoLFxuICAgICAgICBMID0gTS5waWNrLFxuICAgICAgICBRID0gTS5wSW50LFxuICAgICAgICBIID0gTS5yZWxhdGl2ZUxlbmd0aCxcbiAgICAgICAgSyA9IE0ucmVtb3ZlRXZlbnQsXG4gICAgICAgIHAgPSBNLnNldEFuaW1hdGlvbixcbiAgICAgICAgYiA9IE0uc3BsYXQsXG4gICAgICAgIEMgPSBNLnN5bmNUaW1lb3V0LFxuICAgICAgICB4ID0gTS51bmlxdWVLZXksXG4gICAgICAgIFIgPSBkLmRvYyxcbiAgICAgICAgTyA9IGQuQXhpcyxcbiAgICAgICAgWCA9IGQuZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgIFUgPSBkLmNoYXJ0cyxcbiAgICAgICAgbSA9IGQubWFyZ2luTmFtZXMsXG4gICAgICAgIFQgPSBkLnNlcmllc1R5cGVzLFxuICAgICAgICBaID0gZC53aW4sXG4gICAgICAgIGNhID0gZC5DaGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZ2V0QXJncy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBkLmNoYXJ0ID0gZnVuY3Rpb24gKGIsIGEsIGMpIHtcbiAgICAgIHJldHVybiBuZXcgY2EoYiwgYSwgYyk7XG4gICAgfTtcblxuICAgIFAoY2EucHJvdG90eXBlLCB7XG4gICAgICBjYWxsYmFja3M6IFtdLFxuICAgICAgZ2V0QXJnczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHYoYlswXSkgfHwgYlswXS5ub2RlTmFtZSkgdGhpcy5yZW5kZXJUbyA9IGIuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5pbml0KGJbMF0sIGJbMV0pO1xuICAgICAgfSxcbiAgICAgIGluaXQ6IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIHZhciBlLFxuICAgICAgICAgICAgayA9IGIuc2VyaWVzLFxuICAgICAgICAgICAgaCA9IGIucGxvdE9wdGlvbnMgfHwge307XG4gICAgICAgIGModGhpcywgXCJpbml0XCIsIHtcbiAgICAgICAgICBhcmdzOiBhcmd1bWVudHNcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGIuc2VyaWVzID0gbnVsbDtcbiAgICAgICAgICBlID0geihYLCBiKTtcbiAgICAgICAgICBCKGUucGxvdE9wdGlvbnMsIGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgICAgICBsKGIpICYmIChiLnRvb2x0aXAgPSBoW2FdICYmIHooaFthXS50b29sdGlwKSB8fCB2b2lkIDApO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGUudG9vbHRpcC51c2VyT3B0aW9ucyA9IGIuY2hhcnQgJiYgYi5jaGFydC5mb3JFeHBvcnQgJiYgYi50b29sdGlwLnVzZXJPcHRpb25zIHx8IGIudG9vbHRpcDtcbiAgICAgICAgICBlLnNlcmllcyA9IGIuc2VyaWVzID0gaztcbiAgICAgICAgICB0aGlzLnVzZXJPcHRpb25zID0gYjtcbiAgICAgICAgICB2YXIgbSA9IGUuY2hhcnQsXG4gICAgICAgICAgICAgIG4gPSBtLmV2ZW50cztcbiAgICAgICAgICB0aGlzLm1hcmdpbiA9IFtdO1xuICAgICAgICAgIHRoaXMuc3BhY2luZyA9IFtdO1xuICAgICAgICAgIHRoaXMuYm91bmRzID0ge1xuICAgICAgICAgICAgaDoge30sXG4gICAgICAgICAgICB2OiB7fVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5sYWJlbENvbGxlY3RvcnMgPSBbXTtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gYTtcbiAgICAgICAgICB0aGlzLmlzUmVzaXppbmcgPSAwO1xuICAgICAgICAgIHRoaXMub3B0aW9ucyA9IGU7XG4gICAgICAgICAgdGhpcy5heGVzID0gW107XG4gICAgICAgICAgdGhpcy5zZXJpZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLnRpbWUgPSBiLnRpbWUgJiYgT2JqZWN0LmtleXMoYi50aW1lKS5sZW5ndGggPyBuZXcgSShiLnRpbWUpIDogZC50aW1lO1xuICAgICAgICAgIHRoaXMubnVtYmVyRm9ybWF0dGVyID0gbS5udW1iZXJGb3JtYXR0ZXIgfHwgdztcbiAgICAgICAgICB0aGlzLnN0eWxlZE1vZGUgPSBtLnN0eWxlZE1vZGU7XG4gICAgICAgICAgdGhpcy5oYXNDYXJ0ZXNpYW5TZXJpZXMgPSBtLnNob3dBeGVzO1xuICAgICAgICAgIHZhciBwID0gdGhpcztcbiAgICAgICAgICBwLmluZGV4ID0gVS5sZW5ndGg7XG4gICAgICAgICAgVS5wdXNoKHApO1xuICAgICAgICAgIGQuY2hhcnRDb3VudCsrO1xuICAgICAgICAgIG4gJiYgQihuLCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgICAgZihiKSAmJiBFKHAsIGEsIGIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHAueEF4aXMgPSBbXTtcbiAgICAgICAgICBwLnlBeGlzID0gW107XG4gICAgICAgICAgcC5wb2ludENvdW50ID0gcC5jb2xvckNvdW50ZXIgPSBwLnN5bWJvbENvdW50ZXIgPSAwO1xuICAgICAgICAgIGMocCwgXCJhZnRlckluaXRcIik7XG4gICAgICAgICAgcC5maXJzdFJlbmRlcigpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBpbml0U2VyaWVzOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXMub3B0aW9ucy5jaGFydDtcbiAgICAgICAgYSA9IGIudHlwZSB8fCBhLnR5cGUgfHwgYS5kZWZhdWx0U2VyaWVzVHlwZTtcbiAgICAgICAgdmFyIGMgPSBUW2FdO1xuICAgICAgICBjIHx8IHEoMTcsICEwLCB0aGlzLCB7XG4gICAgICAgICAgbWlzc2luZ01vZHVsZUZvcjogYVxuICAgICAgICB9KTtcbiAgICAgICAgYSA9IG5ldyBjKCk7XG4gICAgICAgIGEuaW5pdCh0aGlzLCBiKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9LFxuICAgICAgc2V0U2VyaWVzRGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdldFNlcmllc09yZGVyQnlMaW5rcygpLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBiLnBvaW50cyB8fCBiLmRhdGEgfHwgIWIuZW5hYmxlZERhdGFTb3J0aW5nIHx8IGIuc2V0RGF0YShiLm9wdGlvbnMuZGF0YSwgITEpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZXRTZXJpZXNPcmRlckJ5TGlua3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWVzLmNvbmNhdCgpLnNvcnQoZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICByZXR1cm4gYi5saW5rZWRTZXJpZXMubGVuZ3RoIHx8IGEubGlua2VkU2VyaWVzLmxlbmd0aCA/IGEubGlua2VkU2VyaWVzLmxlbmd0aCAtIGIubGlua2VkU2VyaWVzLmxlbmd0aCA6IDA7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9yZGVyU2VyaWVzOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuc2VyaWVzO1xuXG4gICAgICAgIGZvciAoYiA9IGIgfHwgMDsgYiA8IGEubGVuZ3RoOyBiKyspIGFbYl0gJiYgKGFbYl0uaW5kZXggPSBiLCBhW2JdLm5hbWUgPSBhW2JdLmdldE5hbWUoKSk7XG4gICAgICB9LFxuICAgICAgaXNJbnNpZGVQbG90OiBmdW5jdGlvbiAoYiwgYSwgZSkge1xuICAgICAgICB2YXIgZiA9IGUgPyBhIDogYjtcbiAgICAgICAgYiA9IGUgPyBiIDogYTtcbiAgICAgICAgZiA9IHtcbiAgICAgICAgICB4OiBmLFxuICAgICAgICAgIHk6IGIsXG4gICAgICAgICAgaXNJbnNpZGVQbG90OiAwIDw9IGYgJiYgZiA8PSB0aGlzLnBsb3RXaWR0aCAmJiAwIDw9IGIgJiYgYiA8PSB0aGlzLnBsb3RIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgYyh0aGlzLCBcImFmdGVySXNJbnNpZGVQbG90XCIsIGYpO1xuICAgICAgICByZXR1cm4gZi5pc0luc2lkZVBsb3Q7XG4gICAgICB9LFxuICAgICAgcmVkcmF3OiBmdW5jdGlvbiAoYikge1xuICAgICAgICBjKHRoaXMsIFwiYmVmb3JlUmVkcmF3XCIpO1xuICAgICAgICB2YXIgYSA9IHRoaXMuYXhlcyxcbiAgICAgICAgICAgIGUgPSB0aGlzLnNlcmllcyxcbiAgICAgICAgICAgIGYgPSB0aGlzLnBvaW50ZXIsXG4gICAgICAgICAgICBkID0gdGhpcy5sZWdlbmQsXG4gICAgICAgICAgICBrID0gdGhpcy51c2VyT3B0aW9ucy5sZWdlbmQsXG4gICAgICAgICAgICBsID0gdGhpcy5pc0RpcnR5TGVnZW5kLFxuICAgICAgICAgICAgaCA9IHRoaXMuaGFzQ2FydGVzaWFuU2VyaWVzLFxuICAgICAgICAgICAgbSA9IHRoaXMuaXNEaXJ0eUJveCxcbiAgICAgICAgICAgIG4gPSB0aGlzLnJlbmRlcmVyLFxuICAgICAgICAgICAgeCA9IG4uaXNIaWRkZW4oKSxcbiAgICAgICAgICAgIGcgPSBbXTtcbiAgICAgICAgdGhpcy5zZXRSZXNwb25zaXZlICYmIHRoaXMuc2V0UmVzcG9uc2l2ZSghMSk7XG4gICAgICAgIHAodGhpcy5oYXNSZW5kZXJlZCA/IGIgOiAhMSwgdGhpcyk7XG4gICAgICAgIHggJiYgdGhpcy50ZW1wb3JhcnlEaXNwbGF5KCk7XG4gICAgICAgIHRoaXMubGF5T3V0VGl0bGVzKCk7XG5cbiAgICAgICAgZm9yIChiID0gZS5sZW5ndGg7IGItLTspIHtcbiAgICAgICAgICB2YXIgdyA9IGVbYl07XG5cbiAgICAgICAgICBpZiAody5vcHRpb25zLnN0YWNraW5nKSB7XG4gICAgICAgICAgICB2YXIgQyA9ICEwO1xuXG4gICAgICAgICAgICBpZiAody5pc0RpcnR5KSB7XG4gICAgICAgICAgICAgIHZhciB2ID0gITA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2KSBmb3IgKGIgPSBlLmxlbmd0aDsgYi0tOykgdyA9IGVbYl0sIHcub3B0aW9ucy5zdGFja2luZyAmJiAody5pc0RpcnR5ID0gITApO1xuICAgICAgICBlLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBiLmlzRGlydHkgJiYgKFwicG9pbnRcIiA9PT0gYi5vcHRpb25zLmxlZ2VuZFR5cGUgPyAoYi51cGRhdGVUb3RhbHMgJiYgYi51cGRhdGVUb3RhbHMoKSwgbCA9ICEwKSA6IGsgJiYgKGsubGFiZWxGb3JtYXR0ZXIgfHwgay5sYWJlbEZvcm1hdCkgJiYgKGwgPSAhMCkpO1xuICAgICAgICAgIGIuaXNEaXJ0eURhdGEgJiYgYyhiLCBcInVwZGF0ZWREYXRhXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgbCAmJiBkICYmIGQub3B0aW9ucy5lbmFibGVkICYmIChkLnJlbmRlcigpLCB0aGlzLmlzRGlydHlMZWdlbmQgPSAhMSk7XG4gICAgICAgIEMgJiYgdGhpcy5nZXRTdGFja3MoKTtcbiAgICAgICAgaCAmJiBhLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBiLnVwZGF0ZU5hbWVzKCk7XG4gICAgICAgICAgYi5zZXRTY2FsZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nZXRNYXJnaW5zKCk7XG4gICAgICAgIGggJiYgKGEuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGIuaXNEaXJ0eSAmJiAobSA9ICEwKTtcbiAgICAgICAgfSksIGEuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHZhciBhID0gYi5taW4gKyBcIixcIiArIGIubWF4O1xuICAgICAgICAgIGIuZXh0S2V5ICE9PSBhICYmIChiLmV4dEtleSA9IGEsIGcucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjKGIsIFwiYWZ0ZXJTZXRFeHRyZW1lc1wiLCBQKGIuZXZlbnRBcmdzLCBiLmdldEV4dHJlbWVzKCkpKTtcbiAgICAgICAgICAgIGRlbGV0ZSBiLmV2ZW50QXJncztcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgKG0gfHwgQykgJiYgYi5yZWRyYXcoKTtcbiAgICAgICAgfSkpO1xuICAgICAgICBtICYmIHRoaXMuZHJhd0NoYXJ0Qm94KCk7XG4gICAgICAgIGModGhpcywgXCJwcmVkcmF3XCIpO1xuICAgICAgICBlLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAobSB8fCBiLmlzRGlydHkpICYmIGIudmlzaWJsZSAmJiBiLnJlZHJhdygpO1xuICAgICAgICAgIGIuaXNEaXJ0eURhdGEgPSAhMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGYgJiYgZi5yZXNldCghMCk7XG4gICAgICAgIG4uZHJhdygpO1xuICAgICAgICBjKHRoaXMsIFwicmVkcmF3XCIpO1xuICAgICAgICBjKHRoaXMsIFwicmVuZGVyXCIpO1xuICAgICAgICB4ICYmIHRoaXMudGVtcG9yYXJ5RGlzcGxheSghMCk7XG4gICAgICAgIGcuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGIuY2FsbCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIGZ1bmN0aW9uIGEoYSkge1xuICAgICAgICAgIHJldHVybiBhLmlkID09PSBiIHx8IGEub3B0aW9ucyAmJiBhLm9wdGlvbnMuaWQgPT09IGI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHRoaXMuc2VyaWVzLFxuICAgICAgICAgICAgZjtcbiAgICAgICAgdmFyIGQgPSBlKHRoaXMuYXhlcywgYSkgfHwgZSh0aGlzLnNlcmllcywgYSk7XG5cbiAgICAgICAgZm9yIChmID0gMDsgIWQgJiYgZiA8IGMubGVuZ3RoOyBmKyspIGQgPSBlKGNbZl0ucG9pbnRzIHx8IFtdLCBhKTtcblxuICAgICAgICByZXR1cm4gZDtcbiAgICAgIH0sXG4gICAgICBnZXRBeGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIGUgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBmID0gZS54QXhpcyA9IGIoZS54QXhpcyB8fCB7fSk7XG4gICAgICAgIGUgPSBlLnlBeGlzID0gYihlLnlBeGlzIHx8IHt9KTtcbiAgICAgICAgYyh0aGlzLCBcImdldEF4ZXNcIik7XG4gICAgICAgIGYuZm9yRWFjaChmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIGIuaW5kZXggPSBhO1xuICAgICAgICAgIGIuaXNYID0gITA7XG4gICAgICAgIH0pO1xuICAgICAgICBlLmZvckVhY2goZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBiLmluZGV4ID0gYTtcbiAgICAgICAgfSk7XG4gICAgICAgIGYuY29uY2F0KGUpLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBuZXcgTyhhLCBiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGModGhpcywgXCJhZnRlckdldEF4ZXNcIik7XG4gICAgICB9LFxuICAgICAgZ2V0U2VsZWN0ZWRQb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSBbXTtcbiAgICAgICAgdGhpcy5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGIgPSBiLmNvbmNhdChhLmdldFBvaW50c0NvbGxlY3Rpb24oKS5maWx0ZXIoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIHJldHVybiBMKGIuc2VsZWN0ZWRTdGFnaW5nLCBiLnNlbGVjdGVkKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0sXG4gICAgICBnZXRTZWxlY3RlZFNlcmllczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJpZXMuZmlsdGVyKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgcmV0dXJuIGIuc2VsZWN0ZWQ7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHNldFRpdGxlOiBmdW5jdGlvbiAoYiwgYSwgYykge1xuICAgICAgICB0aGlzLmFwcGx5RGVzY3JpcHRpb24oXCJ0aXRsZVwiLCBiKTtcbiAgICAgICAgdGhpcy5hcHBseURlc2NyaXB0aW9uKFwic3VidGl0bGVcIiwgYSk7XG4gICAgICAgIHRoaXMuYXBwbHlEZXNjcmlwdGlvbihcImNhcHRpb25cIiwgdm9pZCAwKTtcbiAgICAgICAgdGhpcy5sYXlPdXRUaXRsZXMoYyk7XG4gICAgICB9LFxuICAgICAgYXBwbHlEZXNjcmlwdGlvbjogZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLFxuICAgICAgICAgICAgZSA9IFwidGl0bGVcIiA9PT0gYiA/IHtcbiAgICAgICAgICBjb2xvcjogXCIjMzMzMzMzXCIsXG4gICAgICAgICAgZm9udFNpemU6IHRoaXMub3B0aW9ucy5pc1N0b2NrID8gXCIxNnB4XCIgOiBcIjE4cHhcIlxuICAgICAgICB9IDoge1xuICAgICAgICAgIGNvbG9yOiBcIiM2NjY2NjZcIlxuICAgICAgICB9O1xuICAgICAgICBlID0gdGhpcy5vcHRpb25zW2JdID0geighdGhpcy5zdHlsZWRNb2RlICYmIHtcbiAgICAgICAgICBzdHlsZTogZVxuICAgICAgICB9LCB0aGlzLm9wdGlvbnNbYl0sIGEpO1xuICAgICAgICB2YXIgZiA9IHRoaXNbYl07XG4gICAgICAgIGYgJiYgYSAmJiAodGhpc1tiXSA9IGYgPSBmLmRlc3Ryb3koKSk7XG4gICAgICAgIGUgJiYgIWYgJiYgKGYgPSB0aGlzLnJlbmRlcmVyLnRleHQoZS50ZXh0LCAwLCAwLCBlLnVzZUhUTUwpLmF0dHIoe1xuICAgICAgICAgIGFsaWduOiBlLmFsaWduLFxuICAgICAgICAgIFwiY2xhc3NcIjogXCJoaWdoY2hhcnRzLVwiICsgYixcbiAgICAgICAgICB6SW5kZXg6IGUuekluZGV4IHx8IDRcbiAgICAgICAgfSkuYWRkKCksIGYudXBkYXRlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBjW3tcbiAgICAgICAgICAgIHRpdGxlOiBcInNldFRpdGxlXCIsXG4gICAgICAgICAgICBzdWJ0aXRsZTogXCJzZXRTdWJ0aXRsZVwiLFxuICAgICAgICAgICAgY2FwdGlvbjogXCJzZXRDYXB0aW9uXCJcbiAgICAgICAgICB9W2JdXShhKTtcbiAgICAgICAgfSwgdGhpcy5zdHlsZWRNb2RlIHx8IGYuY3NzKGUuc3R5bGUpLCB0aGlzW2JdID0gZik7XG4gICAgICB9LFxuICAgICAgbGF5T3V0VGl0bGVzOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IFswLCAwLCAwXSxcbiAgICAgICAgICAgIGUgPSB0aGlzLnJlbmRlcmVyLFxuICAgICAgICAgICAgZiA9IHRoaXMuc3BhY2luZ0JveDtcbiAgICAgICAgW1widGl0bGVcIiwgXCJzdWJ0aXRsZVwiLCBcImNhcHRpb25cIl0uZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHZhciBjID0gdGhpc1tiXSxcbiAgICAgICAgICAgICAgZCA9IHRoaXMub3B0aW9uc1tiXSxcbiAgICAgICAgICAgICAgayA9IGQudmVydGljYWxBbGlnbiB8fCBcInRvcFwiO1xuICAgICAgICAgIGIgPSBcInRpdGxlXCIgPT09IGIgPyAtMyA6IFwidG9wXCIgPT09IGsgPyBhWzBdICsgMiA6IDA7XG5cbiAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0eWxlZE1vZGUpIHZhciBsID0gZC5zdHlsZS5mb250U2l6ZTtcbiAgICAgICAgICAgIGwgPSBlLmZvbnRNZXRyaWNzKGwsIGMpLmI7XG4gICAgICAgICAgICBjLmNzcyh7XG4gICAgICAgICAgICAgIHdpZHRoOiAoZC53aWR0aCB8fCBmLndpZHRoICsgKGQud2lkdGhBZGp1c3QgfHwgMCkpICsgXCJweFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBoID0gTWF0aC5yb3VuZChjLmdldEJCb3goZC51c2VIVE1MKS5oZWlnaHQpO1xuICAgICAgICAgICAgYy5hbGlnbihQKHtcbiAgICAgICAgICAgICAgeTogXCJib3R0b21cIiA9PT0gayA/IGwgOiBiICsgbCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBoXG4gICAgICAgICAgICB9LCBkKSwgITEsIFwic3BhY2luZ0JveFwiKTtcbiAgICAgICAgICAgIGQuZmxvYXRpbmcgfHwgKFwidG9wXCIgPT09IGsgPyBhWzBdID0gTWF0aC5jZWlsKGFbMF0gKyBoKSA6IFwiYm90dG9tXCIgPT09IGsgJiYgKGFbMl0gPSBNYXRoLmNlaWwoYVsyXSArIGgpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgYVswXSAmJiBcInRvcFwiID09PSAodGhpcy5vcHRpb25zLnRpdGxlLnZlcnRpY2FsQWxpZ24gfHwgXCJ0b3BcIikgJiYgKGFbMF0gKz0gdGhpcy5vcHRpb25zLnRpdGxlLm1hcmdpbik7XG4gICAgICAgIGFbMl0gJiYgXCJib3R0b21cIiA9PT0gdGhpcy5vcHRpb25zLmNhcHRpb24udmVydGljYWxBbGlnbiAmJiAoYVsyXSArPSB0aGlzLm9wdGlvbnMuY2FwdGlvbi5tYXJnaW4pO1xuICAgICAgICB2YXIgZCA9ICF0aGlzLnRpdGxlT2Zmc2V0IHx8IHRoaXMudGl0bGVPZmZzZXQuam9pbihcIixcIikgIT09IGEuam9pbihcIixcIik7XG4gICAgICAgIHRoaXMudGl0bGVPZmZzZXQgPSBhO1xuICAgICAgICBjKHRoaXMsIFwiYWZ0ZXJMYXlPdXRUaXRsZXNcIik7XG4gICAgICAgICF0aGlzLmlzRGlydHlCb3ggJiYgZCAmJiAodGhpcy5pc0RpcnR5Qm94ID0gdGhpcy5pc0RpcnR5TGVnZW5kID0gZCwgdGhpcy5oYXNSZW5kZXJlZCAmJiBMKGIsICEwKSAmJiB0aGlzLmlzRGlydHlCb3ggJiYgdGhpcy5yZWRyYXcoKSk7XG4gICAgICB9LFxuICAgICAgZ2V0Q2hhcnRTaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5vcHRpb25zLmNoYXJ0LFxuICAgICAgICAgICAgYSA9IGIud2lkdGg7XG4gICAgICAgIGIgPSBiLmhlaWdodDtcbiAgICAgICAgdmFyIGMgPSB0aGlzLnJlbmRlclRvO1xuICAgICAgICBEKGEpIHx8ICh0aGlzLmNvbnRhaW5lcldpZHRoID0gayhjLCBcIndpZHRoXCIpKTtcbiAgICAgICAgRChiKSB8fCAodGhpcy5jb250YWluZXJIZWlnaHQgPSBrKGMsIFwiaGVpZ2h0XCIpKTtcbiAgICAgICAgdGhpcy5jaGFydFdpZHRoID0gTWF0aC5tYXgoMCwgYSB8fCB0aGlzLmNvbnRhaW5lcldpZHRoIHx8IDYwMCk7XG4gICAgICAgIHRoaXMuY2hhcnRIZWlnaHQgPSBNYXRoLm1heCgwLCBIKGIsIHRoaXMuY2hhcnRXaWR0aCkgfHwgKDEgPCB0aGlzLmNvbnRhaW5lckhlaWdodCA/IHRoaXMuY29udGFpbmVySGVpZ2h0IDogNDAwKSk7XG4gICAgICB9LFxuICAgICAgdGVtcG9yYXJ5RGlzcGxheTogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLnJlbmRlclRvO1xuICAgICAgICBpZiAoYikgZm9yICg7IGEgJiYgYS5zdHlsZTspIGEuaGNPcmlnU3R5bGUgJiYgKHQoYSwgYS5oY09yaWdTdHlsZSksIGRlbGV0ZSBhLmhjT3JpZ1N0eWxlKSwgYS5oY09yaWdEZXRhY2hlZCAmJiAoUi5ib2R5LnJlbW92ZUNoaWxkKGEpLCBhLmhjT3JpZ0RldGFjaGVkID0gITEpLCBhID0gYS5wYXJlbnROb2RlO2Vsc2UgZm9yICg7IGEgJiYgYS5zdHlsZTspIHtcbiAgICAgICAgICBSLmJvZHkuY29udGFpbnMoYSkgfHwgYS5wYXJlbnROb2RlIHx8IChhLmhjT3JpZ0RldGFjaGVkID0gITAsIFIuYm9keS5hcHBlbmRDaGlsZChhKSk7XG4gICAgICAgICAgaWYgKFwibm9uZVwiID09PSBrKGEsIFwiZGlzcGxheVwiLCAhMSkgfHwgYS5oY09yaWNEZXRhY2hlZCkgYS5oY09yaWdTdHlsZSA9IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGEuc3R5bGUuZGlzcGxheSxcbiAgICAgICAgICAgIGhlaWdodDogYS5zdHlsZS5oZWlnaHQsXG4gICAgICAgICAgICBvdmVyZmxvdzogYS5zdHlsZS5vdmVyZmxvd1xuICAgICAgICAgIH0sIGIgPSB7XG4gICAgICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIlxuICAgICAgICAgIH0sIGEgIT09IHRoaXMucmVuZGVyVG8gJiYgKGIuaGVpZ2h0ID0gMCksIHQoYSwgYiksIGEub2Zmc2V0V2lkdGggfHwgYS5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIiwgXCJibG9ja1wiLCBcImltcG9ydGFudFwiKTtcbiAgICAgICAgICBhID0gYS5wYXJlbnROb2RlO1xuICAgICAgICAgIGlmIChhID09PSBSLmJvZHkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0Q2xhc3NOYW1lOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcImhpZ2hjaGFydHMtY29udGFpbmVyIFwiICsgKGIgfHwgXCJcIik7XG4gICAgICB9LFxuICAgICAgZ2V0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgZSA9IGIuY2hhcnQ7XG4gICAgICAgIHZhciBmID0gdGhpcy5yZW5kZXJUbztcbiAgICAgICAgdmFyIGsgPSB4KCksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgaDtcbiAgICAgICAgZiB8fCAodGhpcy5yZW5kZXJUbyA9IGYgPSBlLnJlbmRlclRvKTtcbiAgICAgICAgdihmKSAmJiAodGhpcy5yZW5kZXJUbyA9IGYgPSBSLmdldEVsZW1lbnRCeUlkKGYpKTtcbiAgICAgICAgZiB8fCBxKDEzLCAhMCwgdGhpcyk7XG4gICAgICAgIHZhciBtID0gUShKKGYsIFwiZGF0YS1oaWdoY2hhcnRzLWNoYXJ0XCIpKTtcbiAgICAgICAgYShtKSAmJiBVW21dICYmIFVbbV0uaGFzUmVuZGVyZWQgJiYgVVttXS5kZXN0cm95KCk7XG4gICAgICAgIEooZiwgXCJkYXRhLWhpZ2hjaGFydHMtY2hhcnRcIiwgdGhpcy5pbmRleCk7XG4gICAgICAgIGYuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgZS5za2lwQ2xvbmUgfHwgZi5vZmZzZXRXaWR0aCB8fCB0aGlzLnRlbXBvcmFyeURpc3BsYXkoKTtcbiAgICAgICAgdGhpcy5nZXRDaGFydFNpemUoKTtcbiAgICAgICAgbSA9IHRoaXMuY2hhcnRXaWR0aDtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmNoYXJ0SGVpZ2h0O1xuICAgICAgICB0KGYsIHtcbiAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHlsZWRNb2RlIHx8IChsID0gUCh7XG4gICAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgICB3aWR0aDogbSArIFwicHhcIixcbiAgICAgICAgICBoZWlnaHQ6IG4gKyBcInB4XCIsXG4gICAgICAgICAgdGV4dEFsaWduOiBcImxlZnRcIixcbiAgICAgICAgICBsaW5lSGVpZ2h0OiBcIm5vcm1hbFwiLFxuICAgICAgICAgIHpJbmRleDogMCxcbiAgICAgICAgICBcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiOiBcInJnYmEoMCwwLDAsMClcIlxuICAgICAgICB9LCBlLnN0eWxlKSk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gZiA9IHkoXCJkaXZcIiwge1xuICAgICAgICAgIGlkOiBrXG4gICAgICAgIH0sIGwsIGYpO1xuICAgICAgICB0aGlzLl9jdXJzb3IgPSBmLnN0eWxlLmN1cnNvcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyAoZFtlLnJlbmRlcmVyXSB8fCBkLlJlbmRlcmVyKShmLCBtLCBuLCBudWxsLCBlLmZvckV4cG9ydCwgYi5leHBvcnRpbmcgJiYgYi5leHBvcnRpbmcuYWxsb3dIVE1MLCB0aGlzLnN0eWxlZE1vZGUpO1xuICAgICAgICBwKHZvaWQgMCwgdGhpcyk7XG4gICAgICAgIHRoaXMuc2V0Q2xhc3NOYW1lKGUuY2xhc3NOYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVkTW9kZSkgZm9yIChoIGluIGIuZGVmcykgdGhpcy5yZW5kZXJlci5kZWZpbml0aW9uKGIuZGVmc1toXSk7ZWxzZSB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGUuc3R5bGUpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmNoYXJ0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICBjKHRoaXMsIFwiYWZ0ZXJHZXRDb250YWluZXJcIik7XG4gICAgICB9LFxuICAgICAgZ2V0TWFyZ2luczogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLnNwYWNpbmcsXG4gICAgICAgICAgICBlID0gdGhpcy5tYXJnaW4sXG4gICAgICAgICAgICBmID0gdGhpcy50aXRsZU9mZnNldDtcbiAgICAgICAgdGhpcy5yZXNldE1hcmdpbnMoKTtcbiAgICAgICAgZlswXSAmJiAhRChlWzBdKSAmJiAodGhpcy5wbG90VG9wID0gTWF0aC5tYXgodGhpcy5wbG90VG9wLCBmWzBdICsgYVswXSkpO1xuICAgICAgICBmWzJdICYmICFEKGVbMl0pICYmICh0aGlzLm1hcmdpbkJvdHRvbSA9IE1hdGgubWF4KHRoaXMubWFyZ2luQm90dG9tLCBmWzJdICsgYVsyXSkpO1xuICAgICAgICB0aGlzLmxlZ2VuZCAmJiB0aGlzLmxlZ2VuZC5kaXNwbGF5ICYmIHRoaXMubGVnZW5kLmFkanVzdE1hcmdpbnMoZSwgYSk7XG4gICAgICAgIGModGhpcywgXCJnZXRNYXJnaW5zXCIpO1xuICAgICAgICBiIHx8IHRoaXMuZ2V0QXhpc01hcmdpbnMoKTtcbiAgICAgIH0sXG4gICAgICBnZXRBeGlzTWFyZ2luczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMsXG4gICAgICAgICAgICBhID0gYi5heGlzT2Zmc2V0ID0gWzAsIDAsIDAsIDBdLFxuICAgICAgICAgICAgYyA9IGIuY29sb3JBeGlzLFxuICAgICAgICAgICAgZSA9IGIubWFyZ2luLFxuICAgICAgICAgICAgZiA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYi5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICBiLnZpc2libGUgJiYgYi5nZXRPZmZzZXQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBiLmhhc0NhcnRlc2lhblNlcmllcyA/IGYoYi5heGVzKSA6IGMgJiYgYy5sZW5ndGggJiYgZihjKTtcbiAgICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uIChjLCBmKSB7XG4gICAgICAgICAgRChlW2ZdKSB8fCAoYltjXSArPSBhW2ZdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGIuc2V0Q2hhcnRTaXplKCk7XG4gICAgICB9LFxuICAgICAgcmVmbG93OiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICBjID0gYS5vcHRpb25zLmNoYXJ0LFxuICAgICAgICAgICAgZSA9IGEucmVuZGVyVG8sXG4gICAgICAgICAgICBmID0gRChjLndpZHRoKSAmJiBEKGMuaGVpZ2h0KSxcbiAgICAgICAgICAgIGQgPSBjLndpZHRoIHx8IGsoZSwgXCJ3aWR0aFwiKTtcbiAgICAgICAgYyA9IGMuaGVpZ2h0IHx8IGsoZSwgXCJoZWlnaHRcIik7XG4gICAgICAgIGUgPSBiID8gYi50YXJnZXQgOiBaO1xuXG4gICAgICAgIGlmICghZiAmJiAhYS5pc1ByaW50aW5nICYmIGQgJiYgYyAmJiAoZSA9PT0gWiB8fCBlID09PSBSKSkge1xuICAgICAgICAgIGlmIChkICE9PSBhLmNvbnRhaW5lcldpZHRoIHx8IGMgIT09IGEuY29udGFpbmVySGVpZ2h0KSBNLmNsZWFyVGltZW91dChhLnJlZmxvd1RpbWVvdXQpLCBhLnJlZmxvd1RpbWVvdXQgPSBDKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGEuY29udGFpbmVyICYmIGEuc2V0U2l6ZSh2b2lkIDAsIHZvaWQgMCwgITEpO1xuICAgICAgICAgIH0sIGIgPyAxMDAgOiAwKTtcbiAgICAgICAgICBhLmNvbnRhaW5lcldpZHRoID0gZDtcbiAgICAgICAgICBhLmNvbnRhaW5lckhlaWdodCA9IGM7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXRSZWZsb3c6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgITEgPT09IGIgfHwgdGhpcy51bmJpbmRSZWZsb3cgPyAhMSA9PT0gYiAmJiB0aGlzLnVuYmluZFJlZmxvdyAmJiAodGhpcy51bmJpbmRSZWZsb3cgPSB0aGlzLnVuYmluZFJlZmxvdygpKSA6ICh0aGlzLnVuYmluZFJlZmxvdyA9IEUoWiwgXCJyZXNpemVcIiwgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBhLm9wdGlvbnMgJiYgYS5yZWZsb3coYik7XG4gICAgICAgIH0pLCBFKHRoaXMsIFwiZGVzdHJveVwiLCB0aGlzLnVuYmluZFJlZmxvdykpO1xuICAgICAgfSxcbiAgICAgIHNldFNpemU6IGZ1bmN0aW9uIChiLCBhLCBlKSB7XG4gICAgICAgIHZhciBmID0gdGhpcyxcbiAgICAgICAgICAgIGQgPSBmLnJlbmRlcmVyO1xuICAgICAgICBmLmlzUmVzaXppbmcgKz0gMTtcbiAgICAgICAgcChlLCBmKTtcbiAgICAgICAgZSA9IGQuZ2xvYmFsQW5pbWF0aW9uO1xuICAgICAgICBmLm9sZENoYXJ0SGVpZ2h0ID0gZi5jaGFydEhlaWdodDtcbiAgICAgICAgZi5vbGRDaGFydFdpZHRoID0gZi5jaGFydFdpZHRoO1xuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYiAmJiAoZi5vcHRpb25zLmNoYXJ0LndpZHRoID0gYik7XG4gICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBhICYmIChmLm9wdGlvbnMuY2hhcnQuaGVpZ2h0ID0gYSk7XG4gICAgICAgIGYuZ2V0Q2hhcnRTaXplKCk7XG4gICAgICAgIGYuc3R5bGVkTW9kZSB8fCAoZSA/IEEgOiB0KShmLmNvbnRhaW5lciwge1xuICAgICAgICAgIHdpZHRoOiBmLmNoYXJ0V2lkdGggKyBcInB4XCIsXG4gICAgICAgICAgaGVpZ2h0OiBmLmNoYXJ0SGVpZ2h0ICsgXCJweFwiXG4gICAgICAgIH0sIGUpO1xuICAgICAgICBmLnNldENoYXJ0U2l6ZSghMCk7XG4gICAgICAgIGQuc2V0U2l6ZShmLmNoYXJ0V2lkdGgsIGYuY2hhcnRIZWlnaHQsIGUpO1xuICAgICAgICBmLmF4ZXMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGIuaXNEaXJ0eSA9ICEwO1xuICAgICAgICAgIGIuc2V0U2NhbGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGYuaXNEaXJ0eUxlZ2VuZCA9ICEwO1xuICAgICAgICBmLmlzRGlydHlCb3ggPSAhMDtcbiAgICAgICAgZi5sYXlPdXRUaXRsZXMoKTtcbiAgICAgICAgZi5nZXRNYXJnaW5zKCk7XG4gICAgICAgIGYucmVkcmF3KGUpO1xuICAgICAgICBmLm9sZENoYXJ0SGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgYyhmLCBcInJlc2l6ZVwiKTtcbiAgICAgICAgQyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZiAmJiBjKGYsIFwiZW5kUmVzaXplXCIsIG51bGwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC0tZi5pc1Jlc2l6aW5nO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBHKGUpLmR1cmF0aW9uIHx8IDApO1xuICAgICAgfSxcbiAgICAgIHNldENoYXJ0U2l6ZTogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmludmVydGVkLFxuICAgICAgICAgICAgZSA9IHRoaXMucmVuZGVyZXIsXG4gICAgICAgICAgICBmID0gdGhpcy5jaGFydFdpZHRoLFxuICAgICAgICAgICAgZCA9IHRoaXMuY2hhcnRIZWlnaHQsXG4gICAgICAgICAgICBrID0gdGhpcy5vcHRpb25zLmNoYXJ0LFxuICAgICAgICAgICAgbCA9IHRoaXMuc3BhY2luZyxcbiAgICAgICAgICAgIGggPSB0aGlzLmNsaXBPZmZzZXQsXG4gICAgICAgICAgICBtLFxuICAgICAgICAgICAgbixcbiAgICAgICAgICAgIHAsXG4gICAgICAgICAgICB4O1xuICAgICAgICB0aGlzLnBsb3RMZWZ0ID0gbSA9IE1hdGgucm91bmQodGhpcy5wbG90TGVmdCk7XG4gICAgICAgIHRoaXMucGxvdFRvcCA9IG4gPSBNYXRoLnJvdW5kKHRoaXMucGxvdFRvcCk7XG4gICAgICAgIHRoaXMucGxvdFdpZHRoID0gcCA9IE1hdGgubWF4KDAsIE1hdGgucm91bmQoZiAtIG0gLSB0aGlzLm1hcmdpblJpZ2h0KSk7XG4gICAgICAgIHRoaXMucGxvdEhlaWdodCA9IHggPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKGQgLSBuIC0gdGhpcy5tYXJnaW5Cb3R0b20pKTtcbiAgICAgICAgdGhpcy5wbG90U2l6ZVggPSBhID8geCA6IHA7XG4gICAgICAgIHRoaXMucGxvdFNpemVZID0gYSA/IHAgOiB4O1xuICAgICAgICB0aGlzLnBsb3RCb3JkZXJXaWR0aCA9IGsucGxvdEJvcmRlcldpZHRoIHx8IDA7XG4gICAgICAgIHRoaXMuc3BhY2luZ0JveCA9IGUuc3BhY2luZ0JveCA9IHtcbiAgICAgICAgICB4OiBsWzNdLFxuICAgICAgICAgIHk6IGxbMF0sXG4gICAgICAgICAgd2lkdGg6IGYgLSBsWzNdIC0gbFsxXSxcbiAgICAgICAgICBoZWlnaHQ6IGQgLSBsWzBdIC0gbFsyXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBsb3RCb3ggPSBlLnBsb3RCb3ggPSB7XG4gICAgICAgICAgeDogbSxcbiAgICAgICAgICB5OiBuLFxuICAgICAgICAgIHdpZHRoOiBwLFxuICAgICAgICAgIGhlaWdodDogeFxuICAgICAgICB9O1xuICAgICAgICBmID0gMiAqIE1hdGguZmxvb3IodGhpcy5wbG90Qm9yZGVyV2lkdGggLyAyKTtcbiAgICAgICAgYSA9IE1hdGguY2VpbChNYXRoLm1heChmLCBoWzNdKSAvIDIpO1xuICAgICAgICBlID0gTWF0aC5jZWlsKE1hdGgubWF4KGYsIGhbMF0pIC8gMik7XG4gICAgICAgIHRoaXMuY2xpcEJveCA9IHtcbiAgICAgICAgICB4OiBhLFxuICAgICAgICAgIHk6IGUsXG4gICAgICAgICAgd2lkdGg6IE1hdGguZmxvb3IodGhpcy5wbG90U2l6ZVggLSBNYXRoLm1heChmLCBoWzFdKSAvIDIgLSBhKSxcbiAgICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KDAsIE1hdGguZmxvb3IodGhpcy5wbG90U2l6ZVkgLSBNYXRoLm1heChmLCBoWzJdKSAvIDIgLSBlKSlcbiAgICAgICAgfTtcbiAgICAgICAgYiB8fCB0aGlzLmF4ZXMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGIuc2V0QXhpc1NpemUoKTtcbiAgICAgICAgICBiLnNldEF4aXNUcmFuc2xhdGlvbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgYyh0aGlzLCBcImFmdGVyU2V0Q2hhcnRTaXplXCIsIHtcbiAgICAgICAgICBza2lwQXhlczogYlxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICByZXNldE1hcmdpbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYyh0aGlzLCBcInJlc2V0TWFyZ2luc1wiKTtcbiAgICAgICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICAgICAgYSA9IGIub3B0aW9ucy5jaGFydDtcbiAgICAgICAgW1wibWFyZ2luXCIsIFwic3BhY2luZ1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgdmFyIGUgPSBhW2NdLFxuICAgICAgICAgICAgICBmID0gbChlKSA/IGUgOiBbZSwgZSwgZSwgZV07XG4gICAgICAgICAgW1wiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCJdLmZvckVhY2goZnVuY3Rpb24gKGUsIGQpIHtcbiAgICAgICAgICAgIGJbY11bZF0gPSBMKGFbYyArIGVdLCBmW2RdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG0uZm9yRWFjaChmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICAgIGJbYV0gPSBMKGIubWFyZ2luW2NdLCBiLnNwYWNpbmdbY10pO1xuICAgICAgICB9KTtcbiAgICAgICAgYi5heGlzT2Zmc2V0ID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICBiLmNsaXBPZmZzZXQgPSBbMCwgMCwgMCwgMF07XG4gICAgICB9LFxuICAgICAgZHJhd0NoYXJ0Qm94OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5vcHRpb25zLmNoYXJ0LFxuICAgICAgICAgICAgYSA9IHRoaXMucmVuZGVyZXIsXG4gICAgICAgICAgICBlID0gdGhpcy5jaGFydFdpZHRoLFxuICAgICAgICAgICAgZiA9IHRoaXMuY2hhcnRIZWlnaHQsXG4gICAgICAgICAgICBkID0gdGhpcy5jaGFydEJhY2tncm91bmQsXG4gICAgICAgICAgICBrID0gdGhpcy5wbG90QmFja2dyb3VuZCxcbiAgICAgICAgICAgIGwgPSB0aGlzLnBsb3RCb3JkZXIsXG4gICAgICAgICAgICBoID0gdGhpcy5zdHlsZWRNb2RlLFxuICAgICAgICAgICAgbSA9IHRoaXMucGxvdEJHSW1hZ2UsXG4gICAgICAgICAgICBuID0gYi5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBwID0gYi5wbG90QmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgeCA9IGIucGxvdEJhY2tncm91bmRJbWFnZSxcbiAgICAgICAgICAgIGcsXG4gICAgICAgICAgICB3ID0gdGhpcy5wbG90TGVmdCxcbiAgICAgICAgICAgIEMgPSB0aGlzLnBsb3RUb3AsXG4gICAgICAgICAgICB2ID0gdGhpcy5wbG90V2lkdGgsXG4gICAgICAgICAgICBxID0gdGhpcy5wbG90SGVpZ2h0LFxuICAgICAgICAgICAgdCA9IHRoaXMucGxvdEJveCxcbiAgICAgICAgICAgIEIgPSB0aGlzLmNsaXBSZWN0LFxuICAgICAgICAgICAgeiA9IHRoaXMuY2xpcEJveCxcbiAgICAgICAgICAgIE8gPSBcImFuaW1hdGVcIjtcbiAgICAgICAgZCB8fCAodGhpcy5jaGFydEJhY2tncm91bmQgPSBkID0gYS5yZWN0KCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWJhY2tncm91bmRcIikuYWRkKCksIE8gPSBcImF0dHJcIik7XG4gICAgICAgIGlmIChoKSB2YXIgeSA9IGcgPSBkLnN0cm9rZVdpZHRoKCk7ZWxzZSB7XG4gICAgICAgICAgeSA9IGIuYm9yZGVyV2lkdGggfHwgMDtcbiAgICAgICAgICBnID0geSArIChiLnNoYWRvdyA/IDggOiAwKTtcbiAgICAgICAgICBuID0ge1xuICAgICAgICAgICAgZmlsbDogbiB8fCBcIm5vbmVcIlxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHkgfHwgZFtcInN0cm9rZS13aWR0aFwiXSkgbi5zdHJva2UgPSBiLmJvcmRlckNvbG9yLCBuW1wic3Ryb2tlLXdpZHRoXCJdID0geTtcbiAgICAgICAgICBkLmF0dHIobikuc2hhZG93KGIuc2hhZG93KTtcbiAgICAgICAgfVxuICAgICAgICBkW09dKHtcbiAgICAgICAgICB4OiBnIC8gMixcbiAgICAgICAgICB5OiBnIC8gMixcbiAgICAgICAgICB3aWR0aDogZSAtIGcgLSB5ICUgMixcbiAgICAgICAgICBoZWlnaHQ6IGYgLSBnIC0geSAlIDIsXG4gICAgICAgICAgcjogYi5ib3JkZXJSYWRpdXNcbiAgICAgICAgfSk7XG4gICAgICAgIE8gPSBcImFuaW1hdGVcIjtcbiAgICAgICAgayB8fCAoTyA9IFwiYXR0clwiLCB0aGlzLnBsb3RCYWNrZ3JvdW5kID0gayA9IGEucmVjdCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1wbG90LWJhY2tncm91bmRcIikuYWRkKCkpO1xuICAgICAgICBrW09dKHQpO1xuICAgICAgICBoIHx8IChrLmF0dHIoe1xuICAgICAgICAgIGZpbGw6IHAgfHwgXCJub25lXCJcbiAgICAgICAgfSkuc2hhZG93KGIucGxvdFNoYWRvdyksIHggJiYgKG0gPyAoeCAhPT0gbS5hdHRyKFwiaHJlZlwiKSAmJiBtLmF0dHIoXCJocmVmXCIsIHgpLCBtLmFuaW1hdGUodCkpIDogdGhpcy5wbG90QkdJbWFnZSA9IGEuaW1hZ2UoeCwgdywgQywgdiwgcSkuYWRkKCkpKTtcbiAgICAgICAgQiA/IEIuYW5pbWF0ZSh7XG4gICAgICAgICAgd2lkdGg6IHoud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB6LmhlaWdodFxuICAgICAgICB9KSA6IHRoaXMuY2xpcFJlY3QgPSBhLmNsaXBSZWN0KHopO1xuICAgICAgICBPID0gXCJhbmltYXRlXCI7XG4gICAgICAgIGwgfHwgKE8gPSBcImF0dHJcIiwgdGhpcy5wbG90Qm9yZGVyID0gbCA9IGEucmVjdCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1wbG90LWJvcmRlclwiKS5hdHRyKHtcbiAgICAgICAgICB6SW5kZXg6IDFcbiAgICAgICAgfSkuYWRkKCkpO1xuICAgICAgICBoIHx8IGwuYXR0cih7XG4gICAgICAgICAgc3Ryb2tlOiBiLnBsb3RCb3JkZXJDb2xvcixcbiAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBiLnBsb3RCb3JkZXJXaWR0aCB8fCAwLFxuICAgICAgICAgIGZpbGw6IFwibm9uZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBsW09dKGwuY3Jpc3Aoe1xuICAgICAgICAgIHg6IHcsXG4gICAgICAgICAgeTogQyxcbiAgICAgICAgICB3aWR0aDogdixcbiAgICAgICAgICBoZWlnaHQ6IHFcbiAgICAgICAgfSwgLWwuc3Ryb2tlV2lkdGgoKSkpO1xuICAgICAgICB0aGlzLmlzRGlydHlCb3ggPSAhMTtcbiAgICAgICAgYyh0aGlzLCBcImFmdGVyRHJhd0NoYXJ0Qm94XCIpO1xuICAgICAgfSxcbiAgICAgIHByb3BGcm9tU2VyaWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcyxcbiAgICAgICAgICAgIGEgPSBiLm9wdGlvbnMuY2hhcnQsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgZSA9IGIub3B0aW9ucy5zZXJpZXMsXG4gICAgICAgICAgICBmLFxuICAgICAgICAgICAgZDtcbiAgICAgICAgW1wiaW52ZXJ0ZWRcIiwgXCJhbmd1bGFyXCIsIFwicG9sYXJcIl0uZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgIGMgPSBUW2EudHlwZSB8fCBhLmRlZmF1bHRTZXJpZXNUeXBlXTtcbiAgICAgICAgICBkID0gYVtrXSB8fCBjICYmIGMucHJvdG90eXBlW2tdO1xuXG4gICAgICAgICAgZm9yIChmID0gZSAmJiBlLmxlbmd0aDsgIWQgJiYgZi0tOykgKGMgPSBUW2VbZl0udHlwZV0pICYmIGMucHJvdG90eXBlW2tdICYmIChkID0gITApO1xuXG4gICAgICAgICAgYltrXSA9IGQ7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGxpbmtTZXJpZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICAgICAgYSA9IGIuc2VyaWVzO1xuICAgICAgICBhLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBiLmxpbmtlZFNlcmllcy5sZW5ndGggPSAwO1xuICAgICAgICB9KTtcbiAgICAgICAgYS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgdmFyIGMgPSBhLm9wdGlvbnMubGlua2VkVG87XG4gICAgICAgICAgdihjKSAmJiAoYyA9IFwiOnByZXZpb3VzXCIgPT09IGMgPyBiLnNlcmllc1thLmluZGV4IC0gMV0gOiBiLmdldChjKSkgJiYgYy5saW5rZWRQYXJlbnQgIT09IGEgJiYgKGMubGlua2VkU2VyaWVzLnB1c2goYSksIGEubGlua2VkUGFyZW50ID0gYywgYy5lbmFibGVkRGF0YVNvcnRpbmcgJiYgYS5zZXREYXRhU29ydGluZ09wdGlvbnMoKSwgYS52aXNpYmxlID0gTChhLm9wdGlvbnMudmlzaWJsZSwgYy5vcHRpb25zLnZpc2libGUsIGEudmlzaWJsZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgYyh0aGlzLCBcImFmdGVyTGlua1Nlcmllc1wiKTtcbiAgICAgIH0sXG4gICAgICByZW5kZXJTZXJpZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGIudHJhbnNsYXRlKCk7XG4gICAgICAgICAgYi5yZW5kZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcmVuZGVyTGFiZWxzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcyxcbiAgICAgICAgICAgIGEgPSBiLm9wdGlvbnMubGFiZWxzO1xuICAgICAgICBhLml0ZW1zICYmIGEuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHZhciBlID0gUChhLnN0eWxlLCBjLnN0eWxlKSxcbiAgICAgICAgICAgICAgZiA9IFEoZS5sZWZ0KSArIGIucGxvdExlZnQsXG4gICAgICAgICAgICAgIGQgPSBRKGUudG9wKSArIGIucGxvdFRvcCArIDEyO1xuICAgICAgICAgIGRlbGV0ZSBlLmxlZnQ7XG4gICAgICAgICAgZGVsZXRlIGUudG9wO1xuICAgICAgICAgIGIucmVuZGVyZXIudGV4dChjLmh0bWwsIGYsIGQpLmF0dHIoe1xuICAgICAgICAgICAgekluZGV4OiAyXG4gICAgICAgICAgfSkuY3NzKGUpLmFkZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmF4ZXMsXG4gICAgICAgICAgICBhID0gdGhpcy5jb2xvckF4aXMsXG4gICAgICAgICAgICBjID0gdGhpcy5yZW5kZXJlcixcbiAgICAgICAgICAgIGUgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBmID0gMCxcbiAgICAgICAgICAgIGQgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGIuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgYi52aXNpYmxlICYmIGIucmVuZGVyKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZXRUaXRsZSgpO1xuICAgICAgICB0aGlzLmxlZ2VuZCA9IG5ldyBnKHRoaXMsIGUubGVnZW5kKTtcbiAgICAgICAgdGhpcy5nZXRTdGFja3MgJiYgdGhpcy5nZXRTdGFja3MoKTtcbiAgICAgICAgdGhpcy5nZXRNYXJnaW5zKCEwKTtcbiAgICAgICAgdGhpcy5zZXRDaGFydFNpemUoKTtcbiAgICAgICAgZSA9IHRoaXMucGxvdFdpZHRoO1xuICAgICAgICBiLnNvbWUoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBpZiAoYi5ob3JpeiAmJiBiLnZpc2libGUgJiYgYi5vcHRpb25zLmxhYmVscy5lbmFibGVkICYmIGIuc2VyaWVzLmxlbmd0aCkgcmV0dXJuIGYgPSAyMSwgITA7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgayA9IHRoaXMucGxvdEhlaWdodCA9IE1hdGgubWF4KHRoaXMucGxvdEhlaWdodCAtIGYsIDApO1xuICAgICAgICBiLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBiLnNldFNjYWxlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdldEF4aXNNYXJnaW5zKCk7XG4gICAgICAgIHZhciBsID0gMS4xIDwgZSAvIHRoaXMucGxvdFdpZHRoO1xuICAgICAgICB2YXIgaCA9IDEuMDUgPCBrIC8gdGhpcy5wbG90SGVpZ2h0O1xuICAgICAgICBpZiAobCB8fCBoKSBiLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAoYi5ob3JpeiAmJiBsIHx8ICFiLmhvcml6ICYmIGgpICYmIGIuc2V0VGlja0ludGVydmFsKCEwKTtcbiAgICAgICAgfSksIHRoaXMuZ2V0TWFyZ2lucygpO1xuICAgICAgICB0aGlzLmRyYXdDaGFydEJveCgpO1xuICAgICAgICB0aGlzLmhhc0NhcnRlc2lhblNlcmllcyA/IGQoYikgOiBhICYmIGEubGVuZ3RoICYmIGQoYSk7XG4gICAgICAgIHRoaXMuc2VyaWVzR3JvdXAgfHwgKHRoaXMuc2VyaWVzR3JvdXAgPSBjLmcoXCJzZXJpZXMtZ3JvdXBcIikuYXR0cih7XG4gICAgICAgICAgekluZGV4OiAzXG4gICAgICAgIH0pLmFkZCgpKTtcbiAgICAgICAgdGhpcy5yZW5kZXJTZXJpZXMoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoKTtcbiAgICAgICAgdGhpcy5hZGRDcmVkaXRzKCk7XG4gICAgICAgIHRoaXMuc2V0UmVzcG9uc2l2ZSAmJiB0aGlzLnNldFJlc3BvbnNpdmUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVDb250YWluZXJTY2FsaW5nKCk7XG4gICAgICAgIHRoaXMuaGFzUmVuZGVyZWQgPSAhMDtcbiAgICAgIH0sXG4gICAgICBhZGRDcmVkaXRzOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIGIgPSB6KCEwLCB0aGlzLm9wdGlvbnMuY3JlZGl0cywgYik7XG4gICAgICAgIGIuZW5hYmxlZCAmJiAhdGhpcy5jcmVkaXRzICYmICh0aGlzLmNyZWRpdHMgPSB0aGlzLnJlbmRlcmVyLnRleHQoYi50ZXh0ICsgKHRoaXMubWFwQ3JlZGl0cyB8fCBcIlwiKSwgMCwgMCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWNyZWRpdHNcIikub24oXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYi5ocmVmICYmIChaLmxvY2F0aW9uLmhyZWYgPSBiLmhyZWYpO1xuICAgICAgICB9KS5hdHRyKHtcbiAgICAgICAgICBhbGlnbjogYi5wb3NpdGlvbi5hbGlnbixcbiAgICAgICAgICB6SW5kZXg6IDhcbiAgICAgICAgfSksIGEuc3R5bGVkTW9kZSB8fCB0aGlzLmNyZWRpdHMuY3NzKGIuc3R5bGUpLCB0aGlzLmNyZWRpdHMuYWRkKCkuYWxpZ24oYi5wb3NpdGlvbiksIHRoaXMuY3JlZGl0cy51cGRhdGUgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGEuY3JlZGl0cyA9IGEuY3JlZGl0cy5kZXN0cm95KCk7XG4gICAgICAgICAgYS5hZGRDcmVkaXRzKGIpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVDb250YWluZXJTY2FsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5jb250YWluZXI7XG5cbiAgICAgICAgaWYgKGIub2Zmc2V0V2lkdGggJiYgYi5vZmZzZXRIZWlnaHQgJiYgYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICAgICAgICB2YXIgYSA9IGIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICAgIGMgPSBhLndpZHRoIC8gYi5vZmZzZXRXaWR0aDtcbiAgICAgICAgICBiID0gYS5oZWlnaHQgLyBiLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAxICE9PSBjIHx8IDEgIT09IGIgPyB0aGlzLmNvbnRhaW5lclNjYWxpbmcgPSB7XG4gICAgICAgICAgICBzY2FsZVg6IGMsXG4gICAgICAgICAgICBzY2FsZVk6IGJcbiAgICAgICAgICB9IDogZGVsZXRlIHRoaXMuY29udGFpbmVyU2NhbGluZztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICAgICAgYSA9IGIuYXhlcyxcbiAgICAgICAgICAgIGUgPSBiLnNlcmllcyxcbiAgICAgICAgICAgIGYgPSBiLmNvbnRhaW5lcixcbiAgICAgICAgICAgIGssXG4gICAgICAgICAgICBsID0gZiAmJiBmLnBhcmVudE5vZGU7XG4gICAgICAgIGMoYiwgXCJkZXN0cm95XCIpO1xuICAgICAgICBiLnJlbmRlcmVyLmZvckV4cG9ydCA/IE4oVSwgYikgOiBVW2IuaW5kZXhdID0gdm9pZCAwO1xuICAgICAgICBkLmNoYXJ0Q291bnQtLTtcbiAgICAgICAgYi5yZW5kZXJUby5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWhpZ2hjaGFydHMtY2hhcnRcIik7XG4gICAgICAgIEsoYik7XG5cbiAgICAgICAgZm9yIChrID0gYS5sZW5ndGg7IGstLTspIGFba10gPSBhW2tdLmRlc3Ryb3koKTtcblxuICAgICAgICB0aGlzLnNjcm9sbGVyICYmIHRoaXMuc2Nyb2xsZXIuZGVzdHJveSAmJiB0aGlzLnNjcm9sbGVyLmRlc3Ryb3koKTtcblxuICAgICAgICBmb3IgKGsgPSBlLmxlbmd0aDsgay0tOykgZVtrXSA9IGVba10uZGVzdHJveSgpO1xuXG4gICAgICAgIFwidGl0bGUgc3VidGl0bGUgY2hhcnRCYWNrZ3JvdW5kIHBsb3RCYWNrZ3JvdW5kIHBsb3RCR0ltYWdlIHBsb3RCb3JkZXIgc2VyaWVzR3JvdXAgY2xpcFJlY3QgY3JlZGl0cyBwb2ludGVyIHJhbmdlU2VsZWN0b3IgbGVnZW5kIHJlc2V0Wm9vbUJ1dHRvbiB0b29sdGlwIHJlbmRlcmVyXCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICB2YXIgYyA9IGJbYV07XG4gICAgICAgICAgYyAmJiBjLmRlc3Ryb3kgJiYgKGJbYV0gPSBjLmRlc3Ryb3koKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmICYmIChmLmlubmVySFRNTCA9IFwiXCIsIEsoZiksIGwgJiYgaChmKSk7XG4gICAgICAgIEIoYiwgZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgICBkZWxldGUgYltjXTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZmlyc3RSZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICAgICAgYSA9IGIub3B0aW9ucztcblxuICAgICAgICBpZiAoIWIuaXNSZWFkeVRvUmVuZGVyIHx8IGIuaXNSZWFkeVRvUmVuZGVyKCkpIHtcbiAgICAgICAgICBiLmdldENvbnRhaW5lcigpO1xuICAgICAgICAgIGIucmVzZXRNYXJnaW5zKCk7XG4gICAgICAgICAgYi5zZXRDaGFydFNpemUoKTtcbiAgICAgICAgICBiLnByb3BGcm9tU2VyaWVzKCk7XG4gICAgICAgICAgYi5nZXRBeGVzKCk7XG4gICAgICAgICAgKG4oYS5zZXJpZXMpID8gYS5zZXJpZXMgOiBbXSkuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYi5pbml0U2VyaWVzKGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGIubGlua1NlcmllcygpO1xuICAgICAgICAgIGIuc2V0U2VyaWVzRGF0YSgpO1xuICAgICAgICAgIGMoYiwgXCJiZWZvcmVSZW5kZXJcIik7XG4gICAgICAgICAgdSAmJiAoYi5wb2ludGVyID0gZC5oYXNUb3VjaCB8fCAhWi5Qb2ludGVyRXZlbnQgJiYgIVouTVNQb2ludGVyRXZlbnQgPyBuZXcgdShiLCBhKSA6IG5ldyByKGIsIGEpKTtcbiAgICAgICAgICBiLnJlbmRlcigpO1xuICAgICAgICAgIGlmICghYi5yZW5kZXJlci5pbWdDb3VudCAmJiAhYi5oYXNMb2FkZWQpIGIub25sb2FkKCk7XG4gICAgICAgICAgYi50ZW1wb3JhcnlEaXNwbGF5KCEwKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9ubG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5jb25jYXQoW3RoaXMuY2FsbGJhY2tdKS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYiAmJiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgdGhpcy5pbmRleCAmJiBiLmFwcGx5KHRoaXMsIFt0aGlzXSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBjKHRoaXMsIFwibG9hZFwiKTtcbiAgICAgICAgYyh0aGlzLCBcInJlbmRlclwiKTtcbiAgICAgICAgRCh0aGlzLmluZGV4KSAmJiB0aGlzLnNldFJlZmxvdyh0aGlzLm9wdGlvbnMuY2hhcnQucmVmbG93KTtcbiAgICAgICAgdGhpcy5oYXNMb2FkZWQgPSAhMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9TY3JvbGxhYmxlUGxvdEFyZWEuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcpIHtcbiAgICB2YXIgciA9IGcuYWRkRXZlbnQsXG4gICAgICAgIHUgPSBnLmNyZWF0ZUVsZW1lbnQsXG4gICAgICAgIEkgPSBnLnBpY2ssXG4gICAgICAgIE0gPSBnLnN0b3A7XG4gICAgZyA9IGQuQ2hhcnQ7XG4gICAgXCJcIjtcbiAgICByKGcsIFwiYWZ0ZXJTZXRDaGFydFNpemVcIiwgZnVuY3Rpb24gKGcpIHtcbiAgICAgIHZhciB1ID0gdGhpcy5vcHRpb25zLmNoYXJ0LnNjcm9sbGFibGVQbG90QXJlYSxcbiAgICAgICAgICByID0gdSAmJiB1Lm1pbldpZHRoO1xuICAgICAgdSA9IHUgJiYgdS5taW5IZWlnaHQ7XG5cbiAgICAgIGlmICghdGhpcy5yZW5kZXJlci5mb3JFeHBvcnQpIHtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICBpZiAodGhpcy5zY3JvbGxhYmxlUGl4ZWxzWCA9IHIgPSBNYXRoLm1heCgwLCByIC0gdGhpcy5jaGFydFdpZHRoKSkge1xuICAgICAgICAgICAgdGhpcy5wbG90V2lkdGggKz0gcjtcbiAgICAgICAgICAgIHRoaXMuaW52ZXJ0ZWQgPyAodGhpcy5jbGlwQm94LmhlaWdodCArPSByLCB0aGlzLnBsb3RCb3guaGVpZ2h0ICs9IHIpIDogKHRoaXMuY2xpcEJveC53aWR0aCArPSByLCB0aGlzLnBsb3RCb3gud2lkdGggKz0gcik7XG4gICAgICAgICAgICB2YXIgRSA9IHtcbiAgICAgICAgICAgICAgMToge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwicmlnaHRcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogclxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHUgJiYgKHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1kgPSByID0gTWF0aC5tYXgoMCwgdSAtIHRoaXMuY2hhcnRIZWlnaHQpKSAmJiAodGhpcy5wbG90SGVpZ2h0ICs9IHIsIHRoaXMuaW52ZXJ0ZWQgPyAodGhpcy5jbGlwQm94LndpZHRoICs9IHIsIHRoaXMucGxvdEJveC53aWR0aCArPSByKSA6ICh0aGlzLmNsaXBCb3guaGVpZ2h0ICs9IHIsIHRoaXMucGxvdEJveC5oZWlnaHQgKz0gciksIEUgPSB7XG4gICAgICAgICAgMjoge1xuICAgICAgICAgICAgbmFtZTogXCJib3R0b21cIixcbiAgICAgICAgICAgIHZhbHVlOiByXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBFICYmICFnLnNraXBBeGVzICYmIHRoaXMuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7XG4gICAgICAgICAgRVtnLnNpZGVdID8gZy5nZXRQbG90TGluZVBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdCA9IEVbZy5zaWRlXS5uYW1lLFxuICAgICAgICAgICAgICAgIHkgPSB0aGlzW3RdO1xuICAgICAgICAgICAgdGhpc1t0XSA9IHkgLSBFW2cuc2lkZV0udmFsdWU7XG4gICAgICAgICAgICB2YXIgaCA9IGQuQXhpcy5wcm90b3R5cGUuZ2V0UGxvdExpbmVQYXRoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzW3RdID0geTtcbiAgICAgICAgICAgIHJldHVybiBoO1xuICAgICAgICAgIH0gOiAoZy5zZXRBeGlzU2l6ZSgpLCBnLnNldEF4aXNUcmFuc2xhdGlvbigpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcihnLCBcInJlbmRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnNjcm9sbGFibGVQaXhlbHNYIHx8IHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1kgPyAodGhpcy5zZXRVcFNjcm9sbGluZyAmJiB0aGlzLnNldFVwU2Nyb2xsaW5nKCksIHRoaXMuYXBwbHlGaXhlZCgpKSA6IHRoaXMuZml4ZWREaXYgJiYgdGhpcy5hcHBseUZpeGVkKCk7XG4gICAgfSk7XG5cbiAgICBnLnByb3RvdHlwZS5zZXRVcFNjcm9sbGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICBnID0ge1xuICAgICAgICBXZWJraXRPdmVyZmxvd1Njcm9sbGluZzogXCJ0b3VjaFwiLFxuICAgICAgICBvdmVyZmxvd1g6IFwiaGlkZGVuXCIsXG4gICAgICAgIG92ZXJmbG93WTogXCJoaWRkZW5cIlxuICAgICAgfTtcbiAgICAgIHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1ggJiYgKGcub3ZlcmZsb3dYID0gXCJhdXRvXCIpO1xuICAgICAgdGhpcy5zY3JvbGxhYmxlUGl4ZWxzWSAmJiAoZy5vdmVyZmxvd1kgPSBcImF1dG9cIik7XG4gICAgICB0aGlzLnNjcm9sbGluZ0NvbnRhaW5lciA9IHUoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwiaGlnaGNoYXJ0cy1zY3JvbGxpbmdcIlxuICAgICAgfSwgZywgdGhpcy5yZW5kZXJUbyk7XG4gICAgICByKHRoaXMuc2Nyb2xsaW5nQ29udGFpbmVyLCBcInNjcm9sbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGQucG9pbnRlciAmJiBkZWxldGUgZC5wb2ludGVyLmNoYXJ0UG9zaXRpb247XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaW5uZXJDb250YWluZXIgPSB1KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImhpZ2hjaGFydHMtaW5uZXItY29udGFpbmVyXCJcbiAgICAgIH0sIG51bGwsIHRoaXMuc2Nyb2xsaW5nQ29udGFpbmVyKTtcbiAgICAgIHRoaXMuaW5uZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICAgICAgdGhpcy5zZXRVcFNjcm9sbGluZyA9IG51bGw7XG4gICAgfTtcblxuICAgIGcucHJvdG90eXBlLm1vdmVGaXhlZEVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGQgPSB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgICBnID0gdGhpcy5maXhlZFJlbmRlcmVyLFxuICAgICAgICAgIHUgPSBcIi5oaWdoY2hhcnRzLWNvbnRleHRidXR0b24gLmhpZ2hjaGFydHMtY3JlZGl0cyAuaGlnaGNoYXJ0cy1sZWdlbmQgLmhpZ2hjaGFydHMtbGVnZW5kLWNoZWNrYm94IC5oaWdoY2hhcnRzLW5hdmlnYXRvci1zZXJpZXMgLmhpZ2hjaGFydHMtbmF2aWdhdG9yLXhheGlzIC5oaWdoY2hhcnRzLW5hdmlnYXRvci15YXhpcyAuaGlnaGNoYXJ0cy1uYXZpZ2F0b3IgLmhpZ2hjaGFydHMtcmVzZXQtem9vbSAuaGlnaGNoYXJ0cy1zY3JvbGxiYXIgLmhpZ2hjaGFydHMtc3VidGl0bGUgLmhpZ2hjaGFydHMtdGl0bGVcIi5zcGxpdChcIiBcIiksXG4gICAgICAgICAgcjtcbiAgICAgIHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1ggJiYgIXRoaXMuaW52ZXJ0ZWQgPyByID0gXCIuaGlnaGNoYXJ0cy15YXhpc1wiIDogdGhpcy5zY3JvbGxhYmxlUGl4ZWxzWCAmJiB0aGlzLmludmVydGVkID8gciA9IFwiLmhpZ2hjaGFydHMteGF4aXNcIiA6IHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1kgJiYgIXRoaXMuaW52ZXJ0ZWQgPyByID0gXCIuaGlnaGNoYXJ0cy14YXhpc1wiIDogdGhpcy5zY3JvbGxhYmxlUGl4ZWxzWSAmJiB0aGlzLmludmVydGVkICYmIChyID0gXCIuaGlnaGNoYXJ0cy15YXhpc1wiKTtcbiAgICAgIHUucHVzaChyLCByICsgXCItbGFiZWxzXCIpO1xuICAgICAgdS5mb3JFYWNoKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgIFtdLmZvckVhY2guY2FsbChkLnF1ZXJ5U2VsZWN0b3JBbGwoeSksIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgKGQubmFtZXNwYWNlVVJJID09PSBnLlNWR19OUyA/IGcuYm94IDogZy5ib3gucGFyZW50Tm9kZSkuYXBwZW5kQ2hpbGQoZCk7XG4gICAgICAgICAgZC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGcucHJvdG90eXBlLmFwcGx5Rml4ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZyxcbiAgICAgICAgICBBID0gIXRoaXMuZml4ZWREaXYsXG4gICAgICAgICAgRyA9IHRoaXMub3B0aW9ucy5jaGFydC5zY3JvbGxhYmxlUGxvdEFyZWE7XG4gICAgICBBID8gKHRoaXMuZml4ZWREaXYgPSB1KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImhpZ2hjaGFydHMtZml4ZWRcIlxuICAgICAgfSwge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gICAgICAgIHpJbmRleDogMlxuICAgICAgfSwgbnVsbCwgITApLCB0aGlzLnJlbmRlclRvLmluc2VydEJlZm9yZSh0aGlzLmZpeGVkRGl2LCB0aGlzLnJlbmRlclRvLmZpcnN0Q2hpbGQpLCB0aGlzLnJlbmRlclRvLnN0eWxlLm92ZXJmbG93ID0gXCJ2aXNpYmxlXCIsIHRoaXMuZml4ZWRSZW5kZXJlciA9IGcgPSBuZXcgZC5SZW5kZXJlcih0aGlzLmZpeGVkRGl2LCB0aGlzLmNoYXJ0V2lkdGgsIHRoaXMuY2hhcnRIZWlnaHQpLCB0aGlzLnNjcm9sbGFibGVNYXNrID0gZy5wYXRoKCkuYXR0cih7XG4gICAgICAgIGZpbGw6IHRoaXMub3B0aW9ucy5jaGFydC5iYWNrZ3JvdW5kQ29sb3IgfHwgXCIjZmZmXCIsXG4gICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IEkoRy5vcGFjaXR5LCAuODUpLFxuICAgICAgICB6SW5kZXg6IC0xXG4gICAgICB9KS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtc2Nyb2xsYWJsZS1tYXNrXCIpLmFkZCgpLCB0aGlzLm1vdmVGaXhlZEVsZW1lbnRzKCksIHIodGhpcywgXCJhZnRlclNob3dSZXNldFpvb21cIiwgdGhpcy5tb3ZlRml4ZWRFbGVtZW50cyksIHIodGhpcywgXCJhZnRlckxheU91dFRpdGxlc1wiLCB0aGlzLm1vdmVGaXhlZEVsZW1lbnRzKSkgOiB0aGlzLmZpeGVkUmVuZGVyZXIuc2V0U2l6ZSh0aGlzLmNoYXJ0V2lkdGgsIHRoaXMuY2hhcnRIZWlnaHQpO1xuICAgICAgZyA9IHRoaXMuY2hhcnRXaWR0aCArICh0aGlzLnNjcm9sbGFibGVQaXhlbHNYIHx8IDApO1xuICAgICAgdmFyIEogPSB0aGlzLmNoYXJ0SGVpZ2h0ICsgKHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1kgfHwgMCk7XG4gICAgICBNKHRoaXMuY29udGFpbmVyKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLndpZHRoID0gZyArIFwicHhcIjtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IEogKyBcInB4XCI7XG4gICAgICB0aGlzLnJlbmRlcmVyLmJveFdyYXBwZXIuYXR0cih7XG4gICAgICAgIHdpZHRoOiBnLFxuICAgICAgICBoZWlnaHQ6IEosXG4gICAgICAgIHZpZXdCb3g6IFswLCAwLCBnLCBKXS5qb2luKFwiIFwiKVxuICAgICAgfSk7XG4gICAgICB0aGlzLmNoYXJ0QmFja2dyb3VuZC5hdHRyKHtcbiAgICAgICAgd2lkdGg6IGcsXG4gICAgICAgIGhlaWdodDogSlxuICAgICAgfSk7XG4gICAgICB0aGlzLnNjcm9sbGFibGVQaXhlbHNZICYmICh0aGlzLnNjcm9sbGluZ0NvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSB0aGlzLmNoYXJ0SGVpZ2h0ICsgXCJweFwiKTtcbiAgICAgIEEgJiYgKEcuc2Nyb2xsUG9zaXRpb25YICYmICh0aGlzLnNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxMZWZ0ID0gdGhpcy5zY3JvbGxhYmxlUGl4ZWxzWCAqIEcuc2Nyb2xsUG9zaXRpb25YKSwgRy5zY3JvbGxQb3NpdGlvblkgJiYgKHRoaXMuc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1kgKiBHLnNjcm9sbFBvc2l0aW9uWSkpO1xuICAgICAgSiA9IHRoaXMuYXhpc09mZnNldDtcbiAgICAgIEEgPSB0aGlzLnBsb3RUb3AgLSBKWzBdIC0gMTtcbiAgICAgIEcgPSB0aGlzLnBsb3RMZWZ0IC0gSlszXSAtIDE7XG4gICAgICBnID0gdGhpcy5wbG90VG9wICsgdGhpcy5wbG90SGVpZ2h0ICsgSlsyXSArIDE7XG4gICAgICBKID0gdGhpcy5wbG90TGVmdCArIHRoaXMucGxvdFdpZHRoICsgSlsxXSArIDE7XG4gICAgICB2YXIgeSA9IHRoaXMucGxvdExlZnQgKyB0aGlzLnBsb3RXaWR0aCAtICh0aGlzLnNjcm9sbGFibGVQaXhlbHNYIHx8IDApLFxuICAgICAgICAgIHQgPSB0aGlzLnBsb3RUb3AgKyB0aGlzLnBsb3RIZWlnaHQgLSAodGhpcy5zY3JvbGxhYmxlUGl4ZWxzWSB8fCAwKTtcbiAgICAgIEEgPSB0aGlzLnNjcm9sbGFibGVQaXhlbHNYID8gW1wiTVwiLCAwLCBBLCBcIkxcIiwgdGhpcy5wbG90TGVmdCAtIDEsIEEsIFwiTFwiLCB0aGlzLnBsb3RMZWZ0IC0gMSwgZywgXCJMXCIsIDAsIGcsIFwiWlwiLCBcIk1cIiwgeSwgQSwgXCJMXCIsIHRoaXMuY2hhcnRXaWR0aCwgQSwgXCJMXCIsIHRoaXMuY2hhcnRXaWR0aCwgZywgXCJMXCIsIHksIGcsIFwiWlwiXSA6IHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1kgPyBbXCJNXCIsIEcsIDAsIFwiTFwiLCBHLCB0aGlzLnBsb3RUb3AgLSAxLCBcIkxcIiwgSiwgdGhpcy5wbG90VG9wIC0gMSwgXCJMXCIsIEosIDAsIFwiWlwiLCBcIk1cIiwgRywgdCwgXCJMXCIsIEcsIHRoaXMuY2hhcnRIZWlnaHQsIFwiTFwiLCBKLCB0aGlzLmNoYXJ0SGVpZ2h0LCBcIkxcIiwgSiwgdCwgXCJaXCJdIDogW1wiTVwiLCAwLCAwXTtcbiAgICAgIFwiYWRqdXN0SGVpZ2h0XCIgIT09IHRoaXMucmVkcmF3VHJpZ2dlciAmJiB0aGlzLnNjcm9sbGFibGVNYXNrLmF0dHIoe1xuICAgICAgICBkOiBBXG4gICAgICB9KTtcbiAgICB9O1xuICB9KTtcbiAgUyhyLCBcIm1peGlucy9sZWdlbmQtc3ltYm9sLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgdmFyIHIgPSBnLm1lcmdlLFxuICAgICAgICB1ID0gZy5waWNrO1xuICAgIGQuTGVnZW5kU3ltYm9sTWl4aW4gPSB7XG4gICAgICBkcmF3UmVjdGFuZ2xlOiBmdW5jdGlvbiAoZCwgZykge1xuICAgICAgICB2YXIgciA9IGQuc3ltYm9sSGVpZ2h0LFxuICAgICAgICAgICAgQSA9IGQub3B0aW9ucy5zcXVhcmVTeW1ib2w7XG4gICAgICAgIGcubGVnZW5kU3ltYm9sID0gdGhpcy5jaGFydC5yZW5kZXJlci5yZWN0KEEgPyAoZC5zeW1ib2xXaWR0aCAtIHIpIC8gMiA6IDAsIGQuYmFzZWxpbmUgLSByICsgMSwgQSA/IHIgOiBkLnN5bWJvbFdpZHRoLCByLCB1KGQub3B0aW9ucy5zeW1ib2xSYWRpdXMsIHIgLyAyKSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXBvaW50XCIpLmF0dHIoe1xuICAgICAgICAgIHpJbmRleDogM1xuICAgICAgICB9KS5hZGQoZy5sZWdlbmRHcm91cCk7XG4gICAgICB9LFxuICAgICAgZHJhd0xpbmVNYXJrZXI6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBnID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgRSA9IGcubWFya2VyLFxuICAgICAgICAgICAgQSA9IGQuc3ltYm9sV2lkdGgsXG4gICAgICAgICAgICBHID0gZC5zeW1ib2xIZWlnaHQsXG4gICAgICAgICAgICBKID0gRyAvIDIsXG4gICAgICAgICAgICB5ID0gdGhpcy5jaGFydC5yZW5kZXJlcixcbiAgICAgICAgICAgIHQgPSB0aGlzLmxlZ2VuZEdyb3VwO1xuICAgICAgICBkID0gZC5iYXNlbGluZSAtIE1hdGgucm91bmQoLjMgKiBkLmZvbnRNZXRyaWNzLmIpO1xuICAgICAgICB2YXIgRCA9IHt9O1xuICAgICAgICB0aGlzLmNoYXJ0LnN0eWxlZE1vZGUgfHwgKEQgPSB7XG4gICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogZy5saW5lV2lkdGggfHwgMFxuICAgICAgICB9LCBnLmRhc2hTdHlsZSAmJiAoRC5kYXNoc3R5bGUgPSBnLmRhc2hTdHlsZSkpO1xuICAgICAgICB0aGlzLmxlZ2VuZExpbmUgPSB5LnBhdGgoW1wiTVwiLCAwLCBkLCBcIkxcIiwgQSwgZF0pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1ncmFwaFwiKS5hdHRyKEQpLmFkZCh0KTtcbiAgICAgICAgRSAmJiAhMSAhPT0gRS5lbmFibGVkICYmIEEgJiYgKGcgPSBNYXRoLm1pbih1KEUucmFkaXVzLCBKKSwgSiksIDAgPT09IHRoaXMuc3ltYm9sLmluZGV4T2YoXCJ1cmxcIikgJiYgKEUgPSByKEUsIHtcbiAgICAgICAgICB3aWR0aDogRyxcbiAgICAgICAgICBoZWlnaHQ6IEdcbiAgICAgICAgfSksIGcgPSAwKSwgdGhpcy5sZWdlbmRTeW1ib2wgPSBFID0geS5zeW1ib2wodGhpcy5zeW1ib2wsIEEgLyAyIC0gZywgZCAtIGcsIDIgKiBnLCAyICogZywgRSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXBvaW50XCIpLmFkZCh0KSwgRS5pc01hcmtlciA9ICEwKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBkLkxlZ2VuZFN5bWJvbE1peGluO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL1BvaW50LmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgXCJcIjtcblxuICAgIHZhciByID0gZy5hbmltT2JqZWN0LFxuICAgICAgICB1ID0gZy5kZWZpbmVkLFxuICAgICAgICBJID0gZy5lcmFzZSxcbiAgICAgICAgTSA9IGcuZXh0ZW5kLFxuICAgICAgICBFID0gZy5mb3JtYXQsXG4gICAgICAgIEEgPSBnLmdldE5lc3RlZFByb3BlcnR5LFxuICAgICAgICBHID0gZy5pc0FycmF5LFxuICAgICAgICBKID0gZy5pc051bWJlcixcbiAgICAgICAgeSA9IGcuaXNPYmplY3QsXG4gICAgICAgIHQgPSBnLnN5bmNUaW1lb3V0LFxuICAgICAgICBEID0gZy5waWNrLFxuICAgICAgICBoID0gZy5yZW1vdmVFdmVudCxcbiAgICAgICAgTiA9IGcudW5pcXVlS2V5LFxuICAgICAgICBxID0gZC5maXJlRXZlbnQ7XG5cbiAgICBnID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gZCgpIHtcbiAgICAgICAgdGhpcy5jb2xvckluZGV4ID0gdGhpcy5jYXRlZ29yeSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5mb3JtYXRQcmVmaXggPSBcInBvaW50XCI7XG4gICAgICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuaXNOdWxsID0gITE7XG4gICAgICAgIHRoaXMucGVyY2VudGFnZSA9IHRoaXMub3B0aW9ucyA9IHRoaXMubmFtZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9ICExO1xuICAgICAgICB0aGlzLnRvdGFsID0gdGhpcy5zZXJpZXMgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9ICEwO1xuICAgICAgICB0aGlzLnggPSB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIGQucHJvdG90eXBlLmFuaW1hdGVCZWZvcmVEZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgICBjID0ge1xuICAgICAgICAgIHg6IGUuc3RhcnRYUG9zLFxuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSxcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBoID0gZS5nZXRHcmFwaGljYWxQcm9wcygpO1xuICAgICAgICBoLnNpbmd1bGFyLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICBkID0gXCJkYXRhTGFiZWxcIiA9PT0gZjtcbiAgICAgICAgICBlW2ZdID0gZVtmXS5hbmltYXRlKGQgPyB7XG4gICAgICAgICAgICB4OiBlW2ZdLnN0YXJ0WFBvcyxcbiAgICAgICAgICAgIHk6IGVbZl0uc3RhcnRZUG9zLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0gOiBjKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGgucGx1cmFsLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBlW2NdLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGEuZWxlbWVudCAmJiBhLmFuaW1hdGUoTSh7XG4gICAgICAgICAgICAgIHg6IGUuc3RhcnRYUG9zXG4gICAgICAgICAgICB9LCBhLnN0YXJ0WVBvcyA/IHtcbiAgICAgICAgICAgICAgeDogYS5zdGFydFhQb3MsXG4gICAgICAgICAgICAgIHk6IGEuc3RhcnRZUG9zXG4gICAgICAgICAgICB9IDoge30pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS5hcHBseU9wdGlvbnMgPSBmdW5jdGlvbiAoZSwgYykge1xuICAgICAgICB2YXIgayA9IHRoaXMuc2VyaWVzLFxuICAgICAgICAgICAgaCA9IGsub3B0aW9ucy5wb2ludFZhbEtleSB8fCBrLnBvaW50VmFsS2V5O1xuICAgICAgICBlID0gZC5wcm90b3R5cGUub3B0aW9uc1RvT2JqZWN0LmNhbGwodGhpcywgZSk7XG4gICAgICAgIE0odGhpcywgZSk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMub3B0aW9ucyA/IE0odGhpcy5vcHRpb25zLCBlKSA6IGU7XG4gICAgICAgIGUuZ3JvdXAgJiYgZGVsZXRlIHRoaXMuZ3JvdXA7XG4gICAgICAgIGUuZGF0YUxhYmVscyAmJiBkZWxldGUgdGhpcy5kYXRhTGFiZWxzO1xuICAgICAgICBoICYmICh0aGlzLnkgPSBkLnByb3RvdHlwZS5nZXROZXN0ZWRQcm9wZXJ0eS5jYWxsKHRoaXMsIGgpKTtcbiAgICAgICAgdGhpcy5mb3JtYXRQcmVmaXggPSAodGhpcy5pc051bGwgPSBEKHRoaXMuaXNWYWxpZCAmJiAhdGhpcy5pc1ZhbGlkKCksIG51bGwgPT09IHRoaXMueCB8fCAhSih0aGlzLnkpKSkgPyBcIm51bGxcIiA6IFwicG9pbnRcIjtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCAmJiAodGhpcy5zdGF0ZSA9IFwic2VsZWN0XCIpO1xuICAgICAgICBcIm5hbWVcIiBpbiB0aGlzICYmIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBjICYmIGsueEF4aXMgJiYgay54QXhpcy5oYXNOYW1lcyAmJiAodGhpcy54ID0gay54QXhpcy5uYW1lVG9YKHRoaXMpKTtcbiAgICAgICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHRoaXMueCAmJiBrICYmICh0aGlzLnggPSBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgYyA/IGsuYXV0b0luY3JlbWVudCh0aGlzKSA6IGMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGUoKSB7XG4gICAgICAgICAgaWYgKGMuZ3JhcGhpYyB8fCBjLmRhdGFMYWJlbCB8fCBjLmRhdGFMYWJlbHMpIGgoYyksIGMuZGVzdHJveUVsZW1lbnRzKCk7XG5cbiAgICAgICAgICBmb3IgKGwgaW4gYykgY1tsXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHRoaXMsXG4gICAgICAgICAgICBkID0gYy5zZXJpZXMsXG4gICAgICAgICAgICBuID0gZC5jaGFydDtcbiAgICAgICAgZCA9IGQub3B0aW9ucy5kYXRhU29ydGluZztcbiAgICAgICAgdmFyIGYgPSBuLmhvdmVyUG9pbnRzLFxuICAgICAgICAgICAgYSA9IHIoYy5zZXJpZXMuY2hhcnQucmVuZGVyZXIuZ2xvYmFsQW5pbWF0aW9uKSxcbiAgICAgICAgICAgIGw7XG4gICAgICAgIGMubGVnZW5kSXRlbSAmJiBuLmxlZ2VuZC5kZXN0cm95SXRlbShjKTtcbiAgICAgICAgZiAmJiAoYy5zZXRTdGF0ZSgpLCBJKGYsIGMpLCBmLmxlbmd0aCB8fCAobi5ob3ZlclBvaW50cyA9IG51bGwpKTtcbiAgICAgICAgaWYgKGMgPT09IG4uaG92ZXJQb2ludCkgYy5vbk1vdXNlT3V0KCk7XG4gICAgICAgIGQgJiYgZC5lbmFibGVkID8gKHRoaXMuYW5pbWF0ZUJlZm9yZURlc3Ryb3koKSwgdChlLCBhLmR1cmF0aW9uKSkgOiBlKCk7XG4gICAgICAgIG4ucG9pbnRDb3VudC0tO1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUuZGVzdHJveUVsZW1lbnRzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzO1xuICAgICAgICBlID0gYy5nZXRHcmFwaGljYWxQcm9wcyhlKTtcbiAgICAgICAgZS5zaW5ndWxhci5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgY1tlXSA9IGNbZV0uZGVzdHJveSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgZS5wbHVyYWwuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGNbZV0uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgYy5lbGVtZW50ICYmIGMuZGVzdHJveSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlbGV0ZSBjW2VdO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLmZpcmVQb2ludEV2ZW50ID0gZnVuY3Rpb24gKGUsIGMsIGQpIHtcbiAgICAgICAgdmFyIGsgPSB0aGlzLFxuICAgICAgICAgICAgZiA9IHRoaXMuc2VyaWVzLm9wdGlvbnM7XG4gICAgICAgIChmLnBvaW50LmV2ZW50c1tlXSB8fCBrLm9wdGlvbnMgJiYgay5vcHRpb25zLmV2ZW50cyAmJiBrLm9wdGlvbnMuZXZlbnRzW2VdKSAmJiBrLmltcG9ydEV2ZW50cygpO1xuICAgICAgICBcImNsaWNrXCIgPT09IGUgJiYgZi5hbGxvd1BvaW50U2VsZWN0ICYmIChkID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBrLnNlbGVjdCAmJiBrLnNlbGVjdChudWxsLCBhLmN0cmxLZXkgfHwgYS5tZXRhS2V5IHx8IGEuc2hpZnRLZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcShrLCBlLCBjLCBkKTtcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiaGlnaGNoYXJ0cy1wb2ludFwiICsgKHRoaXMuc2VsZWN0ZWQgPyBcIiBoaWdoY2hhcnRzLXBvaW50LXNlbGVjdFwiIDogXCJcIikgKyAodGhpcy5uZWdhdGl2ZSA/IFwiIGhpZ2hjaGFydHMtbmVnYXRpdmVcIiA6IFwiXCIpICsgKHRoaXMuaXNOdWxsID8gXCIgaGlnaGNoYXJ0cy1udWxsLXBvaW50XCIgOiBcIlwiKSArIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgdGhpcy5jb2xvckluZGV4ID8gXCIgaGlnaGNoYXJ0cy1jb2xvci1cIiArIHRoaXMuY29sb3JJbmRleCA6IFwiXCIpICsgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUgPyBcIiBcIiArIHRoaXMub3B0aW9ucy5jbGFzc05hbWUgOiBcIlwiKSArICh0aGlzLnpvbmUgJiYgdGhpcy56b25lLmNsYXNzTmFtZSA/IFwiIFwiICsgdGhpcy56b25lLmNsYXNzTmFtZS5yZXBsYWNlKFwiaGlnaGNoYXJ0cy1uZWdhdGl2ZVwiLCBcIlwiKSA6IFwiXCIpO1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUuZ2V0R3JhcGhpY2FsUHJvcHMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgYyA9IHRoaXMsXG4gICAgICAgICAgICBkID0gW10sXG4gICAgICAgICAgICBoLFxuICAgICAgICAgICAgZiA9IHtcbiAgICAgICAgICBzaW5ndWxhcjogW10sXG4gICAgICAgICAgcGx1cmFsOiBbXVxuICAgICAgICB9O1xuICAgICAgICBlID0gZSB8fCB7XG4gICAgICAgICAgZ3JhcGhpYzogMSxcbiAgICAgICAgICBkYXRhTGFiZWw6IDFcbiAgICAgICAgfTtcbiAgICAgICAgZS5ncmFwaGljICYmIGQucHVzaChcImdyYXBoaWNcIiwgXCJzaGFkb3dHcm91cFwiKTtcbiAgICAgICAgZS5kYXRhTGFiZWwgJiYgZC5wdXNoKFwiZGF0YUxhYmVsXCIsIFwiZGF0YUxhYmVsVXBwZXJcIiwgXCJjb25uZWN0b3JcIik7XG5cbiAgICAgICAgZm9yIChoID0gZC5sZW5ndGg7IGgtLTspIHtcbiAgICAgICAgICB2YXIgYSA9IGRbaF07XG4gICAgICAgICAgY1thXSAmJiBmLnNpbmd1bGFyLnB1c2goYSk7XG4gICAgICAgIH1cblxuICAgICAgICBbXCJkYXRhTGFiZWxcIiwgXCJjb25uZWN0b3JcIl0uZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHZhciBkID0gYSArIFwic1wiO1xuICAgICAgICAgIGVbYV0gJiYgY1tkXSAmJiBmLnBsdXJhbC5wdXNoKGQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS5nZXRMYWJlbENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB0aGlzLmNhdGVnb3J5LFxuICAgICAgICAgIHk6IHRoaXMueSxcbiAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICBjb2xvckluZGV4OiB0aGlzLmNvbG9ySW5kZXgsXG4gICAgICAgICAga2V5OiB0aGlzLm5hbWUgfHwgdGhpcy5jYXRlZ29yeSxcbiAgICAgICAgICBzZXJpZXM6IHRoaXMuc2VyaWVzLFxuICAgICAgICAgIHBvaW50OiB0aGlzLFxuICAgICAgICAgIHBlcmNlbnRhZ2U6IHRoaXMucGVyY2VudGFnZSxcbiAgICAgICAgICB0b3RhbDogdGhpcy50b3RhbCB8fCB0aGlzLnN0YWNrVG90YWxcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLmdldE5lc3RlZFByb3BlcnR5ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUpIHJldHVybiAwID09PSBlLmluZGV4T2YoXCJjdXN0b20uXCIpID8gQShlLCB0aGlzLm9wdGlvbnMpIDogdGhpc1tlXTtcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLmdldFpvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5zZXJpZXMsXG4gICAgICAgICAgICBjID0gZS56b25lcztcbiAgICAgICAgZSA9IGUuem9uZUF4aXMgfHwgXCJ5XCI7XG4gICAgICAgIHZhciBkID0gMCxcbiAgICAgICAgICAgIGg7XG5cbiAgICAgICAgZm9yIChoID0gY1tkXTsgdGhpc1tlXSA+PSBoLnZhbHVlOykgaCA9IGNbKytkXTtcblxuICAgICAgICB0aGlzLm5vblpvbmVkQ29sb3IgfHwgKHRoaXMubm9uWm9uZWRDb2xvciA9IHRoaXMuY29sb3IpO1xuICAgICAgICB0aGlzLmNvbG9yID0gaCAmJiBoLmNvbG9yICYmICF0aGlzLm9wdGlvbnMuY29sb3IgPyBoLmNvbG9yIDogdGhpcy5ub25ab25lZENvbG9yO1xuICAgICAgICByZXR1cm4gaDtcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLmhhc05ld1NoYXBlVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmdyYXBoaWMgJiYgKHRoaXMuZ3JhcGhpYy5zeW1ib2xOYW1lIHx8IHRoaXMuZ3JhcGhpYy5lbGVtZW50Lm5vZGVOYW1lKSkgIT09IHRoaXMuc2hhcGVUeXBlO1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChlLCBjLCBkKSB7XG4gICAgICAgIHRoaXMuc2VyaWVzID0gZTtcbiAgICAgICAgdGhpcy5hcHBseU9wdGlvbnMoYywgZCk7XG4gICAgICAgIHRoaXMuaWQgPSB1KHRoaXMuaWQpID8gdGhpcy5pZCA6IE4oKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlQ29sb3IoKTtcbiAgICAgICAgZS5jaGFydC5wb2ludENvdW50Kys7XG4gICAgICAgIHEodGhpcywgXCJhZnRlckluaXRcIik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUub3B0aW9uc1RvT2JqZWN0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGMgPSB7fSxcbiAgICAgICAgICAgIGsgPSB0aGlzLnNlcmllcyxcbiAgICAgICAgICAgIGggPSBrLm9wdGlvbnMua2V5cyxcbiAgICAgICAgICAgIGYgPSBoIHx8IGsucG9pbnRBcnJheU1hcCB8fCBbXCJ5XCJdLFxuICAgICAgICAgICAgYSA9IGYubGVuZ3RoLFxuICAgICAgICAgICAgbCA9IDAsXG4gICAgICAgICAgICBnID0gMDtcbiAgICAgICAgaWYgKEooZSkgfHwgbnVsbCA9PT0gZSkgY1tmWzBdXSA9IGU7ZWxzZSBpZiAoRyhlKSkgZm9yICghaCAmJiBlLmxlbmd0aCA+IGEgJiYgKGsgPSB0eXBlb2YgZVswXSwgXCJzdHJpbmdcIiA9PT0gayA/IGMubmFtZSA9IGVbMF0gOiBcIm51bWJlclwiID09PSBrICYmIChjLnggPSBlWzBdKSwgbCsrKTsgZyA8IGE7KSBoICYmIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBlW2xdIHx8ICgwIDwgZltnXS5pbmRleE9mKFwiLlwiKSA/IGQucHJvdG90eXBlLnNldE5lc3RlZFByb3BlcnR5KGMsIGVbbF0sIGZbZ10pIDogY1tmW2ddXSA9IGVbbF0pLCBsKyssIGcrKztlbHNlIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlICYmIChjID0gZSwgZS5kYXRhTGFiZWxzICYmIChrLl9oYXNQb2ludExhYmVscyA9ICEwKSwgZS5tYXJrZXIgJiYgKGsuX2hhc1BvaW50TWFya2VycyA9ICEwKSk7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfTtcblxuICAgICAgZC5wcm90b3R5cGUucmVzb2x2ZUNvbG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuc2VyaWVzO1xuICAgICAgICB2YXIgYyA9IGUuY2hhcnQub3B0aW9ucy5jaGFydC5jb2xvckNvdW50O1xuICAgICAgICB2YXIgZCA9IGUuY2hhcnQuc3R5bGVkTW9kZTtcbiAgICAgICAgZCB8fCB0aGlzLm9wdGlvbnMuY29sb3IgfHwgKHRoaXMuY29sb3IgPSBlLmNvbG9yKTtcbiAgICAgICAgZS5vcHRpb25zLmNvbG9yQnlQb2ludCA/IChkIHx8IChjID0gZS5vcHRpb25zLmNvbG9ycyB8fCBlLmNoYXJ0Lm9wdGlvbnMuY29sb3JzLCB0aGlzLmNvbG9yID0gdGhpcy5jb2xvciB8fCBjW2UuY29sb3JDb3VudGVyXSwgYyA9IGMubGVuZ3RoKSwgZCA9IGUuY29sb3JDb3VudGVyLCBlLmNvbG9yQ291bnRlcisrLCBlLmNvbG9yQ291bnRlciA9PT0gYyAmJiAoZS5jb2xvckNvdW50ZXIgPSAwKSkgOiBkID0gZS5jb2xvckluZGV4O1xuICAgICAgICB0aGlzLmNvbG9ySW5kZXggPSBEKHRoaXMuY29sb3JJbmRleCwgZCk7XG4gICAgICB9O1xuXG4gICAgICBkLnByb3RvdHlwZS5zZXROZXN0ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChlLCBjLCBkKSB7XG4gICAgICAgIGQuc3BsaXQoXCIuXCIpLnJlZHVjZShmdW5jdGlvbiAoZSwgZiwgYSwgZCkge1xuICAgICAgICAgIGVbZl0gPSBkLmxlbmd0aCAtIDEgPT09IGEgPyBjIDogeShlW2ZdLCAhMCkgPyBlW2ZdIDoge307XG4gICAgICAgICAgcmV0dXJuIGVbZl07XG4gICAgICAgIH0sIGUpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH07XG5cbiAgICAgIGQucHJvdG90eXBlLnRvb2x0aXBGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgYyA9IHRoaXMuc2VyaWVzLFxuICAgICAgICAgICAgZCA9IGMudG9vbHRpcE9wdGlvbnMsXG4gICAgICAgICAgICBoID0gRChkLnZhbHVlRGVjaW1hbHMsIFwiXCIpLFxuICAgICAgICAgICAgZiA9IGQudmFsdWVQcmVmaXggfHwgXCJcIixcbiAgICAgICAgICAgIGEgPSBkLnZhbHVlU3VmZml4IHx8IFwiXCI7XG4gICAgICAgIGMuY2hhcnQuc3R5bGVkTW9kZSAmJiAoZSA9IGMuY2hhcnQudG9vbHRpcC5zdHlsZWRNb2RlRm9ybWF0KGUpKTtcbiAgICAgICAgKGMucG9pbnRBcnJheU1hcCB8fCBbXCJ5XCJdKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgYyA9IFwie3BvaW50LlwiICsgYztcbiAgICAgICAgICBpZiAoZiB8fCBhKSBlID0gZS5yZXBsYWNlKFJlZ0V4cChjICsgXCJ9XCIsIFwiZ1wiKSwgZiArIGMgKyBcIn1cIiArIGEpO1xuICAgICAgICAgIGUgPSBlLnJlcGxhY2UoUmVnRXhwKGMgKyBcIn1cIiwgXCJnXCIpLCBjICsgXCI6LC5cIiArIGggKyBcImZ9XCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEUoZSwge1xuICAgICAgICAgIHBvaW50OiB0aGlzLFxuICAgICAgICAgIHNlcmllczogdGhpcy5zZXJpZXNcbiAgICAgICAgfSwgYy5jaGFydCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZDtcbiAgICB9KCk7XG5cbiAgICBkLlBvaW50ID0gZztcbiAgICByZXR1cm4gZC5Qb2ludDtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9TZXJpZXMuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wibWl4aW5zL2xlZ2VuZC1zeW1ib2wuanNcIl0sIHJbXCJwYXJ0cy9Qb2ludC5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnLCByLCB1KSB7XG4gICAgXCJcIjtcblxuICAgIHZhciBJID0gdS5hZGRFdmVudCxcbiAgICAgICAgTSA9IHUuYW5pbU9iamVjdCxcbiAgICAgICAgRSA9IHUuYXJyYXlNYXgsXG4gICAgICAgIEEgPSB1LmFycmF5TWluLFxuICAgICAgICBHID0gdS5jbGFtcCxcbiAgICAgICAgSiA9IHUuY29ycmVjdEZsb2F0LFxuICAgICAgICB5ID0gdS5kZWZpbmVkLFxuICAgICAgICB0ID0gdS5lcmFzZSxcbiAgICAgICAgRCA9IHUuZXJyb3IsXG4gICAgICAgIGggPSB1LmV4dGVuZCxcbiAgICAgICAgTiA9IHUuZmluZCxcbiAgICAgICAgcSA9IHUuZmlyZUV2ZW50LFxuICAgICAgICBQID0gdS5nZXROZXN0ZWRQcm9wZXJ0eSxcbiAgICAgICAgZSA9IHUuaXNBcnJheSxcbiAgICAgICAgYyA9IHUuaXNGdW5jdGlvbixcbiAgICAgICAgayA9IHUuaXNOdW1iZXIsXG4gICAgICAgIG4gPSB1LmlzU3RyaW5nLFxuICAgICAgICBmID0gdS5tZXJnZSxcbiAgICAgICAgYSA9IHUub2JqZWN0RWFjaCxcbiAgICAgICAgbCA9IHUucGljayxcbiAgICAgICAgdiA9IHUucmVtb3ZlRXZlbnQsXG4gICAgICAgIHogPSB1LnNlcmllc1R5cGUsXG4gICAgICAgIHcgPSB1LnNwbGF0LFxuICAgICAgICBCID0gdS5zeW5jVGltZW91dCxcbiAgICAgICAgTCA9IGQuZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgIFEgPSBkLmRlZmF1bHRQbG90T3B0aW9ucyxcbiAgICAgICAgSCA9IGQuc2VyaWVzVHlwZXMsXG4gICAgICAgIEsgPSBkLlNWR0VsZW1lbnQsXG4gICAgICAgIHAgPSBkLndpbjtcbiAgICBkLlNlcmllcyA9IHooXCJsaW5lXCIsIG51bGwsIHtcbiAgICAgIGxpbmVXaWR0aDogMixcbiAgICAgIGFsbG93UG9pbnRTZWxlY3Q6ICExLFxuICAgICAgc2hvd0NoZWNrYm94OiAhMSxcbiAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICBkdXJhdGlvbjogMUUzXG4gICAgICB9LFxuICAgICAgZXZlbnRzOiB7fSxcbiAgICAgIG1hcmtlcjoge1xuICAgICAgICBlbmFibGVkVGhyZXNob2xkOiAyLFxuICAgICAgICBsaW5lQ29sb3I6IFwiI2ZmZmZmZlwiLFxuICAgICAgICBsaW5lV2lkdGg6IDAsXG4gICAgICAgIHJhZGl1czogNCxcbiAgICAgICAgc3RhdGVzOiB7XG4gICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICBhbmltYXRpb246ICEwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBob3Zlcjoge1xuICAgICAgICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAgICAgIGR1cmF0aW9uOiA1MFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuYWJsZWQ6ICEwLFxuICAgICAgICAgICAgcmFkaXVzUGx1czogMixcbiAgICAgICAgICAgIGxpbmVXaWR0aFBsdXM6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgZmlsbENvbG9yOiBcIiNjY2NjY2NcIixcbiAgICAgICAgICAgIGxpbmVDb2xvcjogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwb2ludDoge1xuICAgICAgICBldmVudHM6IHt9XG4gICAgICB9LFxuICAgICAgZGF0YUxhYmVsczoge1xuICAgICAgICBhbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGIgPSB0aGlzLnNlcmllcy5jaGFydC5udW1iZXJGb3JtYXR0ZXI7XG4gICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCIgIT09IHR5cGVvZiB0aGlzLnkgPyBcIlwiIDogYih0aGlzLnksIC0xKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFkZGluZzogNSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBmb250U2l6ZTogXCIxMXB4XCIsXG4gICAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIsXG4gICAgICAgICAgY29sb3I6IFwiY29udHJhc3RcIixcbiAgICAgICAgICB0ZXh0T3V0bGluZTogXCIxcHggY29udHJhc3RcIlxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcImJvdHRvbVwiLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LFxuICAgICAgY3JvcFRocmVzaG9sZDogMzAwLFxuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHBvaW50UmFuZ2U6IDAsXG4gICAgICBzb2Z0VGhyZXNob2xkOiAhMCxcbiAgICAgIHN0YXRlczoge1xuICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICBhbmltYXRpb246ICEwXG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAgICBkdXJhdGlvbjogNTBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxpbmVXaWR0aFBsdXM6IDEsXG4gICAgICAgICAgbWFya2VyOiB7fSxcbiAgICAgICAgICBoYWxvOiB7XG4gICAgICAgICAgICBzaXplOiAxMCxcbiAgICAgICAgICAgIG9wYWNpdHk6IC4yNVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW5hY3RpdmU6IHtcbiAgICAgICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiA1MFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb3BhY2l0eTogLjJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN0aWNreVRyYWNraW5nOiAhMCxcbiAgICAgIHR1cmJvVGhyZXNob2xkOiAxRTMsXG4gICAgICBmaW5kTmVhcmVzdFBvaW50Qnk6IFwieFwiXG4gICAgfSwge1xuICAgICAgYXhpc1R5cGVzOiBbXCJ4QXhpc1wiLCBcInlBeGlzXCJdLFxuICAgICAgY29sbDogXCJzZXJpZXNcIixcbiAgICAgIGNvbG9yQ291bnRlcjogMCxcbiAgICAgIGNyb3BTaG91bGRlcjogMSxcbiAgICAgIGRpcmVjdFRvdWNoOiAhMSxcbiAgICAgIGV2ZW50c1RvVW5iaW5kOiBbXSxcbiAgICAgIGlzQ2FydGVzaWFuOiAhMCxcbiAgICAgIHBhcmFsbGVsQXJyYXlzOiBbXCJ4XCIsIFwieVwiXSxcbiAgICAgIHBvaW50Q2xhc3M6IHIsXG4gICAgICByZXF1aXJlU29ydGluZzogITAsXG4gICAgICBzb3J0ZWQ6ICEwLFxuICAgICAgaW5pdDogZnVuY3Rpb24gKGIsIGUpIHtcbiAgICAgICAgcSh0aGlzLCBcImluaXRcIiwge1xuICAgICAgICAgIG9wdGlvbnM6IGVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBmID0gdGhpcyxcbiAgICAgICAgICAgIGQgPSBiLnNlcmllcyxcbiAgICAgICAgICAgIGs7XG4gICAgICAgIHRoaXMuZXZlbnRPcHRpb25zID0gdGhpcy5ldmVudE9wdGlvbnMgfHwge307XG4gICAgICAgIGYuY2hhcnQgPSBiO1xuICAgICAgICBmLm9wdGlvbnMgPSBlID0gZi5zZXRPcHRpb25zKGUpO1xuICAgICAgICBmLmxpbmtlZFNlcmllcyA9IFtdO1xuICAgICAgICBmLmJpbmRBeGVzKCk7XG4gICAgICAgIGgoZiwge1xuICAgICAgICAgIG5hbWU6IGUubmFtZSxcbiAgICAgICAgICBzdGF0ZTogXCJcIixcbiAgICAgICAgICB2aXNpYmxlOiAhMSAhPT0gZS52aXNpYmxlLFxuICAgICAgICAgIHNlbGVjdGVkOiAhMCA9PT0gZS5zZWxlY3RlZFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHAgPSBlLmV2ZW50cztcbiAgICAgICAgYShwLCBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIGMoYikgJiYgZi5ldmVudE9wdGlvbnNbYV0gIT09IGIgJiYgKGMoZi5ldmVudE9wdGlvbnNbYV0pICYmIHYoZiwgYSwgZi5ldmVudE9wdGlvbnNbYV0pLCBmLmV2ZW50T3B0aW9uc1thXSA9IGIsIEkoZiwgYSwgYikpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHAgJiYgcC5jbGljayB8fCBlLnBvaW50ICYmIGUucG9pbnQuZXZlbnRzICYmIGUucG9pbnQuZXZlbnRzLmNsaWNrIHx8IGUuYWxsb3dQb2ludFNlbGVjdCkgYi5ydW5UcmFja2VyQ2xpY2sgPSAhMDtcbiAgICAgICAgZi5nZXRDb2xvcigpO1xuICAgICAgICBmLmdldFN5bWJvbCgpO1xuICAgICAgICBmLnBhcmFsbGVsQXJyYXlzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICBmW2IgKyBcIkRhdGFcIl0gfHwgKGZbYiArIFwiRGF0YVwiXSA9IFtdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGYuaXNDYXJ0ZXNpYW4gJiYgKGIuaGFzQ2FydGVzaWFuU2VyaWVzID0gITApO1xuICAgICAgICBkLmxlbmd0aCAmJiAoayA9IGRbZC5sZW5ndGggLSAxXSk7XG4gICAgICAgIGYuX2kgPSBsKGsgJiYgay5faSwgLTEpICsgMTtcbiAgICAgICAgYi5vcmRlclNlcmllcyh0aGlzLmluc2VydChkKSk7XG4gICAgICAgIGUuZGF0YVNvcnRpbmcgJiYgZS5kYXRhU29ydGluZy5lbmFibGVkID8gZi5zZXREYXRhU29ydGluZ09wdGlvbnMoKSA6IGYucG9pbnRzIHx8IGYuZGF0YSB8fCBmLnNldERhdGEoZS5kYXRhLCAhMSk7XG4gICAgICAgIHEodGhpcywgXCJhZnRlckluaXRcIik7XG4gICAgICB9LFxuICAgICAgaXM6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHJldHVybiBIW2JdICYmIHRoaXMgaW5zdGFuY2VvZiBIW2JdO1xuICAgICAgfSxcbiAgICAgIGluc2VydDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9wdGlvbnMuaW5kZXgsXG4gICAgICAgICAgICBjO1xuXG4gICAgICAgIGlmIChrKGEpKSB7XG4gICAgICAgICAgZm9yIChjID0gYi5sZW5ndGg7IGMtLTspIGlmIChhID49IGwoYltjXS5vcHRpb25zLmluZGV4LCBiW2NdLl9pKSkge1xuICAgICAgICAgICAgYi5zcGxpY2UoYyArIDEsIDAsIHRoaXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLTEgPT09IGMgJiYgYi51bnNoaWZ0KHRoaXMpO1xuICAgICAgICAgIGMgKz0gMTtcbiAgICAgICAgfSBlbHNlIGIucHVzaCh0aGlzKTtcblxuICAgICAgICByZXR1cm4gbChjLCBiLmxlbmd0aCAtIDEpO1xuICAgICAgfSxcbiAgICAgIGJpbmRBeGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcyxcbiAgICAgICAgICAgIGEgPSBiLm9wdGlvbnMsXG4gICAgICAgICAgICBjID0gYi5jaGFydCxcbiAgICAgICAgICAgIGU7XG4gICAgICAgIHEodGhpcywgXCJiaW5kQXhlc1wiLCBudWxsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgKGIuYXhpc1R5cGVzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICBjW2ZdLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgZSA9IGMub3B0aW9ucztcbiAgICAgICAgICAgICAgaWYgKGFbZl0gPT09IGUuaW5kZXggfHwgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGFbZl0gJiYgYVtmXSA9PT0gZS5pZCB8fCBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgYVtmXSAmJiAwID09PSBlLmluZGV4KSBiLmluc2VydChjLnNlcmllcyksIGJbZl0gPSBjLCBjLmlzRGlydHkgPSAhMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYltmXSB8fCBiLm9wdGlvbmFsQXhpcyA9PT0gZiB8fCBEKDE4LCAhMCwgYyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJCaW5kQXhlc1wiKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVQYXJhbGxlbEFycmF5czogZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgdmFyIGMgPSBiLnNlcmllcyxcbiAgICAgICAgICAgIGUgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBmID0gayhhKSA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIGYgPSBcInlcIiA9PT0gZSAmJiBjLnRvWURhdGEgPyBjLnRvWURhdGEoYikgOiBiW2VdO1xuICAgICAgICAgIGNbZSArIFwiRGF0YVwiXVthXSA9IGY7XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoYikge1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZVthXS5hcHBseShjW2IgKyBcIkRhdGFcIl0sIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUsIDIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgYy5wYXJhbGxlbEFycmF5cy5mb3JFYWNoKGYpO1xuICAgICAgfSxcbiAgICAgIGhhc0RhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZSAmJiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgdGhpcy5kYXRhTWF4ICYmIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiB0aGlzLmRhdGFNaW4gfHwgdGhpcy52aXNpYmxlICYmIHRoaXMueURhdGEgJiYgMCA8IHRoaXMueURhdGEubGVuZ3RoO1xuICAgICAgfSxcbiAgICAgIGF1dG9JbmNyZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBhID0gdGhpcy54SW5jcmVtZW50LFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIGUgPSBiLnBvaW50SW50ZXJ2YWxVbml0LFxuICAgICAgICAgICAgZiA9IHRoaXMuY2hhcnQudGltZTtcbiAgICAgICAgYSA9IGwoYSwgYi5wb2ludFN0YXJ0LCAwKTtcbiAgICAgICAgdGhpcy5wb2ludEludGVydmFsID0gYyA9IGwodGhpcy5wb2ludEludGVydmFsLCBiLnBvaW50SW50ZXJ2YWwsIDEpO1xuICAgICAgICBlICYmIChiID0gbmV3IGYuRGF0ZShhKSwgXCJkYXlcIiA9PT0gZSA/IGYuc2V0KFwiRGF0ZVwiLCBiLCBmLmdldChcIkRhdGVcIiwgYikgKyBjKSA6IFwibW9udGhcIiA9PT0gZSA/IGYuc2V0KFwiTW9udGhcIiwgYiwgZi5nZXQoXCJNb250aFwiLCBiKSArIGMpIDogXCJ5ZWFyXCIgPT09IGUgJiYgZi5zZXQoXCJGdWxsWWVhclwiLCBiLCBmLmdldChcIkZ1bGxZZWFyXCIsIGIpICsgYyksIGMgPSBiLmdldFRpbWUoKSAtIGEpO1xuICAgICAgICB0aGlzLnhJbmNyZW1lbnQgPSBhICsgYztcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9LFxuICAgICAgc2V0RGF0YVNvcnRpbmdPcHRpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBoKHRoaXMsIHtcbiAgICAgICAgICByZXF1aXJlU29ydGluZzogITEsXG4gICAgICAgICAgc29ydGVkOiAhMSxcbiAgICAgICAgICBlbmFibGVkRGF0YVNvcnRpbmc6ICEwLFxuICAgICAgICAgIGFsbG93REc6ICExXG4gICAgICAgIH0pO1xuICAgICAgICB5KGIucG9pbnRSYW5nZSkgfHwgKGIucG9pbnRSYW5nZSA9IDEpO1xuICAgICAgfSxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGMgPSBhLm9wdGlvbnMsXG4gICAgICAgICAgICBlID0gYy5wbG90T3B0aW9ucyxcbiAgICAgICAgICAgIGQgPSBhLnVzZXJPcHRpb25zIHx8IHt9O1xuICAgICAgICBiID0gZihiKTtcbiAgICAgICAgYSA9IGEuc3R5bGVkTW9kZTtcbiAgICAgICAgdmFyIGsgPSB7XG4gICAgICAgICAgcGxvdE9wdGlvbnM6IGUsXG4gICAgICAgICAgdXNlck9wdGlvbnM6IGJcbiAgICAgICAgfTtcbiAgICAgICAgcSh0aGlzLCBcInNldE9wdGlvbnNcIiwgayk7XG4gICAgICAgIHZhciBoID0gay5wbG90T3B0aW9uc1t0aGlzLnR5cGVdLFxuICAgICAgICAgICAgbSA9IGQucGxvdE9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMudXNlck9wdGlvbnMgPSBrLnVzZXJPcHRpb25zO1xuICAgICAgICBkID0gZihoLCBlLnNlcmllcywgZC5wbG90T3B0aW9ucyAmJiBkLnBsb3RPcHRpb25zW3RoaXMudHlwZV0sIGIpO1xuICAgICAgICB0aGlzLnRvb2x0aXBPcHRpb25zID0gZihMLnRvb2x0aXAsIEwucGxvdE9wdGlvbnMuc2VyaWVzICYmIEwucGxvdE9wdGlvbnMuc2VyaWVzLnRvb2x0aXAsIEwucGxvdE9wdGlvbnNbdGhpcy50eXBlXS50b29sdGlwLCBjLnRvb2x0aXAudXNlck9wdGlvbnMsIGUuc2VyaWVzICYmIGUuc2VyaWVzLnRvb2x0aXAsIGVbdGhpcy50eXBlXS50b29sdGlwLCBiLnRvb2x0aXApO1xuICAgICAgICB0aGlzLnN0aWNreVRyYWNraW5nID0gbChiLnN0aWNreVRyYWNraW5nLCBtW3RoaXMudHlwZV0gJiYgbVt0aGlzLnR5cGVdLnN0aWNreVRyYWNraW5nLCBtLnNlcmllcyAmJiBtLnNlcmllcy5zdGlja3lUcmFja2luZywgdGhpcy50b29sdGlwT3B0aW9ucy5zaGFyZWQgJiYgIXRoaXMubm9TaGFyZWRUb29sdGlwID8gITAgOiBkLnN0aWNreVRyYWNraW5nKTtcbiAgICAgICAgbnVsbCA9PT0gaC5tYXJrZXIgJiYgZGVsZXRlIGQubWFya2VyO1xuICAgICAgICB0aGlzLnpvbmVBeGlzID0gZC56b25lQXhpcztcbiAgICAgICAgYyA9IHRoaXMuem9uZXMgPSAoZC56b25lcyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgIWQubmVnYXRpdmVDb2xvciAmJiAhZC5uZWdhdGl2ZUZpbGxDb2xvciB8fCBkLnpvbmVzIHx8IChlID0ge1xuICAgICAgICAgIHZhbHVlOiBkW3RoaXMuem9uZUF4aXMgKyBcIlRocmVzaG9sZFwiXSB8fCBkLnRocmVzaG9sZCB8fCAwLFxuICAgICAgICAgIGNsYXNzTmFtZTogXCJoaWdoY2hhcnRzLW5lZ2F0aXZlXCJcbiAgICAgICAgfSwgYSB8fCAoZS5jb2xvciA9IGQubmVnYXRpdmVDb2xvciwgZS5maWxsQ29sb3IgPSBkLm5lZ2F0aXZlRmlsbENvbG9yKSwgYy5wdXNoKGUpKTtcbiAgICAgICAgYy5sZW5ndGggJiYgeShjW2MubGVuZ3RoIC0gMV0udmFsdWUpICYmIGMucHVzaChhID8ge30gOiB7XG4gICAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgICAgZmlsbENvbG9yOiB0aGlzLmZpbGxDb2xvclxuICAgICAgICB9KTtcbiAgICAgICAgcSh0aGlzLCBcImFmdGVyU2V0T3B0aW9uc1wiLCB7XG4gICAgICAgICAgb3B0aW9uczogZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9LFxuICAgICAgZ2V0TmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbCh0aGlzLm9wdGlvbnMubmFtZSwgXCJTZXJpZXMgXCIgKyAodGhpcy5pbmRleCArIDEpKTtcbiAgICAgIH0sXG4gICAgICBnZXRDeWNsaWM6IGZ1bmN0aW9uIChiLCBhLCBjKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGYgPSB0aGlzLnVzZXJPcHRpb25zLFxuICAgICAgICAgICAgZCA9IGIgKyBcIkluZGV4XCIsXG4gICAgICAgICAgICBrID0gYiArIFwiQ291bnRlclwiLFxuICAgICAgICAgICAgaCA9IGMgPyBjLmxlbmd0aCA6IGwoZS5vcHRpb25zLmNoYXJ0W2IgKyBcIkNvdW50XCJdLCBlW2IgKyBcIkNvdW50XCJdKTtcblxuICAgICAgICBpZiAoIWEpIHtcbiAgICAgICAgICB2YXIgcCA9IGwoZltkXSwgZltcIl9cIiArIGRdKTtcbiAgICAgICAgICB5KHApIHx8IChlLnNlcmllcy5sZW5ndGggfHwgKGVba10gPSAwKSwgZltcIl9cIiArIGRdID0gcCA9IGVba10gJSBoLCBlW2tdICs9IDEpO1xuICAgICAgICAgIGMgJiYgKGEgPSBjW3BdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBwICYmICh0aGlzW2RdID0gcCk7XG4gICAgICAgIHRoaXNbYl0gPSBhO1xuICAgICAgfSxcbiAgICAgIGdldENvbG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2hhcnQuc3R5bGVkTW9kZSA/IHRoaXMuZ2V0Q3ljbGljKFwiY29sb3JcIikgOiB0aGlzLm9wdGlvbnMuY29sb3JCeVBvaW50ID8gdGhpcy5vcHRpb25zLmNvbG9yID0gbnVsbCA6IHRoaXMuZ2V0Q3ljbGljKFwiY29sb3JcIiwgdGhpcy5vcHRpb25zLmNvbG9yIHx8IFFbdGhpcy50eXBlXS5jb2xvciwgdGhpcy5jaGFydC5vcHRpb25zLmNvbG9ycyk7XG4gICAgICB9LFxuICAgICAgZ2V0UG9pbnRzQ29sbGVjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaGFzR3JvdXBlZERhdGEgPyB0aGlzLnBvaW50cyA6IHRoaXMuZGF0YSkgfHwgW107XG4gICAgICB9LFxuICAgICAgZ2V0U3ltYm9sOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZ2V0Q3ljbGljKFwic3ltYm9sXCIsIHRoaXMub3B0aW9ucy5tYXJrZXIuc3ltYm9sLCB0aGlzLmNoYXJ0Lm9wdGlvbnMuc3ltYm9scyk7XG4gICAgICB9LFxuICAgICAgZmluZFBvaW50SW5kZXg6IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIHZhciBjID0gYi5pZCxcbiAgICAgICAgICAgIGUgPSBiLngsXG4gICAgICAgICAgICBmID0gdGhpcy5wb2ludHMsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgaCA9IHRoaXMub3B0aW9ucy5kYXRhU29ydGluZztcbiAgICAgICAgaWYgKGMpIHZhciBsID0gdGhpcy5jaGFydC5nZXQoYyk7ZWxzZSBpZiAodGhpcy5saW5rZWRQYXJlbnQgfHwgdGhpcy5lbmFibGVkRGF0YVNvcnRpbmcpIHtcbiAgICAgICAgICB2YXIgcCA9IGggJiYgaC5tYXRjaEJ5TmFtZSA/IFwibmFtZVwiIDogXCJpbmRleFwiO1xuICAgICAgICAgIGwgPSBOKGYsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gIWEudG91Y2hlZCAmJiBhW3BdID09PSBiW3BdO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghbCkgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGwpIHtcbiAgICAgICAgICB2YXIgbiA9IGwgJiYgbC5pbmRleDtcbiAgICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgbiAmJiAoZCA9ICEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBuICYmIGsoZSkgJiYgKG4gPSB0aGlzLnhEYXRhLmluZGV4T2YoZSwgYSkpO1xuICAgICAgICAtMSAhPT0gbiAmJiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgbiAmJiB0aGlzLmNyb3BwZWQgJiYgKG4gPSBuID49IHRoaXMuY3JvcFN0YXJ0ID8gbiAtIHRoaXMuY3JvcFN0YXJ0IDogbik7XG4gICAgICAgICFkICYmIGZbbl0gJiYgZltuXS50b3VjaGVkICYmIChuID0gdm9pZCAwKTtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9LFxuICAgICAgZHJhd0xlZ2VuZFN5bWJvbDogZy5kcmF3TGluZU1hcmtlcixcbiAgICAgIHVwZGF0ZURhdGE6IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgZSA9IGMuZGF0YVNvcnRpbmcsXG4gICAgICAgICAgICBmID0gdGhpcy5wb2ludHMsXG4gICAgICAgICAgICBkID0gW10sXG4gICAgICAgICAgICBoLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIG4sXG4gICAgICAgICAgICBwID0gdGhpcy5yZXF1aXJlU29ydGluZyxcbiAgICAgICAgICAgIGcgPSBiLmxlbmd0aCA9PT0gZi5sZW5ndGgsXG4gICAgICAgICAgICB3ID0gITA7XG4gICAgICAgIHRoaXMueEluY3JlbWVudCA9IG51bGw7XG4gICAgICAgIGIuZm9yRWFjaChmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIHZhciBsID0geShiKSAmJiB0aGlzLnBvaW50Q2xhc3MucHJvdG90eXBlLm9wdGlvbnNUb09iamVjdC5jYWxsKHtcbiAgICAgICAgICAgIHNlcmllczogdGhpc1xuICAgICAgICAgIH0sIGIpIHx8IHt9O1xuICAgICAgICAgIHZhciBtID0gbC54O1xuXG4gICAgICAgICAgaWYgKGwuaWQgfHwgayhtKSkge1xuICAgICAgICAgICAgaWYgKG0gPSB0aGlzLmZpbmRQb2ludEluZGV4KGwsIG4pLCAtMSA9PT0gbSB8fCBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgbSA/IGQucHVzaChiKSA6IGZbbV0gJiYgYiAhPT0gYy5kYXRhW21dID8gKGZbbV0udXBkYXRlKGIsICExLCBudWxsLCAhMSksIGZbbV0udG91Y2hlZCA9ICEwLCBwICYmIChuID0gbSArIDEpKSA6IGZbbV0gJiYgKGZbbV0udG91Y2hlZCA9ICEwKSwgIWcgfHwgYSAhPT0gbSB8fCBlICYmIGUuZW5hYmxlZCB8fCB0aGlzLmhhc0Rlcml2ZWREYXRhKSBoID0gITA7XG4gICAgICAgICAgfSBlbHNlIGQucHVzaChiKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGlmIChoKSBmb3IgKGIgPSBmLmxlbmd0aDsgYi0tOykgKGwgPSBmW2JdKSAmJiAhbC50b3VjaGVkICYmIGwucmVtb3ZlICYmIGwucmVtb3ZlKCExLCBhKTtlbHNlICFnIHx8IGUgJiYgZS5lbmFibGVkID8gdyA9ICExIDogKGIuZm9yRWFjaChmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIGZbYV0udXBkYXRlICYmIGIgIT09IGZbYV0ueSAmJiBmW2FdLnVwZGF0ZShiLCAhMSwgbnVsbCwgITEpO1xuICAgICAgICB9KSwgZC5sZW5ndGggPSAwKTtcbiAgICAgICAgZi5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYiAmJiAoYi50b3VjaGVkID0gITEpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF3KSByZXR1cm4gITE7XG4gICAgICAgIGQuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHRoaXMuYWRkUG9pbnQoYiwgITEsIG51bGwsIG51bGwsICExKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIG51bGwgPT09IHRoaXMueEluY3JlbWVudCAmJiB0aGlzLnhEYXRhICYmIHRoaXMueERhdGEubGVuZ3RoICYmICh0aGlzLnhJbmNyZW1lbnQgPSBFKHRoaXMueERhdGEpLCB0aGlzLmF1dG9JbmNyZW1lbnQoKSk7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH0sXG4gICAgICBzZXREYXRhOiBmdW5jdGlvbiAoYiwgYSwgYywgZikge1xuICAgICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgICBoID0gZC5wb2ludHMsXG4gICAgICAgICAgICBwID0gaCAmJiBoLmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIGcgPSBkLm9wdGlvbnMsXG4gICAgICAgICAgICB3ID0gZC5jaGFydCxcbiAgICAgICAgICAgIHggPSBnLmRhdGFTb3J0aW5nLFxuICAgICAgICAgICAgcSA9IG51bGwsXG4gICAgICAgICAgICB2ID0gZC54QXhpcztcbiAgICAgICAgcSA9IGcudHVyYm9UaHJlc2hvbGQ7XG4gICAgICAgIHZhciBDID0gdGhpcy54RGF0YSxcbiAgICAgICAgICAgIHQgPSB0aGlzLnlEYXRhLFxuICAgICAgICAgICAgQiA9IChtID0gZC5wb2ludEFycmF5TWFwKSAmJiBtLmxlbmd0aCxcbiAgICAgICAgICAgIHogPSBnLmtleXMsXG4gICAgICAgICAgICB5ID0gMCxcbiAgICAgICAgICAgIEwgPSAxLFxuICAgICAgICAgICAgdTtcbiAgICAgICAgYiA9IGIgfHwgW107XG4gICAgICAgIG0gPSBiLmxlbmd0aDtcbiAgICAgICAgYSA9IGwoYSwgITApO1xuICAgICAgICB4ICYmIHguZW5hYmxlZCAmJiAoYiA9IHRoaXMuc29ydERhdGEoYikpO1xuICAgICAgICAhMSAhPT0gZiAmJiBtICYmIHAgJiYgIWQuY3JvcHBlZCAmJiAhZC5oYXNHcm91cGVkRGF0YSAmJiBkLnZpc2libGUgJiYgIWQuaXNTZXJpZXNCb29zdGluZyAmJiAodSA9IHRoaXMudXBkYXRlRGF0YShiLCBjKSk7XG5cbiAgICAgICAgaWYgKCF1KSB7XG4gICAgICAgICAgZC54SW5jcmVtZW50ID0gbnVsbDtcbiAgICAgICAgICBkLmNvbG9yQ291bnRlciA9IDA7XG4gICAgICAgICAgdGhpcy5wYXJhbGxlbEFycmF5cy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICBkW2IgKyBcIkRhdGFcIl0ubGVuZ3RoID0gMDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocSAmJiBtID4gcSkge1xuICAgICAgICAgICAgaWYgKHEgPSBkLmdldEZpcnN0VmFsaWRQb2ludChiKSwgayhxKSkgZm9yIChjID0gMDsgYyA8IG07IGMrKykgQ1tjXSA9IHRoaXMuYXV0b0luY3JlbWVudCgpLCB0W2NdID0gYltjXTtlbHNlIGlmIChlKHEpKSB7XG4gICAgICAgICAgICAgIGlmIChCKSBmb3IgKGMgPSAwOyBjIDwgbTsgYysrKSBmID0gYltjXSwgQ1tjXSA9IGZbMF0sIHRbY10gPSBmLnNsaWNlKDEsIEIgKyAxKTtlbHNlIGZvciAoeiAmJiAoeSA9IHouaW5kZXhPZihcInhcIiksIEwgPSB6LmluZGV4T2YoXCJ5XCIpLCB5ID0gMCA8PSB5ID8geSA6IDAsIEwgPSAwIDw9IEwgPyBMIDogMSksIGMgPSAwOyBjIDwgbTsgYysrKSBmID0gYltjXSwgQ1tjXSA9IGZbeV0sIHRbY10gPSBmW0xdO1xuICAgICAgICAgICAgfSBlbHNlIEQoMTIsICExLCB3KTtcbiAgICAgICAgICB9IGVsc2UgZm9yIChjID0gMDsgYyA8IG07IGMrKykgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGJbY10gJiYgKGYgPSB7XG4gICAgICAgICAgICBzZXJpZXM6IGRcbiAgICAgICAgICB9LCBkLnBvaW50Q2xhc3MucHJvdG90eXBlLmFwcGx5T3B0aW9ucy5hcHBseShmLCBbYltjXV0pLCBkLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKGYsIGMpKTtcbiAgICAgICAgICB0ICYmIG4odFswXSkgJiYgRCgxNCwgITAsIHcpO1xuICAgICAgICAgIGQuZGF0YSA9IFtdO1xuICAgICAgICAgIGQub3B0aW9ucy5kYXRhID0gZC51c2VyT3B0aW9ucy5kYXRhID0gYjtcblxuICAgICAgICAgIGZvciAoYyA9IHA7IGMtLTspIGhbY10gJiYgaFtjXS5kZXN0cm95ICYmIGhbY10uZGVzdHJveSgpO1xuXG4gICAgICAgICAgdiAmJiAodi5taW5SYW5nZSA9IHYudXNlck1pblJhbmdlKTtcbiAgICAgICAgICBkLmlzRGlydHkgPSB3LmlzRGlydHlCb3ggPSAhMDtcbiAgICAgICAgICBkLmlzRGlydHlEYXRhID0gISFoO1xuICAgICAgICAgIGMgPSAhMTtcbiAgICAgICAgfVxuXG4gICAgICAgIFwicG9pbnRcIiA9PT0gZy5sZWdlbmRUeXBlICYmICh0aGlzLnByb2Nlc3NEYXRhKCksIHRoaXMuZ2VuZXJhdGVQb2ludHMoKSk7XG4gICAgICAgIGEgJiYgdy5yZWRyYXcoYyk7XG4gICAgICB9LFxuICAgICAgc29ydERhdGE6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIGMgPSBhLm9wdGlvbnMuZGF0YVNvcnRpbmcuc29ydEtleSB8fCBcInlcIixcbiAgICAgICAgICAgIGUgPSBmdW5jdGlvbiAoYiwgYSkge1xuICAgICAgICAgIHJldHVybiB5KGEpICYmIGIucG9pbnRDbGFzcy5wcm90b3R5cGUub3B0aW9uc1RvT2JqZWN0LmNhbGwoe1xuICAgICAgICAgICAgc2VyaWVzOiBiXG4gICAgICAgICAgfSwgYSkgfHwge307XG4gICAgICAgIH07XG5cbiAgICAgICAgYi5mb3JFYWNoKGZ1bmN0aW9uIChjLCBmKSB7XG4gICAgICAgICAgYltmXSA9IGUoYSwgYyk7XG4gICAgICAgICAgYltmXS5pbmRleCA9IGY7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBiLmNvbmNhdCgpLnNvcnQoZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBiID0gUChjLCBiKTtcbiAgICAgICAgICBhID0gUChjLCBhKTtcbiAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBiLnggPSBhO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgYS5saW5rZWRTZXJpZXMgJiYgYS5saW5rZWRTZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHZhciBjID0gYS5vcHRpb25zLFxuICAgICAgICAgICAgICBmID0gYy5kYXRhO1xuICAgICAgICAgIGMuZGF0YVNvcnRpbmcgJiYgYy5kYXRhU29ydGluZy5lbmFibGVkIHx8ICFmIHx8IChmLmZvckVhY2goZnVuY3Rpb24gKGMsIGQpIHtcbiAgICAgICAgICAgIGZbZF0gPSBlKGEsIGMpO1xuICAgICAgICAgICAgYltkXSAmJiAoZltkXS54ID0gYltkXS54LCBmW2RdLmluZGV4ID0gZCk7XG4gICAgICAgICAgfSksIGEuc2V0RGF0YShmLCAhMSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9LFxuICAgICAgcHJvY2Vzc0RhdGE6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy54RGF0YSxcbiAgICAgICAgICAgIGMgPSB0aGlzLnlEYXRhLFxuICAgICAgICAgICAgZSA9IGEubGVuZ3RoO1xuICAgICAgICB2YXIgZiA9IDA7XG4gICAgICAgIHZhciBkID0gdGhpcy54QXhpcyxcbiAgICAgICAgICAgIGsgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBoID0gay5jcm9wVGhyZXNob2xkO1xuICAgICAgICB2YXIgbCA9IHRoaXMuZ2V0RXh0cmVtZXNGcm9tQWxsIHx8IGsuZ2V0RXh0cmVtZXNGcm9tQWxsLFxuICAgICAgICAgICAgcCA9IHRoaXMuaXNDYXJ0ZXNpYW47XG4gICAgICAgIGsgPSBkICYmIGQudmFsMmxpbjtcbiAgICAgICAgdmFyIG4gPSBkICYmIGQuaXNMb2csXG4gICAgICAgICAgICBnID0gdGhpcy5yZXF1aXJlU29ydGluZztcbiAgICAgICAgaWYgKHAgJiYgIXRoaXMuaXNEaXJ0eSAmJiAhZC5pc0RpcnR5ICYmICF0aGlzLnlBeGlzLmlzRGlydHkgJiYgIWIpIHJldHVybiAhMTtcblxuICAgICAgICBpZiAoZCkge1xuICAgICAgICAgIGIgPSBkLmdldEV4dHJlbWVzKCk7XG4gICAgICAgICAgdmFyIHcgPSBiLm1pbjtcbiAgICAgICAgICB2YXIgcSA9IGIubWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHAgJiYgdGhpcy5zb3J0ZWQgJiYgIWwgJiYgKCFoIHx8IGUgPiBoIHx8IHRoaXMuZm9yY2VDcm9wKSkgaWYgKGFbZSAtIDFdIDwgdyB8fCBhWzBdID4gcSkgYSA9IFtdLCBjID0gW107ZWxzZSBpZiAodGhpcy55RGF0YSAmJiAoYVswXSA8IHcgfHwgYVtlIC0gMV0gPiBxKSkge1xuICAgICAgICAgIGYgPSB0aGlzLmNyb3BEYXRhKHRoaXMueERhdGEsIHRoaXMueURhdGEsIHcsIHEpO1xuICAgICAgICAgIGEgPSBmLnhEYXRhO1xuICAgICAgICAgIGMgPSBmLnlEYXRhO1xuICAgICAgICAgIGYgPSBmLnN0YXJ0O1xuICAgICAgICAgIHZhciB2ID0gITA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGggPSBhLmxlbmd0aCB8fCAxOyAtLWg7KSBpZiAoZSA9IG4gPyBrKGFbaF0pIC0gayhhW2ggLSAxXSkgOiBhW2hdIC0gYVtoIC0gMV0sIDAgPCBlICYmIChcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgdCB8fCBlIDwgdCkpIHZhciB0ID0gZTtlbHNlIDAgPiBlICYmIGcgJiYgKEQoMTUsICExLCB0aGlzLmNoYXJ0KSwgZyA9ICExKTtcblxuICAgICAgICB0aGlzLmNyb3BwZWQgPSB2O1xuICAgICAgICB0aGlzLmNyb3BTdGFydCA9IGY7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkWERhdGEgPSBhO1xuICAgICAgICB0aGlzLnByb2Nlc3NlZFlEYXRhID0gYztcbiAgICAgICAgdGhpcy5jbG9zZXN0UG9pbnRSYW5nZSA9IHRoaXMuYmFzZVBvaW50UmFuZ2UgPSB0O1xuICAgICAgfSxcbiAgICAgIGNyb3BEYXRhOiBmdW5jdGlvbiAoYiwgYSwgYywgZSwgZikge1xuICAgICAgICB2YXIgZCA9IGIubGVuZ3RoLFxuICAgICAgICAgICAgayA9IDAsXG4gICAgICAgICAgICBoID0gZCxcbiAgICAgICAgICAgIHA7XG4gICAgICAgIGYgPSBsKGYsIHRoaXMuY3JvcFNob3VsZGVyKTtcblxuICAgICAgICBmb3IgKHAgPSAwOyBwIDwgZDsgcCsrKSBpZiAoYltwXSA+PSBjKSB7XG4gICAgICAgICAgayA9IE1hdGgubWF4KDAsIHAgLSBmKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoYyA9IHA7IGMgPCBkOyBjKyspIGlmIChiW2NdID4gZSkge1xuICAgICAgICAgIGggPSBjICsgZjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeERhdGE6IGIuc2xpY2UoaywgaCksXG4gICAgICAgICAgeURhdGE6IGEuc2xpY2UoaywgaCksXG4gICAgICAgICAgc3RhcnQ6IGssXG4gICAgICAgICAgZW5kOiBoXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZ2VuZXJhdGVQb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBhID0gYi5kYXRhLFxuICAgICAgICAgICAgYyA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGUsXG4gICAgICAgICAgICBmID0gdGhpcy5wcm9jZXNzZWRYRGF0YSxcbiAgICAgICAgICAgIGQgPSB0aGlzLnByb2Nlc3NlZFlEYXRhLFxuICAgICAgICAgICAgayA9IHRoaXMucG9pbnRDbGFzcyxcbiAgICAgICAgICAgIGwgPSBmLmxlbmd0aCxcbiAgICAgICAgICAgIHAgPSB0aGlzLmNyb3BTdGFydCB8fCAwLFxuICAgICAgICAgICAgbiA9IHRoaXMuaGFzR3JvdXBlZERhdGE7XG4gICAgICAgIGIgPSBiLmtleXM7XG4gICAgICAgIHZhciBnID0gW10sXG4gICAgICAgICAgICB2O1xuICAgICAgICBjIHx8IG4gfHwgKGMgPSBbXSwgYy5sZW5ndGggPSBhLmxlbmd0aCwgYyA9IHRoaXMuZGF0YSA9IGMpO1xuICAgICAgICBiICYmIG4gJiYgKHRoaXMub3B0aW9ucy5rZXlzID0gITEpO1xuXG4gICAgICAgIGZvciAodiA9IDA7IHYgPCBsOyB2KyspIHtcbiAgICAgICAgICB2YXIgdCA9IHAgKyB2O1xuXG4gICAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgIHZhciBCID0gbmV3IGsoKS5pbml0KHRoaXMsIFtmW3ZdXS5jb25jYXQodyhkW3ZdKSkpO1xuICAgICAgICAgICAgQi5kYXRhR3JvdXAgPSB0aGlzLmdyb3VwTWFwW3ZdO1xuICAgICAgICAgICAgQi5kYXRhR3JvdXAub3B0aW9ucyAmJiAoQi5vcHRpb25zID0gQi5kYXRhR3JvdXAub3B0aW9ucywgaChCLCBCLmRhdGFHcm91cC5vcHRpb25zKSwgZGVsZXRlIEIuZGF0YUxhYmVscyk7XG4gICAgICAgICAgfSBlbHNlIChCID0gY1t0XSkgfHwgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGFbdF0gfHwgKGNbdF0gPSBCID0gbmV3IGsoKS5pbml0KHRoaXMsIGFbdF0sIGZbdl0pKTtcblxuICAgICAgICAgIEIgJiYgKEIuaW5kZXggPSB0LCBnW3ZdID0gQik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9wdGlvbnMua2V5cyA9IGI7XG4gICAgICAgIGlmIChjICYmIChsICE9PSAoZSA9IGMubGVuZ3RoKSB8fCBuKSkgZm9yICh2ID0gMDsgdiA8IGU7IHYrKykgdiAhPT0gcCB8fCBuIHx8ICh2ICs9IGwpLCBjW3ZdICYmIChjW3ZdLmRlc3Ryb3lFbGVtZW50cygpLCBjW3ZdLnBsb3RYID0gdm9pZCAwKTtcbiAgICAgICAgdGhpcy5kYXRhID0gYztcbiAgICAgICAgdGhpcy5wb2ludHMgPSBnO1xuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJHZW5lcmF0ZVBvaW50c1wiKTtcbiAgICAgIH0sXG4gICAgICBnZXRYRXh0cmVtZXM6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWluOiBBKGIpLFxuICAgICAgICAgIG1heDogRShiKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGdldEV4dHJlbWVzOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXMueEF4aXMsXG4gICAgICAgICAgICBjID0gdGhpcy55QXhpcyxcbiAgICAgICAgICAgIGYgPSB0aGlzLnByb2Nlc3NlZFhEYXRhIHx8IHRoaXMueERhdGEsXG4gICAgICAgICAgICBkID0gW10sXG4gICAgICAgICAgICBoID0gMCxcbiAgICAgICAgICAgIGwgPSAwO1xuICAgICAgICB2YXIgbSA9IDA7XG4gICAgICAgIHZhciBwID0gdGhpcy5yZXF1aXJlU29ydGluZyA/IHRoaXMuY3JvcFNob3VsZGVyIDogMCxcbiAgICAgICAgICAgIG4gPSBjID8gYy5wb3NpdGl2ZVZhbHVlc09ubHkgOiAhMSxcbiAgICAgICAgICAgIGc7XG4gICAgICAgIGIgPSBiIHx8IHRoaXMuc3RhY2tlZFlEYXRhIHx8IHRoaXMucHJvY2Vzc2VkWURhdGEgfHwgW107XG4gICAgICAgIGMgPSBiLmxlbmd0aDtcbiAgICAgICAgYSAmJiAobSA9IGEuZ2V0RXh0cmVtZXMoKSwgbCA9IG0ubWluLCBtID0gbS5tYXgpO1xuXG4gICAgICAgIGZvciAoZyA9IDA7IGcgPCBjOyBnKyspIHtcbiAgICAgICAgICB2YXIgdyA9IGZbZ107XG4gICAgICAgICAgdmFyIHYgPSBiW2ddO1xuICAgICAgICAgIHZhciB0ID0gKGsodikgfHwgZSh2KSkgJiYgKHYubGVuZ3RoIHx8IDAgPCB2IHx8ICFuKTtcbiAgICAgICAgICB3ID0gdGhpcy5nZXRFeHRyZW1lc0Zyb21BbGwgfHwgdGhpcy5vcHRpb25zLmdldEV4dHJlbWVzRnJvbUFsbCB8fCB0aGlzLmNyb3BwZWQgfHwgIWEgfHwgKGZbZyArIHBdIHx8IHcpID49IGwgJiYgKGZbZyAtIHBdIHx8IHcpIDw9IG07XG4gICAgICAgICAgaWYgKHQgJiYgdykgaWYgKHQgPSB2Lmxlbmd0aCkgZm9yICg7IHQtLTspIGsodlt0XSkgJiYgKGRbaCsrXSA9IHZbdF0pO2Vsc2UgZFtoKytdID0gdjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGF0YU1pbiA9IEEoZCk7XG4gICAgICAgIHRoaXMuZGF0YU1heCA9IEUoZCk7XG4gICAgICAgIHEodGhpcywgXCJhZnRlckdldEV4dHJlbWVzXCIpO1xuICAgICAgfSxcbiAgICAgIGdldEZpcnN0VmFsaWRQb2ludDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgZm9yICh2YXIgYSA9IG51bGwsIGMgPSBiLmxlbmd0aCwgZSA9IDA7IG51bGwgPT09IGEgJiYgZSA8IGM7KSBhID0gYltlXSwgZSsrO1xuXG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSxcbiAgICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NlZFhEYXRhIHx8IHRoaXMucHJvY2Vzc0RhdGEoKTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZVBvaW50cygpO1xuICAgICAgICB2YXIgYiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGEgPSBiLnN0YWNraW5nLFxuICAgICAgICAgICAgYyA9IHRoaXMueEF4aXMsXG4gICAgICAgICAgICBmID0gYy5jYXRlZ29yaWVzLFxuICAgICAgICAgICAgZCA9IHRoaXMuZW5hYmxlZERhdGFTb3J0aW5nLFxuICAgICAgICAgICAgaCA9IHRoaXMueUF4aXMsXG4gICAgICAgICAgICBwID0gdGhpcy5wb2ludHMsXG4gICAgICAgICAgICBtID0gcC5sZW5ndGgsXG4gICAgICAgICAgICBuID0gISF0aGlzLm1vZGlmeVZhbHVlLFxuICAgICAgICAgICAgZyxcbiAgICAgICAgICAgIHcgPSB0aGlzLnBvaW50UGxhY2VtZW50VG9YVmFsdWUoKSxcbiAgICAgICAgICAgIHYgPSAhIXcsXG4gICAgICAgICAgICB0ID0gYi50aHJlc2hvbGQsXG4gICAgICAgICAgICBCID0gYi5zdGFydEZyb21UaHJlc2hvbGQgPyB0IDogMCxcbiAgICAgICAgICAgIHosXG4gICAgICAgICAgICBMID0gdGhpcy56b25lQXhpcyB8fCBcInlcIixcbiAgICAgICAgICAgIHUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgIGZvciAoZyA9IDA7IGcgPCBtOyBnKyspIHtcbiAgICAgICAgICB2YXIgSyA9IHBbZ10sXG4gICAgICAgICAgICAgIHIgPSBLLngsXG4gICAgICAgICAgICAgIEggPSBLLnksXG4gICAgICAgICAgICAgIEQgPSBLLmxvdyxcbiAgICAgICAgICAgICAgQSA9IGEgJiYgaC5zdGFja3NbKHRoaXMubmVnU3RhY2tzICYmIEggPCAoQiA/IDAgOiB0KSA/IFwiLVwiIDogXCJcIikgKyB0aGlzLnN0YWNrS2V5XTtcbiAgICAgICAgICBoLnBvc2l0aXZlVmFsdWVzT25seSAmJiBudWxsICE9PSBIICYmIDAgPj0gSCAmJiAoSy5pc051bGwgPSAhMCk7XG4gICAgICAgICAgSy5wbG90WCA9IHogPSBKKEcoYy50cmFuc2xhdGUociwgMCwgMCwgMCwgMSwgdywgXCJmbGFnc1wiID09PSB0aGlzLnR5cGUpLCAtMUU1LCAxRTUpKTtcblxuICAgICAgICAgIGlmIChhICYmIHRoaXMudmlzaWJsZSAmJiBBICYmIEFbcl0pIHtcbiAgICAgICAgICAgIHZhciBOID0gdGhpcy5nZXRTdGFja0luZGljYXRvcihOLCByLCB0aGlzLmluZGV4KTtcblxuICAgICAgICAgICAgaWYgKCFLLmlzTnVsbCkge1xuICAgICAgICAgICAgICB2YXIgUSA9IEFbcl07XG4gICAgICAgICAgICAgIHZhciBFID0gUS5wb2ludHNbTi5rZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGUoRSkgJiYgKEQgPSBFWzBdLCBIID0gRVsxXSwgRCA9PT0gQiAmJiBOLmtleSA9PT0gQVtyXS5iYXNlICYmIChEID0gbChrKHQpICYmIHQsIGgubWluKSksIGgucG9zaXRpdmVWYWx1ZXNPbmx5ICYmIDAgPj0gRCAmJiAoRCA9IG51bGwpLCBLLnRvdGFsID0gSy5zdGFja1RvdGFsID0gUS50b3RhbCwgSy5wZXJjZW50YWdlID0gUS50b3RhbCAmJiBLLnkgLyBRLnRvdGFsICogMTAwLCBLLnN0YWNrWSA9IEgsIHRoaXMuaXJyZWd1bGFyV2lkdGhzIHx8IFEuc2V0T2Zmc2V0KHRoaXMucG9pbnRYT2Zmc2V0IHx8IDAsIHRoaXMuYmFyVyB8fCAwKSk7XG4gICAgICAgICAgSy55Qm90dG9tID0geShEKSA/IEcoaC50cmFuc2xhdGUoRCwgMCwgMSwgMCwgMSksIC0xRTUsIDFFNSkgOiBudWxsO1xuICAgICAgICAgIG4gJiYgKEggPSB0aGlzLm1vZGlmeVZhbHVlKEgsIEspKTtcbiAgICAgICAgICBLLnBsb3RZID0gXCJudW1iZXJcIiA9PT0gdHlwZW9mIEggJiYgSW5maW5pdHkgIT09IEggPyBHKGgudHJhbnNsYXRlKEgsIDAsIDEsIDAsIDEpLCAtMUU1LCAxRTUpIDogdm9pZCAwO1xuICAgICAgICAgIEsuaXNJbnNpZGUgPSB0aGlzLmlzUG9pbnRJbnNpZGUoSyk7XG4gICAgICAgICAgSy5jbGllbnRYID0gdiA/IEooYy50cmFuc2xhdGUociwgMCwgMCwgMCwgMSwgdykpIDogejtcbiAgICAgICAgICBLLm5lZ2F0aXZlID0gS1tMXSA8IChiW0wgKyBcIlRocmVzaG9sZFwiXSB8fCB0IHx8IDApO1xuICAgICAgICAgIEsuY2F0ZWdvcnkgPSBmICYmIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBmW0sueF0gPyBmW0sueF0gOiBLLng7XG5cbiAgICAgICAgICBpZiAoIUsuaXNOdWxsICYmICExICE9PSBLLnZpc2libGUpIHtcbiAgICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBQICYmICh1ID0gTWF0aC5taW4odSwgTWF0aC5hYnMoeiAtIFApKSk7XG4gICAgICAgICAgICB2YXIgUCA9IHo7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgSy56b25lID0gdGhpcy56b25lcy5sZW5ndGggJiYgSy5nZXRab25lKCk7XG4gICAgICAgICAgIUsuZ3JhcGhpYyAmJiB0aGlzLmdyb3VwICYmIGQgJiYgKEsuaXNOZXcgPSAhMCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsb3Nlc3RQb2ludFJhbmdlUHggPSB1O1xuICAgICAgICBxKHRoaXMsIFwiYWZ0ZXJUcmFuc2xhdGVcIik7XG4gICAgICB9LFxuICAgICAgZ2V0VmFsaWRQb2ludHM6IGZ1bmN0aW9uIChiLCBhLCBjKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5jaGFydDtcbiAgICAgICAgcmV0dXJuIChiIHx8IHRoaXMucG9pbnRzIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICByZXR1cm4gYSAmJiAhZS5pc0luc2lkZVBsb3QoYi5wbG90WCwgYi5wbG90WSwgZS5pbnZlcnRlZCkgPyAhMSA6ICExICE9PSBiLnZpc2libGUgJiYgKGMgfHwgIWIuaXNOdWxsKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZ2V0Q2xpcEJveDogZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBlID0gdGhpcy5jaGFydCxcbiAgICAgICAgICAgIGYgPSBlLmludmVydGVkLFxuICAgICAgICAgICAgZCA9IHRoaXMueEF4aXMsXG4gICAgICAgICAgICBrID0gZCAmJiB0aGlzLnlBeGlzO1xuICAgICAgICBiICYmICExID09PSBjLmNsaXAgJiYgayA/IGIgPSBmID8ge1xuICAgICAgICAgIHk6IC1lLmNoYXJ0V2lkdGggKyBrLmxlbiArIGsucG9zLFxuICAgICAgICAgIGhlaWdodDogZS5jaGFydFdpZHRoLFxuICAgICAgICAgIHdpZHRoOiBlLmNoYXJ0SGVpZ2h0LFxuICAgICAgICAgIHg6IC1lLmNoYXJ0SGVpZ2h0ICsgZC5sZW4gKyBkLnBvc1xuICAgICAgICB9IDoge1xuICAgICAgICAgIHk6IC1rLnBvcyxcbiAgICAgICAgICBoZWlnaHQ6IGUuY2hhcnRIZWlnaHQsXG4gICAgICAgICAgd2lkdGg6IGUuY2hhcnRXaWR0aCxcbiAgICAgICAgICB4OiAtZC5wb3NcbiAgICAgICAgfSA6IChiID0gdGhpcy5jbGlwQm94IHx8IGUuY2xpcEJveCwgYSAmJiAoYi53aWR0aCA9IGUucGxvdFNpemVYLCBiLnggPSAwKSk7XG4gICAgICAgIHJldHVybiBhID8ge1xuICAgICAgICAgIHdpZHRoOiBiLndpZHRoLFxuICAgICAgICAgIHg6IGIueFxuICAgICAgICB9IDogYjtcbiAgICAgIH0sXG4gICAgICBzZXRDbGlwOiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBjID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgZSA9IGEucmVuZGVyZXIsXG4gICAgICAgICAgICBmID0gYS5pbnZlcnRlZCxcbiAgICAgICAgICAgIGQgPSB0aGlzLmNsaXBCb3gsXG4gICAgICAgICAgICBrID0gdGhpcy5nZXRDbGlwQm94KGIpLFxuICAgICAgICAgICAgaCA9IHRoaXMuc2hhcmVkQ2xpcEtleSB8fCBbXCJfc2hhcmVkQ2xpcFwiLCBiICYmIGIuZHVyYXRpb24sIGIgJiYgYi5lYXNpbmcsIGsuaGVpZ2h0LCBjLnhBeGlzLCBjLnlBeGlzXS5qb2luKCksXG4gICAgICAgICAgICBsID0gYVtoXSxcbiAgICAgICAgICAgIHAgPSBhW2ggKyBcIm1cIl07XG4gICAgICAgIGIgJiYgKGsud2lkdGggPSAwLCBmICYmIChrLnggPSBhLnBsb3RIZWlnaHQgKyAoITEgIT09IGMuY2xpcCA/IDAgOiBhLnBsb3RUb3ApKSk7XG4gICAgICAgIGwgPyBhLmhhc0xvYWRlZCB8fCBsLmF0dHIoaykgOiAoYiAmJiAoYVtoICsgXCJtXCJdID0gcCA9IGUuY2xpcFJlY3QoZiA/IGEucGxvdFNpemVYICsgOTkgOiAtOTksIGYgPyAtYS5wbG90TGVmdCA6IC1hLnBsb3RUb3AsIDk5LCBmID8gYS5jaGFydFdpZHRoIDogYS5jaGFydEhlaWdodCkpLCBhW2hdID0gbCA9IGUuY2xpcFJlY3QoayksIGwuY291bnQgPSB7XG4gICAgICAgICAgbGVuZ3RoOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBiICYmICFsLmNvdW50W3RoaXMuaW5kZXhdICYmIChsLmNvdW50W3RoaXMuaW5kZXhdID0gITAsIGwuY291bnQubGVuZ3RoICs9IDEpO1xuICAgICAgICBpZiAoITEgIT09IGMuY2xpcCB8fCBiKSB0aGlzLmdyb3VwLmNsaXAoYiB8fCBkID8gbCA6IGEuY2xpcFJlY3QpLCB0aGlzLm1hcmtlckdyb3VwLmNsaXAocCksIHRoaXMuc2hhcmVkQ2xpcEtleSA9IGg7XG4gICAgICAgIGIgfHwgKGwuY291bnRbdGhpcy5pbmRleF0gJiYgKGRlbGV0ZSBsLmNvdW50W3RoaXMuaW5kZXhdLCAtLWwuY291bnQubGVuZ3RoKSwgMCA9PT0gbC5jb3VudC5sZW5ndGggJiYgaCAmJiBhW2hdICYmIChkIHx8IChhW2hdID0gYVtoXS5kZXN0cm95KCkpLCBhW2ggKyBcIm1cIl0gJiYgKGFbaCArIFwibVwiXSA9IGFbaCArIFwibVwiXS5kZXN0cm95KCkpKSk7XG4gICAgICB9LFxuICAgICAgYW5pbWF0ZTogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgYyA9IE0odGhpcy5vcHRpb25zLmFuaW1hdGlvbik7XG4gICAgICAgIGlmICghYS5oYXNSZW5kZXJlZCkgaWYgKGIpIHRoaXMuc2V0Q2xpcChjKTtlbHNlIHtcbiAgICAgICAgICB2YXIgZSA9IHRoaXMuc2hhcmVkQ2xpcEtleTtcbiAgICAgICAgICBiID0gYVtlXTtcbiAgICAgICAgICB2YXIgZiA9IHRoaXMuZ2V0Q2xpcEJveChjLCAhMCk7XG4gICAgICAgICAgYiAmJiBiLmFuaW1hdGUoZiwgYyk7XG4gICAgICAgICAgYVtlICsgXCJtXCJdICYmIGFbZSArIFwibVwiXS5hbmltYXRlKHtcbiAgICAgICAgICAgIHdpZHRoOiBmLndpZHRoICsgOTksXG4gICAgICAgICAgICB4OiBmLnggLSAoYS5pbnZlcnRlZCA/IDAgOiA5OSlcbiAgICAgICAgICB9LCBjKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFmdGVyQW5pbWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldENsaXAoKTtcbiAgICAgICAgcSh0aGlzLCBcImFmdGVyQW5pbWF0ZVwiKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZEFuaW1hdGluZyA9ICEwO1xuICAgICAgfSxcbiAgICAgIGRyYXdQb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLnBvaW50cyxcbiAgICAgICAgICAgIGEgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIGUsXG4gICAgICAgICAgICBmID0gdGhpcy5vcHRpb25zLm1hcmtlcixcbiAgICAgICAgICAgIGQgPSB0aGlzW3RoaXMuc3BlY2lhbEdyb3VwXSB8fCB0aGlzLm1hcmtlckdyb3VwLFxuICAgICAgICAgICAgayA9IHRoaXMueEF4aXMsXG4gICAgICAgICAgICBoID0gbChmLmVuYWJsZWQsICFrIHx8IGsuaXNSYWRpYWwgPyAhMCA6IG51bGwsIHRoaXMuY2xvc2VzdFBvaW50UmFuZ2VQeCA+PSBmLmVuYWJsZWRUaHJlc2hvbGQgKiBmLnJhZGl1cyk7XG4gICAgICAgIGlmICghMSAhPT0gZi5lbmFibGVkIHx8IHRoaXMuX2hhc1BvaW50TWFya2VycykgZm9yIChjID0gMDsgYyA8IGIubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICB2YXIgcCA9IGJbY107XG4gICAgICAgICAgdmFyIG4gPSAoZSA9IHAuZ3JhcGhpYykgPyBcImFuaW1hdGVcIiA6IFwiYXR0clwiO1xuICAgICAgICAgIHZhciBnID0gcC5tYXJrZXIgfHwge307XG4gICAgICAgICAgdmFyIHcgPSAhIXAubWFya2VyO1xuXG4gICAgICAgICAgaWYgKChoICYmIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBnLmVuYWJsZWQgfHwgZy5lbmFibGVkKSAmJiAhcC5pc051bGwgJiYgITEgIT09IHAudmlzaWJsZSkge1xuICAgICAgICAgICAgdmFyIHYgPSBsKGcuc3ltYm9sLCB0aGlzLnN5bWJvbCk7XG4gICAgICAgICAgICB2YXIgcSA9IHRoaXMubWFya2VyQXR0cmlicyhwLCBwLnNlbGVjdGVkICYmIFwic2VsZWN0XCIpO1xuICAgICAgICAgICAgdGhpcy5lbmFibGVkRGF0YVNvcnRpbmcgJiYgKHAuc3RhcnRYUG9zID0gay5yZXZlcnNlZCA/IC1xLndpZHRoIDogay53aWR0aCk7XG4gICAgICAgICAgICB2YXIgdCA9ICExICE9PSBwLmlzSW5zaWRlO1xuICAgICAgICAgICAgZSA/IGVbdCA/IFwic2hvd1wiIDogXCJoaWRlXCJdKHQpLmFuaW1hdGUocSkgOiB0ICYmICgwIDwgcS53aWR0aCB8fCBwLmhhc0ltYWdlKSAmJiAocC5ncmFwaGljID0gZSA9IGEucmVuZGVyZXIuc3ltYm9sKHYsIHEueCwgcS55LCBxLndpZHRoLCBxLmhlaWdodCwgdyA/IGcgOiBmKS5hZGQoZCksIHRoaXMuZW5hYmxlZERhdGFTb3J0aW5nICYmIGEuaGFzUmVuZGVyZWQgJiYgKGUuYXR0cih7XG4gICAgICAgICAgICAgIHg6IHAuc3RhcnRYUG9zXG4gICAgICAgICAgICB9KSwgbiA9IFwiYW5pbWF0ZVwiKSk7XG4gICAgICAgICAgICBlICYmIFwiYW5pbWF0ZVwiID09PSBuICYmIGVbdCA/IFwic2hvd1wiIDogXCJoaWRlXCJdKHQpLmFuaW1hdGUocSk7XG4gICAgICAgICAgICBpZiAoZSAmJiAhYS5zdHlsZWRNb2RlKSBlW25dKHRoaXMucG9pbnRBdHRyaWJzKHAsIHAuc2VsZWN0ZWQgJiYgXCJzZWxlY3RcIikpO1xuICAgICAgICAgICAgZSAmJiBlLmFkZENsYXNzKHAuZ2V0Q2xhc3NOYW1lKCksICEwKTtcbiAgICAgICAgICB9IGVsc2UgZSAmJiAocC5ncmFwaGljID0gZS5kZXN0cm95KCkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWFya2VyQXR0cmliczogZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLm9wdGlvbnMubWFya2VyLFxuICAgICAgICAgICAgZSA9IGIubWFya2VyIHx8IHt9LFxuICAgICAgICAgICAgZiA9IGUuc3ltYm9sIHx8IGMuc3ltYm9sLFxuICAgICAgICAgICAgZCA9IGwoZS5yYWRpdXMsIGMucmFkaXVzKTtcbiAgICAgICAgYSAmJiAoYyA9IGMuc3RhdGVzW2FdLCBhID0gZS5zdGF0ZXMgJiYgZS5zdGF0ZXNbYV0sIGQgPSBsKGEgJiYgYS5yYWRpdXMsIGMgJiYgYy5yYWRpdXMsIGQgKyAoYyAmJiBjLnJhZGl1c1BsdXMgfHwgMCkpKTtcbiAgICAgICAgYi5oYXNJbWFnZSA9IGYgJiYgMCA9PT0gZi5pbmRleE9mKFwidXJsXCIpO1xuICAgICAgICBiLmhhc0ltYWdlICYmIChkID0gMCk7XG4gICAgICAgIGIgPSB7XG4gICAgICAgICAgeDogTWF0aC5mbG9vcihiLnBsb3RYKSAtIGQsXG4gICAgICAgICAgeTogYi5wbG90WSAtIGRcbiAgICAgICAgfTtcbiAgICAgICAgZCAmJiAoYi53aWR0aCA9IGIuaGVpZ2h0ID0gMiAqIGQpO1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0sXG4gICAgICBwb2ludEF0dHJpYnM6IGZ1bmN0aW9uIChiLCBhKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5vcHRpb25zLm1hcmtlcixcbiAgICAgICAgICAgIGUgPSBiICYmIGIub3B0aW9ucyxcbiAgICAgICAgICAgIGYgPSBlICYmIGUubWFya2VyIHx8IHt9LFxuICAgICAgICAgICAgZCA9IHRoaXMuY29sb3IsXG4gICAgICAgICAgICBrID0gZSAmJiBlLmNvbG9yLFxuICAgICAgICAgICAgaCA9IGIgJiYgYi5jb2xvcjtcbiAgICAgICAgZSA9IGwoZi5saW5lV2lkdGgsIGMubGluZVdpZHRoKTtcbiAgICAgICAgdmFyIHAgPSBiICYmIGIuem9uZSAmJiBiLnpvbmUuY29sb3I7XG4gICAgICAgIGIgPSAxO1xuICAgICAgICBkID0gayB8fCBwIHx8IGggfHwgZDtcbiAgICAgICAgayA9IGYuZmlsbENvbG9yIHx8IGMuZmlsbENvbG9yIHx8IGQ7XG4gICAgICAgIGQgPSBmLmxpbmVDb2xvciB8fCBjLmxpbmVDb2xvciB8fCBkO1xuICAgICAgICBhID0gYSB8fCBcIm5vcm1hbFwiO1xuICAgICAgICBjID0gYy5zdGF0ZXNbYV07XG4gICAgICAgIGEgPSBmLnN0YXRlcyAmJiBmLnN0YXRlc1thXSB8fCB7fTtcbiAgICAgICAgZSA9IGwoYS5saW5lV2lkdGgsIGMubGluZVdpZHRoLCBlICsgbChhLmxpbmVXaWR0aFBsdXMsIGMubGluZVdpZHRoUGx1cywgMCkpO1xuICAgICAgICBrID0gYS5maWxsQ29sb3IgfHwgYy5maWxsQ29sb3IgfHwgaztcbiAgICAgICAgZCA9IGEubGluZUNvbG9yIHx8IGMubGluZUNvbG9yIHx8IGQ7XG4gICAgICAgIGIgPSBsKGEub3BhY2l0eSwgYy5vcGFjaXR5LCBiKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdHJva2U6IGQsXG4gICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogZSxcbiAgICAgICAgICBmaWxsOiBrLFxuICAgICAgICAgIG9wYWNpdHk6IGJcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgYyA9IHRoaXMsXG4gICAgICAgICAgICBlID0gYy5jaGFydCxcbiAgICAgICAgICAgIGYgPSAvQXBwbGVXZWJLaXRcXC81MzMvLnRlc3QocC5uYXZpZ2F0b3IudXNlckFnZW50KSxcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgaCA9IGMuZGF0YSB8fCBbXSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBuO1xuICAgICAgICBxKGMsIFwiZGVzdHJveVwiKTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudHMoYik7XG4gICAgICAgIChjLmF4aXNUeXBlcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIChuID0gY1tiXSkgJiYgbi5zZXJpZXMgJiYgKHQobi5zZXJpZXMsIGMpLCBuLmlzRGlydHkgPSBuLmZvcmNlUmVkcmF3ID0gITApO1xuICAgICAgICB9KTtcbiAgICAgICAgYy5sZWdlbmRJdGVtICYmIGMuY2hhcnQubGVnZW5kLmRlc3Ryb3lJdGVtKGMpO1xuXG4gICAgICAgIGZvciAoayA9IGgubGVuZ3RoOyBrLS07KSAobCA9IGhba10pICYmIGwuZGVzdHJveSAmJiBsLmRlc3Ryb3koKTtcblxuICAgICAgICBjLnBvaW50cyA9IG51bGw7XG4gICAgICAgIHUuY2xlYXJUaW1lb3V0KGMuYW5pbWF0aW9uVGltZW91dCk7XG4gICAgICAgIGEoYywgZnVuY3Rpb24gKGIsIGEpIHtcbiAgICAgICAgICBiIGluc3RhbmNlb2YgSyAmJiAhYi5zdXJ2aXZlICYmIChkID0gZiAmJiBcImdyb3VwXCIgPT09IGEgPyBcImhpZGVcIiA6IFwiZGVzdHJveVwiLCBiW2RdKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgZS5ob3ZlclNlcmllcyA9PT0gYyAmJiAoZS5ob3ZlclNlcmllcyA9IG51bGwpO1xuICAgICAgICB0KGUuc2VyaWVzLCBjKTtcbiAgICAgICAgZS5vcmRlclNlcmllcygpO1xuICAgICAgICBhKGMsIGZ1bmN0aW9uIChhLCBlKSB7XG4gICAgICAgICAgYiAmJiBcImhjRXZlbnRzXCIgPT09IGUgfHwgZGVsZXRlIGNbZV07XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdldEdyYXBoUGF0aDogZnVuY3Rpb24gKGIsIGEsIGMpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLFxuICAgICAgICAgICAgZiA9IGUub3B0aW9ucyxcbiAgICAgICAgICAgIGQgPSBmLnN0ZXAsXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgaCA9IFtdLFxuICAgICAgICAgICAgbCA9IFtdLFxuICAgICAgICAgICAgcDtcbiAgICAgICAgYiA9IGIgfHwgZS5wb2ludHM7XG4gICAgICAgIChrID0gYi5yZXZlcnNlZCkgJiYgYi5yZXZlcnNlKCk7XG4gICAgICAgIChkID0ge1xuICAgICAgICAgIHJpZ2h0OiAxLFxuICAgICAgICAgIGNlbnRlcjogMlxuICAgICAgICB9W2RdIHx8IGQgJiYgMykgJiYgayAmJiAoZCA9IDQgLSBkKTtcbiAgICAgICAgYiA9IHRoaXMuZ2V0VmFsaWRQb2ludHMoYiwgITEsICEoZi5jb25uZWN0TnVsbHMgJiYgIWEgJiYgIWMpKTtcbiAgICAgICAgYi5mb3JFYWNoKGZ1bmN0aW9uIChrLCBuKSB7XG4gICAgICAgICAgdmFyIG0gPSBrLnBsb3RYLFxuICAgICAgICAgICAgICBnID0gay5wbG90WSxcbiAgICAgICAgICAgICAgdyA9IGJbbiAtIDFdO1xuICAgICAgICAgIChrLmxlZnRDbGlmZiB8fCB3ICYmIHcucmlnaHRDbGlmZikgJiYgIWMgJiYgKHAgPSAhMCk7XG4gICAgICAgICAgay5pc051bGwgJiYgIXkoYSkgJiYgMCA8IG4gPyBwID0gIWYuY29ubmVjdE51bGxzIDogay5pc051bGwgJiYgIWEgPyBwID0gITAgOiAoMCA9PT0gbiB8fCBwID8gbiA9IFtcIk1cIiwgay5wbG90WCwgay5wbG90WV0gOiBlLmdldFBvaW50U3BsaW5lID8gbiA9IGUuZ2V0UG9pbnRTcGxpbmUoYiwgaywgbikgOiBkID8gKG4gPSAxID09PSBkID8gW1wiTFwiLCB3LnBsb3RYLCBnXSA6IDIgPT09IGQgPyBbXCJMXCIsICh3LnBsb3RYICsgbSkgLyAyLCB3LnBsb3RZLCBcIkxcIiwgKHcucGxvdFggKyBtKSAvIDIsIGddIDogW1wiTFwiLCBtLCB3LnBsb3RZXSwgbi5wdXNoKFwiTFwiLCBtLCBnKSkgOiBuID0gW1wiTFwiLCBtLCBnXSwgbC5wdXNoKGsueCksIGQgJiYgKGwucHVzaChrLngpLCAyID09PSBkICYmIGwucHVzaChrLngpKSwgaC5wdXNoLmFwcGx5KGgsIG4pLCBwID0gITEpO1xuICAgICAgICB9KTtcbiAgICAgICAgaC54TWFwID0gbDtcbiAgICAgICAgcmV0dXJuIGUuZ3JhcGhQYXRoID0gaDtcbiAgICAgIH0sXG4gICAgICBkcmF3R3JhcGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLFxuICAgICAgICAgICAgYSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGMgPSAodGhpcy5nYXBwZWRQYXRoIHx8IHRoaXMuZ2V0R3JhcGhQYXRoKS5jYWxsKHRoaXMpLFxuICAgICAgICAgICAgZSA9IHRoaXMuY2hhcnQuc3R5bGVkTW9kZSxcbiAgICAgICAgICAgIGYgPSBbW1wiZ3JhcGhcIiwgXCJoaWdoY2hhcnRzLWdyYXBoXCJdXTtcbiAgICAgICAgZSB8fCBmWzBdLnB1c2goYS5saW5lQ29sb3IgfHwgdGhpcy5jb2xvciB8fCBcIiNjY2NjY2NcIiwgYS5kYXNoU3R5bGUpO1xuICAgICAgICBmID0gYi5nZXRab25lc0dyYXBocyhmKTtcbiAgICAgICAgZi5mb3JFYWNoKGZ1bmN0aW9uIChmLCBkKSB7XG4gICAgICAgICAgdmFyIGsgPSBmWzBdLFxuICAgICAgICAgICAgICBoID0gYltrXSxcbiAgICAgICAgICAgICAgbCA9IGggPyBcImFuaW1hdGVcIiA6IFwiYXR0clwiO1xuICAgICAgICAgIGggPyAoaC5lbmRYID0gYi5wcmV2ZW50R3JhcGhBbmltYXRpb24gPyBudWxsIDogYy54TWFwLCBoLmFuaW1hdGUoe1xuICAgICAgICAgICAgZDogY1xuICAgICAgICAgIH0pKSA6IGMubGVuZ3RoICYmIChiW2tdID0gaCA9IGIuY2hhcnQucmVuZGVyZXIucGF0aChjKS5hZGRDbGFzcyhmWzFdKS5hdHRyKHtcbiAgICAgICAgICAgIHpJbmRleDogMVxuICAgICAgICAgIH0pLmFkZChiLmdyb3VwKSk7XG4gICAgICAgICAgaCAmJiAhZSAmJiAoayA9IHtcbiAgICAgICAgICAgIHN0cm9rZTogZlsyXSxcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IGEubGluZVdpZHRoLFxuICAgICAgICAgICAgZmlsbDogYi5maWxsR3JhcGggJiYgYi5jb2xvciB8fCBcIm5vbmVcIlxuICAgICAgICAgIH0sIGZbM10gPyBrLmRhc2hzdHlsZSA9IGZbM10gOiBcInNxdWFyZVwiICE9PSBhLmxpbmVjYXAgJiYgKGtbXCJzdHJva2UtbGluZWNhcFwiXSA9IGtbXCJzdHJva2UtbGluZWpvaW5cIl0gPSBcInJvdW5kXCIpLCBoW2xdKGspLnNoYWRvdygyID4gZCAmJiBhLnNoYWRvdykpO1xuICAgICAgICAgIGggJiYgKGguc3RhcnRYID0gYy54TWFwLCBoLmlzQXJlYSA9IGMuaXNBcmVhKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZ2V0Wm9uZXNHcmFwaHM6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHRoaXMuem9uZXMuZm9yRWFjaChmdW5jdGlvbiAoYiwgYykge1xuICAgICAgICAgIGMgPSBbXCJ6b25lLWdyYXBoLVwiICsgYywgXCJoaWdoY2hhcnRzLWdyYXBoIGhpZ2hjaGFydHMtem9uZS1ncmFwaC1cIiArIGMgKyBcIiBcIiArIChiLmNsYXNzTmFtZSB8fCBcIlwiKV07XG4gICAgICAgICAgdGhpcy5jaGFydC5zdHlsZWRNb2RlIHx8IGMucHVzaChiLmNvbG9yIHx8IHRoaXMuY29sb3IsIGIuZGFzaFN0eWxlIHx8IHRoaXMub3B0aW9ucy5kYXNoU3R5bGUpO1xuICAgICAgICAgIGEucHVzaChjKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSxcbiAgICAgIGFwcGx5Wm9uZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgYyA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBlID0gYy5yZW5kZXJlcixcbiAgICAgICAgICAgIGYgPSB0aGlzLnpvbmVzLFxuICAgICAgICAgICAgZCxcbiAgICAgICAgICAgIGssXG4gICAgICAgICAgICBoID0gdGhpcy5jbGlwcyB8fCBbXSxcbiAgICAgICAgICAgIHAsXG4gICAgICAgICAgICBuID0gdGhpcy5ncmFwaCxcbiAgICAgICAgICAgIGcgPSB0aGlzLmFyZWEsXG4gICAgICAgICAgICB3ID0gTWF0aC5tYXgoYy5jaGFydFdpZHRoLCBjLmNoYXJ0SGVpZ2h0KSxcbiAgICAgICAgICAgIHYgPSB0aGlzWyh0aGlzLnpvbmVBeGlzIHx8IFwieVwiKSArIFwiQXhpc1wiXSxcbiAgICAgICAgICAgIHEgPSBjLmludmVydGVkLFxuICAgICAgICAgICAgdCxcbiAgICAgICAgICAgIEIsXG4gICAgICAgICAgICB6LFxuICAgICAgICAgICAgeSA9ICExO1xuXG4gICAgICAgIGlmIChmLmxlbmd0aCAmJiAobiB8fCBnKSAmJiB2ICYmIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiB2Lm1pbikge1xuICAgICAgICAgIHZhciBLID0gdi5yZXZlcnNlZDtcbiAgICAgICAgICB2YXIgTCA9IHYuaG9yaXo7XG4gICAgICAgICAgbiAmJiAhdGhpcy5zaG93TGluZSAmJiBuLmhpZGUoKTtcbiAgICAgICAgICBnICYmIGcuaGlkZSgpO1xuICAgICAgICAgIHZhciB1ID0gdi5nZXRFeHRyZW1lcygpO1xuICAgICAgICAgIGYuZm9yRWFjaChmdW5jdGlvbiAoYiwgZikge1xuICAgICAgICAgICAgZCA9IEsgPyBMID8gYy5wbG90V2lkdGggOiAwIDogTCA/IDAgOiB2LnRvUGl4ZWxzKHUubWluKSB8fCAwO1xuICAgICAgICAgICAgZCA9IEcobChrLCBkKSwgMCwgdyk7XG4gICAgICAgICAgICBrID0gRyhNYXRoLnJvdW5kKHYudG9QaXhlbHMobChiLnZhbHVlLCB1Lm1heCksICEwKSB8fCAwKSwgMCwgdyk7XG4gICAgICAgICAgICB5ICYmIChkID0gayA9IHYudG9QaXhlbHModS5tYXgpKTtcbiAgICAgICAgICAgIHQgPSBNYXRoLmFicyhkIC0gayk7XG4gICAgICAgICAgICBCID0gTWF0aC5taW4oZCwgayk7XG4gICAgICAgICAgICB6ID0gTWF0aC5tYXgoZCwgayk7XG4gICAgICAgICAgICB2LmlzWEF4aXMgPyAocCA9IHtcbiAgICAgICAgICAgICAgeDogcSA/IHogOiBCLFxuICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICB3aWR0aDogdCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiB3XG4gICAgICAgICAgICB9LCBMIHx8IChwLnggPSBjLnBsb3RIZWlnaHQgLSBwLngpKSA6IChwID0ge1xuICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICB5OiBxID8geiA6IEIsXG4gICAgICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgICAgICBoZWlnaHQ6IHRcbiAgICAgICAgICAgIH0sIEwgJiYgKHAueSA9IGMucGxvdFdpZHRoIC0gcC55KSk7XG4gICAgICAgICAgICBxICYmIGUuaXNWTUwgJiYgKHAgPSB2LmlzWEF4aXMgPyB7XG4gICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgIHk6IEsgPyBCIDogeixcbiAgICAgICAgICAgICAgaGVpZ2h0OiBwLndpZHRoLFxuICAgICAgICAgICAgICB3aWR0aDogYy5jaGFydFdpZHRoXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICB4OiBwLnkgLSBjLnBsb3RMZWZ0IC0gYy5zcGFjaW5nQm94LngsXG4gICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgIHdpZHRoOiBwLmhlaWdodCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBjLmNoYXJ0SGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhbZl0gPyBoW2ZdLmFuaW1hdGUocCkgOiBoW2ZdID0gZS5jbGlwUmVjdChwKTtcbiAgICAgICAgICAgIG4gJiYgYVtcInpvbmUtZ3JhcGgtXCIgKyBmXS5jbGlwKGhbZl0pO1xuICAgICAgICAgICAgZyAmJiBhW1wiem9uZS1hcmVhLVwiICsgZl0uY2xpcChoW2ZdKTtcbiAgICAgICAgICAgIHkgPSBiLnZhbHVlID4gdS5tYXg7XG4gICAgICAgICAgICBhLnJlc2V0Wm9uZXMgJiYgMCA9PT0gayAmJiAoayA9IHZvaWQgMCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5jbGlwcyA9IGg7XG4gICAgICAgIH0gZWxzZSBhLnZpc2libGUgJiYgKG4gJiYgbi5zaG93KCEwKSwgZyAmJiBnLnNob3coITApKTtcbiAgICAgIH0sXG4gICAgICBpbnZlcnRHcm91cHM6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGZ1bmN0aW9uIGIoKSB7XG4gICAgICAgICAgW1wiZ3JvdXBcIiwgXCJtYXJrZXJHcm91cFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICBjW2JdICYmIChlLnJlbmRlcmVyLmlzVk1MICYmIGNbYl0uYXR0cih7XG4gICAgICAgICAgICAgIHdpZHRoOiBjLnlBeGlzLmxlbixcbiAgICAgICAgICAgICAgaGVpZ2h0OiBjLnhBeGlzLmxlblxuICAgICAgICAgICAgfSksIGNbYl0ud2lkdGggPSBjLnlBeGlzLmxlbiwgY1tiXS5oZWlnaHQgPSBjLnhBeGlzLmxlbiwgY1tiXS5pbnZlcnQoYy5pc1JhZGlhbFNlcmllcyA/ICExIDogYSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSB0aGlzLFxuICAgICAgICAgICAgZSA9IGMuY2hhcnQ7XG4gICAgICAgIGMueEF4aXMgJiYgKGMuZXZlbnRzVG9VbmJpbmQucHVzaChJKGUsIFwicmVzaXplXCIsIGIpKSwgYigpLCBjLmludmVydEdyb3VwcyA9IGIpO1xuICAgICAgfSxcbiAgICAgIHBsb3RHcm91cDogZnVuY3Rpb24gKGEsIGMsIGUsIGYsIGQpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzW2FdLFxuICAgICAgICAgICAgayA9ICFiO1xuICAgICAgICBrICYmICh0aGlzW2FdID0gYiA9IHRoaXMuY2hhcnQucmVuZGVyZXIuZygpLmF0dHIoe1xuICAgICAgICAgIHpJbmRleDogZiB8fCAuMVxuICAgICAgICB9KS5hZGQoZCkpO1xuICAgICAgICBiLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIiArIGMgKyBcIiBoaWdoY2hhcnRzLXNlcmllcy1cIiArIHRoaXMuaW5kZXggKyBcIiBoaWdoY2hhcnRzLVwiICsgdGhpcy50eXBlICsgXCItc2VyaWVzIFwiICsgKHkodGhpcy5jb2xvckluZGV4KSA/IFwiaGlnaGNoYXJ0cy1jb2xvci1cIiArIHRoaXMuY29sb3JJbmRleCArIFwiIFwiIDogXCJcIikgKyAodGhpcy5vcHRpb25zLmNsYXNzTmFtZSB8fCBcIlwiKSArIChiLmhhc0NsYXNzKFwiaGlnaGNoYXJ0cy10cmFja2VyXCIpID8gXCIgaGlnaGNoYXJ0cy10cmFja2VyXCIgOiBcIlwiKSwgITApO1xuICAgICAgICBiLmF0dHIoe1xuICAgICAgICAgIHZpc2liaWxpdHk6IGVcbiAgICAgICAgfSlbayA/IFwiYXR0clwiIDogXCJhbmltYXRlXCJdKHRoaXMuZ2V0UGxvdEJveCgpKTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9LFxuICAgICAgZ2V0UGxvdEJveDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBjID0gdGhpcy54QXhpcyxcbiAgICAgICAgICAgIGUgPSB0aGlzLnlBeGlzO1xuICAgICAgICBhLmludmVydGVkICYmIChjID0gZSwgZSA9IHRoaXMueEF4aXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYW5zbGF0ZVg6IGMgPyBjLmxlZnQgOiBhLnBsb3RMZWZ0LFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IGUgPyBlLnRvcCA6IGEucGxvdFRvcCxcbiAgICAgICAgICBzY2FsZVg6IDEsXG4gICAgICAgICAgc2NhbGVZOiAxXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgcmVtb3ZlRXZlbnRzOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICBhID8gdGhpcy5ldmVudHNUb1VuYmluZC5sZW5ndGggJiYgKHRoaXMuZXZlbnRzVG9VbmJpbmQuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEoKTtcbiAgICAgICAgfSksIHRoaXMuZXZlbnRzVG9VbmJpbmQubGVuZ3RoID0gMCkgOiB2KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICBjID0gYS5jaGFydCxcbiAgICAgICAgICAgIGUgPSBhLm9wdGlvbnMsXG4gICAgICAgICAgICBmID0gIWEuZmluaXNoZWRBbmltYXRpbmcgJiYgYy5yZW5kZXJlci5pc1NWRyAmJiBNKGUuYW5pbWF0aW9uKS5kdXJhdGlvbixcbiAgICAgICAgICAgIGQgPSBhLnZpc2libGUgPyBcImluaGVyaXRcIiA6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgICBrID0gZS56SW5kZXgsXG4gICAgICAgICAgICBoID0gYS5oYXNSZW5kZXJlZCxcbiAgICAgICAgICAgIGwgPSBjLnNlcmllc0dyb3VwLFxuICAgICAgICAgICAgcCA9IGMuaW52ZXJ0ZWQ7XG4gICAgICAgIHEodGhpcywgXCJyZW5kZXJcIik7XG4gICAgICAgIHZhciBuID0gYS5wbG90R3JvdXAoXCJncm91cFwiLCBcInNlcmllc1wiLCBkLCBrLCBsKTtcbiAgICAgICAgYS5tYXJrZXJHcm91cCA9IGEucGxvdEdyb3VwKFwibWFya2VyR3JvdXBcIiwgXCJtYXJrZXJzXCIsIGQsIGssIGwpO1xuICAgICAgICBmICYmIGEuYW5pbWF0ZSAmJiBhLmFuaW1hdGUoITApO1xuICAgICAgICBuLmludmVydGVkID0gYS5pc0NhcnRlc2lhbiB8fCBhLmludmVydGFibGUgPyBwIDogITE7XG4gICAgICAgIGEuZHJhd0dyYXBoICYmIChhLmRyYXdHcmFwaCgpLCBhLmFwcGx5Wm9uZXMoKSk7XG4gICAgICAgIGEudmlzaWJsZSAmJiBhLmRyYXdQb2ludHMoKTtcbiAgICAgICAgYS5kcmF3RGF0YUxhYmVscyAmJiBhLmRyYXdEYXRhTGFiZWxzKCk7XG4gICAgICAgIGEucmVkcmF3UG9pbnRzICYmIGEucmVkcmF3UG9pbnRzKCk7XG4gICAgICAgIGEuZHJhd1RyYWNrZXIgJiYgITEgIT09IGEub3B0aW9ucy5lbmFibGVNb3VzZVRyYWNraW5nICYmIGEuZHJhd1RyYWNrZXIoKTtcbiAgICAgICAgYS5pbnZlcnRHcm91cHMocCk7XG4gICAgICAgICExID09PSBlLmNsaXAgfHwgYS5zaGFyZWRDbGlwS2V5IHx8IGggfHwgbi5jbGlwKGMuY2xpcFJlY3QpO1xuICAgICAgICBmICYmIGEuYW5pbWF0ZSAmJiBhLmFuaW1hdGUoKTtcbiAgICAgICAgaCB8fCAoYS5hbmltYXRpb25UaW1lb3V0ID0gQihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYS5hZnRlckFuaW1hdGUoKTtcbiAgICAgICAgfSwgZiB8fCAwKSk7XG4gICAgICAgIGEuaXNEaXJ0eSA9ICExO1xuICAgICAgICBhLmhhc1JlbmRlcmVkID0gITA7XG4gICAgICAgIHEoYSwgXCJhZnRlclJlbmRlclwiKTtcbiAgICAgIH0sXG4gICAgICByZWRyYXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgYyA9IHRoaXMuaXNEaXJ0eSB8fCB0aGlzLmlzRGlydHlEYXRhLFxuICAgICAgICAgICAgZSA9IHRoaXMuZ3JvdXAsXG4gICAgICAgICAgICBmID0gdGhpcy54QXhpcyxcbiAgICAgICAgICAgIGQgPSB0aGlzLnlBeGlzO1xuICAgICAgICBlICYmIChhLmludmVydGVkICYmIGUuYXR0cih7XG4gICAgICAgICAgd2lkdGg6IGEucGxvdFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogYS5wbG90SGVpZ2h0XG4gICAgICAgIH0pLCBlLmFuaW1hdGUoe1xuICAgICAgICAgIHRyYW5zbGF0ZVg6IGwoZiAmJiBmLmxlZnQsIGEucGxvdExlZnQpLFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IGwoZCAmJiBkLnRvcCwgYS5wbG90VG9wKVxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMudHJhbnNsYXRlKCk7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIGMgJiYgZGVsZXRlIHRoaXMua2RUcmVlO1xuICAgICAgfSxcbiAgICAgIGtkQXhpc0FycmF5OiBbXCJjbGllbnRYXCIsIFwicGxvdFlcIl0sXG4gICAgICBzZWFyY2hQb2ludDogZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLnhBeGlzLFxuICAgICAgICAgICAgZSA9IHRoaXMueUF4aXMsXG4gICAgICAgICAgICBmID0gdGhpcy5jaGFydC5pbnZlcnRlZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoS0RUcmVlKHtcbiAgICAgICAgICBjbGllbnRYOiBmID8gYi5sZW4gLSBhLmNoYXJ0WSArIGIucG9zIDogYS5jaGFydFggLSBiLnBvcyxcbiAgICAgICAgICBwbG90WTogZiA/IGUubGVuIC0gYS5jaGFydFggKyBlLnBvcyA6IGEuY2hhcnRZIC0gZS5wb3NcbiAgICAgICAgfSwgYywgYSk7XG4gICAgICB9LFxuICAgICAgYnVpbGRLRFRyZWU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGZ1bmN0aW9uIGIoYSwgZSwgZikge1xuICAgICAgICAgIHZhciBkO1xuXG4gICAgICAgICAgaWYgKGQgPSBhICYmIGEubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgayA9IGMua2RBeGlzQXJyYXlbZSAlIGZdO1xuICAgICAgICAgICAgYS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhW2tdIC0gYltrXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZCA9IE1hdGguZmxvb3IoZCAvIDIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcG9pbnQ6IGFbZF0sXG4gICAgICAgICAgICAgIGxlZnQ6IGIoYS5zbGljZSgwLCBkKSwgZSArIDEsIGYpLFxuICAgICAgICAgICAgICByaWdodDogYihhLnNsaWNlKGQgKyAxKSwgZSArIDEsIGYpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYnVpbGRpbmdLZFRyZWUgPSAhMDtcbiAgICAgICAgdmFyIGMgPSB0aGlzLFxuICAgICAgICAgICAgZSA9IC0xIDwgYy5vcHRpb25zLmZpbmROZWFyZXN0UG9pbnRCeS5pbmRleE9mKFwieVwiKSA/IDIgOiAxO1xuICAgICAgICBkZWxldGUgYy5rZFRyZWU7XG4gICAgICAgIEIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGMua2RUcmVlID0gYihjLmdldFZhbGlkUG9pbnRzKG51bGwsICFjLmRpcmVjdFRvdWNoKSwgZSwgZSk7XG4gICAgICAgICAgYy5idWlsZGluZ0tkVHJlZSA9ICExO1xuICAgICAgICB9LCBjLm9wdGlvbnMua2ROb3cgfHwgYSAmJiBcInRvdWNoc3RhcnRcIiA9PT0gYS50eXBlID8gMCA6IDEpO1xuICAgICAgfSxcbiAgICAgIHNlYXJjaEtEVHJlZTogZnVuY3Rpb24gKGEsIGMsIGUpIHtcbiAgICAgICAgZnVuY3Rpb24gYihhLCBjLCBlLCBsKSB7XG4gICAgICAgICAgdmFyIHAgPSBjLnBvaW50LFxuICAgICAgICAgICAgICBuID0gZi5rZEF4aXNBcnJheVtlICUgbF0sXG4gICAgICAgICAgICAgIGcgPSBwO1xuICAgICAgICAgIHZhciBtID0geShhW2RdKSAmJiB5KHBbZF0pID8gTWF0aC5wb3coYVtkXSAtIHBbZF0sIDIpIDogbnVsbDtcbiAgICAgICAgICB2YXIgdyA9IHkoYVtrXSkgJiYgeShwW2tdKSA/IE1hdGgucG93KGFba10gLSBwW2tdLCAyKSA6IG51bGw7XG4gICAgICAgICAgdyA9IChtIHx8IDApICsgKHcgfHwgMCk7XG4gICAgICAgICAgcC5kaXN0ID0geSh3KSA/IE1hdGguc3FydCh3KSA6IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgcC5kaXN0WCA9IHkobSkgPyBNYXRoLnNxcnQobSkgOiBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgIG4gPSBhW25dIC0gcFtuXTtcbiAgICAgICAgICB3ID0gMCA+IG4gPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcbiAgICAgICAgICBtID0gMCA+IG4gPyBcInJpZ2h0XCIgOiBcImxlZnRcIjtcbiAgICAgICAgICBjW3ddICYmICh3ID0gYihhLCBjW3ddLCBlICsgMSwgbCksIGcgPSB3W2hdIDwgZ1toXSA/IHcgOiBwKTtcbiAgICAgICAgICBjW21dICYmIE1hdGguc3FydChuICogbikgPCBnW2hdICYmIChhID0gYihhLCBjW21dLCBlICsgMSwgbCksIGcgPSBhW2hdIDwgZ1toXSA/IGEgOiBnKTtcbiAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmID0gdGhpcyxcbiAgICAgICAgICAgIGQgPSB0aGlzLmtkQXhpc0FycmF5WzBdLFxuICAgICAgICAgICAgayA9IHRoaXMua2RBeGlzQXJyYXlbMV0sXG4gICAgICAgICAgICBoID0gYyA/IFwiZGlzdFhcIiA6IFwiZGlzdFwiO1xuICAgICAgICBjID0gLTEgPCBmLm9wdGlvbnMuZmluZE5lYXJlc3RQb2ludEJ5LmluZGV4T2YoXCJ5XCIpID8gMiA6IDE7XG4gICAgICAgIHRoaXMua2RUcmVlIHx8IHRoaXMuYnVpbGRpbmdLZFRyZWUgfHwgdGhpcy5idWlsZEtEVHJlZShlKTtcbiAgICAgICAgaWYgKHRoaXMua2RUcmVlKSByZXR1cm4gYihhLCB0aGlzLmtkVHJlZSwgYywgYyk7XG4gICAgICB9LFxuICAgICAgcG9pbnRQbGFjZW1lbnRUb1hWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGMgPSBhLnBvaW50UmFuZ2UsXG4gICAgICAgICAgICBlID0gdGhpcy54QXhpcztcbiAgICAgICAgYSA9IGEucG9pbnRQbGFjZW1lbnQ7XG4gICAgICAgIFwiYmV0d2VlblwiID09PSBhICYmIChhID0gZS5yZXZlcnNlZCA/IC0uNSA6IC41KTtcbiAgICAgICAgcmV0dXJuIGsoYSkgPyBhICogbChjLCBlLnBvaW50UmFuZ2UpIDogMDtcbiAgICAgIH0sXG4gICAgICBpc1BvaW50SW5zaWRlOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGEucGxvdFkgJiYgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGEucGxvdFggJiYgMCA8PSBhLnBsb3RZICYmIGEucGxvdFkgPD0gdGhpcy55QXhpcy5sZW4gJiYgMCA8PSBhLnBsb3RYICYmIGEucGxvdFggPD0gdGhpcy54QXhpcy5sZW47XG4gICAgICB9XG4gICAgfSk7XG4gICAgXCJcIjtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9TdGFja2luZy5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZykge1xuICAgIHZhciByID0gZy5jb3JyZWN0RmxvYXQsXG4gICAgICAgIHUgPSBnLmRlZmluZWQsXG4gICAgICAgIEkgPSBnLmRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzLFxuICAgICAgICBNID0gZy5mb3JtYXQsXG4gICAgICAgIEUgPSBnLm9iamVjdEVhY2gsXG4gICAgICAgIEEgPSBnLnBpY2s7XG4gICAgZyA9IGQuQXhpcztcbiAgICB2YXIgRyA9IGQuQ2hhcnQsXG4gICAgICAgIEogPSBkLlNlcmllcztcblxuICAgIGQuU3RhY2tJdGVtID0gZnVuY3Rpb24gKGQsIGcsIHUsIGgsIHIpIHtcbiAgICAgIHZhciBxID0gZC5jaGFydC5pbnZlcnRlZDtcbiAgICAgIHRoaXMuYXhpcyA9IGQ7XG4gICAgICB0aGlzLmlzTmVnYXRpdmUgPSB1O1xuICAgICAgdGhpcy5vcHRpb25zID0gZyA9IGcgfHwge307XG4gICAgICB0aGlzLnggPSBoO1xuICAgICAgdGhpcy50b3RhbCA9IG51bGw7XG4gICAgICB0aGlzLnBvaW50cyA9IHt9O1xuICAgICAgdGhpcy5zdGFjayA9IHI7XG4gICAgICB0aGlzLnJpZ2h0Q2xpZmYgPSB0aGlzLmxlZnRDbGlmZiA9IDA7XG4gICAgICB0aGlzLmFsaWduT3B0aW9ucyA9IHtcbiAgICAgICAgYWxpZ246IGcuYWxpZ24gfHwgKHEgPyB1ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIgOiBcImNlbnRlclwiKSxcbiAgICAgICAgdmVydGljYWxBbGlnbjogZy52ZXJ0aWNhbEFsaWduIHx8IChxID8gXCJtaWRkbGVcIiA6IHUgPyBcImJvdHRvbVwiIDogXCJ0b3BcIiksXG4gICAgICAgIHk6IGcueSxcbiAgICAgICAgeDogZy54XG4gICAgICB9O1xuICAgICAgdGhpcy50ZXh0QWxpZ24gPSBnLnRleHRBbGlnbiB8fCAocSA/IHUgPyBcInJpZ2h0XCIgOiBcImxlZnRcIiA6IFwiY2VudGVyXCIpO1xuICAgIH07XG5cbiAgICBkLlN0YWNrSXRlbS5wcm90b3R5cGUgPSB7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIEkodGhpcywgdGhpcy5heGlzKTtcbiAgICAgIH0sXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBnID0gdGhpcy5heGlzLmNoYXJ0LFxuICAgICAgICAgICAgeSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGggPSB5LmZvcm1hdDtcbiAgICAgICAgaCA9IGggPyBNKGgsIHRoaXMsIGcpIDogeS5mb3JtYXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5sYWJlbCA/IHRoaXMubGFiZWwuYXR0cih7XG4gICAgICAgICAgdGV4dDogaCxcbiAgICAgICAgICB2aXNpYmlsaXR5OiBcImhpZGRlblwiXG4gICAgICAgIH0pIDogKHRoaXMubGFiZWwgPSBnLnJlbmRlcmVyLmxhYmVsKGgsIG51bGwsIG51bGwsIHkuc2hhcGUsIG51bGwsIG51bGwsIHkudXNlSFRNTCwgITEsIFwic3RhY2stbGFiZWxzXCIpLCBoID0ge1xuICAgICAgICAgIHRleHQ6IGgsXG4gICAgICAgICAgcm90YXRpb246IHkucm90YXRpb24sXG4gICAgICAgICAgcGFkZGluZzogQSh5LnBhZGRpbmcsIDUpLFxuICAgICAgICAgIHZpc2liaWxpdHk6IFwiaGlkZGVuXCJcbiAgICAgICAgfSwgdGhpcy5sYWJlbC5hdHRyKGgpLCBnLnN0eWxlZE1vZGUgfHwgdGhpcy5sYWJlbC5jc3MoeS5zdHlsZSksIHRoaXMubGFiZWwuYWRkZWQgfHwgdGhpcy5sYWJlbC5hZGQoZCkpO1xuICAgICAgICB0aGlzLmxhYmVsLmxhYmVscmFuayA9IGcucGxvdEhlaWdodDtcbiAgICAgIH0sXG4gICAgICBzZXRPZmZzZXQ6IGZ1bmN0aW9uIChkLCBnLCByLCBoLCBOKSB7XG4gICAgICAgIHZhciBxID0gdGhpcy5heGlzLFxuICAgICAgICAgICAgdCA9IHEuY2hhcnQ7XG4gICAgICAgIGggPSBxLnRyYW5zbGF0ZShxLnVzZVBlcmNlbnRhZ2UgPyAxMDAgOiBoID8gaCA6IHRoaXMudG90YWwsIDAsIDAsIDAsIDEpO1xuICAgICAgICByID0gcS50cmFuc2xhdGUociA/IHIgOiAwKTtcbiAgICAgICAgciA9IHUoaCkgJiYgTWF0aC5hYnMoaCAtIHIpO1xuICAgICAgICBkID0gQShOLCB0LnhBeGlzWzBdLnRyYW5zbGF0ZSh0aGlzLngpKSArIGQ7XG4gICAgICAgIHEgPSB1KGgpICYmIHRoaXMuZ2V0U3RhY2tCb3godCwgdGhpcywgZCwgaCwgZywgciwgcSk7XG4gICAgICAgIGcgPSB0aGlzLmxhYmVsO1xuICAgICAgICByID0gdGhpcy5pc05lZ2F0aXZlO1xuICAgICAgICBkID0gXCJqdXN0aWZ5XCIgPT09IEEodGhpcy5vcHRpb25zLm92ZXJmbG93LCBcImp1c3RpZnlcIik7XG4gICAgICAgIHZhciBlID0gdGhpcy50ZXh0QWxpZ247XG4gICAgICAgIGcgJiYgcSAmJiAoTiA9IGcuZ2V0QkJveCgpLCBoID0gZy5wYWRkaW5nLCBlID0gXCJsZWZ0XCIgPT09IGUgPyB0LmludmVydGVkID8gLWggOiBoIDogXCJyaWdodFwiID09PSBlID8gTi53aWR0aCA6IHQuaW52ZXJ0ZWQgJiYgXCJjZW50ZXJcIiA9PT0gZSA/IE4ud2lkdGggLyAyIDogdC5pbnZlcnRlZCA/IHIgPyBOLndpZHRoICsgaCA6IC1oIDogTi53aWR0aCAvIDIsIHIgPSB0LmludmVydGVkID8gTi5oZWlnaHQgLyAyIDogciA/IC1oIDogTi5oZWlnaHQsIHRoaXMuYWxpZ25PcHRpb25zLnggPSBBKHRoaXMub3B0aW9ucy54LCAwKSwgdGhpcy5hbGlnbk9wdGlvbnMueSA9IEEodGhpcy5vcHRpb25zLnksIDApLCBxLnggLT0gZSwgcS55IC09IHIsIGcuYWxpZ24odGhpcy5hbGlnbk9wdGlvbnMsIG51bGwsIHEpLCB0LmlzSW5zaWRlUGxvdChnLmFsaWduQXR0ci54ICsgZSAtIHRoaXMuYWxpZ25PcHRpb25zLngsIGcuYWxpZ25BdHRyLnkgKyByIC0gdGhpcy5hbGlnbk9wdGlvbnMueSkgPyBnLnNob3coKSA6IChnLmFsaWduQXR0ci55ID0gLTk5OTksIGQgPSAhMSksIGQgJiYgSi5wcm90b3R5cGUuanVzdGlmeURhdGFMYWJlbC5jYWxsKHRoaXMuYXhpcywgZywgdGhpcy5hbGlnbk9wdGlvbnMsIGcuYWxpZ25BdHRyLCBOLCBxKSwgZy5hdHRyKHtcbiAgICAgICAgICB4OiBnLmFsaWduQXR0ci54LFxuICAgICAgICAgIHk6IGcuYWxpZ25BdHRyLnlcbiAgICAgICAgfSksIEEoIWQgJiYgdGhpcy5vcHRpb25zLmNyb3AsICEwKSAmJiAoKHQgPSB0LmlzSW5zaWRlUGxvdChnLnggLSBoICsgZy53aWR0aCwgZy55KSAmJiB0LmlzSW5zaWRlUGxvdChnLnggKyBoLCBnLnkpKSB8fCBnLmhpZGUoKSkpO1xuICAgICAgfSxcbiAgICAgIGdldFN0YWNrQm94OiBmdW5jdGlvbiAoZCwgZywgciwgaCwgdSwgcSwgQSkge1xuICAgICAgICB2YXIgZSA9IGcuYXhpcy5yZXZlcnNlZCxcbiAgICAgICAgICAgIGMgPSBkLmludmVydGVkO1xuICAgICAgICBkID0gQS5oZWlnaHQgKyBBLnBvcyAtIChjID8gZC5wbG90TGVmdCA6IGQucGxvdFRvcCk7XG4gICAgICAgIGcgPSBnLmlzTmVnYXRpdmUgJiYgIWUgfHwgIWcuaXNOZWdhdGl2ZSAmJiBlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGMgPyBnID8gaCA6IGggLSBxIDogcixcbiAgICAgICAgICB5OiBjID8gZCAtIHIgLSB1IDogZyA/IGQgLSBoIC0gcSA6IGQgLSBoLFxuICAgICAgICAgIHdpZHRoOiBjID8gcSA6IHUsXG4gICAgICAgICAgaGVpZ2h0OiBjID8gdSA6IHFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgRy5wcm90b3R5cGUuZ2V0U3RhY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgIGcgPSBkLmludmVydGVkO1xuICAgICAgZC55QXhpcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGQuc3RhY2tzICYmIGQuaGFzVmlzaWJsZVNlcmllcyAmJiAoZC5vbGRTdGFja3MgPSBkLnN0YWNrcyk7XG4gICAgICB9KTtcbiAgICAgIGQuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGggPSB0LnhBeGlzICYmIHQueEF4aXMub3B0aW9ucyB8fCB7fTtcbiAgICAgICAgIXQub3B0aW9ucy5zdGFja2luZyB8fCAhMCAhPT0gdC52aXNpYmxlICYmICExICE9PSBkLm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzIHx8ICh0LnN0YWNrS2V5ID0gW3QudHlwZSwgQSh0Lm9wdGlvbnMuc3RhY2ssIFwiXCIpLCBnID8gaC50b3AgOiBoLmxlZnQsIGcgPyBoLmhlaWdodCA6IGgud2lkdGhdLmpvaW4oKSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZy5wcm90b3R5cGUuYnVpbGRTdGFja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZyA9IHRoaXMuc2VyaWVzLFxuICAgICAgICAgIHQgPSBBKHRoaXMub3B0aW9ucy5yZXZlcnNlZFN0YWNrcywgITApLFxuICAgICAgICAgIHIgPSBnLmxlbmd0aCxcbiAgICAgICAgICBoO1xuXG4gICAgICBpZiAoIXRoaXMuaXNYQXhpcykge1xuICAgICAgICB0aGlzLnVzZVBlcmNlbnRhZ2UgPSAhMTtcblxuICAgICAgICBmb3IgKGggPSByOyBoLS07KSB7XG4gICAgICAgICAgdmFyIHUgPSBnW3QgPyBoIDogciAtIGggLSAxXTtcbiAgICAgICAgICB1LnNldFN0YWNrZWRQb2ludHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaCA9IDA7IGggPCByOyBoKyspIGdbaF0ubW9kaWZ5U3RhY2tzKCk7XG5cbiAgICAgICAgZC5maXJlRXZlbnQodGhpcywgXCJhZnRlckJ1aWxkU3RhY2tzXCIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBnLnByb3RvdHlwZS5yZW5kZXJTdGFja1RvdGFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkID0gdGhpcy5jaGFydCxcbiAgICAgICAgICBnID0gZC5yZW5kZXJlcixcbiAgICAgICAgICByID0gdGhpcy5zdGFja3MsXG4gICAgICAgICAgaCA9IHRoaXMuc3RhY2tUb3RhbEdyb3VwO1xuICAgICAgaCB8fCAodGhpcy5zdGFja1RvdGFsR3JvdXAgPSBoID0gZy5nKFwic3RhY2stbGFiZWxzXCIpLmF0dHIoe1xuICAgICAgICB2aXNpYmlsaXR5OiBcInZpc2libGVcIixcbiAgICAgICAgekluZGV4OiA2XG4gICAgICB9KS5hZGQoKSk7XG4gICAgICBoLnRyYW5zbGF0ZShkLnBsb3RMZWZ0LCBkLnBsb3RUb3ApO1xuICAgICAgRShyLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICBFKGQsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgZC5yZW5kZXIoaCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGcucHJvdG90eXBlLnJlc2V0U3RhY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgIGcgPSBkLnN0YWNrcztcbiAgICAgIGQuaXNYQXhpcyB8fCBFKGcsIGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIEUoZywgZnVuY3Rpb24gKGgsIHQpIHtcbiAgICAgICAgICBoLnRvdWNoZWQgPCBkLnN0YWNrc1RvdWNoZWQgPyAoaC5kZXN0cm95KCksIGRlbGV0ZSBnW3RdKSA6IChoLnRvdGFsID0gbnVsbCwgaC5jdW11bGF0aXZlID0gbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGcucHJvdG90eXBlLmNsZWFuU3RhY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLmlzWEF4aXMpIHtcbiAgICAgICAgaWYgKHRoaXMub2xkU3RhY2tzKSB2YXIgZCA9IHRoaXMuc3RhY2tzID0gdGhpcy5vbGRTdGFja3M7XG4gICAgICAgIEUoZCwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBFKGQsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICBkLmN1bXVsYXRpdmUgPSBkLnRvdGFsO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgSi5wcm90b3R5cGUuc2V0U3RhY2tlZFBvaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhY2tpbmcgJiYgKCEwID09PSB0aGlzLnZpc2libGUgfHwgITEgPT09IHRoaXMuY2hhcnQub3B0aW9ucy5jaGFydC5pZ25vcmVIaWRkZW5TZXJpZXMpKSB7XG4gICAgICAgIHZhciBnID0gdGhpcy5wcm9jZXNzZWRYRGF0YSxcbiAgICAgICAgICAgIHQgPSB0aGlzLnByb2Nlc3NlZFlEYXRhLFxuICAgICAgICAgICAgRCA9IFtdLFxuICAgICAgICAgICAgaCA9IHQubGVuZ3RoLFxuICAgICAgICAgICAgTiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIHEgPSBOLnRocmVzaG9sZCxcbiAgICAgICAgICAgIEcgPSBBKE4uc3RhcnRGcm9tVGhyZXNob2xkICYmIHEsIDApLFxuICAgICAgICAgICAgZSA9IE4uc3RhY2s7XG4gICAgICAgIE4gPSBOLnN0YWNraW5nO1xuICAgICAgICB2YXIgYyA9IHRoaXMuc3RhY2tLZXksXG4gICAgICAgICAgICBrID0gXCItXCIgKyBjLFxuICAgICAgICAgICAgbiA9IHRoaXMubmVnU3RhY2tzLFxuICAgICAgICAgICAgZiA9IHRoaXMueUF4aXMsXG4gICAgICAgICAgICBhID0gZi5zdGFja3MsXG4gICAgICAgICAgICBsID0gZi5vbGRTdGFja3MsXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgejtcbiAgICAgICAgZi5zdGFja3NUb3VjaGVkICs9IDE7XG5cbiAgICAgICAgZm9yICh6ID0gMDsgeiA8IGg7IHorKykge1xuICAgICAgICAgIHZhciB3ID0gZ1t6XTtcbiAgICAgICAgICB2YXIgQiA9IHRbel07XG4gICAgICAgICAgdmFyIEwgPSB0aGlzLmdldFN0YWNrSW5kaWNhdG9yKEwsIHcsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgIHZhciBRID0gTC5rZXk7XG4gICAgICAgICAgdmFyIEggPSAodiA9IG4gJiYgQiA8IChHID8gMCA6IHEpKSA/IGsgOiBjO1xuICAgICAgICAgIGFbSF0gfHwgKGFbSF0gPSB7fSk7XG4gICAgICAgICAgYVtIXVt3XSB8fCAobFtIXSAmJiBsW0hdW3ddID8gKGFbSF1bd10gPSBsW0hdW3ddLCBhW0hdW3ddLnRvdGFsID0gbnVsbCkgOiBhW0hdW3ddID0gbmV3IGQuU3RhY2tJdGVtKGYsIGYub3B0aW9ucy5zdGFja0xhYmVscywgdiwgdywgZSkpO1xuICAgICAgICAgIEggPSBhW0hdW3ddO1xuICAgICAgICAgIG51bGwgIT09IEIgPyAoSC5wb2ludHNbUV0gPSBILnBvaW50c1t0aGlzLmluZGV4XSA9IFtBKEguY3VtdWxhdGl2ZSwgRyldLCB1KEguY3VtdWxhdGl2ZSkgfHwgKEguYmFzZSA9IFEpLCBILnRvdWNoZWQgPSBmLnN0YWNrc1RvdWNoZWQsIDAgPCBMLmluZGV4ICYmICExID09PSB0aGlzLnNpbmdsZVN0YWNrcyAmJiAoSC5wb2ludHNbUV1bMF0gPSBILnBvaW50c1t0aGlzLmluZGV4ICsgXCIsXCIgKyB3ICsgXCIsMFwiXVswXSkpIDogSC5wb2ludHNbUV0gPSBILnBvaW50c1t0aGlzLmluZGV4XSA9IG51bGw7XG4gICAgICAgICAgXCJwZXJjZW50XCIgPT09IE4gPyAodiA9IHYgPyBjIDogaywgbiAmJiBhW3ZdICYmIGFbdl1bd10gPyAodiA9IGFbdl1bd10sIEgudG90YWwgPSB2LnRvdGFsID0gTWF0aC5tYXgodi50b3RhbCwgSC50b3RhbCkgKyBNYXRoLmFicyhCKSB8fCAwKSA6IEgudG90YWwgPSByKEgudG90YWwgKyAoTWF0aC5hYnMoQikgfHwgMCkpKSA6IEgudG90YWwgPSByKEgudG90YWwgKyAoQiB8fCAwKSk7XG4gICAgICAgICAgSC5jdW11bGF0aXZlID0gQShILmN1bXVsYXRpdmUsIEcpICsgKEIgfHwgMCk7XG4gICAgICAgICAgbnVsbCAhPT0gQiAmJiAoSC5wb2ludHNbUV0ucHVzaChILmN1bXVsYXRpdmUpLCBEW3pdID0gSC5jdW11bGF0aXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFwicGVyY2VudFwiID09PSBOICYmIChmLnVzZVBlcmNlbnRhZ2UgPSAhMCk7XG4gICAgICAgIHRoaXMuc3RhY2tlZFlEYXRhID0gRDtcbiAgICAgICAgZi5vbGRTdGFja3MgPSB7fTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgSi5wcm90b3R5cGUubW9kaWZ5U3RhY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgIGcgPSBkLnN0YWNrS2V5LFxuICAgICAgICAgIHIgPSBkLnlBeGlzLnN0YWNrcyxcbiAgICAgICAgICBoID0gZC5wcm9jZXNzZWRYRGF0YSxcbiAgICAgICAgICB1LFxuICAgICAgICAgIHEgPSBkLm9wdGlvbnMuc3RhY2tpbmc7XG4gICAgICBkW3EgKyBcIlN0YWNrZXJcIl0gJiYgW2csIFwiLVwiICsgZ10uZm9yRWFjaChmdW5jdGlvbiAoZykge1xuICAgICAgICBmb3IgKHZhciBlID0gaC5sZW5ndGgsIGMsIGs7IGUtLTspIGlmIChjID0gaFtlXSwgdSA9IGQuZ2V0U3RhY2tJbmRpY2F0b3IodSwgYywgZC5pbmRleCwgZyksIGsgPSAoYyA9IHJbZ10gJiYgcltnXVtjXSkgJiYgYy5wb2ludHNbdS5rZXldKSBkW3EgKyBcIlN0YWNrZXJcIl0oaywgYywgZSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgSi5wcm90b3R5cGUucGVyY2VudFN0YWNrZXIgPSBmdW5jdGlvbiAoZCwgZywgdSkge1xuICAgICAgZyA9IGcudG90YWwgPyAxMDAgLyBnLnRvdGFsIDogMDtcbiAgICAgIGRbMF0gPSByKGRbMF0gKiBnKTtcbiAgICAgIGRbMV0gPSByKGRbMV0gKiBnKTtcbiAgICAgIHRoaXMuc3RhY2tlZFlEYXRhW3VdID0gZFsxXTtcbiAgICB9O1xuXG4gICAgSi5wcm90b3R5cGUuZ2V0U3RhY2tJbmRpY2F0b3IgPSBmdW5jdGlvbiAoZCwgZywgciwgaCkge1xuICAgICAgIXUoZCkgfHwgZC54ICE9PSBnIHx8IGggJiYgZC5rZXkgIT09IGggPyBkID0ge1xuICAgICAgICB4OiBnLFxuICAgICAgICBpbmRleDogMCxcbiAgICAgICAga2V5OiBoXG4gICAgICB9IDogZC5pbmRleCsrO1xuICAgICAgZC5rZXkgPSBbciwgZywgZC5pbmRleF0uam9pbigpO1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfTtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9EeW5hbWljcy5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9Qb2ludC5qc1wiXSwgcltcInBhcnRzL1RpbWUuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZywgciwgdSkge1xuICAgIHZhciBJID0gdS5hZGRFdmVudCxcbiAgICAgICAgTSA9IHUuYW5pbWF0ZSxcbiAgICAgICAgRSA9IHUuY3JlYXRlRWxlbWVudCxcbiAgICAgICAgQSA9IHUuY3NzLFxuICAgICAgICBHID0gdS5kZWZpbmVkLFxuICAgICAgICBKID0gdS5lcmFzZSxcbiAgICAgICAgeSA9IHUuZXJyb3IsXG4gICAgICAgIHQgPSB1LmV4dGVuZCxcbiAgICAgICAgRCA9IHUuZmlyZUV2ZW50LFxuICAgICAgICBoID0gdS5pc0FycmF5LFxuICAgICAgICBOID0gdS5pc051bWJlcixcbiAgICAgICAgcSA9IHUuaXNPYmplY3QsXG4gICAgICAgIFAgPSB1LmlzU3RyaW5nLFxuICAgICAgICBlID0gdS5tZXJnZSxcbiAgICAgICAgYyA9IHUub2JqZWN0RWFjaCxcbiAgICAgICAgayA9IHUucGljayxcbiAgICAgICAgbiA9IHUucmVsYXRpdmVMZW5ndGgsXG4gICAgICAgIGYgPSB1LnNldEFuaW1hdGlvbixcbiAgICAgICAgYSA9IHUuc3BsYXQsXG4gICAgICAgIGwgPSBkLkF4aXM7XG4gICAgdSA9IGQuQ2hhcnQ7XG4gICAgdmFyIHYgPSBkLlNlcmllcyxcbiAgICAgICAgeiA9IGQuc2VyaWVzVHlwZXM7XG5cbiAgICBkLmNsZWFuUmVjdXJzaXZlbHkgPSBmdW5jdGlvbiAoYSwgZSkge1xuICAgICAgdmFyIGYgPSB7fTtcbiAgICAgIGMoYSwgZnVuY3Rpb24gKGMsIGspIHtcbiAgICAgICAgaWYgKHEoYVtrXSwgITApICYmICFhLm5vZGVUeXBlICYmIGVba10pIGMgPSBkLmNsZWFuUmVjdXJzaXZlbHkoYVtrXSwgZVtrXSksIE9iamVjdC5rZXlzKGMpLmxlbmd0aCAmJiAoZltrXSA9IGMpO2Vsc2UgaWYgKHEoYVtrXSkgfHwgYVtrXSAhPT0gZVtrXSkgZltrXSA9IGFba107XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmO1xuICAgIH07XG5cbiAgICB0KHUucHJvdG90eXBlLCB7XG4gICAgICBhZGRTZXJpZXM6IGZ1bmN0aW9uIChhLCBjLCBlKSB7XG4gICAgICAgIHZhciBmLFxuICAgICAgICAgICAgZCA9IHRoaXM7XG4gICAgICAgIGEgJiYgKGMgPSBrKGMsICEwKSwgRChkLCBcImFkZFNlcmllc1wiLCB7XG4gICAgICAgICAgb3B0aW9uczogYVxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZiA9IGQuaW5pdFNlcmllcyhhKTtcbiAgICAgICAgICBkLmlzRGlydHlMZWdlbmQgPSAhMDtcbiAgICAgICAgICBkLmxpbmtTZXJpZXMoKTtcbiAgICAgICAgICBmLmVuYWJsZWREYXRhU29ydGluZyAmJiBmLnNldERhdGEoYS5kYXRhLCAhMSk7XG4gICAgICAgICAgRChkLCBcImFmdGVyQWRkU2VyaWVzXCIsIHtcbiAgICAgICAgICAgIHNlcmllczogZlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGMgJiYgZC5yZWRyYXcoZSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9LFxuICAgICAgYWRkQXhpczogZnVuY3Rpb24gKGEsIGMsIGUsIGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQXhpcyhjID8gXCJ4QXhpc1wiIDogXCJ5QXhpc1wiLCB7XG4gICAgICAgICAgYXhpczogYSxcbiAgICAgICAgICByZWRyYXc6IGUsXG4gICAgICAgICAgYW5pbWF0aW9uOiBmXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGFkZENvbG9yQXhpczogZnVuY3Rpb24gKGEsIGMsIGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQXhpcyhcImNvbG9yQXhpc1wiLCB7XG4gICAgICAgICAgYXhpczogYSxcbiAgICAgICAgICByZWRyYXc6IGMsXG4gICAgICAgICAgYW5pbWF0aW9uOiBlXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZUF4aXM6IGZ1bmN0aW9uIChjLCBmKSB7XG4gICAgICAgIHZhciBoID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgZyA9IFwiY29sb3JBeGlzXCIgPT09IGMsXG4gICAgICAgICAgICBuID0gZi5yZWRyYXcsXG4gICAgICAgICAgICB3ID0gZi5hbmltYXRpb247XG4gICAgICAgIGYgPSBlKGYuYXhpcywge1xuICAgICAgICAgIGluZGV4OiB0aGlzW2NdLmxlbmd0aCxcbiAgICAgICAgICBpc1g6IFwieEF4aXNcIiA9PT0gY1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHAgPSBnID8gbmV3IGQuQ29sb3JBeGlzKHRoaXMsIGYpIDogbmV3IGwodGhpcywgZik7XG4gICAgICAgIGhbY10gPSBhKGhbY10gfHwge30pO1xuICAgICAgICBoW2NdLnB1c2goZik7XG4gICAgICAgIGcgJiYgKHRoaXMuaXNEaXJ0eUxlZ2VuZCA9ICEwLCB0aGlzLmF4ZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEuc2VyaWVzID0gW107XG4gICAgICAgIH0pLCB0aGlzLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYS5iaW5kQXhlcygpO1xuICAgICAgICAgIGEuaXNEaXJ0eURhdGEgPSAhMDtcbiAgICAgICAgfSkpO1xuICAgICAgICBrKG4sICEwKSAmJiB0aGlzLnJlZHJhdyh3KTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9LFxuICAgICAgc2hvd0xvYWRpbmc6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBjID0gdGhpcyxcbiAgICAgICAgICAgIGUgPSBjLm9wdGlvbnMsXG4gICAgICAgICAgICBmID0gYy5sb2FkaW5nRGl2LFxuICAgICAgICAgICAgZCA9IGUubG9hZGluZyxcbiAgICAgICAgICAgIGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZiAmJiBBKGYsIHtcbiAgICAgICAgICAgIGxlZnQ6IGMucGxvdExlZnQgKyBcInB4XCIsXG4gICAgICAgICAgICB0b3A6IGMucGxvdFRvcCArIFwicHhcIixcbiAgICAgICAgICAgIHdpZHRoOiBjLnBsb3RXaWR0aCArIFwicHhcIixcbiAgICAgICAgICAgIGhlaWdodDogYy5wbG90SGVpZ2h0ICsgXCJweFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZiB8fCAoYy5sb2FkaW5nRGl2ID0gZiA9IEUoXCJkaXZcIiwge1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJoaWdoY2hhcnRzLWxvYWRpbmcgaGlnaGNoYXJ0cy1sb2FkaW5nLWhpZGRlblwiXG4gICAgICAgIH0sIG51bGwsIGMuY29udGFpbmVyKSwgYy5sb2FkaW5nU3BhbiA9IEUoXCJzcGFuXCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwiaGlnaGNoYXJ0cy1sb2FkaW5nLWlubmVyXCJcbiAgICAgICAgfSwgbnVsbCwgZiksIEkoYywgXCJyZWRyYXdcIiwgaCkpO1xuICAgICAgICBmLmNsYXNzTmFtZSA9IFwiaGlnaGNoYXJ0cy1sb2FkaW5nXCI7XG4gICAgICAgIGMubG9hZGluZ1NwYW4uaW5uZXJIVE1MID0gayhhLCBlLmxhbmcubG9hZGluZywgXCJcIik7XG4gICAgICAgIGMuc3R5bGVkTW9kZSB8fCAoQShmLCB0KGQuc3R5bGUsIHtcbiAgICAgICAgICB6SW5kZXg6IDEwXG4gICAgICAgIH0pKSwgQShjLmxvYWRpbmdTcGFuLCBkLmxhYmVsU3R5bGUpLCBjLmxvYWRpbmdTaG93biB8fCAoQShmLCB7XG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICBkaXNwbGF5OiBcIlwiXG4gICAgICAgIH0pLCBNKGYsIHtcbiAgICAgICAgICBvcGFjaXR5OiBkLnN0eWxlLm9wYWNpdHkgfHwgLjVcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiBkLnNob3dEdXJhdGlvbiB8fCAwXG4gICAgICAgIH0pKSk7XG4gICAgICAgIGMubG9hZGluZ1Nob3duID0gITA7XG4gICAgICAgIGgoKTtcbiAgICAgIH0sXG4gICAgICBoaWRlTG9hZGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGMgPSB0aGlzLmxvYWRpbmdEaXY7XG4gICAgICAgIGMgJiYgKGMuY2xhc3NOYW1lID0gXCJoaWdoY2hhcnRzLWxvYWRpbmcgaGlnaGNoYXJ0cy1sb2FkaW5nLWhpZGRlblwiLCB0aGlzLnN0eWxlZE1vZGUgfHwgTShjLCB7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IGEubG9hZGluZy5oaWRlRHVyYXRpb24gfHwgMTAwLFxuICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBBKGMsIHtcbiAgICAgICAgICAgICAgZGlzcGxheTogXCJub25lXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmxvYWRpbmdTaG93biA9ICExO1xuICAgICAgfSxcbiAgICAgIHByb3BzUmVxdWlyZURpcnR5Qm94OiBcImJhY2tncm91bmRDb2xvciBib3JkZXJDb2xvciBib3JkZXJXaWR0aCBib3JkZXJSYWRpdXMgcGxvdEJhY2tncm91bmRDb2xvciBwbG90QmFja2dyb3VuZEltYWdlIHBsb3RCb3JkZXJDb2xvciBwbG90Qm9yZGVyV2lkdGggcGxvdFNoYWRvdyBzaGFkb3dcIi5zcGxpdChcIiBcIiksXG4gICAgICBwcm9wc1JlcXVpcmVSZWZsb3c6IFwibWFyZ2luIG1hcmdpblRvcCBtYXJnaW5SaWdodCBtYXJnaW5Cb3R0b20gbWFyZ2luTGVmdCBzcGFjaW5nIHNwYWNpbmdUb3Agc3BhY2luZ1JpZ2h0IHNwYWNpbmdCb3R0b20gc3BhY2luZ0xlZnRcIi5zcGxpdChcIiBcIiksXG4gICAgICBwcm9wc1JlcXVpcmVVcGRhdGVTZXJpZXM6IFwiY2hhcnQuaW52ZXJ0ZWQgY2hhcnQucG9sYXIgY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzIGNoYXJ0LnR5cGUgY29sb3JzIHBsb3RPcHRpb25zIHRpbWUgdG9vbHRpcFwiLnNwbGl0KFwiIFwiKSxcbiAgICAgIGNvbGxlY3Rpb25zV2l0aFVwZGF0ZTogW1wieEF4aXNcIiwgXCJ5QXhpc1wiLCBcInpBeGlzXCIsIFwic2VyaWVzXCJdLFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoZiwgaCwgbCwgZykge1xuICAgICAgICB2YXIgdiA9IHRoaXMsXG4gICAgICAgICAgICB3ID0ge1xuICAgICAgICAgIGNyZWRpdHM6IFwiYWRkQ3JlZGl0c1wiLFxuICAgICAgICAgIHRpdGxlOiBcInNldFRpdGxlXCIsXG4gICAgICAgICAgc3VidGl0bGU6IFwic2V0U3VidGl0bGVcIixcbiAgICAgICAgICBjYXB0aW9uOiBcInNldENhcHRpb25cIlxuICAgICAgICB9LFxuICAgICAgICAgICAgcCxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBxLFxuICAgICAgICAgICAgdCA9IGYuaXNSZXNwb25zaXZlT3B0aW9ucyxcbiAgICAgICAgICAgIHogPSBbXTtcbiAgICAgICAgRCh2LCBcInVwZGF0ZVwiLCB7XG4gICAgICAgICAgb3B0aW9uczogZlxuICAgICAgICB9KTtcbiAgICAgICAgdCB8fCB2LnNldFJlc3BvbnNpdmUoITEsICEwKTtcbiAgICAgICAgZiA9IGQuY2xlYW5SZWN1cnNpdmVseShmLCB2Lm9wdGlvbnMpO1xuICAgICAgICBlKCEwLCB2LnVzZXJPcHRpb25zLCBmKTtcblxuICAgICAgICBpZiAocCA9IGYuY2hhcnQpIHtcbiAgICAgICAgICBlKCEwLCB2Lm9wdGlvbnMuY2hhcnQsIHApO1xuICAgICAgICAgIFwiY2xhc3NOYW1lXCIgaW4gcCAmJiB2LnNldENsYXNzTmFtZShwLmNsYXNzTmFtZSk7XG4gICAgICAgICAgXCJyZWZsb3dcIiBpbiBwICYmIHYuc2V0UmVmbG93KHAucmVmbG93KTtcblxuICAgICAgICAgIGlmIChcImludmVydGVkXCIgaW4gcCB8fCBcInBvbGFyXCIgaW4gcCB8fCBcInR5cGVcIiBpbiBwKSB7XG4gICAgICAgICAgICB2LnByb3BGcm9tU2VyaWVzKCk7XG4gICAgICAgICAgICB2YXIgQiA9ICEwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFwiYWxpZ25UaWNrc1wiIGluIHAgJiYgKEIgPSAhMCk7XG4gICAgICAgICAgYyhwLCBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICAgICAgLTEgIT09IHYucHJvcHNSZXF1aXJlVXBkYXRlU2VyaWVzLmluZGV4T2YoXCJjaGFydC5cIiArIGMpICYmIChiID0gITApO1xuICAgICAgICAgICAgLTEgIT09IHYucHJvcHNSZXF1aXJlRGlydHlCb3guaW5kZXhPZihjKSAmJiAodi5pc0RpcnR5Qm94ID0gITApO1xuICAgICAgICAgICAgdCB8fCAtMSA9PT0gdi5wcm9wc1JlcXVpcmVSZWZsb3cuaW5kZXhPZihjKSB8fCAocSA9ICEwKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAhdi5zdHlsZWRNb2RlICYmIFwic3R5bGVcIiBpbiBwICYmIHYucmVuZGVyZXIuc2V0U3R5bGUocC5zdHlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICAhdi5zdHlsZWRNb2RlICYmIGYuY29sb3JzICYmICh0aGlzLm9wdGlvbnMuY29sb3JzID0gZi5jb2xvcnMpO1xuICAgICAgICBmLnBsb3RPcHRpb25zICYmIGUoITAsIHRoaXMub3B0aW9ucy5wbG90T3B0aW9ucywgZi5wbG90T3B0aW9ucyk7XG4gICAgICAgIGYudGltZSAmJiB0aGlzLnRpbWUgPT09IGQudGltZSAmJiAodGhpcy50aW1lID0gbmV3IHIoZi50aW1lKSk7XG4gICAgICAgIGMoZiwgZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgICBpZiAodltjXSAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2W2NdLnVwZGF0ZSkgdltjXS51cGRhdGUoYSwgITEpO2Vsc2UgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZbd1tjXV0pIHZbd1tjXV0oYSk7XG4gICAgICAgICAgXCJjaGFydFwiICE9PSBjICYmIC0xICE9PSB2LnByb3BzUmVxdWlyZVVwZGF0ZVNlcmllcy5pbmRleE9mKGMpICYmIChiID0gITApO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uc1dpdGhVcGRhdGUuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGlmIChmW2JdKSB7XG4gICAgICAgICAgICBpZiAoXCJzZXJpZXNcIiA9PT0gYikge1xuICAgICAgICAgICAgICB2YXIgYyA9IFtdO1xuICAgICAgICAgICAgICB2W2JdLmZvckVhY2goZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBhLm9wdGlvbnMuaXNJbnRlcm5hbCB8fCBjLnB1c2goayhhLm9wdGlvbnMuaW5kZXgsIGIpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGEoZltiXSkuZm9yRWFjaChmdW5jdGlvbiAoYSwgZSkge1xuICAgICAgICAgICAgICAoZSA9IEcoYS5pZCkgJiYgdi5nZXQoYS5pZCkgfHwgdltiXVtjID8gY1tlXSA6IGVdKSAmJiBlLmNvbGwgPT09IGIgJiYgKGUudXBkYXRlKGEsICExKSwgbCAmJiAoZS50b3VjaGVkID0gITApKTtcbiAgICAgICAgICAgICAgIWUgJiYgbCAmJiB2LmNvbGxlY3Rpb25zV2l0aEluaXRbYl0gJiYgKHYuY29sbGVjdGlvbnNXaXRoSW5pdFtiXVswXS5hcHBseSh2LCBbYV0uY29uY2F0KHYuY29sbGVjdGlvbnNXaXRoSW5pdFtiXVsxXSB8fCBbXSkuY29uY2F0KFshMV0pKS50b3VjaGVkID0gITApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsICYmIHZbYl0uZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICBhLnRvdWNoZWQgfHwgYS5vcHRpb25zLmlzSW50ZXJuYWwgPyBkZWxldGUgYS50b3VjaGVkIDogei5wdXNoKGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgei5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYS5yZW1vdmUgJiYgYS5yZW1vdmUoITEpO1xuICAgICAgICB9KTtcbiAgICAgICAgQiAmJiB2LmF4ZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEudXBkYXRlKHt9LCAhMSk7XG4gICAgICAgIH0pO1xuICAgICAgICBiICYmIHYuZ2V0U2VyaWVzT3JkZXJCeUxpbmtzKCkuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEuY2hhcnQgJiYgYS51cGRhdGUoe30sICExKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGYubG9hZGluZyAmJiBlKCEwLCB2Lm9wdGlvbnMubG9hZGluZywgZi5sb2FkaW5nKTtcbiAgICAgICAgQiA9IHAgJiYgcC53aWR0aDtcbiAgICAgICAgcCA9IHAgJiYgcC5oZWlnaHQ7XG4gICAgICAgIFAocCkgJiYgKHAgPSBuKHAsIEIgfHwgdi5jaGFydFdpZHRoKSk7XG4gICAgICAgIHEgfHwgTihCKSAmJiBCICE9PSB2LmNoYXJ0V2lkdGggfHwgTihwKSAmJiBwICE9PSB2LmNoYXJ0SGVpZ2h0ID8gdi5zZXRTaXplKEIsIHAsIGcpIDogayhoLCAhMCkgJiYgdi5yZWRyYXcoZyk7XG4gICAgICAgIEQodiwgXCJhZnRlclVwZGF0ZVwiLCB7XG4gICAgICAgICAgb3B0aW9uczogZixcbiAgICAgICAgICByZWRyYXc6IGgsXG4gICAgICAgICAgYW5pbWF0aW9uOiBnXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHNldFN1YnRpdGxlOiBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICB0aGlzLmFwcGx5RGVzY3JpcHRpb24oXCJzdWJ0aXRsZVwiLCBhKTtcbiAgICAgICAgdGhpcy5sYXlPdXRUaXRsZXMoYyk7XG4gICAgICB9LFxuICAgICAgc2V0Q2FwdGlvbjogZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgdGhpcy5hcHBseURlc2NyaXB0aW9uKFwiY2FwdGlvblwiLCBhKTtcbiAgICAgICAgdGhpcy5sYXlPdXRUaXRsZXMoYyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdS5wcm90b3R5cGUuY29sbGVjdGlvbnNXaXRoSW5pdCA9IHtcbiAgICAgIHhBeGlzOiBbdS5wcm90b3R5cGUuYWRkQXhpcywgWyEwXV0sXG4gICAgICB5QXhpczogW3UucHJvdG90eXBlLmFkZEF4aXMsIFshMV1dLFxuICAgICAgc2VyaWVzOiBbdS5wcm90b3R5cGUuYWRkU2VyaWVzXVxuICAgIH07XG4gICAgdChnLnByb3RvdHlwZSwge1xuICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoYSwgYywgZSwgZikge1xuICAgICAgICBmdW5jdGlvbiBkKCkge1xuICAgICAgICAgIGguYXBwbHlPcHRpb25zKGEpO1xuICAgICAgICAgIHZhciBmID0gYiAmJiBoLmhhc0R1bW15R3JhcGhpYztcbiAgICAgICAgICBmID0gbnVsbCA9PT0gaC55ID8gIWYgOiBmO1xuICAgICAgICAgIGIgJiYgZiAmJiAoaC5ncmFwaGljID0gYi5kZXN0cm95KCksIGRlbGV0ZSBoLmhhc0R1bW15R3JhcGhpYyk7XG4gICAgICAgICAgcShhLCAhMCkgJiYgKGIgJiYgYi5lbGVtZW50ICYmIGEgJiYgYS5tYXJrZXIgJiYgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGEubWFya2VyLnN5bWJvbCAmJiAoaC5ncmFwaGljID0gYi5kZXN0cm95KCkpLCBhICYmIGEuZGF0YUxhYmVscyAmJiBoLmRhdGFMYWJlbCAmJiAoaC5kYXRhTGFiZWwgPSBoLmRhdGFMYWJlbC5kZXN0cm95KCkpLCBoLmNvbm5lY3RvciAmJiAoaC5jb25uZWN0b3IgPSBoLmNvbm5lY3Rvci5kZXN0cm95KCkpKTtcbiAgICAgICAgICBnID0gaC5pbmRleDtcbiAgICAgICAgICBsLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKGgsIGcpO1xuICAgICAgICAgIHYuZGF0YVtnXSA9IHEodi5kYXRhW2ddLCAhMCkgfHwgcShhLCAhMCkgPyBoLm9wdGlvbnMgOiBrKGEsIHYuZGF0YVtnXSk7XG4gICAgICAgICAgbC5pc0RpcnR5ID0gbC5pc0RpcnR5RGF0YSA9ICEwO1xuICAgICAgICAgICFsLmZpeGVkQm94ICYmIGwuaGFzQ2FydGVzaWFuU2VyaWVzICYmIChuLmlzRGlydHlCb3ggPSAhMCk7XG4gICAgICAgICAgXCJwb2ludFwiID09PSB2LmxlZ2VuZFR5cGUgJiYgKG4uaXNEaXJ0eUxlZ2VuZCA9ICEwKTtcbiAgICAgICAgICBjICYmIG4ucmVkcmF3KGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGggPSB0aGlzLFxuICAgICAgICAgICAgbCA9IGguc2VyaWVzLFxuICAgICAgICAgICAgYiA9IGguZ3JhcGhpYyxcbiAgICAgICAgICAgIGcsXG4gICAgICAgICAgICBuID0gbC5jaGFydCxcbiAgICAgICAgICAgIHYgPSBsLm9wdGlvbnM7XG4gICAgICAgIGMgPSBrKGMsICEwKTtcbiAgICAgICAgITEgPT09IGYgPyBkKCkgOiBoLmZpcmVQb2ludEV2ZW50KFwidXBkYXRlXCIsIHtcbiAgICAgICAgICBvcHRpb25zOiBhXG4gICAgICAgIH0sIGQpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgdGhpcy5zZXJpZXMucmVtb3ZlUG9pbnQodGhpcy5zZXJpZXMuZGF0YS5pbmRleE9mKHRoaXMpLCBhLCBjKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0KHYucHJvdG90eXBlLCB7XG4gICAgICBhZGRQb2ludDogZnVuY3Rpb24gKGEsIGMsIGUsIGYsIGQpIHtcbiAgICAgICAgdmFyIGggPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBsID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgYiA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBnID0gdGhpcy54QXhpcztcbiAgICAgICAgZyA9IGcgJiYgZy5oYXNOYW1lcyAmJiBnLm5hbWVzO1xuICAgICAgICB2YXIgbiA9IGguZGF0YSxcbiAgICAgICAgICAgIHYgPSB0aGlzLnhEYXRhLFxuICAgICAgICAgICAgcTtcbiAgICAgICAgYyA9IGsoYywgITApO1xuICAgICAgICB2YXIgdyA9IHtcbiAgICAgICAgICBzZXJpZXM6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wb2ludENsYXNzLnByb3RvdHlwZS5hcHBseU9wdGlvbnMuYXBwbHkodywgW2FdKTtcbiAgICAgICAgdmFyIHQgPSB3Lng7XG4gICAgICAgIHZhciBtID0gdi5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLnJlcXVpcmVTb3J0aW5nICYmIHQgPCB2W20gLSAxXSkgZm9yIChxID0gITA7IG0gJiYgdlttIC0gMV0gPiB0OykgbS0tO1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKHcsIFwic3BsaWNlXCIsIG0sIDAsIDApO1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKHcsIG0pO1xuICAgICAgICBnICYmIHcubmFtZSAmJiAoZ1t0XSA9IHcubmFtZSk7XG4gICAgICAgIG4uc3BsaWNlKG0sIDAsIGEpO1xuICAgICAgICBxICYmICh0aGlzLmRhdGEuc3BsaWNlKG0sIDAsIG51bGwpLCB0aGlzLnByb2Nlc3NEYXRhKCkpO1xuICAgICAgICBcInBvaW50XCIgPT09IGgubGVnZW5kVHlwZSAmJiB0aGlzLmdlbmVyYXRlUG9pbnRzKCk7XG4gICAgICAgIGUgJiYgKGxbMF0gJiYgbFswXS5yZW1vdmUgPyBsWzBdLnJlbW92ZSghMSkgOiAobC5zaGlmdCgpLCB0aGlzLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKHcsIFwic2hpZnRcIiksIG4uc2hpZnQoKSkpO1xuICAgICAgICAhMSAhPT0gZCAmJiBEKHRoaXMsIFwiYWRkUG9pbnRcIiwge1xuICAgICAgICAgIHBvaW50OiB3XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmlzRGlydHlEYXRhID0gdGhpcy5pc0RpcnR5ID0gITA7XG4gICAgICAgIGMgJiYgYi5yZWRyYXcoZik7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlUG9pbnQ6IGZ1bmN0aW9uIChhLCBjLCBlKSB7XG4gICAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICAgIGggPSBkLmRhdGEsXG4gICAgICAgICAgICBsID0gaFthXSxcbiAgICAgICAgICAgIGcgPSBkLnBvaW50cyxcbiAgICAgICAgICAgIGIgPSBkLmNoYXJ0LFxuICAgICAgICAgICAgbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBnICYmIGcubGVuZ3RoID09PSBoLmxlbmd0aCAmJiBnLnNwbGljZShhLCAxKTtcbiAgICAgICAgICBoLnNwbGljZShhLCAxKTtcbiAgICAgICAgICBkLm9wdGlvbnMuZGF0YS5zcGxpY2UoYSwgMSk7XG4gICAgICAgICAgZC51cGRhdGVQYXJhbGxlbEFycmF5cyhsIHx8IHtcbiAgICAgICAgICAgIHNlcmllczogZFxuICAgICAgICAgIH0sIFwic3BsaWNlXCIsIGEsIDEpO1xuICAgICAgICAgIGwgJiYgbC5kZXN0cm95KCk7XG4gICAgICAgICAgZC5pc0RpcnR5ID0gITA7XG4gICAgICAgICAgZC5pc0RpcnR5RGF0YSA9ICEwO1xuICAgICAgICAgIGMgJiYgYi5yZWRyYXcoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmKGUsIGIpO1xuICAgICAgICBjID0gayhjLCAhMCk7XG4gICAgICAgIGwgPyBsLmZpcmVQb2ludEV2ZW50KFwicmVtb3ZlXCIsIG51bGwsIG4pIDogbigpO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGEsIGMsIGUsIGYpIHtcbiAgICAgICAgZnVuY3Rpb24gZCgpIHtcbiAgICAgICAgICBoLmRlc3Ryb3koZik7XG4gICAgICAgICAgaC5yZW1vdmUgPSBudWxsO1xuICAgICAgICAgIGwuaXNEaXJ0eUxlZ2VuZCA9IGwuaXNEaXJ0eUJveCA9ICEwO1xuICAgICAgICAgIGwubGlua1NlcmllcygpO1xuICAgICAgICAgIGsoYSwgITApICYmIGwucmVkcmF3KGMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGggPSB0aGlzLFxuICAgICAgICAgICAgbCA9IGguY2hhcnQ7XG4gICAgICAgICExICE9PSBlID8gRChoLCBcInJlbW92ZVwiLCBudWxsLCBkKSA6IGQoKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgIGEgPSBkLmNsZWFuUmVjdXJzaXZlbHkoYSwgdGhpcy51c2VyT3B0aW9ucyk7XG4gICAgICAgIEQodGhpcywgXCJ1cGRhdGVcIiwge1xuICAgICAgICAgIG9wdGlvbnM6IGFcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBmID0gdGhpcyxcbiAgICAgICAgICAgIGggPSBmLmNoYXJ0LFxuICAgICAgICAgICAgbCA9IGYudXNlck9wdGlvbnMsXG4gICAgICAgICAgICBnID0gZi5pbml0aWFsVHlwZSB8fCBmLnR5cGUsXG4gICAgICAgICAgICBuID0gYS50eXBlIHx8IGwudHlwZSB8fCBoLm9wdGlvbnMuY2hhcnQudHlwZSxcbiAgICAgICAgICAgIGIgPSAhKHRoaXMuaGFzRGVyaXZlZERhdGEgfHwgYS5kYXRhR3JvdXBpbmcgfHwgbiAmJiBuICE9PSB0aGlzLnR5cGUgfHwgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGEucG9pbnRTdGFydCB8fCBhLnBvaW50SW50ZXJ2YWwgfHwgYS5wb2ludEludGVydmFsVW5pdCB8fCBhLmtleXMpLFxuICAgICAgICAgICAgdiA9IHpbZ10ucHJvdG90eXBlLFxuICAgICAgICAgICAgcSxcbiAgICAgICAgICAgIHcgPSBbXCJncm91cFwiLCBcIm1hcmtlckdyb3VwXCIsIFwiZGF0YUxhYmVsc0dyb3VwXCIsIFwidHJhbnNmb3JtR3JvdXBcIl0sXG4gICAgICAgICAgICByID0gW1wiZXZlbnRPcHRpb25zXCIsIFwibmF2aWdhdG9yU2VyaWVzXCIsIFwiYmFzZVNlcmllc1wiXSxcbiAgICAgICAgICAgIEIgPSBmLmZpbmlzaGVkQW5pbWF0aW5nICYmIHtcbiAgICAgICAgICBhbmltYXRpb246ICExXG4gICAgICAgIH0sXG4gICAgICAgICAgICB1ID0ge307XG4gICAgICAgIGIgJiYgKHIucHVzaChcImRhdGFcIiwgXCJpc0RpcnR5RGF0YVwiLCBcInBvaW50c1wiLCBcInByb2Nlc3NlZFhEYXRhXCIsIFwicHJvY2Vzc2VkWURhdGFcIiwgXCJ4SW5jcmVtZW50XCIsIFwiX2hhc1BvaW50TWFya2Vyc1wiLCBcIl9oYXNQb2ludExhYmVsc1wiLCBcIm1hcE1hcFwiLCBcIm1hcERhdGFcIiwgXCJtaW5ZXCIsIFwibWF4WVwiLCBcIm1pblhcIiwgXCJtYXhYXCIpLCAhMSAhPT0gYS52aXNpYmxlICYmIHIucHVzaChcImFyZWFcIiwgXCJncmFwaFwiKSwgZi5wYXJhbGxlbEFycmF5cy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgci5wdXNoKGEgKyBcIkRhdGFcIik7XG4gICAgICAgIH0pLCBhLmRhdGEgJiYgKGEuZGF0YVNvcnRpbmcgJiYgdChmLm9wdGlvbnMuZGF0YVNvcnRpbmcsIGEuZGF0YVNvcnRpbmcpLCB0aGlzLnNldERhdGEoYS5kYXRhLCAhMSkpKTtcbiAgICAgICAgYSA9IGUobCwgQiwge1xuICAgICAgICAgIGluZGV4OiBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgbC5pbmRleCA/IGYuaW5kZXggOiBsLmluZGV4LFxuICAgICAgICAgIHBvaW50U3RhcnQ6IGsobC5wb2ludFN0YXJ0LCBmLnhEYXRhWzBdKVxuICAgICAgICB9LCAhYiAmJiB7XG4gICAgICAgICAgZGF0YTogZi5vcHRpb25zLmRhdGFcbiAgICAgICAgfSwgYSk7XG4gICAgICAgIGIgJiYgYS5kYXRhICYmIChhLmRhdGEgPSBmLm9wdGlvbnMuZGF0YSk7XG4gICAgICAgIHIgPSB3LmNvbmNhdChyKTtcbiAgICAgICAgci5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgclthXSA9IGZbYV07XG4gICAgICAgICAgZGVsZXRlIGZbYV07XG4gICAgICAgIH0pO1xuICAgICAgICBmLnJlbW92ZSghMSwgbnVsbCwgITEsICEwKTtcblxuICAgICAgICBmb3IgKHEgaW4gdikgZltxXSA9IHZvaWQgMDtcblxuICAgICAgICB6W24gfHwgZ10gPyB0KGYsIHpbbiB8fCBnXS5wcm90b3R5cGUpIDogeSgxNywgITAsIGgsIHtcbiAgICAgICAgICBtaXNzaW5nTW9kdWxlRm9yOiBuIHx8IGdcbiAgICAgICAgfSk7XG4gICAgICAgIHIuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGZbYV0gPSByW2FdO1xuICAgICAgICB9KTtcbiAgICAgICAgZi5pbml0KGgsIGEpO1xuXG4gICAgICAgIGlmIChiICYmIHRoaXMucG9pbnRzKSB7XG4gICAgICAgICAgdmFyIG0gPSBmLm9wdGlvbnM7XG4gICAgICAgICAgITEgPT09IG0udmlzaWJsZSA/ICh1LmdyYXBoaWMgPSAxLCB1LmRhdGFMYWJlbCA9IDEpIDogZi5faGFzUG9pbnRMYWJlbHMgfHwgKG4gPSBtLm1hcmtlciwgdiA9IG0uZGF0YUxhYmVscywgbiAmJiAoITEgPT09IG4uZW5hYmxlZCB8fCBcInN5bWJvbFwiIGluIG4pICYmICh1LmdyYXBoaWMgPSAxKSwgdiAmJiAhMSA9PT0gdi5lbmFibGVkICYmICh1LmRhdGFMYWJlbCA9IDEpKTtcbiAgICAgICAgICB0aGlzLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBhICYmIGEuc2VyaWVzICYmIChhLnJlc29sdmVDb2xvcigpLCBPYmplY3Qua2V5cyh1KS5sZW5ndGggJiYgYS5kZXN0cm95RWxlbWVudHModSksICExID09PSBtLnNob3dJbkxlZ2VuZCAmJiBhLmxlZ2VuZEl0ZW0gJiYgaC5sZWdlbmQuZGVzdHJveUl0ZW0oYSkpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYS56SW5kZXggIT09IGwuekluZGV4ICYmIHcuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGZbYl0gJiYgZltiXS5hdHRyKHtcbiAgICAgICAgICAgIHpJbmRleDogYS56SW5kZXhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGYuaW5pdGlhbFR5cGUgPSBnO1xuICAgICAgICBoLmxpbmtTZXJpZXMoKTtcbiAgICAgICAgRCh0aGlzLCBcImFmdGVyVXBkYXRlXCIpO1xuICAgICAgICBrKGMsICEwKSAmJiBoLnJlZHJhdyhiID8gdm9pZCAwIDogITEpO1xuICAgICAgfSxcbiAgICAgIHNldE5hbWU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMub3B0aW9ucy5uYW1lID0gdGhpcy51c2VyT3B0aW9ucy5uYW1lID0gYTtcbiAgICAgICAgdGhpcy5jaGFydC5pc0RpcnR5TGVnZW5kID0gITA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdChsLnByb3RvdHlwZSwge1xuICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoYSwgZikge1xuICAgICAgICB2YXIgZCA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBoID0gYSAmJiBhLmV2ZW50cyB8fCB7fTtcbiAgICAgICAgYSA9IGUodGhpcy51c2VyT3B0aW9ucywgYSk7XG4gICAgICAgIGQub3B0aW9uc1t0aGlzLmNvbGxdLmluZGV4T2YgJiYgKGQub3B0aW9uc1t0aGlzLmNvbGxdW2Qub3B0aW9uc1t0aGlzLmNvbGxdLmluZGV4T2YodGhpcy51c2VyT3B0aW9ucyldID0gYSk7XG4gICAgICAgIGMoZC5vcHRpb25zW3RoaXMuY29sbF0uZXZlbnRzLCBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICAgIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBoW2NdICYmIChoW2NdID0gdm9pZCAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVzdHJveSghMCk7XG4gICAgICAgIHRoaXMuaW5pdChkLCB0KGEsIHtcbiAgICAgICAgICBldmVudHM6IGhcbiAgICAgICAgfSkpO1xuICAgICAgICBkLmlzRGlydHlCb3ggPSAhMDtcbiAgICAgICAgayhmLCAhMCkgJiYgZC5yZWRyYXcoKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGZvciAodmFyIGMgPSB0aGlzLmNoYXJ0LCBlID0gdGhpcy5jb2xsLCBmID0gdGhpcy5zZXJpZXMsIGQgPSBmLmxlbmd0aDsgZC0tOykgZltkXSAmJiBmW2RdLnJlbW92ZSghMSk7XG5cbiAgICAgICAgSihjLmF4ZXMsIHRoaXMpO1xuICAgICAgICBKKGNbZV0sIHRoaXMpO1xuICAgICAgICBoKGMub3B0aW9uc1tlXSkgPyBjLm9wdGlvbnNbZV0uc3BsaWNlKHRoaXMub3B0aW9ucy5pbmRleCwgMSkgOiBkZWxldGUgYy5vcHRpb25zW2VdO1xuICAgICAgICBjW2VdLmZvckVhY2goZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgICBhLm9wdGlvbnMuaW5kZXggPSBhLnVzZXJPcHRpb25zLmluZGV4ID0gYztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICBjLmlzRGlydHlCb3ggPSAhMDtcbiAgICAgICAgayhhLCAhMCkgJiYgYy5yZWRyYXcoKTtcbiAgICAgIH0sXG4gICAgICBzZXRUaXRsZTogZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgIHRpdGxlOiBhXG4gICAgICAgIH0sIGMpO1xuICAgICAgfSxcbiAgICAgIHNldENhdGVnb3JpZXM6IGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICBjYXRlZ29yaWVzOiBhXG4gICAgICAgIH0sIGMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL0FyZWFTZXJpZXMuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvQ29sb3IuanNcIl0sIHJbXCJtaXhpbnMvbGVnZW5kLXN5bWJvbC5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnLCByLCB1KSB7XG4gICAgdmFyIEkgPSBnLnBhcnNlLFxuICAgICAgICBNID0gdS5vYmplY3RFYWNoLFxuICAgICAgICBFID0gdS5waWNrO1xuICAgIGcgPSB1LnNlcmllc1R5cGU7XG4gICAgdmFyIEEgPSBkLlNlcmllcztcbiAgICBnKFwiYXJlYVwiLCBcImxpbmVcIiwge1xuICAgICAgc29mdFRocmVzaG9sZDogITEsXG4gICAgICB0aHJlc2hvbGQ6IDBcbiAgICB9LCB7XG4gICAgICBzaW5nbGVTdGFja3M6ICExLFxuICAgICAgZ2V0U3RhY2tQb2ludHM6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBnID0gW10sXG4gICAgICAgICAgICByID0gW10sXG4gICAgICAgICAgICB0ID0gdGhpcy54QXhpcyxcbiAgICAgICAgICAgIHUgPSB0aGlzLnlBeGlzLFxuICAgICAgICAgICAgaCA9IHUuc3RhY2tzW3RoaXMuc3RhY2tLZXldLFxuICAgICAgICAgICAgQSA9IHt9LFxuICAgICAgICAgICAgcSA9IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICBHID0gdS5zZXJpZXMsXG4gICAgICAgICAgICBlID0gRy5sZW5ndGgsXG4gICAgICAgICAgICBjID0gRSh1Lm9wdGlvbnMucmV2ZXJzZWRTdGFja3MsICEwKSA/IDEgOiAtMSxcbiAgICAgICAgICAgIGs7XG4gICAgICAgIGQgPSBkIHx8IHRoaXMucG9pbnRzO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhY2tpbmcpIHtcbiAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgZC5sZW5ndGg7IGsrKykgZFtrXS5sZWZ0TnVsbCA9IGRba10ucmlnaHROdWxsID0gdm9pZCAwLCBBW2Rba10ueF0gPSBkW2tdO1xuXG4gICAgICAgICAgTShoLCBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICAgICAgbnVsbCAhPT0gYy50b3RhbCAmJiByLnB1c2goYSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgci5zb3J0KGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgICAgICByZXR1cm4gYyAtIGE7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIG4gPSBHLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIGMudmlzaWJsZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByLmZvckVhY2goZnVuY3Rpb24gKGYsIGEpIHtcbiAgICAgICAgICAgIHZhciBkID0gMCxcbiAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgIHo7XG4gICAgICAgICAgICBpZiAoQVtmXSAmJiAhQVtmXS5pc051bGwpIGcucHVzaChBW2ZdKSwgWy0xLCAxXS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgIHZhciBsID0gMSA9PT0gZCA/IFwicmlnaHROdWxsXCIgOiBcImxlZnROdWxsXCIsXG4gICAgICAgICAgICAgICAgICBnID0gMCxcbiAgICAgICAgICAgICAgICAgIHcgPSBoW3JbYSArIGRdXTtcbiAgICAgICAgICAgICAgaWYgKHcpIGZvciAoayA9IHE7IDAgPD0gayAmJiBrIDwgZTspIHYgPSB3LnBvaW50c1trXSwgdiB8fCAoayA9PT0gcSA/IEFbZl1bbF0gPSAhMCA6IG5ba10gJiYgKHogPSBoW2ZdLnBvaW50c1trXSkgJiYgKGcgLT0gelsxXSAtIHpbMF0pKSwgayArPSBjO1xuICAgICAgICAgICAgICBBW2ZdWzEgPT09IGQgPyBcInJpZ2h0Q2xpZmZcIiA6IFwibGVmdENsaWZmXCJdID0gZztcbiAgICAgICAgICAgIH0pO2Vsc2Uge1xuICAgICAgICAgICAgICBmb3IgKGsgPSBxOyAwIDw9IGsgJiYgayA8IGU7KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYgPSBoW2ZdLnBvaW50c1trXSkge1xuICAgICAgICAgICAgICAgICAgZCA9IHZbMV07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBrICs9IGM7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkID0gdS50cmFuc2xhdGUoZCwgMCwgMSwgMCwgMSk7XG4gICAgICAgICAgICAgIGcucHVzaCh7XG4gICAgICAgICAgICAgICAgaXNOdWxsOiAhMCxcbiAgICAgICAgICAgICAgICBwbG90WDogdC50cmFuc2xhdGUoZiwgMCwgMCwgMCwgMSksXG4gICAgICAgICAgICAgICAgeDogZixcbiAgICAgICAgICAgICAgICBwbG90WTogZCxcbiAgICAgICAgICAgICAgICB5Qm90dG9tOiBkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGc7XG4gICAgICB9LFxuICAgICAgZ2V0R3JhcGhQYXRoOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgZyA9IEEucHJvdG90eXBlLmdldEdyYXBoUGF0aCxcbiAgICAgICAgICAgIHIgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICB0ID0gci5zdGFja2luZyxcbiAgICAgICAgICAgIHUgPSB0aGlzLnlBeGlzLFxuICAgICAgICAgICAgaCxcbiAgICAgICAgICAgIE4gPSBbXSxcbiAgICAgICAgICAgIHEgPSBbXSxcbiAgICAgICAgICAgIEcgPSB0aGlzLmluZGV4LFxuICAgICAgICAgICAgZSA9IHUuc3RhY2tzW3RoaXMuc3RhY2tLZXldLFxuICAgICAgICAgICAgYyA9IHIudGhyZXNob2xkLFxuICAgICAgICAgICAgayA9IE1hdGgucm91bmQodS5nZXRUaHJlc2hvbGQoci50aHJlc2hvbGQpKTtcbiAgICAgICAgciA9IEUoci5jb25uZWN0TnVsbHMsIFwicGVyY2VudFwiID09PSB0KTtcblxuICAgICAgICB2YXIgbiA9IGZ1bmN0aW9uIChmLCBoLCBsKSB7XG4gICAgICAgICAgdmFyIGcgPSBkW2ZdO1xuICAgICAgICAgIGYgPSB0ICYmIGVbZy54XS5wb2ludHNbR107XG4gICAgICAgICAgdmFyIG4gPSBnW2wgKyBcIk51bGxcIl0gfHwgMDtcbiAgICAgICAgICBsID0gZ1tsICsgXCJDbGlmZlwiXSB8fCAwO1xuICAgICAgICAgIGcgPSAhMDtcblxuICAgICAgICAgIGlmIChsIHx8IG4pIHtcbiAgICAgICAgICAgIHZhciB2ID0gKG4gPyBmWzBdIDogZlsxXSkgKyBsO1xuICAgICAgICAgICAgdmFyIHcgPSBmWzBdICsgbDtcbiAgICAgICAgICAgIGcgPSAhIW47XG4gICAgICAgICAgfSBlbHNlICF0ICYmIGRbaF0gJiYgZFtoXS5pc051bGwgJiYgKHYgPSB3ID0gYyk7XG5cbiAgICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgdiAmJiAocS5wdXNoKHtcbiAgICAgICAgICAgIHBsb3RYOiBhLFxuICAgICAgICAgICAgcGxvdFk6IG51bGwgPT09IHYgPyBrIDogdS5nZXRUaHJlc2hvbGQodiksXG4gICAgICAgICAgICBpc051bGw6IGcsXG4gICAgICAgICAgICBpc0NsaWZmOiAhMFxuICAgICAgICAgIH0pLCBOLnB1c2goe1xuICAgICAgICAgICAgcGxvdFg6IGEsXG4gICAgICAgICAgICBwbG90WTogbnVsbCA9PT0gdyA/IGsgOiB1LmdldFRocmVzaG9sZCh3KSxcbiAgICAgICAgICAgIGRvQ3VydmU6ICExXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGQgPSBkIHx8IHRoaXMucG9pbnRzO1xuICAgICAgICB0ICYmIChkID0gdGhpcy5nZXRTdGFja1BvaW50cyhkKSk7XG5cbiAgICAgICAgZm9yIChoID0gMDsgaCA8IGQubGVuZ3RoOyBoKyspIHtcbiAgICAgICAgICB0IHx8IChkW2hdLmxlZnRDbGlmZiA9IGRbaF0ucmlnaHRDbGlmZiA9IGRbaF0ubGVmdE51bGwgPSBkW2hdLnJpZ2h0TnVsbCA9IHZvaWQgMCk7XG4gICAgICAgICAgdmFyIGYgPSBkW2hdLmlzTnVsbDtcbiAgICAgICAgICB2YXIgYSA9IEUoZFtoXS5yZWN0UGxvdFgsIGRbaF0ucGxvdFgpO1xuICAgICAgICAgIHZhciBsID0gRShkW2hdLnlCb3R0b20sIGspO1xuICAgICAgICAgIGlmICghZiB8fCByKSByIHx8IG4oaCwgaCAtIDEsIFwibGVmdFwiKSwgZiAmJiAhdCAmJiByIHx8IChxLnB1c2goZFtoXSksIE4ucHVzaCh7XG4gICAgICAgICAgICB4OiBoLFxuICAgICAgICAgICAgcGxvdFg6IGEsXG4gICAgICAgICAgICBwbG90WTogbFxuICAgICAgICAgIH0pKSwgciB8fCBuKGgsIGggKyAxLCBcInJpZ2h0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaCA9IGcuY2FsbCh0aGlzLCBxLCAhMCwgITApO1xuICAgICAgICBOLnJldmVyc2VkID0gITA7XG4gICAgICAgIGYgPSBnLmNhbGwodGhpcywgTiwgITAsICEwKTtcbiAgICAgICAgZi5sZW5ndGggJiYgKGZbMF0gPSBcIkxcIik7XG4gICAgICAgIGYgPSBoLmNvbmNhdChmKTtcbiAgICAgICAgZyA9IGcuY2FsbCh0aGlzLCBxLCAhMSwgcik7XG4gICAgICAgIGYueE1hcCA9IGgueE1hcDtcbiAgICAgICAgdGhpcy5hcmVhUGF0aCA9IGY7XG4gICAgICAgIHJldHVybiBnO1xuICAgICAgfSxcbiAgICAgIGRyYXdHcmFwaDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFyZWFQYXRoID0gW107XG4gICAgICAgIEEucHJvdG90eXBlLmRyYXdHcmFwaC5hcHBseSh0aGlzKTtcbiAgICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgICAgZyA9IHRoaXMuYXJlYVBhdGgsXG4gICAgICAgICAgICByID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgdCA9IFtbXCJhcmVhXCIsIFwiaGlnaGNoYXJ0cy1hcmVhXCIsIHRoaXMuY29sb3IsIHIuZmlsbENvbG9yXV07XG4gICAgICAgIHRoaXMuem9uZXMuZm9yRWFjaChmdW5jdGlvbiAoZywgaCkge1xuICAgICAgICAgIHQucHVzaChbXCJ6b25lLWFyZWEtXCIgKyBoLCBcImhpZ2hjaGFydHMtYXJlYSBoaWdoY2hhcnRzLXpvbmUtYXJlYS1cIiArIGggKyBcIiBcIiArIGcuY2xhc3NOYW1lLCBnLmNvbG9yIHx8IGQuY29sb3IsIGcuZmlsbENvbG9yIHx8IHIuZmlsbENvbG9yXSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0LmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgaCA9IHRbMF0sXG4gICAgICAgICAgICAgIHUgPSBkW2hdLFxuICAgICAgICAgICAgICBxID0gdSA/IFwiYW5pbWF0ZVwiIDogXCJhdHRyXCIsXG4gICAgICAgICAgICAgIHkgPSB7fTtcbiAgICAgICAgICB1ID8gKHUuZW5kWCA9IGQucHJldmVudEdyYXBoQW5pbWF0aW9uID8gbnVsbCA6IGcueE1hcCwgdS5hbmltYXRlKHtcbiAgICAgICAgICAgIGQ6IGdcbiAgICAgICAgICB9KSkgOiAoeS56SW5kZXggPSAwLCB1ID0gZFtoXSA9IGQuY2hhcnQucmVuZGVyZXIucGF0aChnKS5hZGRDbGFzcyh0WzFdKS5hZGQoZC5ncm91cCksIHUuaXNBcmVhID0gITApO1xuICAgICAgICAgIGQuY2hhcnQuc3R5bGVkTW9kZSB8fCAoeS5maWxsID0gRSh0WzNdLCBJKHRbMl0pLnNldE9wYWNpdHkoRShyLmZpbGxPcGFjaXR5LCAuNzUpKS5nZXQoKSkpO1xuICAgICAgICAgIHVbcV0oeSk7XG4gICAgICAgICAgdS5zdGFydFggPSBnLnhNYXA7XG4gICAgICAgICAgdS5zaGlmdFVuaXQgPSByLnN0ZXAgPyAyIDogMTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZHJhd0xlZ2VuZFN5bWJvbDogci5kcmF3UmVjdGFuZ2xlXG4gICAgfSk7XG4gICAgXCJcIjtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9TcGxpbmVTZXJpZXMuanNcIiwgW3JbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCkge1xuICAgIHZhciBnID0gZC5waWNrO1xuICAgIGQgPSBkLnNlcmllc1R5cGU7XG4gICAgZChcInNwbGluZVwiLCBcImxpbmVcIiwge30sIHtcbiAgICAgIGdldFBvaW50U3BsaW5lOiBmdW5jdGlvbiAoZCwgciwgSSkge1xuICAgICAgICB2YXIgdSA9IHIucGxvdFgsXG4gICAgICAgICAgICBFID0gci5wbG90WSxcbiAgICAgICAgICAgIEEgPSBkW0kgLSAxXTtcbiAgICAgICAgSSA9IGRbSSArIDFdO1xuXG4gICAgICAgIGlmIChBICYmICFBLmlzTnVsbCAmJiAhMSAhPT0gQS5kb0N1cnZlICYmICFyLmlzQ2xpZmYgJiYgSSAmJiAhSS5pc051bGwgJiYgITEgIT09IEkuZG9DdXJ2ZSAmJiAhci5pc0NsaWZmKSB7XG4gICAgICAgICAgZCA9IEEucGxvdFk7XG4gICAgICAgICAgdmFyIEcgPSBJLnBsb3RYO1xuICAgICAgICAgIEkgPSBJLnBsb3RZO1xuICAgICAgICAgIHZhciBKID0gMDtcbiAgICAgICAgICB2YXIgeSA9ICgxLjUgKiB1ICsgQS5wbG90WCkgLyAyLjU7XG4gICAgICAgICAgdmFyIHQgPSAoMS41ICogRSArIGQpIC8gMi41O1xuICAgICAgICAgIEcgPSAoMS41ICogdSArIEcpIC8gMi41O1xuICAgICAgICAgIHZhciBEID0gKDEuNSAqIEUgKyBJKSAvIDIuNTtcbiAgICAgICAgICBHICE9PSB5ICYmIChKID0gKEQgLSB0KSAqIChHIC0gdSkgLyAoRyAtIHkpICsgRSAtIEQpO1xuICAgICAgICAgIHQgKz0gSjtcbiAgICAgICAgICBEICs9IEo7XG4gICAgICAgICAgdCA+IGQgJiYgdCA+IEUgPyAodCA9IE1hdGgubWF4KGQsIEUpLCBEID0gMiAqIEUgLSB0KSA6IHQgPCBkICYmIHQgPCBFICYmICh0ID0gTWF0aC5taW4oZCwgRSksIEQgPSAyICogRSAtIHQpO1xuICAgICAgICAgIEQgPiBJICYmIEQgPiBFID8gKEQgPSBNYXRoLm1heChJLCBFKSwgdCA9IDIgKiBFIC0gRCkgOiBEIDwgSSAmJiBEIDwgRSAmJiAoRCA9IE1hdGgubWluKEksIEUpLCB0ID0gMiAqIEUgLSBEKTtcbiAgICAgICAgICByLnJpZ2h0Q29udFggPSBHO1xuICAgICAgICAgIHIucmlnaHRDb250WSA9IEQ7XG4gICAgICAgIH1cblxuICAgICAgICByID0gW1wiQ1wiLCBnKEEucmlnaHRDb250WCwgQS5wbG90WCksIGcoQS5yaWdodENvbnRZLCBBLnBsb3RZKSwgZyh5LCB1KSwgZyh0LCBFKSwgdSwgRV07XG4gICAgICAgIEEucmlnaHRDb250WCA9IEEucmlnaHRDb250WSA9IG51bGw7XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFwiXCI7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvQXJlYVNwbGluZVNlcmllcy5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJtaXhpbnMvbGVnZW5kLXN5bWJvbC5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnLCByKSB7XG4gICAgciA9IHIuc2VyaWVzVHlwZTtcbiAgICB2YXIgdSA9IGQuc2VyaWVzVHlwZXMuYXJlYS5wcm90b3R5cGU7XG4gICAgcihcImFyZWFzcGxpbmVcIiwgXCJzcGxpbmVcIiwgZC5kZWZhdWx0UGxvdE9wdGlvbnMuYXJlYSwge1xuICAgICAgZ2V0U3RhY2tQb2ludHM6IHUuZ2V0U3RhY2tQb2ludHMsXG4gICAgICBnZXRHcmFwaFBhdGg6IHUuZ2V0R3JhcGhQYXRoLFxuICAgICAgZHJhd0dyYXBoOiB1LmRyYXdHcmFwaCxcbiAgICAgIGRyYXdMZWdlbmRTeW1ib2w6IGcuZHJhd1JlY3RhbmdsZVxuICAgIH0pO1xuICAgIFwiXCI7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvQ29sdW1uU2VyaWVzLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL0NvbG9yLmpzXCJdLCByW1wibWl4aW5zL2xlZ2VuZC1zeW1ib2wuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZywgciwgdSkge1xuICAgIFwiXCI7XG5cbiAgICB2YXIgSSA9IGcucGFyc2UsXG4gICAgICAgIE0gPSB1LmFuaW1PYmplY3QsXG4gICAgICAgIEUgPSB1LmNsYW1wLFxuICAgICAgICBBID0gdS5kZWZpbmVkLFxuICAgICAgICBHID0gdS5leHRlbmQsXG4gICAgICAgIEogPSB1LmlzTnVtYmVyLFxuICAgICAgICB5ID0gdS5tZXJnZSxcbiAgICAgICAgdCA9IHUucGljaztcbiAgICBnID0gdS5zZXJpZXNUeXBlO1xuICAgIHZhciBEID0gZC5TZXJpZXM7XG4gICAgZyhcImNvbHVtblwiLCBcImxpbmVcIiwge1xuICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgY3Jpc3A6ICEwLFxuICAgICAgZ3JvdXBQYWRkaW5nOiAuMixcbiAgICAgIG1hcmtlcjogbnVsbCxcbiAgICAgIHBvaW50UGFkZGluZzogLjEsXG4gICAgICBtaW5Qb2ludExlbmd0aDogMCxcbiAgICAgIGNyb3BUaHJlc2hvbGQ6IDUwLFxuICAgICAgcG9pbnRSYW5nZTogbnVsbCxcbiAgICAgIHN0YXRlczoge1xuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgIGhhbG86ICExLFxuICAgICAgICAgIGJyaWdodG5lc3M6IC4xXG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgIGNvbG9yOiBcIiNjY2NjY2NcIixcbiAgICAgICAgICBib3JkZXJDb2xvcjogXCIjMDAwMDAwXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgYWxpZ246IG51bGwsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IG51bGwsXG4gICAgICAgIHk6IG51bGxcbiAgICAgIH0sXG4gICAgICBzb2Z0VGhyZXNob2xkOiAhMSxcbiAgICAgIHN0YXJ0RnJvbVRocmVzaG9sZDogITAsXG4gICAgICBzdGlja3lUcmFja2luZzogITEsXG4gICAgICB0b29sdGlwOiB7XG4gICAgICAgIGRpc3RhbmNlOiA2XG4gICAgICB9LFxuICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgYm9yZGVyQ29sb3I6IFwiI2ZmZmZmZlwiXG4gICAgfSwge1xuICAgICAgY3JvcFNob3VsZGVyOiAwLFxuICAgICAgZGlyZWN0VG91Y2g6ICEwLFxuICAgICAgdHJhY2tlckdyb3VwczogW1wiZ3JvdXBcIiwgXCJkYXRhTGFiZWxzR3JvdXBcIl0sXG4gICAgICBuZWdTdGFja3M6ICEwLFxuICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBELnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICAgIGcgPSBkLmNoYXJ0O1xuICAgICAgICBnLmhhc1JlbmRlcmVkICYmIGcuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICBoLnR5cGUgPT09IGQudHlwZSAmJiAoaC5pc0RpcnR5ID0gITApO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZXRDb2x1bW5NZXRyaWNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICAgIGcgPSBkLm9wdGlvbnMsXG4gICAgICAgICAgICBxID0gZC54QXhpcyxcbiAgICAgICAgICAgIHIgPSBkLnlBeGlzLFxuICAgICAgICAgICAgZSA9IHEub3B0aW9ucy5yZXZlcnNlZFN0YWNrcztcbiAgICAgICAgZSA9IHEucmV2ZXJzZWQgJiYgIWUgfHwgIXEucmV2ZXJzZWQgJiYgZTtcbiAgICAgICAgdmFyIGMsXG4gICAgICAgICAgICBrID0ge30sXG4gICAgICAgICAgICBuID0gMDtcbiAgICAgICAgITEgPT09IGcuZ3JvdXBpbmcgPyBuID0gMSA6IGQuY2hhcnQuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICB2YXIgZSA9IGEueUF4aXMsXG4gICAgICAgICAgICAgIGYgPSBhLm9wdGlvbnM7XG5cbiAgICAgICAgICBpZiAoYS50eXBlID09PSBkLnR5cGUgJiYgKGEudmlzaWJsZSB8fCAhZC5jaGFydC5vcHRpb25zLmNoYXJ0Lmlnbm9yZUhpZGRlblNlcmllcykgJiYgci5sZW4gPT09IGUubGVuICYmIHIucG9zID09PSBlLnBvcykge1xuICAgICAgICAgICAgaWYgKGYuc3RhY2tpbmcpIHtcbiAgICAgICAgICAgICAgYyA9IGEuc3RhY2tLZXk7XG4gICAgICAgICAgICAgIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBrW2NdICYmIChrW2NdID0gbisrKTtcbiAgICAgICAgICAgICAgdmFyIGggPSBrW2NdO1xuICAgICAgICAgICAgfSBlbHNlICExICE9PSBmLmdyb3VwaW5nICYmIChoID0gbisrKTtcblxuICAgICAgICAgICAgYS5jb2x1bW5JbmRleCA9IGg7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGYgPSBNYXRoLm1pbihNYXRoLmFicyhxLnRyYW5zQSkgKiAocS5vcmRpbmFsU2xvcGUgfHwgZy5wb2ludFJhbmdlIHx8IHEuY2xvc2VzdFBvaW50UmFuZ2UgfHwgcS50aWNrSW50ZXJ2YWwgfHwgMSksIHEubGVuKSxcbiAgICAgICAgICAgIGEgPSBmICogZy5ncm91cFBhZGRpbmcsXG4gICAgICAgICAgICBsID0gKGYgLSAyICogYSkgLyAobiB8fCAxKTtcbiAgICAgICAgZyA9IE1hdGgubWluKGcubWF4UG9pbnRXaWR0aCB8fCBxLmxlbiwgdChnLnBvaW50V2lkdGgsIGwgKiAoMSAtIDIgKiBnLnBvaW50UGFkZGluZykpKTtcbiAgICAgICAgZC5jb2x1bW5NZXRyaWNzID0ge1xuICAgICAgICAgIHdpZHRoOiBnLFxuICAgICAgICAgIG9mZnNldDogKGwgLSBnKSAvIDIgKyAoYSArICgoZC5jb2x1bW5JbmRleCB8fCAwKSArIChlID8gMSA6IDApKSAqIGwgLSBmIC8gMikgKiAoZSA/IC0xIDogMSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGQuY29sdW1uTWV0cmljcztcbiAgICAgIH0sXG4gICAgICBjcmlzcENvbDogZnVuY3Rpb24gKGQsIGcsIHEsIHQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgYyA9IHRoaXMuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICBrID0gLShjICUgMiA/IC41IDogMCk7XG4gICAgICAgIGMgPSBjICUgMiA/IC41IDogMTtcbiAgICAgICAgZS5pbnZlcnRlZCAmJiBlLnJlbmRlcmVyLmlzVk1MICYmIChjICs9IDEpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuY3Jpc3AgJiYgKHEgPSBNYXRoLnJvdW5kKGQgKyBxKSArIGssIGQgPSBNYXRoLnJvdW5kKGQpICsgaywgcSAtPSBkKTtcbiAgICAgICAgdCA9IE1hdGgucm91bmQoZyArIHQpICsgYztcbiAgICAgICAgayA9IC41ID49IE1hdGguYWJzKGcpICYmIC41IDwgdDtcbiAgICAgICAgZyA9IE1hdGgucm91bmQoZykgKyBjO1xuICAgICAgICB0IC09IGc7XG4gICAgICAgIGsgJiYgdCAmJiAoLS1nLCB0ICs9IDEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGQsXG4gICAgICAgICAgeTogZyxcbiAgICAgICAgICB3aWR0aDogcSxcbiAgICAgICAgICBoZWlnaHQ6IHRcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgICAgZyA9IGQuY2hhcnQsXG4gICAgICAgICAgICBxID0gZC5vcHRpb25zLFxuICAgICAgICAgICAgciA9IGQuZGVuc2UgPSAyID4gZC5jbG9zZXN0UG9pbnRSYW5nZSAqIGQueEF4aXMudHJhbnNBO1xuICAgICAgICByID0gZC5ib3JkZXJXaWR0aCA9IHQocS5ib3JkZXJXaWR0aCwgciA/IDAgOiAxKTtcbiAgICAgICAgdmFyIGUgPSBkLnhBeGlzLFxuICAgICAgICAgICAgYyA9IGQueUF4aXMsXG4gICAgICAgICAgICBrID0gcS50aHJlc2hvbGQsXG4gICAgICAgICAgICBuID0gZC50cmFuc2xhdGVkVGhyZXNob2xkID0gYy5nZXRUaHJlc2hvbGQoayksXG4gICAgICAgICAgICBmID0gdChxLm1pblBvaW50TGVuZ3RoLCA1KSxcbiAgICAgICAgICAgIGEgPSBkLmdldENvbHVtbk1ldHJpY3MoKSxcbiAgICAgICAgICAgIGwgPSBhLndpZHRoLFxuICAgICAgICAgICAgdiA9IGQuYmFyVyA9IE1hdGgubWF4KGwsIDEgKyAyICogciksXG4gICAgICAgICAgICB6ID0gZC5wb2ludFhPZmZzZXQgPSBhLm9mZnNldCxcbiAgICAgICAgICAgIHcgPSBkLmRhdGFNaW4sXG4gICAgICAgICAgICB1ID0gZC5kYXRhTWF4O1xuICAgICAgICBnLmludmVydGVkICYmIChuIC09IC41KTtcbiAgICAgICAgcS5wb2ludFBhZGRpbmcgJiYgKHYgPSBNYXRoLmNlaWwodikpO1xuICAgICAgICBELnByb3RvdHlwZS50cmFuc2xhdGUuYXBwbHkoZCk7XG4gICAgICAgIGQucG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICB2YXIgaCA9IHQoYS55Qm90dG9tLCBuKSxcbiAgICAgICAgICAgICAgcSA9IDk5OSArIE1hdGguYWJzKGgpLFxuICAgICAgICAgICAgICByID0gbCxcbiAgICAgICAgICAgICAgcCA9IGEucGxvdFg7XG4gICAgICAgICAgcSA9IEUoYS5wbG90WSwgLXEsIGMubGVuICsgcSk7XG4gICAgICAgICAgdmFyIGIgPSBhLnBsb3RYICsgeixcbiAgICAgICAgICAgICAgQiA9IHYsXG4gICAgICAgICAgICAgIHggPSBNYXRoLm1pbihxLCBoKSxcbiAgICAgICAgICAgICAgeSA9IE1hdGgubWF4KHEsIGgpIC0geDtcblxuICAgICAgICAgIGlmIChmICYmIE1hdGguYWJzKHkpIDwgZikge1xuICAgICAgICAgICAgeSA9IGY7XG4gICAgICAgICAgICB2YXIgTCA9ICFjLnJldmVyc2VkICYmICFhLm5lZ2F0aXZlIHx8IGMucmV2ZXJzZWQgJiYgYS5uZWdhdGl2ZTtcbiAgICAgICAgICAgIGEueSA9PT0gayAmJiBkLmRhdGFNYXggPD0gayAmJiBjLm1pbiA8IGsgJiYgdyAhPT0gdSAmJiAoTCA9ICFMKTtcbiAgICAgICAgICAgIHggPSBNYXRoLmFicyh4IC0gbikgPiBmID8gaCAtIGYgOiBuIC0gKEwgPyBmIDogMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQShhLm9wdGlvbnMucG9pbnRXaWR0aCkgJiYgKHIgPSBCID0gTWF0aC5jZWlsKGEub3B0aW9ucy5wb2ludFdpZHRoKSwgYiAtPSBNYXRoLnJvdW5kKChyIC0gbCkgLyAyKSk7XG4gICAgICAgICAgYS5iYXJYID0gYjtcbiAgICAgICAgICBhLnBvaW50V2lkdGggPSByO1xuICAgICAgICAgIGEudG9vbHRpcFBvcyA9IGcuaW52ZXJ0ZWQgPyBbYy5sZW4gKyBjLnBvcyAtIGcucGxvdExlZnQgLSBxLCBlLmxlbiArIGUucG9zIC0gZy5wbG90VG9wIC0gKHAgfHwgMCkgLSB6IC0gQiAvIDIsIHldIDogW2IgKyBCIC8gMiwgcSArIGMucG9zIC0gZy5wbG90VG9wLCB5XTtcbiAgICAgICAgICBhLnNoYXBlVHlwZSA9IGQucG9pbnRDbGFzcy5wcm90b3R5cGUuc2hhcGVUeXBlIHx8IFwicmVjdFwiO1xuICAgICAgICAgIGEuc2hhcGVBcmdzID0gZC5jcmlzcENvbC5hcHBseShkLCBhLmlzTnVsbCA/IFtiLCBuLCBCLCAwXSA6IFtiLCB4LCBCLCB5XSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdldFN5bWJvbDogZC5ub29wLFxuICAgICAgZHJhd0xlZ2VuZFN5bWJvbDogci5kcmF3UmVjdGFuZ2xlLFxuICAgICAgZHJhd0dyYXBoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBbdGhpcy5kZW5zZSA/IFwiYWRkQ2xhc3NcIiA6IFwicmVtb3ZlQ2xhc3NcIl0oXCJoaWdoY2hhcnRzLWRlbnNlLWRhdGFcIik7XG4gICAgICB9LFxuICAgICAgcG9pbnRBdHRyaWJzOiBmdW5jdGlvbiAoZCwgZykge1xuICAgICAgICB2YXIgaCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIHIgPSB0aGlzLnBvaW50QXR0clRvT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIGUgPSByLnN0cm9rZSB8fCBcImJvcmRlckNvbG9yXCI7XG4gICAgICAgIHZhciBjID0gcltcInN0cm9rZS13aWR0aFwiXSB8fCBcImJvcmRlcldpZHRoXCIsXG4gICAgICAgICAgICBrID0gZCAmJiBkLmNvbG9yIHx8IHRoaXMuY29sb3IsXG4gICAgICAgICAgICBuID0gZCAmJiBkW2VdIHx8IGhbZV0gfHwgdGhpcy5jb2xvciB8fCBrLFxuICAgICAgICAgICAgZiA9IGQgJiYgZFtjXSB8fCBoW2NdIHx8IHRoaXNbY10gfHwgMDtcbiAgICAgICAgciA9IGQgJiYgZC5vcHRpb25zLmRhc2hTdHlsZSB8fCBoLmRhc2hTdHlsZTtcbiAgICAgICAgdmFyIGEgPSB0KGQgJiYgZC5vcGFjaXR5LCBoLm9wYWNpdHksIDEpO1xuXG4gICAgICAgIGlmIChkICYmIHRoaXMuem9uZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGwgPSBkLmdldFpvbmUoKTtcbiAgICAgICAgICBrID0gZC5vcHRpb25zLmNvbG9yIHx8IGwgJiYgKGwuY29sb3IgfHwgZC5ub25ab25lZENvbG9yKSB8fCB0aGlzLmNvbG9yO1xuICAgICAgICAgIGwgJiYgKG4gPSBsLmJvcmRlckNvbG9yIHx8IG4sIHIgPSBsLmRhc2hTdHlsZSB8fCByLCBmID0gbC5ib3JkZXJXaWR0aCB8fCBmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGcgJiYgZCAmJiAoZCA9IHkoaC5zdGF0ZXNbZ10sIGQub3B0aW9ucy5zdGF0ZXMgJiYgZC5vcHRpb25zLnN0YXRlc1tnXSB8fCB7fSksIGcgPSBkLmJyaWdodG5lc3MsIGsgPSBkLmNvbG9yIHx8IFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBnICYmIEkoaykuYnJpZ2h0ZW4oZC5icmlnaHRuZXNzKS5nZXQoKSB8fCBrLCBuID0gZFtlXSB8fCBuLCBmID0gZFtjXSB8fCBmLCByID0gZC5kYXNoU3R5bGUgfHwgciwgYSA9IHQoZC5vcGFjaXR5LCBhKSk7XG4gICAgICAgIGUgPSB7XG4gICAgICAgICAgZmlsbDogayxcbiAgICAgICAgICBzdHJva2U6IG4sXG4gICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogZixcbiAgICAgICAgICBvcGFjaXR5OiBhXG4gICAgICAgIH07XG4gICAgICAgIHIgJiYgKGUuZGFzaHN0eWxlID0gcik7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfSxcbiAgICAgIGRyYXdQb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgICAgZyA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBxID0gZC5vcHRpb25zLFxuICAgICAgICAgICAgdCA9IGcucmVuZGVyZXIsXG4gICAgICAgICAgICBlID0gcS5hbmltYXRpb25MaW1pdCB8fCAyNTAsXG4gICAgICAgICAgICBjO1xuICAgICAgICBkLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgdmFyIGggPSBrLmdyYXBoaWMsXG4gICAgICAgICAgICAgIGYgPSAhIWgsXG4gICAgICAgICAgICAgIGEgPSBoICYmIGcucG9pbnRDb3VudCA8IGUgPyBcImFuaW1hdGVcIiA6IFwiYXR0clwiO1xuXG4gICAgICAgICAgaWYgKEooay5wbG90WSkgJiYgbnVsbCAhPT0gay55KSB7XG4gICAgICAgICAgICBjID0gay5zaGFwZUFyZ3M7XG4gICAgICAgICAgICBoICYmIGsuaGFzTmV3U2hhcGVUeXBlKCkgJiYgKGggPSBoLmRlc3Ryb3koKSk7XG4gICAgICAgICAgICBkLmVuYWJsZWREYXRhU29ydGluZyAmJiAoay5zdGFydFhQb3MgPSBkLnhBeGlzLnJldmVyc2VkID8gLShjID8gYy53aWR0aCA6IDApIDogZC54QXhpcy53aWR0aCk7XG4gICAgICAgICAgICBoIHx8IChrLmdyYXBoaWMgPSBoID0gdFtrLnNoYXBlVHlwZV0oYykuYWRkKGsuZ3JvdXAgfHwgZC5ncm91cCkpICYmIGQuZW5hYmxlZERhdGFTb3J0aW5nICYmIGcuaGFzUmVuZGVyZWQgJiYgZy5wb2ludENvdW50IDwgZSAmJiAoaC5hdHRyKHtcbiAgICAgICAgICAgICAgeDogay5zdGFydFhQb3NcbiAgICAgICAgICAgIH0pLCBmID0gITAsIGEgPSBcImFuaW1hdGVcIik7XG4gICAgICAgICAgICBpZiAoaCAmJiBmKSBoW2FdKHkoYykpO1xuICAgICAgICAgICAgaWYgKHEuYm9yZGVyUmFkaXVzKSBoW2FdKHtcbiAgICAgICAgICAgICAgcjogcS5ib3JkZXJSYWRpdXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZy5zdHlsZWRNb2RlIHx8IGhbYV0oZC5wb2ludEF0dHJpYnMoaywgay5zZWxlY3RlZCAmJiBcInNlbGVjdFwiKSkuc2hhZG93KCExICE9PSBrLmFsbG93U2hhZG93ICYmIHEuc2hhZG93LCBudWxsLCBxLnN0YWNraW5nICYmICFxLmJvcmRlclJhZGl1cyk7XG4gICAgICAgICAgICBoLmFkZENsYXNzKGsuZ2V0Q2xhc3NOYW1lKCksICEwKTtcbiAgICAgICAgICB9IGVsc2UgaCAmJiAoay5ncmFwaGljID0gaC5kZXN0cm95KCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBhbmltYXRlOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgaCA9IHRoaXMsXG4gICAgICAgICAgICBnID0gdGhpcy55QXhpcyxcbiAgICAgICAgICAgIHQgPSBoLm9wdGlvbnMsXG4gICAgICAgICAgICBlID0gdGhpcy5jaGFydC5pbnZlcnRlZCxcbiAgICAgICAgICAgIGMgPSB7fSxcbiAgICAgICAgICAgIGsgPSBlID8gXCJ0cmFuc2xhdGVYXCIgOiBcInRyYW5zbGF0ZVlcIjtcbiAgICAgICAgaWYgKGQpIGMuc2NhbGVZID0gLjAwMSwgZCA9IEUoZy50b1BpeGVscyh0LnRocmVzaG9sZCksIGcucG9zLCBnLnBvcyArIGcubGVuKSwgZSA/IGMudHJhbnNsYXRlWCA9IGQgLSBnLmxlbiA6IGMudHJhbnNsYXRlWSA9IGQsIGguY2xpcEJveCAmJiBoLnNldENsaXAoKSwgaC5ncm91cC5hdHRyKGMpO2Vsc2Uge1xuICAgICAgICAgIHZhciBuID0gaC5ncm91cC5hdHRyKGspO1xuICAgICAgICAgIGguZ3JvdXAuYW5pbWF0ZSh7XG4gICAgICAgICAgICBzY2FsZVk6IDFcbiAgICAgICAgICB9LCBHKE0oaC5vcHRpb25zLmFuaW1hdGlvbiksIHtcbiAgICAgICAgICAgIHN0ZXA6IGZ1bmN0aW9uIChlLCBhKSB7XG4gICAgICAgICAgICAgIGguZ3JvdXAgJiYgKGNba10gPSBuICsgYS5wb3MgKiAoZy5wb3MgLSBuKSwgaC5ncm91cC5hdHRyKGMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgICAgZyA9IGQuY2hhcnQ7XG4gICAgICAgIGcuaGFzUmVuZGVyZWQgJiYgZy5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoaCkge1xuICAgICAgICAgIGgudHlwZSA9PT0gZC50eXBlICYmIChoLmlzRGlydHkgPSAhMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBELnByb3RvdHlwZS5yZW1vdmUuYXBwbHkoZCwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcIlwiO1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL0JhclNlcmllcy5qc1wiLCBbcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkKSB7XG4gICAgZCA9IGQuc2VyaWVzVHlwZTtcbiAgICBkKFwiYmFyXCIsIFwiY29sdW1uXCIsIG51bGwsIHtcbiAgICAgIGludmVydGVkOiAhMFxuICAgIH0pO1xuICAgIFwiXCI7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvU2NhdHRlclNlcmllcy5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZykge1xuICAgIHZhciByID0gZy5hZGRFdmVudDtcbiAgICBnID0gZy5zZXJpZXNUeXBlO1xuICAgIHZhciB1ID0gZC5TZXJpZXM7XG4gICAgZyhcInNjYXR0ZXJcIiwgXCJsaW5lXCIsIHtcbiAgICAgIGxpbmVXaWR0aDogMCxcbiAgICAgIGZpbmROZWFyZXN0UG9pbnRCeTogXCJ4eVwiLFxuICAgICAgaml0dGVyOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICBtYXJrZXI6IHtcbiAgICAgICAgZW5hYmxlZDogITBcbiAgICAgIH0sXG4gICAgICB0b29sdGlwOiB7XG4gICAgICAgIGhlYWRlckZvcm1hdDogJzxzcGFuIHN0eWxlPVwiY29sb3I6e3BvaW50LmNvbG9yfVwiPlxcdTI1Y2Y8L3NwYW4+IDxzcGFuIHN0eWxlPVwiZm9udC1zaXplOiAxMHB4XCI+IHtzZXJpZXMubmFtZX08L3NwYW4+PGJyLz4nLFxuICAgICAgICBwb2ludEZvcm1hdDogXCJ4OiA8Yj57cG9pbnQueH08L2I+PGJyLz55OiA8Yj57cG9pbnQueX08L2I+PGJyLz5cIlxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNvcnRlZDogITEsXG4gICAgICByZXF1aXJlU29ydGluZzogITEsXG4gICAgICBub1NoYXJlZFRvb2x0aXA6ICEwLFxuICAgICAgdHJhY2tlckdyb3VwczogW1wiZ3JvdXBcIiwgXCJtYXJrZXJHcm91cFwiLCBcImRhdGFMYWJlbHNHcm91cFwiXSxcbiAgICAgIHRha2VPcmRpbmFsUG9zaXRpb246ICExLFxuICAgICAgZHJhd0dyYXBoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5saW5lV2lkdGggJiYgdS5wcm90b3R5cGUuZHJhd0dyYXBoLmNhbGwodGhpcyk7XG4gICAgICB9LFxuICAgICAgYXBwbHlKaXR0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgICAgZyA9IHRoaXMub3B0aW9ucy5qaXR0ZXIsXG4gICAgICAgICAgICByID0gdGhpcy5wb2ludHMubGVuZ3RoO1xuICAgICAgICBnICYmIHRoaXMucG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHUsIEUpIHtcbiAgICAgICAgICBbXCJ4XCIsIFwieVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChBLCB5KSB7XG4gICAgICAgICAgICB2YXIgdCA9IFwicGxvdFwiICsgQS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAoZ1tBXSAmJiAhdS5pc051bGwpIHtcbiAgICAgICAgICAgICAgdmFyIEQgPSBkW0EgKyBcIkF4aXNcIl07XG4gICAgICAgICAgICAgIHZhciBoID0gZ1tBXSAqIEQudHJhbnNBO1xuXG4gICAgICAgICAgICAgIGlmIChEICYmICFELmlzTG9nKSB7XG4gICAgICAgICAgICAgICAgdmFyIEcgPSBNYXRoLm1heCgwLCB1W3RdIC0gaCk7XG4gICAgICAgICAgICAgICAgRCA9IE1hdGgubWluKEQubGVuLCB1W3RdICsgaCk7XG4gICAgICAgICAgICAgICAgeSA9IDFFNCAqIE1hdGguc2luKEUgKyB5ICogcik7XG4gICAgICAgICAgICAgICAgdVt0XSA9IEcgKyAoRCAtIEcpICogKHkgLSBNYXRoLmZsb29yKHkpKTtcbiAgICAgICAgICAgICAgICBcInhcIiA9PT0gQSAmJiAodS5jbGllbnRYID0gdS5wbG90WCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcih1LCBcImFmdGVyVHJhbnNsYXRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuYXBwbHlKaXR0ZXIgJiYgdGhpcy5hcHBseUppdHRlcigpO1xuICAgIH0pO1xuICAgIFwiXCI7XG4gIH0pO1xuICBTKHIsIFwibWl4aW5zL2NlbnRlcmVkLXNlcmllcy5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZykge1xuICAgIHZhciByID0gZy5pc051bWJlcixcbiAgICAgICAgdSA9IGcucGljayxcbiAgICAgICAgSSA9IGcucmVsYXRpdmVMZW5ndGgsXG4gICAgICAgIE0gPSBkLmRlZzJyYWQ7XG4gICAgZC5DZW50ZXJlZFNlcmllc01peGluID0ge1xuICAgICAgZ2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgZyA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICByID0gMiAqIChkLnNsaWNlZE9mZnNldCB8fCAwKSxcbiAgICAgICAgICAgIEogPSBnLnBsb3RXaWR0aCAtIDIgKiByLFxuICAgICAgICAgICAgeSA9IGcucGxvdEhlaWdodCAtIDIgKiByLFxuICAgICAgICAgICAgdCA9IGQuY2VudGVyLFxuICAgICAgICAgICAgRCA9IE1hdGgubWluKEosIHkpLFxuICAgICAgICAgICAgaCA9IGQuc2l6ZSxcbiAgICAgICAgICAgIE4gPSBkLmlubmVyU2l6ZSB8fCAwO1xuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaCAmJiAoaCA9IHBhcnNlRmxvYXQoaCkpO1xuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgTiAmJiAoTiA9IHBhcnNlRmxvYXQoTikpO1xuICAgICAgICBkID0gW3UodFswXSwgXCI1MCVcIiksIHUodFsxXSwgXCI1MCVcIiksIHUoaCAmJiAwID4gaCA/IHZvaWQgMCA6IGQuc2l6ZSwgXCIxMDAlXCIpLCB1KE4gJiYgMCA+IE4gPyB2b2lkIDAgOiBkLmlubmVyU2l6ZSB8fCAwLCBcIjAlXCIpXTtcbiAgICAgICAgZy5hbmd1bGFyICYmIChkWzNdID0gMCk7XG5cbiAgICAgICAgZm9yICh0ID0gMDsgNCA+IHQ7ICsrdCkgaCA9IGRbdF0sIGcgPSAyID4gdCB8fCAyID09PSB0ICYmIC8lJC8udGVzdChoKSwgZFt0XSA9IEkoaCwgW0osIHksIEQsIGRbMl1dW3RdKSArIChnID8gciA6IDApO1xuXG4gICAgICAgIGRbM10gPiBkWzJdICYmIChkWzNdID0gZFsyXSk7XG4gICAgICAgIHJldHVybiBkO1xuICAgICAgfSxcbiAgICAgIGdldFN0YXJ0QW5kRW5kUmFkaWFuczogZnVuY3Rpb24gKGQsIGcpIHtcbiAgICAgICAgZCA9IHIoZCkgPyBkIDogMDtcbiAgICAgICAgZyA9IHIoZykgJiYgZyA+IGQgJiYgMzYwID4gZyAtIGQgPyBnIDogZCArIDM2MDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGFydDogTSAqIChkICsgLTkwKSxcbiAgICAgICAgICBlbmQ6IE0gKiAoZyArIC05MClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgUyhyLCBcInBhcnRzL1BpZVNlcmllcy5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJtaXhpbnMvbGVnZW5kLXN5bWJvbC5qc1wiXSwgcltcInBhcnRzL1BvaW50LmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcsIHIsIHUpIHtcbiAgICB2YXIgSSA9IHUuYWRkRXZlbnQsXG4gICAgICAgIE0gPSB1LmNsYW1wLFxuICAgICAgICBFID0gdS5kZWZpbmVkLFxuICAgICAgICBBID0gdS5maXJlRXZlbnQsXG4gICAgICAgIEcgPSB1LmlzTnVtYmVyLFxuICAgICAgICBKID0gdS5tZXJnZSxcbiAgICAgICAgeSA9IHUucGljayxcbiAgICAgICAgdCA9IHUucmVsYXRpdmVMZW5ndGgsXG4gICAgICAgIEQgPSB1LnNlcmllc1R5cGUsXG4gICAgICAgIGggPSB1LnNldEFuaW1hdGlvbjtcbiAgICB1ID0gZC5DZW50ZXJlZFNlcmllc01peGluO1xuICAgIHZhciBOID0gdS5nZXRTdGFydEFuZEVuZFJhZGlhbnMsXG4gICAgICAgIHEgPSBkLm5vb3AsXG4gICAgICAgIFAgPSBkLlNlcmllcztcbiAgICBEKFwicGllXCIsIFwibGluZVwiLCB7XG4gICAgICBjZW50ZXI6IFtudWxsLCBudWxsXSxcbiAgICAgIGNsaXA6ICExLFxuICAgICAgY29sb3JCeVBvaW50OiAhMCxcbiAgICAgIGRhdGFMYWJlbHM6IHtcbiAgICAgICAgYWxsb3dPdmVybGFwOiAhMCxcbiAgICAgICAgY29ubmVjdG9yUGFkZGluZzogNSxcbiAgICAgICAgY29ubmVjdG9yU2hhcGU6IFwiZml4ZWRPZmZzZXRcIixcbiAgICAgICAgY3Jvb2tEaXN0YW5jZTogXCI3MCVcIixcbiAgICAgICAgZGlzdGFuY2U6IDMwLFxuICAgICAgICBlbmFibGVkOiAhMCxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucG9pbnQuaXNOdWxsID8gdm9pZCAwIDogdGhpcy5wb2ludC5uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzb2Z0Q29ubmVjdG9yOiAhMCxcbiAgICAgICAgeDogMFxuICAgICAgfSxcbiAgICAgIGZpbGxDb2xvcjogdm9pZCAwLFxuICAgICAgaWdub3JlSGlkZGVuUG9pbnQ6ICEwLFxuICAgICAgaW5hY3RpdmVPdGhlclBvaW50czogITAsXG4gICAgICBsZWdlbmRUeXBlOiBcInBvaW50XCIsXG4gICAgICBtYXJrZXI6IG51bGwsXG4gICAgICBzaXplOiBudWxsLFxuICAgICAgc2hvd0luTGVnZW5kOiAhMSxcbiAgICAgIHNsaWNlZE9mZnNldDogMTAsXG4gICAgICBzdGlja3lUcmFja2luZzogITEsXG4gICAgICB0b29sdGlwOiB7XG4gICAgICAgIGZvbGxvd1BvaW50ZXI6ICEwXG4gICAgICB9LFxuICAgICAgYm9yZGVyQ29sb3I6IFwiI2ZmZmZmZlwiLFxuICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICBsaW5lV2lkdGg6IHZvaWQgMCxcbiAgICAgIHN0YXRlczoge1xuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgIGJyaWdodG5lc3M6IC4xXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBpc0NhcnRlc2lhbjogITEsXG4gICAgICByZXF1aXJlU29ydGluZzogITEsXG4gICAgICBkaXJlY3RUb3VjaDogITAsXG4gICAgICBub1NoYXJlZFRvb2x0aXA6ICEwLFxuICAgICAgdHJhY2tlckdyb3VwczogW1wiZ3JvdXBcIiwgXCJkYXRhTGFiZWxzR3JvdXBcIl0sXG4gICAgICBheGlzVHlwZXM6IFtdLFxuICAgICAgcG9pbnRBdHRyaWJzOiBkLnNlcmllc1R5cGVzLmNvbHVtbi5wcm90b3R5cGUucG9pbnRBdHRyaWJzLFxuICAgICAgYW5pbWF0ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLFxuICAgICAgICAgICAgZCA9IGMucG9pbnRzLFxuICAgICAgICAgICAgZyA9IGMuc3RhcnRBbmdsZVJhZDtcbiAgICAgICAgZSB8fCBkLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgYSA9IGUuZ3JhcGhpYyxcbiAgICAgICAgICAgICAgZiA9IGUuc2hhcGVBcmdzO1xuICAgICAgICAgIGEgJiYgZiAmJiAoYS5hdHRyKHtcbiAgICAgICAgICAgIHI6IHkoZS5zdGFydFIsIGMuY2VudGVyICYmIGMuY2VudGVyWzNdIC8gMiksXG4gICAgICAgICAgICBzdGFydDogZyxcbiAgICAgICAgICAgIGVuZDogZ1xuICAgICAgICAgIH0pLCBhLmFuaW1hdGUoe1xuICAgICAgICAgICAgcjogZi5yLFxuICAgICAgICAgICAgc3RhcnQ6IGYuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGYuZW5kXG4gICAgICAgICAgfSwgYy5vcHRpb25zLmFuaW1hdGlvbikpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBoYXNEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucHJvY2Vzc2VkWERhdGEubGVuZ3RoO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZVRvdGFsczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSxcbiAgICAgICAgICAgIGMgPSAwLFxuICAgICAgICAgICAgZCA9IHRoaXMucG9pbnRzLFxuICAgICAgICAgICAgZyA9IGQubGVuZ3RoLFxuICAgICAgICAgICAgZiA9IHRoaXMub3B0aW9ucy5pZ25vcmVIaWRkZW5Qb2ludDtcblxuICAgICAgICBmb3IgKGUgPSAwOyBlIDwgZzsgZSsrKSB7XG4gICAgICAgICAgdmFyIGEgPSBkW2VdO1xuICAgICAgICAgIGMgKz0gZiAmJiAhYS52aXNpYmxlID8gMCA6IGEuaXNOdWxsID8gMCA6IGEueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG90YWwgPSBjO1xuXG4gICAgICAgIGZvciAoZSA9IDA7IGUgPCBnOyBlKyspIGEgPSBkW2VdLCBhLnBlcmNlbnRhZ2UgPSAwIDwgYyAmJiAoYS52aXNpYmxlIHx8ICFmKSA/IGEueSAvIGMgKiAxMDAgOiAwLCBhLnRvdGFsID0gYztcbiAgICAgIH0sXG4gICAgICBnZW5lcmF0ZVBvaW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICBQLnByb3RvdHlwZS5nZW5lcmF0ZVBvaW50cy5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVRvdGFscygpO1xuICAgICAgfSxcbiAgICAgIGdldFg6IGZ1bmN0aW9uIChlLCBjLCBkKSB7XG4gICAgICAgIHZhciBrID0gdGhpcy5jZW50ZXIsXG4gICAgICAgICAgICBmID0gdGhpcy5yYWRpaSA/IHRoaXMucmFkaWlbZC5pbmRleF0gOiBrWzJdIC8gMjtcbiAgICAgICAgZSA9IE1hdGguYXNpbihNKChlIC0ga1sxXSkgLyAoZiArIGQubGFiZWxEaXN0YW5jZSksIC0xLCAxKSk7XG4gICAgICAgIHJldHVybiBrWzBdICsgKGMgPyAtMSA6IDEpICogTWF0aC5jb3MoZSkgKiAoZiArIGQubGFiZWxEaXN0YW5jZSkgKyAoMCA8IGQubGFiZWxEaXN0YW5jZSA/IChjID8gLTEgOiAxKSAqIHRoaXMub3B0aW9ucy5kYXRhTGFiZWxzLnBhZGRpbmcgOiAwKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVQb2ludHMoKTtcbiAgICAgICAgdmFyIGMgPSAwLFxuICAgICAgICAgICAgZCA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGcgPSBkLnNsaWNlZE9mZnNldCxcbiAgICAgICAgICAgIGYgPSBnICsgKGQuYm9yZGVyV2lkdGggfHwgMCksXG4gICAgICAgICAgICBhID0gTihkLnN0YXJ0QW5nbGUsIGQuZW5kQW5nbGUpLFxuICAgICAgICAgICAgaCA9IHRoaXMuc3RhcnRBbmdsZVJhZCA9IGEuc3RhcnQ7XG4gICAgICAgIGEgPSAodGhpcy5lbmRBbmdsZVJhZCA9IGEuZW5kKSAtIGg7XG4gICAgICAgIHZhciB2ID0gdGhpcy5wb2ludHMsXG4gICAgICAgICAgICBxID0gZC5kYXRhTGFiZWxzLmRpc3RhbmNlO1xuICAgICAgICBkID0gZC5pZ25vcmVIaWRkZW5Qb2ludDtcbiAgICAgICAgdmFyIHcsXG4gICAgICAgICAgICByID0gdi5sZW5ndGg7XG4gICAgICAgIGUgfHwgKHRoaXMuY2VudGVyID0gZSA9IHRoaXMuZ2V0Q2VudGVyKCkpO1xuXG4gICAgICAgIGZvciAodyA9IDA7IHcgPCByOyB3KyspIHtcbiAgICAgICAgICB2YXIgdSA9IHZbd107XG4gICAgICAgICAgdmFyIEQgPSBoICsgYyAqIGE7XG4gICAgICAgICAgaWYgKCFkIHx8IHUudmlzaWJsZSkgYyArPSB1LnBlcmNlbnRhZ2UgLyAxMDA7XG4gICAgICAgICAgdmFyIEggPSBoICsgYyAqIGE7XG4gICAgICAgICAgdS5zaGFwZVR5cGUgPSBcImFyY1wiO1xuICAgICAgICAgIHUuc2hhcGVBcmdzID0ge1xuICAgICAgICAgICAgeDogZVswXSxcbiAgICAgICAgICAgIHk6IGVbMV0sXG4gICAgICAgICAgICByOiBlWzJdIC8gMixcbiAgICAgICAgICAgIGlubmVyUjogZVszXSAvIDIsXG4gICAgICAgICAgICBzdGFydDogTWF0aC5yb3VuZCgxRTMgKiBEKSAvIDFFMyxcbiAgICAgICAgICAgIGVuZDogTWF0aC5yb3VuZCgxRTMgKiBIKSAvIDFFM1xuICAgICAgICAgIH07XG4gICAgICAgICAgdS5sYWJlbERpc3RhbmNlID0geSh1Lm9wdGlvbnMuZGF0YUxhYmVscyAmJiB1Lm9wdGlvbnMuZGF0YUxhYmVscy5kaXN0YW5jZSwgcSk7XG4gICAgICAgICAgdS5sYWJlbERpc3RhbmNlID0gdCh1LmxhYmVsRGlzdGFuY2UsIHUuc2hhcGVBcmdzLnIpO1xuICAgICAgICAgIHRoaXMubWF4TGFiZWxEaXN0YW5jZSA9IE1hdGgubWF4KHRoaXMubWF4TGFiZWxEaXN0YW5jZSB8fCAwLCB1LmxhYmVsRGlzdGFuY2UpO1xuICAgICAgICAgIEggPSAoSCArIEQpIC8gMjtcbiAgICAgICAgICBIID4gMS41ICogTWF0aC5QSSA/IEggLT0gMiAqIE1hdGguUEkgOiBIIDwgLU1hdGguUEkgLyAyICYmIChIICs9IDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICB1LnNsaWNlZFRyYW5zbGF0aW9uID0ge1xuICAgICAgICAgICAgdHJhbnNsYXRlWDogTWF0aC5yb3VuZChNYXRoLmNvcyhIKSAqIGcpLFxuICAgICAgICAgICAgdHJhbnNsYXRlWTogTWF0aC5yb3VuZChNYXRoLnNpbihIKSAqIGcpXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgSyA9IE1hdGguY29zKEgpICogZVsyXSAvIDI7XG4gICAgICAgICAgdmFyIHAgPSBNYXRoLnNpbihIKSAqIGVbMl0gLyAyO1xuICAgICAgICAgIHUudG9vbHRpcFBvcyA9IFtlWzBdICsgLjcgKiBLLCBlWzFdICsgLjcgKiBwXTtcbiAgICAgICAgICB1LmhhbGYgPSBIIDwgLU1hdGguUEkgLyAyIHx8IEggPiBNYXRoLlBJIC8gMiA/IDEgOiAwO1xuICAgICAgICAgIHUuYW5nbGUgPSBIO1xuICAgICAgICAgIEQgPSBNYXRoLm1pbihmLCB1LmxhYmVsRGlzdGFuY2UgLyA1KTtcbiAgICAgICAgICB1LmxhYmVsUG9zaXRpb24gPSB7XG4gICAgICAgICAgICBuYXR1cmFsOiB7XG4gICAgICAgICAgICAgIHg6IGVbMF0gKyBLICsgTWF0aC5jb3MoSCkgKiB1LmxhYmVsRGlzdGFuY2UsXG4gICAgICAgICAgICAgIHk6IGVbMV0gKyBwICsgTWF0aC5zaW4oSCkgKiB1LmxhYmVsRGlzdGFuY2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZpbmFsXCI6IHt9LFxuICAgICAgICAgICAgYWxpZ25tZW50OiAwID4gdS5sYWJlbERpc3RhbmNlID8gXCJjZW50ZXJcIiA6IHUuaGFsZiA/IFwicmlnaHRcIiA6IFwibGVmdFwiLFxuICAgICAgICAgICAgY29ubmVjdG9yUG9zaXRpb246IHtcbiAgICAgICAgICAgICAgYnJlYWtBdDoge1xuICAgICAgICAgICAgICAgIHg6IGVbMF0gKyBLICsgTWF0aC5jb3MoSCkgKiBELFxuICAgICAgICAgICAgICAgIHk6IGVbMV0gKyBwICsgTWF0aC5zaW4oSCkgKiBEXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRvdWNoaW5nU2xpY2VBdDoge1xuICAgICAgICAgICAgICAgIHg6IGVbMF0gKyBLLFxuICAgICAgICAgICAgICAgIHk6IGVbMV0gKyBwXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgQSh0aGlzLCBcImFmdGVyVHJhbnNsYXRlXCIpO1xuICAgICAgfSxcbiAgICAgIGRyYXdFbXB0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICBpZiAoMCA9PT0gdGhpcy50b3RhbCkge1xuICAgICAgICAgIHZhciBjID0gdGhpcy5jZW50ZXJbMF07XG4gICAgICAgICAgdmFyIGQgPSB0aGlzLmNlbnRlclsxXTtcbiAgICAgICAgICB0aGlzLmdyYXBoIHx8ICh0aGlzLmdyYXBoID0gdGhpcy5jaGFydC5yZW5kZXJlci5jaXJjbGUoYywgZCwgMCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWdyYXBoXCIpLmFkZCh0aGlzLmdyb3VwKSk7XG4gICAgICAgICAgdGhpcy5ncmFwaC5hbmltYXRlKHtcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICBjeDogYyxcbiAgICAgICAgICAgIGN5OiBkLFxuICAgICAgICAgICAgcjogdGhpcy5jZW50ZXJbMl0gLyAyLFxuICAgICAgICAgICAgZmlsbDogZS5maWxsQ29sb3IgfHwgXCJub25lXCIsXG4gICAgICAgICAgICBzdHJva2U6IGUuY29sb3IgfHwgXCIjY2NjY2NjXCJcbiAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHRoaXMuZ3JhcGggJiYgKHRoaXMuZ3JhcGggPSB0aGlzLmdyYXBoLmRlc3Ryb3koKSk7XG4gICAgICB9LFxuICAgICAgcmVkcmF3UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgICAgIGMgPSBlLmNoYXJ0LFxuICAgICAgICAgICAgZCA9IGMucmVuZGVyZXIsXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgZixcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBoLFxuICAgICAgICAgICAgdiA9IGUub3B0aW9ucy5zaGFkb3c7XG4gICAgICAgIHRoaXMuZHJhd0VtcHR5KCk7XG4gICAgICAgICF2IHx8IGUuc2hhZG93R3JvdXAgfHwgYy5zdHlsZWRNb2RlIHx8IChlLnNoYWRvd0dyb3VwID0gZC5nKFwic2hhZG93XCIpLmF0dHIoe1xuICAgICAgICAgIHpJbmRleDogLTFcbiAgICAgICAgfSkuYWRkKGUuZ3JvdXApKTtcbiAgICAgICAgZS5wb2ludHMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgIHZhciBsID0ge307XG4gICAgICAgICAgZiA9IGsuZ3JhcGhpYztcblxuICAgICAgICAgIGlmICghay5pc051bGwgJiYgZikge1xuICAgICAgICAgICAgaCA9IGsuc2hhcGVBcmdzO1xuICAgICAgICAgICAgZyA9IGsuZ2V0VHJhbnNsYXRlKCk7XG5cbiAgICAgICAgICAgIGlmICghYy5zdHlsZWRNb2RlKSB7XG4gICAgICAgICAgICAgIHZhciBuID0gay5zaGFkb3dHcm91cDtcbiAgICAgICAgICAgICAgdiAmJiAhbiAmJiAobiA9IGsuc2hhZG93R3JvdXAgPSBkLmcoXCJzaGFkb3dcIikuYWRkKGUuc2hhZG93R3JvdXApKTtcbiAgICAgICAgICAgICAgbiAmJiBuLmF0dHIoZyk7XG4gICAgICAgICAgICAgIGEgPSBlLnBvaW50QXR0cmlicyhrLCBrLnNlbGVjdGVkICYmIFwic2VsZWN0XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBrLmRlbGF5ZWRSZW5kZXJpbmcgPyAoZi5zZXRSYWRpYWxSZWZlcmVuY2UoZS5jZW50ZXIpLmF0dHIoaCkuYXR0cihnKSwgYy5zdHlsZWRNb2RlIHx8IGYuYXR0cihhKS5hdHRyKHtcbiAgICAgICAgICAgICAgXCJzdHJva2UtbGluZWpvaW5cIjogXCJyb3VuZFwiXG4gICAgICAgICAgICB9KS5zaGFkb3codiwgbiksIGsuZGVsYXllZFJlbmRlcmluZyA9ICExKSA6IChmLnNldFJhZGlhbFJlZmVyZW5jZShlLmNlbnRlciksIGMuc3R5bGVkTW9kZSB8fCBKKCEwLCBsLCBhKSwgSighMCwgbCwgaCwgZyksIGYuYW5pbWF0ZShsKSk7XG4gICAgICAgICAgICBmLmF0dHIoe1xuICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBrLnZpc2libGUgPyBcImluaGVyaXRcIiA6IFwiaGlkZGVuXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZi5hZGRDbGFzcyhrLmdldENsYXNzTmFtZSgpKTtcbiAgICAgICAgICB9IGVsc2UgZiAmJiAoay5ncmFwaGljID0gZi5kZXN0cm95KCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBkcmF3UG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5jaGFydC5yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5wb2ludHMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGMuZ3JhcGhpYyAmJiBjLmhhc05ld1NoYXBlVHlwZSgpICYmIChjLmdyYXBoaWMgPSBjLmdyYXBoaWMuZGVzdHJveSgpKTtcbiAgICAgICAgICBjLmdyYXBoaWMgfHwgKGMuZ3JhcGhpYyA9IGVbYy5zaGFwZVR5cGVdKGMuc2hhcGVBcmdzKS5hZGQoYy5zZXJpZXMuZ3JvdXApLCBjLmRlbGF5ZWRSZW5kZXJpbmcgPSAhMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHNlYXJjaFBvaW50OiBxLFxuICAgICAgc29ydEJ5QW5nbGU6IGZ1bmN0aW9uIChlLCBjKSB7XG4gICAgICAgIGUuc29ydChmdW5jdGlvbiAoZSwgZCkge1xuICAgICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZS5hbmdsZSAmJiAoZC5hbmdsZSAtIGUuYW5nbGUpICogYztcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZHJhd0xlZ2VuZFN5bWJvbDogZy5kcmF3UmVjdGFuZ2xlLFxuICAgICAgZ2V0Q2VudGVyOiB1LmdldENlbnRlcixcbiAgICAgIGdldFN5bWJvbDogcSxcbiAgICAgIGRyYXdHcmFwaDogbnVsbFxuICAgIH0sIHtcbiAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgci5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICAgIGUubmFtZSA9IHkoZS5uYW1lLCBcIlNsaWNlXCIpO1xuXG4gICAgICAgIHZhciBjID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBlLnNsaWNlKFwic2VsZWN0XCIgPT09IGMudHlwZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgSShlLCBcInNlbGVjdFwiLCBjKTtcbiAgICAgICAgSShlLCBcInVuc2VsZWN0XCIsIGMpO1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0sXG4gICAgICBpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBHKHRoaXMueSkgJiYgMCA8PSB0aGlzLnk7XG4gICAgICB9LFxuICAgICAgc2V0VmlzaWJsZTogZnVuY3Rpb24gKGUsIGMpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgICAgZyA9IGQuc2VyaWVzLFxuICAgICAgICAgICAgZiA9IGcuY2hhcnQsXG4gICAgICAgICAgICBhID0gZy5vcHRpb25zLmlnbm9yZUhpZGRlblBvaW50O1xuICAgICAgICBjID0geShjLCBhKTtcbiAgICAgICAgZSAhPT0gZC52aXNpYmxlICYmIChkLnZpc2libGUgPSBkLm9wdGlvbnMudmlzaWJsZSA9IGUgPSBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgZSA/ICFkLnZpc2libGUgOiBlLCBnLm9wdGlvbnMuZGF0YVtnLmRhdGEuaW5kZXhPZihkKV0gPSBkLm9wdGlvbnMsIFtcImdyYXBoaWNcIiwgXCJkYXRhTGFiZWxcIiwgXCJjb25uZWN0b3JcIiwgXCJzaGFkb3dHcm91cFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgaWYgKGRbYV0pIGRbYV1bZSA/IFwic2hvd1wiIDogXCJoaWRlXCJdKCEwKTtcbiAgICAgICAgfSksIGQubGVnZW5kSXRlbSAmJiBmLmxlZ2VuZC5jb2xvcml6ZUl0ZW0oZCwgZSksIGUgfHwgXCJob3ZlclwiICE9PSBkLnN0YXRlIHx8IGQuc2V0U3RhdGUoXCJcIiksIGEgJiYgKGcuaXNEaXJ0eSA9ICEwKSwgYyAmJiBmLnJlZHJhdygpKTtcbiAgICAgIH0sXG4gICAgICBzbGljZTogZnVuY3Rpb24gKGUsIGMsIGQpIHtcbiAgICAgICAgdmFyIGcgPSB0aGlzLnNlcmllcztcbiAgICAgICAgaChkLCBnLmNoYXJ0KTtcbiAgICAgICAgeShjLCAhMCk7XG4gICAgICAgIHRoaXMuc2xpY2VkID0gdGhpcy5vcHRpb25zLnNsaWNlZCA9IEUoZSkgPyBlIDogIXRoaXMuc2xpY2VkO1xuICAgICAgICBnLm9wdGlvbnMuZGF0YVtnLmRhdGEuaW5kZXhPZih0aGlzKV0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHRoaXMuZ3JhcGhpYy5hbmltYXRlKHRoaXMuZ2V0VHJhbnNsYXRlKCkpO1xuICAgICAgICB0aGlzLnNoYWRvd0dyb3VwICYmIHRoaXMuc2hhZG93R3JvdXAuYW5pbWF0ZSh0aGlzLmdldFRyYW5zbGF0ZSgpKTtcbiAgICAgIH0sXG4gICAgICBnZXRUcmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2VkID8gdGhpcy5zbGljZWRUcmFuc2xhdGlvbiA6IHtcbiAgICAgICAgICB0cmFuc2xhdGVYOiAwLFxuICAgICAgICAgIHRyYW5zbGF0ZVk6IDBcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBoYWxvUGF0aDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLnNoYXBlQXJncztcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2VkIHx8ICF0aGlzLnZpc2libGUgPyBbXSA6IHRoaXMuc2VyaWVzLmNoYXJ0LnJlbmRlcmVyLnN5bWJvbHMuYXJjKGMueCwgYy55LCBjLnIgKyBlLCBjLnIgKyBlLCB7XG4gICAgICAgICAgaW5uZXJSOiBjLnIgLSAxLFxuICAgICAgICAgIHN0YXJ0OiBjLnN0YXJ0LFxuICAgICAgICAgIGVuZDogYy5lbmRcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgY29ubmVjdG9yU2hhcGVzOiB7XG4gICAgICAgIGZpeGVkT2Zmc2V0OiBmdW5jdGlvbiAoZSwgYywgZCkge1xuICAgICAgICAgIHZhciBnID0gYy5icmVha0F0O1xuICAgICAgICAgIGMgPSBjLnRvdWNoaW5nU2xpY2VBdDtcbiAgICAgICAgICByZXR1cm4gW1wiTVwiLCBlLngsIGUueV0uY29uY2F0KGQuc29mdENvbm5lY3RvciA/IFtcIkNcIiwgZS54ICsgKFwibGVmdFwiID09PSBlLmFsaWdubWVudCA/IC01IDogNSksIGUueSwgMiAqIGcueCAtIGMueCwgMiAqIGcueSAtIGMueSwgZy54LCBnLnldIDogW1wiTFwiLCBnLngsIGcueV0pLmNvbmNhdChbXCJMXCIsIGMueCwgYy55XSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmFpZ2h0OiBmdW5jdGlvbiAoZSwgYykge1xuICAgICAgICAgIGMgPSBjLnRvdWNoaW5nU2xpY2VBdDtcbiAgICAgICAgICByZXR1cm4gW1wiTVwiLCBlLngsIGUueSwgXCJMXCIsIGMueCwgYy55XTtcbiAgICAgICAgfSxcbiAgICAgICAgY3Jvb2tlZExpbmU6IGZ1bmN0aW9uIChlLCBjLCBkKSB7XG4gICAgICAgICAgYyA9IGMudG91Y2hpbmdTbGljZUF0O1xuICAgICAgICAgIHZhciBnID0gdGhpcy5zZXJpZXMsXG4gICAgICAgICAgICAgIGYgPSBnLmNlbnRlclswXSxcbiAgICAgICAgICAgICAgYSA9IGcuY2hhcnQucGxvdFdpZHRoLFxuICAgICAgICAgICAgICBrID0gZy5jaGFydC5wbG90TGVmdDtcbiAgICAgICAgICBnID0gZS5hbGlnbm1lbnQ7XG4gICAgICAgICAgdmFyIGggPSB0aGlzLnNoYXBlQXJncy5yO1xuICAgICAgICAgIGQgPSB0KGQuY3Jvb2tEaXN0YW5jZSwgMSk7XG4gICAgICAgICAgZCA9IFwibGVmdFwiID09PSBnID8gZiArIGggKyAoYSArIGsgLSBmIC0gaCkgKiAoMSAtIGQpIDogayArIChmIC0gaCkgKiBkO1xuICAgICAgICAgIGYgPSBbXCJMXCIsIGQsIGUueV07XG4gICAgICAgICAgaWYgKFwibGVmdFwiID09PSBnID8gZCA+IGUueCB8fCBkIDwgYy54IDogZCA8IGUueCB8fCBkID4gYy54KSBmID0gW107XG4gICAgICAgICAgcmV0dXJuIFtcIk1cIiwgZS54LCBlLnldLmNvbmNhdChmKS5jb25jYXQoW1wiTFwiLCBjLngsIGMueV0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0Q29ubmVjdG9yUGF0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMubGFiZWxQb3NpdGlvbixcbiAgICAgICAgICAgIGMgPSB0aGlzLnNlcmllcy5vcHRpb25zLmRhdGFMYWJlbHMsXG4gICAgICAgICAgICBkID0gYy5jb25uZWN0b3JTaGFwZSxcbiAgICAgICAgICAgIGcgPSB0aGlzLmNvbm5lY3RvclNoYXBlcztcbiAgICAgICAgZ1tkXSAmJiAoZCA9IGdbZF0pO1xuICAgICAgICByZXR1cm4gZC5jYWxsKHRoaXMsIHtcbiAgICAgICAgICB4OiBlLmZpbmFsLngsXG4gICAgICAgICAgeTogZS5maW5hbC55LFxuICAgICAgICAgIGFsaWdubWVudDogZS5hbGlnbm1lbnRcbiAgICAgICAgfSwgZS5jb25uZWN0b3JQb3NpdGlvbiwgYyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXCJcIjtcbiAgfSk7XG4gIFMociwgXCJwYXJ0cy9EYXRhTGFiZWxzLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXSwgcltcInBhcnRzL1V0aWxpdGllcy5qc1wiXV0sIGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgdmFyIHIgPSBnLmFuaW1PYmplY3QsXG4gICAgICAgIHUgPSBnLmFycmF5TWF4LFxuICAgICAgICBJID0gZy5jbGFtcCxcbiAgICAgICAgTSA9IGcuZGVmaW5lZCxcbiAgICAgICAgRSA9IGcuZXh0ZW5kLFxuICAgICAgICBBID0gZy5mb3JtYXQsXG4gICAgICAgIEcgPSBnLmlzQXJyYXksXG4gICAgICAgIEogPSBnLm1lcmdlLFxuICAgICAgICB5ID0gZy5vYmplY3RFYWNoLFxuICAgICAgICB0ID0gZy5waWNrLFxuICAgICAgICBEID0gZy5yZWxhdGl2ZUxlbmd0aCxcbiAgICAgICAgaCA9IGcuc3BsYXQsXG4gICAgICAgIE4gPSBnLnN0YWJsZVNvcnQ7XG4gICAgZyA9IGQubm9vcDtcbiAgICB2YXIgcSA9IGQuU2VyaWVzLFxuICAgICAgICBQID0gZC5zZXJpZXNUeXBlcztcblxuICAgIGQuZGlzdHJpYnV0ZSA9IGZ1bmN0aW9uIChlLCBjLCBnKSB7XG4gICAgICBmdW5jdGlvbiBoKGEsIGMpIHtcbiAgICAgICAgcmV0dXJuIGEudGFyZ2V0IC0gYy50YXJnZXQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBmLFxuICAgICAgICAgIGEgPSAhMCxcbiAgICAgICAgICBrID0gZSxcbiAgICAgICAgICB2ID0gW107XG4gICAgICB2YXIgcSA9IDA7XG4gICAgICB2YXIgdyA9IGsucmVkdWNlZExlbiB8fCBjO1xuXG4gICAgICBmb3IgKGYgPSBlLmxlbmd0aDsgZi0tOykgcSArPSBlW2ZdLnNpemU7XG5cbiAgICAgIGlmIChxID4gdykge1xuICAgICAgICBOKGUsIGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgICAgcmV0dXJuIChjLnJhbmsgfHwgMCkgLSAoYS5yYW5rIHx8IDApO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHEgPSBmID0gMDsgcSA8PSB3OykgcSArPSBlW2ZdLnNpemUsIGYrKztcblxuICAgICAgICB2ID0gZS5zcGxpY2UoZiAtIDEsIGUubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgTihlLCBoKTtcblxuICAgICAgZm9yIChlID0gZS5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzaXplOiBhLnNpemUsXG4gICAgICAgICAgdGFyZ2V0czogW2EudGFyZ2V0XSxcbiAgICAgICAgICBhbGlnbjogdChhLmFsaWduLCAuNSlcbiAgICAgICAgfTtcbiAgICAgIH0pOyBhOykge1xuICAgICAgICBmb3IgKGYgPSBlLmxlbmd0aDsgZi0tOykgYSA9IGVbZl0sIHEgPSAoTWF0aC5taW4uYXBwbHkoMCwgYS50YXJnZXRzKSArIE1hdGgubWF4LmFwcGx5KDAsIGEudGFyZ2V0cykpIC8gMiwgYS5wb3MgPSBJKHEgLSBhLnNpemUgKiBhLmFsaWduLCAwLCBjIC0gYS5zaXplKTtcblxuICAgICAgICBmID0gZS5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChhID0gITE7IGYtLTspIDAgPCBmICYmIGVbZiAtIDFdLnBvcyArIGVbZiAtIDFdLnNpemUgPiBlW2ZdLnBvcyAmJiAoZVtmIC0gMV0uc2l6ZSArPSBlW2ZdLnNpemUsIGVbZiAtIDFdLnRhcmdldHMgPSBlW2YgLSAxXS50YXJnZXRzLmNvbmNhdChlW2ZdLnRhcmdldHMpLCBlW2YgLSAxXS5hbGlnbiA9IC41LCBlW2YgLSAxXS5wb3MgKyBlW2YgLSAxXS5zaXplID4gYyAmJiAoZVtmIC0gMV0ucG9zID0gYyAtIGVbZiAtIDFdLnNpemUpLCBlLnNwbGljZShmLCAxKSwgYSA9ICEwKTtcbiAgICAgIH1cblxuICAgICAgay5wdXNoLmFwcGx5KGssIHYpO1xuICAgICAgZiA9IDA7XG4gICAgICBlLnNvbWUoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGUgPSAwO1xuICAgICAgICBpZiAoYS50YXJnZXRzLnNvbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGtbZl0ucG9zID0gYS5wb3MgKyBlO1xuICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZyAmJiBNYXRoLmFicyhrW2ZdLnBvcyAtIGtbZl0udGFyZ2V0KSA+IGcpIHJldHVybiBrLnNsaWNlKDAsIGYgKyAxKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBkZWxldGUgYS5wb3M7XG4gICAgICAgICAgfSksIGsucmVkdWNlZExlbiA9IChrLnJlZHVjZWRMZW4gfHwgYykgLSAuMSAqIGMsIGsucmVkdWNlZExlbiA+IC4xICogYyAmJiBkLmRpc3RyaWJ1dGUoaywgYywgZyksICEwO1xuICAgICAgICAgIGUgKz0ga1tmXS5zaXplO1xuICAgICAgICAgIGYrKztcbiAgICAgICAgfSkpIHJldHVybiAhMDtcbiAgICAgIH0pO1xuICAgICAgTihrLCBoKTtcbiAgICB9O1xuXG4gICAgcS5wcm90b3R5cGUuZHJhd0RhdGFMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBlKGEsIGMpIHtcbiAgICAgICAgdmFyIGIgPSBjLmZpbHRlcjtcbiAgICAgICAgcmV0dXJuIGIgPyAoYyA9IGIub3BlcmF0b3IsIGEgPSBhW2IucHJvcGVydHldLCBiID0gYi52YWx1ZSwgXCI+XCIgPT09IGMgJiYgYSA+IGIgfHwgXCI8XCIgPT09IGMgJiYgYSA8IGIgfHwgXCI+PVwiID09PSBjICYmIGEgPj0gYiB8fCBcIjw9XCIgPT09IGMgJiYgYSA8PSBiIHx8IFwiPT1cIiA9PT0gYyAmJiBhID09IGIgfHwgXCI9PT1cIiA9PT0gYyAmJiBhID09PSBiID8gITAgOiAhMSkgOiAhMDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYyhhLCBjKSB7XG4gICAgICAgIHZhciBiID0gW10sXG4gICAgICAgICAgICBlO1xuICAgICAgICBpZiAoRyhhKSAmJiAhRyhjKSkgYiA9IGEubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgcmV0dXJuIEooYSwgYyk7XG4gICAgICAgIH0pO2Vsc2UgaWYgKEcoYykgJiYgIUcoYSkpIGIgPSBjLm1hcChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHJldHVybiBKKGEsIGIpO1xuICAgICAgICB9KTtlbHNlIGlmIChHKGEpIHx8IEcoYykpIGZvciAoZSA9IE1hdGgubWF4KGEubGVuZ3RoLCBjLmxlbmd0aCk7IGUtLTspIGJbZV0gPSBKKGFbZV0sIGNbZV0pO2Vsc2UgYiA9IEooYSwgYyk7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfVxuXG4gICAgICB2YXIgZyA9IHRoaXMsXG4gICAgICAgICAgbiA9IGcuY2hhcnQsXG4gICAgICAgICAgZiA9IGcub3B0aW9ucyxcbiAgICAgICAgICBhID0gZi5kYXRhTGFiZWxzLFxuICAgICAgICAgIGwgPSBnLnBvaW50cyxcbiAgICAgICAgICB2LFxuICAgICAgICAgIHEgPSBnLmhhc1JlbmRlcmVkIHx8IDAsXG4gICAgICAgICAgdyA9IHIoZi5hbmltYXRpb24pLmR1cmF0aW9uLFxuICAgICAgICAgIHUgPSBNYXRoLm1pbih3LCAyMDApLFxuICAgICAgICAgIEwgPSAhbi5yZW5kZXJlci5mb3JFeHBvcnQgJiYgdChhLmRlZmVyLCAwIDwgdSksXG4gICAgICAgICAgRCA9IG4ucmVuZGVyZXI7XG4gICAgICBhID0gYyhjKG4ub3B0aW9ucy5wbG90T3B0aW9ucyAmJiBuLm9wdGlvbnMucGxvdE9wdGlvbnMuc2VyaWVzICYmIG4ub3B0aW9ucy5wbG90T3B0aW9ucy5zZXJpZXMuZGF0YUxhYmVscywgbi5vcHRpb25zLnBsb3RPcHRpb25zICYmIG4ub3B0aW9ucy5wbG90T3B0aW9uc1tnLnR5cGVdICYmIG4ub3B0aW9ucy5wbG90T3B0aW9uc1tnLnR5cGVdLmRhdGFMYWJlbHMpLCBhKTtcbiAgICAgIGQuZmlyZUV2ZW50KHRoaXMsIFwiZHJhd0RhdGFMYWJlbHNcIik7XG5cbiAgICAgIGlmIChHKGEpIHx8IGEuZW5hYmxlZCB8fCBnLl9oYXNQb2ludExhYmVscykge1xuICAgICAgICB2YXIgSCA9IGcucGxvdEdyb3VwKFwiZGF0YUxhYmVsc0dyb3VwXCIsIFwiZGF0YS1sYWJlbHNcIiwgTCAmJiAhcSA/IFwiaGlkZGVuXCIgOiBcImluaGVyaXRcIiwgYS56SW5kZXggfHwgNik7XG4gICAgICAgIEwgJiYgKEguYXR0cih7XG4gICAgICAgICAgb3BhY2l0eTogK3FcbiAgICAgICAgfSksIHEgfHwgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGEgPSBnLmRhdGFMYWJlbHNHcm91cDtcbiAgICAgICAgICBhICYmIChnLnZpc2libGUgJiYgSC5zaG93KCEwKSwgYVtmLmFuaW1hdGlvbiA/IFwiYW5pbWF0ZVwiIDogXCJhdHRyXCJdKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogdVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSwgdyAtIHUpKTtcbiAgICAgICAgbC5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgdiA9IGgoYyhhLCBkLmRsT3B0aW9ucyB8fCBkLm9wdGlvbnMgJiYgZC5vcHRpb25zLmRhdGFMYWJlbHMpKTtcbiAgICAgICAgICB2LmZvckVhY2goZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBjID0gYS5lbmFibGVkICYmICghZC5pc051bGwgfHwgZC5kYXRhTGFiZWxPbk51bGwpICYmIGUoZCwgYSksXG4gICAgICAgICAgICAgICAgaCA9IGQuZGF0YUxhYmVscyA/IGQuZGF0YUxhYmVsc1tiXSA6IGQuZGF0YUxhYmVsLFxuICAgICAgICAgICAgICAgIGsgPSBkLmNvbm5lY3RvcnMgPyBkLmNvbm5lY3RvcnNbYl0gOiBkLmNvbm5lY3RvcixcbiAgICAgICAgICAgICAgICBsID0gdChhLmRpc3RhbmNlLCBkLmxhYmVsRGlzdGFuY2UpLFxuICAgICAgICAgICAgICAgIHAgPSAhaDtcblxuICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgdmFyIHYgPSBkLmdldExhYmVsQ29uZmlnKCk7XG4gICAgICAgICAgICAgIHZhciBtID0gdChhW2QuZm9ybWF0UHJlZml4ICsgXCJGb3JtYXRcIl0sIGEuZm9ybWF0KTtcbiAgICAgICAgICAgICAgdiA9IE0obSkgPyBBKG0sIHYsIG4pIDogKGFbZC5mb3JtYXRQcmVmaXggKyBcIkZvcm1hdHRlclwiXSB8fCBhLmZvcm1hdHRlcikuY2FsbCh2LCBhKTtcbiAgICAgICAgICAgICAgbSA9IGEuc3R5bGU7XG4gICAgICAgICAgICAgIHZhciBxID0gYS5yb3RhdGlvbjtcbiAgICAgICAgICAgICAgbi5zdHlsZWRNb2RlIHx8IChtLmNvbG9yID0gdChhLmNvbG9yLCBtLmNvbG9yLCBnLmNvbG9yLCBcIiMwMDAwMDBcIiksIFwiY29udHJhc3RcIiA9PT0gbS5jb2xvciA/IChkLmNvbnRyYXN0Q29sb3IgPSBELmdldENvbnRyYXN0KGQuY29sb3IgfHwgZy5jb2xvciksIG0uY29sb3IgPSAhTShsKSAmJiBhLmluc2lkZSB8fCAwID4gbCB8fCBmLnN0YWNraW5nID8gZC5jb250cmFzdENvbG9yIDogXCIjMDAwMDAwXCIpIDogZGVsZXRlIGQuY29udHJhc3RDb2xvciwgZi5jdXJzb3IgJiYgKG0uY3Vyc29yID0gZi5jdXJzb3IpKTtcbiAgICAgICAgICAgICAgdmFyIHcgPSB7XG4gICAgICAgICAgICAgICAgcjogYS5ib3JkZXJSYWRpdXMgfHwgMCxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogcSxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiBhLnBhZGRpbmcsXG4gICAgICAgICAgICAgICAgekluZGV4OiAxXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIG4uc3R5bGVkTW9kZSB8fCAody5maWxsID0gYS5iYWNrZ3JvdW5kQ29sb3IsIHcuc3Ryb2tlID0gYS5ib3JkZXJDb2xvciwgd1tcInN0cm9rZS13aWR0aFwiXSA9IGEuYm9yZGVyV2lkdGgpO1xuICAgICAgICAgICAgICB5KHcsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGEgJiYgZGVsZXRlIHdbYl07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAhaCB8fCBjICYmIE0odikgPyBjICYmIE0odikgJiYgKGggPyB3LnRleHQgPSB2IDogKGQuZGF0YUxhYmVscyA9IGQuZGF0YUxhYmVscyB8fCBbXSwgaCA9IGQuZGF0YUxhYmVsc1tiXSA9IHEgPyBELnRleHQodiwgMCwgLTk5OTksIGEudXNlSFRNTCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWRhdGEtbGFiZWxcIikgOiBELmxhYmVsKHYsIDAsIC05OTk5LCBhLnNoYXBlLCBudWxsLCBudWxsLCBhLnVzZUhUTUwsIG51bGwsIFwiZGF0YS1sYWJlbFwiKSwgYiB8fCAoZC5kYXRhTGFiZWwgPSBoKSwgaC5hZGRDbGFzcyhcIiBoaWdoY2hhcnRzLWRhdGEtbGFiZWwtY29sb3ItXCIgKyBkLmNvbG9ySW5kZXggKyBcIiBcIiArIChhLmNsYXNzTmFtZSB8fCBcIlwiKSArIChhLnVzZUhUTUwgPyBcIiBoaWdoY2hhcnRzLXRyYWNrZXJcIiA6IFwiXCIpKSksIGgub3B0aW9ucyA9IGEsIGguYXR0cih3KSwgbi5zdHlsZWRNb2RlIHx8IGguY3NzKG0pLnNoYWRvdyhhLnNoYWRvdyksIGguYWRkZWQgfHwgaC5hZGQoSCksIGEudGV4dFBhdGggJiYgIWEudXNlSFRNTCAmJiAoaC5zZXRUZXh0UGF0aChkLmdldERhdGFMYWJlbFBhdGggJiYgZC5nZXREYXRhTGFiZWxQYXRoKGgpIHx8IGQuZ3JhcGhpYywgYS50ZXh0UGF0aCksIGQuZGF0YUxhYmVsUGF0aCAmJiAhYS50ZXh0UGF0aC5lbmFibGVkICYmIChkLmRhdGFMYWJlbFBhdGggPSBkLmRhdGFMYWJlbFBhdGguZGVzdHJveSgpKSksIGcuYWxpZ25EYXRhTGFiZWwoZCwgaCwgYSwgbnVsbCwgcCkpIDogKGQuZGF0YUxhYmVsID0gZC5kYXRhTGFiZWwgJiYgZC5kYXRhTGFiZWwuZGVzdHJveSgpLCBkLmRhdGFMYWJlbHMgJiYgKDEgPT09IGQuZGF0YUxhYmVscy5sZW5ndGggPyBkZWxldGUgZC5kYXRhTGFiZWxzIDogZGVsZXRlIGQuZGF0YUxhYmVsc1tiXSksIGIgfHwgZGVsZXRlIGQuZGF0YUxhYmVsLCBrICYmIChkLmNvbm5lY3RvciA9IGQuY29ubmVjdG9yLmRlc3Ryb3koKSwgZC5jb25uZWN0b3JzICYmICgxID09PSBkLmNvbm5lY3RvcnMubGVuZ3RoID8gZGVsZXRlIGQuY29ubmVjdG9ycyA6IGRlbGV0ZSBkLmNvbm5lY3RvcnNbYl0pKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBkLmZpcmVFdmVudCh0aGlzLCBcImFmdGVyRHJhd0RhdGFMYWJlbHNcIik7XG4gICAgfTtcblxuICAgIHEucHJvdG90eXBlLmFsaWduRGF0YUxhYmVsID0gZnVuY3Rpb24gKGQsIGMsIGcsIGgsIGYpIHtcbiAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICBlID0gdGhpcy5jaGFydCxcbiAgICAgICAgICBrID0gdGhpcy5pc0NhcnRlc2lhbiAmJiBlLmludmVydGVkLFxuICAgICAgICAgIG4gPSB0aGlzLmVuYWJsZWREYXRhU29ydGluZyxcbiAgICAgICAgICBxID0gdChkLmRsQm94ICYmIGQuZGxCb3guY2VudGVyWCwgZC5wbG90WCwgLTk5OTkpLFxuICAgICAgICAgIHIgPSB0KGQucGxvdFksIC05OTk5KSxcbiAgICAgICAgICB1ID0gYy5nZXRCQm94KCksXG4gICAgICAgICAgeSA9IGcucm90YXRpb24sXG4gICAgICAgICAgQSA9IGcuYWxpZ24sXG4gICAgICAgICAgSyA9IGUuaXNJbnNpZGVQbG90KHEsIE1hdGgucm91bmQociksIGspLFxuICAgICAgICAgIHAgPSBcImp1c3RpZnlcIiA9PT0gdChnLm92ZXJmbG93LCBuID8gXCJub25lXCIgOiBcImp1c3RpZnlcIiksXG4gICAgICAgICAgYiA9IHRoaXMudmlzaWJsZSAmJiAhMSAhPT0gZC52aXNpYmxlICYmIChkLnNlcmllcy5mb3JjZURMIHx8IG4gJiYgIXAgfHwgSyB8fCBnLmluc2lkZSAmJiBoICYmIGUuaXNJbnNpZGVQbG90KHEsIGsgPyBoLnggKyAxIDogaC55ICsgaC5oZWlnaHQgLSAxLCBrKSk7XG5cbiAgICAgIHZhciBDID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgbiAmJiBhLnhBeGlzICYmICFwICYmIGEuc2V0RGF0YUxhYmVsU3RhcnRQb3MoZCwgYywgZiwgSywgYik7XG4gICAgICB9O1xuXG4gICAgICBpZiAoYikge1xuICAgICAgICB2YXIgeCA9IGUucmVuZGVyZXIuZm9udE1ldHJpY3MoZS5zdHlsZWRNb2RlID8gdm9pZCAwIDogZy5zdHlsZS5mb250U2l6ZSwgYykuYjtcbiAgICAgICAgaCA9IEUoe1xuICAgICAgICAgIHg6IGsgPyB0aGlzLnlBeGlzLmxlbiAtIHIgOiBxLFxuICAgICAgICAgIHk6IE1hdGgucm91bmQoayA/IHRoaXMueEF4aXMubGVuIC0gcSA6IHIpLFxuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9LCBoKTtcbiAgICAgICAgRShnLCB7XG4gICAgICAgICAgd2lkdGg6IHUud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB1LmhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgeSA/IChwID0gITEsIHEgPSBlLnJlbmRlcmVyLnJvdENvcnIoeCwgeSksIHEgPSB7XG4gICAgICAgICAgeDogaC54ICsgZy54ICsgaC53aWR0aCAvIDIgKyBxLngsXG4gICAgICAgICAgeTogaC55ICsgZy55ICsge1xuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgbWlkZGxlOiAuNSxcbiAgICAgICAgICAgIGJvdHRvbTogMVxuICAgICAgICAgIH1bZy52ZXJ0aWNhbEFsaWduXSAqIGguaGVpZ2h0XG4gICAgICAgIH0sIEMocSksIGNbZiA/IFwiYXR0clwiIDogXCJhbmltYXRlXCJdKHEpLmF0dHIoe1xuICAgICAgICAgIGFsaWduOiBBXG4gICAgICAgIH0pLCBDID0gKHkgKyA3MjApICUgMzYwLCBDID0gMTgwIDwgQyAmJiAzNjAgPiBDLCBcImxlZnRcIiA9PT0gQSA/IHEueSAtPSBDID8gdS5oZWlnaHQgOiAwIDogXCJjZW50ZXJcIiA9PT0gQSA/IChxLnggLT0gdS53aWR0aCAvIDIsIHEueSAtPSB1LmhlaWdodCAvIDIpIDogXCJyaWdodFwiID09PSBBICYmIChxLnggLT0gdS53aWR0aCwgcS55IC09IEMgPyAwIDogdS5oZWlnaHQpLCBjLnBsYWNlZCA9ICEwLCBjLmFsaWduQXR0ciA9IHEpIDogKEMoaCksIGMuYWxpZ24oZywgbnVsbCwgaCksIHEgPSBjLmFsaWduQXR0cik7XG4gICAgICAgIHAgJiYgMCA8PSBoLmhlaWdodCA/IHRoaXMuanVzdGlmeURhdGFMYWJlbChjLCBnLCBxLCB1LCBoLCBmKSA6IHQoZy5jcm9wLCAhMCkgJiYgKGIgPSBlLmlzSW5zaWRlUGxvdChxLngsIHEueSkgJiYgZS5pc0luc2lkZVBsb3QocS54ICsgdS53aWR0aCwgcS55ICsgdS5oZWlnaHQpKTtcbiAgICAgICAgaWYgKGcuc2hhcGUgJiYgIXkpIGNbZiA/IFwiYXR0clwiIDogXCJhbmltYXRlXCJdKHtcbiAgICAgICAgICBhbmNob3JYOiBrID8gZS5wbG90V2lkdGggLSBkLnBsb3RZIDogZC5wbG90WCxcbiAgICAgICAgICBhbmNob3JZOiBrID8gZS5wbG90SGVpZ2h0IC0gZC5wbG90WCA6IGQucGxvdFlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGYgJiYgbiAmJiAoYy5wbGFjZWQgPSAhMSk7XG4gICAgICBiIHx8IG4gJiYgIXAgfHwgKGMuaGlkZSghMCksIGMucGxhY2VkID0gITEpO1xuICAgIH07XG5cbiAgICBxLnByb3RvdHlwZS5zZXREYXRhTGFiZWxTdGFydFBvcyA9IGZ1bmN0aW9uIChkLCBjLCBnLCBoLCBmKSB7XG4gICAgICB2YXIgYSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgZSA9IGEuaW52ZXJ0ZWQsXG4gICAgICAgICAgayA9IHRoaXMueEF4aXMsXG4gICAgICAgICAgbiA9IGsucmV2ZXJzZWQsXG4gICAgICAgICAgcSA9IGUgPyBjLmhlaWdodCAvIDIgOiBjLndpZHRoIC8gMjtcbiAgICAgIGQgPSAoZCA9IGQucG9pbnRXaWR0aCkgPyBkIC8gMiA6IDA7XG4gICAgICBrID0gZSA/IGYueCA6IG4gPyAtcSAtIGQgOiBrLndpZHRoIC0gcSArIGQ7XG4gICAgICBmID0gZSA/IG4gPyB0aGlzLnlBeGlzLmhlaWdodCAtIHEgKyBkIDogLXEgLSBkIDogZi55O1xuICAgICAgYy5zdGFydFhQb3MgPSBrO1xuICAgICAgYy5zdGFydFlQb3MgPSBmO1xuICAgICAgaCA/IFwiaGlkZGVuXCIgPT09IGMudmlzaWJpbGl0eSAmJiAoYy5zaG93KCksIGMuYXR0cih7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0pLmFuaW1hdGUoe1xuICAgICAgICBvcGFjaXR5OiAxXG4gICAgICB9KSkgOiBjLmF0dHIoe1xuICAgICAgICBvcGFjaXR5OiAxXG4gICAgICB9KS5hbmltYXRlKHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSwgdm9pZCAwLCBjLmhpZGUpO1xuICAgICAgYS5oYXNSZW5kZXJlZCAmJiAoZyAmJiBjLmF0dHIoe1xuICAgICAgICB4OiBjLnN0YXJ0WFBvcyxcbiAgICAgICAgeTogYy5zdGFydFlQb3NcbiAgICAgIH0pLCBjLnBsYWNlZCA9ICEwKTtcbiAgICB9O1xuXG4gICAgcS5wcm90b3R5cGUuanVzdGlmeURhdGFMYWJlbCA9IGZ1bmN0aW9uIChkLCBjLCBnLCBoLCBmLCBhKSB7XG4gICAgICB2YXIgZSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgayA9IGMuYWxpZ24sXG4gICAgICAgICAgbiA9IGMudmVydGljYWxBbGlnbixcbiAgICAgICAgICBxID0gZC5ib3ggPyAwIDogZC5wYWRkaW5nIHx8IDA7XG4gICAgICB2YXIgciA9IGcueCArIHE7XG5cbiAgICAgIGlmICgwID4gcikge1xuICAgICAgICBcInJpZ2h0XCIgPT09IGsgPyAoYy5hbGlnbiA9IFwibGVmdFwiLCBjLmluc2lkZSA9ICEwKSA6IGMueCA9IC1yO1xuICAgICAgICB2YXIgdCA9ICEwO1xuICAgICAgfVxuXG4gICAgICByID0gZy54ICsgaC53aWR0aCAtIHE7XG4gICAgICByID4gZS5wbG90V2lkdGggJiYgKFwibGVmdFwiID09PSBrID8gKGMuYWxpZ24gPSBcInJpZ2h0XCIsIGMuaW5zaWRlID0gITApIDogYy54ID0gZS5wbG90V2lkdGggLSByLCB0ID0gITApO1xuICAgICAgciA9IGcueSArIHE7XG4gICAgICAwID4gciAmJiAoXCJib3R0b21cIiA9PT0gbiA/IChjLnZlcnRpY2FsQWxpZ24gPSBcInRvcFwiLCBjLmluc2lkZSA9ICEwKSA6IGMueSA9IC1yLCB0ID0gITApO1xuICAgICAgciA9IGcueSArIGguaGVpZ2h0IC0gcTtcbiAgICAgIHIgPiBlLnBsb3RIZWlnaHQgJiYgKFwidG9wXCIgPT09IG4gPyAoYy52ZXJ0aWNhbEFsaWduID0gXCJib3R0b21cIiwgYy5pbnNpZGUgPSAhMCkgOiBjLnkgPSBlLnBsb3RIZWlnaHQgLSByLCB0ID0gITApO1xuICAgICAgdCAmJiAoZC5wbGFjZWQgPSAhYSwgZC5hbGlnbihjLCBudWxsLCBmKSk7XG4gICAgICByZXR1cm4gdDtcbiAgICB9O1xuXG4gICAgUC5waWUgJiYgKFAucGllLnByb3RvdHlwZS5kYXRhTGFiZWxQb3NpdGlvbmVycyA9IHtcbiAgICAgIHJhZGlhbERpc3RyaWJ1dGlvblk6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLnRvcCArIGQuZGlzdHJpYnV0ZUJveC5wb3M7XG4gICAgICB9LFxuICAgICAgcmFkaWFsRGlzdHJpYnV0aW9uWDogZnVuY3Rpb24gKGQsIGMsIGcsIGgpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0WChnIDwgYy50b3AgKyAyIHx8IGcgPiBjLmJvdHRvbSAtIDIgPyBoIDogZywgYy5oYWxmLCBjKTtcbiAgICAgIH0sXG4gICAgICBqdXN0aWZ5OiBmdW5jdGlvbiAoZCwgYywgZykge1xuICAgICAgICByZXR1cm4gZ1swXSArIChkLmhhbGYgPyAtMSA6IDEpICogKGMgKyBkLmxhYmVsRGlzdGFuY2UpO1xuICAgICAgfSxcbiAgICAgIGFsaWduVG9QbG90RWRnZXM6IGZ1bmN0aW9uIChkLCBjLCBnLCBoKSB7XG4gICAgICAgIGQgPSBkLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgcmV0dXJuIGMgPyBkICsgaCA6IGcgLSBkIC0gaDtcbiAgICAgIH0sXG4gICAgICBhbGlnblRvQ29ubmVjdG9yczogZnVuY3Rpb24gKGQsIGMsIGcsIGgpIHtcbiAgICAgICAgdmFyIGUgPSAwLFxuICAgICAgICAgICAgYTtcbiAgICAgICAgZC5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgYSA9IGMuZGF0YUxhYmVsLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgICBhID4gZSAmJiAoZSA9IGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGMgPyBlICsgaCA6IGcgLSBlIC0gaDtcbiAgICAgIH1cbiAgICB9LCBQLnBpZS5wcm90b3R5cGUuZHJhd0RhdGFMYWJlbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgYyA9IGUuZGF0YSxcbiAgICAgICAgICBnLFxuICAgICAgICAgIGggPSBlLmNoYXJ0LFxuICAgICAgICAgIGYgPSBlLm9wdGlvbnMuZGF0YUxhYmVscyB8fCB7fSxcbiAgICAgICAgICBhID0gZi5jb25uZWN0b3JQYWRkaW5nLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgdiA9IGgucGxvdFdpZHRoLFxuICAgICAgICAgIHIgPSBoLnBsb3RIZWlnaHQsXG4gICAgICAgICAgdyA9IGgucGxvdExlZnQsXG4gICAgICAgICAgeSA9IE1hdGgucm91bmQoaC5jaGFydFdpZHRoIC8gMyksXG4gICAgICAgICAgQSxcbiAgICAgICAgICBEID0gZS5jZW50ZXIsXG4gICAgICAgICAgSCA9IERbMl0gLyAyLFxuICAgICAgICAgIEsgPSBEWzFdLFxuICAgICAgICAgIHAsXG4gICAgICAgICAgYixcbiAgICAgICAgICBDLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgRyA9IFtbXSwgW11dLFxuICAgICAgICAgIEUsXG4gICAgICAgICAgTixcbiAgICAgICAgICBJLFxuICAgICAgICAgIG0sXG4gICAgICAgICAgUCA9IFswLCAwLCAwLCAwXSxcbiAgICAgICAgICBTID0gZS5kYXRhTGFiZWxQb3NpdGlvbmVycyxcbiAgICAgICAgICBXO1xuICAgICAgZS52aXNpYmxlICYmIChmLmVuYWJsZWQgfHwgZS5faGFzUG9pbnRMYWJlbHMpICYmIChjLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgYS5kYXRhTGFiZWwgJiYgYS52aXNpYmxlICYmIGEuZGF0YUxhYmVsLnNob3J0ZW5lZCAmJiAoYS5kYXRhTGFiZWwuYXR0cih7XG4gICAgICAgICAgd2lkdGg6IFwiYXV0b1wiXG4gICAgICAgIH0pLmNzcyh7XG4gICAgICAgICAgd2lkdGg6IFwiYXV0b1wiLFxuICAgICAgICAgIHRleHRPdmVyZmxvdzogXCJjbGlwXCJcbiAgICAgICAgfSksIGEuZGF0YUxhYmVsLnNob3J0ZW5lZCA9ICExKTtcbiAgICAgIH0pLCBxLnByb3RvdHlwZS5kcmF3RGF0YUxhYmVscy5hcHBseShlKSwgYy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIGEuZGF0YUxhYmVsICYmIChhLnZpc2libGUgPyAoR1thLmhhbGZdLnB1c2goYSksIGEuZGF0YUxhYmVsLl9wb3MgPSBudWxsLCAhTShmLnN0eWxlLndpZHRoKSAmJiAhTShhLm9wdGlvbnMuZGF0YUxhYmVscyAmJiBhLm9wdGlvbnMuZGF0YUxhYmVscy5zdHlsZSAmJiBhLm9wdGlvbnMuZGF0YUxhYmVscy5zdHlsZS53aWR0aCkgJiYgYS5kYXRhTGFiZWwuZ2V0QkJveCgpLndpZHRoID4geSAmJiAoYS5kYXRhTGFiZWwuY3NzKHtcbiAgICAgICAgICB3aWR0aDogLjcgKiB5XG4gICAgICAgIH0pLCBhLmRhdGFMYWJlbC5zaG9ydGVuZWQgPSAhMCkpIDogKGEuZGF0YUxhYmVsID0gYS5kYXRhTGFiZWwuZGVzdHJveSgpLCBhLmRhdGFMYWJlbHMgJiYgMSA9PT0gYS5kYXRhTGFiZWxzLmxlbmd0aCAmJiBkZWxldGUgYS5kYXRhTGFiZWxzKSk7XG4gICAgICB9KSwgRy5mb3JFYWNoKGZ1bmN0aW9uIChjLCBrKSB7XG4gICAgICAgIHZhciBsID0gYy5sZW5ndGgsXG4gICAgICAgICAgICBuID0gW10sXG4gICAgICAgICAgICBxO1xuXG4gICAgICAgIGlmIChsKSB7XG4gICAgICAgICAgZS5zb3J0QnlBbmdsZShjLCBrIC0gLjUpO1xuXG4gICAgICAgICAgaWYgKDAgPCBlLm1heExhYmVsRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHZhciB1ID0gTWF0aC5tYXgoMCwgSyAtIEggLSBlLm1heExhYmVsRGlzdGFuY2UpO1xuICAgICAgICAgICAgdmFyIHogPSBNYXRoLm1pbihLICsgSCArIGUubWF4TGFiZWxEaXN0YW5jZSwgaC5wbG90SGVpZ2h0KTtcbiAgICAgICAgICAgIGMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAwIDwgYS5sYWJlbERpc3RhbmNlICYmIGEuZGF0YUxhYmVsICYmIChhLnRvcCA9IE1hdGgubWF4KDAsIEsgLSBIIC0gYS5sYWJlbERpc3RhbmNlKSwgYS5ib3R0b20gPSBNYXRoLm1pbihLICsgSCArIGEubGFiZWxEaXN0YW5jZSwgaC5wbG90SGVpZ2h0KSwgcSA9IGEuZGF0YUxhYmVsLmdldEJCb3goKS5oZWlnaHQgfHwgMjEsIGEuZGlzdHJpYnV0ZUJveCA9IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGEubGFiZWxQb3NpdGlvbi5uYXR1cmFsLnkgLSBhLnRvcCArIHEgLyAyLFxuICAgICAgICAgICAgICAgIHNpemU6IHEsXG4gICAgICAgICAgICAgICAgcmFuazogYS55XG4gICAgICAgICAgICAgIH0sIG4ucHVzaChhLmRpc3RyaWJ1dGVCb3gpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdSA9IHogKyBxIC0gdTtcbiAgICAgICAgICAgIGQuZGlzdHJpYnV0ZShuLCB1LCB1IC8gNSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChtID0gMDsgbSA8IGw7IG0rKykge1xuICAgICAgICAgICAgZyA9IGNbbV07XG4gICAgICAgICAgICBDID0gZy5sYWJlbFBvc2l0aW9uO1xuICAgICAgICAgICAgcCA9IGcuZGF0YUxhYmVsO1xuICAgICAgICAgICAgSSA9ICExID09PSBnLnZpc2libGUgPyBcImhpZGRlblwiIDogXCJpbmhlcml0XCI7XG4gICAgICAgICAgICBOID0gdSA9IEMubmF0dXJhbC55O1xuICAgICAgICAgICAgbiAmJiBNKGcuZGlzdHJpYnV0ZUJveCkgJiYgKFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBnLmRpc3RyaWJ1dGVCb3gucG9zID8gSSA9IFwiaGlkZGVuXCIgOiAoeCA9IGcuZGlzdHJpYnV0ZUJveC5zaXplLCBOID0gUy5yYWRpYWxEaXN0cmlidXRpb25ZKGcpKSk7XG4gICAgICAgICAgICBkZWxldGUgZy5wb3NpdGlvbkluZGV4O1xuICAgICAgICAgICAgaWYgKGYuanVzdGlmeSkgRSA9IFMuanVzdGlmeShnLCBILCBEKTtlbHNlIHN3aXRjaCAoZi5hbGlnblRvKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJjb25uZWN0b3JzXCI6XG4gICAgICAgICAgICAgICAgRSA9IFMuYWxpZ25Ub0Nvbm5lY3RvcnMoYywgaywgdiwgdyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBcInBsb3RFZGdlc1wiOlxuICAgICAgICAgICAgICAgIEUgPSBTLmFsaWduVG9QbG90RWRnZXMocCwgaywgdiwgdyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBFID0gUy5yYWRpYWxEaXN0cmlidXRpb25YKGUsIGcsIE4sIHUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcC5fYXR0ciA9IHtcbiAgICAgICAgICAgICAgdmlzaWJpbGl0eTogSSxcbiAgICAgICAgICAgICAgYWxpZ246IEMuYWxpZ25tZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgVyA9IGcub3B0aW9ucy5kYXRhTGFiZWxzIHx8IHt9O1xuICAgICAgICAgICAgcC5fcG9zID0ge1xuICAgICAgICAgICAgICB4OiBFICsgdChXLngsIGYueCkgKyAoe1xuICAgICAgICAgICAgICAgIGxlZnQ6IGEsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IC1hXG4gICAgICAgICAgICAgIH1bQy5hbGlnbm1lbnRdIHx8IDApLFxuICAgICAgICAgICAgICB5OiBOICsgdChXLnksIGYueSkgLSAxMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEMuZmluYWwueCA9IEU7XG4gICAgICAgICAgICBDLmZpbmFsLnkgPSBOO1xuICAgICAgICAgICAgdChmLmNyb3AsICEwKSAmJiAoYiA9IHAuZ2V0QkJveCgpLndpZHRoLCB1ID0gbnVsbCwgRSAtIGIgPCBhICYmIDEgPT09IGsgPyAodSA9IE1hdGgucm91bmQoYiAtIEUgKyBhKSwgUFszXSA9IE1hdGgubWF4KHUsIFBbM10pKSA6IEUgKyBiID4gdiAtIGEgJiYgMCA9PT0gayAmJiAodSA9IE1hdGgucm91bmQoRSArIGIgLSB2ICsgYSksIFBbMV0gPSBNYXRoLm1heCh1LCBQWzFdKSksIDAgPiBOIC0geCAvIDIgPyBQWzBdID0gTWF0aC5tYXgoTWF0aC5yb3VuZCgtTiArIHggLyAyKSwgUFswXSkgOiBOICsgeCAvIDIgPiByICYmIChQWzJdID0gTWF0aC5tYXgoTWF0aC5yb3VuZChOICsgeCAvIDIgLSByKSwgUFsyXSkpLCBwLnNpZGVPdmVyZmxvdyA9IHUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksIDAgPT09IHUoUCkgfHwgdGhpcy52ZXJpZnlEYXRhTGFiZWxPdmVyZmxvdyhQKSkgJiYgKHRoaXMucGxhY2VEYXRhTGFiZWxzKCksIHRoaXMucG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgVyA9IEooZiwgYS5vcHRpb25zLmRhdGFMYWJlbHMpO1xuXG4gICAgICAgIGlmIChsID0gdChXLmNvbm5lY3RvcldpZHRoLCAxKSkge1xuICAgICAgICAgIHZhciBiO1xuICAgICAgICAgIEEgPSBhLmNvbm5lY3RvcjtcblxuICAgICAgICAgIGlmICgocCA9IGEuZGF0YUxhYmVsKSAmJiBwLl9wb3MgJiYgYS52aXNpYmxlICYmIDAgPCBhLmxhYmVsRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIEkgPSBwLl9hdHRyLnZpc2liaWxpdHk7XG4gICAgICAgICAgICBpZiAoYiA9ICFBKSBhLmNvbm5lY3RvciA9IEEgPSBoLnJlbmRlcmVyLnBhdGgoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtZGF0YS1sYWJlbC1jb25uZWN0b3IgIGhpZ2hjaGFydHMtY29sb3ItXCIgKyBhLmNvbG9ySW5kZXggKyAoYS5jbGFzc05hbWUgPyBcIiBcIiArIGEuY2xhc3NOYW1lIDogXCJcIikpLmFkZChlLmRhdGFMYWJlbHNHcm91cCksIGguc3R5bGVkTW9kZSB8fCBBLmF0dHIoe1xuICAgICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBsLFxuICAgICAgICAgICAgICBzdHJva2U6IFcuY29ubmVjdG9yQ29sb3IgfHwgYS5jb2xvciB8fCBcIiM2NjY2NjZcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBBW2IgPyBcImF0dHJcIiA6IFwiYW5pbWF0ZVwiXSh7XG4gICAgICAgICAgICAgIGQ6IGEuZ2V0Q29ubmVjdG9yUGF0aCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEEuYXR0cihcInZpc2liaWxpdHlcIiwgSSk7XG4gICAgICAgICAgfSBlbHNlIEEgJiYgKGEuY29ubmVjdG9yID0gQS5kZXN0cm95KCkpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSwgUC5waWUucHJvdG90eXBlLnBsYWNlRGF0YUxhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdmFyIGMgPSBkLmRhdGFMYWJlbCxcbiAgICAgICAgICAgIGU7XG4gICAgICAgIGMgJiYgZC52aXNpYmxlICYmICgoZSA9IGMuX3BvcykgPyAoYy5zaWRlT3ZlcmZsb3cgJiYgKGMuX2F0dHIud2lkdGggPSBNYXRoLm1heChjLmdldEJCb3goKS53aWR0aCAtIGMuc2lkZU92ZXJmbG93LCAwKSwgYy5jc3Moe1xuICAgICAgICAgIHdpZHRoOiBjLl9hdHRyLndpZHRoICsgXCJweFwiLFxuICAgICAgICAgIHRleHRPdmVyZmxvdzogKHRoaXMub3B0aW9ucy5kYXRhTGFiZWxzLnN0eWxlIHx8IHt9KS50ZXh0T3ZlcmZsb3cgfHwgXCJlbGxpcHNpc1wiXG4gICAgICAgIH0pLCBjLnNob3J0ZW5lZCA9ICEwKSwgYy5hdHRyKGMuX2F0dHIpLCBjW2MubW92ZWQgPyBcImFuaW1hdGVcIiA6IFwiYXR0clwiXShlKSwgYy5tb3ZlZCA9ICEwKSA6IGMgJiYgYy5hdHRyKHtcbiAgICAgICAgICB5OiAtOTk5OVxuICAgICAgICB9KSk7XG4gICAgICAgIGRlbGV0ZSBkLmRpc3RyaWJ1dGVCb3g7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LCBQLnBpZS5wcm90b3R5cGUuYWxpZ25EYXRhTGFiZWwgPSBnLCBQLnBpZS5wcm90b3R5cGUudmVyaWZ5RGF0YUxhYmVsT3ZlcmZsb3cgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIGMgPSB0aGlzLmNlbnRlcixcbiAgICAgICAgICBlID0gdGhpcy5vcHRpb25zLFxuICAgICAgICAgIGcgPSBlLmNlbnRlcixcbiAgICAgICAgICBmID0gZS5taW5TaXplIHx8IDgwLFxuICAgICAgICAgIGEgPSBudWxsICE9PSBlLnNpemU7XG5cbiAgICAgIGlmICghYSkge1xuICAgICAgICBpZiAobnVsbCAhPT0gZ1swXSkgdmFyIGggPSBNYXRoLm1heChjWzJdIC0gTWF0aC5tYXgoZFsxXSwgZFszXSksIGYpO2Vsc2UgaCA9IE1hdGgubWF4KGNbMl0gLSBkWzFdIC0gZFszXSwgZiksIGNbMF0gKz0gKGRbM10gLSBkWzFdKSAvIDI7XG4gICAgICAgIG51bGwgIT09IGdbMV0gPyBoID0gSShoLCBmLCBjWzJdIC0gTWF0aC5tYXgoZFswXSwgZFsyXSkpIDogKGggPSBJKGgsIGYsIGNbMl0gLSBkWzBdIC0gZFsyXSksIGNbMV0gKz0gKGRbMF0gLSBkWzJdKSAvIDIpO1xuICAgICAgICBoIDwgY1syXSA/IChjWzJdID0gaCwgY1szXSA9IE1hdGgubWluKEQoZS5pbm5lclNpemUgfHwgMCwgaCksIGgpLCB0aGlzLnRyYW5zbGF0ZShjKSwgdGhpcy5kcmF3RGF0YUxhYmVscyAmJiB0aGlzLmRyYXdEYXRhTGFiZWxzKCkpIDogYSA9ICEwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYTtcbiAgICB9KTtcbiAgICBQLmNvbHVtbiAmJiAoUC5jb2x1bW4ucHJvdG90eXBlLmFsaWduRGF0YUxhYmVsID0gZnVuY3Rpb24gKGQsIGMsIGcsIGgsIGYpIHtcbiAgICAgIHZhciBhID0gdGhpcy5jaGFydC5pbnZlcnRlZCxcbiAgICAgICAgICBlID0gZC5zZXJpZXMsXG4gICAgICAgICAgayA9IGQuZGxCb3ggfHwgZC5zaGFwZUFyZ3MsXG4gICAgICAgICAgbiA9IHQoZC5iZWxvdywgZC5wbG90WSA+IHQodGhpcy50cmFuc2xhdGVkVGhyZXNob2xkLCBlLnlBeGlzLmxlbikpLFxuICAgICAgICAgIHIgPSB0KGcuaW5zaWRlLCAhIXRoaXMub3B0aW9ucy5zdGFja2luZyk7XG4gICAgICBrICYmIChoID0gSihrKSwgMCA+IGgueSAmJiAoaC5oZWlnaHQgKz0gaC55LCBoLnkgPSAwKSwgayA9IGgueSArIGguaGVpZ2h0IC0gZS55QXhpcy5sZW4sIDAgPCBrICYmIGsgPCBoLmhlaWdodCAmJiAoaC5oZWlnaHQgLT0gayksIGEgJiYgKGggPSB7XG4gICAgICAgIHg6IGUueUF4aXMubGVuIC0gaC55IC0gaC5oZWlnaHQsXG4gICAgICAgIHk6IGUueEF4aXMubGVuIC0gaC54IC0gaC53aWR0aCxcbiAgICAgICAgd2lkdGg6IGguaGVpZ2h0LFxuICAgICAgICBoZWlnaHQ6IGgud2lkdGhcbiAgICAgIH0pLCByIHx8IChhID8gKGgueCArPSBuID8gMCA6IGgud2lkdGgsIGgud2lkdGggPSAwKSA6IChoLnkgKz0gbiA/IGguaGVpZ2h0IDogMCwgaC5oZWlnaHQgPSAwKSkpO1xuICAgICAgZy5hbGlnbiA9IHQoZy5hbGlnbiwgIWEgfHwgciA/IFwiY2VudGVyXCIgOiBuID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpO1xuICAgICAgZy52ZXJ0aWNhbEFsaWduID0gdChnLnZlcnRpY2FsQWxpZ24sIGEgfHwgciA/IFwibWlkZGxlXCIgOiBuID8gXCJ0b3BcIiA6IFwiYm90dG9tXCIpO1xuICAgICAgcS5wcm90b3R5cGUuYWxpZ25EYXRhTGFiZWwuY2FsbCh0aGlzLCBkLCBjLCBnLCBoLCBmKTtcbiAgICAgIGcuaW5zaWRlICYmIGQuY29udHJhc3RDb2xvciAmJiBjLmNzcyh7XG4gICAgICAgIGNvbG9yOiBkLmNvbnRyYXN0Q29sb3JcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgUyhyLCBcIm1vZHVsZXMvb3ZlcmxhcHBpbmctZGF0YWxhYmVscy5zcmMuanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvVXRpbGl0aWVzLmpzXCJdXSwgZnVuY3Rpb24gKGQsIGcpIHtcbiAgICB2YXIgciA9IGcuYWRkRXZlbnQsXG4gICAgICAgIHUgPSBnLmZpcmVFdmVudCxcbiAgICAgICAgSSA9IGcuaXNBcnJheSxcbiAgICAgICAgTSA9IGcub2JqZWN0RWFjaCxcbiAgICAgICAgRSA9IGcucGljaztcbiAgICBkID0gZC5DaGFydDtcbiAgICByKGQsIFwicmVuZGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkID0gW107XG4gICAgICAodGhpcy5sYWJlbENvbGxlY3RvcnMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgZCA9IGQuY29uY2F0KGcoKSk7XG4gICAgICB9KTtcbiAgICAgICh0aGlzLnlBeGlzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIGcub3B0aW9ucy5zdGFja0xhYmVscyAmJiAhZy5vcHRpb25zLnN0YWNrTGFiZWxzLmFsbG93T3ZlcmxhcCAmJiBNKGcuc3RhY2tzLCBmdW5jdGlvbiAoZykge1xuICAgICAgICAgIE0oZywgZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgICAgIGQucHVzaChnLmxhYmVsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgICh0aGlzLnNlcmllcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoZykge1xuICAgICAgICB2YXIgciA9IGcub3B0aW9ucy5kYXRhTGFiZWxzO1xuICAgICAgICBnLnZpc2libGUgJiYgKCExICE9PSByLmVuYWJsZWQgfHwgZy5faGFzUG9pbnRMYWJlbHMpICYmIChnLm5vZGVzIHx8IGcucG9pbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7XG4gICAgICAgICAgZy52aXNpYmxlICYmIChJKGcuZGF0YUxhYmVscykgPyBnLmRhdGFMYWJlbHMgOiBnLmRhdGFMYWJlbCA/IFtnLmRhdGFMYWJlbF0gOiBbXSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgdmFyIHQgPSByLm9wdGlvbnM7XG4gICAgICAgICAgICByLmxhYmVscmFuayA9IEUodC5sYWJlbHJhbmssIGcubGFiZWxyYW5rLCBnLnNoYXBlQXJncyAmJiBnLnNoYXBlQXJncy5oZWlnaHQpO1xuICAgICAgICAgICAgdC5hbGxvd092ZXJsYXAgfHwgZC5wdXNoKHIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oaWRlT3ZlcmxhcHBpbmdMYWJlbHMoZCk7XG4gICAgfSk7XG5cbiAgICBkLnByb3RvdHlwZS5oaWRlT3ZlcmxhcHBpbmdMYWJlbHMgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIGcgPSB0aGlzLFxuICAgICAgICAgIHIgPSBkLmxlbmd0aCxcbiAgICAgICAgICB5ID0gZy5yZW5kZXJlcixcbiAgICAgICAgICB0LFxuICAgICAgICAgIEEsXG4gICAgICAgICAgaCxcbiAgICAgICAgICBFID0gITE7XG5cbiAgICAgIHZhciBxID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGQgPSBjLmJveCA/IDAgOiBjLnBhZGRpbmcgfHwgMDtcbiAgICAgICAgdmFyIGUgPSAwO1xuXG4gICAgICAgIGlmIChjICYmICghYy5hbGlnbkF0dHIgfHwgYy5wbGFjZWQpKSB7XG4gICAgICAgICAgdmFyIGYgPSBjLmFsaWduQXR0ciB8fCB7XG4gICAgICAgICAgICB4OiBjLmF0dHIoXCJ4XCIpLFxuICAgICAgICAgICAgeTogYy5hdHRyKFwieVwiKVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGEgPSBjLnBhcmVudEdyb3VwO1xuICAgICAgICAgIGMud2lkdGggfHwgKGUgPSBjLmdldEJCb3goKSwgYy53aWR0aCA9IGUud2lkdGgsIGMuaGVpZ2h0ID0gZS5oZWlnaHQsIGUgPSB5LmZvbnRNZXRyaWNzKG51bGwsIGMuZWxlbWVudCkuaCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGYueCArIChhLnRyYW5zbGF0ZVggfHwgMCkgKyBkLFxuICAgICAgICAgICAgeTogZi55ICsgKGEudHJhbnNsYXRlWSB8fCAwKSArIGQgLSBlLFxuICAgICAgICAgICAgd2lkdGg6IGMud2lkdGggLSAyICogZCxcbiAgICAgICAgICAgIGhlaWdodDogYy5oZWlnaHQgLSAyICogZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAoQSA9IDA7IEEgPCByOyBBKyspIGlmICh0ID0gZFtBXSkgdC5vbGRPcGFjaXR5ID0gdC5vcGFjaXR5LCB0Lm5ld09wYWNpdHkgPSAxLCB0LmFic29sdXRlQm94ID0gcSh0KTtcblxuICAgICAgZC5zb3J0KGZ1bmN0aW9uIChjLCBkKSB7XG4gICAgICAgIHJldHVybiAoZC5sYWJlbHJhbmsgfHwgMCkgLSAoYy5sYWJlbHJhbmsgfHwgMCk7XG4gICAgICB9KTtcblxuICAgICAgZm9yIChBID0gMDsgQSA8IHI7IEErKykge1xuICAgICAgICB2YXIgSSA9IChxID0gZFtBXSkgJiYgcS5hYnNvbHV0ZUJveDtcblxuICAgICAgICBmb3IgKHQgPSBBICsgMTsgdCA8IHI7ICsrdCkge1xuICAgICAgICAgIHZhciBlID0gKGggPSBkW3RdKSAmJiBoLmFic29sdXRlQm94O1xuICAgICAgICAgICFJIHx8ICFlIHx8IHEgPT09IGggfHwgMCA9PT0gcS5uZXdPcGFjaXR5IHx8IDAgPT09IGgubmV3T3BhY2l0eSB8fCBlLnggPiBJLnggKyBJLndpZHRoIHx8IGUueCArIGUud2lkdGggPCBJLnggfHwgZS55ID4gSS55ICsgSS5oZWlnaHQgfHwgZS55ICsgZS5oZWlnaHQgPCBJLnkgfHwgKChxLmxhYmVscmFuayA8IGgubGFiZWxyYW5rID8gcSA6IGgpLm5ld09wYWNpdHkgPSAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGQ7XG5cbiAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICB2YXIgZSA9IGMubmV3T3BhY2l0eTtcbiAgICAgICAgICBjLm9sZE9wYWNpdHkgIT09IGUgJiYgKGMuYWxpZ25BdHRyICYmIGMucGxhY2VkID8gKGUgPyBjLnNob3coITApIDogZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGMuaGlkZSghMCk7XG4gICAgICAgICAgICBjLnBsYWNlZCA9ICExO1xuICAgICAgICAgIH0sIEUgPSAhMCwgYy5hbGlnbkF0dHIub3BhY2l0eSA9IGUsIGNbYy5pc09sZCA/IFwiYW5pbWF0ZVwiIDogXCJhdHRyXCJdKGMuYWxpZ25BdHRyLCBudWxsLCBkKSwgdShnLCBcImFmdGVySGlkZU92ZXJsYXBwaW5nTGFiZWxcIikpIDogYy5hdHRyKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IGVcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgYy5pc09sZCA9ICEwO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIEUgJiYgdShnLCBcImFmdGVySGlkZUFsbE92ZXJsYXBwaW5nTGFiZWxzXCIpO1xuICAgIH07XG4gIH0pO1xuICBTKHIsIFwicGFydHMvSW50ZXJhY3Rpb24uanNcIiwgW3JbXCJwYXJ0cy9HbG9iYWxzLmpzXCJdLCByW1wicGFydHMvTGVnZW5kLmpzXCJdLCByW1wicGFydHMvUG9pbnQuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZywgciwgdSkge1xuICAgIHZhciBJID0gdS5hZGRFdmVudCxcbiAgICAgICAgTSA9IHUuY3JlYXRlRWxlbWVudCxcbiAgICAgICAgRSA9IHUuY3NzLFxuICAgICAgICBBID0gdS5kZWZpbmVkLFxuICAgICAgICBHID0gdS5leHRlbmQsXG4gICAgICAgIEogPSB1LmZpcmVFdmVudCxcbiAgICAgICAgeSA9IHUuaXNBcnJheSxcbiAgICAgICAgdCA9IHUuaXNGdW5jdGlvbixcbiAgICAgICAgRCA9IHUuaXNPYmplY3QsXG4gICAgICAgIGggPSB1Lm1lcmdlLFxuICAgICAgICBOID0gdS5vYmplY3RFYWNoLFxuICAgICAgICBxID0gdS5waWNrO1xuICAgIHUgPSBkLkNoYXJ0O1xuICAgIHZhciBQID0gZC5kZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgZSA9IGQuZGVmYXVsdFBsb3RPcHRpb25zLFxuICAgICAgICBjID0gZC5oYXNUb3VjaCxcbiAgICAgICAgayA9IGQuU2VyaWVzLFxuICAgICAgICBuID0gZC5zZXJpZXNUeXBlcyxcbiAgICAgICAgZiA9IGQuc3ZnO1xuICAgIGQgPSBkLlRyYWNrZXJNaXhpbiA9IHtcbiAgICAgIGRyYXdUcmFja2VyUG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgZCA9IGEuY2hhcnQsXG4gICAgICAgICAgICBlID0gZC5wb2ludGVyLFxuICAgICAgICAgICAgZiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgdmFyIGMgPSBlLmdldFBvaW50RnJvbUV2ZW50KGEpO1xuICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBjICYmIChlLmlzRGlyZWN0VG91Y2ggPSAhMCwgYy5vbk1vdXNlT3ZlcihhKSk7XG4gICAgICAgIH0sXG4gICAgICAgICAgICBnO1xuXG4gICAgICAgIGEucG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBnID0geShhLmRhdGFMYWJlbHMpID8gYS5kYXRhTGFiZWxzIDogYS5kYXRhTGFiZWwgPyBbYS5kYXRhTGFiZWxdIDogW107XG4gICAgICAgICAgYS5ncmFwaGljICYmIChhLmdyYXBoaWMuZWxlbWVudC5wb2ludCA9IGEpO1xuICAgICAgICAgIGcuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgYy5kaXYgPyBjLmRpdi5wb2ludCA9IGEgOiBjLmVsZW1lbnQucG9pbnQgPSBhO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYS5faGFzVHJhY2tpbmcgfHwgKGEudHJhY2tlckdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChnKSB7XG4gICAgICAgICAgaWYgKGFbZ10pIHtcbiAgICAgICAgICAgIGFbZ10uYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikub24oXCJtb3VzZW92ZXJcIiwgZikub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICBlLm9uVHJhY2tlck1vdXNlT3V0KGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYykgYVtnXS5vbihcInRvdWNoc3RhcnRcIiwgZik7XG4gICAgICAgICAgICAhZC5zdHlsZWRNb2RlICYmIGEub3B0aW9ucy5jdXJzb3IgJiYgYVtnXS5jc3MoRSkuY3NzKHtcbiAgICAgICAgICAgICAgY3Vyc29yOiBhLm9wdGlvbnMuY3Vyc29yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBhLl9oYXNUcmFja2luZyA9ICEwKTtcbiAgICAgICAgSih0aGlzLCBcImFmdGVyRHJhd1RyYWNrZXJcIik7XG4gICAgICB9LFxuICAgICAgZHJhd1RyYWNrZXJHcmFwaDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMsXG4gICAgICAgICAgICBkID0gYS5vcHRpb25zLFxuICAgICAgICAgICAgZSA9IGQudHJhY2tCeUFyZWEsXG4gICAgICAgICAgICBnID0gW10uY29uY2F0KGUgPyBhLmFyZWFQYXRoIDogYS5ncmFwaFBhdGgpLFxuICAgICAgICAgICAgaCA9IGcubGVuZ3RoLFxuICAgICAgICAgICAgayA9IGEuY2hhcnQsXG4gICAgICAgICAgICBuID0gay5wb2ludGVyLFxuICAgICAgICAgICAgcSA9IGsucmVuZGVyZXIsXG4gICAgICAgICAgICByID0gay5vcHRpb25zLnRvb2x0aXAuc25hcCxcbiAgICAgICAgICAgIHQgPSBhLnRyYWNrZXIsXG4gICAgICAgICAgICBwLFxuICAgICAgICAgICAgYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoay5ob3ZlclNlcmllcyAhPT0gYSkgYS5vbk1vdXNlT3ZlcigpO1xuICAgICAgICB9LFxuICAgICAgICAgICAgdSA9IFwicmdiYSgxOTIsMTkyLDE5MixcIiArIChmID8gLjAwMDEgOiAuMDAyKSArIFwiKVwiO1xuXG4gICAgICAgIGlmIChoICYmICFlKSBmb3IgKHAgPSBoICsgMTsgcC0tOykgXCJNXCIgPT09IGdbcF0gJiYgZy5zcGxpY2UocCArIDEsIDAsIGdbcCArIDFdIC0gciwgZ1twICsgMl0sIFwiTFwiKSwgKHAgJiYgXCJNXCIgPT09IGdbcF0gfHwgcCA9PT0gaCkgJiYgZy5zcGxpY2UocCwgMCwgXCJMXCIsIGdbcCAtIDJdICsgciwgZ1twIC0gMV0pO1xuICAgICAgICB0ID8gdC5hdHRyKHtcbiAgICAgICAgICBkOiBnXG4gICAgICAgIH0pIDogYS5ncmFwaCAmJiAoYS50cmFja2VyID0gcS5wYXRoKGcpLmF0dHIoe1xuICAgICAgICAgIHZpc2liaWxpdHk6IGEudmlzaWJsZSA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIixcbiAgICAgICAgICB6SW5kZXg6IDJcbiAgICAgICAgfSkuYWRkQ2xhc3MoZSA/IFwiaGlnaGNoYXJ0cy10cmFja2VyLWFyZWFcIiA6IFwiaGlnaGNoYXJ0cy10cmFja2VyLWxpbmVcIikuYWRkKGEuZ3JvdXApLCBrLnN0eWxlZE1vZGUgfHwgYS50cmFja2VyLmF0dHIoe1xuICAgICAgICAgIFwic3Ryb2tlLWxpbmVqb2luXCI6IFwicm91bmRcIixcbiAgICAgICAgICBzdHJva2U6IHUsXG4gICAgICAgICAgZmlsbDogZSA/IHUgOiBcIm5vbmVcIixcbiAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiBhLmdyYXBoLnN0cm9rZVdpZHRoKCkgKyAoZSA/IDAgOiAyICogcilcbiAgICAgICAgfSksIFthLnRyYWNrZXIsIGEubWFya2VyR3JvdXBdLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy10cmFja2VyXCIpLm9uKFwibW91c2VvdmVyXCIsIGIpLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIG4ub25UcmFja2VyTW91c2VPdXQoYSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZC5jdXJzb3IgJiYgIWsuc3R5bGVkTW9kZSAmJiBhLmNzcyh7XG4gICAgICAgICAgICBjdXJzb3I6IGQuY3Vyc29yXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGMpIGEub24oXCJ0b3VjaHN0YXJ0XCIsIGIpO1xuICAgICAgICB9KSk7XG4gICAgICAgIEoodGhpcywgXCJhZnRlckRyYXdUcmFja2VyXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgbi5jb2x1bW4gJiYgKG4uY29sdW1uLnByb3RvdHlwZS5kcmF3VHJhY2tlciA9IGQuZHJhd1RyYWNrZXJQb2ludCk7XG4gICAgbi5waWUgJiYgKG4ucGllLnByb3RvdHlwZS5kcmF3VHJhY2tlciA9IGQuZHJhd1RyYWNrZXJQb2ludCk7XG4gICAgbi5zY2F0dGVyICYmIChuLnNjYXR0ZXIucHJvdG90eXBlLmRyYXdUcmFja2VyID0gZC5kcmF3VHJhY2tlclBvaW50KTtcbiAgICBHKGcucHJvdG90eXBlLCB7XG4gICAgICBzZXRJdGVtRXZlbnRzOiBmdW5jdGlvbiAoYSwgYywgZCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgICBmID0gZS5jaGFydC5yZW5kZXJlci5ib3hXcmFwcGVyLFxuICAgICAgICAgICAgZyA9IGEgaW5zdGFuY2VvZiByLFxuICAgICAgICAgICAgayA9IFwiaGlnaGNoYXJ0cy1sZWdlbmQtXCIgKyAoZyA/IFwicG9pbnRcIiA6IFwic2VyaWVzXCIpICsgXCItYWN0aXZlXCIsXG4gICAgICAgICAgICBsID0gZS5jaGFydC5zdHlsZWRNb2RlO1xuICAgICAgICAoZCA/IFtjLCBhLmxlZ2VuZFN5bWJvbF0gOiBbYS5sZWdlbmRHcm91cF0pLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBpZiAoZCkgZC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhLnZpc2libGUgJiYgZS5hbGxJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgIGEgIT09IGMgJiYgYy5zZXRTdGF0ZShcImluYWN0aXZlXCIsICFnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYS5zZXRTdGF0ZShcImhvdmVyXCIpO1xuICAgICAgICAgICAgYS52aXNpYmxlICYmIGYuYWRkQ2xhc3Moayk7XG4gICAgICAgICAgICBsIHx8IGMuY3NzKGUub3B0aW9ucy5pdGVtSG92ZXJTdHlsZSk7XG4gICAgICAgICAgfSkub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlLmNoYXJ0LnN0eWxlZE1vZGUgfHwgYy5jc3MoaChhLnZpc2libGUgPyBlLml0ZW1TdHlsZSA6IGUuaXRlbUhpZGRlblN0eWxlKSk7XG4gICAgICAgICAgICBlLmFsbEl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgYSAhPT0gYyAmJiBjLnNldFN0YXRlKFwiXCIsICFnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZi5yZW1vdmVDbGFzcyhrKTtcbiAgICAgICAgICAgIGEuc2V0U3RhdGUoKTtcbiAgICAgICAgICB9KS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICB2YXIgZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgYS5zZXRWaXNpYmxlICYmIGEuc2V0VmlzaWJsZSgpO1xuICAgICAgICAgICAgICBlLmFsbEl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgICBhICE9PSBiICYmIGIuc2V0U3RhdGUoYS52aXNpYmxlID8gXCJpbmFjdGl2ZVwiIDogXCJcIiwgIWcpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGYucmVtb3ZlQ2xhc3Moayk7XG4gICAgICAgICAgICBjID0ge1xuICAgICAgICAgICAgICBicm93c2VyRXZlbnQ6IGNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhLmZpcmVQb2ludEV2ZW50ID8gYS5maXJlUG9pbnRFdmVudChcImxlZ2VuZEl0ZW1DbGlja1wiLCBjLCBkKSA6IEooYSwgXCJsZWdlbmRJdGVtQ2xpY2tcIiwgYywgZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZUNoZWNrYm94Rm9ySXRlbTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgYS5jaGVja2JveCA9IE0oXCJpbnB1dFwiLCB7XG4gICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgIGNsYXNzTmFtZTogXCJoaWdoY2hhcnRzLWxlZ2VuZC1jaGVja2JveFwiLFxuICAgICAgICAgIGNoZWNrZWQ6IGEuc2VsZWN0ZWQsXG4gICAgICAgICAgZGVmYXVsdENoZWNrZWQ6IGEuc2VsZWN0ZWRcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLml0ZW1DaGVja2JveFN0eWxlLCB0aGlzLmNoYXJ0LmNvbnRhaW5lcik7XG4gICAgICAgIEkoYS5jaGVja2JveCwgXCJjbGlja1wiLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIEooYS5zZXJpZXMgfHwgYSwgXCJjaGVja2JveENsaWNrXCIsIHtcbiAgICAgICAgICAgIGNoZWNrZWQ6IGMudGFyZ2V0LmNoZWNrZWQsXG4gICAgICAgICAgICBpdGVtOiBhXG4gICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYS5zZWxlY3QoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgRyh1LnByb3RvdHlwZSwge1xuICAgICAgc2hvd1Jlc2V0Wm9vbTogZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBhKCkge1xuICAgICAgICAgIGMuem9vbU91dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSB0aGlzLFxuICAgICAgICAgICAgZCA9IFAubGFuZyxcbiAgICAgICAgICAgIGUgPSBjLm9wdGlvbnMuY2hhcnQucmVzZXRab29tQnV0dG9uLFxuICAgICAgICAgICAgZiA9IGUudGhlbWUsXG4gICAgICAgICAgICBnID0gZi5zdGF0ZXMsXG4gICAgICAgICAgICBoID0gXCJjaGFydFwiID09PSBlLnJlbGF0aXZlVG8gfHwgXCJzcGFjZUJveFwiID09PSBlLnJlbGF0aXZlVG8gPyBudWxsIDogXCJwbG90Qm94XCI7XG4gICAgICAgIEoodGhpcywgXCJiZWZvcmVTaG93UmVzZXRab29tXCIsIG51bGwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjLnJlc2V0Wm9vbUJ1dHRvbiA9IGMucmVuZGVyZXIuYnV0dG9uKGQucmVzZXRab29tLCBudWxsLCBudWxsLCBhLCBmLCBnICYmIGcuaG92ZXIpLmF0dHIoe1xuICAgICAgICAgICAgYWxpZ246IGUucG9zaXRpb24uYWxpZ24sXG4gICAgICAgICAgICB0aXRsZTogZC5yZXNldFpvb21UaXRsZVxuICAgICAgICAgIH0pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1yZXNldC16b29tXCIpLmFkZCgpLmFsaWduKGUucG9zaXRpb24sICExLCBoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIEoodGhpcywgXCJhZnRlclNob3dSZXNldFpvb21cIik7XG4gICAgICB9LFxuICAgICAgem9vbU91dDogZnVuY3Rpb24gKCkge1xuICAgICAgICBKKHRoaXMsIFwic2VsZWN0aW9uXCIsIHtcbiAgICAgICAgICByZXNldFNlbGVjdGlvbjogITBcbiAgICAgICAgfSwgdGhpcy56b29tKTtcbiAgICAgIH0sXG4gICAgICB6b29tOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYyA9IHRoaXMsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgZSA9IGMucG9pbnRlcixcbiAgICAgICAgICAgIGYgPSAhMSxcbiAgICAgICAgICAgIGcgPSBjLmludmVydGVkID8gZS5tb3VzZURvd25YIDogZS5tb3VzZURvd25ZO1xuICAgICAgICAhYSB8fCBhLnJlc2V0U2VsZWN0aW9uID8gKGMuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgZCA9IGEuem9vbSgpO1xuICAgICAgICB9KSwgZS5pbml0aWF0ZWQgPSAhMSkgOiBhLnhBeGlzLmNvbmNhdChhLnlBeGlzKS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgdmFyIGggPSBhLmF4aXMsXG4gICAgICAgICAgICAgIGsgPSBjLmludmVydGVkID8gaC5sZWZ0IDogaC50b3AsXG4gICAgICAgICAgICAgIGwgPSBjLmludmVydGVkID8gayArIGgud2lkdGggOiBrICsgaC5oZWlnaHQsXG4gICAgICAgICAgICAgIGIgPSBoLmlzWEF4aXMsXG4gICAgICAgICAgICAgIG4gPSAhMTtcbiAgICAgICAgICBpZiAoIWIgJiYgZyA+PSBrICYmIGcgPD0gbCB8fCBiIHx8ICFBKGcpKSBuID0gITA7XG4gICAgICAgICAgZVtiID8gXCJ6b29tWFwiIDogXCJ6b29tWVwiXSAmJiBuICYmIChkID0gaC56b29tKGEubWluLCBhLm1heCksIGguZGlzcGxheUJ0biAmJiAoZiA9ICEwKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaCA9IGMucmVzZXRab29tQnV0dG9uO1xuICAgICAgICBmICYmICFoID8gYy5zaG93UmVzZXRab29tKCkgOiAhZiAmJiBEKGgpICYmIChjLnJlc2V0Wm9vbUJ1dHRvbiA9IGguZGVzdHJveSgpKTtcbiAgICAgICAgZCAmJiBjLnJlZHJhdyhxKGMub3B0aW9ucy5jaGFydC5hbmltYXRpb24sIGEgJiYgYS5hbmltYXRpb24sIDEwMCA+IGMucG9pbnRDb3VudCkpO1xuICAgICAgfSxcbiAgICAgIHBhbjogZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgICAgZSA9IGQuaG92ZXJQb2ludHMsXG4gICAgICAgICAgICBmID0gZC5vcHRpb25zLmNoYXJ0LFxuICAgICAgICAgICAgZztcbiAgICAgICAgYyA9IFwib2JqZWN0XCIgPT09IHR5cGVvZiBjID8gYyA6IHtcbiAgICAgICAgICBlbmFibGVkOiBjLFxuICAgICAgICAgIHR5cGU6IFwieFwiXG4gICAgICAgIH07XG4gICAgICAgIGYgJiYgZi5wYW5uaW5nICYmIChmLnBhbm5pbmcgPSBjKTtcbiAgICAgICAgdmFyIGggPSBjLnR5cGU7XG4gICAgICAgIEoodGhpcywgXCJwYW5cIiwge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGFcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGUgJiYgZS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBhLnNldFN0YXRlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGMgPSBbMV07XG4gICAgICAgICAgXCJ4eVwiID09PSBoID8gYyA9IFsxLCAwXSA6IFwieVwiID09PSBoICYmIChjID0gWzBdKTtcbiAgICAgICAgICBjLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHZhciBlID0gZFtjID8gXCJ4QXhpc1wiIDogXCJ5QXhpc1wiXVswXSxcbiAgICAgICAgICAgICAgICBmID0gZS5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGIgPSBlLmhvcml6LFxuICAgICAgICAgICAgICAgIGggPSBhW2IgPyBcImNoYXJ0WFwiIDogXCJjaGFydFlcIl07XG4gICAgICAgICAgICBiID0gYiA/IFwibW91c2VEb3duWFwiIDogXCJtb3VzZURvd25ZXCI7XG4gICAgICAgICAgICB2YXIgayA9IGRbYl0sXG4gICAgICAgICAgICAgICAgbCA9IChlLnBvaW50UmFuZ2UgfHwgMCkgLyAyLFxuICAgICAgICAgICAgICAgIG4gPSBlLnJldmVyc2VkICYmICFkLmludmVydGVkIHx8ICFlLnJldmVyc2VkICYmIGQuaW52ZXJ0ZWQgPyAtMSA6IDEsXG4gICAgICAgICAgICAgICAgcSA9IGUuZ2V0RXh0cmVtZXMoKSxcbiAgICAgICAgICAgICAgICB2ID0gZS50b1ZhbHVlKGsgLSBoLCAhMCkgKyBsICogbjtcbiAgICAgICAgICAgIG4gPSBlLnRvVmFsdWUoayArIGUubGVuIC0gaCwgITApIC0gbCAqIG47XG4gICAgICAgICAgICB2YXIgbSA9IG4gPCB2O1xuICAgICAgICAgICAgayA9IG0gPyBuIDogdjtcbiAgICAgICAgICAgIHYgPSBtID8gdiA6IG47XG4gICAgICAgICAgICBuID0gTWF0aC5taW4ocS5kYXRhTWluLCBsID8gcS5taW4gOiBlLnRvVmFsdWUoZS50b1BpeGVscyhxLm1pbikgLSBlLm1pblBpeGVsUGFkZGluZykpO1xuICAgICAgICAgICAgbCA9IE1hdGgubWF4KHEuZGF0YU1heCwgbCA/IHEubWF4IDogZS50b1ZhbHVlKGUudG9QaXhlbHMocS5tYXgpICsgZS5taW5QaXhlbFBhZGRpbmcpKTtcblxuICAgICAgICAgICAgaWYgKCFmLm9yZGluYWwpIHtcbiAgICAgICAgICAgICAgYyAmJiAoZiA9IG4gLSBrLCAwIDwgZiAmJiAodiArPSBmLCBrID0gbiksIGYgPSB2IC0gbCwgMCA8IGYgJiYgKHYgPSBsLCBrIC09IGYpKTtcbiAgICAgICAgICAgICAgaWYgKGUuc2VyaWVzLmxlbmd0aCAmJiBrICE9PSBxLm1pbiAmJiB2ICE9PSBxLm1heCAmJiBjIHx8IGUucGFubmluZ1N0YXRlICYmIGsgPj0gZS5wYW5uaW5nU3RhdGUuc3RhcnRNaW4gJiYgdiA8PSBlLnBhbm5pbmdTdGF0ZS5zdGFydE1heCkgZS5zZXRFeHRyZW1lcyhrLCB2LCAhMSwgITEsIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiBcInBhblwiXG4gICAgICAgICAgICAgIH0pLCBnID0gITA7XG4gICAgICAgICAgICAgIGRbYl0gPSBoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGcgJiYgZC5yZWRyYXcoITEpO1xuICAgICAgICAgIEUoZC5jb250YWluZXIsIHtcbiAgICAgICAgICAgIGN1cnNvcjogXCJtb3ZlXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgRyhyLnByb3RvdHlwZSwge1xuICAgICAgc2VsZWN0OiBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICB2YXIgZCA9IHRoaXMsXG4gICAgICAgICAgICBlID0gZC5zZXJpZXMsXG4gICAgICAgICAgICBmID0gZS5jaGFydDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZFN0YWdpbmcgPSBhID0gcShhLCAhZC5zZWxlY3RlZCk7XG4gICAgICAgIGQuZmlyZVBvaW50RXZlbnQoYSA/IFwic2VsZWN0XCIgOiBcInVuc2VsZWN0XCIsIHtcbiAgICAgICAgICBhY2N1bXVsYXRlOiBjXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkLnNlbGVjdGVkID0gZC5vcHRpb25zLnNlbGVjdGVkID0gYTtcbiAgICAgICAgICBlLm9wdGlvbnMuZGF0YVtlLmRhdGEuaW5kZXhPZihkKV0gPSBkLm9wdGlvbnM7XG4gICAgICAgICAgZC5zZXRTdGF0ZShhICYmIFwic2VsZWN0XCIpO1xuICAgICAgICAgIGMgfHwgZi5nZXRTZWxlY3RlZFBvaW50cygpLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHZhciBjID0gYS5zZXJpZXM7XG4gICAgICAgICAgICBhLnNlbGVjdGVkICYmIGEgIT09IGQgJiYgKGEuc2VsZWN0ZWQgPSBhLm9wdGlvbnMuc2VsZWN0ZWQgPSAhMSwgYy5vcHRpb25zLmRhdGFbYy5kYXRhLmluZGV4T2YoYSldID0gYS5vcHRpb25zLCBhLnNldFN0YXRlKGYuaG92ZXJQb2ludHMgJiYgYy5vcHRpb25zLmluYWN0aXZlT3RoZXJQb2ludHMgPyBcImluYWN0aXZlXCIgOiBcIlwiKSwgYS5maXJlUG9pbnRFdmVudChcInVuc2VsZWN0XCIpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNlbGVjdGVkU3RhZ2luZztcbiAgICAgIH0sXG4gICAgICBvbk1vdXNlT3ZlcjogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLnNlcmllcy5jaGFydCxcbiAgICAgICAgICAgIGQgPSBjLnBvaW50ZXI7XG4gICAgICAgIGEgPSBhID8gZC5ub3JtYWxpemUoYSkgOiBkLmdldENoYXJ0Q29vcmRpbmF0ZXNGcm9tUG9pbnQodGhpcywgYy5pbnZlcnRlZCk7XG4gICAgICAgIGQucnVuUG9pbnRBY3Rpb25zKGEsIHRoaXMpO1xuICAgICAgfSxcbiAgICAgIG9uTW91c2VPdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLnNlcmllcy5jaGFydDtcbiAgICAgICAgdGhpcy5maXJlUG9pbnRFdmVudChcIm1vdXNlT3V0XCIpO1xuICAgICAgICB0aGlzLnNlcmllcy5vcHRpb25zLmluYWN0aXZlT3RoZXJQb2ludHMgfHwgKGEuaG92ZXJQb2ludHMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhLnNldFN0YXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBhLmhvdmVyUG9pbnRzID0gYS5ob3ZlclBvaW50ID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBpbXBvcnRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ltcG9ydGVkRXZlbnRzKSB7XG4gICAgICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgICAgICBjID0gaChhLnNlcmllcy5vcHRpb25zLnBvaW50LCBhLm9wdGlvbnMpLmV2ZW50cztcbiAgICAgICAgICBhLmV2ZW50cyA9IGM7XG4gICAgICAgICAgTihjLCBmdW5jdGlvbiAoYywgZCkge1xuICAgICAgICAgICAgdChjKSAmJiBJKGEsIGQsIGMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuaGFzSW1wb3J0ZWRFdmVudHMgPSAhMDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldFN0YXRlOiBmdW5jdGlvbiAoYSwgYykge1xuICAgICAgICB2YXIgZCA9IHRoaXMuc2VyaWVzLFxuICAgICAgICAgICAgZiA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICBnID0gZC5vcHRpb25zLnN0YXRlc1thIHx8IFwibm9ybWFsXCJdIHx8IHt9LFxuICAgICAgICAgICAgaCA9IGVbZC50eXBlXS5tYXJrZXIgJiYgZC5vcHRpb25zLm1hcmtlcixcbiAgICAgICAgICAgIGsgPSBoICYmICExID09PSBoLmVuYWJsZWQsXG4gICAgICAgICAgICBsID0gaCAmJiBoLnN0YXRlcyAmJiBoLnN0YXRlc1thIHx8IFwibm9ybWFsXCJdIHx8IHt9LFxuICAgICAgICAgICAgbiA9ICExID09PSBsLmVuYWJsZWQsXG4gICAgICAgICAgICByID0gZC5zdGF0ZU1hcmtlckdyYXBoaWMsXG4gICAgICAgICAgICBwID0gdGhpcy5tYXJrZXIgfHwge30sXG4gICAgICAgICAgICBiID0gZC5jaGFydCxcbiAgICAgICAgICAgIHQgPSBkLmhhbG8sXG4gICAgICAgICAgICB1LFxuICAgICAgICAgICAgeSA9IGggJiYgZC5tYXJrZXJBdHRyaWJzO1xuICAgICAgICBhID0gYSB8fCBcIlwiO1xuXG4gICAgICAgIGlmICghKGEgPT09IHRoaXMuc3RhdGUgJiYgIWMgfHwgdGhpcy5zZWxlY3RlZCAmJiBcInNlbGVjdFwiICE9PSBhIHx8ICExID09PSBnLmVuYWJsZWQgfHwgYSAmJiAobiB8fCBrICYmICExID09PSBsLmVuYWJsZWQpIHx8IGEgJiYgcC5zdGF0ZXMgJiYgcC5zdGF0ZXNbYV0gJiYgITEgPT09IHAuc3RhdGVzW2FdLmVuYWJsZWQpKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IGE7XG4gICAgICAgICAgeSAmJiAodSA9IGQubWFya2VyQXR0cmlicyh0aGlzLCBhKSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5ncmFwaGljKSB7XG4gICAgICAgICAgICBmICYmIHRoaXMuZ3JhcGhpYy5yZW1vdmVDbGFzcyhcImhpZ2hjaGFydHMtcG9pbnQtXCIgKyBmKTtcbiAgICAgICAgICAgIGEgJiYgdGhpcy5ncmFwaGljLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1wb2ludC1cIiArIGEpO1xuXG4gICAgICAgICAgICBpZiAoIWIuc3R5bGVkTW9kZSkge1xuICAgICAgICAgICAgICB2YXIgQSA9IGQucG9pbnRBdHRyaWJzKHRoaXMsIGEpO1xuICAgICAgICAgICAgICB2YXIgRCA9IHEoYi5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbiwgZy5hbmltYXRpb24pO1xuICAgICAgICAgICAgICBkLm9wdGlvbnMuaW5hY3RpdmVPdGhlclBvaW50cyAmJiAoKHRoaXMuZGF0YUxhYmVscyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIGEgJiYgYS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IEEub3BhY2l0eVxuICAgICAgICAgICAgICAgIH0sIEQpO1xuICAgICAgICAgICAgICB9KSwgdGhpcy5jb25uZWN0b3IgJiYgdGhpcy5jb25uZWN0b3IuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogQS5vcGFjaXR5XG4gICAgICAgICAgICAgIH0sIEQpKTtcbiAgICAgICAgICAgICAgdGhpcy5ncmFwaGljLmFuaW1hdGUoQSwgRCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHUgJiYgdGhpcy5ncmFwaGljLmFuaW1hdGUodSwgcShiLm9wdGlvbnMuY2hhcnQuYW5pbWF0aW9uLCBsLmFuaW1hdGlvbiwgaC5hbmltYXRpb24pKTtcbiAgICAgICAgICAgIHIgJiYgci5oaWRlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhICYmIGwpIHtcbiAgICAgICAgICAgICAgZiA9IHAuc3ltYm9sIHx8IGQuc3ltYm9sO1xuICAgICAgICAgICAgICByICYmIHIuY3VycmVudFN5bWJvbCAhPT0gZiAmJiAociA9IHIuZGVzdHJveSgpKTtcbiAgICAgICAgICAgICAgaWYgKHUpIGlmIChyKSByW2MgPyBcImFuaW1hdGVcIiA6IFwiYXR0clwiXSh7XG4gICAgICAgICAgICAgICAgeDogdS54LFxuICAgICAgICAgICAgICAgIHk6IHUueVxuICAgICAgICAgICAgICB9KTtlbHNlIGYgJiYgKGQuc3RhdGVNYXJrZXJHcmFwaGljID0gciA9IGIucmVuZGVyZXIuc3ltYm9sKGYsIHUueCwgdS55LCB1LndpZHRoLCB1LmhlaWdodCkuYWRkKGQubWFya2VyR3JvdXApLCByLmN1cnJlbnRTeW1ib2wgPSBmKTtcbiAgICAgICAgICAgICAgIWIuc3R5bGVkTW9kZSAmJiByICYmIHIuYXR0cihkLnBvaW50QXR0cmlicyh0aGlzLCBhKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIgJiYgKHJbYSAmJiB0aGlzLmlzSW5zaWRlID8gXCJzaG93XCIgOiBcImhpZGVcIl0oKSwgci5lbGVtZW50LnBvaW50ID0gdGhpcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYSA9IGcuaGFsbztcbiAgICAgICAgICBnID0gKHIgPSB0aGlzLmdyYXBoaWMgfHwgcikgJiYgci52aXNpYmlsaXR5IHx8IFwiaW5oZXJpdFwiO1xuICAgICAgICAgIGEgJiYgYS5zaXplICYmIHIgJiYgXCJoaWRkZW5cIiAhPT0gZyAmJiAhdGhpcy5pc0NsdXN0ZXIgPyAodCB8fCAoZC5oYWxvID0gdCA9IGIucmVuZGVyZXIucGF0aCgpLmFkZChyLnBhcmVudEdyb3VwKSksIHQuc2hvdygpW2MgPyBcImFuaW1hdGVcIiA6IFwiYXR0clwiXSh7XG4gICAgICAgICAgICBkOiB0aGlzLmhhbG9QYXRoKGEuc2l6ZSlcbiAgICAgICAgICB9KSwgdC5hdHRyKHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogXCJoaWdoY2hhcnRzLWhhbG8gaGlnaGNoYXJ0cy1jb2xvci1cIiArIHEodGhpcy5jb2xvckluZGV4LCBkLmNvbG9ySW5kZXgpICsgKHRoaXMuY2xhc3NOYW1lID8gXCIgXCIgKyB0aGlzLmNsYXNzTmFtZSA6IFwiXCIpLFxuICAgICAgICAgICAgdmlzaWJpbGl0eTogZyxcbiAgICAgICAgICAgIHpJbmRleDogLTFcbiAgICAgICAgICB9KSwgdC5wb2ludCA9IHRoaXMsIGIuc3R5bGVkTW9kZSB8fCB0LmF0dHIoRyh7XG4gICAgICAgICAgICBmaWxsOiB0aGlzLmNvbG9yIHx8IGQuY29sb3IsXG4gICAgICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiBhLm9wYWNpdHlcbiAgICAgICAgICB9LCBhLmF0dHJpYnV0ZXMpKSkgOiB0ICYmIHQucG9pbnQgJiYgdC5wb2ludC5oYWxvUGF0aCAmJiB0LmFuaW1hdGUoe1xuICAgICAgICAgICAgZDogdC5wb2ludC5oYWxvUGF0aCgwKVxuICAgICAgICAgIH0sIG51bGwsIHQuaGlkZSk7XG4gICAgICAgICAgSih0aGlzLCBcImFmdGVyU2V0U3RhdGVcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYWxvUGF0aDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWVzLmNoYXJ0LnJlbmRlcmVyLnN5bWJvbHMuY2lyY2xlKE1hdGguZmxvb3IodGhpcy5wbG90WCkgLSBhLCB0aGlzLnBsb3RZIC0gYSwgMiAqIGEsIDIgKiBhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBHKGsucHJvdG90eXBlLCB7XG4gICAgICBvbk1vdXNlT3ZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBjID0gYS5ob3ZlclNlcmllcztcbiAgICAgICAgaWYgKGMgJiYgYyAhPT0gdGhpcykgYy5vbk1vdXNlT3V0KCk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5ldmVudHMubW91c2VPdmVyICYmIEoodGhpcywgXCJtb3VzZU92ZXJcIik7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoXCJob3ZlclwiKTtcbiAgICAgICAgYS5ob3ZlclNlcmllcyA9IHRoaXM7XG4gICAgICB9LFxuICAgICAgb25Nb3VzZU91dDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGMgPSB0aGlzLmNoYXJ0LFxuICAgICAgICAgICAgZCA9IGMudG9vbHRpcCxcbiAgICAgICAgICAgIGUgPSBjLmhvdmVyUG9pbnQ7XG4gICAgICAgIGMuaG92ZXJTZXJpZXMgPSBudWxsO1xuICAgICAgICBpZiAoZSkgZS5vbk1vdXNlT3V0KCk7XG4gICAgICAgIHRoaXMgJiYgYS5ldmVudHMubW91c2VPdXQgJiYgSih0aGlzLCBcIm1vdXNlT3V0XCIpO1xuICAgICAgICAhZCB8fCB0aGlzLnN0aWNreVRyYWNraW5nIHx8IGQuc2hhcmVkICYmICF0aGlzLm5vU2hhcmVkVG9vbHRpcCB8fCBkLmhpZGUoKTtcbiAgICAgICAgYy5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEuc2V0U3RhdGUoXCJcIiwgITApO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzZXRTdGF0ZTogZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLFxuICAgICAgICAgICAgZSA9IGQub3B0aW9ucyxcbiAgICAgICAgICAgIGYgPSBkLmdyYXBoLFxuICAgICAgICAgICAgZyA9IGUuaW5hY3RpdmVPdGhlclBvaW50cyxcbiAgICAgICAgICAgIGggPSBlLnN0YXRlcyxcbiAgICAgICAgICAgIGsgPSBlLmxpbmVXaWR0aCxcbiAgICAgICAgICAgIGwgPSBlLm9wYWNpdHksXG4gICAgICAgICAgICBuID0gcShoW2EgfHwgXCJub3JtYWxcIl0gJiYgaFthIHx8IFwibm9ybWFsXCJdLmFuaW1hdGlvbiwgZC5jaGFydC5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbik7XG4gICAgICAgIGUgPSAwO1xuICAgICAgICBhID0gYSB8fCBcIlwiO1xuXG4gICAgICAgIGlmIChkLnN0YXRlICE9PSBhICYmIChbZC5ncm91cCwgZC5tYXJrZXJHcm91cCwgZC5kYXRhTGFiZWxzR3JvdXBdLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBjICYmIChkLnN0YXRlICYmIGMucmVtb3ZlQ2xhc3MoXCJoaWdoY2hhcnRzLXNlcmllcy1cIiArIGQuc3RhdGUpLCBhICYmIGMuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXNlcmllcy1cIiArIGEpKTtcbiAgICAgICAgfSksIGQuc3RhdGUgPSBhLCAhZC5jaGFydC5zdHlsZWRNb2RlKSkge1xuICAgICAgICAgIGlmIChoW2FdICYmICExID09PSBoW2FdLmVuYWJsZWQpIHJldHVybjtcbiAgICAgICAgICBhICYmIChrID0gaFthXS5saW5lV2lkdGggfHwgayArIChoW2FdLmxpbmVXaWR0aFBsdXMgfHwgMCksIGwgPSBxKGhbYV0ub3BhY2l0eSwgbCkpO1xuICAgICAgICAgIGlmIChmICYmICFmLmRhc2hzdHlsZSkgZm9yIChoID0ge1xuICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjoga1xuICAgICAgICAgIH0sIGYuYW5pbWF0ZShoLCBuKTsgZFtcInpvbmUtZ3JhcGgtXCIgKyBlXTspIGRbXCJ6b25lLWdyYXBoLVwiICsgZV0uYXR0cihoKSwgZSArPSAxO1xuICAgICAgICAgIGcgfHwgW2QuZ3JvdXAsIGQubWFya2VyR3JvdXAsIGQuZGF0YUxhYmVsc0dyb3VwLCBkLmxhYmVsQnlTZXJpZXNdLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGEgJiYgYS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogbFxuICAgICAgICAgICAgfSwgbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjICYmIGcgJiYgZC5wb2ludHMgJiYgZC5zZXRBbGxQb2ludHNUb1N0YXRlKGEpO1xuICAgICAgfSxcbiAgICAgIHNldEFsbFBvaW50c1RvU3RhdGU6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHRoaXMucG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICBjLnNldFN0YXRlICYmIGMuc2V0U3RhdGUoYSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHNldFZpc2libGU6IGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgIHZhciBkID0gdGhpcyxcbiAgICAgICAgICAgIGUgPSBkLmNoYXJ0LFxuICAgICAgICAgICAgZiA9IGQubGVnZW5kSXRlbSxcbiAgICAgICAgICAgIGcgPSBlLm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzLFxuICAgICAgICAgICAgaCA9IGQudmlzaWJsZTtcbiAgICAgICAgdmFyIGsgPSAoZC52aXNpYmxlID0gYSA9IGQub3B0aW9ucy52aXNpYmxlID0gZC51c2VyT3B0aW9ucy52aXNpYmxlID0gXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGEgPyAhaCA6IGEpID8gXCJzaG93XCIgOiBcImhpZGVcIjtcbiAgICAgICAgW1wiZ3JvdXBcIiwgXCJkYXRhTGFiZWxzR3JvdXBcIiwgXCJtYXJrZXJHcm91cFwiLCBcInRyYWNrZXJcIiwgXCJ0dFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgaWYgKGRbYV0pIGRbYV1ba10oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlLmhvdmVyU2VyaWVzID09PSBkIHx8IChlLmhvdmVyUG9pbnQgJiYgZS5ob3ZlclBvaW50LnNlcmllcykgPT09IGQpIGQub25Nb3VzZU91dCgpO1xuICAgICAgICBmICYmIGUubGVnZW5kLmNvbG9yaXplSXRlbShkLCBhKTtcbiAgICAgICAgZC5pc0RpcnR5ID0gITA7XG4gICAgICAgIGQub3B0aW9ucy5zdGFja2luZyAmJiBlLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYS5vcHRpb25zLnN0YWNraW5nICYmIGEudmlzaWJsZSAmJiAoYS5pc0RpcnR5ID0gITApO1xuICAgICAgICB9KTtcbiAgICAgICAgZC5saW5rZWRTZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGMuc2V0VmlzaWJsZShhLCAhMSk7XG4gICAgICAgIH0pO1xuICAgICAgICBnICYmIChlLmlzRGlydHlCb3ggPSAhMCk7XG4gICAgICAgIEooZCwgayk7XG4gICAgICAgICExICE9PSBjICYmIGUucmVkcmF3KCk7XG4gICAgICB9LFxuICAgICAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldFZpc2libGUoITApO1xuICAgICAgfSxcbiAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRWaXNpYmxlKCExKTtcbiAgICAgIH0sXG4gICAgICBzZWxlY3Q6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBhID0gdGhpcy5vcHRpb25zLnNlbGVjdGVkID0gXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGEgPyAhdGhpcy5zZWxlY3RlZCA6IGE7XG4gICAgICAgIHRoaXMuY2hlY2tib3ggJiYgKHRoaXMuY2hlY2tib3guY2hlY2tlZCA9IGEpO1xuICAgICAgICBKKHRoaXMsIGEgPyBcInNlbGVjdFwiIDogXCJ1bnNlbGVjdFwiKTtcbiAgICAgIH0sXG4gICAgICBkcmF3VHJhY2tlcjogZC5kcmF3VHJhY2tlckdyYXBoXG4gICAgfSk7XG4gIH0pO1xuICBTKHIsIFwicGFydHMvUmVzcG9uc2l2ZS5qc1wiLCBbcltcInBhcnRzL0dsb2JhbHMuanNcIl0sIHJbXCJwYXJ0cy9VdGlsaXRpZXMuanNcIl1dLCBmdW5jdGlvbiAoZCwgZykge1xuICAgIHZhciByID0gZy5maW5kLFxuICAgICAgICB1ID0gZy5pc0FycmF5LFxuICAgICAgICBJID0gZy5pc09iamVjdCxcbiAgICAgICAgTSA9IGcubWVyZ2UsXG4gICAgICAgIEUgPSBnLm9iamVjdEVhY2gsXG4gICAgICAgIEEgPSBnLnBpY2ssXG4gICAgICAgIEcgPSBnLnNwbGF0LFxuICAgICAgICBKID0gZy51bmlxdWVLZXk7XG4gICAgZCA9IGQuQ2hhcnQ7XG5cbiAgICBkLnByb3RvdHlwZS5zZXRSZXNwb25zaXZlID0gZnVuY3Rpb24gKGQsIGcpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5vcHRpb25zLnJlc3BvbnNpdmUsXG4gICAgICAgICAgaCA9IFtdLFxuICAgICAgICAgIHUgPSB0aGlzLmN1cnJlbnRSZXNwb25zaXZlO1xuICAgICAgIWcgJiYgdCAmJiB0LnJ1bGVzICYmIHQucnVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICBcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgZC5faWQgJiYgKGQuX2lkID0gSigpKTtcbiAgICAgICAgdGhpcy5tYXRjaFJlc3BvbnNpdmVSdWxlKGQsIGgpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgICBnID0gTS5hcHBseSgwLCBoLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gcih0LnJ1bGVzLCBmdW5jdGlvbiAoZykge1xuICAgICAgICAgIHJldHVybiBnLl9pZCA9PT0gZDtcbiAgICAgICAgfSkuY2hhcnRPcHRpb25zO1xuICAgICAgfSkpO1xuICAgICAgZy5pc1Jlc3BvbnNpdmVPcHRpb25zID0gITA7XG4gICAgICBoID0gaC50b1N0cmluZygpIHx8IHZvaWQgMDtcbiAgICAgIGggIT09ICh1ICYmIHUucnVsZUlkcykgJiYgKHUgJiYgdGhpcy51cGRhdGUodS51bmRvT3B0aW9ucywgZCwgITApLCBoID8gKHUgPSB0aGlzLmN1cnJlbnRPcHRpb25zKGcpLCB1LmlzUmVzcG9uc2l2ZU9wdGlvbnMgPSAhMCwgdGhpcy5jdXJyZW50UmVzcG9uc2l2ZSA9IHtcbiAgICAgICAgcnVsZUlkczogaCxcbiAgICAgICAgbWVyZ2VkT3B0aW9uczogZyxcbiAgICAgICAgdW5kb09wdGlvbnM6IHVcbiAgICAgIH0sIHRoaXMudXBkYXRlKGcsIGQsICEwKSkgOiB0aGlzLmN1cnJlbnRSZXNwb25zaXZlID0gdm9pZCAwKTtcbiAgICB9O1xuXG4gICAgZC5wcm90b3R5cGUubWF0Y2hSZXNwb25zaXZlUnVsZSA9IGZ1bmN0aW9uIChkLCBnKSB7XG4gICAgICB2YXIgciA9IGQuY29uZGl0aW9uO1xuICAgICAgKHIuY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFydFdpZHRoIDw9IEEoci5tYXhXaWR0aCwgTnVtYmVyLk1BWF9WQUxVRSkgJiYgdGhpcy5jaGFydEhlaWdodCA8PSBBKHIubWF4SGVpZ2h0LCBOdW1iZXIuTUFYX1ZBTFVFKSAmJiB0aGlzLmNoYXJ0V2lkdGggPj0gQShyLm1pbldpZHRoLCAwKSAmJiB0aGlzLmNoYXJ0SGVpZ2h0ID49IEEoci5taW5IZWlnaHQsIDApO1xuICAgICAgfSkuY2FsbCh0aGlzKSAmJiBnLnB1c2goZC5faWQpO1xuICAgIH07XG5cbiAgICBkLnByb3RvdHlwZS5jdXJyZW50T3B0aW9ucyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICBmdW5jdGlvbiBnKGQsIGgsIHQsIGUpIHtcbiAgICAgICAgdmFyIGM7XG4gICAgICAgIEUoZCwgZnVuY3Rpb24gKGQsIG4pIHtcbiAgICAgICAgICBpZiAoIWUgJiYgLTEgPCByLmNvbGxlY3Rpb25zV2l0aFVwZGF0ZS5pbmRleE9mKG4pKSBmb3IgKGQgPSBHKGQpLCB0W25dID0gW10sIGMgPSAwOyBjIDwgZC5sZW5ndGg7IGMrKykgaFtuXVtjXSAmJiAodFtuXVtjXSA9IHt9LCBnKGRbY10sIGhbbl1bY10sIHRbbl1bY10sIGUgKyAxKSk7ZWxzZSBJKGQpID8gKHRbbl0gPSB1KGQpID8gW10gOiB7fSwgZyhkLCBoW25dIHx8IHt9LCB0W25dLCBlICsgMSkpIDogdFtuXSA9IFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBoW25dID8gbnVsbCA6IGhbbl07XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgciA9IHRoaXMsXG4gICAgICAgICAgaCA9IHt9O1xuICAgICAgZyhkLCB0aGlzLm9wdGlvbnMsIGgsIDApO1xuICAgICAgcmV0dXJuIGg7XG4gICAgfTtcbiAgfSk7XG4gIFMociwgXCJtYXN0ZXJzL2hpZ2hjaGFydHMuc3JjLmpzXCIsIFtyW1wicGFydHMvR2xvYmFscy5qc1wiXV0sIGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH0pO1xuICByW1wibWFzdGVycy9oaWdoY2hhcnRzLnNyYy5qc1wiXS5fbW9kdWxlcyA9IHI7XG4gIHJldHVybiByW1wibWFzdGVycy9oaWdoY2hhcnRzLnNyYy5qc1wiXTtcbn0pOyIsIi8qXG4gSGlnaGNoYXJ0cyBKUyB2OC4wLjQgKDIwMjAtMDMtMTApXG5cbiBFeHBvcnRpbmcgbW9kdWxlXG5cbiAoYykgMjAxMC0yMDE5IFRvcnN0ZWluIEhvbnNpXG5cbiBMaWNlbnNlOiB3d3cuaGlnaGNoYXJ0cy5jb20vbGljZW5zZVxuKi9cbihmdW5jdGlvbiAoZSkge1xuICBcIm9iamVjdFwiID09PSB0eXBlb2YgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzID8gKGVbXCJkZWZhdWx0XCJdID0gZSwgbW9kdWxlLmV4cG9ydHMgPSBlKSA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFwiaGlnaGNoYXJ0cy9tb2R1bGVzL2V4cG9ydGluZ1wiLCBbXCJoaWdoY2hhcnRzXCJdLCBmdW5jdGlvbiAobSkge1xuICAgIGUobSk7XG4gICAgZS5IaWdoY2hhcnRzID0gbTtcbiAgICByZXR1cm4gZTtcbiAgfSkgOiBlKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBIaWdoY2hhcnRzID8gSGlnaGNoYXJ0cyA6IHZvaWQgMCk7XG59KShmdW5jdGlvbiAoZSkge1xuICBmdW5jdGlvbiBtKGYsIGcsIGUsIG4pIHtcbiAgICBmLmhhc093blByb3BlcnR5KGcpIHx8IChmW2ddID0gbi5hcHBseShudWxsLCBlKSk7XG4gIH1cblxuICBlID0gZSA/IGUuX21vZHVsZXMgOiB7fTtcbiAgbShlLCBcIm1vZHVsZXMvZnVsbC1zY3JlZW4uc3JjLmpzXCIsIFtlW1wicGFydHMvR2xvYmFscy5qc1wiXV0sIGZ1bmN0aW9uIChmKSB7XG4gICAgdmFyIGcgPSBmLmFkZEV2ZW50LFxuICAgICAgICBlID0gZi5DaGFydCxcbiAgICAgICAgbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIGcoaCkge1xuICAgICAgICB0aGlzLmNoYXJ0ID0gaDtcbiAgICAgICAgdGhpcy5pc09wZW4gPSAhMTtcbiAgICAgICAgaC5jb250YWluZXIucGFyZW50Tm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgKGggPSBoLmNvbnRhaW5lci5wYXJlbnROb2RlLCB0aGlzLmJyb3dzZXJQcm9wcyB8fCAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaC5yZXF1ZXN0RnVsbHNjcmVlbiA/IHRoaXMuYnJvd3NlclByb3BzID0ge1xuICAgICAgICAgIGZ1bGxzY3JlZW5DaGFuZ2U6IFwiZnVsbHNjcmVlbmNoYW5nZVwiLFxuICAgICAgICAgIHJlcXVlc3RGdWxsc2NyZWVuOiBcInJlcXVlc3RGdWxsc2NyZWVuXCIsXG4gICAgICAgICAgZXhpdEZ1bGxzY3JlZW46IFwiZXhpdEZ1bGxzY3JlZW5cIlxuICAgICAgICB9IDogaC5tb3pSZXF1ZXN0RnVsbFNjcmVlbiA/IHRoaXMuYnJvd3NlclByb3BzID0ge1xuICAgICAgICAgIGZ1bGxzY3JlZW5DaGFuZ2U6IFwibW96ZnVsbHNjcmVlbmNoYW5nZVwiLFxuICAgICAgICAgIHJlcXVlc3RGdWxsc2NyZWVuOiBcIm1velJlcXVlc3RGdWxsU2NyZWVuXCIsXG4gICAgICAgICAgZXhpdEZ1bGxzY3JlZW46IFwibW96Q2FuY2VsRnVsbFNjcmVlblwiXG4gICAgICAgIH0gOiBoLndlYmtpdFJlcXVlc3RGdWxsU2NyZWVuID8gdGhpcy5icm93c2VyUHJvcHMgPSB7XG4gICAgICAgICAgZnVsbHNjcmVlbkNoYW5nZTogXCJ3ZWJraXRmdWxsc2NyZWVuY2hhbmdlXCIsXG4gICAgICAgICAgcmVxdWVzdEZ1bGxzY3JlZW46IFwid2Via2l0UmVxdWVzdEZ1bGxTY3JlZW5cIixcbiAgICAgICAgICBleGl0RnVsbHNjcmVlbjogXCJ3ZWJraXRFeGl0RnVsbHNjcmVlblwiXG4gICAgICAgIH0gOiBoLm1zUmVxdWVzdEZ1bGxzY3JlZW4gJiYgKHRoaXMuYnJvd3NlclByb3BzID0ge1xuICAgICAgICAgIGZ1bGxzY3JlZW5DaGFuZ2U6IFwiTVNGdWxsc2NyZWVuQ2hhbmdlXCIsXG4gICAgICAgICAgcmVxdWVzdEZ1bGxzY3JlZW46IFwibXNSZXF1ZXN0RnVsbHNjcmVlblwiLFxuICAgICAgICAgIGV4aXRGdWxsc2NyZWVuOiBcIm1zRXhpdEZ1bGxzY3JlZW5cIlxuICAgICAgICB9KSkpO1xuICAgICAgfVxuXG4gICAgICBnLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGggPSB0aGlzLmNoYXJ0O1xuICAgICAgICBpZiAodGhpcy5pc09wZW4gJiYgdGhpcy5icm93c2VyUHJvcHMgJiYgaC5jb250YWluZXIub3duZXJEb2N1bWVudCBpbnN0YW5jZW9mIERvY3VtZW50KSBoLmNvbnRhaW5lci5vd25lckRvY3VtZW50W3RoaXMuYnJvd3NlclByb3BzLmV4aXRGdWxsc2NyZWVuXSgpO1xuICAgICAgICB0aGlzLnVuYmluZEZ1bGxzY3JlZW5FdmVudCAmJiB0aGlzLnVuYmluZEZ1bGxzY3JlZW5FdmVudCgpO1xuICAgICAgICB0aGlzLmlzT3BlbiA9ICExO1xuICAgICAgICB0aGlzLnNldEJ1dHRvblRleHQoKTtcbiAgICAgIH07XG5cbiAgICAgIGcucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoID0gdGhpcyxcbiAgICAgICAgICAgIGcgPSBoLmNoYXJ0O1xuXG4gICAgICAgIGlmIChoLmJyb3dzZXJQcm9wcykge1xuICAgICAgICAgIGgudW5iaW5kRnVsbHNjcmVlbkV2ZW50ID0gZi5hZGRFdmVudChnLmNvbnRhaW5lci5vd25lckRvY3VtZW50LCBoLmJyb3dzZXJQcm9wcy5mdWxsc2NyZWVuQ2hhbmdlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBoLmlzT3BlbiA/IChoLmlzT3BlbiA9ICExLCBoLmNsb3NlKCkpIDogKGguaXNPcGVuID0gITAsIGguc2V0QnV0dG9uVGV4dCgpKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChnLmNvbnRhaW5lci5wYXJlbnROb2RlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGUgPSBnLmNvbnRhaW5lci5wYXJlbnROb2RlW2guYnJvd3NlclByb3BzLnJlcXVlc3RGdWxsc2NyZWVuXSgpO1xuICAgICAgICAgICAgaWYgKGUpIGVbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGFsZXJ0KFwiRnVsbCBzY3JlZW4gaXMgbm90IHN1cHBvcnRlZCBpbnNpZGUgYSBmcmFtZS5cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmLmFkZEV2ZW50KGcsIFwiZGVzdHJveVwiLCBoLnVuYmluZEZ1bGxzY3JlZW5FdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGcucHJvdG90eXBlLnNldEJ1dHRvblRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoLFxuICAgICAgICAgICAgZyA9IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICBmID0gZy5leHBvcnREaXZFbGVtZW50cyxcbiAgICAgICAgICAgIGUgPSBnLm9wdGlvbnMuZXhwb3J0aW5nLFxuICAgICAgICAgICAgbiA9IG51bGwgPT09IChoID0gbnVsbCA9PT0gZSB8fCB2b2lkIDAgPT09IGUgPyB2b2lkIDAgOiBlLmJ1dHRvbnMpIHx8IHZvaWQgMCA9PT0gaCA/IHZvaWQgMCA6IGguY29udGV4dEJ1dHRvbi5tZW51SXRlbXM7XG4gICAgICAgIGggPSBnLm9wdGlvbnMubGFuZztcbiAgICAgICAgKG51bGwgPT09IGUgfHwgdm9pZCAwID09PSBlID8gMCA6IGUubWVudUl0ZW1EZWZpbml0aW9ucykgJiYgKG51bGwgPT09IGggfHwgdm9pZCAwID09PSBoID8gMCA6IGguZXhpdEZ1bGxzY3JlZW4pICYmIGgudmlld0Z1bGxzY3JlZW4gJiYgbiAmJiBmICYmIGYubGVuZ3RoICYmIChmW24uaW5kZXhPZihcInZpZXdGdWxsc2NyZWVuXCIpXS5pbm5lckhUTUwgPSB0aGlzLmlzT3BlbiA/IGguZXhpdEZ1bGxzY3JlZW4gOiBlLm1lbnVJdGVtRGVmaW5pdGlvbnMudmlld0Z1bGxzY3JlZW4udGV4dCB8fCBoLnZpZXdGdWxsc2NyZWVuKTtcbiAgICAgIH07XG5cbiAgICAgIGcucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc09wZW4gPyB0aGlzLmNsb3NlKCkgOiB0aGlzLm9wZW4oKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBnO1xuICAgIH0oKTtcblxuICAgIGYuRnVsbHNjcmVlbiA9IG47XG4gICAgZyhlLCBcImJlZm9yZVJlbmRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmZ1bGxzY3JlZW4gPSBuZXcgZi5GdWxsc2NyZWVuKHRoaXMpO1xuICAgIH0pO1xuICAgIHJldHVybiBmLkZ1bGxzY3JlZW47XG4gIH0pO1xuICBtKGUsIFwibWl4aW5zL25hdmlnYXRpb24uanNcIiwgW10sIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5pdFVwZGF0ZTogZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgZi5uYXZpZ2F0aW9uIHx8IChmLm5hdmlnYXRpb24gPSB7XG4gICAgICAgICAgdXBkYXRlczogW10sXG4gICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoZywgZikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgZS51cGRhdGUuY2FsbChlLmNvbnRleHQsIGcsIGYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBhZGRVcGRhdGU6IGZ1bmN0aW9uIChmLCBnKSB7XG4gICAgICAgIGcubmF2aWdhdGlvbiB8fCB0aGlzLmluaXRVcGRhdGUoZyk7XG4gICAgICAgIGcubmF2aWdhdGlvbi51cGRhdGVzLnB1c2goe1xuICAgICAgICAgIHVwZGF0ZTogZixcbiAgICAgICAgICBjb250ZXh0OiBnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICBtKGUsIFwibW9kdWxlcy9leHBvcnRpbmcuc3JjLmpzXCIsIFtlW1wicGFydHMvR2xvYmFscy5qc1wiXSwgZVtcInBhcnRzL1V0aWxpdGllcy5qc1wiXSwgZVtcIm1peGlucy9uYXZpZ2F0aW9uLmpzXCJdXSwgZnVuY3Rpb24gKGYsIGcsIGUpIHtcbiAgICB2YXIgbiA9IGcuYWRkRXZlbnQsXG4gICAgICAgIHUgPSBnLmNzcyxcbiAgICAgICAgaCA9IGcuY3JlYXRlRWxlbWVudCxcbiAgICAgICAgbSA9IGcuZGlzY2FyZEVsZW1lbnQsXG4gICAgICAgIHggPSBnLmV4dGVuZCxcbiAgICAgICAgSSA9IGcuZmluZCxcbiAgICAgICAgQiA9IGcuZmlyZUV2ZW50LFxuICAgICAgICBKID0gZy5pc09iamVjdCxcbiAgICAgICAgcCA9IGcubWVyZ2UsXG4gICAgICAgIEUgPSBnLm9iamVjdEVhY2gsXG4gICAgICAgIHEgPSBnLnBpY2ssXG4gICAgICAgIEsgPSBnLnJlbW92ZUV2ZW50LFxuICAgICAgICBMID0gZy51bmlxdWVLZXksXG4gICAgICAgIHcgPSBmLmRlZmF1bHRPcHRpb25zLFxuICAgICAgICB5ID0gZi5kb2MsXG4gICAgICAgIEMgPSBmLkNoYXJ0LFxuICAgICAgICBNID0gZi5pc1RvdWNoRGV2aWNlLFxuICAgICAgICB6ID0gZi53aW4sXG4gICAgICAgIEcgPSB6Lm5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAgIEYgPSBmLlNWR1JlbmRlcmVyLFxuICAgICAgICBIID0gZi5SZW5kZXJlci5wcm90b3R5cGUuc3ltYm9scyxcbiAgICAgICAgTiA9IC9FZGdlXFwvfFRyaWRlbnRcXC98TVNJRSAvLnRlc3QoRyksXG4gICAgICAgIE8gPSAvZmlyZWZveC9pLnRlc3QoRyk7XG4gICAgeCh3LmxhbmcsIHtcbiAgICAgIHZpZXdGdWxsc2NyZWVuOiBcIlZpZXcgaW4gZnVsbCBzY3JlZW5cIixcbiAgICAgIGV4aXRGdWxsc2NyZWVuOiBcIkV4aXQgZnJvbSBmdWxsIHNjcmVlblwiLFxuICAgICAgcHJpbnRDaGFydDogXCJQcmludCBjaGFydFwiLFxuICAgICAgZG93bmxvYWRQTkc6IFwiRG93bmxvYWQgUE5HIGltYWdlXCIsXG4gICAgICBkb3dubG9hZEpQRUc6IFwiRG93bmxvYWQgSlBFRyBpbWFnZVwiLFxuICAgICAgZG93bmxvYWRQREY6IFwiRG93bmxvYWQgUERGIGRvY3VtZW50XCIsXG4gICAgICBkb3dubG9hZFNWRzogXCJEb3dubG9hZCBTVkcgdmVjdG9yIGltYWdlXCIsXG4gICAgICBjb250ZXh0QnV0dG9uVGl0bGU6IFwiQ2hhcnQgY29udGV4dCBtZW51XCJcbiAgICB9KTtcbiAgICB3Lm5hdmlnYXRpb24gfHwgKHcubmF2aWdhdGlvbiA9IHt9KTtcbiAgICBwKCEwLCB3Lm5hdmlnYXRpb24sIHtcbiAgICAgIGJ1dHRvbk9wdGlvbnM6IHtcbiAgICAgICAgdGhlbWU6IHt9LFxuICAgICAgICBzeW1ib2xTaXplOiAxNCxcbiAgICAgICAgc3ltYm9sWDogMTIuNSxcbiAgICAgICAgc3ltYm9sWTogMTAuNSxcbiAgICAgICAgYWxpZ246IFwicmlnaHRcIixcbiAgICAgICAgYnV0dG9uU3BhY2luZzogMyxcbiAgICAgICAgaGVpZ2h0OiAyMixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0b3BcIixcbiAgICAgICAgd2lkdGg6IDI0XG4gICAgICB9XG4gICAgfSk7XG4gICAgcCghMCwgdy5uYXZpZ2F0aW9uLCB7XG4gICAgICBtZW51U3R5bGU6IHtcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjOTk5OTk5XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI2ZmZmZmZlwiLFxuICAgICAgICBwYWRkaW5nOiBcIjVweCAwXCJcbiAgICAgIH0sXG4gICAgICBtZW51SXRlbVN0eWxlOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMC41ZW0gMWVtXCIsXG4gICAgICAgIGNvbG9yOiBcIiMzMzMzMzNcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCJub25lXCIsXG4gICAgICAgIGZvbnRTaXplOiBNID8gXCIxNHB4XCIgOiBcIjExcHhcIixcbiAgICAgICAgdHJhbnNpdGlvbjogXCJiYWNrZ3JvdW5kIDI1MG1zLCBjb2xvciAyNTBtc1wiXG4gICAgICB9LFxuICAgICAgbWVudUl0ZW1Ib3ZlclN0eWxlOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzMzNWNhZFwiLFxuICAgICAgICBjb2xvcjogXCIjZmZmZmZmXCJcbiAgICAgIH0sXG4gICAgICBidXR0b25PcHRpb25zOiB7XG4gICAgICAgIHN5bWJvbEZpbGw6IFwiIzY2NjY2NlwiLFxuICAgICAgICBzeW1ib2xTdHJva2U6IFwiIzY2NjY2NlwiLFxuICAgICAgICBzeW1ib2xTdHJva2VXaWR0aDogMyxcbiAgICAgICAgdGhlbWU6IHtcbiAgICAgICAgICBwYWRkaW5nOiA1XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB3LmV4cG9ydGluZyA9IHtcbiAgICAgIHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG4gICAgICB1cmw6IFwiaHR0cHM6Ly9leHBvcnQuaGlnaGNoYXJ0cy5jb20vXCIsXG4gICAgICBwcmludE1heFdpZHRoOiA3ODAsXG4gICAgICBzY2FsZTogMixcbiAgICAgIGJ1dHRvbnM6IHtcbiAgICAgICAgY29udGV4dEJ1dHRvbjoge1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJoaWdoY2hhcnRzLWNvbnRleHRidXR0b25cIixcbiAgICAgICAgICBtZW51Q2xhc3NOYW1lOiBcImhpZ2hjaGFydHMtY29udGV4dG1lbnVcIixcbiAgICAgICAgICBzeW1ib2w6IFwibWVudVwiLFxuICAgICAgICAgIHRpdGxlS2V5OiBcImNvbnRleHRCdXR0b25UaXRsZVwiLFxuICAgICAgICAgIG1lbnVJdGVtczogXCJ2aWV3RnVsbHNjcmVlbiBwcmludENoYXJ0IHNlcGFyYXRvciBkb3dubG9hZFBORyBkb3dubG9hZEpQRUcgZG93bmxvYWRQREYgZG93bmxvYWRTVkdcIi5zcGxpdChcIiBcIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1lbnVJdGVtRGVmaW5pdGlvbnM6IHtcbiAgICAgICAgdmlld0Z1bGxzY3JlZW46IHtcbiAgICAgICAgICB0ZXh0S2V5OiBcInZpZXdGdWxsc2NyZWVuXCIsXG4gICAgICAgICAgb25jbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5mdWxsc2NyZWVuLnRvZ2dsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJpbnRDaGFydDoge1xuICAgICAgICAgIHRleHRLZXk6IFwicHJpbnRDaGFydFwiLFxuICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNlcGFyYXRvcjoge1xuICAgICAgICAgIHNlcGFyYXRvcjogITBcbiAgICAgICAgfSxcbiAgICAgICAgZG93bmxvYWRQTkc6IHtcbiAgICAgICAgICB0ZXh0S2V5OiBcImRvd25sb2FkUE5HXCIsXG4gICAgICAgICAgb25jbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5leHBvcnRDaGFydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZG93bmxvYWRKUEVHOiB7XG4gICAgICAgICAgdGV4dEtleTogXCJkb3dubG9hZEpQRUdcIixcbiAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmV4cG9ydENoYXJ0KHtcbiAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZS9qcGVnXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZG93bmxvYWRQREY6IHtcbiAgICAgICAgICB0ZXh0S2V5OiBcImRvd25sb2FkUERGXCIsXG4gICAgICAgICAgb25jbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5leHBvcnRDaGFydCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vcGRmXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZG93bmxvYWRTVkc6IHtcbiAgICAgICAgICB0ZXh0S2V5OiBcImRvd25sb2FkU1ZHXCIsXG4gICAgICAgICAgb25jbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5leHBvcnRDaGFydCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2Uvc3ZnK3htbFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZi5wb3N0ID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHZhciBkID0gaChcImZvcm1cIiwgcCh7XG4gICAgICAgIG1ldGhvZDogXCJwb3N0XCIsXG4gICAgICAgIGFjdGlvbjogYSxcbiAgICAgICAgZW5jdHlwZTogXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCJcbiAgICAgIH0sIGMpLCB7XG4gICAgICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gICAgICB9LCB5LmJvZHkpO1xuICAgICAgRShiLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBoKFwiaW5wdXRcIiwge1xuICAgICAgICAgIHR5cGU6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgbmFtZTogYixcbiAgICAgICAgICB2YWx1ZTogYVxuICAgICAgICB9LCBudWxsLCBkKTtcbiAgICAgIH0pO1xuICAgICAgZC5zdWJtaXQoKTtcbiAgICAgIG0oZCk7XG4gICAgfTtcblxuICAgIGYuaXNTYWZhcmkgJiYgZi53aW4ubWF0Y2hNZWRpYShcInByaW50XCIpLmFkZExpc3RlbmVyKGZ1bmN0aW9uIChhKSB7XG4gICAgICBmLnByaW50aW5nQ2hhcnQgJiYgKGEubWF0Y2hlcyA/IGYucHJpbnRpbmdDaGFydC5iZWZvcmVQcmludCgpIDogZi5wcmludGluZ0NoYXJ0LmFmdGVyUHJpbnQoKSk7XG4gICAgfSk7XG4gICAgeChDLnByb3RvdHlwZSwge1xuICAgICAgc2FuaXRpemVTVkc6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBjID0gYS5pbmRleE9mKFwiPC9zdmc+XCIpICsgNixcbiAgICAgICAgICAgIGQgPSBhLnN1YnN0cihjKTtcbiAgICAgICAgYSA9IGEuc3Vic3RyKDAsIGMpO1xuICAgICAgICBiICYmIGIuZXhwb3J0aW5nICYmIGIuZXhwb3J0aW5nLmFsbG93SFRNTCAmJiBkICYmIChkID0gJzxmb3JlaWduT2JqZWN0IHg9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIicgKyBiLmNoYXJ0LndpZHRoICsgJ1wiIGhlaWdodD1cIicgKyBiLmNoYXJ0LmhlaWdodCArICdcIj48Ym9keSB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIj4nICsgZCArIFwiPC9ib2R5PjwvZm9yZWlnbk9iamVjdD5cIiwgYSA9IGEucmVwbGFjZShcIjwvc3ZnPlwiLCBkICsgXCI8L3N2Zz5cIikpO1xuICAgICAgICBhID0gYS5yZXBsYWNlKC96SW5kZXg9XCJbXlwiXStcIi9nLCBcIlwiKS5yZXBsYWNlKC9zeW1ib2xOYW1lPVwiW15cIl0rXCIvZywgXCJcIikucmVwbGFjZSgvalF1ZXJ5WzAtOV0rPVwiW15cIl0rXCIvZywgXCJcIikucmVwbGFjZSgvdXJsXFwoKFwifCZxdW90OykoLio/KShcInwmcXVvdDspOz9cXCkvZywgXCJ1cmwoJDIpXCIpLnJlcGxhY2UoL3VybFxcKFteI10rIy9nLCBcInVybCgjXCIpLnJlcGxhY2UoLzxzdmcgLywgJzxzdmcgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgJykucmVwbGFjZSgvICh8TlNbMC05XSs6KWhyZWY9L2csIFwiIHhsaW5rOmhyZWY9XCIpLnJlcGxhY2UoL1xcbi8sIFwiIFwiKS5yZXBsYWNlKC8oZmlsbHxzdHJva2UpPVwicmdiYVxcKChbIDAtOV0rLFsgMC05XSssWyAwLTldKyksKFsgMC05XFwuXSspXFwpXCIvZywgJyQxPVwicmdiKCQyKVwiICQxLW9wYWNpdHk9XCIkM1wiJykucmVwbGFjZSgvJm5ic3A7L2csIFwiXFx1MDBhMFwiKS5yZXBsYWNlKC8mc2h5Oy9nLCBcIlxcdTAwYWRcIik7XG4gICAgICAgIHRoaXMuaWVTYW5pdGl6ZVNWRyAmJiAoYSA9IHRoaXMuaWVTYW5pdGl6ZVNWRyhhKSk7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSxcbiAgICAgIGdldENoYXJ0SFRNTDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0eWxlZE1vZGUgJiYgdGhpcy5pbmxpbmVTdHlsZXMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLmlubmVySFRNTDtcbiAgICAgIH0sXG4gICAgICBnZXRTVkc6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBiLFxuICAgICAgICAgICAgYyA9IHAodGhpcy5vcHRpb25zLCBhKTtcbiAgICAgICAgYy5wbG90T3B0aW9ucyA9IHAodGhpcy51c2VyT3B0aW9ucy5wbG90T3B0aW9ucywgYSAmJiBhLnBsb3RPcHRpb25zKTtcbiAgICAgICAgYy50aW1lID0gcCh0aGlzLnVzZXJPcHRpb25zLnRpbWUsIGEgJiYgYS50aW1lKTtcbiAgICAgICAgdmFyIGQgPSBoKFwiZGl2XCIsIG51bGwsIHtcbiAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgIHRvcDogXCItOTk5OWVtXCIsXG4gICAgICAgICAgd2lkdGg6IHRoaXMuY2hhcnRXaWR0aCArIFwicHhcIixcbiAgICAgICAgICBoZWlnaHQ6IHRoaXMuY2hhcnRIZWlnaHQgKyBcInB4XCJcbiAgICAgICAgfSwgeS5ib2R5KTtcbiAgICAgICAgdmFyIGcgPSB0aGlzLnJlbmRlclRvLnN0eWxlLndpZHRoO1xuICAgICAgICB2YXIgZSA9IHRoaXMucmVuZGVyVG8uc3R5bGUuaGVpZ2h0O1xuICAgICAgICBnID0gYy5leHBvcnRpbmcuc291cmNlV2lkdGggfHwgYy5jaGFydC53aWR0aCB8fCAvcHgkLy50ZXN0KGcpICYmIHBhcnNlSW50KGcsIDEwKSB8fCAoYy5pc0dhbnR0ID8gODAwIDogNjAwKTtcbiAgICAgICAgZSA9IGMuZXhwb3J0aW5nLnNvdXJjZUhlaWdodCB8fCBjLmNoYXJ0LmhlaWdodCB8fCAvcHgkLy50ZXN0KGUpICYmIHBhcnNlSW50KGUsIDEwKSB8fCA0MDA7XG4gICAgICAgIHgoYy5jaGFydCwge1xuICAgICAgICAgIGFuaW1hdGlvbjogITEsXG4gICAgICAgICAgcmVuZGVyVG86IGQsXG4gICAgICAgICAgZm9yRXhwb3J0OiAhMCxcbiAgICAgICAgICByZW5kZXJlcjogXCJTVkdSZW5kZXJlclwiLFxuICAgICAgICAgIHdpZHRoOiBnLFxuICAgICAgICAgIGhlaWdodDogZVxuICAgICAgICB9KTtcbiAgICAgICAgYy5leHBvcnRpbmcuZW5hYmxlZCA9ICExO1xuICAgICAgICBkZWxldGUgYy5kYXRhO1xuICAgICAgICBjLnNlcmllcyA9IFtdO1xuICAgICAgICB0aGlzLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgYiA9IHAoYS51c2VyT3B0aW9ucywge1xuICAgICAgICAgICAgYW5pbWF0aW9uOiAhMSxcbiAgICAgICAgICAgIGVuYWJsZU1vdXNlVHJhY2tpbmc6ICExLFxuICAgICAgICAgICAgc2hvd0NoZWNrYm94OiAhMSxcbiAgICAgICAgICAgIHZpc2libGU6IGEudmlzaWJsZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGIuaXNJbnRlcm5hbCB8fCBjLnNlcmllcy5wdXNoKGIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5heGVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICBhLnVzZXJPcHRpb25zLmludGVybmFsS2V5IHx8IChhLnVzZXJPcHRpb25zLmludGVybmFsS2V5ID0gTCgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByID0gbmV3IGYuQ2hhcnQoYywgdGhpcy5jYWxsYmFjayk7XG4gICAgICAgIGEgJiYgW1wieEF4aXNcIiwgXCJ5QXhpc1wiLCBcInNlcmllc1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgdmFyIGQgPSB7fTtcbiAgICAgICAgICBhW2JdICYmIChkW2JdID0gYVtiXSwgci51cGRhdGUoZCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5heGVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICB2YXIgYiA9IEkoci5heGVzLCBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgcmV0dXJuIGIub3B0aW9ucy5pbnRlcm5hbEtleSA9PT0gYS51c2VyT3B0aW9ucy5pbnRlcm5hbEtleTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgZCA9IGEuZ2V0RXh0cmVtZXMoKSxcbiAgICAgICAgICAgICAgYyA9IGQudXNlck1pbjtcbiAgICAgICAgICBkID0gZC51c2VyTWF4O1xuICAgICAgICAgIGIgJiYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBjICYmIGMgIT09IGIubWluIHx8IFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBkICYmIGQgIT09IGIubWF4KSAmJiBiLnNldEV4dHJlbWVzKGMsIGQsICEwLCAhMSk7XG4gICAgICAgIH0pO1xuICAgICAgICBnID0gci5nZXRDaGFydEhUTUwoKTtcbiAgICAgICAgQih0aGlzLCBcImdldFNWR1wiLCB7XG4gICAgICAgICAgY2hhcnRDb3B5OiByXG4gICAgICAgIH0pO1xuICAgICAgICBnID0gdGhpcy5zYW5pdGl6ZVNWRyhnLCBjKTtcbiAgICAgICAgYyA9IG51bGw7XG4gICAgICAgIHIuZGVzdHJveSgpO1xuICAgICAgICBtKGQpO1xuICAgICAgICByZXR1cm4gZztcbiAgICAgIH0sXG4gICAgICBnZXRTVkdGb3JFeHBvcnQ6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5vcHRpb25zLmV4cG9ydGluZztcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U1ZHKHAoe1xuICAgICAgICAgIGNoYXJ0OiB7XG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGMuY2hhcnRPcHRpb25zLCBiLCB7XG4gICAgICAgICAgZXhwb3J0aW5nOiB7XG4gICAgICAgICAgICBzb3VyY2VXaWR0aDogYSAmJiBhLnNvdXJjZVdpZHRoIHx8IGMuc291cmNlV2lkdGgsXG4gICAgICAgICAgICBzb3VyY2VIZWlnaHQ6IGEgJiYgYS5zb3VyY2VIZWlnaHQgfHwgYy5zb3VyY2VIZWlnaHRcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICBnZXRGaWxlbmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMudXNlck9wdGlvbnMudGl0bGUgJiYgdGhpcy51c2VyT3B0aW9ucy50aXRsZS50ZXh0LFxuICAgICAgICAgICAgYiA9IHRoaXMub3B0aW9ucy5leHBvcnRpbmcuZmlsZW5hbWU7XG4gICAgICAgIGlmIChiKSByZXR1cm4gYi5yZXBsYWNlKC9cXC8vZywgXCItXCIpO1xuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgYSAmJiAoYiA9IGEudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC88XFwvP1tePl0rKD58JCkvZywgXCJcIikucmVwbGFjZSgvW1xcc19dKy9nLCBcIi1cIikucmVwbGFjZSgvW15hLXowLTlcXC1dL2csIFwiXCIpLnJlcGxhY2UoL15bXFwtXSsvZywgXCJcIikucmVwbGFjZSgvW1xcLV0rL2csIFwiLVwiKS5zdWJzdHIoMCwgMjQpLnJlcGxhY2UoL1tcXC1dKyQvZywgXCJcIikpO1xuICAgICAgICBpZiAoIWIgfHwgNSA+IGIubGVuZ3RoKSBiID0gXCJjaGFydFwiO1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0sXG4gICAgICBleHBvcnRDaGFydDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgYiA9IHRoaXMuZ2V0U1ZHRm9yRXhwb3J0KGEsIGIpO1xuICAgICAgICBhID0gcCh0aGlzLm9wdGlvbnMuZXhwb3J0aW5nLCBhKTtcbiAgICAgICAgZi5wb3N0KGEudXJsLCB7XG4gICAgICAgICAgZmlsZW5hbWU6IGEuZmlsZW5hbWUgPyBhLmZpbGVuYW1lLnJlcGxhY2UoL1xcLy9nLCBcIi1cIikgOiB0aGlzLmdldEZpbGVuYW1lKCksXG4gICAgICAgICAgdHlwZTogYS50eXBlLFxuICAgICAgICAgIHdpZHRoOiBhLndpZHRoIHx8IDAsXG4gICAgICAgICAgc2NhbGU6IGEuc2NhbGUsXG4gICAgICAgICAgc3ZnOiBiXG4gICAgICAgIH0sIGEuZm9ybUF0dHJpYnV0ZXMpO1xuICAgICAgfSxcbiAgICAgIG1vdmVDb250YWluZXJzOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAodGhpcy5maXhlZERpdiA/IFt0aGlzLmZpeGVkRGl2LCB0aGlzLnNjcm9sbGluZ0NvbnRhaW5lcl0gOiBbdGhpcy5jb250YWluZXJdKS5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYS5hcHBlbmRDaGlsZChiKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgYmVmb3JlUHJpbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB5LmJvZHksXG4gICAgICAgICAgICBiID0gdGhpcy5vcHRpb25zLmV4cG9ydGluZy5wcmludE1heFdpZHRoLFxuICAgICAgICAgICAgYyA9IHtcbiAgICAgICAgICBjaGlsZE5vZGVzOiBhLmNoaWxkTm9kZXMsXG4gICAgICAgICAgb3JpZ0Rpc3BsYXk6IFtdLFxuICAgICAgICAgIHJlc2V0UGFyYW1zOiB2b2lkIDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc1ByaW50aW5nID0gITA7XG4gICAgICAgIHRoaXMucG9pbnRlci5yZXNldChudWxsLCAwKTtcbiAgICAgICAgQih0aGlzLCBcImJlZm9yZVByaW50XCIpO1xuICAgICAgICBiICYmIHRoaXMuY2hhcnRXaWR0aCA+IGIgJiYgKGMucmVzZXRQYXJhbXMgPSBbdGhpcy5vcHRpb25zLmNoYXJ0LndpZHRoLCB2b2lkIDAsICExXSwgdGhpcy5zZXRTaXplKGIsIHZvaWQgMCwgITEpKTtcbiAgICAgICAgW10uZm9yRWFjaC5jYWxsKGMuY2hpbGROb2RlcywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAxID09PSBhLm5vZGVUeXBlICYmIChjLm9yaWdEaXNwbGF5W2JdID0gYS5zdHlsZS5kaXNwbGF5LCBhLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vdmVDb250YWluZXJzKGEpO1xuICAgICAgICB0aGlzLnByaW50UmV2ZXJzZUluZm8gPSBjO1xuICAgICAgfSxcbiAgICAgIGFmdGVyUHJpbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJpbnRSZXZlcnNlSW5mbykge1xuICAgICAgICAgIHZhciBhID0gdGhpcy5wcmludFJldmVyc2VJbmZvLmNoaWxkTm9kZXMsXG4gICAgICAgICAgICAgIGIgPSB0aGlzLnByaW50UmV2ZXJzZUluZm8ub3JpZ0Rpc3BsYXksXG4gICAgICAgICAgICAgIGMgPSB0aGlzLnByaW50UmV2ZXJzZUluZm8ucmVzZXRQYXJhbXM7XG4gICAgICAgICAgdGhpcy5tb3ZlQ29udGFpbmVycyh0aGlzLnJlbmRlclRvKTtcbiAgICAgICAgICBbXS5mb3JFYWNoLmNhbGwoYSwgZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgICAgIDEgPT09IGEubm9kZVR5cGUgJiYgKGEuc3R5bGUuZGlzcGxheSA9IGJbY10gfHwgXCJcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5pc1ByaW50aW5nID0gITE7XG4gICAgICAgICAgYyAmJiB0aGlzLnNldFNpemUuYXBwbHkodGhpcywgYyk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMucHJpbnRSZXZlcnNlSW5mbztcbiAgICAgICAgICBkZWxldGUgZi5wcmludGluZ0NoYXJ0O1xuICAgICAgICAgIEIodGhpcywgXCJhZnRlclByaW50XCIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJpbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICBhLmlzUHJpbnRpbmcgfHwgKGYucHJpbnRpbmdDaGFydCA9IGEsIGYuaXNTYWZhcmkgfHwgYS5iZWZvcmVQcmludCgpLCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB6LmZvY3VzKCk7XG4gICAgICAgICAgei5wcmludCgpO1xuICAgICAgICAgIGYuaXNTYWZhcmkgfHwgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhLmFmdGVyUHJpbnQoKTtcbiAgICAgICAgICB9LCAxRTMpO1xuICAgICAgICB9LCAxKSk7XG4gICAgICB9LFxuICAgICAgY29udGV4dE1lbnU6IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmLCByKSB7XG4gICAgICAgIHZhciBrID0gdGhpcyxcbiAgICAgICAgICAgIEQgPSBrLm9wdGlvbnMubmF2aWdhdGlvbixcbiAgICAgICAgICAgIHAgPSBrLmNoYXJ0V2lkdGgsXG4gICAgICAgICAgICBBID0gay5jaGFydEhlaWdodCxcbiAgICAgICAgICAgIHQgPSBcImNhY2hlLVwiICsgYSxcbiAgICAgICAgICAgIGwgPSBrW3RdLFxuICAgICAgICAgICAgdiA9IE1hdGgubWF4KGUsIGYpO1xuXG4gICAgICAgIGlmICghbCkge1xuICAgICAgICAgIGsuZXhwb3J0Q29udGV4dE1lbnUgPSBrW3RdID0gbCA9IGgoXCJkaXZcIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBhXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHpJbmRleDogMUUzLFxuICAgICAgICAgICAgcGFkZGluZzogdiArIFwicHhcIixcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiXG4gICAgICAgICAgfSwgay5maXhlZERpdiB8fCBrLmNvbnRhaW5lcik7XG4gICAgICAgICAgdmFyIG0gPSBoKFwidWxcIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImhpZ2hjaGFydHMtbWVudVwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbGlzdFN0eWxlOiBcIm5vbmVcIixcbiAgICAgICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgICAgIHBhZGRpbmc6IDBcbiAgICAgICAgICB9LCBsKTtcbiAgICAgICAgICBrLnN0eWxlZE1vZGUgfHwgdShtLCB4KHtcbiAgICAgICAgICAgIE1vekJveFNoYWRvdzogXCIzcHggM3B4IDEwcHggIzg4OFwiLFxuICAgICAgICAgICAgV2Via2l0Qm94U2hhZG93OiBcIjNweCAzcHggMTBweCAjODg4XCIsXG4gICAgICAgICAgICBib3hTaGFkb3c6IFwiM3B4IDNweCAxMHB4ICM4ODhcIlxuICAgICAgICAgIH0sIEQubWVudVN0eWxlKSk7XG5cbiAgICAgICAgICBsLmhpZGVNZW51ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdShsLCB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHIgJiYgci5zZXRTdGF0ZSgwKTtcbiAgICAgICAgICAgIGsub3Blbk1lbnUgPSAhMTtcbiAgICAgICAgICAgIHUoay5yZW5kZXJUbywge1xuICAgICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBnLmNsZWFyVGltZW91dChsLmhpZGVUaW1lcik7XG4gICAgICAgICAgICBCKGssIFwiZXhwb3J0TWVudUhpZGRlblwiKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgay5leHBvcnRFdmVudHMucHVzaChuKGwsIFwibW91c2VsZWF2ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsLmhpZGVUaW1lciA9IHouc2V0VGltZW91dChsLmhpZGVNZW51LCA1MDApO1xuICAgICAgICAgIH0pLCBuKGwsIFwibW91c2VlbnRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBnLmNsZWFyVGltZW91dChsLmhpZGVUaW1lcik7XG4gICAgICAgICAgfSksIG4oeSwgXCJtb3VzZXVwXCIsIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICBrLnBvaW50ZXIuaW5DbGFzcyhiLnRhcmdldCwgYSkgfHwgbC5oaWRlTWVudSgpO1xuICAgICAgICAgIH0pLCBuKGwsIFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgay5vcGVuTWVudSAmJiBsLmhpZGVNZW51KCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGIuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGEgJiYgKGEgPSBrLm9wdGlvbnMuZXhwb3J0aW5nLm1lbnVJdGVtRGVmaW5pdGlvbnNbYV0pO1xuXG4gICAgICAgICAgICBpZiAoSihhLCAhMCkpIHtcbiAgICAgICAgICAgICAgaWYgKGEuc2VwYXJhdG9yKSB2YXIgYiA9IGgoXCJoclwiLCBudWxsLCBudWxsLCBtKTtlbHNlIGIgPSBoKFwibGlcIiwge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJoaWdoY2hhcnRzLW1lbnUtaXRlbVwiLFxuICAgICAgICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAgICAgICBiICYmIGIuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICBsLmhpZGVNZW51KCk7XG4gICAgICAgICAgICAgICAgICBhLm9uY2xpY2sgJiYgYS5vbmNsaWNrLmFwcGx5KGssIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbm5lckhUTUw6IGEudGV4dCB8fCBrLm9wdGlvbnMubGFuZ1thLnRleHRLZXldXG4gICAgICAgICAgICAgIH0sIG51bGwsIG0pLCBrLnN0eWxlZE1vZGUgfHwgKGIub25tb3VzZW92ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdSh0aGlzLCBELm1lbnVJdGVtSG92ZXJTdHlsZSk7XG4gICAgICAgICAgICAgIH0sIGIub25tb3VzZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB1KHRoaXMsIEQubWVudUl0ZW1TdHlsZSk7XG4gICAgICAgICAgICAgIH0sIHUoYiwgeCh7XG4gICAgICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgICAgICAgICAgICB9LCBELm1lbnVJdGVtU3R5bGUpKSk7XG4gICAgICAgICAgICAgIGsuZXhwb3J0RGl2RWxlbWVudHMucHVzaChiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBrLmV4cG9ydERpdkVsZW1lbnRzLnB1c2gobSwgbCk7XG4gICAgICAgICAgay5leHBvcnRNZW51V2lkdGggPSBsLm9mZnNldFdpZHRoO1xuICAgICAgICAgIGsuZXhwb3J0TWVudUhlaWdodCA9IGwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgYiA9IHtcbiAgICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCJcbiAgICAgICAgfTtcbiAgICAgICAgYyArIGsuZXhwb3J0TWVudVdpZHRoID4gcCA/IGIucmlnaHQgPSBwIC0gYyAtIGUgLSB2ICsgXCJweFwiIDogYi5sZWZ0ID0gYyAtIHYgKyBcInB4XCI7XG4gICAgICAgIGQgKyBmICsgay5leHBvcnRNZW51SGVpZ2h0ID4gQSAmJiBcInRvcFwiICE9PSByLmFsaWduT3B0aW9ucy52ZXJ0aWNhbEFsaWduID8gYi5ib3R0b20gPSBBIC0gZCAtIHYgKyBcInB4XCIgOiBiLnRvcCA9IGQgKyBmIC0gdiArIFwicHhcIjtcbiAgICAgICAgdShsLCBiKTtcbiAgICAgICAgdShrLnJlbmRlclRvLCB7XG4gICAgICAgICAgb3ZlcmZsb3c6IFwiXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGsub3Blbk1lbnUgPSAhMDtcbiAgICAgICAgQihrLCBcImV4cG9ydE1lbnVTaG93blwiKTtcbiAgICAgIH0sXG4gICAgICBhZGRCdXR0b246IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBiID0gdGhpcyxcbiAgICAgICAgICAgIGMgPSBiLnJlbmRlcmVyLFxuICAgICAgICAgICAgZCA9IHAoYi5vcHRpb25zLm5hdmlnYXRpb24uYnV0dG9uT3B0aW9ucywgYSksXG4gICAgICAgICAgICBnID0gZC5vbmNsaWNrLFxuICAgICAgICAgICAgZSA9IGQubWVudUl0ZW1zLFxuICAgICAgICAgICAgZiA9IGQuc3ltYm9sU2l6ZSB8fCAxMjtcbiAgICAgICAgYi5idG5Db3VudCB8fCAoYi5idG5Db3VudCA9IDApO1xuICAgICAgICBiLmV4cG9ydERpdkVsZW1lbnRzIHx8IChiLmV4cG9ydERpdkVsZW1lbnRzID0gW10sIGIuZXhwb3J0U1ZHRWxlbWVudHMgPSBbXSk7XG5cbiAgICAgICAgaWYgKCExICE9PSBkLmVuYWJsZWQpIHtcbiAgICAgICAgICB2YXIgayA9IGQudGhlbWUsXG4gICAgICAgICAgICAgIGggPSBrLnN0YXRlcyxcbiAgICAgICAgICAgICAgbSA9IGggJiYgaC5ob3ZlcjtcbiAgICAgICAgICBoID0gaCAmJiBoLnNlbGVjdDtcbiAgICAgICAgICB2YXIgQTtcbiAgICAgICAgICBiLnN0eWxlZE1vZGUgfHwgKGsuZmlsbCA9IHEoay5maWxsLCBcIiNmZmZmZmZcIiksIGsuc3Ryb2tlID0gcShrLnN0cm9rZSwgXCJub25lXCIpKTtcbiAgICAgICAgICBkZWxldGUgay5zdGF0ZXM7XG4gICAgICAgICAgZyA/IEEgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgYSAmJiBhLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZy5jYWxsKGIsIGEpO1xuICAgICAgICAgIH0gOiBlICYmIChBID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGEgJiYgYS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGIuY29udGV4dE1lbnUodC5tZW51Q2xhc3NOYW1lLCBlLCB0LnRyYW5zbGF0ZVgsIHQudHJhbnNsYXRlWSwgdC53aWR0aCwgdC5oZWlnaHQsIHQpO1xuICAgICAgICAgICAgdC5zZXRTdGF0ZSgyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkLnRleHQgJiYgZC5zeW1ib2wgPyBrLnBhZGRpbmdMZWZ0ID0gcShrLnBhZGRpbmdMZWZ0LCAyNSkgOiBkLnRleHQgfHwgeChrLCB7XG4gICAgICAgICAgICB3aWR0aDogZC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogZC5oZWlnaHQsXG4gICAgICAgICAgICBwYWRkaW5nOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYi5zdHlsZWRNb2RlIHx8IChrW1wic3Ryb2tlLWxpbmVjYXBcIl0gPSBcInJvdW5kXCIsIGsuZmlsbCA9IHEoay5maWxsLCBcIiNmZmZmZmZcIiksIGsuc3Ryb2tlID0gcShrLnN0cm9rZSwgXCJub25lXCIpKTtcbiAgICAgICAgICB2YXIgdCA9IGMuYnV0dG9uKGQudGV4dCwgMCwgMCwgQSwgaywgbSwgaCkuYWRkQ2xhc3MoYS5jbGFzc05hbWUpLmF0dHIoe1xuICAgICAgICAgICAgdGl0bGU6IHEoYi5vcHRpb25zLmxhbmdbZC5fdGl0bGVLZXkgfHwgZC50aXRsZUtleV0sIFwiXCIpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdC5tZW51Q2xhc3NOYW1lID0gYS5tZW51Q2xhc3NOYW1lIHx8IFwiaGlnaGNoYXJ0cy1tZW51LVwiICsgYi5idG5Db3VudCsrO1xuXG4gICAgICAgICAgaWYgKGQuc3ltYm9sKSB7XG4gICAgICAgICAgICB2YXIgbCA9IGMuc3ltYm9sKGQuc3ltYm9sLCBkLnN5bWJvbFggLSBmIC8gMiwgZC5zeW1ib2xZIC0gZiAvIDIsIGYsIGYsIHtcbiAgICAgICAgICAgICAgd2lkdGg6IGYsXG4gICAgICAgICAgICAgIGhlaWdodDogZlxuICAgICAgICAgICAgfSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWJ1dHRvbi1zeW1ib2xcIikuYXR0cih7XG4gICAgICAgICAgICAgIHpJbmRleDogMVxuICAgICAgICAgICAgfSkuYWRkKHQpO1xuICAgICAgICAgICAgYi5zdHlsZWRNb2RlIHx8IGwuYXR0cih7XG4gICAgICAgICAgICAgIHN0cm9rZTogZC5zeW1ib2xTdHJva2UsXG4gICAgICAgICAgICAgIGZpbGw6IGQuc3ltYm9sRmlsbCxcbiAgICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogZC5zeW1ib2xTdHJva2VXaWR0aCB8fCAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0LmFkZChiLmV4cG9ydGluZ0dyb3VwKS5hbGlnbih4KGQsIHtcbiAgICAgICAgICAgIHdpZHRoOiB0LndpZHRoLFxuICAgICAgICAgICAgeDogcShkLngsIGIuYnV0dG9uT2Zmc2V0KVxuICAgICAgICAgIH0pLCAhMCwgXCJzcGFjaW5nQm94XCIpO1xuICAgICAgICAgIGIuYnV0dG9uT2Zmc2V0ICs9ICh0LndpZHRoICsgZC5idXR0b25TcGFjaW5nKSAqIChcInJpZ2h0XCIgPT09IGQuYWxpZ24gPyAtMSA6IDEpO1xuICAgICAgICAgIGIuZXhwb3J0U1ZHRWxlbWVudHMucHVzaCh0LCBsKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlc3Ryb3lFeHBvcnQ6IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBiID0gYSA/IGEudGFyZ2V0IDogdGhpcztcbiAgICAgICAgYSA9IGIuZXhwb3J0U1ZHRWxlbWVudHM7XG4gICAgICAgIHZhciBjID0gYi5leHBvcnREaXZFbGVtZW50cyxcbiAgICAgICAgICAgIGQgPSBiLmV4cG9ydEV2ZW50cyxcbiAgICAgICAgICAgIGY7XG4gICAgICAgIGEgJiYgKGEuZm9yRWFjaChmdW5jdGlvbiAoYSwgZCkge1xuICAgICAgICAgIGEgJiYgKGEub25jbGljayA9IGEub250b3VjaHN0YXJ0ID0gbnVsbCwgZiA9IFwiY2FjaGUtXCIgKyBhLm1lbnVDbGFzc05hbWUsIGJbZl0gJiYgZGVsZXRlIGJbZl0sIGIuZXhwb3J0U1ZHRWxlbWVudHNbZF0gPSBhLmRlc3Ryb3koKSk7XG4gICAgICAgIH0pLCBhLmxlbmd0aCA9IDApO1xuICAgICAgICBiLmV4cG9ydGluZ0dyb3VwICYmIChiLmV4cG9ydGluZ0dyb3VwLmRlc3Ryb3koKSwgZGVsZXRlIGIuZXhwb3J0aW5nR3JvdXApO1xuICAgICAgICBjICYmIChjLmZvckVhY2goZnVuY3Rpb24gKGEsIGQpIHtcbiAgICAgICAgICBnLmNsZWFyVGltZW91dChhLmhpZGVUaW1lcik7XG4gICAgICAgICAgSyhhLCBcIm1vdXNlbGVhdmVcIik7XG4gICAgICAgICAgYi5leHBvcnREaXZFbGVtZW50c1tkXSA9IGEub25tb3VzZW91dCA9IGEub25tb3VzZW92ZXIgPSBhLm9udG91Y2hzdGFydCA9IGEub25jbGljayA9IG51bGw7XG4gICAgICAgICAgbShhKTtcbiAgICAgICAgfSksIGMubGVuZ3RoID0gMCk7XG4gICAgICAgIGQgJiYgKGQuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIGEoKTtcbiAgICAgICAgfSksIGQubGVuZ3RoID0gMCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgRi5wcm90b3R5cGUuaW5saW5lVG9BdHRyaWJ1dGVzID0gXCJmaWxsIHN0cm9rZSBzdHJva2VMaW5lY2FwIHN0cm9rZUxpbmVqb2luIHN0cm9rZVdpZHRoIHRleHRBbmNob3IgeCB5XCIuc3BsaXQoXCIgXCIpO1xuICAgIEYucHJvdG90eXBlLmlubGluZUJsYWNrbGlzdCA9IFsvLS8sIC9eKGNsaXBQYXRofGNzc1RleHR8ZHxoZWlnaHR8d2lkdGgpJC8sIC9eZm9udCQvLCAvW2xMXW9naWNhbChXaWR0aHxIZWlnaHQpJC8sIC9wZXJzcGVjdGl2ZS8sIC9UYXBIaWdobGlnaHRDb2xvci8sIC9edHJhbnNpdGlvbi8sIC9ebGVuZ3RoJC9dO1xuICAgIEYucHJvdG90eXBlLnVuc3R5bGVkRWxlbWVudHMgPSBbXCJjbGlwUGF0aFwiLCBcImRlZnNcIiwgXCJkZXNjXCJdO1xuXG4gICAgQy5wcm90b3R5cGUuaW5saW5lU3R5bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gYShhKSB7XG4gICAgICAgIHJldHVybiBhLnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gXCItXCIgKyBiLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBiKGMpIHtcbiAgICAgICAgZnVuY3Rpb24gayhiLCBlKSB7XG4gICAgICAgICAgdiA9IHUgPSAhMTtcblxuICAgICAgICAgIGlmIChnKSB7XG4gICAgICAgICAgICBmb3IgKHEgPSBnLmxlbmd0aDsgcS0tICYmICF1OykgdSA9IGdbcV0udGVzdChlKTtcblxuICAgICAgICAgICAgdiA9ICF1O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFwidHJhbnNmb3JtXCIgPT09IGUgJiYgXCJub25lXCIgPT09IGIgJiYgKHYgPSAhMCk7XG5cbiAgICAgICAgICBmb3IgKHEgPSBmLmxlbmd0aDsgcS0tICYmICF2OykgdiA9IGZbcV0udGVzdChlKSB8fCBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBiO1xuXG4gICAgICAgICAgdiB8fCB4W2VdID09PSBiICYmIFwic3ZnXCIgIT09IGMubm9kZU5hbWUgfHwgaFtjLm5vZGVOYW1lXVtlXSA9PT0gYiB8fCAoLTEgIT09IGQuaW5kZXhPZihlKSA/IGMuc2V0QXR0cmlidXRlKGEoZSksIGIpIDogbCArPSBhKGUpICsgXCI6XCIgKyBiICsgXCI7XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGwgPSBcIlwiLFxuICAgICAgICAgICAgdixcbiAgICAgICAgICAgIHUsXG4gICAgICAgICAgICBxO1xuXG4gICAgICAgIGlmICgxID09PSBjLm5vZGVUeXBlICYmIC0xID09PSBlLmluZGV4T2YoYy5ub2RlTmFtZSkpIHtcbiAgICAgICAgICB2YXIgciA9IHouZ2V0Q29tcHV0ZWRTdHlsZShjLCBudWxsKTtcbiAgICAgICAgICB2YXIgeCA9IFwic3ZnXCIgPT09IGMubm9kZU5hbWUgPyB7fSA6IHouZ2V0Q29tcHV0ZWRTdHlsZShjLnBhcmVudE5vZGUsIG51bGwpO1xuXG4gICAgICAgICAgaWYgKCFoW2Mubm9kZU5hbWVdKSB7XG4gICAgICAgICAgICBtID0gbi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN2Z1wiKVswXTtcbiAgICAgICAgICAgIHZhciB3ID0gbi5jcmVhdGVFbGVtZW50TlMoYy5uYW1lc3BhY2VVUkksIGMubm9kZU5hbWUpO1xuICAgICAgICAgICAgbS5hcHBlbmRDaGlsZCh3KTtcbiAgICAgICAgICAgIGhbYy5ub2RlTmFtZV0gPSBwKHouZ2V0Q29tcHV0ZWRTdHlsZSh3LCBudWxsKSk7XG4gICAgICAgICAgICBcInRleHRcIiA9PT0gYy5ub2RlTmFtZSAmJiBkZWxldGUgaC50ZXh0LmZpbGw7XG4gICAgICAgICAgICBtLnJlbW92ZUNoaWxkKHcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChPIHx8IE4pIGZvciAodmFyIHkgaW4gcikgayhyW3ldLCB5KTtlbHNlIEUociwgayk7XG4gICAgICAgICAgbCAmJiAociA9IGMuZ2V0QXR0cmlidXRlKFwic3R5bGVcIiksIGMuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgKHIgPyByICsgXCI7XCIgOiBcIlwiKSArIGwpKTtcbiAgICAgICAgICBcInN2Z1wiID09PSBjLm5vZGVOYW1lICYmIGMuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIFwiMXB4XCIpO1xuICAgICAgICAgIFwidGV4dFwiICE9PSBjLm5vZGVOYW1lICYmIFtdLmZvckVhY2guY2FsbChjLmNoaWxkcmVuIHx8IGMuY2hpbGROb2RlcywgYik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGMgPSB0aGlzLnJlbmRlcmVyLFxuICAgICAgICAgIGQgPSBjLmlubGluZVRvQXR0cmlidXRlcyxcbiAgICAgICAgICBmID0gYy5pbmxpbmVCbGFja2xpc3QsXG4gICAgICAgICAgZyA9IGMuaW5saW5lV2hpdGVsaXN0LFxuICAgICAgICAgIGUgPSBjLnVuc3R5bGVkRWxlbWVudHMsXG4gICAgICAgICAgaCA9IHt9LFxuICAgICAgICAgIG07XG4gICAgICBjID0geS5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgdShjLCB7XG4gICAgICAgIHdpZHRoOiBcIjFweFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMXB4XCIsXG4gICAgICAgIHZpc2liaWxpdHk6IFwiaGlkZGVuXCJcbiAgICAgIH0pO1xuICAgICAgeS5ib2R5LmFwcGVuZENoaWxkKGMpO1xuICAgICAgdmFyIG4gPSBjLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgICBuLm9wZW4oKTtcbiAgICAgIG4ud3JpdGUoJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjwvc3ZnPicpO1xuICAgICAgbi5jbG9zZSgpO1xuICAgICAgYih0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpKTtcbiAgICAgIG0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtKTtcbiAgICB9O1xuXG4gICAgSC5tZW51ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICAgIHJldHVybiBbXCJNXCIsIGEsIGIgKyAyLjUsIFwiTFwiLCBhICsgYywgYiArIDIuNSwgXCJNXCIsIGEsIGIgKyBkIC8gMiArIC41LCBcIkxcIiwgYSArIGMsIGIgKyBkIC8gMiArIC41LCBcIk1cIiwgYSwgYiArIGQgLSAxLjUsIFwiTFwiLCBhICsgYywgYiArIGQgLSAxLjVdO1xuICAgIH07XG5cbiAgICBILm1lbnViYWxsID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICAgIGEgPSBbXTtcbiAgICAgIGQgPSBkIC8gMyAtIDI7XG4gICAgICByZXR1cm4gYSA9IGEuY29uY2F0KHRoaXMuY2lyY2xlKGMgLSBkLCBiLCBkLCBkKSwgdGhpcy5jaXJjbGUoYyAtIGQsIGIgKyBkICsgNCwgZCwgZCksIHRoaXMuY2lyY2xlKGMgLSBkLCBiICsgMiAqIChkICsgNCksIGQsIGQpKTtcbiAgICB9O1xuXG4gICAgQy5wcm90b3R5cGUucmVuZGVyRXhwb3J0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGEgPSB0aGlzLFxuICAgICAgICAgIGIgPSBhLm9wdGlvbnMuZXhwb3J0aW5nLFxuICAgICAgICAgIGMgPSBiLmJ1dHRvbnMsXG4gICAgICAgICAgZCA9IGEuaXNEaXJ0eUV4cG9ydGluZyB8fCAhYS5leHBvcnRTVkdFbGVtZW50cztcbiAgICAgIGEuYnV0dG9uT2Zmc2V0ID0gMDtcbiAgICAgIGEuaXNEaXJ0eUV4cG9ydGluZyAmJiBhLmRlc3Ryb3lFeHBvcnQoKTtcbiAgICAgIGQgJiYgITEgIT09IGIuZW5hYmxlZCAmJiAoYS5leHBvcnRFdmVudHMgPSBbXSwgYS5leHBvcnRpbmdHcm91cCA9IGEuZXhwb3J0aW5nR3JvdXAgfHwgYS5yZW5kZXJlci5nKFwiZXhwb3J0aW5nLWdyb3VwXCIpLmF0dHIoe1xuICAgICAgICB6SW5kZXg6IDNcbiAgICAgIH0pLmFkZCgpLCBFKGMsIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIGEuYWRkQnV0dG9uKGIpO1xuICAgICAgfSksIGEuaXNEaXJ0eUV4cG9ydGluZyA9ICExKTtcbiAgICAgIG4oYSwgXCJkZXN0cm95XCIsIGEuZGVzdHJveUV4cG9ydCk7XG4gICAgfTtcblxuICAgIG4oQywgXCJpbml0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhID0gdGhpcztcbiAgICAgIGEuZXhwb3J0aW5nID0ge1xuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChiLCBjKSB7XG4gICAgICAgICAgYS5pc0RpcnR5RXhwb3J0aW5nID0gITA7XG4gICAgICAgICAgcCghMCwgYS5vcHRpb25zLmV4cG9ydGluZywgYik7XG4gICAgICAgICAgcShjLCAhMCkgJiYgYS5yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGUuYWRkVXBkYXRlKGZ1bmN0aW9uIChiLCBjKSB7XG4gICAgICAgIGEuaXNEaXJ0eUV4cG9ydGluZyA9ICEwO1xuICAgICAgICBwKCEwLCBhLm9wdGlvbnMubmF2aWdhdGlvbiwgYik7XG4gICAgICAgIHEoYywgITApICYmIGEucmVkcmF3KCk7XG4gICAgICB9LCBhKTtcbiAgICB9KTtcbiAgICBDLnByb3RvdHlwZS5jYWxsYmFja3MucHVzaChmdW5jdGlvbiAoYSkge1xuICAgICAgYS5yZW5kZXJFeHBvcnRpbmcoKTtcbiAgICAgIG4oYSwgXCJyZWRyYXdcIiwgYS5yZW5kZXJFeHBvcnRpbmcpO1xuICAgIH0pO1xuICB9KTtcbiAgbShlLCBcIm1hc3RlcnMvbW9kdWxlcy9leHBvcnRpbmcuc3JjLmpzXCIsIFtdLCBmdW5jdGlvbiAoKSB7fSk7XG59KTsiLCJ2YXIgZzsgLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcblxuZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59KCk7XG5cbnRyeSB7XG4gIC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuICBnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuICAvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn0gLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7IiwiaW1wb3J0IFwiLi9zdHlsZXMvaW5kZXguc2Nzc1wiO1xyXG5pbXBvcnQgeyBjYXJkU2VhcmNoZXIgfSBmcm9tICcuL3NjcmlwdHMvY2FyZF9zZWFyY2hlcic7XHJcbmltcG9ydCBjYXJkR2VuZXJhdG9yIGZyb20gJy4vc2NyaXB0cy9jYXJkX2dlbmVyYXRvcic7XHJcblxyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4ge1xyXG4gIGNvbnN0IGJvYXJkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICBjb25zdCBzZWFyY2hCYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKTtcclxuICBjb25zdCBpbnB1dEZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xyXG4gIGNvbnN0IHN1Ym1pdEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XHJcbiAgY29uc3Qgc2VhcmNoSWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpXCIpO1xyXG4gIGNvbnN0IHRpdGxlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaDFcIik7XHJcbiAgY29uc3QgdGl0bGVJbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xyXG4gIGNvbnN0IG5hdkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIGNvbnN0IGdpdExpbmtJbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcclxuICBjb25zdCBsaW5rZWRpbkxpbmtJbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcclxuICBjb25zdCBhbmdlbExpbmtJbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcclxuICBjb25zdCBnaXRMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgY29uc3QgbGlua2VkaW5MaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgY29uc3QgYW5nZWxMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgY29uc3QgZXJyb3JzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICBjb25zdCBpbnN0cnVjdGlvbnNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBjb25zdCBpbnN0cnVjdGlvbnNCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcclxuXHJcbiAgaW5zdHJ1Y3Rpb25zQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2luc3RydWN0aW9ucy1jb250YWluZXInKTtcclxuICBpbnN0cnVjdGlvbnNDb250YWluZXIuYXBwZW5kKGluc3RydWN0aW9uc0J1dHRvbilcclxuXHJcbiAgZXJyb3JzQ29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaWQnLCBcImVycm9ycy1jb250YWluZXJcIik7XHJcblxyXG4gIGdpdExpbmsuYXBwZW5kKGdpdExpbmtJbWcpO1xyXG4gIGdpdExpbmsuY2xhc3NMaXN0LmFkZCgnbmF2LWxpbmsnKTtcclxuICBnaXRMaW5rLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgXCJodHRwczovL2dpdGh1Yi5jb20vTm9ydG9uLURlc2lnbi9jYXJkQXVndXJ5XCIpO1xyXG4gIGdpdExpbmsuc2V0QXR0cmlidXRlKFwidGFyZ2V0XCIsIFwiX2JsYW5rXCIpO1xyXG4gIGdpdExpbmsuc2V0QXR0cmlidXRlKFwicmVsXCIsIFwibm9vcGVuZXIgbm9yZWZlcnJlclwiKTtcclxuICBnaXRMaW5rLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnR2l0aHViIFJlcG8nKTtcclxuXHJcbiAgbGlua2VkaW5MaW5rLmFwcGVuZChsaW5rZWRpbkxpbmtJbWcpO1xyXG4gIGxpbmtlZGluTGluay5jbGFzc0xpc3QuYWRkKCduYXYtbGluaycpO1xyXG4gIGxpbmtlZGluTGluay5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIFwiaHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL21pY2hhZWwtbm9ydG9uLTViNTU1OTE5OS9cIik7XHJcbiAgbGlua2VkaW5MaW5rLnNldEF0dHJpYnV0ZShcInRhcmdldFwiLCBcIl9ibGFua1wiKTtcclxuICBsaW5rZWRpbkxpbmsuc2V0QXR0cmlidXRlKFwicmVsXCIsIFwibm9vcGVuZXIgbm9yZWZlcnJlclwiKTtcclxuICBsaW5rZWRpbkxpbmsuc2V0QXR0cmlidXRlKCd0aXRsZScsICdMaW5rZWRpbiBMaW5rJylcclxuXHJcbiAgYW5nZWxMaW5rLmFwcGVuZChhbmdlbExpbmtJbWcpO1xyXG4gIGFuZ2VsTGluay5jbGFzc0xpc3QuYWRkKCduYXYtbGluaycpO1xyXG4gIGFuZ2VsTGluay5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIFwiaHR0cHM6Ly9hbmdlbC5jby91L21pY2hhZWwtbm9ydG9uLTE3XCIpO1xyXG4gIGFuZ2VsTGluay5zZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIiwgXCJfYmxhbmtcIik7XHJcbiAgYW5nZWxMaW5rLnNldEF0dHJpYnV0ZShcInJlbFwiLCBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIik7XHJcbiAgYW5nZWxMaW5rLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIFwiQW5nZWxsaXN0IExpbmtcIik7XHJcblxyXG4gIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChcImNlbnRlclwiKTtcclxuICBkb2N1bWVudC5ib2R5LmFwcGVuZChib2FyZCk7XHJcblxyXG4gIGJvYXJkLmNsYXNzTGlzdC5hZGQoXCJib2FyZFwiLCBcImNlbnRlclwiKTtcclxuICBib2FyZC5zZXRBdHRyaWJ1dGUoJ2lkJywgXCJtYWluLWJvYXJkXCIpXHJcbiAgYm9hcmQuYXBwZW5kKGluc3RydWN0aW9uc0NvbnRhaW5lcilcclxuICBib2FyZC5hcHBlbmQoZXJyb3JzQ29udGFpbmVyKTtcclxuICBib2FyZC5hcHBlbmQodGl0bGVDb250YWluZXIpXHJcbiAgYm9hcmQuYXBwZW5kKHNlYXJjaEJhcik7XHJcbiAgYm9hcmQuYXBwZW5kKG5hdkNvbnRhaW5lcik7XHJcblxyXG4gIHRpdGxlQ29udGFpbmVyLmFwcGVuZCh0aXRsZUltZyk7XHJcbiAgdGl0bGVDb250YWluZXIuYXBwZW5kKHRpdGxlKTtcclxuICB0aXRsZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGl0bGUtY29udGFpbmVyXCIpXHJcblxyXG4gIG5hdkNvbnRhaW5lci5hcHBlbmQoZ2l0TGluayk7XHJcbiAgbmF2Q29udGFpbmVyLmFwcGVuZChsaW5rZWRpbkxpbmspO1xyXG4gIG5hdkNvbnRhaW5lci5hcHBlbmQoYW5nZWxMaW5rKVxyXG4gIG5hdkNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCduYXYnKTtcclxuXHJcbiAgdGl0bGVJbWcuc2V0QXR0cmlidXRlKFwic3JjXCIsIFwiLi9zcmMvaW1hZ2VzL2ZpbmFsLW93bDIucG5nXCIpXHJcblxyXG4gIHRpdGxlLmlubmVySFRNTCA9IFwiQ2FyZCBBdWd1cnlcIjtcclxuXHJcbiAgc2VhcmNoSWNvbi5jbGFzc0xpc3QuYWRkKFwiZmFcIik7XHJcbiAgc2VhcmNoSWNvbi5jbGFzc0xpc3QuYWRkKFwiZmEtc2VhcmNoXCIpO1xyXG5cclxuICBsaW5rZWRpbkxpbmtJbWcuY2xhc3NMaXN0LmFkZCgnZmEnKTtcclxuICBsaW5rZWRpbkxpbmtJbWcuY2xhc3NMaXN0LmFkZCgnZmEtbGlua2VkaW4nKTtcclxuXHJcbiAgZ2l0TGlua0ltZy5jbGFzc0xpc3QuYWRkKCdmYScpO1xyXG4gIGdpdExpbmtJbWcuY2xhc3NMaXN0LmFkZCgnZmEtZ2l0aHViJyk7XHJcblxyXG4gIGFuZ2VsTGlua0ltZy5jbGFzc0xpc3QuYWRkKCdmYScpO1xyXG4gIGFuZ2VsTGlua0ltZy5jbGFzc0xpc3QuYWRkKCdmYS1hbmdlbGxpc3QnKTtcclxuXHJcbiAgc3VibWl0QnV0dG9uLmFwcGVuZChzZWFyY2hJY29uKTtcclxuICBzdWJtaXRCdXR0b24uY2xhc3NMaXN0LmFkZCgnc2VhcmNoLWJ1dHRvbicpO1xyXG5cclxuICBpbnN0cnVjdGlvbnNCdXR0b24uY2xhc3NMaXN0LmFkZChcImZhXCIpO1xyXG4gIGluc3RydWN0aW9uc0J1dHRvbi5jbGFzc0xpc3QuYWRkKFwiZmEtYmFyc1wiKTtcclxuXHJcbiAgaW5wdXRGaWVsZC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNlYXJjaGJhclwiKTtcclxuICBpbnB1dEZpZWxkLnNldEF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIsIFwiU2VhcmNoIGZvciBhIGNhcmQuLi5cIik7XHJcbiAgaW5wdXRGaWVsZC5jbGFzc0xpc3QuYWRkKFwic2VhcmNoYmFyXCIpO1xyXG5cclxuICBzZWFyY2hCYXIuY2xhc3NMaXN0LmFkZChcInNlYXJjaGJhci1jb250YWluZXJcIik7XHJcbiAgc2VhcmNoQmFyLmFwcGVuZChpbnB1dEZpZWxkKTtcclxuICBzZWFyY2hCYXIuYXBwZW5kKHN1Ym1pdEJ1dHRvbik7XHJcblxyXG4gIGNvbnN0IG1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtb2RhbFwiKTtcclxuICBjb25zdCBzcGFuID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImNsb3NlXCIpWzBdO1xyXG5cclxuICB3aW5kb3cub25jbGljayA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09IG1vZGFsKSB7XHJcbiAgICAgIG1vZGFsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNwYW4ub25jbGljayA9IGZ1bmN0aW9uKCkge1xyXG4gICAgbW9kYWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gIH1cclxuXHJcbiAgaW5zdHJ1Y3Rpb25zQnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcclxuICAgIG1vZGFsLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgfVxyXG5cclxuICBzdWJtaXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgIFxyXG4gICAgY2FyZFNlYXJjaGVyKClcclxuICAgICAgLnRoZW4oY2FyZCA9PiB7XHJcbiAgICAgICAgY29uc3QgbmF2Q29uID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIm5hdlwiKVswXTtcclxuICAgICAgICBpZiAobmF2Q29uKSB7XHJcbiAgICAgICAgICBib2FyZC5yZW1vdmVDaGlsZChuYXZDb250YWluZXIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhcmRHZW5lcmF0b3IoY2FyZCk7XHJcbiAgICAgICAgYm9hcmQuYXBwZW5kKG5hdkNvbnRhaW5lcilcclxuXHJcbiAgICAgICAgaWYgKGNhcmQub2JqZWN0KSB7XHJcbiAgICAgICAgICBib2FyZC5zdHlsZS5tYXJnaW4gPSBcIjAgNXJlbSAwIHJlbSA1cmVtXCI7XHJcbiAgICAgICAgICBib2FyZC5zdHlsZS5taW5IZWlnaHQgPSAnaW5oZXJpdCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RydWN0aW9uc0NvbnRhaW5lci5zdHlsZS5tYXJnaW4gPSBcIjEuMnJlbSAwXCI7XHJcbiAgICAgIH0pXHJcbiAgfSlcclxufSk7XHJcblxyXG4iLCJpbXBvcnQgeyBzZXRGZXRjaGVyIH0gZnJvbSAnLi9zZXRfZmV0Y2hlcidcclxuaW1wb3J0IHsgdHlwZVRvdGFscyB9IGZyb20gJy4vc2V0X3N0YXRzX3V0aWwnO1xyXG5pbXBvcnQgeyBtYW5hSW1hZ2VHZW5lcmF0b3IsIG9yYWNsZVRleHRIYW5kbGVyIH0gZnJvbSAnLi9jYXJkX3V0aWwnXHJcbmltcG9ydCAnYmFiZWwtcG9seWZpbGwnO1xyXG5jb25zdCBIaWdoY2hhcnRzID0gcmVxdWlyZSgnaGlnaGNoYXJ0cycpOyBcclxucmVxdWlyZSgnaGlnaGNoYXJ0cy9tb2R1bGVzL2V4cG9ydGluZycpKEhpZ2hjaGFydHMpO1xyXG5cclxuY29uc3QgY2FyZEdlbmVyYXRvciA9IGFzeW5jIChjYXJkSW5mbykgPT4ge1xyXG4gIGNvbnN0IGJvYXJkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtYWluLWJvYXJkXCIpO1xyXG4gIGNvbnN0IHByZXZDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhcmQtY29udGFpbmVyXCIpO1xyXG4gIGNvbnN0IGNhcmRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gIGNvbnN0IHNldFN0YXRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBjb25zdCBpbWdMaW5rID0gY2FyZEluZm8uaW1hZ2VfdXJpcy5ub3JtYWw7XHJcbiAgY29uc3Qgc2V0QmFyQ2hhcnRQbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIGNvbnN0IHNldFBpZUNoYXJ0UGxhY2Vob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBjb25zdCBwaWVMb2FkaW5nSWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpXCIpO1xyXG4gIGNvbnN0IGJhckxvYWRpbmdJY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlcIik7XHJcblxyXG4gIGlmIChwcmV2Q29udGFpbmVyKSBib2FyZC5yZW1vdmVDaGlsZChwcmV2Q29udGFpbmVyKTtcclxuICBcclxuICBwaWVMb2FkaW5nSWNvbi5jbGFzc0xpc3QuYWRkKFwiZmFcIik7XHJcbiAgcGllTG9hZGluZ0ljb24uY2xhc3NMaXN0LmFkZChcImZhLXNwaW5uZXJcIik7XHJcblxyXG4gIGJhckxvYWRpbmdJY29uLmNsYXNzTGlzdC5hZGQoXCJmYVwiKTtcclxuICBiYXJMb2FkaW5nSWNvbi5jbGFzc0xpc3QuYWRkKFwiZmEtc3Bpbm5lclwiKTtcclxuXHJcbiAgc2V0U3RhdENvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdzZXQtc3RhdHMtY29udGFpbmVyJyk7XHJcbiAgc2V0QmFyQ2hhcnRQbGFjZWhvbGRlci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNldC1iYXItcGhcIik7IC8vIDwtLS0gVEFSR0VUIFRPIFJFUExBQ0UgVEhFIEJBUkNIQVJUXHJcbiAgc2V0UGllQ2hhcnRQbGFjZWhvbGRlci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNldC1waWUtcGhcIik7IC8vIDwtLS0gVEFSR0VUIFRPIFJFUExBQ0UgVEhFIFBJRUNIQVJUXHJcblxyXG4gIHNldEJhckNoYXJ0UGxhY2Vob2xkZXIuYXBwZW5kKGJhckxvYWRpbmdJY29uKTtcclxuICBzZXRQaWVDaGFydFBsYWNlaG9sZGVyLmFwcGVuZChwaWVMb2FkaW5nSWNvbik7XHJcblxyXG4gIGJvYXJkLmFwcGVuZChjYXJkQ29udGFpbmVyKTtcclxuXHJcbiAgc2V0U3RhdENvbnRhaW5lci5hcHBlbmQoc2V0QmFyQ2hhcnRQbGFjZWhvbGRlcik7XHJcbiAgc2V0U3RhdENvbnRhaW5lci5hcHBlbmQoc2V0UGllQ2hhcnRQbGFjZWhvbGRlcik7XHJcblxyXG4gIGNhcmRDb250YWluZXIuYXBwZW5kKGltZ0NyZWF0b3IoaW1nTGluaykpO1xyXG4gIGNhcmRDb250YWluZXIuYXBwZW5kKHN0YXRCbG9ja0NyZWF0b3IoY2FyZEluZm8pKTtcclxuICBjYXJkQ29udGFpbmVyLmFwcGVuZChzZXRTdGF0Q29udGFpbmVyKTtcclxuICBjYXJkQ29udGFpbmVyLnNldEF0dHJpYnV0ZShcImlkXCIsIFwiY2FyZC1jb250YWluZXJcIik7XHJcbiAgY2FyZENvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiY2FyZC1jb250YWluZXJcIik7XHJcblxyXG4gIHNldEZldGNoZXIoY2FyZEluZm8pXHJcbiAgICAudGhlbihjYXJkU2V0ID0+IHNldFN0YXRzQ3JlYXRvcihjYXJkSW5mbywgY2FyZFNldCkpXHJcbn1cclxuXHJcbmNvbnN0IGltZ0NyZWF0b3IgPSBpbWdMaW5rID0+IHtcclxuICBjb25zdCBpbWdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gIGltZ0NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaW1hZ2UtY29udGFpbmVyXCIpO1xyXG4gIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XHJcbiAgaW1nLnNldEF0dHJpYnV0ZShcInNyY1wiLCBpbWdMaW5rKTtcclxuICBpbWdDb250YWluZXIuYXBwZW5kKGltZyk7XHJcblxyXG4gIHJldHVybiBpbWdDb250YWluZXI7XHJcbn1cclxuXHJcbmNvbnN0IHN0YXRCbG9ja0NyZWF0b3IgPSAoY2FyZEluZm8pID0+IHtcclxuICBjb25zdCB7IFxyXG4gICAgbmFtZSwgXHJcbiAgICBtYW5hX2Nvc3QsIFxyXG4gICAgcmFyaXR5LCBcclxuICAgIG9yYWNsZV90ZXh0LCBcclxuICAgIHNldF9uYW1lLCBcclxuICAgIHR5cGVfbGluZSwgXHJcbiAgICBmbGF2b3JfdGV4dCBcclxuICB9ID0gY2FyZEluZm87XHJcblxyXG4gIGNvbnN0IHN0YXRCbG9ja0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiKTtcclxuICBzdGF0QmxvY2tDb250YWluZXIuY2xhc3NMaXN0LmFkZChcInN0YXQtYmxvY2stY29udGFpbmVyXCIpO1xyXG5cclxuICBjb25zdCBjYXJkVGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIilcclxuICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoMlwiKVxyXG4gIGNvbnN0IGNhcmRDb3N0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuXHJcbiAgY2FyZENvc3QuYXBwZW5kKG1hbmFJbWFnZUdlbmVyYXRvcihtYW5hX2Nvc3QpKTtcclxuXHJcbiAgdGl0bGUuaW5uZXJIVE1MID0gbmFtZTtcclxuICBjYXJkVGl0bGUuYXBwZW5kKHRpdGxlKVxyXG4gIGNhcmRUaXRsZS5hcHBlbmQoY2FyZENvc3QpO1xyXG4gIGNhcmRUaXRsZS5jbGFzc0xpc3QuYWRkKFwiY2FyZC10aXRsZS1jb250YWluZXJcIik7XHJcbiAgc3RhdEJsb2NrQ29udGFpbmVyLmFwcGVuZChjYXJkVGl0bGUpO1xyXG5cclxuXHJcbiAgLy8gU0VUIFRIRSBMSVNUIFZBTFVFUyBGT1IgVEhFIENBUkRcclxuICBjb25zdCBociA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoclwiKTtcclxuICBzdGF0QmxvY2tDb250YWluZXIuYXBwZW5kKGhyKTtcclxuXHJcbiAgY29uc3QgY2FyZFR5cGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIik7XHJcbiAgY2FyZFR5cGUuaW5uZXJIVE1MID0gdHlwZV9saW5lO1xyXG4gIHN0YXRCbG9ja0NvbnRhaW5lci5hcHBlbmQoY2FyZFR5cGUpO1xyXG5cclxuICBjb25zdCBjYXJkU2V0TmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcclxuICBjYXJkU2V0TmFtZS5pbm5lckhUTUwgPSBzZXRfbmFtZTtcclxuICBzdGF0QmxvY2tDb250YWluZXIuYXBwZW5kKGNhcmRTZXROYW1lKTtcclxuXHJcbiAgY29uc3QgY2FyZFJhcml0eSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcclxuICBjYXJkUmFyaXR5LmlubmVySFRNTCA9IGNhcGl0YWxpemUocmFyaXR5KTtcclxuICBzdGF0QmxvY2tDb250YWluZXIuYXBwZW5kKGNhcmRSYXJpdHkpO1xyXG5cclxuICAvLyBjb25zdCBjYXJkT3JhY2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpO1xyXG4gIC8vIGNhcmRPcmFjbGUuaW5uZXJIVE1MID0gb3JhY2xlX3RleHQ7XHJcbiAgLy8gc3RhdEJsb2NrQ29udGFpbmVyLmFwcGVuZChjYXJkT3JhY2xlKTtcclxuXHJcbiAgb3JhY2xlVGV4dEhhbmRsZXIob3JhY2xlX3RleHQsIHN0YXRCbG9ja0NvbnRhaW5lcik7IC8vPC0tLSBUaGlzIGlzIHRoZSBuZXcgdGVzdGluZyBzY3JpcHQgLS0tLS0tXHJcblxyXG4gIGlmIChmbGF2b3JfdGV4dCl7XHJcbiAgICBjb25zdCBjYXJkRmxhdm9yVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcclxuICAgIGNhcmRGbGF2b3JUZXh0LmlubmVySFRNTCA9IGZsYXZvcl90ZXh0O1xyXG4gICAgc3RhdEJsb2NrQ29udGFpbmVyLmFwcGVuZChjYXJkRmxhdm9yVGV4dCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RhdEJsb2NrQ29udGFpbmVyO1xyXG59XHJcblxyXG5jb25zdCBzZXRTdGF0c0NyZWF0b3IgPSAoY2FyZEluZm8sIGNhcmRTZXQpID0+IHtcclxuICAvLyBjb25zb2xlLmxvZyhjYXJkU2V0KTtcclxuICB0eXBlVG90YWxzKGNhcmRTZXQpLnRoZW4odG90YWxCcmVha2Rvd24gPT4ge1xyXG4gICAgLy8gY29uc29sZS5sb2codG90YWxCcmVha2Rvd24pO1xyXG4gICAgY29uc3QgdHlwZUNoYXJ0ID0gSGlnaGNoYXJ0cy5jaGFydChcInNldC1waWUtcGhcIiwge1xyXG4gICAgICBjaGFydDoge1xyXG4gICAgICAgIHBsb3RCYWNrZ3JvdW5kQ29sb3I6IG51bGwsXHJcbiAgICAgICAgcGxvdEJvcmRlcldpZHRoOiBudWxsLFxyXG4gICAgICAgIHBsb3RTaGFkb3c6IGZhbHNlLFxyXG4gICAgICAgIHR5cGU6ICdwaWUnXHJcbiAgICAgIH0sXHJcbiAgICAgIHRpdGxlOiB7XHJcbiAgICAgICAgdGV4dDogYENhcmQgVHlwZXMgKCR7Y2FyZEluZm8uc2V0X25hbWV9KWAsXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgIFwiZm9udC1mYW1pbHlcIjogXCIkdGl0bGUtZm9udFwiLFxyXG4gICAgICAgICAgXCJmb250LXNpemVcIjogXCIxcmVtXCJcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHRvb2x0aXA6IHtcclxuICAgICAgICBwb2ludEZvcm1hdDogJ3tzZXJpZXMubmFtZX06IHtwb2ludC5wZXJjZW50YWdlOi4xZn0lJyxcclxuICAgICAgICBmb290ZXJGb3JtYXQ6ICdcXG4gKHtwb2ludC55fSknXHJcbiAgICAgIH0sXHJcbiAgICAgIGFjY2Vzc2liaWxpdHk6IHtcclxuICAgICAgICBwb2ludDoge1xyXG4gICAgICAgICAgdmFsdWVTdWZmaXg6ICclJ1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgcGxvdE9wdGlvbnM6IHtcclxuICAgICAgICBwaWU6IHtcclxuICAgICAgICAgIGFsbG93UG9pbnRTZWxlY3Q6IHRydWUsXHJcbiAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcclxuICAgICAgICAgIGRhdGFMYWJlbHM6IHtcclxuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICAgICAgZm9ybWF0OiAne3BvaW50Lm5hbWV9JyxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICBmb250V2VpZ2h0OiA0MDAsXHJcbiAgICAgICAgICAgICAgZm9udEZhbWlseTogXCIkYm9keS1mb250XCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgc2VyaWVzOiBbe1xyXG4gICAgICAgIG5hbWU6ICdUeXBlcycsXHJcbiAgICAgICAgY29sb3JCeVBvaW50OiB0cnVlLFxyXG4gICAgICAgIGRhdGE6IE9iamVjdC5lbnRyaWVzKHRvdGFsQnJlYWtkb3duLnR5cGVzKS5zb3J0KChhLGIpID0+IGFbMV0gLSBiWzFdKS5yZXZlcnNlKCkubWFwKHBhaXIgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIHtuYW1lOiBwYWlyWzBdLCB5OiBwYWlyWzFdfVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1dXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB2YWx1ZUNoYXJ0ID0gSGlnaGNoYXJ0cy5jaGFydChcInNldC1iYXItcGhcIiwge1xyXG4gICAgICBjaGFydDoge1xyXG4gICAgICAgIHR5cGU6ICdjb2x1bW4nXHJcbiAgICB9LFxyXG4gICAgdGl0bGU6IHtcclxuICAgICAgICB0ZXh0OiBgTW9zdCBWYWx1ZWQgKCR7Y2FyZEluZm8uc2V0X25hbWV9KWAsXHJcbiAgICAgICAgc3R5bGU6IHsgXHJcbiAgICAgICAgICBcImZvbnQtZmFtaWx5XCI6IFwiJHRpdGxlLWZvbnRcIixcclxuICAgICAgICAgIFwiZm9udC1zaXplXCI6IFwiMXJlbVwiXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHhBeGlzOiB7XHJcbiAgICAgICAgY2F0ZWdvcmllczogdG90YWxCcmVha2Rvd24ubm9uUHJvbW9Ub3BUZW4ubWFwKGNhcmQgPT4gY2FyZC5uYW1lKSxcclxuICAgICAgICBjcm9zc2hhaXI6IHRydWUsXHJcbiAgICAgICAgbGFiZWxzOiB7IGVuYWJsZWQ6IGZhbHNlIH1cclxuICAgIH0sXHJcbiAgICB5QXhpczoge1xyXG4gICAgICAgIG1pbjogMCxcclxuICAgICAgICB0aXRsZToge1xyXG4gICAgICAgICAgICB0ZXh0OiAnVVNEJyxcclxuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIG9wcG9zaXRlOiB0cnVlXHJcbiAgICB9LFxyXG4gICAgdG9vbHRpcDoge1xyXG4gICAgICAgIGhlYWRlckZvcm1hdDogJzxzcGFuIHN0eWxlPVwiZm9udC1zaXplOjEwcHhcIj57cG9pbnQua2V5fTwvc3Bhbj48dGFibGU+JyxcclxuICAgICAgICBwb2ludEZvcm1hdDogJzx0cj48dGQgc3R5bGU9XCJjb2xvcjp7c2VyaWVzLmNvbG9yfTtwYWRkaW5nOjBcIj57c2VyaWVzLm5hbWV9OiA8L3RkPicgK1xyXG4gICAgICAgICAgICAnPHRkIHN0eWxlPVwicGFkZGluZzowXCI+PGI+JHtwb2ludC55Oi4xZn08L2I+PC90ZD48L3RyPicsXHJcbiAgICAgICAgZm9vdGVyRm9ybWF0OiAnPC90YWJsZT4nLFxyXG4gICAgICAgIHNoYXJlZDogdHJ1ZSxcclxuICAgICAgICB1c2VIVE1MOiB0cnVlXHJcbiAgICB9LFxyXG4gICAgcGxvdE9wdGlvbnM6IHtcclxuICAgICAgICBjb2x1bW46IHtcclxuICAgICAgICAgICAgcG9pbnRQYWRkaW5nOiAwLjIsXHJcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAwXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHNlcmllczogW3tcclxuICAgICAgICBuYW1lOiAnVmFsdWUnLFxyXG4gICAgICAgIGNvbG9yQnlQb2ludDogdHJ1ZSxcclxuICAgICAgICBkYXRhOiB0b3RhbEJyZWFrZG93bi5ub25Qcm9tb1RvcFRlbi5tYXAoY2FyZCA9PiBwYXJzZUZsb2F0KGNhcmQucHJpY2VzLnVzZCkpLFxyXG4gICAgICAgIHNob3dJbkxlZ2VuZDogZmFsc2VcclxuICAgIH1dXHJcbiAgICB9KTtcclxuICB9KVxyXG59XHJcblxyXG5jb25zdCBjYXBpdGFsaXplID0gc3RyID0+e1xyXG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNhcmRHZW5lcmF0b3I7IiwiZXhwb3J0IGxldCBjYXJkO1xyXG5pbXBvcnQgJ2JhYmVsLXBvbHlmaWxsJztcclxuXHJcbmV4cG9ydCBjb25zdCBjYXJkU2VhcmNoZXIgPSBhc3luYyAoZSkgPT4ge1xyXG4gIGNvbnN0IGlucHV0U3RyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZWFyY2hiYXJcIikudmFsdWU7XHJcbiAgY29uc3QgdXJsID0gJ2h0dHBzOi8vYXBpLnNjcnlmYWxsLmNvbS9jYXJkcy9uYW1lZD9mdXp6eT0nO1xyXG4gIGNvbnN0IHNlYXJjaFVybCA9IHVybCArIHZhbGlkU2VhcmNoSW5wdXQoaW5wdXRTdHIpO1xyXG4gIGNvbnN0IGVycm9yVGFyZ2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJlcnJvcnMtY29udGFpbmVyXCIpXHJcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChzZWFyY2hVcmwpO1xyXG4gIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gIGVycm9yVGFyZ2V0LmlubmVySFRNTCA9ICcnXHJcbiAgY2FyZCA9IGF3YWl0IGpzb247XHJcblxyXG4gIGlmIChjYXJkLm9iamVjdCA9PT0gXCJlcnJvclwiKSB7XHJcbiAgICAvL21ha2UgZXJyb3IgYW5kIGFwcGVuZCB0byBib2FyZC5pbnB1dFxyXG4gICAgY29uc3QgZXJyb3JCYW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGNvbnN0IGVycm9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKVxyXG4gICAgY29uc3QgYm9hcmQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiYm9hcmRcIilbMF07XHJcblxyXG4gICAgYm9hcmQuc3R5bGUubWFyZ2luID0gXCI1cmVtXCI7XHJcblxyXG4gICAgZXJyb3JCYW5uZXIuc2V0QXR0cmlidXRlKCdpZCcsIFwiZXJyb3Itc3ViXCIpXHJcbiAgICBlcnJvci5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2Vycm9yLW1lc3NhZ2UnKVxyXG5cclxuICAgIGVycm9yLmlubmVySFRNTCA9IGNhcmQuZGV0YWlscztcclxuICAgIGVycm9yQmFubmVyLmFwcGVuZChlcnJvcik7XHJcbiAgICBlcnJvclRhcmdldC5hcHBlbmQoZXJyb3JCYW5uZXIpXHJcblxyXG4gICAgcmV0dXJuO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zb2xlLmxvZyhjYXJkKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNhcmQ7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB2YWxpZFNlYXJjaElucHV0ID0gc2VhcmNoSW5wdXQgPT4gKCBzZWFyY2hJbnB1dC5zcGxpdCgnICcpLmpvaW4oXCItXCIpIClcclxuIiwiXG5cbmV4cG9ydCBjb25zdCBtYW5hSW1hZ2VHZW5lcmF0b3IgPSBtYW5hU3RyID0+IHtcbiAgICBsZXQgcmVzdWx0cyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJlc3VsdHMuY2xhc3NMaXN0LmFkZChcIm1hbmEtc3ltYm9sLWNvbnRhaW5lclwiKTtcblxuICAgIGlmICghbWFuYVN0cikgcmV0dXJuIHJlc3VsdHM7XG5cbiAgICBsZXQgc3ViU3RyID0gJyc7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hbmFTdHIubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBsZXR0ZXIgPSBtYW5hU3RyW2ldO1xuXG4gICAgICAgIGlmIChsZXR0ZXIgPT09ICd7Jyl7XG4gICAgICAgICAgICBzdWJTdHIgPSAnJztcbiAgICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09ICd9Jyl7XG4gICAgICAgICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZShcInNyY1wiLCBgaHR0cHM6Ly9pbWcuc2NyeWZhbGwuY29tL3N5bWJvbG9neS8ke3N1YlN0cn0uc3ZnYCk7XG5cbiAgICAgICAgICAgIHJlc3VsdHMuYXBwZW5kKGltZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJTdHIgPSBzdWJTdHIgKyBsZXR0ZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGNvbnN0IG9yYWNsZVRleHRIYW5kbGVyID0gKHRleHRTdHIsIHBhcmVudENvbikgPT4ge1xuICAgIGNvbnN0IGNvbGxlY3Rpb24gPSBbXTtcbiAgICBsZXQgc3ViU3RyID0gJyc7XG4gICAgLy8gY29uc29sZS5sb2codGV4dFN0cik7XG5cbiAgICBsZXQgdGVzdEFyciA9IHRleHRTdHIuc3BsaXQoXCJcXG5cIik7XG4gICAgY29uc29sZS5sb2codGVzdEFyci5sZW5ndGgpXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHRTdHIubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBjaGFyID0gdGV4dFN0cltpXTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coY2hhcik7XG5cbiAgICAgICAgaWYgKGNoYXIgPT09ICfihrUnKXtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ucHVzaChzdWJTdHIpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coc3ViU3RyKTtcblxuICAgICAgICAgICAgc3ViU3RyID0gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJTdHIgKz0gY2hhcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbGxlY3Rpb24ucHVzaChzdWJTdHIpO1xuXG4gICAgY29sbGVjdGlvbi5mb3JFYWNoKHN1YlN0ciA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0xpc3RJdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgbmV3TGlzdEl0ZW0uaW5uZXJIVE1MID0gc3ViU3RyO1xuICAgICAgICBwYXJlbnRDb24uYXBwZW5kKG5ld0xpc3RJdGVtKTtcbiAgICB9KVxufVxuXG4iLCJpbXBvcnQgJ2JhYmVsLXBvbHlmaWxsJztcclxuXHJcbmV4cG9ydCBjb25zdCBzZXRGZXRjaGVyID0gYXN5bmMgKGNhcmRJbmZvKSA9PiB7XHJcbiAgICBjb25zdCBzZWFyY2hVcmwgPSBgaHR0cHM6Ly9hcGkuc2NyeWZhbGwuY29tL2NhcmRzL3NlYXJjaD9vcmRlcj11c2QmcT1lJTNBJHtjYXJkSW5mby5zZXR9JnVuaXF1ZT1wcmludHNgO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChzZWFyY2hVcmwpO1xyXG4gICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICBpZiAoanNvbi5oYXNfbW9yZSl7XHJcbiAgICAgIGNvbnN0IG5leHRVcmwgPSBqc29uLm5leHRfcGFnZTtcclxuICAgICAgY29uc3QgbmV4dFJlc3BvbnNlID0gYXdhaXQgZmV0Y2gobmV4dFVybCk7XHJcbiAgICAgIGNvbnN0IG5leHRKc29uID0gYXdhaXQgbmV4dFJlc3BvbnNlLmpzb24oKTtcclxuICBcclxuICAgICAgaWYgKG5leHRKc29uLmhhc19tb3JlKXtcclxuICAgICAgICBjb25zdCBmaW5hbFVybCA9IG5leHRKc29uLm5leHRfcGFnZTtcclxuICAgICAgICBjb25zdCBmaW5hbFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZmluYWxVcmwpO1xyXG4gICAgICAgIGNvbnN0IGZpbmFsSnNvbiA9IGF3YWl0IGZpbmFsUmVzcG9uc2UuanNvbigpXHJcblxyXG4gICAgICAgIHJldHVybiBzZXRNZXJnZShbanNvbiwgbmV4dEpzb24sIGZpbmFsSnNvbl0pXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIHJldHVybiBzZXRNZXJnZShbanNvbiwgbmV4dEpzb25dKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgIHJldHVybiBhd2FpdCBqc29uO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3Qgc2V0TWVyZ2UgPSBhc3luYyAoYXJyT2ZTZXRzKSA9PiB7XHJcbiAgbGV0IGJhc2VTZXQgPSBhcnJPZlNldHNbMF07XHJcblxyXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJyT2ZTZXRzLmxlbmd0aDsgaSsrKXtcclxuICAgIGNvbnN0IG1lcmdpbmdTZXQgPSBhcnJPZlNldHNbaV07XHJcbiAgICBiYXNlU2V0LmRhdGEgPSBiYXNlU2V0LmRhdGEuY29uY2F0KG1lcmdpbmdTZXQuZGF0YSlcclxuICB9XHJcblxyXG4gIHJldHVybiBiYXNlU2V0O1xyXG59XHJcblxyXG5cclxuIiwiaW1wb3J0ICdiYWJlbC1wb2x5ZmlsbCc7XG5cbmV4cG9ydCBjb25zdCB0eXBlVG90YWxzID0gYXN5bmMgc2V0ID0+IHtcbiAgICAvLyByZXR1cm4gb2JqIHdpdGggYWxsIHR5cGVzIGFzIGtleXMgZXhjZXB0IGJhc2ljIGxhbmRzXG4gICAgY29uc3QgTVRHQ0FSRFRZUEVTID0gWydBcnRpZmFjdCcsICdDcmVhdHVyZScsICdFbmNoYW50bWVudCcsICdJbnN0YW50JywgJ0xhbmQnLCAnUGxhbmVzd2Fsa2VyJywgJ1NvcmNlcnknLCAnVHJpYmFsJ107XG4gICAgY29uc3QgY2FyZHMgPSBzZXQuZGF0YTtcbiAgICBjb25zdCBzdGF0cyA9IHsgXG4gICAgICAgIG5vbkJhc2ljc1RvdGFsOiAwLCBcbiAgICAgICAgdG90YWxTZXRWYWx1ZTogMCxcbiAgICAgICAgbm9uUHJvbW9Ub3BUZW46IFtdLFxuICAgICAgICB0b3RhbFNldFZhbHVlQXZlcmFnZTogMCxcbiAgICAgICAgdHlwZXM6IHt9LFxuICAgICAgICBzdWJUeXBlczoge31cbiAgICB9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYXJkcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IGNhcmQgPSBjYXJkc1tpXTtcbiAgICAgICAgbGV0IGN1cnJlbnRDYXJkVHlwZXM7XG4gICAgICAgIC8vIFJFTU9WRSBQUk9NTyBDQVJEUyBGUk9NIFRIRSBQT09MIEJFQ0FVU0UgVEhFWSdSRSBEVVBFU1xuICAgICAgICBpZiAoY2FyZC5wcm9tbyl7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRDYXJkVHlwZXMgPSB0eXBlTGluZVBhcnNlcihjYXJkLnR5cGVfbGluZSk7IC8vIDwtLSBcblxuICAgICAgICBpZiAoY3VycmVudENhcmRUeXBlcy5pbmNsdWRlcygnQmFzaWMnKSl7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNhcmRWYWx1ZSA9ICh0eXBlb2YgY2FyZC5wcmljZXMudXNkID09PSBcInVuZGVmaW5lZFwiIHx8IGNhcmQucHJpY2VzLnVzZCA9PT0gbnVsbCkgPyAwIDogcGFyc2VGbG9hdChjYXJkLnByaWNlcy51c2QpXG4gICAgICAgICAgICBjdXJyZW50Q2FyZFR5cGVzLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKE1UR0NBUkRUWVBFUy5pbmNsdWRlcyh0eXBlKSAmJiB0eXBlb2Ygc3RhdHMudHlwZXNbdHlwZV0gPT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMudHlwZXNbdHlwZV0gPSAxXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNVEdDQVJEVFlQRVMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMudHlwZXNbdHlwZV0gKz0gMVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIU1UR0NBUkRUWVBFUy5pbmNsdWRlcyh0eXBlKSAmJiB0eXBlb2Ygc3RhdHMuc3ViVHlwZXNbdHlwZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLnN1YlR5cGVzW3R5cGVdID0gMVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLnN1YlR5cGVzW3R5cGVdICs9IDFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0YXRzLm5vbkJhc2ljc1RvdGFsICs9IDE7XG4gICAgICAgICAgICBzdGF0cy50b3RhbFNldFZhbHVlICs9IGNhcmRWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKHN0YXRzLm5vblByb21vVG9wVGVuLmxlbmd0aCA8IDEwKXtcbiAgICAgICAgICAgICAgICBzdGF0cy5ub25Qcm9tb1RvcFRlbi5wdXNoKGNhcmQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0cy5ub25Qcm9tb1RvcFRlblZhbHVlQXZlcmFnZSA9IGNhcmRBdmVyYWdlcihzdGF0cy5ub25Qcm9tb1RvcFRlbik7XG4gICAgc3RhdHMudG90YWxTZXRWYWx1ZUF2ZXJhZ2UgPSBzdGF0cy50b3RhbFNldFZhbHVlIC8gc3RhdHMubm9uQmFzaWNzVG90YWw7XG5cbiAgICByZXR1cm4gc3RhdHNcbn1cblxuY29uc3QgY2FyZEF2ZXJhZ2VyID0gY2FyZEFyciA9PiB7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBjYXJkQXJyLmZvckVhY2goY2FyZCA9PiB0b3RhbCArPSBwYXJzZUZsb2F0KGNhcmQucHJpY2VzLnVzZCkpXG4gICAgcmV0dXJuIHRvdGFsIC8gY2FyZEFyci5sZW5ndGg7XG59XG5cbmNvbnN0IHR5cGVMaW5lUGFyc2VyID0gdHlwZUxpbmVTdHIgPT4ge1xuICAgIGNvbnN0IHR5cGVBcnIgPSB0eXBlTGluZVN0ci5zcGxpdCgnICcpXG4gICAgcmV0dXJuIHR5cGVBcnIuZmlsdGVyKHR5cGUgPT4gdHlwZS5sZW5ndGggPiAyKVxufVxuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==